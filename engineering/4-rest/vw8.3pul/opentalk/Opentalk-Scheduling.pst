<?xml version="1.0"?><st-source><!-- Name: Opentalk-SchedulingNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Opentalk-Scheduling defines a scheduler and scheduler policies for use alongside request brokers when user applications elect to take explicit control of worker process scheduling.Copyright: Copyright © 2004-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 496345DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#package 'Opentalk-Core' ''))PackageName: Opentalk-SchedulingParcel: #('Opentalk-Scheduling')ParcelName: Opentalk-SchedulingPrerequisiteParcels: #(#('Opentalk-Core' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:30:44 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:44 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OtEScheduling</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.OtEScheduling</class-id><body>OtEScheduling is the class of errors in the Opentalk scheduling machinery.</body></comment><class><name>SchedulingPolicyConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.SchedulingPolicyConfiguration</class-id><body>SchedulingPolicyConfiguration is the abstract superclass of configurations for scheduling policies.</body></comment><class><name>LotterySchedulingPolicyConfiguration</name><environment>Opentalk</environment><super>Opentalk.SchedulingPolicyConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newMultiplier oldMultiplier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.LotterySchedulingPolicyConfiguration</class-id><body>A LotterySchedulingPolicyConfiguration is used to configure a LotterySchedulingPolicy.Instance Variables:	newMultiplier		&lt;Integer&gt;					the multiplier for 'new' processes	oldMultiplier			&lt;Integer&gt;					the multiplier for 'old' processes</body></comment><class><name>SchedulingPolicy</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.SchedulingPolicy</class-id><body>SchedulingPolicy is the abstract superclass of concrete scheduling policies for priority level schedulers.Subclasses must implement the following messages:	scheduling		scheduleAt:Instance Variables:	configuration	&lt;SchedulingPolicyConfiguration&gt;		the configuration of the policy</body></comment><class><name>LotterySchedulingPolicy</name><environment>Opentalk</environment><super>Opentalk.SchedulingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newMultiplier oldMultiplier random scheduledDictionary </inst-vars><class-inst-vars>defaultNewMultiplier defaultOldMultiplier </class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.LotterySchedulingPolicy</class-id><body>A LotterySchedulingPolicy assigns lottery tickets to all the process on the target quiescent process list, randomly picks a winning ticket, and them moves the process witht he winning ticket to the head of the list.  The number of tickets assigned to 'old' processes (those that have been seen at the head of the list at least once) and 'new' processes (those that have not yet been seen at the head of the list) may be changed using the 'multipliers'.Instance Variables:	newMultiplier		&lt;Integer&gt;						the multiplier for 'new' processes	oldMultiplier			&lt;Integer&gt;						the multiplier for 'old' processes	random				&lt;Random&gt;						the Random used to draw the winning ticket	scheduledDictionary	&lt;OtWeakKeyDictionary&gt;		the dictionary of 'old' processesClass Instance Variables:	defaultNewMultiplier	&lt;Integer | UndefinedObject&gt;		default multiplier for 'new' processes	defaultOldMultiplier	&lt;Integer | UndefinedObject&gt;		default multiplier for 'old' processes</body></comment><class><name>PriorityLevelSchedulerConfiguration</name><environment>Opentalk</environment><super>Opentalk.RestartProtocolConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lowerThreshold scheduledPriority schedulingInterval schedulingPolicy schedulingPriority </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.PriorityLevelSchedulerConfiguration</class-id><body>A PriorityLevelSchedulerConfiguration is used to configure and create a PriorityLevelScheduler.Instance Variables:	lowerThreshold		&lt;Integer&gt;			the number of processes, at the target priority level, required to initiaite scheduling activity	scheduledPriority	&lt;Integer&gt;			the process priority level being scheduled	schedulingInterval	&lt;Integer&gt;			the millisecond wait in the scheduling process	schedulingPolicy	&lt;SchedulingPolicy&gt;	the policy regulating the scheduling	schedulingPriority	&lt;Integer&gt;			the priority of the higher-level scheduling process</body></comment><class><name>PriorityLevelScheduler</name><environment>Opentalk</environment><super>Opentalk.RestartProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lowerThreshold scheduledPriority schedulingInterval schedulingPolicy schedulingPriority schedulingProcess </inst-vars><class-inst-vars>defaultLowerThreshold defaultScheduledPriority defaultSchedulingInterval defaultSchedulingPriority schedulerDictionary </class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.PriorityLevelScheduler</class-id><body>A PriorityLevelScheduler takes over the scheduling of processes at a designated priority in the lists of quiescent processes.Instance Variables:	lowerThreshold			&lt;Integer&gt;							the number of processes, at the target priority level, required to initiaite scheduling activity	scheduledPriority		&lt;Integer&gt;							the process priority level being scheduled	schedulingInterval		&lt;Integer&gt;							the millisecond wait in the scheduling process	schedulingPolicy		&lt;SchedulingPolicy&gt;					the policy regulating the scheduling	schedulingPriority		&lt;Integer&gt;							the priority of the higher-level scheduling process	schedulingProcess		&lt;Process&gt;							the scheduling processClass Instance Variables:	defaultLowerThreshold	&lt;Integer | UndefinedObject&gt;			default lower threshold	defaultScheduledPriority	&lt;Integer | UndefinedObject&gt;			default scheduled priority level	defaultSchedulingInterval	&lt;Integer | UndefinedObject&gt;			default millisecond wait	defaultSchedulingPriority	&lt;Integer | UndefinedObject&gt;			default scheduling process priority	schedulerDictionary		&lt;Dictionary | UndefinedObject&gt;		scheduler instance store</body></comment><class><name>CyclicSchedulingPolicy</name><environment>Opentalk</environment><super>Opentalk.SchedulingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.CyclicSchedulingPolicy</class-id><body>CyclicSchedulingPolicy implementes the simplest possible scheduling algorithm.  It rotates the target priority process list.  This is the simplest and most generally useful approach to scheduling.  It has one drawback.  If a request stream is highly bi-modal, containing a nearly balanced mix of nearly coeval short-running (e.g., ten 10 ms processes) and long-running processes (e.g., ten 1000 ms), and the set 'schedulingInterval' falls between the two modal values (e.g., at 55 ms), then though the coeval short-running processes will finish before the coeval long-running ones, the long-running ones will tend to finish together at a time approaching the sum of all the nearly coeval execution times involved (e.g., after (10 * 10) + (10 * 1000) ms).</body></comment><class><name>CyclicSchedulingPolicyConfiguration</name><environment>Opentalk</environment><super>Opentalk.SchedulingPolicyConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Scheduling</category><attributes><package>Opentalk-Scheduling</package></attributes></class><comment><class-id>Opentalk.CyclicSchedulingPolicyConfiguration</class-id><body>A CyclicSchedulingPolicyConfiguration is used to configure and create a CyclicSchedulingPolicy.</body></comment><methods><class-id>Opentalk.SchedulingPolicyConfiguration class</class-id> <category>types</category><body package="Opentalk-Scheduling">cyclic	^CyclicSchedulingPolicyConfiguration new</body><body package="Opentalk-Scheduling">lottery	^LotterySchedulingPolicyConfiguration new</body></methods><methods><class-id>Opentalk.LotterySchedulingPolicyConfiguration</class-id> <category>accessing</category><body package="Opentalk-Scheduling">componentClass	^LotterySchedulingPolicy</body><body package="Opentalk-Scheduling">newMultiplier	^newMultiplier</body><body package="Opentalk-Scheduling">newMultiplier: anInteger	newMultiplier := anInteger</body><body package="Opentalk-Scheduling">oldMultiplier	^oldMultiplier</body><body package="Opentalk-Scheduling">oldMultiplier: anInteger	oldMultiplier := anInteger</body></methods><methods><class-id>Opentalk.SchedulingPolicy</class-id> <category>initialize-release</category><body package="Opentalk-Scheduling">initialize	"... intentionally null."</body><body package="Opentalk-Scheduling">initialize: aConfiguration	configuration := aConfiguration.</body></methods><methods><class-id>Opentalk.SchedulingPolicy</class-id> <category>scheduling</category><body package="Opentalk-Scheduling">scheduleAt: anInteger	self subclassResponsibility</body></methods><methods><class-id>Opentalk.SchedulingPolicy class</class-id> <category>instance creation</category><body package="Opentalk-Scheduling">new	^super new initialize</body><body package="Opentalk-Scheduling">new: aConfiguration	^self new initialize: aConfiguration</body></methods><methods><class-id>Opentalk.LotterySchedulingPolicy</class-id> <category>initialize-release</category><body package="Opentalk-Scheduling">initialize	super initialize.	random := MinimumStandardRandom new.	scheduledDictionary := OtWeakKeyDictionary new: 29.</body></methods><methods><class-id>Opentalk.LotterySchedulingPolicy</class-id> <category>accessing</category><body package="Opentalk-Scheduling">newMultiplier	"... the factor that multipliess the number of lottery tickets possessed by hitherto unscheduled processes."	^newMultiplier ifNil: [ newMultiplier := configuration newMultiplier ifNil: [ self class defaultNewMultiplier ] ]</body><body package="Opentalk-Scheduling">oldMultiplier	"... the factor that multipliess the number of lottery tickets possessed by formerly scheduled processes."	^oldMultiplier ifNil: [ oldMultiplier := configuration oldMultiplier ifNil: [ self class defaultOldMultiplier ] ]</body><body package="Opentalk-Scheduling">random	^random</body><body package="Opentalk-Scheduling">scheduledDictionary	^scheduledDictionary</body></methods><methods><class-id>Opentalk.LotterySchedulingPolicy</class-id> <category>scheduling</category><body package="Opentalk-Scheduling">processWithTicket: anInteger inList: aList	| min max keys |	min := max := 0.	keys := scheduledDictionary keys.	aList do:		[ :p |	min := max.				( keys includes: p )					ifTrue: 	[ max := max + ( self oldMultiplier * ( scheduledDictionary at: p ) ) ] 					ifFalse:	[ max := max + ( self newMultiplier ) ].				( anInteger &lt;= max )					ifTrue:	[ ^p ].		].	^nil</body><body package="Opentalk-Scheduling">scheduleAt: anInteger	"... assumes the first quiescent process will be preempted and adds it to the preempted dictionary; calculates the number of lottery tickets in the drawing; selects a ticket; then moves the process with the winning ticket to the head of the process list being scheduled."	| lst cp tc wt wp |	lst := Processor quiescentProcessLists at: anInteger.	cp := lst first.	self updateScheduledAt: cp.	tc := self ticketCountFor: lst.	wt := self randomPositiveIntegerTo: tc.	wp := self processWithTicket: wt inList: lst.	( cp ~~ wp )		ifTrue:	[	lst addLast: lst removeFirst.					lst addFirst: ( lst remove: wp )				]</body><body package="Opentalk-Scheduling">ticketCountFor: aList	"... calculates the number of lottery tickets in the drawing."	| n keys |	n := 0.	keys := scheduledDictionary keys.	aList do:		[ :p | ( keys includes: p )				ifTrue: 	[ n := n + ( self oldMultiplier * ( scheduledDictionary at: p ) ) ] 				ifFalse:	[ n := n + ( self newMultiplier ) ]		].	^n</body><body package="Opentalk-Scheduling">updateScheduledAt: aProcess	( scheduledDictionary keys includes: aProcess )		ifTrue:	[ scheduledDictionary at: aProcess put: ( ( scheduledDictionary at: aProcess ) + 1 ) ]		ifFalse:	[ scheduledDictionary add: ( aProcess -&gt; 1 ) ].</body></methods><methods><class-id>Opentalk.LotterySchedulingPolicy</class-id> <category>utility</category><body package="Opentalk-Scheduling">randomPositiveIntegerTo: aPositiveInteger	^( random next * aPositiveInteger ) truncated + 1</body></methods><methods><class-id>Opentalk.LotterySchedulingPolicy class</class-id> <category>defaults</category><body package="Opentalk-Scheduling">defaultNewMultiplier	^defaultNewMultiplier ifNil: [ defaultNewMultiplier := self defaultNewMultiplierValue ]</body><body package="Opentalk-Scheduling">defaultNewMultiplier: anInteger	defaultNewMultiplier := anInteger</body><body package="Opentalk-Scheduling">defaultNewMultiplierValue	"... the factor that multiplies the number of lottery tickets possessed by hitherto unscheduled processes."	^1</body><body package="Opentalk-Scheduling">defaultOldMultiplier	^defaultOldMultiplier ifNil: [ defaultOldMultiplier := self defaultOldMultiplierValue ]</body><body package="Opentalk-Scheduling">defaultOldMultiplier: anInteger	defaultOldMultiplier := anInteger</body><body package="Opentalk-Scheduling">defaultOldMultiplierValue	"... the factor that multiplies the number of lottery tickets possessed by previously scheduled processes."	^1</body></methods><methods><class-id>Opentalk.PriorityLevelSchedulerConfiguration</class-id> <category>accessing</category><body package="Opentalk-Scheduling">componentClass	^PriorityLevelScheduler</body><body package="Opentalk-Scheduling">lowerThreshold	^lowerThreshold</body><body package="Opentalk-Scheduling">lowerThreshold: anInteger	lowerThreshold := anInteger</body><body package="Opentalk-Scheduling">scheduledPriority	^scheduledPriority</body><body package="Opentalk-Scheduling">scheduledPriority: anInteger	scheduledPriority := anInteger</body><body package="Opentalk-Scheduling">schedulingInterval	^schedulingInterval</body><body package="Opentalk-Scheduling">schedulingInterval: anInteger	schedulingInterval := anInteger</body><body package="Opentalk-Scheduling">schedulingPolicy	^schedulingPolicy</body><body package="Opentalk-Scheduling">schedulingPolicy: aConfiguration	schedulingPolicy := aConfiguration</body><body package="Opentalk-Scheduling">schedulingPriority	^schedulingPriority</body><body package="Opentalk-Scheduling">schedulingPriority: anInteger	schedulingPriority := anInteger</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler</class-id> <category>private</category><body package="Opentalk-Scheduling">doStart	super doStart.	self startSchedulingProcess</body><body package="Opentalk-Scheduling">doStop	super doStop.	self stopSchedulingProcess</body><body package="Opentalk-Scheduling">schedulingInterval: anInteger	schedulingInterval := anInteger</body><body package="Opentalk-Scheduling">schedulingPolicy: aSchedulingPolicy	schedulingPolicy := aSchedulingPolicy</body><body package="Opentalk-Scheduling">schedulingPriority: anInteger	schedulingPriority := anInteger</body><body package="Opentalk-Scheduling">startSchedulingProcess	| i | 	( schedulingProcess ~~ nil )		ifTrue:	[ ^nil ].	i := self schedulingInterval.	schedulingProcess :=		[	[ true ]				whileTrue:			[	( Delay forMilliseconds: i ) wait.				self schedulingProcessBody			]		] forkAt: self schedulingPriority</body><body package="Opentalk-Scheduling">stopSchedulingProcess	( schedulingProcess == nil )		ifTrue:	[ ^nil ].	schedulingProcess terminate.	schedulingProcess := nil</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler</class-id> <category>initialize-release</category><body package="Opentalk-Scheduling">initialize: aConfiguration	super initialize: aConfiguration.	schedulingPolicy := aConfiguration schedulingPolicy new. 	self validatePriorities.	self class		schedulerAt: self scheduledPriority		put:	self.</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler</class-id> <category>accessing</category><body package="Opentalk-Scheduling">lowerThreshold	"... the quiescent process list size threshold that must be exceeded to kick in scheduling action."	^lowerThreshold ifNil: [ lowerThreshold := configuration lowerThreshold ifNil: [ self class defaultLowerThreshold ] ]</body><body package="Opentalk-Scheduling">scheduledPriority	"... the priority of the quiescent process list being scheduled."	^scheduledPriority ifNil: [ scheduledPriority := configuration scheduledPriority ifNil: [ self class defaultScheduledPriority ] ]</body><body package="Opentalk-Scheduling">schedulingInterval	"... the interval in milliseconds between invocations of the scheduling action."	^schedulingInterval ifNil: [ schedulingInterval := configuration schedulingInterval ifNil: [ self class defaultSchedulingInterval ] ]</body><body package="Opentalk-Scheduling">schedulingPolicy	^schedulingPolicy</body><body package="Opentalk-Scheduling">schedulingPriority	"... the priority of the process doing the scheduling."	^schedulingPriority ifNil: [ schedulingPriority := configuration schedulingPriority ifNil: [ self class defaultSchedulingPriority ] ]</body><body package="Opentalk-Scheduling">schedulingProcess	^schedulingProcess</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler</class-id> <category>scheduling</category><body package="Opentalk-Scheduling">schedulingProcessBody	( ( Processor processesAt: self scheduledPriority ) &gt; self lowerThreshold )		ifTrue:	[	( self isRunning )						ifTrue: [ schedulingPolicy scheduleAt: self scheduledPriority ]				]</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler</class-id> <category>utility</category><body package="Opentalk-Scheduling">validatePriorities	( self scheduledPriority &gt;= self schedulingPriority )		ifTrue:	[ ^OtEScheduling raiseSignal: (					(#ScheduledPriority1sHigherThanSchedulingPriority2s &lt;&lt; #opentalk &gt;&gt; 'The scheduled priority, &lt;1s&gt;, must be less than the scheduling priority, &lt;2s&gt;.')						expandMacrosWith: self scheduledPriority printString						with: self schedulingPriority printString) ].</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler class</class-id> <category>defaults</category><body package="Opentalk-Scheduling">defaultLowerThreshold	^defaultLowerThreshold ifNil: [ defaultLowerThreshold := self defaultLowerThresholdValue ]</body><body package="Opentalk-Scheduling">defaultLowerThreshold: anInteger	defaultLowerThreshold := anInteger</body><body package="Opentalk-Scheduling">defaultLowerThresholdValue	"... the number of quiescent process over which scheduling will kick in."	"... the meaningful minimum."	^1</body><body package="Opentalk-Scheduling">defaultScheduledPriority	^defaultScheduledPriority ifNil: [ defaultScheduledPriority := self defaultScheduledPriorityValue ]</body><body package="Opentalk-Scheduling">defaultScheduledPriority: anInteger	defaultScheduledPriority := anInteger</body><body package="Opentalk-Scheduling">defaultScheduledPriorityValue	"... the default request broker worker priority."	^RequestDispatcher defaultWorkerPriority</body><body package="Opentalk-Scheduling">defaultSchedulingInterval	^defaultSchedulingInterval ifNil: [ defaultSchedulingInterval := self defaultSchedulingIntervalValue ]</body><body package="Opentalk-Scheduling">defaultSchedulingInterval: anInteger	defaultSchedulingInterval := anInteger</body><body package="Opentalk-Scheduling">defaultSchedulingIntervalValue	"... scheduling interval in milliseconds."	"... not based on any measures, but convenient for testing."	^331</body><body package="Opentalk-Scheduling">defaultSchedulingPriority	^defaultSchedulingPriority ifNil: [ defaultSchedulingPriority := self defaultSchedulingPriorityValue ]</body><body package="Opentalk-Scheduling">defaultSchedulingPriority: anInteger	defaultSchedulingPriority := anInteger</body><body package="Opentalk-Scheduling">defaultSchedulingPriorityValue	"... lies below the default server and listener priorities but above the default worker priority."	^71</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler class</class-id> <category>instance creation</category><body package="Opentalk-Scheduling">for: anInteger1 at: anInteger2 with: aSchedulingPolicy	| n |	n := ( self basicNew )			scheduledPriority: anInteger1;			schedulingPriority: anInteger2;			schedulingPolicy: aSchedulingPolicy.	n validatePriorities.	self		schedulerAt: anInteger1		put:	n.	^n</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler class</class-id> <category>private</category><body package="Opentalk-Scheduling">initializeSchedulerDictionary	schedulerDictionary := Dictionary new: 3</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler class</class-id> <category>scheduling</category><body package="Opentalk-Scheduling">removeAllSchedulers	self stopAllSchedulers.	self initializeSchedulerDictionary</body><body package="Opentalk-Scheduling">startAllSchedulers	self schedulers do: [ :x | x start ]</body><body package="Opentalk-Scheduling">stopAllSchedulers	self schedulers do: [ :x | x stop ]</body></methods><methods><class-id>Opentalk.PriorityLevelScheduler class</class-id> <category>accessing</category><body package="Opentalk-Scheduling">schedulerAt: anInteger	^self schedulerDictionary at: anInteger</body><body package="Opentalk-Scheduling">schedulerAt: anInteger ifAbsent: aBlockClosure	^self schedulerDictionary at: anInteger ifAbsent: aBlockClosure</body><body package="Opentalk-Scheduling">schedulerAt: anInteger put: aPriorityLevelScheduler	| s |	( ( s := self schedulerDictionary at: anInteger ifAbsent: [] ) ~~ nil )		ifTrue: [ s stop ].	^self schedulerDictionary at: anInteger put: aPriorityLevelScheduler</body><body package="Opentalk-Scheduling">schedulerDictionary	^schedulerDictionary ifNil: [ schedulerDictionary := Dictionary new: 3 ]</body><body package="Opentalk-Scheduling">schedulers	^self schedulerDictionary values</body></methods><methods><class-id>Opentalk.CyclicSchedulingPolicy</class-id> <category>scheduling</category><body package="Opentalk-Scheduling">scheduleAt: anInteger	| lst |	lst := Processor quiescentProcessLists at: anInteger.	lst addLast: lst removeFirst</body></methods><methods><class-id>Opentalk.CyclicSchedulingPolicyConfiguration</class-id> <category>accessing</category><body package="Opentalk-Scheduling">componentClass	^CyclicSchedulingPolicy</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>OtSystemException</name><environment>Opentalk</environment><super>Opentalk.OtException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Configuration</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>RestartProtocolConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>autoRestart id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>RestartProtocol</name><environment>Opentalk</environment><super>Opentalk.GenericProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration id </inst-vars><class-inst-vars>defaultComponentIdGenerator defaultAutoRestart </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class></st-source>