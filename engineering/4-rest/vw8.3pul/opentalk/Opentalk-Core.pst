<?xml version="1.0"?><st-source><!-- Name: Opentalk-CoreNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Opentalk-Core defines the core classes of the Opentalk communication framework. Included are the basic classes that implement listeners, proxies, adaptors, request brokers, and communication exceptions, as well as the classes that implement the mechanism for pass mode control.Copyright: Copyright © 1999-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 500680DbUsername: tkoganDbVersion: 8.3 - 3DevelopmentPrerequisites: #(#(#package 'Opentalk-Core-Support' ''))PackageName: Opentalk-CoreParcel: #('Opentalk-Core')ParcelName: Opentalk-CorePrerequisiteParcels: #(#('Opentalk-Core-Support' ''))PrintStringCache: (8.3 - 3,tkogan)Version: 8.3 - 3Date: 2:30:43 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:43 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OtException</name><environment>Opentalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtException</class-id><body>OtException is the superclass of all exceptions raised by the Opentalk communication layer, Opentalk services, or Opentalk components.</body></comment><class><name>OtSystemException</name><environment>Opentalk</environment><super>Opentalk.OtException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtSystemException</class-id><body>OtSystemException is the abstract superclass of all Opentalk system exceptions, as distinct from the Opentalk service exceptions.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtENoResponse</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtENoResponse</class-id><body>This exception is currently unused by the Opentalk frameworkInstance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtEMarshaling</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEMarshaling</class-id><body>An error has occurred in the attempt to marshall upon, unmarshall, write, or read an internal buffer used for linearizing an object according to a specified communication protocol. Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtEOIDNotFound</name><environment>Opentalk</environment><super>Opentalk.OtEMarshaling</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEOIDNotFound</class-id><body>This exception is signaled by an ObjectTable when it fails to find an object exported with a given ID.</body></comment><class><name>InterceptorDispatcher</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policy interceptors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-SOAP-Headers</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.InterceptorDispatcher</class-id><body>I maintain a sequence of interceptors that are invoked at each interception point in sequence. If an interceptor signals an exception that is not resumed, any following interceptors won't be invoked at that particular interception point.Instance Variables:	policy	&lt;ProcessingPolicy&gt; 	interceptors	&lt;OrderedCollection of: MessageInterceptor&gt; </body></comment><class><name>GenericProtocol</name><environment>Opentalk</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.GenericProtocol</class-id><body>GenericProtocol is the abstract superclass for all protocols in the Opentalk system.  It supports: [1] a startup and shutdown control protocol and [2] an event model to allow for the loose coupling of protocol components.Instance Variables:	state	&lt;Symbol&gt; ... the current state of the protocol, in this class either '#stopped' or '#running'Shared Class Variables:	HostAddress	&lt;ByteArray&gt; caches automatically determined (via reverse DNS lookup) address of the current host	HostName	&lt;String&gt; caches the OS provided hostname of the system	HostAddresses	&lt;Array of: ByteArray&gt; configurable list of available host interfaces (not auto-determined)</body></comment><class><name>RestartProtocol</name><environment>Opentalk</environment><super>Opentalk.GenericProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration id </inst-vars><class-inst-vars>defaultComponentIdGenerator defaultAutoRestart </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RestartProtocol</class-id><body>RestartProtocol is the abstract superclass of those 'outer' components in the Opentalk system that usually elect to respond to system events.  'Outer' components regulate the startup and shutdown of their contained sub-components.  RestartProtocol supports a control protocol for response to system events.  It adds another state to the startup and shutdown state machine implemented in GenericProtocol, the 'quiescent' state, the state of a running component temporarily shut down in response to some system event.Instance Variables:	configuration	&lt;RestartProtocolConfiguration&gt; runtime cache of the configuration	id	&lt;Symbol&gt; the component ID used as a key in the opentalk component registryClass Instance Variables:	defaultComponentIdGenerator	&lt;BlockClosure | UndefinedObject&gt; generates a component ID for its single parameter	defaultAutoRestart	&lt;Symbol&gt; default auto restart mode</body></comment><class><name>BasicObjectAdaptor</name><environment>Opentalk</environment><super>Opentalk.RestartProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint localAccessPoint accessAddress objectTable orb requestDispatcher processingPolicy localityTest </inst-vars><class-inst-vars>defaultRequestDispatcherConfiguration defaultLocalityTest </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.BasicObjectAdaptor</class-id><body>BasicObjectAdaptor is abstract superclass of all concrete object adaptors, that are the servers of all remote object invocations.  Object adaptors are at a fixed, well known accessPoint, so that other parties can forward messages to the adaptor's image.  An adaptor records all exported server objects in its objectTable and supports the export registry service.Note that in the terms of the client-server model, an objectAdaptor is a part of the server.  It receives the object request, activates the server object and forwards the request. In this context, the ORB is part of the client, as it forwards the request to the server.  The objectTable is a registry of exported objects.  Subclasses of BasicObjectAdaptor must implement a real communication protocol to pass remote invocation messages.Subclasses must implement the following messages:	RMI-API		transportTo:	testing		socketIsInactiveOrNilInstance Variables:	accessPoint	&lt;IPSocketAddress&gt; the access point of the adaptor	localAccessPoint	&lt;IPSocketAddress&gt; caches the localhost variant of the access point	accessAddress	&lt;ByteArray&gt; forced IP address to be used instead of the discovered one	objectTable	&lt;ObjectTable&gt; distributed object mapping table	orb	&lt;BasicRequestBroker&gt; the adaptor's request broker	requestDispatcher	&lt;RequestDispatcher&gt; controls dispatch of incoming requests to worker processes	processingPolicy	&lt;ProcessingPolicy&gt; defines how to process header entries on a server	localityTest	&lt;BlockClosure&gt; configurable test for locality of ObjRefsClass Instance Variables:	defaultRequestDispatcherConfiguration	&lt;RequestDispatcherConfiguration | UndefinedObject&gt; the default request dispatcher configuration	defaultLocalityTest	&lt;BlockClosure&gt; the default test for locality of ObjRefs</body></comment><class><name>ConnectionAdaptor</name><environment>Opentalk</environment><super>Opentalk.BasicObjectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connections clientConnections listener connectionTimeout connectingTimeout upperConnectionLimit lowerConnectionLimit maxAcceptDelay isBiDirectional useDistinctServerEvents </inst-vars><class-inst-vars>defaultConnectingTimeout defaultConnectionTimeout defaultSoReuseAddr defaultUpperConnectionLimit defaultLowerConnectionLimit defaultMaxAcceptDelay defaultIsBiDirectional defaultUseDistinctServerEvents </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ConnectionAdaptor</class-id><body>This is an adaptor for connection-oriented protocols, i.e. protocols that multiplex a communication transport by connections. It usually has a listener waiting for connection requests.  It is capable of managing a set of existing connections. Instance Variables:	connections	&lt;SharedRegistry key: IPSocketAddress value: StreamTransport&gt; the established connection registry	clientConnections	&lt;SharedRegistry key: IPSocketAddress value: StreamTransport&gt; the established client connection registry	listener	&lt;ConnectionListener&gt; listens for incoming connection requests	connectionTimeout	&lt;SmallInteger&gt; how long can a connection idle before being closed (ms)	connectingTimeout	&lt;SmallInteger&gt; how long to wait for a connection request to succeed (ms)	upperConnectionLimit	&lt;SmallInteger&gt; maximum number of concurrent connections	lowerConnectionLimit	&lt;SmallInteger&gt; threshold at which to re-enable acceptance of new connections	maxAcceptDelay	&lt;SmallInteger&gt; once we get into the limit zone accept rate will gradually slow down up to this delay time (ms)	isBiDirectional	&lt;Boolean&gt; allow bi-directional connections (requests flowing both ways)	useDistinctServerEvents	&lt;Boolean&gt; trigger distinct server side connection add/remove eventsClass Instance Variables:	defaultConnectingTimeout	&lt;SmallInteger | UndefinedObject&gt; how long to wait for a connect request to succeed (ms)	defaultConnectionTimeout	&lt;SmallInteger | UndefinedObject&gt; how long to wait before shutting down an inactive connection (ms)	defaultSoReuseAddr	&lt;Boolean | UndefinedObject&gt; the default value for SO_REUSEADDR socket option	defaultUpperConnectionLimit	&lt;SmallInteger | UndefinedObject&gt; maximum number of concurrent connections	defaultLowerConnectionLimit	&lt;SmallInteger | UndefinedObject&gt; threshold at which to re-enable acceptance of new connections	defaultMaxAcceptDelay	&lt;SmallInteger | UndefinedObject&gt; once we get into the limit zone accept rate will gradually slow down up to this delay time (ms)	defaultIsBiDirectional	&lt;Boolean&gt; allow bi-directional connections (requests flowing both ways)	defaultUseDistinctServerEvents	&lt;Boolean&gt; trigger distinct server side connection add/remove events</body></comment><class><name>Configuration</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.Configuration</class-id><body>Configuraion is the abstract superclass of those classes used to represent the dimesions of a broker configuration.  Configurations are used both [1] as blueprints for building a broker instance and [2] as runtime caches of the original configuation.  Configurations can be stored in files, and print themselves in a form that may be used to create an instance of a configuration.Subclasses have to implement:	#componentClass 		returns a class that need to be instantiated to realize a broker configuration </body></comment><class><name>MarshalerConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.MarshalerConfiguration</class-id><body>A MarshalerConfiguration represents the configuration of a marshaler.  In addition to specifying the class of the marshaler, it specified the marshaler's buffer size. Instance Variables:	bufferSize	&lt;Integer&gt;	the size of the marshaling buffer</body></comment><class><name>TransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshaler bufferSize serverPriority </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.TransportConfiguration</class-id><body>A TransportConfiguration represents the configuration of a transport.  It essentially involves the configuration of the marshaling machinery used with the transport.Instance Variables:	marshaler		&lt;MarshalerConfiguration&gt;		the marshaler specificiation	bufferSize		&lt;SmallInteger&gt; 				the size of transport buffers	serverPriority	&lt;SmallInteger&gt;				the priority of the process that reads incoming messages</body></comment><class><name>DatagramTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.TransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soReuseAddr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.DatagramTransportConfiguration</class-id><body>A TransportConfiguration represents the configuration of a transport.  It essentially involves the configuration of the marshaling machinery used with the transport.Instance Variables:	soReuseAddr	&lt;Boolean&gt;	should the broker set SO_REUSEADDR on the listening socket</body></comment><class><name>OtEServerError</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEServerError</class-id><body>A remote error has occurred when remote debugging was not active.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>UnregisteredObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>UnregisteredObject</class-id><body>A privileged instance of UnregisteredObject is used to represent objects that are not registered in the object table of the receiving adaptor during unmarshaling.</body></comment><class><name>ConnectionListener</name><environment>Opentalk</environment><super>Opentalk.GenericProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>port socket listenerProcess connectionManager suspend </inst-vars><class-inst-vars>defaultListenerPriority defaultListenerBacklog </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ConnectionListener</class-id><body>ConnectionListener implements the TCP connection request listener.  It is important to understand how a connection oriented protocol works:	[1]	Listener:			... waits for client connection request on a known port.  The listener is implemented by this class.	[2]	Client:			... issues a connection request by given the ip address and the port number of the server.  ... implemented by a client object. 	[3]	Listener:			... accepts the connection request and establishes a connection with a connected socket.  ... either activates a server object on the socket or just passes the socket to an existing server object.  ... is usually handled by this class or subclass of this class.	[4]	Client and Server: 			... communicate through the established connected socket.  ... on the client side, implemented by the client object.  ... on the server side, implemented by the server object.	[5]	Client and Server:			... close the connection.In some protocol implementations, the same object may implement both server and client functionalities.  In this case, the ConnectionListener is just a facilitator.Instance Variables:	port	&lt;SmallInteger&gt; port number to listen on	socket	&lt;SocketAccessor&gt; the listening socket	listenerProcess	&lt;Process&gt; the listening process	connectionManager	&lt;ConnectionOrientedAdaptor&gt; the adaptor that manages connections that I create	suspend	&lt;Boolean&gt; a flag that indicates that the listener process should suspend itself before starting the next roundClass Instance Variables:	defaultListenerPriority	&lt;SmallInteger&gt; default priority of the listening process</body></comment><class><name>RequestDispatcher</name><environment>Opentalk</environment><super>Opentalk.GenericProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration manager workerPriority </inst-vars><class-inst-vars>defaultWorkerPriority </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RequestDispatcher</class-id><body>RequestDispatch is the abstract superclass of all request dispatch implementations.  Request dispatch regulates the number of worker processes and the priority at which they are forked.  If you are interested in time slicing worker processes, look at the classes in the package named 'Opentalk-Scheduling'.Subclasses must implement the following messages:	dispatch api		dispatchRequest:inBlock:Instance Variables:	configuration			&lt;RequestDispatcherConfiguration&gt;	the configuration	manager				&lt;BasicObjectAdaptor&gt; 				the manager	workerPriority			&lt;SmallInteger&gt;						the worker process priorityClass Instance Variables:	defaultWorkerPriority	&lt;SmallInteger | UndefinedObject&gt;	the worker process priority</body></comment><class><name>PoolRequestDispatcher</name><environment>Opentalk</environment><super>Opentalk.RequestDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processPool processNumber sharedQueue </inst-vars><class-inst-vars>defaultProcessNumber </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.PoolRequestDispatcher</class-id><body>A PoolRequestDispatcher limits the number of spawned worker processes using a SharedQueue and a process pool of fixed size.Instance Variables:	processNumber			&lt;Integer&gt;								the number of processes in the pool	processPool			&lt;OrderedCollection | UndefinedObject&gt;	the process pool	sharedQueue			&lt;SharedQueue&gt;							the queue used to store incoming requestsClass Instance Variables:	defaultProcessNumber	&lt;Integer | UndefinedObject&gt;				default number of processes in the pool</body></comment><class><name>RestartProtocolConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>autoRestart id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RestartProtocolConfiguration</class-id><body>RestartProtocolConfiguration is an abstract class.  It represents the configuration of component that subscribes for and responds to system events.Instance Variables:	autoRestart	&lt;Symbol&gt; indicates under what circumstances a component should restart on system startup 	id			&lt;Symbol&gt; the component ID to be used as the in the global opentalk component registry (optional)Class Instance Variables:	defaultComponentIDGenerator</body></comment><class><name>BrokerConfiguration</name><environment>Opentalk</environment><super>Opentalk.RestartProtocolConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptor requestTimeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.BrokerConfiguration</class-id><body>A BrokerConfiguration represents the configuration of a broker.  The details of a BrokerConfiguration are folded within its AdaptorConfiguration.Instance Variables:	adaptor	&lt;AdaptorConfiguration&gt;	the object adaptor configuration	requestTimeout	&lt;Integer&gt;	how many milliseconds to wait for a response</body></comment><class><name>BasicBrokerConfiguration</name><environment>Opentalk</environment><super>Opentalk.BrokerConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.BasicBrokerConfiguration</class-id><body>Configuration for BasicRequestBrokers.</body></comment><class><name>StandardBrokerConfiguration</name><environment>Opentalk</environment><super>Opentalk.BasicBrokerConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.StandardBrokerConfiguration</class-id><body>Configuration for standard request brokers.</body></comment><class><name>TransportPackageBytes</name><environment>Opentalk</environment><super>Kernel.BinaryStorageBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.TransportPackageBytes</class-id><body>TransportPackageBytes holds required message information:	protocol name (magic),	protocol version numbers (major and minor),	endianness,	message type (including whether a fragment), and	message size.This a bare bones implementation of the CORBA GIOP message header, that anticipates the integration of DST under Opentalk.	Instance Variables:	*Indexed*Class Instance Variables:	None.Class Shared Variables:	HeaderSize		&lt;SmallInteger&gt;		the header size in bytes</body></comment><class><name>AdaptorConfiguration</name><environment>Opentalk</environment><super>Opentalk.RestartProtocolConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint transport requestDispatcher processingPolicy localityTest </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.AdaptorConfiguration</class-id><body>An AdaptorConfiguration represents the configuration of an object adaptor.  It essentially involves the specification of an access point, usually an IPAddress, the configuration used to specify the transport, the dispatcher that manages the priority and number of worker processes, and the intended worker process priority.Instance Variables:	accessPoint	&lt;IPSocketAddress&gt; the access point of the adaptor	transport	&lt;TransportConfiguration&gt; the transport configuration	requestDispatcher	&lt;RequestDispatcherConfiguration&gt; the dispatcher configuration	processingPolicy	&lt;ProcessingPolicy&gt; defines additional message processing requirements	localityTest	&lt;BlockClosure&gt; configurable test for locality of ObjRefs</body></comment><class><name>OtWeakKeyDictionary</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tally keys values accessLock minimumSize growBound growRatio shrinkBound shrinkRatio </inst-vars><class-inst-vars>defaultGrowBound defaultGrowRatio defaultShrinkBound defaultShrinkRatio </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtWeakKeyDictionary</class-id><body>This class is private to the implementation of Opentalk.  Users should not use this class directly and should not subclass it.  An OtWeakKeyDictionary is a dictionary whose keyArray is a WeakArray.  It is fully protocol-compatible with  IdentityDictionary.  The lookup is done using '==' rather than '='.This version implements new growing and shrinking strategy in an attempt to address some performance issues reported by customers. The new strategy also allows tuning of some of its parameters. Note however that it is a delicate issue and even though there are some basic sanity checks performed when setting the parameters, thorough testing before deployment is highly recommended. The new strategy also allows to disable shrinking altogether by setting the shrinkBound to nil.Here are some design notes for the new strategy:There's shrinkBound (e.g 20%) and growBound (e.g. 50%) which trigger shrinking or growth respectively. Then there's a change ratio (e.g. 2) that is applied to size (not tally !) during this operation. Shrinking is dividing the size by ratio, growing is multiplying the size by ratio. If we define fullness as tally/size. Then the change in fullness after growing and shrinking goes like this:	a) growing:	fullness' = tally / (size * ratio) = (tally / size) * (1 / ratio) = fullness / ratio	b) shrinking:	fullness' = tally / (size / ratio) = (tally / size ) * ratio = fullness * ratioGiven our example values	a) growing at 50%:	fullness = 0.5 =&gt; fullness' = 0.5 / 2 = .25 = 25%	b) shrinking at 20%:	fullness = 0.2 =&gt; fullness' = 0.2 * 2 = 0.4 = 40%So after growing we are at 25% fullness and we are only 5% away from shrinking. Similarly after shrinking we are at 40% fullness and only 10% away from growing back. This is a fairly small margin resulting in a very real possibility of thrashing, i.e. repeated shrinking and growing if the number of elements of the dictionary fluctuates at just the right levels. However we don't want to reduce the ratio further (which would mean more frequent growing or shrinking), it was effectively 2.5 before, so instead we need to move the bounds further apart. If we go for 10% and 60% we get following fullness change:	grow: 60% -&gt; 30%	shrink: 10% -&gt; 20%Considering the above it seems that it would be better to shrink more aggressively, so that after shrinking we don't have only 10% room from next shrinking. Given that we have 40% room for growing, the default shrink ratio is set to 3 which gives us		shrink: 10% -&gt; 30%So these are the current default parameter values:	shrinkBound = 0.1	"shrink when only 10% full"	shrinkRatio = 3		"shrink by 3"	growBound = 0.6	"grow when 60% full"	growRatio = 2.		"grow by 2"For finalization, the dictionary assumes that the value is the 'executor'.  An executor is responsible for finalization after the key has been reclaimed.  Any key with special finalization requirements should implement the #finalize message, which is sent to actually perform the finalization.  Otherwise, note that the default implementation in 'Object&gt;&gt;finalize' performs no finalization.All the accessing methods contain critical regions using the accessLock, so that finalization does not occur during access.Instance Variables:	tally			&lt;Number&gt; the current number of elements	keys			&lt;WeakArray&gt; holder of all keys	values		&lt;Array&gt; holder of all values	accessLock	&lt;RecursionLock&gt; mutex protecting access	minimumSize	&lt;Integer&gt; never shrink below this size (initialized to the original #new: parameter)	growBound	&lt;Float&gt; the tally/capacity at which we should grow	growRatio	&lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)	shrinkBound	&lt;Float&gt; the tally/capacity at which we should shrink	shrinkRatio	&lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)Class Instance Variables:	defaultGrowBound	&lt;Float&gt; the tally/capacity at which we should grow	defaultGrowRatio	&lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)	defaultShrinkBound	&lt;Float&gt; the tally/capacity at which we should shrink	defaultShrinkRatio	&lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)</body></comment><class><name>OtWeakValueDictionary</name><environment>Opentalk</environment><super>Opentalk.OtWeakKeyDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtWeakValueDictionary</class-id><body>This class is private to the implementation of the Opentalk.  Users should not use this class directly and should not subclass it.  The only difference between this class and its superclass, OtWeakKeyDictionary, is that its value array is a WeakArray instead of its key array being a WeakArray.  Also, the lookup is done using = rather than ==, because the key/ooid may be one of the copies with the same value.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>Marshaler</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.Marshaler</class-id><body>Marshaler is the abstract superclass of some marshalers.Subclasses must implement the following messages:	class protocol		accessing			requestClassInstance Variables:	manager		&lt;Transport&gt;					the marshaler's transport	configuration	&lt;MarshalerConfiguration&gt;  	the marshaler's configuration</body></comment><class><name>HighLowRequestDispatcher</name><environment>Opentalk</environment><super>Opentalk.RequestDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discriminationBlock highPriority </inst-vars><class-inst-vars>defaultDiscriminationBlock defaultHighPriority </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.HighLowRequestDispatcher</class-id><body>A HighLowRequestDispatcher is a request dispatcher that supports selective dispatch at two different priority levels.  Using a block, the discrimination is made on some arbitrary characteristic of the remote message, by default, the selector name.Instance Variables:	discriminationBlock	&lt;BlockClosure&gt; a block that, if true, entails worker process dispatch at the 'highPriority' level	highPriority	&lt;SmallInteger&gt; a priority level above the default worker priority but below the default server priorityClass Instance Variables:	defaultDiscriminationBlock	&lt;Object&gt; undocumented	defaultHighPriority	&lt;Object&gt; undocumented</body></comment><class><name>OtECommunicationFailure</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtECommunicationFailure</class-id><body>A communication failure has occurred, triggered by either a socket notReady signal, a socket write error, a socket commit error, or a remote reply timeout.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtETimeout</name><environment>Opentalk</environment><super>Opentalk.OtECommunicationFailure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request transport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtETimeout</class-id><body>This exception is signaled when a reply to a remote request is not received within the specified timeout period.Instance Variables	request	&lt;RemoteRequest&gt; 	transport	&lt;Transport&gt;</body></comment><class><name>RemoteMessage</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId interceptorDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RemoteMessage</class-id><body>RemoteMessage is an abstract class representing a communication package and its semantics.Subclasses must implement the following messages:		msgTypeInstance Variables:	requestId	&lt;Number&gt; the id number of the request	interceptorDispatcher	&lt;InterceptorDispatcher&gt; interceptors assigned to this message</body></comment><class><name>RemoteReply</name><environment>Opentalk</environment><super>Opentalk.RemoteMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RemoteReply</class-id><body>Reply is the abstract superclass representing replies to remote requests.Instance Variables:	reply	&lt;Object | RemoteObject&gt;  the return value of a remote request</body></comment><class><name>OtEComponentIdNotFound</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEComponentIdNotFound</class-id><body>This exception is raised by the OpentalkSubsystem when it fails to find a registered component with given ID.</body></comment><class><name>OtEProtocol</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEProtocol</class-id><body>An attempt has been made to process an incoming package bearing a header which indicates that it follows a protocol other than that employed by the active adaptor or connection.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>ConnectionLessAdaptorConfiguration</name><environment>Opentalk</environment><super>Opentalk.AdaptorConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ConnectionLessAdaptorConfiguration</class-id><body>A ConnectionLessAdaptorConfiguration is used to configure and create a ConnectionLessAdaptor.</body></comment><class><name>TransportPackage</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer position peer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.TransportPackage</class-id><body>TransportPackage is an abstract class representing a communication package and its semantics, that assumes its buffer will support the protocol of TransportMessageHeader.Instance Variables:	buffer	&lt;TransportPackageBytes&gt;	the on-the-wire formatted bytes of the message	position	&lt;SmallInteger&gt;				buffer position available for writing	peer	&lt;IPSocketAddress&gt;			the peer address</body></comment><class><name>RemoteObject</name><environment>Opentalk</environment><super>Opentalk.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestBroker dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RemoteObject</class-id><body>RemoteObject is the default concrete proxy or object reference of Opentalk.  It implements a lightweight dependency mechanism.Remotely Dispatched:	RemoteObject&gt;&gt;eventService	RemoteObject&gt;&gt;_remoteCopy	RemoteObject&gt;&gt;inspectorClassNameInstance Variables:	requestBroker	&lt;BasicRequestBroker&gt;	the request broker	dependents		&lt;LocalDependents&gt;		a collection of dependentsClass Instance Variables:	None.Class Shared Variables:	PrintUsingHostAddress	&lt;Boolean&gt;		controls printing</body></comment><class><name>StreamTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.TransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.StreamTransportConfiguration</class-id><body>A StreamTransportConfiguration is used to configure and create a StreamTransport.</body></comment><class><name>SimpleTransportMessage</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer msgSize position peer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.SimpleTransportMessage</class-id><body>SimpleTransportMessage is an abstract class representing a communication package and its semantics, that expects its buffer to be no more than a lowly ByteArray.Instance Variables:	buffer		&lt;ByteArray&gt;		the 'on-the-wire' bytes	msgSize	&lt;SmallInteger&gt;		size of message written or read into the buffer	position		&lt;SmallInteger&gt;		buffer position for writing	peer		&lt;IPSocketAddress&gt;	the peer address</body></comment><class><name>ConnectionLessAdaptor</name><environment>Opentalk</environment><super>Opentalk.BasicObjectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ConnectionLessAdaptor</class-id><body>This is an adaptor for connection-less protocols. The same instance of transport is used to send messages to any destinationInstance Variables:	transport	&lt;UDPTransport&gt;	implements the actual transport protocol</body></comment><class><name>ProcessingPolicy</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptor dispatcherClass interceptorClasses </inst-vars><class-inst-vars>defaultDispatcherClass defaultInterceptorClasses </class-inst-vars><imports></imports><category>Opentalk-SOAP-Headers</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ProcessingPolicy</class-id><body>Processing policy allows to customize message processing. The main responsibility is to provide a set of message interceptors to each incoming/outgoing message. Interceptors will receive callbacks at various points of message processing. Dedicated interceptors can be instantiated for each message to allow for stateful interception (carrying state from one interception point to another), or they can be global objects for stateless interception. Additional interception points can be introduced by specific protocols.Instance Variables:	adaptor	&lt;BasicObjectAdaptor&gt; 	dispatcherClass	&lt;InterceptorDispatcher&gt; interceptor dispatcher class	interceptorClasses	&lt;Collection of MessageInterceptor&gt; collection of  message interceptorsClass Instance Variables:	defaultDispatcherClass	&lt;Class&gt; 	defaultInterceptorClasses	&lt;SequenceableCollection of: Class&gt;</body></comment><class><name>Transport</name><environment>Opentalk</environment><super>Opentalk.GenericProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager serverProcess sendLock marshaler unmarshaler readBuffer writeBuffer configuration </inst-vars><class-inst-vars>defaultBufferSize defaultServerPriority </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.Transport</class-id><body>Transport is the abstract superclass of all transport implementations.  The principal discriminator in the Transport hierarchy is streaming.  Streaming transports are used with ConnectionOrientedAdaptors.  DatagramTransports are used with ConnectionLessAdaptors.Subclasses must implement the following messages:	private		serverProcessBodyInstance Variables:	manager	&lt;BasicObjectAdaptor&gt; manager	serverProcess	&lt;Process&gt; server	sendLock	&lt;Semaphore&gt; mutex for packet transmission	marshaler	&lt;Marshaler&gt; the transport's marshaler	unmarshaler	&lt;Marshaler&gt; the transport's unmarshaler	readBuffer	&lt;TransportPackageBytes&gt; the buffer for incoming messages	writeBuffer	&lt;TransportPackageBytes&gt; the buffer for outgoing messages	configuration	&lt;TransportConfiguration&gt; the configuration of the transportClass Instance Variables:	defaultBufferSize	&lt;SmallInteger | UndefinedObject&gt; the default size of transport buffers	defaultServerPriority	&lt;SmallInteger&gt; default priority of transport server process</body></comment><class><name>RequestTransport</name><environment>Opentalk</environment><super>Opentalk.Transport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestRegistry nextRequestId sessionObjects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RequestTransport</class-id><body>RequestTransport is the abstract superclass of those transports possessing the infrastructure needed to match incoming replies to previous requests and to record the values of replies.  A RequestTransport stops and starts its 'requestDispatch' in case the dispatch policy it implements is preemptive and involves a high-priority scheduling process.Subclasses must implement the following messages:	private		readTransportPackageInstance Variables:	requestRegistry		&lt;OtWeakValueDictionary&gt;	registry for reply to request matching		nextRequestId		&lt;Integer&gt;					next request identifier	sessionObjects		&lt;Set&gt;						reply objects	requestDispatcherClass Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>ConnectionAdaptorConfiguration</name><environment>Opentalk</environment><super>Opentalk.AdaptorConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listenerPriority listenerBacklog connectionTimeout connectingTimeout upperConnectionLimit lowerConnectionLimit soReuseAddr maxAcceptDelay isBiDirectional useDistinctServerEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ConnectionAdaptorConfiguration</class-id><body>A ConnectionAdaptorConfiguration is used to configure and create a ConnectionAdaptor.Instance Variables:	listenerPriority	&lt;SmallInteger&gt; the listener process priority (11..89)	listenerBacklog	&lt;SmallInteger&gt; the number of allowed connect requests pending (SocketAccessor&gt;&gt;listenFor:)	connectionTimeout	&lt;SmallInteger&gt; how long can a connection idle before being closed (ms)	connectingTimeout	&lt;SmallInteger&gt; how long to wait for a connection request to succeed (ms)	upperConnectionLimit	&lt;SmallInteger&gt; maximum number of concurrent connections	lowerConnectionLimit	&lt;SmallInteger&gt; treshold at which to re-enable acceptance of new connections	soReuseAddr	&lt;Boolean&gt; should the broker set SO_REUSEADDR on the listening socket	maxAcceptDelay	&lt;SmallInteger&gt; once we get into the limit zone accept rate will gradually slow down up to this delay time (ms)	isBiDirectional	&lt;Boolean&gt; allow bi-directional connections (requests flowing both ways)	useDistinctServerEvents	&lt;Boolean&gt; trigger distinct server side connection add/remove events</body></comment><class><name>AsymmetricConnectionAdaptorConfiguration</name><environment>Opentalk</environment><super>Opentalk.ConnectionAdaptorConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.AsymmetricConnectionAdaptorConfiguration</class-id><body>DEPRECATED! This class used to represent configuration of an asymmetric (one-way) connection-oriented adaptor. Use ConnectionAdaptorConfiguration&gt;&gt;isBiDirectional: config parameter instead.Therefore instead of	AdaptorConfiguration asymmetricConnectionOrientedor	AsymmetricConnectionAdaptorConfiguration newuse	ConnectionAdaptorConfiguration new		isBiDirectional: false;</body></comment><class><name>RequestDispatcherConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workerPriority </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RequestDispatcherConfiguration</class-id><body>A RequestDispatchConfiguration is used to configure and create a request dispatcher.Instance Variables:	workerPriority	&lt;SmallInteger&gt; the worker process priority</body></comment><class><name>HighLowRequestDispatcherConfiguration</name><environment>Opentalk</environment><super>Opentalk.RequestDispatcherConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discriminationBlock highPriority </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.HighLowRequestDispatcherConfiguration</class-id><body>Instance Variables:	discriminationBlock	&lt;BlockClosure&gt; one argument block for detecting high priority messages	highPriority	&lt;SmallInteger&gt; the high priority for worker processes</body></comment><class><name>DatagramTransport</name><environment>Opentalk</environment><super>Opentalk.RequestTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.DatagramTransport</class-id><body>DatagramTransport is the abstract superclass of all non-streaming transports.  Note that Datagram packets have an OS-dependent maximum size, with 4000 as the safe limit.Instance Variables:	None.</body></comment><class><name>ObjectTable</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessLock objectsToOIDs oidsToObjects nextKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ObjectTable</class-id><body>This class implements an object table which maps OIDs to objects.  It holds all the mappings in a weak form: if there are no reference to an object in the image, the mapping will be garbage collected.  It also has a simple sequencer which can be used to generate simple number based ooids in this object space.Instance Variables:	accessLock		&lt;RecursionLock&gt;			mutex protecting acceses the object table	objectsToOIDs	&lt;OtWeakKeyDictionary&gt;	object-to-OID dictionary	oidsToObjects	&lt;OtWeakValueDictionary&gt;	OID-to-object dictionary	nextKey		&lt;Number&gt;					next number used to generate an OIDClass Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtEBadOperation</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEBadOperation</class-id><body>An attempt was made to invoke a remote operation that was denied by the receiver.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>RemoteRequest</name><environment>Opentalk</environment><super>Opentalk.RemoteMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target message timeout promise reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RemoteRequest</class-id><body>Request represent a remote message invocation.  Note that the service context is used to pass the home interface, debugging, transaction, and session information, and other such things to the remote execution site.Subclasses must implement the following messages:	accessing		destination	dispatching		doTheWorkFor:		replyForResult:Instance Variables:	target		&lt;ObjRef&gt;			the addressee of the invocation	message	&lt;Message&gt;			the Smalltalk message to be invoked	timeout		&lt;Integer&gt;			timeout value in milliseconds	promise		&lt;TimedPromise&gt; 	client side promise to return a reply value when it arrives from the server	reply		&lt;RemoteReply&gt; 	the reply</body></comment><class><name>OtEDifferentOIDExists</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEDifferentOIDExists</class-id><body>The exception is raised when already registed object is registed with different oid</body></comment><class><name>MessageInterceptor</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-SOAP-Headers</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.MessageInterceptor</class-id><body>Interceptors receive callbacks at various points of message processing. This allows injection of customized activity into the process. Interception points are expressed in terms of the callbacks defined in the 'processing callbacks' protocol. Different protocols may add their own interception points to the standard set. The back pointer to interceptors allows an interceptor to access the rest of the processing context and other interceptors.Instance Variables:	dispatcher	&lt;InterceptorDispatcher&gt; </body></comment><class><name>OtServiceException</name><environment>Opentalk</environment><super>Opentalk.OtException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtServiceException</class-id><body>OTServiceException is the abstract superclass of those errors generated by the Opentalk Services, as opposed to the Opentalk communication and marshalling layer.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OpentalkSystem</name><environment>Opentalk</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>accessLock componentRegistry </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OpentalkSystem</class-id><body>OpentalkSystem coordinates image startup and shutdown, other event notification, command-line options, and the like, for the Opentalk subsystem.  The class-side 'componentRegistry' registers those Opentalk components affected by the actions mediated through OpentalkSystem.Class Instance Variables:	accessLock			&lt;RecursionLock&gt;			access lock for the componentRegistry	componentRegistry	&lt;OtWeakValueDictionary&gt;	registry of Opentalk components</body></comment><class><name>BasicRequestBroker</name><environment>Opentalk</environment><super>Opentalk.RestartProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>remoteObjectRegistry objectAdaptor requestType requestTimeout </inst-vars><class-inst-vars>brokerId defaultPort defaultRequestTimeout </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.BasicRequestBroker</class-id><body>BasicRequestBroker is the abstract superclass of all concrete object request brokers.  The remoteObjectRegistry is a registry of imported proxies, and is used to maintain remote object identity in the image of the broker.As implemented here, a request broker has only one object adaptor.  However, concrete subclases could have more than one.  For example, a request broker implementing distributed object groups might use a multicast adaptor to maintain the group view and a point-to-point adaptor for communication between group members.  Similarly, a 'gateway' broker might be used to translate between multiple protocols.  Thus, it's the responsibility of an adaptor to implement a concrete protocol, and the broker is an abstraction layer on top of the protocol level.Some communication frameworks elect to separate the protocol layer and the adaptor layer, so that adaptors transfer messages to objects from multiple protocols.  This design pattern was explicitly rejected in Opentalk, as entailing needless complexity.Note that there is a default 'activeBroker' among the class instance variables.  This is intended to be used only for demonstration or experimental purposes.  Any substantive application should, like OpentalkCentral, hold on to and manage its own broker(s).Note that the error log presently collects error strings.  Sophisticated users may find it useful to have it collect exceptions instead.  See the warnings in the message comment of 'logError:with:from:level:'. Subclass Responsibility:	BasicRequestBroker class&gt;&gt;typeInstance Variables:	remoteObjectRegistry	&lt;OtWeakValueDictionary&gt;			registry of imported proxies 	objectAdaptor			&lt;BasicObjectAdaptor&gt; 				the broker's adaptor	requestType				&lt;Class&gt; 							a class of requests to be used by the broker	requestTimeout			&lt;Integer&gt;							how many milliseconds to wait for a responseClass Instance Variables:	brokerId					&lt;Symbol | UndefinedObject&gt;			usually the class name					defaultPort				&lt;SmallInteger | UndefinedObject&gt; 	default listener port number	defaultRequestTimeout	&lt;SmallInteger | UndefinedObject&gt;	default request timeout value in milliseconds</body></comment><class><name>RequestBroker</name><environment>Opentalk</environment><super>Opentalk.BasicRequestBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceDictionary openSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.RequestBroker</class-id><body>RequestBroker is a subclass of BasicRequestBroker that supports a service dictionary for registering broker services and restrictions on the remote messages sent directly to the broker.  In almost all cases, Opentalk users should create instances of RequestBroker rather than of BasicRequestBroker Instance Variables:	serviceDictionary	&lt;Dictionary&gt;		of 'serviceId-&gt;object' Associations	openSelectors		&lt;Array of: Symbol&gt;  remote message selectors permitted by the broker itself</body></comment><class><name>StandardRequestDispatcherConfiguration</name><environment>Opentalk</environment><super>Opentalk.RequestDispatcherConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.StandardRequestDispatcherConfiguration</class-id><body>A StandardRequestDispatcherConfiguration is used to configure and create a StandardRequestDispatcher.</body></comment><class><name>StandardRequestDispatcher</name><environment>Opentalk</environment><super>Opentalk.RequestDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.StandardRequestDispatcher</class-id><body>A StandardRequestDispatcher implements the default pattern for request dispatch: worker processes are forked, at the worker process priority, in first received first forked order, and are therefore executed in that order, unless the implementation of the methods called by the worker processes themselves issues 'yield's, or attach themselves to Semaphores, or the like.</body></comment><class><name>StreamTransport</name><environment>Opentalk</environment><super>Opentalk.RequestTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id peerId writeStream readStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.StreamTransport</class-id><body>StreamTransport is the abstract superclass of connection-oriented transports.Subclasses must implement the following messages:	Instance protocol:		initialize-release			initializeStreams		protocol-API			peerOK	Class protocol:		private			new:socketTo:for:Instance Variables:	id	&lt;Object&gt; canonicalized peer address	peerId	&lt;Object&gt; the peer identifier as reported by the bi-directional support	writeStream	&lt;Stream&gt; outgoing stream	readStream	&lt;Stream&gt; incoming stream</body></comment><class><name>PoolRequestDispatcherConfiguration</name><environment>Opentalk</environment><super>Opentalk.RequestDispatcherConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.PoolRequestDispatcherConfiguration</class-id><body>Instance Variables:	processNumber	&lt;Integer&gt; the number of processes in the pool</body></comment><class><name>LocalDependents</name><environment>Opentalk</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.LocalDependents</class-id><body>An instance of this class is presented as a single remote dependent to the remote object but itself holds all the local dependents of the remote object. See the protocol 'RemoteObject&gt;local-dependents' for the usage of LocalDependents.Instance Variables:	*Indexed*Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtEObjectNotFound</name><environment>Opentalk</environment><super>Opentalk.OtEMarshaling</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEObjectNotFound</class-id><body>This exception is signaled by an ObjectTable when it fails to find given object amongst its exported objects.</body></comment><class><name>ObjRef</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint oid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.ObjRef</class-id><body>ObjRef represents object references in a distributed systems. An ObjRef usually holds an 'accessPoint' which is used to establish the connection to the referenced object's home space, and an 'oid' which is used to identify the object within its home space.  An object's home space is the OS process space where the object is located.  The concrete types of both the accessPoint and the ooid of anObjRef are dependent upon the communcation protocol in use (represented by the ORB and/or the ObjectAdaptor which created the object reference). For example, the accessPoint is anIPSocketAddress and the ooid is usually aSymbolOrString (for reserved or deliberately created ooids) or aNumber (for automatically generatedoids) in the Opentalk STST protocol.  This is an unenforced but useful convention.Instance Variables:	accessPoint	&lt;IPSocketAddress&gt;			the access point of the object's home space	oid				&lt;Symbol|Number&gt;			the identifier of the object in its home spaceClass Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtENullPackage</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtENullPackage</class-id><body>An attempt has been made to unmarshall an internal buffer containing nils.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtEInvalidObjectReference</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.OtEInvalidObjectReference</class-id><body>An attempt has been made to send a remote message to a target object that is either unspecified or not present in the target application.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>AsymmetricConnectionAdaptor</name><environment>Opentalk</environment><super>Opentalk.ConnectionAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><comment><class-id>Opentalk.AsymmetricConnectionAdaptor</class-id><body>DEPRECATED! This class was used for connection-oriented protocols that require asymetric connections, i.e. connections that are used to send requests only one-way (e.g. GIOP). If the server wants to send a request to the client, it cannot reuse an existing connection established previously by the client, rather it has to establish a separate connection where the client/server roles will be reversed. This capability is now controlled by ConnectionAdaptor&gt;&gt;isBiDirectional parameter.</body></comment><shared-variable><name>HeaderSize</name><environment>Opentalk.TransportPackageBytes</environment><private>false</private><constant>false</constant><category>Constants</category><attributes><package>Opentalk-Core</package></attributes></shared-variable><shared-variable><name>HostName</name><environment>Opentalk.GenericProtocol</environment><private>false</private><constant>false</constant><category>Host information</category><initializer></initializer><attributes><package>Opentalk-Core</package></attributes></shared-variable><shared-variable><name>HostAddresses</name><environment>Opentalk.GenericProtocol</environment><private>false</private><constant>false</constant><category>As yet unclassified </category><attributes><package>Opentalk-Core</package></attributes></shared-variable><shared-variable><name>HostAddress</name><environment>Opentalk.GenericProtocol</environment><private>false</private><constant>false</constant><category>Host information</category><attributes><package>Opentalk-Core</package></attributes></shared-variable><shared-variable><name>ConnectionOrientedAdaptor</name><environment>Opentalk</environment><private>false</private><constant>true</constant><category>Opentalk</category><initializer>Opentalk.ConnectionAdaptor</initializer><attributes><package>Opentalk-Core</package></attributes></shared-variable><shared-variable><name>PrintUsingHostAddress</name><environment>Opentalk.RemoteObject</environment><private>false</private><constant>false</constant><category>preferences</category><attributes><package>Opentalk-Core</package></attributes></shared-variable><shared-variable><name>TheUnregisteredObject</name><environment>UnregisteredObject</environment><private>false</private><constant>false</constant><category>singleton</category><attributes><package>Opentalk-Core</package></attributes></shared-variable><methods><class-id>Opentalk.OtException</class-id> <category>printing</category><body package="Opentalk-Core">printOn: aStream	super printOn: aStream.	aStream		nextPut: ${;		nextPutAll: self description;		nextPut: $}</body></methods><methods><class-id>Opentalk.InterceptorDispatcher</class-id> <category>interceptor</category><body package="Opentalk-Core">addInterceptor: anInterceptor	interceptors add: anInterceptor.	anInterceptor dispatcher: self.</body><body package="Opentalk-Core">interceptors	interceptors ifNil: [ interceptors := OrderedCollection new ].	^interceptors</body><body package="Opentalk-Core">setInterceptors: aSequenceOfInterceptors	interceptors := aSequenceOfInterceptors.	aSequenceOfInterceptors do: [ :each | each dispatcher: self ]</body></methods><methods><class-id>Opentalk.InterceptorDispatcher</class-id> <category>processing callbacks</category><body package="Opentalk-Core">receivingReply: aReply in: aTransport	self interceptors do: [ :each | each receivingReply: aReply in: aTransport ]</body><body package="Opentalk-Core">receivingRequest: aRequest in: aTransport	self interceptors do: [ :each | each receivingRequest: aRequest in: aTransport ]</body><body package="Opentalk-Core">sendingReply: aReply in: aTransport	self interceptors do: [ :each | each sendingReply: aReply in: aTransport ]</body><body package="Opentalk-Core">sendingRequest: aRequest in: aTransport	self interceptors do: [ :each | each sendingRequest: aRequest in: aTransport ]</body></methods><methods><class-id>Opentalk.InterceptorDispatcher</class-id> <category>accessing</category><body package="Opentalk-Core">broker	^self policy broker</body><body package="Opentalk-Core">policy	^policy</body><body package="Opentalk-Core">policy: aProcessingPolicy	policy := aProcessingPolicy</body></methods><methods><class-id>Opentalk.InterceptorDispatcher</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize</body></methods><methods><class-id>Opentalk.InterceptorDispatcher class</class-id> <category>instance creation</category><body package="Opentalk-Core">new	^super new initialize</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>protocol-states</category><body package="Opentalk-Core">pRunning	^#running</body><body package="Opentalk-Core">pStopped	^#stopped</body><body package="Opentalk-Core">state	^state</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>protocol-API</category><body package="Opentalk-Core">reset	"Reset the state FSM to its initial state."	self stop</body><body package="Opentalk-Core">restart	"Begin the protocol FSM."	self		stop;		start</body><body package="Opentalk-Core">start	"Begin the protocol FSM."	self isRunning ifTrue: [^self].	self		preStart;		doStart;		postStart</body><body package="Opentalk-Core">stop	"Stop of the protocol FSM."	( self isStopped ) ifTrue: [ ^self ].	self		preStop;		doStop;		postStop</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>testing</category><body package="Opentalk-Core">isRunning	^( state == self pRunning )</body><body package="Opentalk-Core">isStopped	^( state == self pStopped )</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize	state := self pStopped.</body><body package="Opentalk-Core">release	"... intentionally null."</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>backward compatibility</category><body package="Opentalk-Core">shutDown	self doStop</body><body package="Opentalk-Core">startRequest	"Start, if possible."	self start</body><body package="Opentalk-Core">stopRequest	"Stop, if possible"	self stop</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>accessing</category><body package="Opentalk-Core">hostAddress	^self class hostAddress</body><body package="Opentalk-Core">hostAddresses	^self class hostAddresses</body><body package="Opentalk-Core">hostName	^self class hostName</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>events</category><body package="Opentalk-Core">doStart	"Begin the protocol FSM."	state := self pRunning.	self triggerEvent: #doStart</body><body package="Opentalk-Core">doStop	state := self pStopped.	self triggerEvent: #doStop</body><body package="Opentalk-Core">postStart	self triggerEvent: #postStart</body><body package="Opentalk-Core">postStop	self triggerEvent: #postStop</body><body package="Opentalk-Core">preStart	self triggerEvent: #preStart</body><body package="Opentalk-Core">preStop	self triggerEvent: #preStop</body><body package="Opentalk-Core">restartFailedBecause: anError	self	triggerEvent: #restartOf:failedBecause:		with: self		with: anError</body></methods><methods><class-id>Opentalk.GenericProtocol</class-id> <category>private</category><body package="Opentalk-Core">tryRestart	"Try to restart"	[self restart]		on: Error		do: [ :ex |			self restartFailedBecause: ex ]</body></methods><methods><class-id>Opentalk.GenericProtocol class</class-id> <category>utilities</category><body package="Opentalk-Core">accessPointByAddress: bytes4 port: p	^IPSocketAddress hostAddress: bytes4 port: p</body><body package="Opentalk-Core">accessPointByName: host port: p	^IPSocketAddress hostName: host port: p</body></methods><methods><class-id>Opentalk.GenericProtocol class</class-id> <category>events</category><body package="Opentalk-Core">allEvents	^self operationalEvents, self errorEvents</body><body package="Opentalk-Core">canTriggerEvent: eventName	^true</body><body package="Opentalk-Core">errorEvents	^#(	"triggered if a restart fails"	restartOf:failedBecause:)</body><body package="Opentalk-Core">operationalEvents	^#(	"start phases"		preStart		doStart		postStart		"stop phases"		preStop		doStop		postStop)</body></methods><methods><class-id>Opentalk.GenericProtocol class</class-id> <category>accessing</category><body package="Opentalk-Core">hostAddress	^HostAddress ifNil: [ self setHost. HostAddress ]</body><body package="Opentalk-Core">hostAddress: bytes	HostAddress := bytes</body><body package="Opentalk-Core">hostAddresses	^HostAddresses ifNil: [ #() ]</body><body package="Opentalk-Core">hostAddresses: addresses"This allows to explicitly specify the set of available interface addresses.	addresses &lt;Array of: ByteArray&gt; configurable list of available host interfaces (not auto-determined)"	HostAddresses := addresses</body><body package="Opentalk-Core">hostName	^HostName ifNil: [ self setHost. HostName ]</body></methods><methods><class-id>Opentalk.GenericProtocol class</class-id> <category>initialize-release</category><body package="Opentalk-Core">flushHost"	self flushHost"	HostName := nil.	HostAddress := nil.</body><body package="Opentalk-Core">setHost	"self setHost."	HostName := SocketAccessor getHostname.	HostAddress := IPSocketAddress hostAddressByName: HostName.</body></methods><methods><class-id>Opentalk.GenericProtocol class</class-id> <category>instance creation</category><body package="Opentalk-Core">new	^super new initialize</body></methods><methods><class-id>Opentalk.GenericProtocol class</class-id> <category>testing</category><body package="Opentalk-Core">isObjectStudio	^Smalltalk isNil</body><body package="Opentalk-Core">isVisualWorks	^self isObjectStudio not</body></methods><methods><class-id>Opentalk.RestartProtocol</class-id> <category>system events</category><body package="Opentalk-Core">systemPauseEvent	| b |	b := self isRunning.	self stop.	( b )		ifTrue:	[ state := self pQuiescent ]</body><body package="Opentalk-Core">systemResumeEvent	( self isQuiescent )   			ifTrue:	[ self restart ]</body><body package="Opentalk-Core">systemSetUpEvent	( ( self autoRestart == self class restartNever )		and: [ self isQuiescent ] )			ifTrue:	[ state := self pStopped ].				( ( self autoRestart == self class restartAlways ) 		or: [  ( self autoRestart == self class restartIfQuiescent ) and: [ self isQuiescent ] ] )   			ifTrue:	[ self start ]</body><body package="Opentalk-Core">systemTearDownEvent	| b |	b := self isRunning.	self stop.	( b )		ifTrue:	[ state := self pQuiescent ]</body></methods><methods><class-id>Opentalk.RestartProtocol</class-id> <category>protocol-states</category><body package="Opentalk-Core">pQuiescent	^#quiescent</body></methods><methods><class-id>Opentalk.RestartProtocol</class-id> <category>testing</category><body package="Opentalk-Core">isQuiescent	^( state == self pQuiescent )</body><body package="Opentalk-Core">shouldRegisterForSystemEvents	"... by default, anything in this hierarchy should register."	^true</body></methods><methods><class-id>Opentalk.RestartProtocol</class-id> <category>accessing</category><body package="Opentalk-Core">autoRestart	^configuration autoRestart ifNil: [ self class defaultAutoRestart ]</body><body package="Opentalk-Core">configuration	^configuration</body><body package="Opentalk-Core">id	^id ifNil: [		id := configuration id ifNil: [			self class defaultComponentIdGenerator value: self ] ]</body></methods><methods><class-id>Opentalk.RestartProtocol</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize: aConfiguration	configuration := aConfiguration.	self shouldRegisterForSystemEvents ifTrue: [		OpentalkSystem registerComponent:self atId: self id ]</body></methods><methods><class-id>Opentalk.RestartProtocol class</class-id> <category>defaults</category><body package="Opentalk-Core">defaultAutoRestart	^defaultAutoRestart ifNil: [ self defaultAutoRestartValue ]</body><body package="Opentalk-Core">defaultAutoRestart: aSymbol	"The permitted values are #always, #never, and #ifQuiescent."	defaultAutoRestart := aSymbol</body><body package="Opentalk-Core">defaultAutoRestartValue	^self restartNever</body><body package="Opentalk-Core">defaultComponentIdGenerator	^defaultComponentIdGenerator ifNil: [ self defaultComponentIdGeneratorValue ]</body><body package="Opentalk-Core">defaultComponentIdGenerator: aBlock	defaultComponentIdGenerator := aBlock</body><body package="Opentalk-Core">defaultComponentIdGeneratorValue	^[ :aComponent | ( aComponent class name, ' ', Time millisecondClockValue printString ) asSymbol ]</body></methods><methods><class-id>Opentalk.RestartProtocol class</class-id> <category>restart settings</category><body package="Opentalk-Core">restartAlways	^#always</body><body package="Opentalk-Core">restartIfQuiescent	^#ifQuiescent</body><body package="Opentalk-Core">restartNever	^#never</body></methods><methods><class-id>Opentalk.RestartProtocol class</class-id> <category>instance creation</category><body package="Opentalk-Core">new: aConfiguration	^self new initialize: aConfiguration</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>protocol-API</category><body package="Opentalk-Core">accessAddress: a4ByteArray	accessAddress := a4ByteArray</body><body package="Opentalk-Core">changePort: anInteger 	"Change the access point's port number."	( anInteger = self accessPoint port ) 		ifFalse:	[	self accessPoint port: anInteger.					( self isRunning ) 						ifTrue:	[ self restart ]				]</body><body package="Opentalk-Core">doStart	"... call startServer every time, ensuring that the hostAddress is updated, in	case the image is started on a host different from that where it was created."	super doStart.	self startRequestDispatcher.	self startServer.</body><body package="Opentalk-Core">doStop	super doStop.	orb isNil ifFalse: [orb objectAdaptorStopped].	self stopRequestDispatcher.</body><body package="Opentalk-Core">reset	super reset.	self		initializeObjectTable;		setORB: self orb</body><body package="Opentalk-Core">setORB: anORB	orb := anORB.	self export: anORB oid: anORB brokerId</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>accessing</category><body package="Opentalk-Core">accessAddress	^(accessAddress isNil or: [accessAddress = IPSocketAddress defaultServerAddressType thisHost])		ifTrue: [self hostAddress]		ifFalse: [accessAddress]</body><body package="Opentalk-Core">accessPoint	^accessPoint</body><body package="Opentalk-Core">bindAddress	^self isForcingAddress		ifTrue: [self accessAddress]		ifFalse: [IPSocketAddress defaultServerAddressType thisHost].</body><body package="Opentalk-Core">localAccessPoint	^localAccessPoint</body><body package="Opentalk-Core">localAddress	^self class localAddress</body><body package="Opentalk-Core">localityTest	^localityTest ifNil: [		localityTest :=			configuration localityTest ifNil: [				self class defaultLocalityTest ] ]</body><body package="Opentalk-Core">localityTest: aBlock"	aBlock &lt;BlockClosure&gt; configurable test for locality of ObjRefs; the block takes an ObjRef and the adaptor as arguments and answers a Boolean"	localityTest := aBlock</body><body package="Opentalk-Core">orb	^orb</body><body package="Opentalk-Core">processingPolicy	^processingPolicy ifNil: [		processingPolicy :=			configuration processingPolicy ifNil: [				self defaultProcessingPolicy ].		processingPolicy adaptor: self; yourself ]</body><body package="Opentalk-Core">processingPolicy: aProcessingPolicy"	aProcessingPolicy &lt;ProcessingPolicy&gt;"	processingPolicy := aProcessingPolicy</body><body package="Opentalk-Core">requestClass	^configuration transport marshaler requestClass</body><body package="Opentalk-Core">requestDispatcher	^requestDispatcher</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>objectTable-API</category><body package="Opentalk-Core">export: anObject 	"Registers anObject in the exported object table and returns an 	object reference to self."	| oid |	oid := objectTable export: anObject for: self.	^ObjRef newOn: self accessPoint oid: oid</body><body package="Opentalk-Core">export: anObject oid: oid 	"Registers anObject in the exported object table and returns an 	object reference to self."	| registeredOid  |	registeredOid := objectTable export: anObject oid: oid for: self.	registeredOid ~= oid		ifTrue:[^OtEDifferentOIDExists raiseErrorString: (			(#ObjectHasBeenRegistedWithOID &lt;&lt; #opentalk &gt;&gt; 'The object has been already registered with oid: &lt;1s&gt;')				expandMacrosWith: registeredOid printString)].	^ObjRef newOn: self accessPoint oid: oid</body><body package="Opentalk-Core">objectByRef: objRef 	"If the argument, 'objRef' is local, answers the published object associated with the objRef, otherwise answer a proxy.  Note that nil is no longer used to represent the case where there is no object under 'objRef oid' in the table."	^( self isLocal: objRef )		ifTrue:	[	[ objectTable objectByOID: objRef oid ]						on: OtEOIDNotFound						do: [ :ex | UnregisteredObject default ] 				]		ifFalse:	[	self orb findOrCreateRemoteObject: objRef				]</body><body package="Opentalk-Core">objectTable	^objectTable</body><body package="Opentalk-Core">revokeAllExportedObjects	self objectTable clearAll</body><body package="Opentalk-Core">revokeExportedObject: anObject	self objectTable revokeObject: anObject for: self.</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>initialize-release</category><body package="Opentalk-Core">initAt: a4ByteArray port: anInteger	accessAddress := a4ByteArray. "nil means a dynamically discovered host address"	self setAccessPointForPort: anInteger</body><body package="Opentalk-Core">initialize	super initialize.	self initializeObjectTable</body><body package="Opentalk-Core">initialize: aConfiguration 	super initialize: aConfiguration.	accessAddress := aConfiguration accessPoint hostAddress.	self setAccessPointForPort: aConfiguration accessPoint port.	requestDispatcher := self requestDispatcherConfiguration new.	requestDispatcher manager: self</body><body package="Opentalk-Core">initialize: aConfiguration for: aBroker	orb := aBroker.	self initialize: aConfiguration</body><body package="Opentalk-Core">initializeObjectTable	objectTable := ObjectTable new.</body><body package="Opentalk-Core">release	super release.	objectTable := nil.</body><body package="Opentalk-Core">requestDispatcherConfiguration	^configuration requestDispatcher		ifNil: [ self class defaultRequestDispatcherConfiguration ]</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>testing</category><body package="Opentalk-Core">isForcingAddress"Should the adaptor bind to a specific interface or to all available interfaces on the host?"	"^(accessAddress isNil or: [ accessAddress = IPSocketAddress thisHost ]) not"	^accessAddress notNil and: [		accessAddress = self hostAddress		or: [ accessAddress = #[127 0 0 1]		or: [ self hostAddresses includes: accessAddress ] ] ]</body><body package="Opentalk-Core">isLocal: objRef 	^self localityTest value: objRef value: self</body><body package="Opentalk-Core">isLocalObjRef: objRef 	^( objRef accessPoint = self accessPoint )		or: [ objRef accessPoint = self localAccessPoint ]</body><body package="Opentalk-Core">shouldRegisterForSystemEvents	^orb isNil</body><body package="Opentalk-Core">socketIsInactiveOrNil	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>private</category><body package="Opentalk-Core">accessPort	^self accessPoint notNil		ifTrue: [accessPoint port]		ifFalse: [self orb class defaultPort]</body><body package="Opentalk-Core">defaultProcessingPolicy	^self configuration transport marshaler defaultProcessingPolicyClass new</body><body package="Opentalk-Core">setAccessPointForPort: anInteger	"The argument anInteger is treated as the new port number of receiver's 	access point."	accessPoint := self class 		accessPointByAddress: self accessAddress 		port: anInteger.	localAccessPoint := self class		accessPointByAddress: self localAddress		port: anInteger</body><body package="Opentalk-Core">startRequestDispatcher	requestDispatcher start</body><body package="Opentalk-Core">startServer	"Subclasses overriding 'startServer' are urged to include 'super startServer' 	in the overriding implementation, thus ensuring that the host address will 	be updated when an image is started on a host different from that on which	the image was created."	self setAccessPointForPort: self accessPort</body><body package="Opentalk-Core">stopRequestDispatcher	requestDispatcher stop</body><body package="Opentalk-Core">transportFor: request id: transportId	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>printing</category><body package="Opentalk-Core">printAccessInfoOn: aStream	aStream		nextPut: $&lt;;		nextPutAll: self protocolTag;		nextPut: $/.	self accessPoint ifNotNil: [ :ap |		ap hostAddress			do: [ :e | aStream print: e ]			separatedBy: [ aStream nextPut: $.].		aStream			nextPut: $:;			print: self accessPoint port ].	aStream nextPut: $&gt;</body><body package="Opentalk-Core">printOn: aStream	aStream nextPutAll: (#Adaptor &lt;&lt; #opentalk &gt;&gt; 'Adaptor') asString.	self printAccessInfoOn: aStream</body><body package="Opentalk-Core">protocolTag	^self configuration transport componentClass protocolTag</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>RMI-API</category><body package="Opentalk-Core">ping: anAccessPoint	"Answer true if anAccessPoint is reachable, and false otherwise."	self isRunning ifFalse: [		OtECommunicationFailure new			messageText: 'Must be running to ping!';			parameter: anAccessPoint;			raise ].</body><body package="Opentalk-Core">sendRequest: aRequest	self isRunning ifFalse: [		OtECommunicationFailure new			messageText: 'Must be running to send remote messages!';			parameter: aRequest;			raise ].	aRequest interceptorDispatcher: self processingPolicy provideInterceptorDispatcher.	^aRequest sendAndWaitForReply: (		self configuration transportFor: aRequest on: self)</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>events-API</category><body package="Opentalk-Core">haltErrors"Make the process loop handling incoming messages of the broker halt on any unexpected errors.  Note that the event handler has to be a block, otherwise the cleanup code in 'suppressErrors' won't work.  For an explanation of the use of this method, see the method comment of 'suppressErrors'."	self removeErrorHandlers.	self		when: #handlingIncomingMessageIn:failedBecause:			do: [ :transport :exception | transport halt ];		when: #evaluatingMessage:in:failedBecause:			do: [ :message :transport :exception | transport halt ];		when: #sendingReply:in:failedBecause:			do: [ :message :transport :exception | transport halt ]</body><body package="Opentalk-Core">passErrors"Do not handle unexpected errors that occur in the process loop handling incoming messages of the broker.  Note that the event handler has to be a block, otherwise the cleanup code in 'suppressErrors' won't work.  For an explanation of the use of this method, see the method comment of 'suppressErrors'."	self removeErrorHandlers.	self		when: #handlingIncomingMessageIn:failedBecause:			do: [ :transport :exception | exception pass ];		when: #evaluatingMessage:in:failedBecause:			do: [ :message :transport :exception | exception pass ];		when: #sendingReply:in:failedBecause:			do: [ :message :transport :exception | exception pass ]</body><body package="Opentalk-Core">removeErrorHandlers	| selectors |	"This is the list of error handling API methods, needs to be kept up to date"	selectors := #(haltErrors passErrors showErrors).	#(	handlingIncomingMessageIn:failedBecause:		evaluatingMessage:in:failedBecause:		sendingReply:in:failedBecause:) do: [ :ev |		self	removeActionsSatisfying: [ :action |				action isExecutableBlock and: [					selectors includes: action homeMethodSelector ] ]			forEvent: ev ]</body><body package="Opentalk-Core">sendAllEventsTo: anObject	self class allEvents do: [ :ev |		self when: ev send: ev to: anObject ]</body><body package="Opentalk-Core">sendErrorEventsTo: anObject	self class errorEvents do: [ :ev |		self when: ev send: ev to: anObject ]</body><body package="Opentalk-Core">sendOperationalEventsTo: anObject	self class operationalEvents do: [ :ev |		self when: ev send: ev to: anObject ]</body><body package="Opentalk-Core">showErrors"Print to the Transcript any unexpected errors that occur in the broker's server process loop handling incoming messages.  Note that the event handler has to be a block, otherwise the cleanup code in 'suppressErrors' won't work.  Also note that no special provisions are taken to serialize concurrent attempts to print to the Transcript.  This feature is meant just to help developement.  For an explanation of the use of this method, see the method comment of 'suppressErrors'."	self removeErrorHandlers.	self		when: #handlingIncomingMessageIn:failedBecause:			do: [ :transport :exception | Transcript cr; show: exception printString ];		when: #evaluatingMessage:in:failedBecause:			do: [ :message :transport :exception | Transcript cr; show: exception printString ];		when: #sendingReply:in:failedBecause:			do: [ :message :transport :exception | Transcript cr; show: exception printString ]</body><body package="Opentalk-Core">suppressErrors"Suppresses any unexpected errors that occur in the process loop handling incoming messages of the broker.  This restores the default setup.	By default, any errors in the server process loop, which handles incoming messages and their unmarshaling, are suppressed.  If you suspect that you have an error in this loop, it is common practice to debug it by sending the broker the message 'haltErrors' and then resending the remote message that caused the error.  This will expose the error stack in a debugger.  After you have successfully addressed the problem, send the broker the message 'suppressErrors' to make it revert back to its default mode of operation.  In some circumstances, 'passErrors' may be more useful than 'haltErrors'.  The exception will then be passed up the stack to exception handlers in your application code, or up to the unhandled exception handler.  In other circumstances, you may find it more useful, at least at the start, to print the exception to the Transcript using 'showErrors'.  In no case do you care about what happens when you proceed from the debugger after having switched on either 'haltErrors' or 'passErrors'.  Any significant error generated in the server loop is one that you want to fix immediately.  The one circumstance in which you do not want to address an error is when it is an unmarshalling error caused, for example, by someone sending an SNMP message to the IIOP broker you are working on.  The IIOP broker will not be able to successfully unmarshal an SNMP message, it will generate a unmarshalling exception, and you will want to suppress it, because it is not your problem.  You only care about IIOP messages, and you were sent a message that should have been addressed elsewhere.  So, you want to suppress the unmarshaling exception and go on.  This case explains why, by default, we suppress server process loop exceptions."	self removeErrorHandlers</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>system events</category><body package="Opentalk-Core">systemPauseEvent	( orb == nil )		ifTrue:	[ super systemPauseEvent ]</body><body package="Opentalk-Core">systemResumeEvent	( ( orb == nil ) and: [ self socketIsInactiveOrNil ] )		ifTrue:	[ super systemResumeEvent ]</body><body package="Opentalk-Core">systemSetUpEvent	( ( orb == nil ) and: [ self socketIsInactiveOrNil ] )		ifTrue:	[ super systemSetUpEvent ]</body><body package="Opentalk-Core">systemTearDownEvent	( orb == nil )   		ifTrue:	[ super systemTearDownEvent ]</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>image-API</category><body package="Opentalk-Core">imageSuffix	^ObjectMemory imageFilename tail</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>dispatch-API</category><body package="Opentalk-Core">dispatchRequest: aRemoteRequest inBlock: aBlockClosure	requestDispatcher		dispatchRequest: aRemoteRequest inBlock: aBlockClosure</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>events-transport activity</category><body package="Opentalk-Core">receivingPackage: aTransportPackage in: aTransport	| action |	(action := self actionForEvent: #receivingPackage:size:in:) isNil ifFalse: [		"Just trying to save the argument array creation in case there's nobody interested in the event"		action evaluateWithArguments: (Array with: aTransportPackage with: aTransportPackage size with: aTransport)].</body><body package="Opentalk-Core">sendingPackage: aTransportPackage in: aTransport	| action |	(action := self actionForEvent: #sendingPackage:size:in:) isNil ifFalse: [		"Just trying to save the argument array creation in case there's nobody interested in the event"		action evaluateWithArguments: (Array with: aTransportPackage with: aTransportPackage size with: aTransport)].</body><body package="Opentalk-Core">serverProcessExitingIn: aTransport	self triggerEvent: #serverProcessExitingIn: with: aTransport</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>events-message processing</category><body package="Opentalk-Core">evaluatingMessage: aMessage in: aTransport	self	triggerEvent: #evaluatingMessage:in:		withArguments: (Array with: aMessage with: aTransport)</body><body package="Opentalk-Core">evaluatingMessage: aMessage in: aTransport failedBecause: anError	self	triggerEvent: #evaluatingMessage:in:failedBecause:		withArguments: (Array with: aMessage with: aTransport with: anError)</body><body package="Opentalk-Core">handlingIncomingMessageIn: aTransport failedBecause: anError	self	triggerEvent: #handlingIncomingMessageIn:failedBecause:		withArguments: (Array with: aTransport with: anError)</body><body package="Opentalk-Core">receivedOrphanReply: aReply in: aTransport	self	triggerEvent: #receivedOrphanReply:in:		with: aReply		with: aTransport.</body><body package="Opentalk-Core">receivingReply: aReply in: aTransport	| action |	(action := aTransport manager actionForEvent: #receivingReply:in:) isNil ifFalse: [		"Just trying to save the argument array creation in case there's nobody interested in the event"		action evaluateWithArguments: (Array with: aReply with: aTransport)].	aReply interceptorDispatcher receivingReply: aReply in: aTransport</body><body package="Opentalk-Core">receivingRequest: aRequest in: aTransport	| action |	(action := aTransport manager actionForEvent: #receivingRequest:in:) isNil ifFalse: [		"Just trying to save the argument array creation in case there's nobody interested in the event"		action evaluateWithArguments: (Array with: aRequest with: aTransport)].	aRequest interceptorDispatcher receivingRequest: aRequest in: aTransport</body><body package="Opentalk-Core">sendingReply: aReply in: aTransport	| action |	(action := aTransport manager actionForEvent: #sendingReply:in:) isNil ifFalse: [		"Just trying to save the argument array creation in case there's nobody interested in the event"		action evaluateWithArguments: (Array with: aReply with: aTransport)].	aReply interceptorDispatcher sendingReply: aReply in: aTransport</body><body package="Opentalk-Core">sendingReply: aReply in: aTransport failedBecause: anError	self	triggerEvent: #sendingReply:in:failedBecause:		withArguments: (Array with: aReply with: aTransport with: anError)</body><body package="Opentalk-Core">sendingRequest: aRequest in: aTransport	| action |	(action := aTransport manager actionForEvent: #sendingRequest:in:) isNil ifFalse: [		"Just trying to save the argument array creation in case there's nobody interested in the event"		action evaluateWithArguments: (Array with: aRequest with: aTransport)].	aRequest interceptorDispatcher sendingRequest: aRequest in: aTransport</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>events-object activation</category><body package="Opentalk-Core">exportingObject: anObject oid: oid	self	triggerEvent: #exportingObject:oid:in:		withArguments: (Array with: anObject with: oid with: self)</body><body package="Opentalk-Core">revokingExportedObject: anObject oid: oid	self	triggerEvent: #revokingExportedObject:oid:in:		withArguments: (Array with: anObject with: oid with: self)</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor class</class-id> <category>deprecated</category><body package="Opentalk-Core">newAt: a4ByteArray port: anInteger	^self new initAt: a4ByteArray port: anInteger</body><body package="Opentalk-Core">newAtPort: anInteger	^self newAt: nil port: anInteger</body><body package="Opentalk-Core">newOnPort: anInteger	^self newAtPort: anInteger</body><body package="Opentalk-Core">startOnPort: anInteger	^(self newAtPort: anInteger) start</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor class</class-id> <category>events</category><body package="Opentalk-Core">errorEvents	^super errorEvents, 	self serverErrorEvents,	#(	"trigger when a reply that does not find it's corresponding request is received"		receivedOrphanReply:in:)</body><body package="Opentalk-Core">operationalEvents	^super operationalEvents, #(	"triggered when an object gets registered in the object table"	exportingObject:oid:in:	"triggered when an object gets deregistered from the object able"	revokingExportedObject:oid:in:	"triggered on the client side when a  request is being sent out"	sendingRequest:in:	"triggered on the server side when a request from a client is received"	receivingRequest:in:	"triggered on the server side when a reply to a request is being sent back to the client"	sendingReply:in:	"triggered on the client side when a reply from the server is received"	receivingReply:in:	"triggered by some transports when sending data"	sendingPackage:size:in:	"triggered by some transports when receiving data"	receivingPackage:size:in:	"triggered by transports when the server process loop exits"	serverProcessExitingIn:	"triggerd just before a message is evaluated locally"	evaluatingMessage:in:	)</body><body package="Opentalk-Core">serverErrorEvents	^#(	"triggered when a remote message unmarshaling or dispatch fails"		handlingIncomingMessageIn:failedBecause:		"triggered when message evaluation fails"		evaluatingMessage:in:failedBecause:		"triggered when there's a failure sending a reply"		sendingReply:in:failedBecause:)</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor class</class-id> <category>defaults</category><body package="Opentalk-Core">defaultAutoRestartValue	^self restartIfQuiescent</body><body package="Opentalk-Core">defaultLocalityTest	^defaultLocalityTest ifNil: [ self defaultLocalityTestValue ]</body><body package="Opentalk-Core">defaultLocalityTest: aBlock"	aBlock &lt;BlockClosure&gt; the default test for locality of ObjRefs"	defaultLocalityTest := aBlock</body><body package="Opentalk-Core">defaultLocalityTestValue	^[ :objRef :adaptor | adaptor isLocalObjRef: objRef ]</body><body package="Opentalk-Core">defaultRequestDispatcherConfiguration	^defaultRequestDispatcherConfiguration ifNil: [		self defaultRequestDispatcherConfigurationValue ]</body><body package="Opentalk-Core">defaultRequestDispatcherConfiguration: aConfiguration	defaultRequestDispatcherConfiguration := aConfiguration</body><body package="Opentalk-Core">defaultRequestDispatcherConfigurationValue	^StandardRequestDispatcherConfiguration new</body><body package="Opentalk-Core">localAddress	^#[127 0 0 1]</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor class</class-id> <category>instance creation</category><body package="Opentalk-Core">new: aConfiguration for: aBroker	^self new initialize: aConfiguration for: aBroker</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>accessing</category><body package="Opentalk-Core">connectingTimeout	^connectingTimeout ifNil: [		configuration connectingTimeout ifNil: [			self class defaultConnectingTimeout ] ]</body><body package="Opentalk-Core">connectingTimeout: anObject"how long to wait for a connection request to succeed (ms)"	connectingTimeout := anObject</body><body package="Opentalk-Core">connectionTimeout	^connectionTimeout ifNil: [		configuration connectionTimeout ifNil: [			self class defaultConnectionTimeout ] ]</body><body package="Opentalk-Core">connectionTimeout: anObject"how long can a connection idle before being closed (ms)"	connectionTimeout := anObject</body><body package="Opentalk-Core">isBiDirectional	^isBiDirectional ifNil: [		configuration isBiDirectional ifNil: [			self class defaultIsBiDirectional ] ]</body><body package="Opentalk-Core">isBiDirectional: allowed"This flag indicates if connections can be used symmetrically as opposed to asymmetric connections that are used to send requests only one-way (e.g. GIOP). If the server wants to send a request to the client, it cannot reuse an existing connection established previously by the client, rather it has to establish a separate connection where the client/server roles will be reversed. 	allowed &lt;Boolean&gt; allow bi-directional connections (requests can flow in both directions)"	isBiDirectional := allowed</body><body package="Opentalk-Core">listener	^listener</body><body package="Opentalk-Core">lowerConnectionLimit	^lowerConnectionLimit ifNil: [		configuration lowerConnectionLimit ifNil: [			self class defaultLowerConnectionLimit ] ]</body><body package="Opentalk-Core">lowerConnectionLimit: anInteger	lowerConnectionLimit := anInteger</body><body package="Opentalk-Core">maxAcceptDelay	^maxAcceptDelay ifNil: [		configuration maxAcceptDelay ifNil: [			self class defaultMaxAcceptDelay ] ]</body><body package="Opentalk-Core">maxAcceptDelay: aNumber	maxAcceptDelay := aNumber</body><body package="Opentalk-Core">soReuseAddr	^configuration soReuseAddr		ifNil: [self class defaultSoReuseAddr]</body><body package="Opentalk-Core">upperConnectionLimit	^upperConnectionLimit ifNil: [		configuration upperConnectionLimit ifNil: [			self class defaultUpperConnectionLimit ] ]</body><body package="Opentalk-Core">upperConnectionLimit: anInteger	upperConnectionLimit := anInteger</body><body package="Opentalk-Core">useDistinctServerEvents	^useDistinctServerEvents ifNil: [		configuration useDistinctServerEvents ifNil: [			self class defaultUseDistinctServerEvents ] ]</body><body package="Opentalk-Core">useDistinctServerEvents: use"	use &lt;Boolean&gt; trigger distinct server side connection add/remove events"	useDistinctServerEvents := use</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>connection-API</category><body package="Opentalk-Core">addConnection: aTransport		self	addingConnection: aTransport;		privateAddConnection: aTransport</body><body package="Opentalk-Core">addServerConnection: aTransport	self	addingServerConnection: aTransport;		privateAddConnection: aTransport</body><body package="Opentalk-Core">cleanDeadConnections	connections do: [ :each |		each peerOK ifFalse: [ each stop ] ].	"Do we need a timed daemon to do this periodically ?"</body><body package="Opentalk-Core">clientConnections	^clientConnections</body><body package="Opentalk-Core">connectionAt:  addr	^self clientConnections at: addr ifAbsent: []</body><body package="Opentalk-Core">connectionStopped: aTransport	"... invoked from aTransport after it has been stopped."	(clientConnections includesKey: aTransport peerId)		ifTrue: [ self removingConnection: aTransport.			clientConnections removeKey: aTransport peerId ifAbsent: [nil] ]		ifFalse: [ self removingServerConnection: aTransport ].	self privateConnectionStopped: aTransport</body><body package="Opentalk-Core">connections	^connections</body><body package="Opentalk-Core">peerAccessPointFor: transport is: address"This method can be used to designate an established &lt;transport&gt; as suitable for client access to &lt;address&gt;.This is used to support bi-directional connections (see the use in STST)."	self clientConnections		at: address		ifAbsentPut: [ transport ]</body><body package="Opentalk-Core">stopAllConnections	connections do: [:each | each stop]</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>protocol-API</category><body package="Opentalk-Core">doStop	super doStop.		(listener == nil) ifFalse: [ listener stop ].	self stopAllConnections.</body><body package="Opentalk-Core">ping: anAccessPoint 	"Pings the accessPoint, answering true 	if it is reachable and false otherwise."	super ping: anAccessPoint.	^[	(self clientConnections			at: anAccessPoint			ifAbsentPut: [ self newClientConnectionTo: anAccessPoint ]		) peerOK	]	on: Error 		do: [ :ex | false ]</body><body package="Opentalk-Core">reset	super reset.	self initializeConnectionRegistry</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>events-transport activity</category><body package="Opentalk-Core">addingConnection: aTransport		self triggerEvent: #addingConnection:in: with: aTransport with: self</body><body package="Opentalk-Core">addingServerConnection: aTransport	self useDistinctServerEvents		ifTrue: [ self triggerEvent: #addingServerConnection:in: with: aTransport with: self ]		ifFalse: [ self addingConnection: aTransport ]</body><body package="Opentalk-Core">connectionDelayFor: anInteger"When approaching the limit, slow down the rate at which we accept. The closer we get to the maximum, the longer we wait, grouped into buckets.So, for example, if our upper limit is 200, our lower limit is 100, our maximum delay is 10ms, and we have just created our 125th connection, then we will wait for 2.5ms."	| maxHeadroom delay headroom headroomPercentage headroomPercentageBucketed |	headroom := self upperConnectionLimit - anInteger.	maxHeadroom := self upperConnectionLimit		- self lowerConnectionLimit.	headroomPercentage := 1.0 - (headroom asFloat / maxHeadroom asFloat).	headroomPercentageBucketed := (((headroomPercentage * 100) // 1) + 1) / 100.0.	delay := (self maxAcceptDelay * headroomPercentageBucketed).	^delay.</body><body package="Opentalk-Core">leavingConnectionLimit: anInteger with: aTransport	self triggerEvent: #leavingConnectionLimit:with: with: anInteger with: aTransport</body><body package="Opentalk-Core">leftConnectionLimit: anInteger with: aTransport	self triggerEvent: #leftConnectionLimit:with: with: anInteger with: aTransport</body><body package="Opentalk-Core">listenerError: anError in: aListener	self triggerEvent: #listenerError:in: with: anError with: aListener</body><body package="Opentalk-Core">reachedConnectionLimit: anInteger with: aTransport	self triggerEvent: #reachedConnectionLimit:with: with: anInteger with: aTransport</body><body package="Opentalk-Core">reachingConnectionLimit: anInteger with: aTransport	self triggerEvent: #reachingConnectionLimit:with: with: anInteger with: aTransport.	"Once we get to into the limit zone, we'll gradually start slowing down the accept rate up to the maxAcceptDelay	based on how close we are to the upper limit"	self maxAcceptDelay isZero ifFalse: [ | delay |		delay := self connectionDelayFor: anInteger.		(Delay forMilliseconds: delay) wait ]</body><body package="Opentalk-Core">removingConnection: aTransport	self triggerEvent: #removingConnection:in: with: aTransport with: self</body><body package="Opentalk-Core">removingServerConnection: aTransport 	self useDistinctServerEvents		ifTrue: [ self triggerEvent: #removingServerConnection:in: with: aTransport with: self ]		ifFalse: [ self removingConnection: aTransport ]</body><body package="Opentalk-Core">transportSetupIn: aTransport failedBecause: error	self triggerEvent: #transportSetupIn:failedBecause: with: aTransport with: error</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>private</category><body package="Opentalk-Core">accessPort	^listener socketIsInactiveOrNil		ifTrue: [ super accessPort ]		ifFalse: [ listener getSocketAddress port ]</body><body package="Opentalk-Core">newClientConnectionTo: anAccessPoint 	"Create a client connection to the given access point."	^self configuration transport		newTo: anAccessPoint		for: self</body><body package="Opentalk-Core">newServerConnectionOn: aSocket 	"... creates a server connection on the given 	socket; usually called by a listener."	^self configuration transport		newOn: aSocket		for: self</body><body package="Opentalk-Core">privateAddConnection: aTransport		| nr |	(nr := connections size + 1) &lt; self upperConnectionLimit		ifTrue: [ nr &lt; self lowerConnectionLimit				ifFalse: [ self reachingConnectionLimit: nr with: aTransport ] ] 		ifFalse: [ self reachedConnectionLimit: nr with: aTransport ].	connections		at: aTransport id		put: aTransport		do: [ connections size &lt; self upperConnectionLimit				ifFalse: [ listener suspendListenerProcess ] ].</body><body package="Opentalk-Core">privateConnectionStopped: aTransport	| nr |	(nr := connections size) &gt; self lowerConnectionLimit		ifTrue: [ self leavingConnectionLimit: nr with: aTransport ]		ifFalse: [ nr = self lowerConnectionLimit				ifTrue: [ self leftConnectionLimit: nr with: aTransport ] ].	connections		removeKey: aTransport id		ifAbsent: []		ifPresent: [ :transport  |			connections size &gt;= self lowerConnectionLimit				ifFalse: [ listener resumeListenerProcess ] ].</body><body package="Opentalk-Core">startServer	listener port: self accessPort.		listener start.	"Reset access point so that it reflects the actual access port	set up above by the listener."	super startServer.</body><body package="Opentalk-Core">transportFor: request id: transportId	^self clientConnections		at: transportId		ifAbsentPut: [ self newClientConnectionTo: request destination ]		do: [ :transport |			"We need to register the request with the transport atomically,			so that the higher priority server process doesn't time-out the transport in the meantime.			See AR#50767"			transport registerRequest: request ]</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>deprecated</category><body package="Opentalk-Core">initAt: a4ByteArray port: anInteger	super initAt: a4ByteArray port: anInteger.	listener := ConnectionListener port: anInteger connectionManager: self.</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>testing</category><body package="Opentalk-Core">isRunning	^( super isRunning and: [ self listener isRunning ] )</body><body package="Opentalk-Core">socketIsInactiveOrNil	^listener socketIsInactiveOrNil</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize	super initialize.	self initializeConnectionRegistry</body><body package="Opentalk-Core">initialize: aConfiguration	super initialize: aConfiguration.	listener := ConnectionListener port: aConfiguration accessPoint port connectionManager: self.</body><body package="Opentalk-Core">initializeConnectionRegistry	connections := SharedRegistry new.	clientConnections := SharedRegistry new.</body></methods><methods><class-id>Opentalk.ConnectionAdaptor</class-id> <category>events-API</category><body package="Opentalk-Core">passErrors"Do not handle unexpected errors that occur in the process loop handling incoming messages of the broker.  Note that the event handler has to be a block, otherwise the cleanup code in 'suppressErrors' won't work.  For an explanation of the use of this method, see the method comment of 'suppressErrors'."	self removeErrorHandlers.	self		when: #handlingIncomingMessageIn:failedBecause:			do: [ :transport :exception | exception pass ];		when: #transportSetupIn:failedBecause:			do: [ :transport :exception | exception pass ];		when: #evaluatingMessage:in:failedBecause:			do: [ :message :transport :exception | exception pass ];		when: #sendingReply:in:failedBecause:			do: [ :message :transport :exception | exception pass ]</body><body package="Opentalk-Core">removeErrorHandlers	| selectors |	"This is the list of error handling API methods, needs to be kept up to date"	selectors := #(haltErrors passErrors showErrors).	self class serverErrorEvents do: [ :ev |		self	removeActionsSatisfying: [ :action |				action isExecutableBlock and: [					selectors includes: action homeMethodSelector ] ]			forEvent: ev ]</body></methods><methods><class-id>Opentalk.ConnectionAdaptor class</class-id> <category>defaults-accessing</category><body package="Opentalk-Core">defaultConnectingTimeout"The default socket connect timeout in milliseconds."	^defaultConnectingTimeout ifNil: [		self defaultConnectingTimeoutValue ]</body><body package="Opentalk-Core">defaultConnectingTimeout: milliseconds"Set the default socket connect timeout interval.	milliseconds 	&lt;SmallInteger&gt; timeout interval"	defaultConnectingTimeout := milliseconds</body><body package="Opentalk-Core">defaultConnectionTimeout"Default connection timeout interval in milliseconds."		^defaultConnectionTimeout ifNil: [		self defaultConnectionTimeoutValue ]</body><body package="Opentalk-Core">defaultConnectionTimeout: milliseconds"Set the default connection timeout interval in milliseconds.	milliseconds 	&lt;SmallInteger&gt; timeout interval"	defaultConnectionTimeout := milliseconds</body><body package="Opentalk-Core">defaultIsBiDirectional	^defaultIsBiDirectional ifNil: [		self defaultIsBiDirectionalValue ]</body><body package="Opentalk-Core">defaultIsBiDirectional: aBoolean	defaultIsBiDirectional := aBoolean</body><body package="Opentalk-Core">defaultLowerConnectionLimit	^defaultLowerConnectionLimit ifNil: [		self defaultLowerConnectionLimitValue ]</body><body package="Opentalk-Core">defaultLowerConnectionLimit: anInteger	defaultLowerConnectionLimit := anInteger</body><body package="Opentalk-Core">defaultMaxAcceptDelay	^defaultMaxAcceptDelay ifNil: [		self defaultMaxAcceptDelayValue ]</body><body package="Opentalk-Core">defaultMaxAcceptDelay: aNumber	defaultMaxAcceptDelay := aNumber</body><body package="Opentalk-Core">defaultSoReuseAddr	^defaultSoReuseAddr ifNil: [		self defaultSoReuseAddrValue ]</body><body package="Opentalk-Core">defaultSoReuseAddr: aBoolean	defaultSoReuseAddr := aBoolean</body><body package="Opentalk-Core">defaultUpperConnectionLimit	^defaultUpperConnectionLimit ifNil: [		self defaultUpperConnectionLimitValue ]</body><body package="Opentalk-Core">defaultUpperConnectionLimit: anInteger	defaultUpperConnectionLimit := anInteger</body><body package="Opentalk-Core">defaultUseDistinctServerEvents	^defaultUseDistinctServerEvents ifNil: [self defaultUseDistinctServerEventsValue ]</body><body package="Opentalk-Core">defaultUseDistinctServerEvents: use"	use &lt;Boolean&gt; trigger distinct server side connection add/remove events"	defaultUseDistinctServerEvents := use</body></methods><methods><class-id>Opentalk.ConnectionAdaptor class</class-id> <category>deprecated</category><body package="Opentalk-Core">lowerConnectionLimit	^self defaultLowerConnectionLimit</body><body package="Opentalk-Core">lowerConnectionLimit: anInteger	self defaultLowerConnectionLimit: anInteger</body><body package="Opentalk-Core">maxAcceptDelay	^self defaultMaxAcceptDelay</body><body package="Opentalk-Core">maxAcceptDelay: aNumber	self defaultMaxAcceptDelay: aNumber</body><body package="Opentalk-Core">soReuseAddr	^self defaultSoReuseAddr</body><body package="Opentalk-Core">soReuseAddr: aBoolean	self defaultSoReuseAddr: aBoolean</body><body package="Opentalk-Core">upperConnectionLimit	^self defaultUpperConnectionLimit</body><body package="Opentalk-Core">upperConnectionLimit: anInteger	self defaultUpperConnectionLimit: anInteger</body></methods><methods><class-id>Opentalk.ConnectionAdaptor class</class-id> <category>defaults-constants</category><body package="Opentalk-Core">defaultConnectingTimeoutValue"The default socket connect timeout in milliseconds."	^1200</body><body package="Opentalk-Core">defaultConnectionTimeoutValue"The default connection timeout interval in milliseconds.A server connection will be closed after being idle for 20 minutes."		^1200000</body><body package="Opentalk-Core">defaultIsBiDirectionalValue	^true</body><body package="Opentalk-Core">defaultLowerConnectionLimitValue	^900</body><body package="Opentalk-Core">defaultMaxAcceptDelayValue	^10</body><body package="Opentalk-Core">defaultSoReuseAddrValue	^false</body><body package="Opentalk-Core">defaultUpperConnectionLimitValue	^1000</body><body package="Opentalk-Core">defaultUseDistinctServerEventsValue	^true</body></methods><methods><class-id>Opentalk.ConnectionAdaptor class</class-id> <category>events</category><body package="Opentalk-Core">errorEvents	^super errorEvents, #(	"triggered for errors in the listener loop"	listenerError:in:)</body><body package="Opentalk-Core">operationalEvents	^super operationalEvents, #(	"triggered when a new connection is created"	addingConnection:in:	"triggered when a connection is destroyed"	removingConnection:in:	"triggered when a new server connection is created"	addingServerConnection:in:	"triggered when a server connection is destroyed"	removingServerConnection:in:	"triggered when adding connections beyond the lowerConnectionLimit"	reachingConnectionLimit:with:	"triggered when hitting the upperConnectionLimit"	reachedConnectionLimit:with:	"triggered when removing connections beyond the lowerConnectionLimit"	leavingConnectionLimit:with:	"triggered when removing last connection beyond the lowerConnectionLimit"	leftConnectionLimit:with:)</body><body package="Opentalk-Core">serverErrorEvents	^super serverErrorEvents,	#(	"triggered when transport fails to set up and start up properly"		transportSetupIn:failedBecause:	)</body></methods><methods><class-id>Opentalk.Configuration</class-id> <category>printing</category><body package="Opentalk-Core">printOn: aStream	self printOn: aStream offset: 1</body><body package="Opentalk-Core">  printOn: aStream offset: aNumber	self		printOn: aStream		offset: aNumber		parameters: self printOnParameters</body><body package="Opentalk-Core">printOn: aStream offset: aNumber parameters: params	aStream nextPutAll: self class name; space; nextPutAll: 'new'.	params do: [ :param || val |		val := self perform: param asSymbol.		val notNil ifTrue: [			aStream cr; tab: aNumber; nextPutAll: param; nextPut: $:; space.			(val isKindOf: Configuration)				ifTrue: [ aStream nextPut: $(.					val printOn: aStream offset: aNumber + 1.					aStream nextPut: $)]				ifFalse: [val printOn: aStream] ] ].</body><body package="Opentalk-Core">printOnParameters	| params |	params := self class allInstVarNames.	^params copyFrom: 2 to: params size</body><body package="Opentalk-Core">storeOn: aStream	self printOn: aStream offset: 1</body></methods><methods><class-id>Opentalk.Configuration</class-id> <category>component building</category><body package="Opentalk-Core">new	^self componentClass new: self</body></methods><methods><class-id>Opentalk.Configuration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass"Concrete subclasses should override this with explicit class reference"	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.Configuration class</class-id> <category>instance creation</category><body package="Opentalk-Core">rootConfigurationMetaclass	^self class</body></methods><methods><class-id>Opentalk.MarshalerConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">bufferSize	^bufferSize</body><body package="Opentalk-Core">bufferSize: aNumber	bufferSize := aNumber</body><body package="Opentalk-Core">defaultProcessingPolicyClass	^ProcessingPolicy</body><body package="Opentalk-Core">requestClass	^self componentClass requestClass</body></methods><methods><class-id>Opentalk.MarshalerConfiguration</class-id> <category>component building</category><body package="Opentalk-Core">newFor: aManager	^(self componentClass new: self)		setManager: aManager;		yourself</body></methods><methods><class-id>Opentalk.TransportConfiguration</class-id> <category>component building</category><body package="Opentalk-Core">newAt: anAccessPoint for: aManager"Creation method for datagram transports"	^self componentClass		new: self at: anAccessPoint for: aManager</body><body package="Opentalk-Core">newOn: aSocket for: aManager"Creation method for stream transports. Usually invoked by listener"	^self componentClass		new: self on: aSocket for: aManager</body><body package="Opentalk-Core">newTo: anAccessPoint for: aManager"Creation method for stream transports"	^self componentClass		new: self to: anAccessPoint for: aManager</body></methods><methods><class-id>Opentalk.TransportConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">bufferSize	^bufferSize</body><body package="Opentalk-Core">bufferSize: anInteger	bufferSize := anInteger</body><body package="Opentalk-Core">marshaler	^marshaler</body><body package="Opentalk-Core">marshaler: aConfiguration	marshaler := aConfiguration</body><body package="Opentalk-Core">serverPriority	^serverPriority</body><body package="Opentalk-Core">serverPriority: anObject	serverPriority := anObject</body></methods><methods><class-id>Opentalk.TransportConfiguration</class-id> <category>transport building</category><body package="Opentalk-Core">transportFor: request on: aManager	^aManager transportFor: request id: request destination</body></methods><methods><class-id>Opentalk.DatagramTransportConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">soReuseAddr	^soReuseAddr</body><body package="Opentalk-Core">soReuseAddr: aBoolean	soReuseAddr := aBoolean</body></methods><methods><class-id>Opentalk.DatagramTransportConfiguration class</class-id> <category>instance creation</category><body package="Opentalk-Core">rootConfigurationMetaclass	^TransportConfiguration class</body></methods><methods><class-id>UnregisteredObject class</class-id> <category>accessing</category><body package="Opentalk-Core">default	^TheUnregisteredObject</body></methods><methods><class-id>UnregisteredObject class</class-id> <category>class initialization</category><body package="Opentalk-Core">initialize	"((( UnregisteredObject initialize )))"	TheUnregisteredObject := self new</body></methods><methods><class-id>Opentalk.ConnectionListener</class-id> <category>accessing</category><body package="Opentalk-Core">connectionManager	"Return the connectionManager that is responsible 	for handling established connections."	^connectionManager</body><body package="Opentalk-Core">connectionManager: anObject 	"The connectionManager is responsible for 	handling established TCP connections."	connectionManager := anObject</body><body package="Opentalk-Core">getSocketAddress		^socket getName</body><body package="Opentalk-Core">isSuspended	^listenerProcess notNil and: [ listenerProcess isSuspended ]</body><body package="Opentalk-Core">listenerBacklog	^connectionManager configuration listenerBacklog ifNil: [ self class defaultListenerBacklog ]</body><body package="Opentalk-Core">listenerPriority	"Answers the priority level of the listener process."	^connectionManager configuration listenerPriority ifNil: [ self class defaultListenerPriority ]</body><body package="Opentalk-Core">port	"Returns the port number of the listener."	^port</body><body package="Opentalk-Core">port: anInteger	port := anInteger</body><body package="Opentalk-Core">socketIsInactiveOrNil		^socket isNil or: [ socket isActive not ]</body></methods><methods><class-id>Opentalk.ConnectionListener</class-id> <category>private</category><body package="Opentalk-Core">handleConnection: aSocket 	"If connectionManger is not nil, create a server 	connection on the connected socket."		[ self connectionManager newServerConnectionOn:  aSocket	] ifCurtailed: [ aSocket close ]</body><body package="Opentalk-Core">handleListenerError: anError	self connectionManager listenerError: anError in: self.	"This is a somewhat crude measure but seems to help for Wave servers.	We need to be at least as good, so let's emulate that for now."	(OsNoResourcesError handles: anError) ifTrue: [		(Delay forMilliseconds: 250) wait ]</body><body package="Opentalk-Core">listenerProcessBody	[	socket notNil		and: [ socket isActive		and: [ self isRunning ] ]	] whileTrue: [		[	self handleConnection: socket accept		]	on: Error			do: [ :ex |				self handleListenerError: ex ].		suspend ifTrue: [			listenerProcess suspend.			suspend := false ] ]</body><body package="Opentalk-Core">resumeListenerProcess		"We have to make sure that the process is suspended otherwise #resume signals a primitive failure.	This is never sent from the listener process so	Processor activeProcess ~= listenerProcess is not necessary"	self isSuspended ifTrue: [		suspend := false.		listenerProcess resume ]</body><body package="Opentalk-Core">setOptionsOn: aSocketAccessor	connectionManager soReuseAddr ifTrue: [		aSocketAccessor otReuseAddress: true ]</body><body package="Opentalk-Core">startListenerProcess	listenerProcess ifNil: [		suspend := false.		listenerProcess := [ self listenerProcessBody ] forkAt: self listenerPriority ]</body><body package="Opentalk-Core">stopListenerProcess	listenerProcess ifNotNil: [		Processor activeProcess = listenerProcess ifFalse: [			"If doStop runs from a listener event we don't want to terminate ourselves.			Let doStop close the socket and the listener process will exit normally on next iteration."			self terminateListenerProcess ].		listenerProcess := nil ]</body><body package="Opentalk-Core">suspendListenerProcess	"This is invoked from the listener process itself during the process of adding a new connection.	We can't suspend the process until the connection addition is complete, so let's just raise a flag	to suspend the process at a more appropriate point"	suspend := true</body><body package="Opentalk-Core">terminateListenerProcess	listenerProcess terminate</body></methods><methods><class-id>Opentalk.ConnectionListener</class-id> <category>protocol-API</category><body package="Opentalk-Core">doStart	"Start to accept incoming connections 	and set the protocol state to running."	| address |	super doStart.	address := IPSocketAddress defaultServerAddressType hostAddress: connectionManager bindAddress port: self port.	socket == nil ifFalse: [socket close].	socket := 	SocketAccessor			family: address domainCode			type: SocketAccessor SOCK_STREAM.	self setOptionsOn: socket.	[	socket			bindTo: address;			listenFor: self listenerBacklog.		self startListenerProcess	] ifCurtailed: [ socket close. socket := nil ]</body><body package="Opentalk-Core">doStop	super doStop.	self stopListenerProcess.	( socket isNil )		ifFalse:	[	socket close.					socket := nil				].</body></methods><methods><class-id>Opentalk.ConnectionListener</class-id> <category>initialize-release</category><body package="Opentalk-Core">port: aSmallInteger connectionManager: anObject	port := aSmallInteger.	connectionManager := anObject</body></methods><methods><class-id>Opentalk.ConnectionListener</class-id> <category>deprecated</category><body package="Opentalk-Core">listenerProcessPriority	"Answers the priority level of the listener process."	self deprecated: #(#version '9.0' #use #listenerPriority).	^self listenerPriority</body><body package="Opentalk-Core">listenerProcessPriority: anInteger	"Sets the priority of the listener process."	self deprecated: #(#version '9.0' ).	connectionManager configuration listenerPriority: anInteger.	listenerProcess isNil ifFalse: [		listenerProcess priority: anInteger ].</body></methods><methods><class-id>Opentalk.ConnectionListener class</class-id> <category>instance creation</category><body package="Opentalk-Core">port: aSmallInteger connectionManager: anObject	"The argument 'aSmallInteger' is the listening port number, and anObject 	is used to process a connected socket.  The connectionManager object 	must understand: 'on: aConnectedSocket'."		^( super new )		port: aSmallInteger connectionManager: anObject</body></methods><methods><class-id>Opentalk.ConnectionListener class</class-id> <category>defaults</category><body package="Opentalk-Core">defaultListenerBacklog	^defaultListenerBacklog ifNil: [ self defaultListenerBacklogValue ]</body><body package="Opentalk-Core">defaultListenerBacklog: backlog"	backlog &lt;SmallInteger&gt; default size of the listener backlog queue"	defaultListenerBacklog := backlog</body><body package="Opentalk-Core">defaultListenerBacklogValue	^128</body><body package="Opentalk-Core">defaultListenerPriority	^defaultListenerPriority ifNil: [ self defaultListenerPriorityValue ]</body><body package="Opentalk-Core">defaultListenerPriority: aPriority"	aPriority &lt;SmallInteger&gt; default priority of the listening process"	defaultListenerPriority := aPriority</body><body package="Opentalk-Core">defaultListenerPriorityValue	^83</body></methods><methods><class-id>Opentalk.ConnectionListener class</class-id> <category>deprecation</category><body package="Opentalk-Core">listenerBacklog	self deprecated: #(#version '9.0' #use #defaultListenerBacklogValue).	^self defaultListenerBacklogValue</body><body package="Opentalk-Core">listenerPriority	self deprecated: #(#version '9.0' #use #defaultListenerPriorityValue).	^self defaultListenerPriorityValue</body></methods><methods><class-id>Opentalk.RequestDispatcher</class-id> <category>accessing</category><body package="Opentalk-Core">configuration	^configuration</body><body package="Opentalk-Core">manager	^manager</body><body package="Opentalk-Core">manager: anAdaptor	"... called in 'BasicObjectAdaptor&gt;&gt;initialize:'."	manager := anAdaptor</body><body package="Opentalk-Core">workerPriority	"The incoming message server process priority."	^workerPriority ifNil: [		configuration workerPriority ifNil: [			self class defaultWorkerPriority ] ]</body><body package="Opentalk-Core">workerPriority: anInteger	workerPriority := anInteger</body></methods><methods><class-id>Opentalk.RequestDispatcher</class-id> <category>dispatch api</category><body package="Opentalk-Core">dispatchRequest: aRemoteRequest inBlock: aBlockClosure	self subclassResponsibility</body></methods><methods><class-id>Opentalk.RequestDispatcher</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize: aConfiguration	configuration := aConfiguration.</body></methods><methods><class-id>Opentalk.RequestDispatcher class</class-id> <category>instance creation</category><body package="Opentalk-Core">new: aConfiguration	^self new initialize: aConfiguration</body></methods><methods><class-id>Opentalk.RequestDispatcher class</class-id> <category>accessing</category><body package="Opentalk-Core">defaultWorkerPriority	^defaultWorkerPriority ifNil: [ self defaultWorkerPriorityValue ]</body><body package="Opentalk-Core">defaultWorkerPriority: anInteger"	anInteger &lt;SmallInteger&gt; the worker process priority"	defaultWorkerPriority := anInteger</body><body package="Opentalk-Core">defaultWorkerPriorityValue	^67</body></methods><methods><class-id>Opentalk.PoolRequestDispatcher</class-id> <category>accessing</category><body package="Opentalk-Core">processNumber	^processNumber ifNil:		[ processNumber := configuration processNumber ifNil:			[ self class defaultProcessNumber ] ]</body><body package="Opentalk-Core">processPool	^processPool</body></methods><methods><class-id>Opentalk.PoolRequestDispatcher</class-id> <category>private</category><body package="Opentalk-Core">doStart	super doStart.	self startProcesses</body><body package="Opentalk-Core">doStop	super doStop.	self stopProcesses</body></methods><methods><class-id>Opentalk.PoolRequestDispatcher</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize	sharedQueue := SharedQueue new: 17</body></methods><methods><class-id>Opentalk.PoolRequestDispatcher</class-id> <category>dispatch api</category><body package="Opentalk-Core">dispatchRequest: aRemoteRequest inBlock: aBlockClosure	sharedQueue nextPut: aBlockClosure</body><body package="Opentalk-Core">processBody	^[ [ true ] whileTrue: [ ( sharedQueue next ) value ] ]</body></methods><methods><class-id>Opentalk.PoolRequestDispatcher</class-id> <category>process api</category><body package="Opentalk-Core">startProcesses	processPool ifNil:		[	processPool := Array new: self processNumber.			1 to: self processNumber do:				[ :n | processPool						at: n						put: ( self processBody forkAt: self workerPriority )				]		]</body><body package="Opentalk-Core">stopProcesses	processPool ifNotNil:		[	processPool do: [ :p | p terminate ].			processPool := nil		]</body></methods><methods><class-id>Opentalk.PoolRequestDispatcher class</class-id> <category>defaults</category><body package="Opentalk-Core">defaultProcessNumber		^defaultProcessNumber ifNil: [ self defaultProcessNumberValue ]</body><body package="Opentalk-Core">defaultProcessNumberValue	"... only a convenient value for testing."	^3</body></methods><methods><class-id>Opentalk.RestartProtocolConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">autoRestart	"Should the component start automatically?"	^autoRestart</body><body package="Opentalk-Core">autoRestart: aSymbol	"Should the component start automatically?  The permitted values are #always, #never, and #ifQuiescent."	autoRestart := aSymbol</body><body package="Opentalk-Core">id	^id</body><body package="Opentalk-Core">id: aSymbol	"... the component ID to be used as the in the global opentalk component registry."	id := aSymbol</body></methods><methods><class-id>Opentalk.BrokerConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">adaptor	^adaptor</body><body package="Opentalk-Core">adaptor: aConfiguration	adaptor := aConfiguration</body><body package="Opentalk-Core">requestTimeout	^requestTimeout</body><body package="Opentalk-Core">requestTimeout: anInteger"How many milliseconds to wait for a response"	requestTimeout := anInteger</body></methods><methods><class-id>Opentalk.BrokerConfiguration</class-id> <category>component building</category><body package="Opentalk-Core">newAt: anAccessPoint	adaptor accessPoint: anAccessPoint.	^self new</body><body package="Opentalk-Core">newAtPort: aNumber	adaptor accessPointPort: aNumber.	^self new</body></methods><methods><class-id>Opentalk.BrokerConfiguration class</class-id> <category>types</category><body package="Opentalk-Core">basic	^BasicBrokerConfiguration new</body><body package="Opentalk-Core">standard	^StandardBrokerConfiguration new</body></methods><methods><class-id>Opentalk.BasicBrokerConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^BasicRequestBroker</body></methods><methods><class-id>Opentalk.StandardBrokerConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^RequestBroker</body></methods><methods><class-id>Opentalk.TransportPackageBytes</class-id> <category>accessing</category><body package="Opentalk-Core">byteOrder	"return the byte ordering of the message"	^((self byteAt: 7) bitAnd: 1)		== 1</body><body package="Opentalk-Core">byteOrder: aBoolean 	"set the byte ordering of the message"	self byteAt: 7 put: (aBoolean					ifTrue: [(self byteAt: 7) bitOr: 1]					ifFalse: [(self byteAt: 7) bitAnd: 254])</body><body package="Opentalk-Core">fragment	"Return false if this is the last fragment"	^((self byteAt: 7) bitAnd: 2) == 2</body><body package="Opentalk-Core">fragment: aBoolean 	"set the fragment flag"	self byteAt: 7 put: (aBoolean					ifTrue: [(self byteAt: 7) bitOr: 2]					ifFalse: [(self byteAt: 7) bitAnd: 253])</body><body package="Opentalk-Core">headerSize	^HeaderSize</body><body package="Opentalk-Core">magic	"return the magic byte array of the message"	^(ByteArray new: 4)		replaceBytesFrom: 1 to: 4 with: self startingAt: 1;		yourself</body><body package="Opentalk-Core">magic: aBytes	"set the magic byte array of the message"	self		replaceBytesFrom: 1		to: 4		with: aBytes		startingAt: 1</body><body package="Opentalk-Core">majorVersion	"return the major version number of the message"	^self byteAt: 5</body><body package="Opentalk-Core">majorVersion: aByte	"set the major version number of the message"	self byteAt: 5 put: aByte</body><body package="Opentalk-Core">minorVersion	"return the major version number of the message"	^self byteAt: 6</body><body package="Opentalk-Core">minorVersion: aByte	"set the minor version number of the message"	self byteAt: 6 put: aByte</body><body package="Opentalk-Core">msgSize	"return the size of the message"	| b0 b1 b2 w h byteIndex |	byteIndex := 9.	self isBigEndian		ifTrue:			[b0 := self byteAt: byteIndex.  			b1 := self byteAt: byteIndex+1.  			b2 := self byteAt: byteIndex+2.  			w := self byteAt: byteIndex+3]		ifFalse:			[b0 := self byteAt: byteIndex+3.  			b1 := self byteAt: byteIndex+2.  			b2 := self byteAt: byteIndex+1.  			w := self byteAt: byteIndex].	"Following sequence minimizes LargeInteger arithmetic for small results."	h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2=0 ifFalse: [w := (b2 bitShift: 8) + w].	h=0 ifFalse: [w := (h bitShift: 16) + w].	^w</body><body package="Opentalk-Core">msgSize: anInt 	"set the size of the message"	self swap		ifTrue: [ self isBigEndian			ifTrue: [ | half |				half := anInt bitShift: -16.				self at: 9 put: (half bitShift: -8).				self at: 10 put: (half bitAnd: 255).				half := anInt bitAnd: 65535.				self at: 11 put: (half bitShift: -8).				self at: 12 put: (half bitAnd: 255) ]			ifFalse: [ | remainder |				remainder := anInt.				9 to: 12 do: [ :i |					self at: i put: (remainder bitAnd: 255).					remainder := remainder bitShift: -8 ] ] ]		ifFalse: [ self longAt: 9 put: anInt ]</body><body package="Opentalk-Core">msgType	"... answers the type of the message."	^self byteAt: 8</body><body package="Opentalk-Core">msgType: anInt 	"set the type of the message"	^self byteAt: 8 put: anInt</body><body package="Opentalk-Core">totalSize	^self msgSize + self headerSize</body></methods><methods><class-id>Opentalk.TransportPackageBytes</class-id> <category>testing</category><body package="Opentalk-Core">isBigEndian	^self byteOrder not</body><body package="Opentalk-Core">isBigEnoughForMessageBody	^self size &gt;= self totalSize</body><body package="Opentalk-Core">isSystemVersion: aHeader	^self magic  = aHeader magic and:[	(self majorVersion = aHeader majorVersion) and: [	(self minorVersion = aHeader minorVersion) ]]</body><body package="Opentalk-Core">isValid	^self isSystemVersion: self class header</body><body package="Opentalk-Core">swap	"Return false if my endianess is same as the platform's endianess"	^self isBigEndian ~~ UninterpretedBytes isBigEndian</body></methods><methods><class-id>Opentalk.TransportPackageBytes</class-id> <category>initialize</category><body package="Opentalk-Core">initialize	"Initialize the receiver"	self majorVersion: 2.	self minorVersion: 0.	self magic: 'STST'.	self byteOrder: UninterpretedBytes isBigEndian not</body></methods><methods><class-id>Opentalk.TransportPackageBytes</class-id> <category>services</category><body package="Opentalk-Core">growToFitTheMessageBody	| new |	new := self class new: self totalSize.	new replaceFrom: 1 to: self headerSize with: self startingAt: 1.	self become: new</body></methods><methods><class-id>Opentalk.TransportPackageBytes class</class-id> <category>instance creation</category><body package="Opentalk-Core">header	^self new initialize</body><body package="Opentalk-Core">new	^super new: HeaderSize</body></methods><methods><class-id>Opentalk.TransportPackageBytes class</class-id> <category>class initialization</category><body package="Opentalk-Core">initialize	HeaderSize := 12.</body></methods><methods><class-id>Opentalk.TransportPackageBytes class</class-id> <category>accessing</category><body package="Opentalk-Core">headerSize	^HeaderSize</body></methods><methods><class-id>Opentalk.AdaptorConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">accessPoint	^accessPoint</body><body package="Opentalk-Core">accessPoint: anAccessPoint	accessPoint := anAccessPoint</body><body package="Opentalk-Core">accessPointPort: aNumber	self accessPoint: (IPSocketAddress thisHostPort: aNumber)</body><body package="Opentalk-Core">localityTest	^localityTest</body><body package="Opentalk-Core">localityTest: aBlock"	aBlock &lt;BlockClosure&gt; configurable test for locality of ObjRefs; the block takes an ObjRef and the adaptor as arguments and answers a Boolean"	localityTest := aBlock</body><body package="Opentalk-Core">processingPolicy	^processingPolicy</body><body package="Opentalk-Core">processingPolicy: aProcessingPolicy"	aProcessingPolicy &lt;ProcessingPolicy&gt;"	processingPolicy := aProcessingPolicy</body><body package="Opentalk-Core">requestDispatcher	^requestDispatcher</body><body package="Opentalk-Core">requestDispatcher: aConfiguration	requestDispatcher := aConfiguration</body><body package="Opentalk-Core">transport	^transport</body><body package="Opentalk-Core">transport: aConfiguration	transport := aConfiguration</body></methods><methods><class-id>Opentalk.AdaptorConfiguration</class-id> <category>component building</category><body package="Opentalk-Core">newAt: anAccessPoint"Used for creation of standalone adaptors"	self accessPoint: anAccessPoint.	^self new</body><body package="Opentalk-Core">newAtPort: aNumber"Used for creation of standalone adaptors"	self accessPointPort: aNumber.	^self new</body><body package="Opentalk-Core">newFor: aBroker"Used for adaptors within brokers"	^self componentClass new: self for: aBroker</body></methods><methods><class-id>Opentalk.AdaptorConfiguration</class-id> <category>private</category><body package="Opentalk-Core">transportFor: aRequest on: anAdaptor	^transport transportFor: aRequest on: anAdaptor</body></methods><methods><class-id>Opentalk.AdaptorConfiguration class</class-id> <category>types</category><body package="Opentalk-Core">asymmetricConnectionOriented"DEPRECATED! Use ConnectionAdaptor&gt;&gt;isBiDirectional parameter instead. So instead of	AdaptorConfiguration asymmetricConnectionOrienteduse	ConnectionAdaptorConfiguration new		isBiDirectional: false;"	^AsymmetricConnectionAdaptorConfiguration new</body><body package="Opentalk-Core">connectionLess	^ConnectionLessAdaptorConfiguration new</body><body package="Opentalk-Core">connectionOriented	^ConnectionAdaptorConfiguration new</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>private</category><body package="Opentalk-Core">accessLock	^accessLock</body><body package="Opentalk-Core">atIndex: index putKey: key andValue: anObject 	(keys at: index) == nil ifTrue: [		tally := tally + 1.		keys at: index put: key].	values at: index put: anObject.	^anObject</body><body package="Opentalk-Core">checkBound: aFloat	(aFloat &lt; 1 and: [ aFloat &gt; 0 ])		ifFalse: [ Warning raiseSignal: #BoundMustBeBetweenZeroAndOne &lt;&lt; #opentalk &gt;&gt; 'Bound must between 0 and 1!' ].</body><body package="Opentalk-Core">checkRatio: aNumber	aNumber &gt; 1 ifFalse: [ Warning raiseSignal: #RatioMustBeGreaterThanOne &lt;&lt; #opentalk &gt;&gt; 'Ratio must be greater than 1!' ].	self shrinkBound ifNotNil: [ :shrink || maximum |		maximum := self growBound / shrink.		aNumber &lt; maximum			ifFalse: [ Warning					raiseWith: (Array with: maximum)					errorPattern: #GrowthRatioMustBeAtMost1p &lt;&lt; #opentalk &gt;&gt; 'Grow ratio must be at most &lt;1p&gt;' ] ].</body><body package="Opentalk-Core">copyEmpty: aSize	"Answer a copy of the receiver that contains no elements.	This method should be redefined in subclasses that add	instance variables, so that the state of those variables	is preserved"	^(self class new: aSize)		shrinkBound: shrinkBound;		growBound: growBound;		shrinkRatio: shrinkRatio;		growRatio: growRatio;		minimumSize: minimumSize;		yourself</body><body package="Opentalk-Core">findKey: key ifAbsent: aBlock	"Look for the key in the receiver.  If it is found, answer	the index of the association containing the key, otherwise	answer the result of evaluating aBlock."		| index |	index := self findKeyOrNil: key.	(keys basicAt: index) == nil ifTrue: [^aBlock value].	^index</body><body package="Opentalk-Core">findKeyOrNil: key 	"Look for the key in the receiver. If it is found, answer 	the index of the association containing the key, otherwise 	answer the index of the first unused slot."	| location length probe pass |	length := keys size.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.		[probe := keys at: location.	probe == 0 ifTrue: [values at: location put: 0].	probe == nil or: [probe == key]]		whileFalse: [(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body><body package="Opentalk-Core">initialIndexFor: aHashValue boundedBy: length 	"Find the place where we should start the search. 	Optimize for relatively small dictionaries."	"For very large dictionaries, spread out the hash."	| maxHash |	maxHash := ObjectMemory maximumIdentityHashValue.	length &gt; maxHash ifTrue: [^aHashValue * (length // maxHash + 1) \\ length + 1].	^aHashValue \\ length + 1</body><body package="Opentalk-Core">keyNotFoundError: key	"Raise a signal indicating that the key was	not found."	^Dictionary keyNotFoundSignal raiseWith: key</body><body package="Opentalk-Core">rehash	self changeCapacityTo: self capacity</body><body package="Opentalk-Core">representBinaryOn: binWriter	" Represent a Dictionary by its elements	(Associations). "	^MessageSend		receiver: self class		selector: #withAll:		argument: self associations asArray</body><body package="Opentalk-Core">swap: nextIndex with: oldIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| k v |	k := keys at: oldIndex.	v := values at: oldIndex.	keys at: oldIndex put: (keys at: nextIndex).	values at: oldIndex put: (values at: nextIndex).	keys at: nextIndex put: k.	values at: nextIndex put: v</body><body package="Opentalk-Core">tally	^tally</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>user interface</category><body package="Opentalk-Core">inspect	"Create and schedule a DictionaryInspector in which the user can examine the	receiver's variables."	| insp |	insp := Smalltalk at: #DictionaryInspector ifAbsent: [^super inspect].	Cursor wait showWhile: [insp openOn: self]</body><body package="Opentalk-Core">inspectorClassName	^#DictionaryInspector</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>accessing</category><body package="Opentalk-Core">associations	"Answer an OrderedCollection containing the receiver's associations in an 	arbitrary order."	| aCollection |	aCollection := OrderedCollection new: tally.	self associationsDo: [:assn | aCollection add: assn].	^aCollection</body><body package="Opentalk-Core">at: key 	"Answer the value at key.  If key is not found, raise a signal."	^self at: key ifAbsent: [self keyNotFoundError: key]</body><body package="Opentalk-Core">at: key ifAbsent: aBlock 	"Answer the value at key. If key is not found, answer the 	result of evaluating aBlock."	(key == nil or: [key == 0]) ifTrue: [^self subscriptBoundsError: key].	^self accessLock critical: [ | index k v |		index := self findKeyOrNil: key.		k := keys at: index.		(k isNil or: [k == 0 or: [(v := values at: index) == 0]])			ifTrue: [aBlock value]			ifFalse: [v]]</body><body package="Opentalk-Core">at: key ifAbsentPut: valueBlock 	"Answer the value at key.  If key is not found, create a new	entry for key, set its value to be the result of evaluating	valueBlock, and answer that value."	(key == nil or: [key == 0]) ifTrue: [^self subscriptBoundsError: key].	^self accessLock critical: [ | index k v |		index := self findKeyOrNil: key.		k := keys at: index.		(k isNil or: [k == 0 or: [(v := values at: index) == 0]])			ifTrue: [ | value |				(value := valueBlock value) == 0					ifTrue: [ self error: (#InvalidValue &lt;&lt; #opentalk &gt;&gt; 'Invalid value') ]					ifFalse: [						tally * 2 &gt; keys size ifTrue: [							self grow.							index := self findKeyOrNil: key ].						 self atIndex: index putKey: key andValue: value ] ]			ifFalse: [v]]</body><body package="Opentalk-Core">at: key put: anObject 	"Set the value at key to be anObject. If key is not found, create a new 	entry for key and set is value to anObject. Answer anObject."	(key == nil or: [ key == 0 ]) ifTrue: [^self subscriptBoundsError: key].	anObject == 0 ifTrue: [^self error: (#InvalidValue &lt;&lt; #opentalk &gt;&gt; 'Invalid value')].	^self accessLock critical: [ | index |		tally * 2 &gt; keys size ifTrue: [self grow].		index := self findKeyOrNil: key.		self atIndex: index putKey: key andValue: anObject ]</body><body package="Opentalk-Core">capacity	^keys capacity</body><body package="Opentalk-Core">keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key whose value is identical to the argument, value.  	If there is none, answer the result of evaluating exceptionBlock." 	self keysAndValuesDo: 		[:aKey :aValue | value == aValue ifTrue: [^aKey]].	^exceptionBlock value</body><body package="Opentalk-Core">keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value is identical to the argument, value.  	If there is none, answer the result of evaluating exceptionBlock." 	self keysAndValuesDo: 		[:aKey :aValue | value == aValue ifTrue: [^aKey]].	^exceptionBlock value</body><body package="Opentalk-Core">keys	^self accessLock		critical: 			[| keyList |			keyList := OrderedCollection new: tally.			1 to: keys size				do: 					[:index | 					| key |					key := keys at: index.					(key isNil or: [key == 0 or: [(values at: index)								== 0]])						ifFalse: [keyList add: key]].			^keyList]</body><body package="Opentalk-Core">size	^tally</body><body package="Opentalk-Core">values	^self accessLock		critical: 			[| valList |			valList := OrderedCollection new: tally.			1 to: values size				do: 					[:index | 					| val key |					key := keys at: index.					(key isNil or: [key == 0 or: [(val := values at: index) == 0]])						ifFalse: [valList add: val]].			^valList]</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>initialize-release</category><body package="Opentalk-Core">accessLock: aRecursionLock	accessLock := aRecursionLock</body><body package="Opentalk-Core">initSize: aSize 	keys := WeakArray new: aSize.	values := Array new: aSize.	tally := 0.	self accessLock: RecursionLock new.	"To allow disabling shrinking, the default is only applied during instance creation. If it is subsequently nilled out then shrinking is disabled."	shrinkBound := self class defaultShrinkBound.	self makeDependent</body><body package="Opentalk-Core">makeDependent	keys addDependent: self.</body><body package="Opentalk-Core">release	keys release.	values release.	super release.</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>enumerating</category><body package="Opentalk-Core">associationsDo: aBlock 	"Evaluate aBlock for associations consisting of the receiver's keys and 	their values."	self keysAndValuesDo: [ :key :val | aBlock value: key -&gt; val ]</body><body package="Opentalk-Core">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection.	 Answer the new collection."	| newCollection |	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection</body><body package="Opentalk-Core">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="Opentalk-Core">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the 	argument."	self keysAndValuesDo: [ :key :val | aBlock value: val ]</body><body package="Opentalk-Core">keysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	self accessLock		critical: 			[tally = 0 ifTrue: [^self].			1 to: keys size do: 				[:index | 				| key val |				(((key := keys at: index) == nil or: [key == 0])					or: [(val := values at: index) == 0])					ifFalse: [aBlock value: key value: val]]]</body><body package="Opentalk-Core">keysDo: aBlockClosure 	self keysAndValuesDo: [ :key :value | aBlockClosure value: key ]</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>private-finalization/growth</category><body package="Opentalk-Core">changeCapacityTo: newCapacity "Change the size of the receiver to newCapacity. The receiver will re-grow to fit its contents if necessary.Note that this is used in rehashing -- don't optimize the case where the receiver does not change in size."	self accessLock critical: [ | newSelf |		newSelf := self copyEmpty: newCapacity.		newSelf accessLock: self accessLock.		1 to: keys size do: [ :index || key val |			key := keys at: index.			(key isNil or: [key == 0 or: [(val := values at: index) == 0]])				ifFalse: [newSelf privateAt: key put: val]].		self release.		newSelf release.		self become: newSelf.		self makeDependent]</body><body package="Opentalk-Core">finalizeElements	"Reclaim the slots containing dead objects."	self accessLock critical: [		keys isNil ifFalse: [			self reclaimElements.			self shrinkBound				ifNil: [ self rehash ]				ifNotNil: [ :bound |					self tally / self capacity &lt; bound						ifTrue: [ self privateShrink ]						ifFalse: [ self rehash ] ] ] ]</body><body package="Opentalk-Core">grow	"The receiver becomes roomier."	"Reclaim elements to get an accurate 'tally' before the grow."	self reclaimElements.	self tally / self capacity &gt; self growBound		ifTrue: [ self privateGrow ]		ifFalse: [ self rehash ]</body><body package="Opentalk-Core">privateAt: key put: anObject 	"Set the value at key to be anObject. If key is not found, create a new 	entry for key and set is value to anObject. Answer anObject."	| index element |	index := self findKeyOrNil: key.	element := values at: index.	element == nil ifTrue: [tally := tally + 1].	keys at: index put: key.	values at: index put: anObject.	^anObject</body><body package="Opentalk-Core">privateGrow	"The receiver becomes roomier."	"To prevent collapsing down to zero the capacity	should have a delta above the multiplied size.  41	is a arbitrary number designed to (hopefully more	frequently then a round number) be prime when	added to the multiplied size.  5 is picked as the	multiplier also rather arbitrarily, hopefully it is big	enough that grows won't happen too often, while	not making the dictionary too big."	"self changeCapacityTo: (41 + (tally * 5))"	self changeCapacityTo: (self minimumSize max: (self capacity * self growRatio) floor )</body><body package="Opentalk-Core">privateShrink	self shrinkRatio ifNotNil: [		self changeCapacityTo: (			self minimumSize max: (self capacity / self shrinkRatio) floor ) ]</body><body package="Opentalk-Core">reclaimElements	| tombstone size |	size := keys size.	tombstone := 1.	[	(tombstone := keys indexOf: 0 replaceWith: nil startingAt: tombstone stoppingAt: size)				== 0	] whileFalse: [		values at: tombstone put: nil.		tally := tally - 1 ]</body><body package="Opentalk-Core">update: anAspectSymbol with: aParameter from: aSender 	"Finalize all finalizable entries of aSender."	(aSender == keys and: [anAspectSymbol = #ElementExpired])		ifTrue: [self finalizeElements]		ifFalse: [^self]</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>adding</category><body package="Opentalk-Core">add: anAssociation 	"Include anAssociation as one of the receiver's elements. Answer 	anAssociation."	self at: anAssociation key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>removing</category><body package="Opentalk-Core">notFoundError	"Raise a signal indicating that an object is not in the collection."	^Collection notFoundSignal raise</body><body package="Opentalk-Core">remove: anObject ifAbsent: exceptionBlock 	"Provide an error notification that Dictionaries can not respond to	remove: messages."	self shouldNotImplement</body><body package="Opentalk-Core">removeKey: key 	"Remove key from the receiver.  If key is not in the receiver, raise a signal.  Otherwise, answer the value associated with key."	^self removeKey: key ifAbsent: [self keyNotFoundError: key]</body><body package="Opentalk-Core">removeKey: key ifAbsent: aBlock 	"Remove key from the receiver. If key is not in the receiver, 	answer the result of evaluating aBlock. Otherwise, answer the value 	associated with key."	^self accessLock		critical: 			[| index element |			index := self findKey: key ifAbsent: [nil].			index isNil				ifTrue: [aBlock value]				ifFalse: 					[element := values at: index.					keys at: index put: 0.					values at: index put: 0.					element]]</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>testing</category><body package="Opentalk-Core">includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	^self accessLock critical: [ (keys at: (self findKeyOrNil: key)) = key ]</body><body package="Opentalk-Core">isEmpty	^tally isZero</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary</class-id> <category>accessing - growth parameters</category><body package="Opentalk-Core">growBound	^growBound ifNil: [ self class defaultGrowBound ]</body><body package="Opentalk-Core">growBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should grow"	| new |	new := aFloat			ifNil: [ self class defaultGrowBound ]			ifNotNil: [ self checkBound: aFloat. aFloat ].	self shrinkBound ifNotNil: [ :shrink || minimum |		minimum := self growRatio * shrink.		new &gt; minimum			ifFalse: [ Warning					raiseWith: (Array with: minimum)					errorPattern: #GrowthBoundAtLeast1p &lt;&lt; #opentalk &gt;&gt; 'Growth bound must be at least &lt;1p&gt;' ] ].	growBound := aFloat</body><body package="Opentalk-Core">growRatio	^growRatio ifNil: [ self class defaultGrowRatio ]</body><body package="Opentalk-Core">growRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)"	| new |	new := aNumber ifNil: [ self class defaultGrowRatio ].	self checkRatio: new.	growRatio := aNumber</body><body package="Opentalk-Core">minimumSize	^minimumSize ifNil: [41]</body><body package="Opentalk-Core">minimumSize: anInteger"	anInteger &lt;Integer&gt; never shrink below this size (initialized to the original #new: paramater)"	minimumSize := anInteger</body><body package="Opentalk-Core">shrinkBound"To allow disabling shrinking, the default is only applied during instance creation. If it is subsequently nilled out then shrinking is disabled."	^shrinkBound</body><body package="Opentalk-Core">shrinkBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should shrink"	| maximum |	aFloat ifNil: [ shrinkBound := nil. ^self ].	self checkBound: aFloat.	maximum := self growBound / self shrinkRatio.	aFloat &lt; maximum		ifFalse: [ Warning				raiseWith: (Array with: maximum)				errorPattern: #ShrinkBoundAtMost1p &lt;&lt; #opentalk &gt;&gt; 'Shrink bound must be at most &lt;1p&gt;' ].	shrinkBound := aFloat</body><body package="Opentalk-Core">shrinkRatio	^shrinkRatio ifNil: [ self class defaultShrinkRatio ]</body><body package="Opentalk-Core">shrinkRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)"	| new |	new := aNumber ifNil: [ self class defaultShrinkRatio ].	self checkRatio: new.	shrinkRatio := aNumber</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary class</class-id> <category>instance creation</category><body package="Opentalk-Core">new	^self new: 100</body><body package="Opentalk-Core">new: aSize 	^super new initSize: (Dictionary goodSizeFrom: aSize)</body></methods><methods><class-id>Opentalk.OtWeakKeyDictionary class</class-id> <category>accessing - growth parameters</category><body package="Opentalk-Core">defaultGrowBound	^defaultGrowBound ifNil: [ self defaultGrowBoundValue ]</body><body package="Opentalk-Core">defaultGrowBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should grow"	defaultGrowBound := aFloat</body><body package="Opentalk-Core">defaultGrowBoundValue	^0.6</body><body package="Opentalk-Core">defaultGrowRatio	^defaultGrowRatio ifNil: [ self defaultGrowRatioValue ]</body><body package="Opentalk-Core">defaultGrowRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)"	defaultGrowRatio := aNumber</body><body package="Opentalk-Core">defaultGrowRatioValue	^2</body><body package="Opentalk-Core">defaultShrinkBound	^defaultShrinkBound ifNil: [ self defaultShrinkBoundValue ]</body><body package="Opentalk-Core">defaultShrinkBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should shrink"	defaultShrinkBound := aFloat</body><body package="Opentalk-Core">defaultShrinkBoundValue	^0.1</body><body package="Opentalk-Core">defaultShrinkRatio		^defaultShrinkRatio ifNil: [ self defaultShrinkRatioValue ]</body><body package="Opentalk-Core">defaultShrinkRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)"	defaultShrinkRatio := aNumber</body><body package="Opentalk-Core">defaultShrinkRatioValue		^3</body></methods><methods><class-id>Opentalk.OtWeakValueDictionary</class-id> <category>updating</category><body package="Opentalk-Core">update: anAspectSymbol with: aParameter from: aSender 	"Finalize all finalizable entries of aSender."	(aSender == values and: [anAspectSymbol = #ElementExpired])		ifTrue: [self finalizeElements]		ifFalse: [^self]</body></methods><methods><class-id>Opentalk.OtWeakValueDictionary</class-id> <category>private</category><body package="Opentalk-Core">findKeyOrNil: key 	"Look for the key in the receiver. If it is found, answer 	the index of the association containing the key, otherwise 	answer the index of the first unused slot."	| location length probe pass |	length := keys size.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.		[probe := keys at: location.	(values at: location) == 0		ifTrue: 			[keys at: location put: 0.			probe := 0].	probe == nil or: [probe = key]]		whileFalse: [(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>Opentalk.OtWeakValueDictionary</class-id> <category>initialize-release</category><body package="Opentalk-Core">initSize: aSize 	keys := Array new: aSize.	values := WeakArray new: aSize.	tally := 0.	self accessLock: RecursionLock new.	shrinkBound := self class defaultShrinkBound.	self makeDependent</body><body package="Opentalk-Core">makeDependent	values addDependent: self</body></methods><methods><class-id>Opentalk.OtWeakValueDictionary</class-id> <category>private-finalization/growth</category><body package="Opentalk-Core">reclaimElements"Reclamation can break hash bucket chains, it MUST BE FOLLOWED by rehash!!!!"	| deathMarker size |	size := values basicSize.	deathMarker := 1.	[deathMarker ~= 0]		whileTrue: [(deathMarker := values						indexOf: 0						replaceWith: nil						startingAt: deathMarker						stoppingAt: size) == 0				ifFalse: 					[keys at: deathMarker put: nil.					tally := tally - 1]]</body></methods><methods><class-id>Opentalk.Marshaler</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize: aConfiguration	configuration := aConfiguration</body><body package="Opentalk-Core">setManager: aConnectionManager 	manager := aConnectionManager</body></methods><methods><class-id>Opentalk.Marshaler</class-id> <category>accessing</category><body package="Opentalk-Core">adaptor	^manager manager</body><body package="Opentalk-Core">broker	^self adaptor orb</body><body package="Opentalk-Core">configuration	^configuration</body><body package="Opentalk-Core">manager	^manager</body><body package="Opentalk-Core">processingPolicy	^self adaptor processingPolicy</body><body package="Opentalk-Core">transport	^manager</body></methods><methods><class-id>Opentalk.Marshaler</class-id> <category>marshaling</category><body package="Opentalk-Core">marshalTransportPayloadOf: aMessage into: aTransportPackage	^self subclassResponsibility</body><body package="Opentalk-Core">unmarshalTransportPayloadFrom: aTransportPackage	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.Marshaler class</class-id> <category>instance creation</category><body package="Opentalk-Core">new: aConfiguration	^self new initialize: aConfiguration</body></methods><methods><class-id>Opentalk.Marshaler class</class-id> <category>accessing</category><body package="Opentalk-Core">requestClass	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.HighLowRequestDispatcher</class-id> <category>accessing</category><body package="Opentalk-Core">discriminationBlock	^discriminationBlock ifNil:		[ discriminationBlock := configuration discriminationBlock ifNil:			[ self class defaultDiscriminationBlock ] ]</body><body package="Opentalk-Core">highPriority	^highPriority ifNil:		[ highPriority := configuration highPriority ifNil:			[ self class defaultHighPriority ] ]</body></methods><methods><class-id>Opentalk.HighLowRequestDispatcher</class-id> <category>dispatch api</category><body package="Opentalk-Core">dispatchRequest: aRemoteRequest inBlock: aBlockClosure	aBlockClosure forkAt:		( ( self discriminationBlock value: aRemoteRequest )			ifTrue:	[ self highPriority ]			ifFalse:	[ self workerPriority ] )</body></methods><methods><class-id>Opentalk.HighLowRequestDispatcher class</class-id> <category>defaults</category><body package="Opentalk-Core">defaultDiscriminationBlock		^defaultDiscriminationBlock ifNil: [ self defaultDiscriminationBlockValue ]</body><body package="Opentalk-Core">defaultDiscriminationBlockValue	"... the default block for discrimination between high and normal priority processes, which answers true if the message selector matches '*high*'."	^[ :remoteRequest | '*high*' match: remoteRequest message selector ]</body><body package="Opentalk-Core">defaultHighPriority		^defaultHighPriority ifNil: [ self defaultHighPriorityValue ]</body><body package="Opentalk-Core">defaultHighPriorityValue	"... the prime between the default worker priority (67) and the default server process priority (73)."	^71</body></methods><methods><class-id>Opentalk.OtETimeout</class-id> <category>accessing</category><body package="Opentalk-Core">request	^request</body><body package="Opentalk-Core">request: anObject	request := anObject</body><body package="Opentalk-Core">transport	^transport</body><body package="Opentalk-Core">transport: anObject	transport := anObject</body></methods><methods><class-id>Opentalk.OtETimeout class</class-id> <category>testing</category><body package="Opentalk-Core">mayResume	^true</body></methods><methods><class-id>Opentalk.RemoteMessage</class-id> <category>accessing</category><body package="Opentalk-Core">interceptorDispatcher	^interceptorDispatcher</body><body package="Opentalk-Core">interceptorDispatcher: anInterceptorDispatcher	interceptorDispatcher := anInterceptorDispatcher</body><body package="Opentalk-Core">msgType	^self class msgType</body><body package="Opentalk-Core">requestId	^requestId</body><body package="Opentalk-Core">requestId: aNumber	requestId := aNumber</body></methods><methods><class-id>Opentalk.RemoteMessage</class-id> <category>printing</category><body package="Opentalk-Core">printOn: aStream	aStream		nextPutAll: self typeTag;		nextPut: $[;		print: requestId;		nextPut: $]</body><body package="Opentalk-Core">typeTag	^self class name</body></methods><methods><class-id>Opentalk.RemoteMessage</class-id> <category>testing</category><body package="Opentalk-Core">isReply	^false</body></methods><methods><class-id>Opentalk.RemoteMessage</class-id> <category>dispatching</category><body package="Opentalk-Core">dispatchFor: aConnection	[	self evaluateFor: aConnection	]	on: Error		do: [ :ex | self handleEvaluationError: ex in: aConnection ]</body><body package="Opentalk-Core">evaluateFor: aTransport	"... evaluate the package for aTransport. ... 	may return the result through aTransport."	self evaluatingMessageIn: aTransport</body><body package="Opentalk-Core">handleEvaluationError: anError in: aConnection	self evaluatingMessageIn: aConnection failedBecause: anError</body></methods><methods><class-id>Opentalk.RemoteMessage</class-id> <category>events-message processing</category><body package="Opentalk-Core">evaluatingMessageIn: aTransport	aTransport manager evaluatingMessage: self in: aTransport</body><body package="Opentalk-Core">evaluatingMessageIn: aConnection failedBecause: anError	aConnection manager evaluatingMessage: self in: aConnection failedBecause: anError</body></methods><methods><class-id>Opentalk.RemoteMessage class</class-id> <category>accessing</category><body package="Opentalk-Core">msgType	"... answers anInteger, the type of the message."	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.RemoteReply</class-id> <category>accessing</category><body package="Opentalk-Core">reply	^reply</body><body package="Opentalk-Core">reply: anObject	reply := anObject</body></methods><methods><class-id>Opentalk.RemoteReply</class-id> <category>dispatching</category><body package="Opentalk-Core">evaluateFor: aTransport	"Lookup the sender and return self to the sender."	| request |	"If I do this I screw up distributed debugger because it relies on the possiblity for a request	to receive multiple replies. If it's unregistered, the subsequent replies won't find it.	Be REALLY careful, it took me hours to figure this one out.	request := aTransport unregisterRequestById: self requestId."	request := aTransport requestById: self requestId.	request isNil		ifTrue: [ self receivedOrphanReplyIn: aTransport ]		ifFalse: [ "In the SOAP land the reply can't be fully unmarshaled until it's linked to the corresponding request.			Triggerring #evaluatingMessage:in: with such incomplete message is giving me hard time with support			for header processing using broker events. This adds a new dispatch allowing us to complete the unmarshaling			before the event is triggered."			request prepareReply: self for: aTransport.			super evaluateFor: aTransport.			request returnWith: self ]	"We use a triple dispatch technique here:	In the objectAdapter thread, theReturnPackage send &lt;returnWith: self&gt; to theRequestPackage to wakeup the calling thread.	In the calling thread, theRequestPackage send &lt;getReturnValueFor: self&gt; back to theReturnPackge.		If theReturnPackage is a ReturnPacakge it just return the reply		If theReturnPackage is a ErrorReturnPackage it send &lt;returnRemoteException: aRemtoeException&gt; back to theRequestPackage		to handle the remoteException.			If theRequest is a RequestPackage, an OtEServerError is raised.			if theRequest is a DebuggableRequestPackage, an OtERemtoeException is raise which allows distributed debugging."</body><body package="Opentalk-Core">getReturnValueFor: aRequestPackage	"In the caller's thread, return the reply"	^reply</body></methods><methods><class-id>Opentalk.RemoteReply</class-id> <category>printing</category><body package="Opentalk-Core">printOn: aStream	super printOn: aStream.	aStream nextPut: ${.	self printReplyOn: aStream.	aStream nextPut: $}</body><body package="Opentalk-Core">printReplyOn: aStream	reply _isRemote		ifTrue: [ reply _printOn: aStream ]		ifFalse: [ reply printOn: aStream ]</body></methods><methods><class-id>Opentalk.RemoteReply</class-id> <category>testing</category><body package="Opentalk-Core">failed	^reply _isRemote not and: [ reply isSignalledException ]</body><body package="Opentalk-Core">isReply	^true</body><body package="Opentalk-Core">succeeded	^self failed not</body></methods><methods><class-id>Opentalk.RemoteReply</class-id> <category>events-message processing</category><body package="Opentalk-Core">receivedOrphanReplyIn: aTransport	aTransport manager receivedOrphanReply: self in: aTransport</body><body package="Opentalk-Core">receivingMessageIn: aTransport	aTransport manager receivingReply: self in: aTransport</body><body package="Opentalk-Core">sendingMessageIn: aTransport	aTransport manager sendingReply: self in: aTransport</body></methods><methods><class-id>Opentalk.RemoteReply</class-id> <category>invocation</category><body package="Opentalk-Core">send: aTransport	aTransport sendPackage: self</body></methods><methods><class-id>Opentalk.RemoteReply class</class-id> <category>instance creation</category><body package="Opentalk-Core">return: anObject	^self new		reply: anObject; 		yourself</body></methods><methods><class-id>Opentalk.ConnectionLessAdaptorConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^ConnectionLessAdaptor</body></methods><methods><class-id>Opentalk.TransportPackage</class-id> <category>accessing</category><body package="Opentalk-Core">buffer	^buffer</body><body package="Opentalk-Core">buffer: aTransportPackageBytes	buffer := aTransportPackageBytes</body><body package="Opentalk-Core">byteOrder	^buffer byteOrder</body><body package="Opentalk-Core">headerSize	^buffer headerSize</body><body package="Opentalk-Core">msgSize	^buffer msgSize</body><body package="Opentalk-Core">msgSize: anInteger	buffer msgSize: anInteger</body><body package="Opentalk-Core">msgType	^buffer msgType</body><body package="Opentalk-Core">msgType: anInteger	buffer msgType: anInteger</body><body package="Opentalk-Core">peerAccessPoint	^peer</body><body package="Opentalk-Core">peerAccessPoint: anAccessPoint	peer := anAccessPoint</body><body package="Opentalk-Core">position	^position</body><body package="Opentalk-Core">position: anInteger	position := anInteger</body><body package="Opentalk-Core">size	^buffer msgSize</body><body package="Opentalk-Core">swap	^buffer swap</body></methods><methods><class-id>Opentalk.TransportPackage</class-id> <category>initialization</category><body package="Opentalk-Core">initialize: aBuffer	buffer := aBuffer.	position := aBuffer headerSize</body></methods><methods><class-id>Opentalk.TransportPackage class</class-id> <category>instance creation</category><body package="Opentalk-Core">newOn: aBuffer	^self new initialize: aBuffer</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>local-testing</category><body package="Opentalk-Core">_isRemote	"A local remote object is always elsewhere."	^true</body><body package="Opentalk-Core">isNil	"Nil is always passed by value, so aRemoteObject is never nil"	^false</body><body package="Opentalk-Core">isVariableBinding	"The receiver can never be aVariableBinding because aVariableBinding is 	always passed by value.  The is a critical safeguard that prevents remote 	call recursion in ProcessEnvironment."	^false</body><body package="Opentalk-Core">notNil	"Nil is always passed by value, so aRemoteObject is never nil."	^true</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>local-accessing</category><body package="Opentalk-Core">_accessPoint	^objRef accessPoint</body><body package="Opentalk-Core">_changeORB: anORB	requestBroker := anORB</body><body package="Opentalk-Core">_objectAdaptor	^requestBroker objectAdaptor</body><body package="Opentalk-Core">_remoteHostName	^objRef hostName</body><body package="Opentalk-Core">_requestBroker	^requestBroker</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>local-printing</category><body package="Opentalk-Core">_printOn: aStream	aStream nextPutAll: (#RemoteObject &lt;&lt; #opentalk &gt;&gt; 'RemoteObject') asString; nextPut: $&lt;.	objRef printAccessInfoOn: aStream.	aStream nextPut: $&gt;</body><body package="Opentalk-Core">_printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self _printOn: aStream.	^aStream contents</body><body package="Opentalk-Core">basicPrintString	^((#ARemote1s &lt;&lt; #opentalk &gt;&gt; 'A Remote &lt;1s&gt;')			expandMacrosWith: super basicPrintString)</body><body package="Opentalk-Core">displayString	"Answer a String whose characters are a description of the receiver."	^( InputState default shiftDown )		ifTrue:	[ self _printString ]		ifFalse:	[self _remoteHostName, '::', (  super displayString ) ]</body><body package="Opentalk-Core">printOn: aStream	"Passing a local stream and doing the remote streaming is very expensive, 	so we do a remote printString instead."	aStream nextPutAll: self printString</body><body package="Opentalk-Core">printString	"Answer a String whose characters are a description of the receiver."	^( PrintUsingHostAddress )		ifTrue:	[ self _printString ]		ifFalse:	[self _remoteHostName, '::', (  super printString ) ]</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>initialize-release</category><body package="Opentalk-Core">_initializeWith: anObject requestBroker: anORB 	self _initializeWith: anObject.	requestBroker := anORB.</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>local-dependents</category><body package="Opentalk-Core">addDependent: anObject 	"If anObject is the first local dependent of the remote object, then create 	aLocalDependents as the dependent and add it to the remote object's 	dependents.  Then add anObject to my dependents.  This is an optimization 	to prevent adding each local dependents remotely, thus cutting the number 	of remote updates."	dependents size == 0		ifTrue: 			[dependents := LocalDependents new.			[super addDependent: dependents]				on: OtSystemException do: [:ex | ]].	dependents add: anObject.	^anObject</body><body package="Opentalk-Core">dependents 	"Answer a Collection of the local objects that are dependent on the receiver, 	that is, of the objects that should be notified if the receiver changes."	^dependents == nil		ifTrue:[#()]		ifFalse:[DependentsCollection withAll: dependents]</body><body package="Opentalk-Core">myDependents	"Answer the receiver's dependents or nil."	^self dependents</body><body package="Opentalk-Core">myDependents: dependentsOrNil	"Set the receivers dependents."	dependentsOrNil == nil		ifTrue:[dependents == nil				ifFalse:[dependents copy do: [:d | self removeDependent: d]]]		ifFalse:[dependentsOrNil do: [:d | self addDependent: d]]</body><body package="Opentalk-Core">removeDependent: anObject	dependents == nil ifTrue: [^self].	dependents remove: anObject ifAbsent: [].	dependents isEmpty ifTrue: [		[	super removeDependent: dependents.			dependents := nil		] on: OtSystemException do: [:ex | ]].	^anObject</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>local-tool-support</category><body package="Opentalk-Core">_inspect	"Inspect the components of this proxy."	( Dictionary new )		add: ( (#className &lt;&lt; #opentalk &gt;&gt; 'class name') -&gt; self _type name );		add: ( (#objectAdaptor &lt;&lt; #opentalk &gt;&gt; 'object adaptor') -&gt; requestBroker );		add: ( (#objectReference &lt;&lt; #opentalk &gt;&gt; 'object reference') -&gt; objRef );		inspect</body><body package="Opentalk-Core">basicInspect	"Inspecting is always done local to the object, where the object header is."	Cursor wait showWhile: [ Inspector openOn: self ]</body><body package="Opentalk-Core">basicInspectorClass	^Inspector</body><body package="Opentalk-Core">inspectorClass	"Always returns a local inspector class."	^self inspectorClassName asQualifiedReference valueOrDo: [ Inspector ]</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>class membership</category><body package="Opentalk-Core">changeClassTo: aClass	"Change the class of the receiver to aClass."	aClass adoptInstance: self.	^self</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>controlling</category><body package="Opentalk-Core">ifNil: aBlock	^self</body><body package="Opentalk-Core">ifNil: nilBlock ifNotNil: notNilBlock	^( 0 == notNilBlock numArgs )		ifTrue:	[ notNilBlock value]		ifFalse:	[ notNilBlock value: self ]</body><body package="Opentalk-Core">ifNotNil: aBlock	^( 0 == aBlock numArgs )		ifTrue:	[ aBlock value ]		ifFalse:	[ aBlock value: self ]</body><body package="Opentalk-Core">ifNotNil: notNilBlock ifNil: nilBlock	^( 0 == notNilBlock numArgs )		ifTrue:	[ notNilBlock value ]		ifFalse:	[ notNilBlock value: self ]</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>forwarding</category><body package="Opentalk-Core">_sendMessage: aMessage	^requestBroker sendMessage: aMessage to: objRef</body></methods><methods><class-id>Opentalk.RemoteObject class</class-id> <category>testing</category><body package="Opentalk-Core">isRemoteForwarder	^true</body></methods><methods><class-id>Opentalk.RemoteObject class</class-id> <category>instance-creation</category><body package="Opentalk-Core">newOn: anObject requestBroker: aORB	^( self new )		_initializeWith: anObject requestBroker: aORB</body><body package="Opentalk-Core">newOnOID: oid hostName: hn port: p requestBroker: aORB	| objRef |	objRef := ObjRef 				newOnHostName: hn				port: p				oid: oid.	^self newOn: objRef requestBroker: aORB</body></methods><methods><class-id>Opentalk.RemoteObject class</class-id> <category>class initialization</category><body package="Opentalk-Core">initialize	"((( self initialize )))"	PrintUsingHostAddress := true</body></methods><methods><class-id>Opentalk.RemoteObject class</class-id> <category>accessing</category><body package="Opentalk-Core">printUsingHostAddress	^PrintUsingHostAddress</body><body package="Opentalk-Core">printUsingHostAddress: aBoolean	PrintUsingHostAddress := aBoolean</body></methods><methods><class-id>Opentalk.SimpleTransportMessage</class-id> <category>accessing</category><body package="Opentalk-Core">buffer	^buffer</body><body package="Opentalk-Core">buffer: aByteArrayOrTransportPackageBytes	buffer := aByteArrayOrTransportPackageBytes</body><body package="Opentalk-Core">msgSize	^msgSize</body><body package="Opentalk-Core">msgSize: anInteger	msgSize := anInteger</body><body package="Opentalk-Core">peerAccessPoint	^peer</body><body package="Opentalk-Core">peerAccessPoint: anAccessPoint	peer := anAccessPoint</body><body package="Opentalk-Core">position	^position</body><body package="Opentalk-Core">position: anInteger	position := anInteger</body><body package="Opentalk-Core">size	^buffer size</body></methods><methods><class-id>Opentalk.SimpleTransportMessage</class-id> <category>initialization</category><body package="Opentalk-Core">initialize: aBuffer	buffer := aBuffer.	position := 0</body></methods><methods><class-id>Opentalk.SimpleTransportMessage class</class-id> <category>instance creation</category><body package="Opentalk-Core">newOn: aBuffer	^self new initialize: aBuffer</body></methods><methods><class-id>Opentalk.ConnectionLessAdaptor</class-id> <category>accessing</category><body package="Opentalk-Core">transport	^transport</body></methods><methods><class-id>Opentalk.ConnectionLessAdaptor</class-id> <category>private</category><body package="Opentalk-Core">accessPort	^self socketIsInactiveOrNil		ifTrue: [super accessPort]		ifFalse: [transport getSocketAddress port]</body><body package="Opentalk-Core">startServer	transport := self configuration transport				newAt: self accessPoint				for: self.	transport start.	super startServer. "Reset access point so that it reflects the actual access port"</body><body package="Opentalk-Core">transportFor: request id: transportId	transport registerRequest: request.	^transport</body></methods><methods><class-id>Opentalk.ConnectionLessAdaptor</class-id> <category>testing</category><body package="Opentalk-Core">socketIsInactiveOrNil	^transport isNil or: [ transport socketIsInactiveOrNil ]</body></methods><methods><class-id>Opentalk.ConnectionLessAdaptor</class-id> <category>protocol-API</category><body package="Opentalk-Core">doStop	super doStop.	transport notNil ifTrue: [		transport stop.		transport := nil ]</body><body package="Opentalk-Core">ping: ipAddress	"Ping the host at the ipAddress."	| objRef msg |	super ping: ipAddress.	objRef := ObjRef newOn: ipAddress oid: orb brokerId.	msg := SmalltalkMessage selector: #isRunning arguments: #().	[	self sendRequest: (			self requestClass 				newRequest: msg				to: objRef				timeout: 2000)	] on: Error do: [:ex| ^false].	^true</body></methods><methods><class-id>Opentalk.ProcessingPolicy</class-id> <category>accessing</category><body package="Opentalk-Core">adaptor	^adaptor</body><body package="Opentalk-Core">adaptor: anObjectAdaptor	adaptor := anObjectAdaptor</body><body package="Opentalk-Core">dispatcherClass	dispatcherClass ifNil: [ dispatcherClass := self class defaultDispatcherClass].	^dispatcherClass</body><body package="Opentalk-Core">dispatcherClass: aClass	dispatcherClass := aClass</body><body package="Opentalk-Core">interceptorClasses	^interceptorClasses ifNil: [ interceptorClasses := self class defaultInterceptorClasses ]</body><body package="Opentalk-Core">interceptorClasses: aCollectionOfMessageInterceptor	interceptorClasses := aCollectionOfMessageInterceptor</body><body package="Opentalk-Core">provideInterceptorDispatcher	^self dispatcherClass new		setInterceptors: ( self interceptorClasses collect: [ :each | each new] );		policy: self;		yourself</body></methods><methods><class-id>Opentalk.ProcessingPolicy</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize</body></methods><methods><class-id>Opentalk.ProcessingPolicy class</class-id> <category>defaults</category><body package="Opentalk-Core">defaultDispatcherClass	^defaultDispatcherClass ifNil: [defaultDispatcherClass := self defaultDispatcherClassValue ]</body><body package="Opentalk-Core">defaultDispatcherClass: aClass	defaultDispatcherClass := aClass</body><body package="Opentalk-Core">defaultInterceptorClasses	^defaultInterceptorClasses ifNil: [ self defaultInterceptorClassesValue ]</body><body package="Opentalk-Core">defaultInterceptorClasses: aClassOrCollection	defaultInterceptorClasses := (aClassOrCollection isSequenceable 		or: [aClassOrCollection isNil ])		ifTrue: [ 	aClassOrCollection ]		ifFalse: 	[ OrderedCollection with: aClassOrCollection ]</body></methods><methods><class-id>Opentalk.ProcessingPolicy class</class-id> <category>instance creation</category><body package="Opentalk-Core">new	^super new initialize</body></methods><methods><class-id>Opentalk.ProcessingPolicy class</class-id> <category>default values</category><body package="Opentalk-Core">defaultDispatcherClassValue	^InterceptorDispatcher</body><body package="Opentalk-Core">defaultInterceptorClassesValue 	^OrderedCollection new</body></methods><methods><class-id>Opentalk.Transport</class-id> <category>private</category><body package="Opentalk-Core">doStop	super doStop.	self stopServerProcess</body><body package="Opentalk-Core">export: anObject	^manager export: anObject.</body><body package="Opentalk-Core">marshaler	^marshaler</body><body package="Opentalk-Core">objectByRef: anObjRef	^self manager objectByRef: anObjRef</body><body package="Opentalk-Core">serverPriority	"The request accepting process priority."	^configuration serverPriority ifNil: [ self class defaultServerPriority ]</body><body package="Opentalk-Core">serverProcessBody	self subclassResponsibility</body><body package="Opentalk-Core">startServerProcess"... starts the request accepting process."	serverProcess := [self serverProcessBody] forkAt: self serverPriority</body><body package="Opentalk-Core">stopServerProcess	serverProcess isNil ifFalse: [		Processor activeProcess == serverProcess			"If we are not stopping within the server process exit handling then terminate it"			ifFalse: [ serverProcess terminate ].		serverProcess := nil].</body><body package="Opentalk-Core">unmarshaler	^unmarshaler</body></methods><methods><class-id>Opentalk.Transport</class-id> <category>protocol-API</category><body package="Opentalk-Core">doStart	super doStart.	self initializeSendLock.	self startServerProcess.</body><body package="Opentalk-Core">reset	super reset.	self initializeSendLock</body><body package="Opentalk-Core">stop	"Stop of the protocol FSM."	( self isStopped ) ifTrue: [ ^self ].	self preStop.	sendLock critical: [ self doStop ].	self postStop</body></methods><methods><class-id>Opentalk.Transport</class-id> <category>accessing</category><body package="Opentalk-Core">adaptor	^self manager</body><body package="Opentalk-Core">bufferSize	^configuration bufferSize ifNil: [		self class defaultBufferSize ]</body><body package="Opentalk-Core">configuration	^configuration</body><body package="Opentalk-Core">manager	"Answers the connection manager."	^manager</body><body package="Opentalk-Core">objectTable	^manager objectTable</body><body package="Opentalk-Core">orb	^self manager orb</body><body package="Opentalk-Core">processingPolicy	^self adaptor processingPolicy</body><body package="Opentalk-Core">protocolTag	^self class protocolTag</body></methods><methods><class-id>Opentalk.Transport</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize: aConfiguration	configuration := aConfiguration.	self initializeBuffers: self bufferSize.	self initializeSendLock</body><body package="Opentalk-Core">initializeBuffers: bufferSize	readBuffer := (TransportPackageBytes new: bufferSize) initialize.	writeBuffer := (TransportPackageBytes new: bufferSize) initialize.</body><body package="Opentalk-Core">initializeMarshalers	"Set up marshaler and unmarshaler"	| marshalerConfiguration |	(marshalerConfiguration := self configuration marshaler) notNil ifTrue: [		unmarshaler := marshalerConfiguration newFor: self.		marshaler  := marshalerConfiguration newFor: self ]</body><body package="Opentalk-Core">initializeSendLock	sendLock := RecursionLock new</body><body package="Opentalk-Core">setManager: aConnectionManager 	manager := aConnectionManager.	self initializeMarshalers.</body></methods><methods><class-id>Opentalk.Transport</class-id> <category>printing</category><body package="Opentalk-Core">printAccessInfoOn: aStream	aStream nextPutAll: self protocolTag</body><body package="Opentalk-Core">printOn: aStream	aStream nextPutAll: (#Transport &lt;&lt; #opentalk &gt;&gt; 'Transport') asString; nextPut: $&lt;.	self printAccessInfoOn: aStream.	aStream nextPut: $&gt;.</body></methods><methods><class-id>Opentalk.Transport class</class-id> <category>instance creation</category><body package="Opentalk-Core">new: aConfiguration	^self new initialize: aConfiguration</body></methods><methods><class-id>Opentalk.Transport class</class-id> <category>constants</category><body package="Opentalk-Core">serverPriority	"The request accepting process priority."	^73</body></methods><methods><class-id>Opentalk.Transport class</class-id> <category>defaults-accessing</category><body package="Opentalk-Core">defaultBufferSize	^defaultBufferSize ifNil: [		self defaultBufferSizeValue ]</body><body package="Opentalk-Core">defaultBufferSize: aSmallInteger	defaultBufferSize := aSmallInteger</body><body package="Opentalk-Core">defaultServerPriority	^defaultServerPriority ifNil: [ self defaultServerPriorityValue ]</body><body package="Opentalk-Core">defaultServerPriority: aPriority"	aPriority &lt;SmallInteger&gt; default priority of transport server process"	defaultServerPriority := aPriority</body></methods><methods><class-id>Opentalk.Transport class</class-id> <category>defaults-constants</category><body package="Opentalk-Core">defaultBufferSizeValue	^1024</body><body package="Opentalk-Core">defaultServerPriorityValue	^self serverPriority</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>request-registry</category><body package="Opentalk-Core">hasPendingRequests	^(requestRegistry detect: [ :request | request hasReply not ] ifNone: [ nil ]) notNil</body><body package="Opentalk-Core">newRequestId	"We hope that a request would not last long 	enough to permit the reuse of an id number."	^nextRequestId := ( nextRequestId + 1 ) \\ 536870911 max: 1.</body><body package="Opentalk-Core">registerRequest: aRequest	requestRegistry accessLock critical: [		"Need to extend the critical region somewhat to protect the id counter"		aRequest requestId isNil ifTrue: [aRequest requestId: self newRequestId].		requestRegistry at: aRequest requestId put: aRequest ]</body><body package="Opentalk-Core">requestById: rid	^requestRegistry 		at: rid 		ifAbsent: []</body><body package="Opentalk-Core">requestRegistry	^requestRegistry</body><body package="Opentalk-Core">unregisterRequest: aRequest	".. may not be necessary, but added in 	case the finalization is too late."	^requestRegistry 		removeKey: aRequest requestId 		ifAbsent: [nil]</body><body package="Opentalk-Core">unregisterRequestById: requestId	^requestRegistry 		removeKey: requestId 		ifAbsent: [nil]</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>private</category><body package="Opentalk-Core">clearSessionObjects	sessionObjects := Set new: 20.</body><body package="Opentalk-Core">createApplicationPackageFrom: aTransportPackage	^unmarshaler unmarshalTransportPayloadFrom: aTransportPackage</body><body package="Opentalk-Core">createTransportPackageFrom: aRemoteMessage	| transportPkg |	( transportPkg := TransportPackage newOn: writeBuffer )		msgType: aRemoteMessage msgType.	transportPkg := marshaler marshalTransportPayloadOf: aRemoteMessage into: transportPkg.	^transportPkg</body><body package="Opentalk-Core">export: anObject"Make exported objects to session persist to ensure that return values don't get garbage collected right away."	sessionObjects isNil ifFalse:[sessionObjects add: anObject].	^super export: anObject.</body><body package="Opentalk-Core">handleIncomingMessage: aRemoteMessage	aRemoteMessage dispatchFor: self</body><body package="Opentalk-Core">handleIncomingMessageError: anException	self handlingIncomingMessageFailedBecause: anException</body><body package="Opentalk-Core">handlingIncomingMessage"Get the next income package and dispatches it."	[	self handleIncomingMessage: self nextPackage	]	on: Error		do: [:ex | self handleIncomingMessageError: ex]</body><body package="Opentalk-Core">provideInterceptorDispatcher	^self processingPolicy provideInterceptorDispatcher</body><body package="Opentalk-Core">readTransportPackage	^self subclassResponsibility</body><body package="Opentalk-Core">readyToHandleIncomingMessage"Note that this will let the server process go straight into the incoming message handling routine.Possibly trying to read data that is not ready yet"	^self isRunning</body><body package="Opentalk-Core">receiveTransportPackage	| pkg |	pkg := self readTransportPackage.	self receivingPackage: pkg.	^pkg</body><body package="Opentalk-Core">sendTransportPackage: aTransportPackage	self sendingPackage: aTransportPackage</body><body package="Opentalk-Core">serverProcessBody	[ 	self readyToHandleIncomingMessage	] 	whileTrue: [self handlingIncomingMessage].	self serverProcessExiting</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>protocol-API</category><body package="Opentalk-Core">doStart	super doStart.	self clearSessionObjects</body><body package="Opentalk-Core">reset	super reset.	self initializeRequestRegistry</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize	super initialize.	self initializeRequestRegistry</body><body package="Opentalk-Core">initializeRequestRegistry	requestRegistry := OtWeakValueDictionary new.	nextRequestId := 0.</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>transport-API</category><body package="Opentalk-Core">nextPackage	^self createApplicationPackageFrom: self receiveTransportPackage</body><body package="Opentalk-Core">sendPackage: aRemoteMessage	sendLock critical: [		self sendTransportPackage: (			self createTransportPackageFrom: aRemoteMessage ) ]</body><body package="Opentalk-Core">sendPackage: aRemoteMessage onErrorDo: aBlock 	[self sendPackage: aRemoteMessage]		on: Error do: [:ex | aBlock value: ex].	"There are basically two kind of errors:		marshaling errors, and		communication errors"</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>events-transport activity</category><body package="Opentalk-Core">receivingPackage: aTransportPackage	self manager receivingPackage: aTransportPackage in: self</body><body package="Opentalk-Core">sendingPackage: aTransportPackage	self manager sendingPackage: aTransportPackage in: self</body><body package="Opentalk-Core">serverProcessExiting	self manager serverProcessExitingIn: self</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>events-message processing</category><body package="Opentalk-Core">handlingIncomingMessageFailedBecause: anException	self manager handlingIncomingMessageIn: self failedBecause: anException</body></methods><methods><class-id>Opentalk.RequestTransport</class-id> <category>events</category><body package="Opentalk-Core">postStop	sessionObjects := nil.	self requestRegistry do: [:each |		each shutdown ].	super postStop.</body></methods><methods><class-id>Opentalk.ConnectionAdaptorConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^ConnectionAdaptor</body><body package="Opentalk-Core">connectingTimeout	^connectingTimeout</body><body package="Opentalk-Core">connectingTimeout: anObject"how long to wait for a connection request to succeed (ms)"	connectingTimeout := anObject</body><body package="Opentalk-Core">connectionTimeout	^connectionTimeout</body><body package="Opentalk-Core">connectionTimeout: anObject"how long can a connection idle before being closed (ms)"	connectionTimeout := anObject</body><body package="Opentalk-Core">isBiDirectional	^isBiDirectional</body><body package="Opentalk-Core">isBiDirectional: allowed"	allowed &lt;Boolean&gt; allow bi-directional connections (requests can flow in both directions)"	isBiDirectional := allowed</body><body package="Opentalk-Core">listenerBacklog	^listenerBacklog</body><body package="Opentalk-Core">listenerBacklog: anObject	listenerBacklog := anObject</body><body package="Opentalk-Core">listenerPriority	^listenerPriority</body><body package="Opentalk-Core">listenerPriority: anInteger	listenerPriority := anInteger</body><body package="Opentalk-Core">lowerConnectionLimit	^lowerConnectionLimit</body><body package="Opentalk-Core">lowerConnectionLimit: anInteger	lowerConnectionLimit := anInteger</body><body package="Opentalk-Core">maxAcceptDelay	^maxAcceptDelay</body><body package="Opentalk-Core">maxAcceptDelay: aNumber	maxAcceptDelay := aNumber</body><body package="Opentalk-Core">soReuseAddr	^soReuseAddr</body><body package="Opentalk-Core">soReuseAddr: aBoolean	soReuseAddr := aBoolean</body><body package="Opentalk-Core">upperConnectionLimit	^upperConnectionLimit</body><body package="Opentalk-Core">upperConnectionLimit: anInteger	upperConnectionLimit := anInteger</body><body package="Opentalk-Core">useDistinctServerEvents	^useDistinctServerEvents</body><body package="Opentalk-Core">useDistinctServerEvents: use"	use &lt;Boolean&gt; trigger distinct server side connection add/remove events"	useDistinctServerEvents := use</body></methods><methods><class-id>Opentalk.ConnectionAdaptorConfiguration class</class-id> <category>instance creation</category><body package="Opentalk-Core">rootConfigurationMetaclass	^AdaptorConfiguration class</body></methods><methods><class-id>Opentalk.AsymmetricConnectionAdaptorConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^ConnectionAdaptor</body><body package="Opentalk-Core">isBiDirectional	^false</body></methods><methods><class-id>Opentalk.RequestDispatcherConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">workerPriority	^workerPriority</body><body package="Opentalk-Core">workerPriority: anInteger"	anInteger &lt;SmallInteger&gt; the worker process priority"	workerPriority := anInteger</body></methods><methods><class-id>Opentalk.RequestDispatcherConfiguration class</class-id> <category>types</category><body package="Opentalk-Core">highLow	^HighLowRequestDispatcherConfiguration new</body><body package="Opentalk-Core">pool	^PoolRequestDispatcherConfiguration new</body><body package="Opentalk-Core">standard	^StandardRequestDispatcherConfiguration new</body></methods><methods><class-id>Opentalk.HighLowRequestDispatcherConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^HighLowRequestDispatcher</body><body package="Opentalk-Core">discriminationBlock	^discriminationBlock</body><body package="Opentalk-Core">discriminationBlock: aBlockClosure	discriminationBlock := aBlockClosure</body><body package="Opentalk-Core">highPriority	^highPriority</body><body package="Opentalk-Core">highPriority: anInteger	highPriority := anInteger</body></methods><methods><class-id>Opentalk.DatagramTransport</class-id> <category>initialize-release</category><body package="Opentalk-Core">setManager: aConnectionManager at: anAccessPoint	self setManager: aConnectionManager</body></methods><methods><class-id>Opentalk.DatagramTransport</class-id> <category>private</category><body package="Opentalk-Core">createApplicationPackageFrom: aTransportPackage	^( super createApplicationPackageFrom: aTransportPackage )		source: aTransportPackage peerAccessPoint;		yourself</body><body package="Opentalk-Core">createTransportPackageFrom: aRemoteMessage	^( super createTransportPackageFrom: aRemoteMessage )		peerAccessPoint: aRemoteMessage destination;		yourself</body></methods><methods><class-id>Opentalk.DatagramTransport class</class-id> <category>defaults-constants</category><body package="Opentalk-Core">defaultBufferSizeValue	^4000</body></methods><methods><class-id>Opentalk.DatagramTransport class</class-id> <category>instance creation</category><body package="Opentalk-Core">new: aConfiguration at: anAccessPoint for: aManager	^(self new: aConfiguration)		setManager: aManager at: anAccessPoint;		yourself</body></methods><methods><class-id>Opentalk.ObjectTable</class-id> <category>private</category><body package="Opentalk-Core">deregisterObject: anObject oid: anOID	objectsToOIDs removeKey: anObject ifAbsent: [].	oidsToObjects removeKey: anOID ifAbsent: []</body><body package="Opentalk-Core">register: anObject oid: anOID	"If anObject not published yet, publised it at anOID and return anOID"	objectsToOIDs at: anObject put: anOID.	oidsToObjects at: anOID put: anObject.	^anOID</body><body package="Opentalk-Core">removeObject: anObject	accessLock critical: [ | ooid |		ooid := objectsToOIDs at: anObject ifAbsent: [].		self deregisterObject: anObject oid: ooid]</body></methods><methods><class-id>Opentalk.ObjectTable</class-id> <category>removing</category><body package="Opentalk-Core">clearAll	oidsToObjects := OtWeakValueDictionary new.	objectsToOIDs := OtWeakKeyDictionary new.</body><body package="Opentalk-Core">revokeObject: anObject	accessLock critical: [ | oid |		oid := objectsToOIDs at: anObject ifAbsent: [].		self deregisterObject: anObject oid: oid.		oid]</body><body package="Opentalk-Core">revokeObject: anObject for: anAdaptor	accessLock critical: [ | oid |		oid := objectsToOIDs at: anObject ifAbsent: [].		self revokingExportedObject: anObject oid: oid in: anAdaptor.		self deregisterObject: anObject oid: oid.		oid]</body></methods><methods><class-id>Opentalk.ObjectTable</class-id> <category>adding</category><body package="Opentalk-Core">export: anObject 	"Exports anObject and returns its OID."	^accessLock critical: [		objectsToOIDs 			at: anObject			ifAbsent: [self register: anObject oid: self nextOID]]</body><body package="Opentalk-Core">export: anObject for: anAdaptor	"Exports anObject and returns its OID."	^accessLock critical: [		objectsToOIDs 			at: anObject			ifAbsent: [ | oid |				oid := self nextOID.				self exportingObject: anObject oid: oid in: anAdaptor.				self register: anObject oid: oid]]</body><body package="Opentalk-Core">export: anObject oid: oid 	"Exports anObject on the given OID."	^accessLock critical: [		objectsToOIDs 			at: anObject 			ifAbsent: [self register: anObject oid: oid]]</body><body package="Opentalk-Core">export: anObject oid: oid for: anAdaptor	"Exports anObject on the given OID."	^accessLock critical: [		objectsToOIDs 			at: anObject 			ifAbsent: [				self exportingObject: anObject oid: oid in: anAdaptor.				self register: anObject oid: oid]]</body></methods><methods><class-id>Opentalk.ObjectTable</class-id> <category>accessing</category><body package="Opentalk-Core">allRemoteObjects	^oidsToObjects values select: [ :each | each _isRemote ]</body><body package="Opentalk-Core">nextOID	"Return the next available OID. This is a simple OID implemenation."	^nextKey := nextKey + 1</body><body package="Opentalk-Core">objectByOID: anOID	^self		objectByOID: anOID		ifAbsent: [ OtEOIDNotFound raiseSignal: (					(#TheOID1sWasNotFound &lt;&lt; #opentalk &gt;&gt; 'The OID, &lt;1s&gt;, was not found.')						expandMacrosWith: anOID printString) ]</body><body package="Opentalk-Core">objectByOID: anOID ifAbsent: aBlock	^accessLock critical: 		[ oidsToObjects at: anOID ifAbsent: aBlock ]</body><body package="Opentalk-Core">oidByObject: anObject	^self		oidByObject: anObject		ifAbsent: [ OtEObjectNotFound raiseSignal: (					(#TheObject1sWasNotFound &lt;&lt; #opentalk &gt;&gt; 'The object, &lt;1s&gt;, was not found.')						expandMacrosWith: anObject printString) ]</body><body package="Opentalk-Core">oidByObject: anObject ifAbsent: aBlock	^accessLock critical: 		[ objectsToOIDs at: anObject ifAbsent: aBlock ]</body></methods><methods><class-id>Opentalk.ObjectTable</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize	oidsToObjects := OtWeakValueDictionary new.	objectsToOIDs := OtWeakKeyDictionary new.	accessLock := RecursionLock new.	"There should never be a key of 0, which value would dangerously 	conflict with the implementation of class WeakDictionary."	nextKey := 100.</body></methods><methods><class-id>Opentalk.ObjectTable</class-id> <category>events-object activation</category><body package="Opentalk-Core">exportingObject: anObject oid: oid in: anAdaptor	anAdaptor exportingObject: anObject oid: oid</body><body package="Opentalk-Core">revokingExportedObject: anObject oid: oid in: anAdaptor	anAdaptor revokingExportedObject: anObject oid: oid</body></methods><methods><class-id>Opentalk.ObjectTable class</class-id> <category>instance creation</category><body package="Opentalk-Core">new	^super new initialize</body></methods><methods><class-id>Opentalk.RemoteRequest</class-id> <category>dispatching</category><body package="Opentalk-Core">dispatchFor: aTransport 	"Fork a working thread to handle the remote request."	aTransport manager		dispatchRequest: self		inBlock: [ super dispatchFor: aTransport ]</body><body package="Opentalk-Core">doTheWorkFor: aConnection"Perform the request on the receiving end and return the result"	^self subclassResponsibility</body><body package="Opentalk-Core">evaluateFor: aConnection 	super evaluateFor: aConnection.	self		sendReply: (self doTheWorkFor: aConnection)		for: aConnection</body><body package="Opentalk-Core">handleReplyError: anError in: aTransport	self sendingReply: reply in: aTransport failedBecause: anError</body><body package="Opentalk-Core">prepareReply: aReply for: aConnection"This is a dispatch from reply evaluation after it's linked to the request."</body><body package="Opentalk-Core">replyForResult: anObject"Package the result object in a reply"	^self subclassResponsibility</body><body package="Opentalk-Core">sendReply: anObject for: aConnection 	[	reply := self replyForResult: anObject.		reply send: aConnection	] on: Error do: [ :error |		self handleReplyError: error in: aConnection ].</body></methods><methods><class-id>Opentalk.RemoteRequest</class-id> <category>accessing</category><body package="Opentalk-Core">destination	^self subclassResponsibility</body><body package="Opentalk-Core">message	^message</body><body package="Opentalk-Core">message: msg	message := msg</body><body package="Opentalk-Core">reply	^reply</body><body package="Opentalk-Core">reply: aReply	reply := aReply</body><body package="Opentalk-Core">target	^target</body><body package="Opentalk-Core">target: anObject	target := anObject</body><body package="Opentalk-Core">timeout	"Answers the timeout value in milliseconds."	^timeout</body><body package="Opentalk-Core">timeout: anInteger	"The argument, anInteger, is understood 	to be a timeout value in milliseconds."	timeout := anInteger</body></methods><methods><class-id>Opentalk.RemoteRequest</class-id> <category>printing</category><body package="Opentalk-Core">printMessageOn: aStream	message ifNil: [^self].	(message selector last = $:)		ifTrue: [ message selector keywords with: message arguments do: [ :k :a |				aStream space; nextPutAll: k; space.				a _isRemote ifTrue: [ a _printOn: aStream ] ifFalse: [ a printOn: aStream ] ] ]		ifFalse: [ aStream space; nextPutAll: message selector ]</body><body package="Opentalk-Core">printOn: aStream	super printOn: aStream.	aStream nextPut: ${.	self		printTargetOn: aStream;		printMessageOn: aStream.	aStream nextPut: $}</body><body package="Opentalk-Core">printTargetOn: aStream	target printOn: aStream</body></methods><methods><class-id>Opentalk.RemoteRequest</class-id> <category>initialize-release</category><body package="Opentalk-Core">initWith: msg to: aTarget timeout: ms	message := msg.	target := aTarget.	timeout := ms.	promise := TimedPromise forMilliseconds: timeout</body></methods><methods><class-id>Opentalk.RemoteRequest</class-id> <category>invocation</category><body package="Opentalk-Core">returnWith: aReturnPackage	"Returned from remote invocation (called from return package dispatching).  Inject the result into the promise to wakeup the sending thread."	| result |	reply := aReturnPackage.	result := aReturnPackage getReturnValueFor: self.	aReturnPackage failed		ifTrue: [ promise exception: result ]		ifFalse: [ promise value: result ]</body><body package="Opentalk-Core">sendAndWaitForReply: aTransport 	"Send the request and waiting for a remote invocation return or timeout. This is client side function."	[		[aTransport sendPackage: self. ] on: Error do: [ :ex | promise value: ex. ex return]			] fork.	^self waitForReply: aTransport</body><body package="Opentalk-Core">shutdown	(reply isNil and: [ promise notNil ]) ifTrue: [		promise exception: (			OtEServerError new				messageText: (#ConnectionClosed &lt;&lt; #opentalk &gt;&gt; 'Connection Closed');				parameter: self				yourself) ]</body><body package="Opentalk-Core">waitForReply: aConnection 	"Now wait on the promise for specified timeout period.  Either timeout or return the remote call return value."		^[ 		promise value isSignalledException ifTrue: [			promise value class new				messageText: promise value description;				parameter: promise value parameter;				raise].		promise value.	]		on: PromiseExpiredError		do: [ :ex | ex resignalAs:					( OtETimeout new						messageText: (#RemoteInvocationTimeout &lt;&lt; #opentalk &gt;&gt; 'Remote invocation timeout!');						parameter: ex parameter;						request: self;						transport: aConnection;						yourself ) ]</body></methods><methods><class-id>Opentalk.RemoteRequest</class-id> <category>events-message processing</category><body package="Opentalk-Core">receivingMessageIn: aTransport	aTransport manager receivingRequest: self in: aTransport</body><body package="Opentalk-Core">sendingMessageIn: aTransport	aTransport manager sendingRequest: self in: aTransport</body><body package="Opentalk-Core">sendingReply: aReply in: aTransport failedBecause: anError	aTransport manager sendingReply: aReply in: aTransport failedBecause: anError</body></methods><methods><class-id>Opentalk.RemoteRequest</class-id> <category>testing</category><body package="Opentalk-Core">hasReply	^reply notNil</body></methods><methods><class-id>Opentalk.RemoteRequest class</class-id> <category>instance creation</category><body package="Opentalk-Core">newRequest: msg to: aRemoteObject timeout: tm	^self new 		initWith: msg 		to: aRemoteObject 		timeout: tm</body></methods><methods><class-id>Opentalk.MessageInterceptor</class-id> <category>accessing</category><body package="Opentalk-Core">dispatcher	^dispatcher</body><body package="Opentalk-Core">dispatcher: anInterceptorDispatcher	dispatcher := anInterceptorDispatcher</body><body package="Opentalk-Core">policy	^self dispatcher policy</body></methods><methods><class-id>Opentalk.MessageInterceptor</class-id> <category>processing callbacks</category><body package="Opentalk-Core">receivingReply: aReply in: aTransport</body><body package="Opentalk-Core">receivingRequest: aRequest in: aTransport</body><body package="Opentalk-Core">sendingReply: aReply in: aTransport</body><body package="Opentalk-Core">sendingRequest: aRequest in: aTransport</body></methods><methods><class-id>Opentalk.OpentalkSystem</class-id> <category>actions</category><body package="Opentalk-Core">pauseAction	super pauseAction.	self class pauseComponents</body><body package="Opentalk-Core">resumeAction	super resumeAction.	( Snapshot isAboutToQuit not )		ifTrue:	[ self class resumeComponents ]</body><body package="Opentalk-Core">setUp	super setUp.	GenericProtocol flushHost.	self class setUpComponents</body><body package="Opentalk-Core">tearDown	super tearDown.	self class tearDownComponents</body></methods><methods><class-id>Opentalk.OpentalkSystem</class-id> <category>prerequisites</category><body package="Opentalk-Core">prerequisiteSystems	^Array with: InterestNotificationSystem</body></methods><methods><class-id>Opentalk.OpentalkSystem</class-id> <category>initialize/release</category><body package="Opentalk-Core">initialize	super initialize</body></methods><methods><class-id>Opentalk.OpentalkSystem class</class-id> <category>accessing api</category><body package="Opentalk-Core">componentAtId: anObject	^self		componentAtId: anObject		ifAbsent: [ OtEComponentIdNotFound raiseSignal: (					(#TheIdentifier1sWasNotFound &lt;&lt; #opentalk &gt;&gt; 'The identifier, &lt;1s&gt;, was not found.')						expandMacrosWith: anObject printString) ]</body><body package="Opentalk-Core">componentAtId: anObject ifAbsent: aBlockClosure	^self accessLock critical: 		[ self componentRegistry at: anObject ifAbsent: aBlockClosure ]</body></methods><methods><class-id>Opentalk.OpentalkSystem class</class-id> <category>registration api</category><body package="Opentalk-Core">deregisterComponent: anObject	| k |	k := self componentRegistry keyAtIdentityValue: anObject ifAbsent: [].	( k notNil )		ifTrue:	[ self deregisterId: k ]</body><body package="Opentalk-Core">deregisterId: anObject	self accessLock		critical:	[ self componentRegistry					removeKey: anObject					ifAbsent: []				]</body><body package="Opentalk-Core">registerComponent: anObject	self		registerComponent: anObject		atId: anObject id</body><body package="Opentalk-Core">registerComponent: anObject1 atId: anObject2	^self accessLock		critical: [	self componentRegistry 						at: anObject2						ifAbsentPut: [ anObject1 ]				]</body></methods><methods><class-id>Opentalk.OpentalkSystem class</class-id> <category>operational api</category><body package="Opentalk-Core">pauseComponents	self componentRegistry do: [ :x | x systemPauseEvent ]</body><body package="Opentalk-Core">resumeComponents	self componentRegistry do: [ :x | x systemResumeEvent ]</body><body package="Opentalk-Core">setUpComponents	self componentRegistry do: [ :x | x systemSetUpEvent ]</body><body package="Opentalk-Core">tearDownComponents	self componentRegistry do: [ :x | x systemTearDownEvent ]</body></methods><methods><class-id>Opentalk.OpentalkSystem class</class-id> <category>accessing</category><body package="Opentalk-Core">accessLock	^accessLock ifNil: [ accessLock := RecursionLock new ]</body><body package="Opentalk-Core">componentRegistry	^componentRegistry ifNil: [ componentRegistry := OtWeakValueDictionary new ]</body></methods><methods><class-id>Opentalk.OpentalkSystem class</class-id> <category>fileIn/Out</category><body package="Opentalk-Core">prerequisitesForLoading        ^super prerequisitesForLoading                addLast: OtWeakValueDictionary;                yourself</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>protocol-API</category><body package="Opentalk-Core">changePort: aPortNumber	self objectAdaptor changePort: aPortNumber</body><body package="Opentalk-Core">doStart	super doStart.	"Ensure that every time a broker is started, 	it is registered with its objectAdaptor."	objectAdaptor setORB: self.	objectAdaptor start</body><body package="Opentalk-Core">doStop	super doStop.	objectAdaptor isNil ifFalse: [objectAdaptor stop].</body><body package="Opentalk-Core">objectAdaptorClass	"Change the return value of this method to 	switch to a different object adaptor."	^BasicObjectAdaptor</body><body package="Opentalk-Core">objectAdaptorStopped	"... intentionally null. The object adaptor has stopped.  Do not stop it again within this 	method!  This method should be over-ridden by subclasses that need to take action 	when the adaptor stops."</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>remoteObj-API</category><body package="Opentalk-Core">activeBrokerAt: anIPSocketAddress	"Get the ORB at the given IPSocketAddress"	^self 		remoteObjectOn: anIPSocketAddress		oid: self  brokerId</body><body package="Opentalk-Core">activeBrokerAtHost: hn port: pn	"Get the ORB at the host name 'hn',	 on the port number 'pn'."	^self remoteObjectToHost: hn			port: pn			oid: self  brokerId</body><body package="Opentalk-Core">clearRemoteObjectRegistry	remoteObjectRegistry := OtWeakValueDictionary new:100.</body><body package="Opentalk-Core">export: anObject  oid: aValue	self objectAdaptor export: anObject  oid:  aValue.</body><body package="Opentalk-Core">findOrCreateRemoteObject: objRef	^remoteObjectRegistry 		at: objRef		ifAbsentPut: [ 			self importingReference: objRef.			RemoteObject newOn: objRef requestBroker: self]</body><body package="Opentalk-Core">remoteObjectOn: anIPSocketAddress oid: oid 	^self 		remoteObjectOn: anIPSocketAddress		oid: oid		ifNotRunning: []</body><body package="Opentalk-Core">remoteObjectOn: anIPSocketAddress oid: oid ifNotRunning: aBlock 	"Answer a proxy to the remote object.  If the receiver 	has not started, then evaluate the argument aBlock 	first."	| objRef |	( self isRunning )		ifFalse: [ aBlock value ].	objRef := ObjRef 				newOn: anIPSocketAddress				oid: oid.	^self findOrCreateRemoteObject: objRef</body><body package="Opentalk-Core">remoteObjectRegistry	"The 'remoteObjectRegistry' is a weakValueDictionary employed	to maintain the object identities of remoteObjects."	^remoteObjectRegistry</body><body package="Opentalk-Core">remoteObjectToHost: aHostName port: p oid: oid 	^self 		remoteObjectToHost: aHostName		port: p		oid: oid		ifNotRunning: []</body><body package="Opentalk-Core">remoteObjectToHost: aHostName port: p oid: oid ifNotRunning: aBlock 	"Answer a proxy to the remote object.  If the receiver 	has not started, then evaluate the rgaument aBlock 	first."	| objRef |	( self isRunning )		ifFalse: [ aBlock value ].	objRef := ObjRef 				newOnHostName: aHostName				port: p				oid: oid.	^self findOrCreateRemoteObject: objRef</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>testing</category><body package="Opentalk-Core">isRunning	^( super isRunning and: [ self objectAdaptor isRunning ] )</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>RMI-API</category><body package="Opentalk-Core">ping: accessPoint	"Redispatch to the object adaptor."	^self objectAdaptor ping: accessPoint</body><body package="Opentalk-Core">sendMessage: msg to: objRef 	"Send the request, 'msg', to the 'objRef',	and return the request."	^self sendMessage: msg		to: objRef		timeout: self requestTimeout</body><body package="Opentalk-Core">sendMessage: msg to: objRef timeout: ms "Build a request out of the smalltalk message and send it"	(msg isNil or: [objRef isNil]) ifTrue: [^nil].	^self sendRequest: (		self requestClass			newRequest: msg			to: objRef			timeout: ms)</body><body package="Opentalk-Core">sendRequest: aRequest	"Redispatch to the object adaptor."	^self objectAdaptor sendRequest: aRequest</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>accessing</category><body package="Opentalk-Core">accessPoint	"Redispatch to the object adaptor."	^self objectAdaptor accessPoint</body><body package="Opentalk-Core">brokerId	^self class brokerId</body><body package="Opentalk-Core">objectAdaptor	^objectAdaptor</body><body package="Opentalk-Core">objectAdaptors	"At the highest level, one configures an Opentalk image by selecting at least one request 	broker.  More may be selected if the image needs separate brokers for, say, both  point-to-	point and broadcast communications.  This case aside, brokers are the unit within which 	communication protocols are composed.  The drill is that there will never be more than one 	broker for a general protocol type.  It is thus possible that an image serving as a gateway	will have one point-to-point broker with two object adaptors, each requireing the configuration	of a port number.  So, the configuration machinery needs to provide for multiple adaptors, and	so, this method."	^Set with: objectAdaptor</body><body package="Opentalk-Core">requestClass	self requestType isNil ifTrue: [		self requestType: objectAdaptor requestClass].	^self requestType</body><body package="Opentalk-Core">requestTimeout	^requestTimeout ifNil: [		configuration requestTimeout ifNil: [			self class defaultRequestTimeout ] ]</body><body package="Opentalk-Core">requestTimeout: anInteger"How many milliseconds to wait for a response"	requestTimeout := anInteger</body><body package="Opentalk-Core">requestType	^requestType</body><body package="Opentalk-Core">requestType: aClass	requestType := aClass</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>printing</category><body package="Opentalk-Core">printOn: aStream	aStream nextPutAll: (#Broker &lt;&lt; #opentalk &gt;&gt; 'Broker') asString</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>events-API</category><body package="Opentalk-Core">haltErrors"Make the process loop handling incoming messages of the broker halt on any unexpected errors.  Note that the event handler has to be a block, otherwise the cleanup code in 'suppressErrors' won't work.  For an explanation of the use of this method, see the method comment of 'suppressErrors'."	objectAdaptor haltErrors</body><body package="Opentalk-Core">passErrors"Do not handle unexpected errors that occur in the process loop handling incoming messages of the broker.  Note that the event handler has to be a block, otherwise the cleanup code in 'suppressErrors' won't work.  For an explanation of the use of this method, see the method comment of 'suppressErrors'."	objectAdaptor passErrors</body><body package="Opentalk-Core">sendAllEventsTo: anObject	objectAdaptor sendAllEventsTo: anObject.	self class allEvents do: [ :ev |		self when: ev send: ev to: anObject ]</body><body package="Opentalk-Core">sendErrorEventsTo: anObject	objectAdaptor sendErrorEventsTo: anObject.	self class errorEvents do: [ :ev |		self when: ev send: ev to: anObject ]</body><body package="Opentalk-Core">sendOperationalEventsTo: anObject	objectAdaptor sendOperationalEventsTo: anObject.	self class operationalEvents do: [ :ev |		self when: ev send: ev to: anObject ]</body><body package="Opentalk-Core">showErrors"Print to the Transcript any unexpected errors that occur in the broker's server process loop handling incoming messages.  Note that the event handler has to be a block, otherwise the cleanup code in 'suppressErrors' won't work.  Also note that no special provisions are taken to serialize concurrent attempts to print to the Transcript.  This feature is meant just to help developement.  For an explanation of the use of this method, see the method comment of 'suppressErrors'."	objectAdaptor showErrors</body><body package="Opentalk-Core">suppressErrors"Suppresses any unexpected errors that occur in the process loop handling incoming messages of the broker.  This restores the default setup."	objectAdaptor suppressErrors</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize	super initialize.	remoteObjectRegistry := OtWeakValueDictionary new: 100</body><body package="Opentalk-Core">initialize: aConfiguration	super initialize: aConfiguration. 	objectAdaptor := aConfiguration adaptor newFor: self</body><body package="Opentalk-Core">release	self stop.	self objectAdaptor release.	objectAdaptor := nil.	remoteObjectRegistry := nil.	super release.</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>deprecated</category><body package="Opentalk-Core">handleErrors"Suppress any unexpected errors that occur in the process loop handling incoming messages of the broker.  This is the default setup.  ... to be deprecated in favor of 'supressErrors' because the method name is misleading."	self suppressErrors</body><body package="Opentalk-Core">initAt: a4ByteArray port: anInteger	objectAdaptor := self objectAdaptorClass newAt: a4ByteArray port: anInteger.</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>image-API</category><body package="Opentalk-Core">imageSuffix	^self objectAdaptor imageSuffix</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>accessing-configuration</category><body package="Opentalk-Core">processingPolicy	^objectAdaptor processingPolicy</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>events-object activation</category><body package="Opentalk-Core">importingReference: objRef	self	triggerEvent: #importingReference:in:		withArguments: (Array with: objRef with: self).</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>system events</category><body package="Opentalk-Core">systemResumeEvent	( ( state == self pQuiescent ) and: [ self objectAdaptor socketIsInactiveOrNil ] )		ifTrue:	[ self restart ]</body><body package="Opentalk-Core">systemSetUpEvent	( ( self autoRestart == self class restartNever )		and: [ self isQuiescent ] )			ifTrue:	[ state := self pStopped ].	( ( ( self autoRestart == self class restartAlways ) or:		[ ( self autoRestart == self class restartIfQuiescent )			and: [ state == self pQuiescent ] ] ) 				and: [ self objectAdaptor socketIsInactiveOrNil ] )			ifTrue:	[ self start ]</body></methods><methods><class-id>Opentalk.BasicRequestBroker class</class-id> <category>accessing</category><body package="Opentalk-Core">brokerId	^( brokerId isNil )		ifTrue:	[ brokerId := self name ]		ifFalse:	[ brokerId ]</body><body package="Opentalk-Core">defaultPort	^( defaultPort isNil )		ifTrue:	[ defaultPort := 3500 ]		ifFalse:	[ defaultPort ]</body><body package="Opentalk-Core">setBrokerId: anObject	brokerId := anObject</body><body package="Opentalk-Core">setDefaultPort: anInteger	defaultPort := anInteger</body></methods><methods><class-id>Opentalk.BasicRequestBroker class</class-id> <category>events</category><body package="Opentalk-Core">operationalEvents	^super operationalEvents, #(	"triggered when a new ObjRef is imported"	importingReference:in:)</body></methods><methods><class-id>Opentalk.BasicRequestBroker class</class-id> <category>deprecated</category><body package="Opentalk-Core">newAt: a4ByteArray port: anInteger"Creates a local broker at port number anInteger using given host address a4ByteArray."	^super new initAt: a4ByteArray port: anInteger</body><body package="Opentalk-Core">newAtAnyPort"Creates a local broker at some free port number using GenericProtocol class&gt;&gt;hostAddress.This is useful for creating client side brokers where it doesn't matter what port they run on."	^self newAtPort: IPSocketAddress anyPort</body><body package="Opentalk-Core">newAtAnyPort: a4ByteArray"Creates a local broker at some free port number using given host address a4ByteArray.This is useful for creating client side brokers where it doesn't matter what port they run on."	^self newAt: a4ByteArray port: IPSocketAddress anyPort</body><body package="Opentalk-Core">newAtPort: anInteger"Creates a local broker at port number anInteger using GenericProtocol class&gt;&gt;hostAddress."	^self newAt: nil port: anInteger</body></methods><methods><class-id>Opentalk.BasicRequestBroker class</class-id> <category>defaults</category><body package="Opentalk-Core">defaultAutoRestartValue	^self restartIfQuiescent</body><body package="Opentalk-Core">defaultRequestTimeout	^defaultRequestTimeout ifNil: [		self defaultRequestTimeoutValue ]</body><body package="Opentalk-Core">defaultRequestTimeout: aSmallInteger	defaultRequestTimeout := aSmallInteger</body><body package="Opentalk-Core">defaultRequestTimeoutValue	"Answers the waiting time for request completion 	in milliseconds.  The default value is 1 minute."	^60000</body></methods><methods><class-id>Opentalk.RequestBroker</class-id> <category>printing</category><body package="Opentalk-Core">printOn: aStream	super printOn: aStream.	objectAdaptor notNil ifTrue: [		objectAdaptor printAccessInfoOn: aStream ]</body></methods><methods><class-id>Opentalk.RequestBroker</class-id> <category>api - services</category><body package="Opentalk-Core">hasServices	^self serviceDictionary isEmpty not</body><body package="Opentalk-Core">registerService: anObject id: aSymbol	serviceDictionary at: aSymbol put: anObject</body><body package="Opentalk-Core">serviceById: aSymbol	^serviceDictionary at: aSymbol ifAbsent: []</body><body package="Opentalk-Core">serviceDictionary	^serviceDictionary</body><body package="Opentalk-Core">serviceIds	^serviceDictionary keys</body><body package="Opentalk-Core">services	^serviceDictionary values</body><body package="Opentalk-Core">unregisterServiceId: aSymbol	serviceDictionary removeKey: aSymbol ifAbsent: []</body></methods><methods><class-id>Opentalk.RequestBroker</class-id> <category>api - accesss control</category><body package="Opentalk-Core">openSelectors	^openSelectors</body><body package="Opentalk-Core">openSelectors: aCollection 	"Set the ACL control"	(aCollection isKindOf: Collection)		ifTrue: [openSelectors := aCollection]</body><body package="Opentalk-Core">remotePerform: selector withArguments: agrs 	"Validate the remote operation before excution"	(openSelectors includes: selector)		ifFalse: [^OtEBadOperation raiseErrorString: (			(#OperationDenied1s &lt;&lt; #opentalk &gt;&gt; 'Operation denied: &lt;1s&gt;')				expandMacrosWith: selector asString)].	^super remotePerform: selector withArguments: agrs	"Note: the ACL can be checked against a requestPrincipal which can be pass by processEnvironment or setwhen a secure connection is established."</body></methods><methods><class-id>Opentalk.RequestBroker</class-id> <category>api - test</category><body package="Opentalk-Core">echo: anObject 	"Simply return anObject, used for remote testing"	^anObject</body></methods><methods><class-id>Opentalk.RequestBroker</class-id> <category>initialize-release</category><body package="Opentalk-Core">initialize	"Note that we clear the services dictionary at initialization time.	We allow '#classname' as an openSelector to support profiling."	super initialize.	self initializeServices.	"Open only limited set of remote calls to the receiver"	openSelectors := #(#echo: #serviceIds #serviceById: #class #isRunning).</body><body package="Opentalk-Core">initializeServices	serviceDictionary := Dictionary new.</body></methods><methods><class-id>Opentalk.StandardRequestDispatcherConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^StandardRequestDispatcher</body></methods><methods><class-id>Opentalk.StandardRequestDispatcher</class-id> <category>dispatch api</category><body package="Opentalk-Core">dispatchRequest: aRemoteRequest inBlock: aBlockClosure	aBlockClosure forkAt: self workerPriority</body></methods><methods><class-id>Opentalk.StreamTransport</class-id> <category>protocol-API</category><body package="Opentalk-Core">peerOK	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.StreamTransport</class-id> <category>accessing</category><body package="Opentalk-Core">id	^id</body><body package="Opentalk-Core">peerId	^peerId ifNil: [ id ]</body></methods><methods><class-id>Opentalk.StreamTransport</class-id> <category>initialize-release</category><body package="Opentalk-Core">initializeStreams	self subclassResponsibility</body><body package="Opentalk-Core">setManager: aConnectionManager id: aConnectionId socket: aSocket	self setManager: aConnectionManager.	id := aConnectionId.		self initializeStreams</body></methods><methods><class-id>Opentalk.StreamTransport</class-id> <category>private</category><body package="Opentalk-Core">serverProcessBody	[	super serverProcessBody	] ensure: [ self serverProcessExitHandling ]</body><body package="Opentalk-Core">serverProcessExitHandling	"The server process is exiting, so let's make sure the connection is stopped"	self isRunning ifTrue: [self stop]</body></methods><methods><class-id>Opentalk.StreamTransport</class-id> <category>events</category><body package="Opentalk-Core">preStop	self manager connectionStopped: self.	super preStop.</body></methods><methods><class-id>Opentalk.StreamTransport class</class-id> <category>private</category><body package="Opentalk-Core">new: aConfiguration socketTo: anIPSocketAddress for: aManager"Create a socket connected to the given remote address"	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.StreamTransport class</class-id> <category>instance creation</category><body package="Opentalk-Core">new: aConfiguration on: aSocket for: aManager	| conn |	conn := (self new: aConfiguration)			setManager: aManager			id: aSocket getPeer			socket: aSocket.	aManager addServerConnection: conn.	conn start.	^conn</body><body package="Opentalk-Core">new: aConfiguration to: anIPSocketAddress for: aManager	"Create a client connection to the given remote address.  Note that I cannot 	make a connection to myself because it causes connection id conflict."	| conn |	conn := (self new: aConfiguration)			setManager: aManager			id: anIPSocketAddress			socket: (self					new: aConfiguration					socketTo: anIPSocketAddress					for: aManager).	aManager addConnection: conn.	conn start.	^conn</body></methods><methods><class-id>Opentalk.PoolRequestDispatcherConfiguration</class-id> <category>accessing</category><body package="Opentalk-Core">componentClass	^PoolRequestDispatcher</body><body package="Opentalk-Core">processNumber	^processNumber</body><body package="Opentalk-Core">processNumber: anInteger	processNumber := anInteger</body></methods><methods><class-id>Opentalk.LocalDependents</class-id> <category>updating</category><body package="Opentalk-Core">performUpdate: aSymbol 	"Send aSymbol to each member of the receiver."	self do: [:obj | obj perform: aSymbol]</body><body package="Opentalk-Core">performUpdate: aSymbol with: anObject	"Send aSymbol to each member of the receiver with anObject as argument."	self do: [:obj | obj perform: aSymbol with: anObject]</body><body package="Opentalk-Core">update: anAspect with: aParameter from: anObject	"Send the message update: anAspect with: aParameter from: anObject to each member of the receiver."	self do: [:obj | obj update: anAspect with: aParameter from: anObject]</body><body package="Opentalk-Core">updateRequest	"Send the message updateRequest to each member of the receiver.	If any member answers false, answer false; otherwise, answer true."	self do: [:obj | obj updateRequest ifFalse: [^false]].	^true</body><body package="Opentalk-Core">updateRequest: anAspectSymbol	"Send the message updateRequest: to each member of the receiver with anAspectSymbol as argument.	If one answers false, answer false, otherwise answer true."	self do: [:obj | (obj updateRequest: anAspectSymbol) ifFalse: [^false]].	^true</body></methods><methods><class-id>Opentalk.ObjRef</class-id> <category>accessing</category><body package="Opentalk-Core">accessPoint	"My accessing point. Usually a network address where the object can be reached"	^accessPoint</body><body package="Opentalk-Core">hostAddress	^accessPoint hostAddress</body><body package="Opentalk-Core">hostName	^accessPoint hostName</body><body package="Opentalk-Core">oid	"My object identifier"	^oid</body><body package="Opentalk-Core">port	^accessPoint port</body></methods><methods><class-id>Opentalk.ObjRef</class-id> <category>comparing</category><body package="Opentalk-Core">= anObject 	"Answer whether the receiver is equal to the argument."	^self class = anObject class		and: [accessPoint = anObject accessPoint and: [oid == anObject oid]]</body><body package="Opentalk-Core">hash	^accessPoint hash + oid hash</body></methods><methods><class-id>Opentalk.ObjRef</class-id> <category>initialize</category><body package="Opentalk-Core">initOID: id accessPoint: addr	oid := id.	accessPoint := addr</body></methods><methods><class-id>Opentalk.ObjRef</class-id> <category>printing</category><body package="Opentalk-Core">printAccessInfoOn: aStream 	aStream		print: self oid;		nextPut: $@.	(accessPoint respondsTo: #hostAddress)		ifTrue: [ self hostAddress				do: [ :e | aStream print: e ]				separatedBy: [ aStream nextPut: $. ] ]		ifFalse: [ accessPoint printOn: aStream ].	aStream		nextPut: $:;		print: self accessPoint port</body><body package="Opentalk-Core">printOn: aStream 	aStream nextPutAll: (#ObjRef &lt;&lt; #opentalk &gt;&gt; 'ObjRef') asString; nextPut: $&lt;.	self printAccessInfoOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Opentalk.ObjRef class</class-id> <category>instance creation</category><body package="Opentalk-Core">newOn: anAccessPoint oid: anOID	^super new initOID: anOID accessPoint: anAccessPoint</body><body package="Opentalk-Core">newOnHostAddress: aHostAddress port: aPort oid: anOID	^self newOn:( IPSocketAddress hostAddress: aHostAddress port: aPort) oid: anOID</body><body package="Opentalk-Core">newOnHostName: hn port: p oid: anOID	^self newOn: ( IPSocketAddress hostName: hn port: p) oid: anOID</body></methods><methods><class-id>Opentalk.AsymmetricConnectionAdaptor class</class-id> <category>defaults-constants</category><body package="Opentalk-Core">defaultIsBiDirectionalValue	^true</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk</category><body package="Opentalk-Core">_isRemote	^false</body><body package="Opentalk-Core">_printString	^self printString</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>accessing</category><body package="Opentalk-Core">quiescentProcessLists	^quiescentProcessLists</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>forwarding</category><body package="Opentalk-Core">doesNotUnderstand: aMessage 	"Forward the message to the remote object through the orb."	"Mark this context as a user level remote send context - for distributed debugging and such"	&lt;aboutToRemoteSend: #UserLevel&gt;		^self _sendMessage: aMessage</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk</category><body package="Opentalk-Core">remotePerform: selector withArguments: args 	"Remote call excution. 	Server objects may override this methods to implement all kinds of message interceptors"	"Mark this context as a user level remote return context - for distributed debugging and such"	&lt;aboutToRemoteReturn: #UserLevel&gt;	^self perform: selector withArguments: args</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>opentalk</category><body package="Opentalk-Core">remotePerform: selector withArguments: args 	"Remote call excution. 	Server objects may override this methods to implement all kinds of message interceptors"	"Mark this context as a user level remote return context - for distributed debugging and such"	&lt;aboutToRemoteReturn: #UserLevel&gt;	^self perform: selector withArguments: args</body></methods><initialize><class-id>UnregisteredObject</class-id></initialize><initialize><class-id>Opentalk.TransportPackageBytes</class-id></initialize><initialize><class-id>Opentalk.RemoteObject</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BinaryStorageBytes</name><environment>Kernel</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>Proxy</name><environment>Opentalk</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>objRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core-Support</package></attributes></class><class><name>ProtoObject</name><environment>Protocols</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>EventManager</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>ProcessorScheduler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quiescentProcessLists activeProcess pausedProcesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>