<?xml version="1.0"?><st-source><!-- Name: Opentalk-GroupsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Opentalk-Groups defines the adaptors, transports, and special request types used in multicast and broadcast communication.Copyright: Copyright © 1999-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 496343DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#package 'Opentalk-STST' ''))PackageName: Opentalk-GroupsParcel: #('Opentalk-Groups')ParcelName: Opentalk-GroupsPrerequisiteParcels: #(#('Opentalk-STST' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:30:44 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:44 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>McastTransport</name><environment>Opentalk</environment><super>Opentalk.UDPTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mcastAddresses </inst-vars><class-inst-vars>defaultMcastAddress </class-inst-vars><imports></imports><category>Opentalk-Groups</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.McastTransport</class-id><body>McastTransport is the  UDPTransport for multicastcast messaging.  It is a UDPTransport with 'soReuseaddr == true'.  Running multiple mcast adaptors on the same port is allowed but it may not work on all udp/ip implementations.Instance Variables:	mcastAddresses	&lt;OrderedCollection&gt; mcast addresses of the groups that transport belongs toClass Instance Variables:	defaultMcastAddress	&lt;ByteArray size: 4&gt; the default mcast address to join</body></comment><class><name>McastEventService</name><environment>Opentalk</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Services</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.McastEventService</class-id><body>An McastEventService wraps a multicast proxy and understands the SysDeps protocol.  It is intended for use on both the sending and receiving ends of a multicast channel.  Its purpose is multiplex event dispatch, so that only one event need to be sent to an image containing several objects that are interested in the event.  It presumes that all receivers on the multicast channel understand the dispatch protocol defined in 'event dispatch'.  Users of this class should be aware of the variance in multicast implementations discussed in the class comment of 'McastObjectAdaptor'.Instance Variables:	sender					&lt;RemoteObject&gt;	a multicast proxyClass Instance Variables:	None.Shared Variables:	EventServiceRegistry	&lt;Dictionary&gt;		of local relays</body></comment><class><name>McastTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.DatagramTransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loopBack mcastAddresses ttl </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Groups</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.McastTransportConfiguration</class-id><body>A McastTransportConfiguration specifies configuration of a multicast transport.Instance Variables:	loopBack	&lt;Boolean&gt; should the sender receive the cast as well ?	mcastAddresses	&lt;OrderedCollection of: (ByteArray size: 4)&gt; the list of multicast channels to join	ttl	&lt;SmallInteger between: 0 and: 255&gt; the value determines the scope of multicasts, bigger number is wider scope</body></comment><class><name>BcastTransport</name><environment>Opentalk</environment><super>Opentalk.UDPTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>groupAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Groups</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.BcastTransport</class-id><body>BcastTransport is the  UDPTransport for broadcast messaging.  It is a UDPTransport with 'soBroadcast == true' and 'soReuseaddr == true'.  Running multiple bcast adaptors on the same port is allowed but it may not work on all udp/ip implementations.Instance Variables:	groupAddress	&lt;ByteArray size: 4&gt; caches the broadcast address for this transport</body></comment><class><name>STSTOnewayRequest</name><environment>Opentalk</environment><super>Opentalk.STSTRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Groups</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.STSTOnewayRequest</class-id><body>STSTOnewayRequestPackage implements the semantics of one-way, remote invocations.  One-way requests do not pass the current process environment, so machinery based on 'opentalkHome' is not functional with these requests.  This is by intent.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>ObjectGroupAdaptorConfiguration</name><environment>Opentalk</environment><super>Opentalk.ConnectionLessAdaptorConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.ObjectGroupAdaptorConfiguration</class-id><body>An ObjectGroupAdaptorConfiguration is used to configure and create an ObjectGroupAdaptor.</body></comment><class><name>BcastTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.DatagramTransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>netmask </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Groups</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.BcastTransportConfiguration</class-id><body>A BcastTransportConfiguration specifies the configuration of a broadcast transport.  It requires specification of a netmask, used to specify the extent of a network directed broadcast.Instance Variables	netmask	&lt;(ByteArray size: 4) | Boolean&gt; bytes of an IP network mask, e.g. #[255 255 255 0], or Boolean indicating network-directed (true) or limited-local (false) broadcast</body></comment><class><name>ObjectGroupAdaptor</name><environment>Opentalk</environment><super>Opentalk.ConnectionLessAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Groups</category><attributes><package>Opentalk-Groups</package></attributes></class><comment><class-id>Opentalk.ObjectGroupAdaptor</class-id><body>ObjectGroupAdaptor implements the adaptor for connectionless, one-way requests.</body></comment><methods><class-id>Opentalk.McastTransport</class-id> <category>protocol-API</category><body package="Opentalk-Groups">doStart	super doStart.	self mcastAddresses do: [ :each |		self socket join: ( IPMulticastRequest toAddress: each ) ]</body><body package="Opentalk-Groups">dropGroup: address"	address	&lt;(ByteArray size: 4) | IPSocketAddress &gt; group to leave, allowing IPSocketAddress for backward compatibility"	| addr |	addr := (address isKindOf: IPSocketAddress)			ifTrue: [ address hostAddress ]			ifFalse: [ address ].	self mcastAddresses remove: addr ifAbsent: [^self].	self socketIsInactiveOrNil ifFalse: [		self socket drop: ( IPMulticastRequest toAddress:  addr ) ].</body><body package="Opentalk-Groups">joinGroup: address"	address	&lt;(ByteArray size: 4) | IPSocketAddress &gt; group to join, allowing IPSocketAddress for backward compatibility"	| addr |	addr := (address isKindOf: IPSocketAddress)			ifTrue: [ address hostAddress ]			ifFalse: [ address ].	self mcastAddresses add: addr.	self socketIsInactiveOrNil ifFalse: [		self socket join: ( IPMulticastRequest toAddress:  addr ) ].</body><body package="Opentalk-Groups">loopBack: aBoolean"Turn on or turn off the multicast loopback.  If loopback is off, the sender does not receive the cast."	self socketIsInactiveOrNil ifFalse: [		socket mLoop: aBoolean ]</body><body package="Opentalk-Groups">setTTL: aByte	self socketIsInactiveOrNil ifFalse: [		socket ttl: aByte ]</body></methods><methods><class-id>Opentalk.McastTransport</class-id> <category>initialize-release</category><body package="Opentalk-Groups">setOptionsOn: aSocketAccessor	super setOptionsOn: aSocketAccessor.	configuration loopBack ifNotNil: [ :loopBack |		aSocketAccessor mLoop: loopBack ].	configuration ttl ifNotNil: [ :ttl |		aSocketAccessor ttl: ttl ].</body></methods><methods><class-id>Opentalk.McastTransport</class-id> <category>accessing</category><body package="Opentalk-Groups">groupAddress	^self mcastAddresses first</body><body package="Opentalk-Groups">mcastAddresses	^mcastAddresses ifNil: [		mcastAddresses := 			configuration mcastAddresses				ifNil: [ Array with: self class defaultMcastAddress ]				ifNotNil: [ :addrs | addrs copy ] ]</body></methods><methods><class-id>Opentalk.McastTransport</class-id> <category>private</category><body package="Opentalk-Groups">isGroupObjRef: objRef		^self mcastAddresses includes: objRef accessPoint hostAddress	"Old implementation allows any mcast address, but our standard practice is to check for specific access address.		IPMulticastRequest inMulticast: ( objRef accessPoint hostAddress )"</body></methods><methods><class-id>Opentalk.McastTransport class</class-id> <category>accessing</category><body package="Opentalk-Groups">defaultMcastAddress	^defaultMcastAddress ifNil: [ self defaultMcastAddressValue ]</body><body package="Opentalk-Groups">defaultMcastAddress: address"	address	&lt;ByteArray size: 4&gt; the default mcast address to join"	defaultMcastAddress := address</body><body package="Opentalk-Groups">defaultMcastAddressValue	^#[224 5 6 7]</body><body package="Opentalk-Groups">protocolTag	^'mcast'</body></methods><methods><class-id>Opentalk.McastTransport class</class-id> <category>defaults-constants</category><body package="Opentalk-Groups">defaultSoReuseAddrValue	"Note: Running multiple mcast adaptors on the same port is allowed 	but it may not work on all udp/ip implementations"	^true</body></methods><methods><class-id>Opentalk.McastEventService</class-id> <category>event triggering</category><body package="Opentalk-Groups">triggerEvent: eventName	^self sender dispatchEvent: eventName</body><body package="Opentalk-Groups">triggerEvent: eventName ifNotHandled: exceptionBlock	^(self eventTable		at: eventName asSymbol		ifAbsent: [^exceptionBlock value])			evaluate</body><body package="Opentalk-Groups">triggerEvent: eventName with: argument	^self sender		dispatchEvent: eventName		with: argument</body><body package="Opentalk-Groups">triggerEvent: eventName with: firstArgument with: secondArgument	^self sender		dispatchEvent: eventName 		with: firstArgument 		with: secondArgument</body><body package="Opentalk-Groups">triggerEvent: eventName withArguments: argumentList	^self sender 		dispatchEvent: eventName 		withArguments: argumentList asArray</body><body package="Opentalk-Groups">triggerEvent: eventName withArguments: argumentList ifNotHandled: exceptionBlock	^(self eventTable		at: eventName asSymbol		ifAbsent: [^exceptionBlock value])			evaluateWithArguments: argumentList</body></methods><methods><class-id>Opentalk.McastEventService</class-id> <category>accessing</category><body package="Opentalk-Groups">sender	^sender</body><body package="Opentalk-Groups">sender: aRemoteObject	sender := aRemoteObject</body></methods><methods><class-id>Opentalk.McastEventService</class-id> <category>event dispatch</category><body package="Opentalk-Groups">dispatchEvent: eventName	^super triggerEvent: eventName withArguments: #()</body><body package="Opentalk-Groups">dispatchEvent: eventName with: argument	^super		triggerEvent: eventName		withArguments: (Array with: argument)</body><body package="Opentalk-Groups">dispatchEvent: eventName with: firstArgument with: secondArgument	^super		triggerEvent: eventName 		withArguments: (Array			with: firstArgument 			with: secondArgument)</body><body package="Opentalk-Groups">dispatchEvent: eventName withArguments: argumentList	^super		triggerEvent: eventName 		withArguments: argumentList asArray</body></methods><methods><class-id>Opentalk.McastEventService class</class-id> <category>events</category><body package="Opentalk-Groups">canTriggerEvent: eventName	^true</body></methods><methods><class-id>Opentalk.McastTransportConfiguration</class-id> <category>accessing</category><body package="Opentalk-Groups">componentClass	^McastTransport</body><body package="Opentalk-Groups">loopBack	^loopBack</body><body package="Opentalk-Groups">loopBack: aBoolean"	aBoolean &lt;Boolean&gt; should the sender receive the cast as well ?"	loopBack := aBoolean</body><body package="Opentalk-Groups">mcastAddresses	^mcastAddresses</body><body package="Opentalk-Groups">mcastAddresses: addresses"	addresses	&lt;OrderedCollection of: (ByteArray size: 4)&gt; the list of multicast channels to join"	(addresses allSatisfy: [ :address | IPMulticastRequest inMulticast: address ]) ifFalse: [		self error: (#NotAnIPMulticastAddress &lt;&lt; #opentalk &gt;&gt; 'Not an IP multicast address.') ].	mcastAddresses := addresses</body><body package="Opentalk-Groups">ttl	^ttl</body><body package="Opentalk-Groups">ttl: scope"	scope	&lt;SmallInteger between: 0 and: 255&gt; the value determines the scope of multicasts, bigger number is wider scope"	ttl := scope</body></methods><methods><class-id>Opentalk.McastTransportConfiguration class</class-id> <category>accessing</category><body package="Opentalk-Groups">componentClass	^McastTransport</body></methods><methods><class-id>Opentalk.BcastTransport</class-id> <category>initialize-release</category><body package="Opentalk-Groups">setOptionsOn: aSocketAccessor	aSocketAccessor soBroadcast: true.	super setOptionsOn: aSocketAccessor</body></methods><methods><class-id>Opentalk.BcastTransport</class-id> <category>private</category><body package="Opentalk-Groups">groupAddress	^groupAddress ifNil: [ | mask |		mask := self configuration netmask.		groupAddress := 			mask isSequenceable				ifTrue: [ self networkAddressWithMask: mask ]				ifFalse: [					mask						ifTrue: [ self networkAddressWithDefaultMask ]						ifFalse: [ self limitedLocalAddress ] ] ]</body><body package="Opentalk-Groups">isGroupObjRef: objRef 	^objRef accessPoint hostAddress = self groupAddress</body><body package="Opentalk-Groups">limitedLocalAddress"This is address indicates limited (local network only) broadcast address. It is never forwarded by routers."	^#[255 255 255 255]</body><body package="Opentalk-Groups">networkAddressWithDefaultMask"Figure out the commonly used netmask, give the class of accessAddress, then apply the netmask to the accessAddress.Assume common netmask setup	Class C (e.g. 192.168.1...) - no subnets	Class B (e.g. 172.16.1...) - 8-bit subnets	Class A (e.g. 10.1...) - 16-bit subnets"	| class mask |	class := manager accessAddress first.	mask := 		class &lt; 128			ifTrue: [ "Class A"				#[ 255 255 0 0 ] ]			ifFalse: [ "Classes B and C will use the same netmask"				#[ 255 255 255 0 ] ].	^self networkAddressWithMask: mask</body><body package="Opentalk-Groups">networkAddressWithMask: netmask"Compute a network directed broadcast address for network indicated by the accessAddress and the netmask.The unmasked bits should all be set to 1."	| ba c |	ba := ByteArray new: 4.	c := 1.	manager accessAddress		with: netmask		do: [ :a :m |			ba at: c put: (a bitOr: (m bitXor: 255)).			c := c + 1 ].	^ba</body></methods><methods><class-id>Opentalk.BcastTransport class</class-id> <category>accessing</category><body package="Opentalk-Groups">protocolTag	^'bcast'</body></methods><methods><class-id>Opentalk.BcastTransport class</class-id> <category>defaults-constants</category><body package="Opentalk-Groups">defaultSoReuseAddrValue	"Note: Running multiple bcast adaptors on the same port is allowed 	but it may not work on all udp/ip implementations"	^true</body></methods><methods><class-id>Opentalk.STSTOnewayRequest</class-id> <category>dispatching</category><body package="Opentalk-Groups">dispatchFor: aConnection 	"Fork a working thread to handle the remote request"	target == UnregisteredObject default		ifTrue: ["Do nothing"]		ifFalse: [super dispatchFor: aConnection]</body><body package="Opentalk-Groups">sendReply: anObject for: aConnection	"Override to do nothing"</body></methods><methods><class-id>Opentalk.STSTOnewayRequest</class-id> <category>initialize-release</category><body package="Opentalk-Groups">initWith: msg to: anObject timeout: ms 	"... client side initialization."	super		initWith: msg		to: anObject		timeout: ms</body></methods><methods><class-id>Opentalk.STSTOnewayRequest</class-id> <category>invocation</category><body package="Opentalk-Groups">sendAndWaitForReply: aTransport	"Just send request and don't wait for reply"	self serviceContext: (self getProcessEnvironmentAssociations: aTransport).	aTransport sendPackage: self.	^nil</body></methods><methods><class-id>Opentalk.STSTOnewayRequest class</class-id> <category>accessing</category><body package="Opentalk-Groups">msgType	^4</body></methods><methods><class-id>Opentalk.STSTOnewayRequest class</class-id> <category>class initialization</category><body package="Opentalk-Groups">initialize	STSTStream 		addSpecialType: STSTOnewayRequest 		dispatchAs: [:mySelf :anObject | 						mySelf nextPut: 137.						mySelf nextPutSTSTRequest: anObject];		addTag: 137		dispatchAs: [ :obj | obj nextSTSTOnewayRequest ]</body></methods><methods><class-id>Opentalk.ObjectGroupAdaptorConfiguration</class-id> <category>accessing</category><body package="Opentalk-Groups">componentClass	^ObjectGroupAdaptor</body></methods><methods><class-id>Opentalk.BcastTransportConfiguration</class-id> <category>accessing</category><body package="Opentalk-Groups">componentClass	^BcastTransport</body><body package="Opentalk-Groups">netmask	^netmask ifNil: [ false ]</body><body package="Opentalk-Groups">netmask: a4ByteArray	netmask := a4ByteArray</body><body package="Opentalk-Groups">networkDirected: aBoolean"Instead of specifying the netmask, use either the limited (local) broadcast address (false), or guess the netmask for a network directed broadcast based on the address class (true)."	netmask := aBoolean</body><body package="Opentalk-Groups">networkDirectedWithNetmask: a4ByteArray	netmask := a4ByteArray</body><body package="Opentalk-Groups">networkDirectedWithNetmaskWidth: numberOfBits"Parameter numberOfBits represents the number of 1s in the binary representation of netmask.E.g. 255.255.128.0 -&gt; 17 or 255.255.255.0 -&gt; 24"	| w |	netmask := ByteArray new: 4.	w := numberOfBits.	1 to: 4 do: [ :i |		netmask at: i put: (w &gt; 0			ifTrue: [ w := w - 8.				w &gt;= 0					ifTrue: [ 255 ]					ifFalse: [ 256 - (2 ** w abs) ] ]			ifFalse: [ 0 ] ) ]</body></methods><methods><class-id>Opentalk.BcastTransportConfiguration class</class-id> <category>accessing</category><body package="Opentalk-Groups">componentClass	^BcastTransport</body></methods><methods><class-id>Opentalk.ObjectGroupAdaptor</class-id> <category>private</category><body package="Opentalk-Groups">groupAccessPoint	^IPSocketAddress		hostAddress: self transport groupAddress		port: self accessPoint port</body><body package="Opentalk-Groups">isLocalObjRef: objRef 	^(super isLocalObjRef: objRef)		or: [self accessPoint port = objRef accessPoint port			and: [ transport isGroupObjRef: objRef ] ]</body><body package="Opentalk-Groups">requestClass	^STSTOnewayRequest</body></methods><methods><class-id>Opentalk.TransportConfiguration class</class-id> <category>types</category><body package="Opentalk-Groups">bcast	^BcastTransportConfiguration new</body><body package="Opentalk-Groups">mcast	^McastTransportConfiguration new</body></methods><methods><class-id>Opentalk.AdaptorConfiguration class</class-id> <category>types</category><body package="Opentalk-Groups">objectGroups	^ObjectGroupAdaptorConfiguration new</body></methods><methods><class-id>Opentalk.BasicRequestBroker class</class-id> <category>instance creation</category><body package="Opentalk-Groups">newStstBcastAt: anIPSocketAddress	^(StandardBrokerConfiguration new		adaptor: (ObjectGroupAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (BcastTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAt: anIPSocketAddress</body><body package="Opentalk-Groups">newStstBcastAtPort: aNumber	^(StandardBrokerConfiguration new		adaptor: (ObjectGroupAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (BcastTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAtPort: aNumber</body><body package="Opentalk-Groups">newStstMcastAt: anIPSocketAddress	^(StandardBrokerConfiguration new		adaptor: (ObjectGroupAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (McastTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAt: anIPSocketAddress</body><body package="Opentalk-Groups">newStstMcastAtPort: aNumber	^(StandardBrokerConfiguration new		adaptor: (ObjectGroupAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (McastTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAtPort: aNumber</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>remoteObj-API</category><body package="Opentalk-Groups">groupAt: anAccessPoint id: oid	"Create a proxy for a multicast based group"	| objRef |	(IPMulticastRequest inMulticast: anAccessPoint hostAddress) ifFalse: [		self error: (#NotAnIPMulticastAddress &lt;&lt; #opentalk &gt;&gt; 'Not an IP multicast address.') ].	objRef := ObjRef newOn: anAccessPoint oid: oid.	^self findOrCreateRemoteObject: objRef</body><body package="Opentalk-Groups">groupById: oid 	"Create a proxy for a broadcast based group"	| objRef |	objRef := ObjRef newOn: objectAdaptor groupAccessPoint oid: oid.	^self findOrCreateRemoteObject: objRef</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>marshaling - low-level decoding</category><body package="Opentalk-Groups">nextSTSTOnewayRequest	^(STSTOnewayRequest		request: self nextMessage 		to: (self next; nextObjRef)  		id: self nextLong		context: self unmarshalObjectRecursively	)	interceptorDispatcher: self manager provideInterceptorDispatcher;		yourself</body></methods><initialize><class-id>Opentalk.STSTOnewayRequest</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>EventManager</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class><class><name>STSTRequest</name><environment>Opentalk</environment><super>Opentalk.RemoteRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><class><name>DatagramTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.TransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soReuseAddr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>ConnectionLessAdaptor</name><environment>Opentalk</environment><super>Opentalk.BasicObjectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>UDPTransport</name><environment>Opentalk</environment><super>Opentalk.DatagramTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket tryRestart port </inst-vars><class-inst-vars>defaultSoReuseAddr </class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><class><name>BasicRequestBroker</name><environment>Opentalk</environment><super>Opentalk.RestartProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>remoteObjectRegistry objectAdaptor requestType requestTimeout </inst-vars><class-inst-vars>brokerId defaultPort defaultRequestTimeout </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>ConnectionLessAdaptorConfiguration</name><environment>Opentalk</environment><super>Opentalk.AdaptorConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>STSTStream</name><environment>Opentalk</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectToIndex manager nextIndex swap scratchBuffer isBigEndianPlatform objects index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class></st-source>