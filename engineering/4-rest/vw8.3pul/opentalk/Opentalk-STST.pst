<?xml version="1.0"?><st-source><!-- Name: Opentalk-STSTNotice: Copyright 2008-2016 Cincom Systems, Inc.  All rights reserved.Comment: Opentalk-STST defines the marshallers, connections, packages, adaptors, and brokers that comprise the smalltalk-to-smalltalk unicast communication layer.Copyright: Copyright © 1999-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 496342DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#package 'Opentalk-Core' ''))PackageName: Opentalk-STSTParcel: #('Opentalk-STST')ParcelName: Opentalk-STSTPrerequisiteParcels: #(#('Opentalk-Core' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:30:44 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:44 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>STSTRequest</name><environment>Opentalk</environment><super>Opentalk.RemoteRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.STSTRequest</class-id><body>STSTRequest represent a Smalltalk-to-Smalltalkremote message invocation.  The service context is used to pass the home interface, debugging, transaction, and session information, and other such things to the remote execution site.Instance Variables:	serviceContext		&lt;OrderedCollection&gt;		'ProcessEnvironment current environmentDictionary associations' of the Class Instance Variables:	None.Class Shared Variables:	BreakSelector	&lt;Symbol|UndefinedObject&gt;	the selector for remote breaks</body></comment><class><name>TCPTransport</name><environment>Opentalk</environment><super>Opentalk.StreamTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.TCPTransport</class-id><body>TCPTransport implements standard TCP transport.Instance Variables:	socket	&lt;SocketAccessor&gt;	the socket	timeout	&lt;Integer&gt;		the socket readWait and writeWait timeout</body></comment><class><name>OtEUnrecognizedPassMode</name><environment>Opentalk</environment><super>Opentalk.OtEMarshaling</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.OtEUnrecognizedPassMode</class-id><body>An OtEUnknownPassMode exception is raised when an attempt is made to control an instance variable's pass mode using an unrecognized pass mode designator.</body></comment><class><name>STSTReply</name><environment>Opentalk</environment><super>Opentalk.RemoteReply</super><private>false</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.STSTReply</class-id><body>STSTReply represents a message that is the return from a remote invocation.Instance Variables:	destination 	&lt;IPSocketAddress&gt; 	used only for UDP protocols to address the destinationClass Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>STSTErrorReply</name><environment>Opentalk</environment><super>Opentalk.STSTReply</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.STSTErrorReply</class-id><body>STSTErrorReply is a message that represents an error return from a remote invocation.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>UDPTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.DatagramTransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.UDPTransportConfiguration</class-id><body>A UDPTransportConfiguration is used to configure and create a UDPTransport.</body></comment><class><name>STSTMarshalerConfiguration</name><environment>Opentalk</environment><super>Opentalk.MarshalerConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.STSTMarshalerConfiguration</class-id><body>A STSTMarshalerConfiguration is used to configure and create a STSTMarshaler.</body></comment><class><name>PassModeWrapper</name><environment>Opentalk</environment><super>Opentalk.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>passMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.PassModeWrapper</class-id><body>PassModeWrapper is used to overwrite the default object pass mode (defined by the object class, or in the SpecialTypeDispatchTable of the marshalling stream) of the object wrapped in it.  This class is internal to the Opentalk Core.  This class should not be employed in user-level code, without a *full* understanding of the marshalling machinery.Instance Variables:	passMode	&lt;Symbol&gt; the pass mode to use for the wrapped object</body></comment><class><name>STSTStream</name><environment>Opentalk</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectToIndex manager nextIndex swap scratchBuffer isBigEndianPlatform objects index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.STSTStream</class-id><body>STSTStream is the stream employed for marshalling and unmarshalling messages employing the STST protocol.  STSTStream now implements version 2.0 of the Opentalk STST protocol.  It is not backwardly compatible with Opentalk STST 1.0, the version of the STST protocol found in previous releases.  In version 2.0, the SpecialTypeDispatchTable and the TagDispatchTable have been extended to support more optimal, class-specific marshaling machinery for commonly used classes.  In both tables, several blocks of tags are reserved for customer use.  Also, two new pass modes are supported -- pass-by-name and pass-by-OID, and the pass mode code has been updated accordingly.  The pass-by-name implementation allows Classes, NameSpaces, NameSpacesOfClasses, BindingReferences, LiteralBindingReferences, and Signals to be passed by name using, for example, '#{Object.DependentsFields} asPassedByName'.  On receipt, a passed-by-name object will resolve to either (a) the local object that bears the passed name or (b) an exception if there is no such object.  The default pass mode for the several classes mentioned will remain '#reference', because pass-by-name is reliable only in cases where identity of implementation (or a scrupulously calculated divergence in implementation) is assured.  The pass-by-OID implementation supports applications that pre-replicate objects to all involved locales.  In such cases, if a replicated object is an argument to a remotely invoked operation, it is a waste of resources to pass the replicate by either reference or value: pass-by-reference entails remote message sends, while pass-by-value entails the marshaling of a complete copy.  In contrast, pass-by-OID allows pre-replicated objects to be passed by no more than the object identifier (OID) under which they were pre-registered in the object tables of the adaptors at both the sending and the receiving locales.  A passed-by-OID object, on receipt, resolves to either (a) its local replicate, or (b) an exception if the passed OID has not been pre-registered in the object tables of both sending and receiving object adaptors.Instance Variables:	objectToIndex			&lt;IdentityDictionary&gt;			of instream references for marshaling		manager				&lt;GenericProtocol&gt;			an adaptor or connection	nextIndex				&lt;Integer&gt;					for indexing into 'objects'	swap					&lt;Boolean&gt;					for mixed endianness	scratchBuffer			&lt;BinaryStorageBytes&gt;		for flipping endianness	isBigEndianPlatform		&lt;Boolean&gt;					indicating local endianness	objects					&lt;IdentitySet&gt;				objects that are indexed in 'index'	index					&lt;OrderedCollection&gt; 		index of instream references of objects that are being marshaled by valueClass Instance Variables:	None.Class Shared Variables:	PassModeTable				&lt;IdentityDictionary&gt;		dispatch table for pass mode control keyed by pass mode designators	SpecialTypeDispatchTable	&lt;IdentityDictionary&gt;		dispatch tale for encoding keyed by Classes or Symbols	TagDispatchTable			&lt;Array&gt;					dispatch table for decoding using numeric type tags</body></comment><class><name>OtEMarshalingFullBlock</name><environment>Opentalk</environment><super>Opentalk.OtEMarshaling</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.OtEMarshalingFullBlock</class-id><body>An OtEMarshalingFullBlock exception is raised when an attempt is made to pass a possible full block by value.</body></comment><class><name>TCPTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.StreamTransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.TCPTransportConfiguration</class-id><body>A TCPTransportConfiguration is used to configure and create a TCPTransport.</body></comment><class><name>STSTCloseConnection</name><environment>Opentalk</environment><super>Opentalk.RemoteMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>TheOne </class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.STSTCloseConnection</class-id><body>STSTCloseConnection is a message used to inform the communication peer that the connection is going to be closed.  It is a oneway call (i.e. it requires no reply).  Upon receiving this message, just force close the connection.Instance Variables:	None.Class Instance Variables:	TheOne		&lt;STSTCloseConnection|UndefinedObject&gt;	the sole required instanceShared Variables:	None.</body></comment><class><name>UDPTransport</name><environment>Opentalk</environment><super>Opentalk.DatagramTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket tryRestart port </inst-vars><class-inst-vars>defaultSoReuseAddr </class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.UDPTransport</class-id><body>UDPTransport implements standard UDP transport.Instance Variables	socket	&lt;SocketAccessor&gt; the socket	tryRestart	&lt;Boolean&gt; the restart flag	port	&lt;SmallInteger&gt; the port number to useClass Instance Variables	defaultSoReuseAddr	&lt;Boolean | UndefinedObject&gt; the default value for SO_REUSEADDR socket option</body></comment><class><name>OtEMarshalingPassByName</name><environment>Opentalk</environment><super>Opentalk.OtEMarshaling</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.OtEMarshalingPassByName</class-id><body>An OtEMarshalingPassByName exception is raised when an attempt to pass an object by name fails.  This may be due to [1] unmarshaling errors in the receiver, [2] an attempt to change the pass mode of an object that cannot be passed by name to pass by name in the sender.</body></comment><class><name>STSTMarshaler</name><environment>Opentalk</environment><super>Opentalk.Marshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ststStream </inst-vars><class-inst-vars>defaultBufferSize </class-inst-vars><imports></imports><category>Opentalk-STST</category><attributes><package>Opentalk-STST</package></attributes></class><comment><class-id>Opentalk.STSTMarshaler</class-id><body>Instance Variables:	ststStream			&lt;STSTStream&gt;						the marshaling streamClass Instance Variables:	defaultBufferSize	&lt;SmallInteger | UndefinedObject&gt; 	the default size of marshaling buffers</body></comment><shared-variable><name>BreakSelector</name><environment>Opentalk.STSTRequest</environment><private>false</private><constant>false</constant><category>debugging</category><attributes><package>Opentalk-STST</package></attributes></shared-variable><shared-variable><name>SpecialTypeDispatchTable</name><environment>Opentalk.STSTStream</environment><private>true</private><constant>false</constant><category>tables</category><attributes><package>Opentalk-STST</package></attributes></shared-variable><shared-variable><name>PassModeTable</name><environment>Opentalk.STSTStream</environment><private>true</private><constant>false</constant><category>tables</category><attributes><package>Opentalk-STST</package></attributes></shared-variable><shared-variable><name>TagDispatchTable</name><environment>Opentalk.STSTStream</environment><private>false</private><constant>false</constant><category>tables</category><attributes><package>Opentalk-STST</package></attributes></shared-variable><methods><class-id>Opentalk.STSTRequest</class-id> <category>accessing</category><body package="Opentalk-STST">destination	^target accessPoint</body><body package="Opentalk-STST">environmentAssociations	^self serviceContext</body><body package="Opentalk-STST">serviceContext	"Return the service context"	^serviceContext</body><body package="Opentalk-STST">serviceContext: aContextObject	"Set the service context"	serviceContext := aContextObject</body></methods><methods><class-id>Opentalk.STSTRequest</class-id> <category>udp-support</category><body package="Opentalk-STST">source	"Only used in STSTUDP server"	^promise</body><body package="Opentalk-STST">source: anIPSocketAddress "Only used in StstUdp server. Just overload the promise which is not used on the server side."	promise := anIPSocketAddress</body></methods><methods><class-id>Opentalk.STSTRequest</class-id> <category>invocation</category><body package="Opentalk-STST">getProcessEnvironmentAssociations: aConnection		^(ProcessEnvironment current environmentDictionary associations		reject: [ :assoc | assoc key = #WindowManager ]),	(aConnection transportEnvironmentAssociationsFor: self)</body><body package="Opentalk-STST">remoteExceptionReturn: anException	^anException</body><body package="Opentalk-STST">sendAndWaitForReply: aConnection 	self serviceContext: (self getProcessEnvironmentAssociations: aConnection).	^super sendAndWaitForReply: aConnection</body></methods><methods><class-id>Opentalk.STSTRequest</class-id> <category>dispatching</category><body package="Opentalk-STST">doTheWorkFor: aConnection	"Perform the user remote call"	( message selector = self class breakSelector )		ifTrue:	[ self halt: (#RemoteEvaluationBreak &lt;&lt; #opentalk &gt;&gt; 'Remote Evaluation Break') ].	^target remotePerform: message selector withArguments: message arguments.</body><body package="Opentalk-STST">evaluateFor: aConnection 	target := aConnection adaptor objectByRef: target.	self validate.	self setProcessEnvironmentAssociations: aConnection.	super evaluateFor: aConnection</body><body package="Opentalk-STST">handleEvaluationError: anException in: aConnection	super handleEvaluationError: anException in: aConnection.	self returnError: anException through: aConnection</body><body package="Opentalk-STST">replyForResult: anObject 	^(STSTReply return: anObject to: self source requestId: self requestId)		interceptorDispatcher: self interceptorDispatcher;		yourself</body><body package="Opentalk-STST">setProcessEnvironmentAssociations: aConnection 	serviceContext == nil ifFalse:	[ | edic |		edic := ProcessEnvironment current environmentDictionary.		(aConnection nonTransportEnvironmentAssociationsFrom: self)			do: [ :each | edic add: each ] ]</body></methods><methods><class-id>Opentalk.STSTRequest</class-id> <category>private</category><body package="Opentalk-STST">handleReplyError: anError in: aConnection"Previous attempt to send a reply has failed. Let's log anError and try to send it to the caller if the transport layer is ok.Otherwise the caller will have to wait until the request timeout expires to know there's something wrong."	| response |	super handleReplyError: anError in: aConnection.	(OtECommunicationFailure handles: anError) ifTrue: [^self].	[	"This is most likely a marshaling error, let's try sending that one"		response := STSTErrorReply			return: anError clearForReraise			to: self source			requestId: self requestId.		response			interceptorDispatcher: self interceptorDispatcher;			send: aConnection	] 	on: Error		do: [ :error | "Just log another failure and give up to avoid recursive failures"			self sendingReply: response in: aConnection failedBecause: error ]</body><body package="Opentalk-STST">returnError: ex through: aConnection	[	reply := STSTErrorReply			return: ex clearForReraise			to: self source			requestId: self requestId.		reply			interceptorDispatcher: self interceptorDispatcher;			send: aConnection	] 	on: Error		do: [ :error |			self handleReplyError: error in: aConnection ]</body><body package="Opentalk-STST">validate	( ( target == UnregisteredObject default ) or: [ target _isRemote ] )		ifTrue:	[	OtEInvalidObjectReference 						raiseSignal: (#ReceiverNotOnServer &lt;&lt; #opentalk &gt;&gt; 'The message receiver is not on the server.').					^false				].	message arguments do:		[ :a | ( a == UnregisteredObject default )				ifTrue:	[	OtEInvalidObjectReference 								raiseSignal: (#ArgumentNotOnServer &lt;&lt; #opentalk &gt;&gt; 'A message argument is not on the server.').							^false						]		].	^true.</body></methods><methods><class-id>Opentalk.STSTRequest class</class-id> <category>debugging</category><body package="Opentalk-STST">breakSelector	^BreakSelector</body><body package="Opentalk-STST">breakSelector: aSymbol	"Set the breakSelector. When server	got a message with the same selector, halt at dispatching.	Useful during the debugging"	BreakSelector := aSymbol</body><body package="Opentalk-STST">clearBreak	BreakSelector := nil</body></methods><methods><class-id>Opentalk.STSTRequest class</class-id> <category>instance creation</category><body package="Opentalk-STST">request: msg to: anObject id: aId context: aContext	"... used by the client to construct an outgoing request."	^super new 		message: msg; 		target: anObject; 		requestId: aId;		serviceContext: aContext.</body></methods><methods><class-id>Opentalk.STSTRequest class</class-id> <category>accessing</category><body package="Opentalk-STST">msgType	^0</body></methods><methods><class-id>Opentalk.STSTRequest class</class-id> <category>compiler support</category><body package="Opentalk-STST">pragmas	^#(#remoteReturn)</body></methods><methods><class-id>Opentalk.TCPTransport</class-id> <category>private</category><body package="Opentalk-STST">checkHeader	readBuffer isValid ifFalse: [		OtEProtocol raiseSignal: (#ProtocolMismatch &lt;&lt; #opentalk &gt;&gt; 'Protocol Mismatch')].</body><body package="Opentalk-STST">handleIncomingMessageError: anException	super handleIncomingMessageError: anException.	self stop</body><body package="Opentalk-STST">nextBuffer: aBuffer size: aSize startingAt: position	^[	| readSize chunkSize |		readSize := 0.		chunkSize := 100. "Just to let us into the first iteration of the loop, the value is otherwise meaningless"		[ readSize &lt; aSize and: [ chunkSize &gt; 0 and: [ (socket readWaitWithTimeoutMs: timeout) not] ]		] whileTrue: [			chunkSize := socket					readInto: aBuffer					startingAt: position + readSize					for: aSize - readSize.			readSize := readSize + chunkSize ].		readSize = 0 ifTrue: [			OtECommunicationFailure raiseSignal: (				(#x1sSocketPossiblyClosed &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket malfunction, possibly closed by the other party')					expandMacrosWith: self printString)].		readSize = aSize ifFalse: [			OtECommunicationFailure raiseSignal: (				(#x1sSocketReadFailed2s3s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket read failed. Expected &lt;2s&gt; and got &lt;3s&gt;')					expandMacrosWith: self printString					with: aSize printString					with: readSize printString) ].		aBuffer	]	on: OsError do: [ :ex |			ex resignalAs: (				OtECommunicationFailure new					messageText: (						(#x1sFailed2s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; failed - &lt;2s&gt;')							expandMacrosWith: self printString							with: ex printString);					yourself) ]</body><body package="Opentalk-STST">readTransportPackage"Read in the body of the incoming message.Here the expectation is that the header was already read in and that it check out."	| size |	"Note that in many cases the readBuffer is reused. Also note that if one huge message comes in,	the readBuffer will stay large even though all the subsequent messages are tiny.	We may want to throw in some configurable policy here."	readBuffer isBigEnoughForMessageBody ifFalse: [ readBuffer growToFitTheMessageBody ].	(size := readBuffer msgSize) = 0 ifFalse: [		readBuffer := self nextBuffer: readBuffer size: size startingAt: readBuffer headerSize + 1].	^TransportPackage newOn: readBuffer</body><body package="Opentalk-STST">readTransportPackageHeader	readBuffer := self nextBuffer: readBuffer size: readBuffer headerSize startingAt: 1.	self checkHeader</body><body package="Opentalk-STST">readyToHandleIncomingMessage"Let's quit the server loop if no message arrives within timeout period"	| timedOut |	[	super readyToHandleIncomingMessage ifFalse: [^false].		(timedOut := socket readWaitWithTimeoutMs: timeout)		and: [ self commenceTimeOut not ]	] whileTrue.	^timedOut not</body><body package="Opentalk-STST">receiveTransportPackage	self readTransportPackageHeader.	^super receiveTransportPackage</body><body package="Opentalk-STST">sendTransportPackage: aTransportPackage	super sendTransportPackage: aTransportPackage.	[	| writeSize pkgSize |		pkgSize := aTransportPackage position.		writeSize := 0.		[ writeSize &lt; pkgSize and: [(socket writeWaitWithTimeoutMs: timeout) not ] ] whileTrue: [			writeSize := writeSize +					(socket						writeFrom: aTransportPackage buffer						startingAt: 1 + writeSize						for: pkgSize - writeSize) ].		writeSize = pkgSize ifFalse: [			OtECommunicationFailure raiseSignal: (				(#x1sSocketWriteFailed2s3s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket write failed. Wanted &lt;2s&gt; and got &lt;3s&gt;')					expandMacrosWith: self printString					with: pkgSize printString					with: writeSize printString) ]	] 	on: OsError do: [:ex |		"This is likely a connection failure so let's skip connection closing handshake,		especially because the handshake itself needs this part working smoothly as well		(See AR 42265 for more details)"			self doStop.			ex resignalAs: (				OtECommunicationFailure new					messageText: (						(#x1sFailed2s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; failed - &lt;2s&gt;')							expandMacrosWith: self printString							with: ex printString);					yourself) ]</body><body package="Opentalk-STST">socket	^socket</body><body package="Opentalk-STST">timeout	^timeout</body></methods><methods><class-id>Opentalk.TCPTransport</class-id> <category>initialize-release</category><body package="Opentalk-STST">initializeStreams"Since we're always reading a know number of bytes let's skip the stream overhead for this one.	writeStream := ((ExternalConnection new) input: socket; output: socket) writeStream.	readStream := ((ExternalConnection new) input: socket; output: socket) readStream.	writeStream binary.	readStream binary." "Note that using streams is causing troubles with socket readWait as the driving condition of the server loop. If there are 2 messages incoming when the first one is read, the second one will get sucked into the BufferedExternalStream buffers and readWait will block because the data for the second message are not in the socket anymore."</body><body package="Opentalk-STST">setManager: aManager id: aConnectionId socket: aSocket	timeout := aManager connectionTimeout.	socket := aSocket.	"Need to set socket first because streams are created on top of it."	super setManager: aManager id: aConnectionId socket: aSocket.</body></methods><methods><class-id>Opentalk.TCPTransport</class-id> <category>protocol-API</category><body package="Opentalk-STST">closePeer	"Inform my peer that I'm going down"	self peerOK ifTrue: [ 		STSTCloseConnection theOne send: self ]</body><body package="Opentalk-STST">commenceTimeOut	^manager clientConnections		at: self peerId		ifAbsent: [ "self is the server side of an asymmetric connection"			true ]		ifPresent: [ :t |			self == t 				ifTrue: [ self hasPendingRequests						ifTrue: [ false ]						ifFalse: [ "Retract the transport so that someone doesn't start sending before we manage to shut it down"							manager clientConnections removeKey: self peerId ifAbsent: [].							true ] ]				ifFalse: [ "Another transport already replaced me (unusual)"					true ] ]</body><body package="Opentalk-STST">doStop	socket isNil ifFalse: [		socket close.		socket := nil].	super doStop.</body><body package="Opentalk-STST">peerClose	state := self pStopping.	self stop.</body><body package="Opentalk-STST">peerOK	"Answer true if my peer is ok and false otherwise."	^[	(	socket isNil			or: [ socket getPeer.				socket errorCode notNil ]		) not	]	on: Error		do: [:ex | ex return: false ]</body><body package="Opentalk-STST">preStop	super preStop.	"We need to terminate the server rpocess before sending close request,	otherwise the broken pipe will cause the server loop to run once more with no data"	self isRunning ifTrue: [		state := self pStopping.		self stopServerProcess.		self closePeer ]</body></methods><methods><class-id>Opentalk.TCPTransport</class-id> <category>protocol-states</category><body package="Opentalk-STST">pStopping	^#stopping</body></methods><methods><class-id>Opentalk.TCPTransport</class-id> <category>printing</category><body package="Opentalk-STST">printAccessInfoOn: aStream	super printAccessInfoOn: aStream.	id notNil ifTrue: [		aStream nextPut: $/.		id hostAddress			do: [ :e | aStream print: e ]			separatedBy: [ aStream nextPut: $.].		aStream nextPut: $:.		id port printOn: aStream].	peerId ifNotNil: [		aStream nextPut: $(;			print: peerId port;			nextPut: $) ]</body></methods><methods><class-id>Opentalk.TCPTransport class</class-id> <category>accessing</category><body package="Opentalk-STST">protocolTag	^'tcp'</body></methods><methods><class-id>Opentalk.TCPTransport class</class-id> <category>private</category><body package="Opentalk-STST">new: aConfiguration socketTo: anIPSocketAddress for: aManager"Create a socket connected to the given remote address"	| skt |	skt := SocketAccessor 				family: anIPSocketAddress domainCode				type: SocketAccessor SOCK_STREAM.	[ skt connectTo: anIPSocketAddress timeout: aManager connectingTimeout ]		on: OsError		do: [ :ex | ex resignalAs: (			OtECommunicationFailure new				messageText: (					(#FailedToConnectTo1s &lt;&lt; #opentalk &gt;&gt; 'Failed to establish connection to &lt;1s&gt;')						expandMacrosWith: anIPSocketAddress printString);				yourself) ].	^skt</body></methods><methods><class-id>Opentalk.STSTReply</class-id> <category>accessing</category><body package="Opentalk-STST">destination	"The destination of this package, only used in datagram protocols"	^destination</body><body package="Opentalk-STST">destination: aDestination	"The destination of this package, only used in datagram protocols"	destination := aDestination</body><body package="Opentalk-STST">source: anIPSocketAddress"Only used in STSTUDP client. Can be ignored by replies"</body></methods><methods><class-id>Opentalk.STSTReply</class-id> <category>printing</category><body package="Opentalk-STST">printReplyOn: aStream	destination notNil ifTrue: [		destination hostAddress			do: [ :e | aStream print: e ]			separatedBy: [ aStream nextPut: $. ].		aStream			nextPut: $:;			print: destination port;			nextPutAll: ' &lt;- ' ].	super printReplyOn: aStream</body></methods><methods><class-id>Opentalk.STSTReply class</class-id> <category>accessing</category><body package="Opentalk-STST">msgType	^1</body></methods><methods><class-id>Opentalk.STSTReply class</class-id> <category>instance creation</category><body package="Opentalk-STST">return: anObject to: des requestId: requestId	^(self return: anObject) 		destination: des; 		requestId: requestId; 		yourself</body></methods><methods><class-id>Opentalk.STSTErrorReply</class-id> <category>dispatching</category><body package="Opentalk-STST">getReturnValueFor: aRequestPackage	"In the caller's thread, let the request handle the remote exception"	^aRequestPackage remoteExceptionReturn: reply</body></methods><methods><class-id>Opentalk.STSTErrorReply class</class-id> <category>accessing</category><body package="Opentalk-STST">msgType	^5</body></methods><methods><class-id>Opentalk.UDPTransportConfiguration</class-id> <category>accessing</category><body package="Opentalk-STST">componentClass	^UDPTransport</body></methods><methods><class-id>Opentalk.STSTMarshalerConfiguration</class-id> <category>accessing</category><body package="Opentalk-STST">componentClass	^STSTMarshaler</body></methods><methods><class-id>Opentalk.PassModeWrapper</class-id> <category>testing</category><body package="Opentalk-STST">isPassedByName	^passMode == #name</body><body package="Opentalk-STST">isPassedByOID	^passMode == #oid</body><body package="Opentalk-STST">isPassedByReference	^passMode == #reference</body><body package="Opentalk-STST">isPassedByValue	^passMode == #value</body></methods><methods><class-id>Opentalk.PassModeWrapper</class-id> <category>initialize</category><body package="Opentalk-STST">init: anObject passMode: aSymbol 	"Initialize the objRef as a local object reference"	objRef := anObject.	passMode := aSymbol</body></methods><methods><class-id>Opentalk.PassModeWrapper</class-id> <category>accessing</category><body package="Opentalk-STST">object	^objRef</body><body package="Opentalk-STST">passMode	^passMode</body></methods><methods><class-id>Opentalk.PassModeWrapper</class-id> <category>marshaling</category><body package="Opentalk-STST">marshalWith: aMarshaler	aMarshaler nextPutObject: self _objRef</body></methods><methods><class-id>Opentalk.PassModeWrapper class</class-id> <category>instance creation</category><body package="Opentalk-STST">new	"PassModeWrappers should not be created raw,	and should not be passed as arguments or answered	as return values in user-level code."	^self shouldNotImplement</body><body package="Opentalk-STST">newOn: anObject passMode: aSymbol	^( super new ) init: anObject passMode: aSymbol</body></methods><methods><class-id>Opentalk.PassModeWrapper class</class-id> <category>marshaling</category><body package="Opentalk-STST">unmarshalWith: aMarshaler	^aMarshaler nextPassModeWrapper</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>accessing</category><body package="Opentalk-STST">buffer	"... a shortcut for sharing the buffer between marshaler and socket writes."	^collection</body><body package="Opentalk-STST">contentSize	^self position</body><body package="Opentalk-STST">manager	^manager</body><body package="Opentalk-STST">manager: aMarshalingManager	manager := aMarshalingManager</body><body package="Opentalk-STST">nextIndex	^nextIndex := nextIndex + 1</body><body package="Opentalk-STST">swap	^swap</body><body package="Opentalk-STST">swap: aBoolean	swap := aBoolean</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>initialize-release</category><body package="Opentalk-STST">on: aCollection	"Initialize the receiver on aCollection."	super on: aCollection.	swap := false.	isBigEndianPlatform := UninterpretedBytes isBigEndian.	"I hope that we can avoid this	collection changeClassTo: BinaryStorageBytes."	scratchBuffer := BinaryStorageBytes new: 8</body><body package="Opentalk-STST">on: aCollection swap: aBoolean size: aNumber	self on: aCollection.	readLimit := aNumber min: aCollection size.	swap := aBoolean.</body><body package="Opentalk-STST">setManager: aManager	self manager: aManager</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>constants</category><body package="Opentalk-STST">forwardReferenceTag	^112</body><body package="Opentalk-STST">genericTag	^0</body><body package="Opentalk-STST">lastSingletonTag	^9</body><body package="Opentalk-STST">passBindingReferenceByNameTag	^124</body><body package="Opentalk-STST">passByOIDTag	^114</body><body package="Opentalk-STST">passByReferenceTag	^113</body><body package="Opentalk-STST">passClassByNameTag	^120</body><body package="Opentalk-STST">passLiteralBindingReferenceByNameTag	^125</body><body package="Opentalk-STST">passNameSpaceByNameTag	^121</body><body package="Opentalk-STST">passNameSpaceOfClassByNameTag	^122</body><body package="Opentalk-STST">passSignalByNameTag	^123</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>utility</category><body package="Opentalk-STST">passModeDispatchWith: aSymbolOrBoolean	^[ PassModeTable at: aSymbolOrBoolean ]		on: Error		do: [ :ex | OtEUnrecognizedPassMode					raiseSignal: (						(#UnrecognizedPassMode &lt;&lt; #opentalk &gt;&gt; 'Unrecognized pass mode designator: &lt;1s&gt;.' ) expandMacrosWith: aSymbolOrBoolean printString ) ]</body><body package="Opentalk-STST">tagDispatchWith: anInteger	^TagDispatchTable at: anInteger</body><body package="Opentalk-STST">typeDispatchWith: aClassOrSymbol	^SpecialTypeDispatchTable		at: aClassOrSymbol		ifAbsent: []</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>marshaling - low-level encoding</category><body package="Opentalk-STST">nextPutArray: anArray	self nextPutLength: anArray size.	anArray do: [ :x | self marshalObjectRecursively: x ]</body><body package="Opentalk-STST">nextPutBag: aBag	self marshalObjectRecursively: aBag contents asPassedByValue</body><body package="Opentalk-STST">nextPutBindingReferenceByName: aBindingReference	self nextPutSharedName: aBindingReference fullName</body><body package="Opentalk-STST">nextPutByteArray: aByteArray	self		nextPutLength: aByteArray size;		nextPutByteObject: aByteArray</body><body package="Opentalk-STST">nextPutByteObject: aByteObject	"Ideally should use sizeInBytes, but that's not recognized by all byte objects, e.g. WordArray, so have to use basicSize instead."	self 		nextPutFromByteObject: aByteObject 		bytes: aByteObject basicSize</body><body package="Opentalk-STST">nextPutByteString: aByteString	self		nextPutLength: aByteString sizeInBytes;		nextPutByteObject: aByteString</body><body package="Opentalk-STST">nextPutByteSymbol: aByteSymbol	self nextPutByteString: aByteSymbol asString</body><body package="Opentalk-STST">nextPutCharacter: aChar	self nextPutLong: aChar asInteger</body><body package="Opentalk-STST">nextPutClassByName: anObject	"We do not register objects passed-by-name."	( anObject isBehavior )		ifFalse: [ ^OtEMarshalingPassByName raiseSignal: (				#ObjectByNameError &lt;&lt; #opentalk &gt;&gt; 'Attempt to pass an instance by name.') ].	self nextPut: self passClassByNameTag.	self nextPutSharedName: anObject fullName</body><body package="Opentalk-STST">nextPutCleanOrCopyBlockClosure: aCleanOrCopyBlockClosure	"This method attempts to raise an exception if a block is detectably 'full'.  However, as a product of recent optimizations, blocks that you expect would explicitly retain their context of definition (for example, simple recursive blocks) have a nil 'outerContext'.  So, troublesome blocks can get through.  However, simple clean and copy blocks, of the sort used in SortedCollections, are OK, though you may experience problems debugging a pass-by-value block, as the attempt to display their remote source code, accessed through the 'outerMethod' of their CompiledBlock, may fail."	( aCleanOrCopyBlockClosure outerContext notNil )		ifTrue: [ ^OtEMarshalingFullBlock raiseSignal: (				#FullBlockByValueError &lt;&lt; #opentalk &gt;&gt; 'Attempt to pass a full block by value.') ].	self marshalObjectRecursively: aCleanOrCopyBlockClosure method.	self marshalObjectRecursively: aCleanOrCopyBlockClosure copiedValues</body><body package="Opentalk-STST">nextPutDate: aDate	self		nextPutSmallInteger: aDate day;		nextPutSmallInteger: aDate year</body><body package="Opentalk-STST">nextPutDictionary: aDictionary	self nextPutLength: aDictionary size.	aDictionary keysAndValuesDo: 		[:key :value |	self							marshalObjectRecursively: key;							marshalObjectRecursively: value		]</body><body package="Opentalk-STST">nextPutDouble: aDouble	( writeLimit - position &gt; 8 )		ifTrue:	[	collection doubleAt: position + 1 put: aDouble.			 		position := position + 8				]		ifFalse:	[	scratchBuffer doubleAt: 1 put: aDouble.			 		self next: 8 putAll: scratchBuffer startingAt: 1				]</body><body package="Opentalk-STST">nextPutDwordArray: aDwordArray	self		nextPutLength: aDwordArray basicSize;		nextPutByteObject: aDwordArray</body><body package="Opentalk-STST">nextPutFixedPoint: aFixedPoint	self		marshalObjectRecursively: aFixedPoint numerator;		marshalObjectRecursively: aFixedPoint denominator;		marshalObjectRecursively: aFixedPoint scale</body><body package="Opentalk-STST">nextPutFloat: aFloat	( writeLimit - position &gt; 4 )		ifTrue:	[	collection floatAt: position + 1 put: aFloat.					 position := position + 4				]		ifFalse:	[	scratchBuffer floatAt: 1 put: aFloat.			 		self next: 4 putAll: scratchBuffer startingAt: 1				]</body><body package="Opentalk-STST">nextPutFourByteString: aFourByteString	self 	nextPutLength: aFourByteString sizeInBytes;		nextPutByteObject: aFourByteString</body><body package="Opentalk-STST">nextPutFourByteSymbol: aFourByteSymbol	self nextPutFourByteString: aFourByteSymbol asString</body><body package="Opentalk-STST">nextPutFraction: aFraction	self		marshalObjectRecursively: aFraction numerator;		marshalObjectRecursively: aFraction denominator</body><body package="Opentalk-STST">nextPutFromByteObject: aByteObject bytes: anInteger	self nextPutFromByteObject: aByteObject bytes: anInteger startingAt: 1</body><body package="Opentalk-STST">nextPutFromByteObject: aByteObject bytes: anInteger1 startingAt: anInteger2	| newPosition |	newPosition := position + anInteger1.	( newPosition &gt; writeLimit )		ifTrue:	[	collection growToAtLeast: newPosition.					writeLimit := collection size				].	collection		replaceBytesFrom: position + 1		to: newPosition		with: aByteObject		startingAt: anInteger2.	position := newPosition</body><body package="Opentalk-STST">nextPutIPSocketAddress: anIPSocketAddress	| port |	port := anIPSocketAddress port.	self		nextPutByteObject: anIPSocketAddress hostAddress;		nextPut: ( port bitShift: -8 );		nextPut: ( port bitAnd: 255 )</body><body package="Opentalk-STST">nextPutIdentityDictionary: anIdentityDictionary	self nextPutDictionary: anIdentityDictionary</body><body package="Opentalk-STST">nextPutIdentitySet: anIdentitySet	self nextPutSet: anIdentitySet</body><body package="Opentalk-STST">nextPutInterval: anInterval	self		marshalObjectRecursively: anInterval first;		marshalObjectRecursively: anInterval stop;		marshalObjectRecursively: anInterval increment</body><body package="Opentalk-STST">nextPutLargeNegativeInteger: aLargeNegativeInteger	self		nextPutLength: aLargeNegativeInteger digitLength;		nextPutByteObject: aLargeNegativeInteger</body><body package="Opentalk-STST">nextPutLargePositiveInteger: aLargePositiveInteger	self		nextPutLength: aLargePositiveInteger digitLength;		nextPutByteObject: aLargePositiveInteger</body><body package="Opentalk-STST">nextPutLength: anInteger"71354: STSTStream should raise an error if object size exceeds the limit"	anInteger &gt; self class encodingLimit ifTrue: [				OtEMarshaling new					parameter: anInteger;					messageText: (#LengthExceedsEncodingLimit &lt;&lt; #opentalk &gt;&gt; 'The length exceeds the encoding limit: &lt;1p&gt;' expandMacrosWith: self class encodingLimit);					raise ].	( anInteger &gt;= 255 )		ifTrue:	[	self						nextPut: 255;						nextPut: ( ( anInteger bitShift: -16 ) bitAnd: 16rFF );						nextPut: ( ( anInteger bitShift: -8 ) bitAnd: 16rFF );						nextPut: ( anInteger bitAnd: 16rFF )				]		ifFalse:	[	self nextPut: anInteger				]</body><body package="Opentalk-STST">nextPutLiteralBindingReferenceByName: aLiteralBindingReference	self nextPutByteString: aLiteralBindingReference printString</body><body package="Opentalk-STST">nextPutLong: anInteger	( writeLimit - position &gt; 4 )		ifTrue:	[	collection longAt: position + 1 put: anInteger.			 		position := position + 4				]		ifFalse:	[	scratchBuffer longAt: 1 put: anInteger.			 		self next: 4 putAll: scratchBuffer startingAt: 1				]</body><body package="Opentalk-STST">nextPutMessage: msg	| args |	self nextPutSymbol: msg selector.	args := msg arguments.	self nextPutLength: args size.	args do: [ :each | self marshalObjectRecursively: each ]</body><body package="Opentalk-STST">nextPutNameSpaceByName: aNameSpace	self nextPutSharedName: aNameSpace fullName</body><body package="Opentalk-STST">nextPutNameSpaceOfClassByName: aNameOfClass	self nextPutSharedName: aNameOfClass owner fullName</body><body package="Opentalk-STST">nextPutObjRef: objRef	self marshalObjectRecursively: objRef oid asPassedByValue.	self nextPutIPSocketAddress: objRef accessPoint.</body><body package="Opentalk-STST">nextPutObject: anObject	self nextPutLong: anObject basicSize.	1 to: anObject basicSize		do: [ :i || v |			v := anObject basicAt: i.			( self passModeDispatchWith: ( anObject passModeForIndexedSlot: i value: v ) )				value: self				value: v ].	self marshalObjectInstVars: anObject.</body><body package="Opentalk-STST">nextPutOrderedCollection: anOrderedCollection	self nextPutLength: anOrderedCollection size.	anOrderedCollection do: [ :x | self marshalObjectRecursively: x ]</body><body package="Opentalk-STST">nextPutPoint: aPoint	self		marshalObjectRecursively: aPoint x;		marshalObjectRecursively: aPoint y</body><body package="Opentalk-STST">nextPutPositiveMediumInteger: anInteger"This is for integers outside of 32-bit SmallInteger range but within 64-bit SmallInteger range.We want to emulate LargeInteger marshaling layout."	| remainder | 	remainder := anInteger.	[ remainder &gt; 0 ] whileTrue: [		self nextPut: (remainder bitAnd: 255).		remainder := remainder bitShift: -8 ]</body><body package="Opentalk-STST">nextPutSTSTErrorReply: anRemoteReply	self nextPutSTSTReply: anRemoteReply</body><body package="Opentalk-STST">nextPutSTSTReply: aRemoteReply	self		marshalObjectRecursively: aRemoteReply reply;		nextPutLong: aRemoteReply requestId</body><body package="Opentalk-STST">nextPutSTSTRequest: req	self		nextPutMessage: req message;		nextPut: self passByReferenceTag;		nextPutObjRef: req target;		nextPutLong: req requestId;		marshalObjectRecursively: req serviceContext</body><body package="Opentalk-STST">nextPutSet: aSet	self nextPutLength: aSet size.	aSet do: [ :x | self marshalObjectRecursively: x ]</body><body package="Opentalk-STST">nextPutSharedName: aName	self nextPutString: aName</body><body package="Opentalk-STST">nextPutSignalByName: aSignal	self nextPutSharedName: aSignal nameClass fullName.	self nextPutByteSymbol: aSignal nameMessage</body><body package="Opentalk-STST">nextPutSmallInteger: aSmallInteger	( writeLimit - position &gt; 4 )		ifTrue:	[	collection longAt: position + 1 put: aSmallInteger.			 		position := position + 4				]		ifFalse:	[	scratchBuffer longAt: 1 put: aSmallInteger.			 		self next: 4 putAll: scratchBuffer startingAt: 1				]</body><body package="Opentalk-STST">nextPutSortedCollection: aSortedCollection	self nextPutArray: aSortedCollection asArray.	self nextPutCleanOrCopyBlockClosure: aSortedCollection sortBlock asPassedByValue</body><body package="Opentalk-STST">nextPutString: aString	aString class == ByteString		ifTrue:	[ self nextPut: 1 ]		ifFalse: [ ( aString class == TwoByteString )					ifTrue:	[ self nextPut: 2 ]					ifFalse:	[ ^self nextPutString: aString asByteString ] ].	self		nextPutLength: aString sizeInBytes;		nextPutByteObject: aString</body><body package="Opentalk-STST">nextPutSymbol: aSymbol	self nextPutString: aSymbol asString</body><body package="Opentalk-STST">nextPutTaggedClassByName: anObject with: marshalingBlock	"We do not register objects passed-by-name."	marshalingBlock		value: self		value: anObject</body><body package="Opentalk-STST">nextPutText: aText	self		marshalObjectRecursively: aText string;		marshalObjectRecursively: aText runs runs;		marshalObjectRecursively: aText runs values</body><body package="Opentalk-STST">nextPutTime: aTime	self		nextPutLength: aTime hours;		nextPutLength: aTime minutes;		nextPutLength: aTime seconds</body><body package="Opentalk-STST">nextPutTimestamp: aTimestamp	self		nextPutLength: aTimestamp year;		nextPutLength: aTimestamp month;		nextPutLength: aTimestamp day;		nextPutLength: aTimestamp hour;		nextPutLength: aTimestamp minute;		nextPutLength: aTimestamp second;		nextPutLength: aTimestamp millisecond</body><body package="Opentalk-STST">nextPutTwoByteString: aTwoByteString	self		nextPutLength: aTwoByteString sizeInBytes;		nextPutByteObject: aTwoByteString</body><body package="Opentalk-STST">nextPutTwoByteSymbol: aTwoByteSymbol	self nextPutTwoByteString: aTwoByteSymbol asString</body><body package="Opentalk-STST">nextPutUninterpretedBytes: ubytes	self		nextPutLength: ubytes sizeInBytes;		nextPutByteObject: ubytes</body><body package="Opentalk-STST">nextPutWordArray: aWordArray	self		nextPutLength: aWordArray basicSize;		nextPutByteObject: aWordArray</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>marshaling - low-level decoding</category><body package="Opentalk-STST">nextArray	| s a |	s := self nextLength.	a := Array new: s.	1 to: s do: [ :n | a at: n put: self unmarshalObjectRecursively ].	^a</body><body package="Opentalk-STST">nextBag	^( Bag new )		contents: self unmarshalObjectRecursively;		yourself</body><body package="Opentalk-STST">nextBindingReferenceByName	^[ self nextQualifiedReference ]		on: Error		do: [ :ex | OtEMarshalingPassByName raiseSignal: (				#BindingReferenceByNameError &lt;&lt; #opentalk &gt;&gt; 'Error unmarshaling a BindingReference passed by name.') ]</body><body package="Opentalk-STST">nextByteArray	^self nextByteArraySize: self nextLength</body><body package="Opentalk-STST">nextByteArraySize: byteSize	| ba |	ba := ByteArray new: byteSize.	readLimit - position &gt; byteSize		ifTrue: [ba 				replaceElementsFrom: 1				to: byteSize				withByteArray: collection 				startingAt: position + 1.				position := position + byteSize]		ifFalse: [ self next: byteSize into: ba startingAt: 1].	^ba</body><body package="Opentalk-STST">nextByteString	| ba |	ba := self nextByteArraySize: self nextLength.	ByteString adoptInstance: ba.	^ba</body><body package="Opentalk-STST">nextByteSymbol	^self nextByteString asSymbol</body><body package="Opentalk-STST">nextCharacter	^Character value: self nextLong</body><body package="Opentalk-STST">nextClassByName	^[ self nextSharedName ]		on: Error		do: [ :ex | OtEMarshalingPassByName raiseSignal: (			#ClassByNameError &lt;&lt; #opentalk &gt;&gt; 'Error unmarshaling a Class passed by name.') ]</body><body package="Opentalk-STST">nextCleanOrCopyBlockClosure	^( BlockClosure new )		setMethod: self unmarshalObjectRecursively		outerContext: nil		copiedValues: self unmarshalObjectRecursively</body><body package="Opentalk-STST">nextDate	^Date		newDay: self nextSmallInteger		year: self nextSmallInteger</body><body package="Opentalk-STST">nextDictionary	| s d |	s := self nextLength.	d := Dictionary new: s.	1 to: s do: [ :n | d add: ( ( self unmarshalObjectRecursively ) -&gt; ( self unmarshalObjectRecursively ) ) ].	^d</body><body package="Opentalk-STST">nextDouble	^readLimit - position &gt; 8		ifTrue:			[				position := position + 8.				collection doubleAt: position - 7 bigEndian: swap ~~ isBigEndianPlatform			]		ifFalse:			[				self next: 8 into: scratchBuffer startingAt: 1.				scratchBuffer doubleAt: 1 bigEndian: swap ~~ isBigEndianPlatform			]</body><body package="Opentalk-STST">nextDwordArray	| dwa |	dwa := (self nextByteArraySize: self nextLength) changeClassTo: DwordArray.	swap ifTrue: [dwa reverseByteOrder].	^dwa</body><body package="Opentalk-STST">nextFixedPoint	^FixedPoint		numerator: self unmarshalObjectRecursively		denominator: self unmarshalObjectRecursively		scale: self unmarshalObjectRecursively</body><body package="Opentalk-STST">nextFloat	^readLimit - position &gt; 4		ifTrue:			[				position := position + 4.				collection floatAt: position - 3 bigEndian: swap ~~ isBigEndianPlatform			]		ifFalse:			[				self next: 4 into: scratchBuffer startingAt: 1.				scratchBuffer floatAt: 1 bigEndian: swap ~~ isBigEndianPlatform			]</body><body package="Opentalk-STST">nextFourByteString	| ba |	ba := self nextByteArraySize: self nextLength.	FourByteString adoptInstance: ba.	swap ifTrue: [ ba reverseByteOrder ].	^ba</body><body package="Opentalk-STST">nextFourByteSymbol	^self nextFourByteString asSymbol</body><body package="Opentalk-STST">nextFraction	^Fraction		numerator: self unmarshalObjectRecursively		denominator: self unmarshalObjectRecursively</body><body package="Opentalk-STST">nextIPSocketAddress	| ha pn ip |	ha := self nextByteArraySize: 4.	pn := (self next bitShift: 8) bitOr: self next.	ip := IPv4SocketAddress			hostAddress: ha			port: pn.	^ip</body><body package="Opentalk-STST">nextIdentityDictionary	| s d |	s := self nextLength.	d := IdentityDictionary new: s.	1 to: s do: [ :n |		d	at: self unmarshalObjectRecursively			put: self unmarshalObjectRecursively ].	^d</body><body package="Opentalk-STST">nextIdentitySet	^IdentitySet withAll: self nextArray</body><body package="Opentalk-STST">nextInterval	^Interval		from: self unmarshalObjectRecursively		to: self unmarshalObjectRecursively		by: self unmarshalObjectRecursively</body><body package="Opentalk-STST">nextLargeNegativeInteger	^(( self nextByteArraySize: self nextLength ) changeClassTo: LargeNegativeInteger) compressed</body><body package="Opentalk-STST">nextLargePositiveInteger	^(( self nextByteArraySize: self nextLength ) changeClassTo: LargePositiveInteger) compressed</body><body package="Opentalk-STST">nextLength	| b |	b := self next.	^b = 255		ifTrue: [(self next bitShift: 16) + (self next bitShift: 8)  + self next]		ifFalse: [b]</body><body package="Opentalk-STST">nextLiteralBindingReferenceByName	| pbns |	pbns := self nextByteString.	^[ ( LiteralBindingReference pathString: ( pbns copyFrom: 3 to: ( pbns size -1 ) ) )		method: ( PseudoMethod class: nil home: Smalltalk ) ]		on: Error		do: [ :ex | OtEMarshalingPassByName raiseSignal: (				#LiteralBindingReferenceByNameError &lt;&lt; #opentalk &gt;&gt; 'Error unmarshaling a LiteralBindingReference passed by name.') ]</body><body package="Opentalk-STST">nextLong	| l w b2 b1 b0 h |	^((readLimit - position &gt; 4) and: [swap not])		ifTrue: [l := collection longAt: position+1.				position := position + 4.				l]		ifFalse:			[swap == isBigEndianPlatform				ifTrue:					[w := self next.					b2 := self next.					b1 := self next.					b0 := self next]				ifFalse:					[b0 := self next.					b1 := self next.					b2 := self next.					w := self next].			h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.			b2 = 0 ifFalse: [w := (b2 bitShift: 8) + w].			h = 0 ifFalse: [w := (h bitShift: 16) + w].			w]</body><body package="Opentalk-STST">nextMessage	| args sel size |	sel := self nextSymbol.	size := self nextLength.	args := Array new: size.	1 to: size do: [ :i | args at: i put: self unmarshalObjectRecursively ].	^SmalltalkMessage selector: sel arguments: args</body><body package="Opentalk-STST">nextNameSpaceByName	^[ self nextSharedName ]		on: Error		do: [ :ex | OtEMarshalingPassByName raiseSignal: (			#NameSpaceByNameError &lt;&lt; #opentalk &gt;&gt; 'Error unmarshaling a NameSpace passed by name.') ]</body><body package="Opentalk-STST">nextNameSpaceOfClassByName	^[ self nextSharedName asNameSpace ]		on: Error		do: [ :ex | OtEMarshalingPassByName raiseSignal: (			#NameSpaceOfClassByNameError &lt;&lt; #opentalk &gt;&gt; 'Error unmarshaling a NameSpaceOfClass passed by name.') ]</body><body package="Opentalk-STST">nextObjRef	| oid  accessPoint |	oid := self unmarshalObjectRecursively.	accessPoint := self nextIPSocketAddress.	^ObjRef newOn: accessPoint oid: oid</body><body package="Opentalk-STST">nextObject: aClass	"Read an instance of aClass"		| obj  objSize |	"Create and register an empty skeleton to handle 	recursion and forward references."	obj := ( ( objSize := self nextLong ) = 0 )				ifTrue:	[ aClass basicNew ]				ifFalse:	[ aClass basicNew: objSize ].	self registerUnmarshaledObject: obj.	1 to: objSize do: [ :i | obj basicAt: i put: ( self unmarshalObjectRecursively ) ].	1 to: obj class instSize do: [ :i | obj instVarAt: i put: ( self unmarshalObjectRecursively ) ].	^obj postPassByValue</body><body package="Opentalk-STST">nextObjectByReference	"Returns either a local object or aRemoteObject."	^self manager objectByRef: self nextObjRef</body><body package="Opentalk-STST">nextOrderedCollection	| s oc |	s := self nextLength.	oc := OrderedCollection new: s.	s timesRepeat: [ oc addLast: self unmarshalObjectRecursively ].	^oc</body><body package="Opentalk-STST">nextPassByOID	| oid ot obj |	oid := self unmarshalObjectRecursively.	ot := self manager objectTable.	obj := ot objectByOID: oid.	^obj</body><body package="Opentalk-STST">nextPassModeWrapper	^self unmarshalObjectRecursively</body><body package="Opentalk-STST">nextPoint	^Point		x: self unmarshalObjectRecursively		y: self unmarshalObjectRecursively</body><body package="Opentalk-STST">nextQualifiedReference 	^self nextString asQualifiedReference</body><body package="Opentalk-STST">nextSTSTErrorReply	| id |	^(STSTErrorReply		return: self unmarshalObjectRecursively		to: nil		requestId: (id := self nextLong)	)	interceptorDispatcher: (			(self manager requestById: id)				ifNil: [self manager provideInterceptorDispatcher]				ifNotNil: [ :request | request interceptorDispatcher ]);		yourself</body><body package="Opentalk-STST">nextSTSTReply	| id |	^(	STSTReply			return: self unmarshalObjectRecursively  			to: nil 			requestId: (id := self nextLong)	)	interceptorDispatcher: (			(self manager requestById: id)				ifNil: [self manager provideInterceptorDispatcher]				ifNotNil: [ :request | request interceptorDispatcher ]);		yourself</body><body package="Opentalk-STST">nextSTSTRequest		^(	STSTRequest			request: self nextMessage 			to: (self next; nextObjRef)  			id: self nextLong			context: self unmarshalObjectRecursively	)	interceptorDispatcher: self manager provideInterceptorDispatcher;		yourself</body><body package="Opentalk-STST">nextSet	| s set |	s := self nextLength.	set := Set new: s.	s timesRepeat: [ set add: self unmarshalObjectRecursively ].	^set</body><body package="Opentalk-STST">nextSharedName	| ref |	ref := self nextQualifiedReference. 	^[	ref value	]	on: Error		do: [ :ex |			"ObjectStudio sends us unqualified class names. If we can't find the name in Smalltalk,			we'll try to look it up in Opentalk so that things like OtExceptions resolve"			Opentalk at: ref name ]</body><body package="Opentalk-STST">nextSignalByName	[	^( self nextSharedName )			perform: self nextByteString asSymbol	]	on: Error		do: [ :ex | OtEMarshalingPassByName raiseSignal: (			#SignalByNameError &lt;&lt; #opentalk &gt;&gt; 'Error unmarshaling a Signal passed by name.') ]</body><body package="Opentalk-STST">nextSmallInteger	| l w b2 b1 b0 h |	^((readLimit - position &gt; 4) and: [swap not])		ifTrue: [l := collection longAt: position+1.				position := position + 4.				l]		ifFalse:			[swap == isBigEndianPlatform				ifTrue:					[w := self next.					b2 := self next.					b1 := self next.					b0 := self next]				ifFalse:					[b0 := self next.					b1 := self next.					b2 := self next.					w := self next].			h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.			b2 = 0 ifFalse: [w := (b2 bitShift: 8) + w].			h = 0 ifFalse: [w := (h bitShift: 16) + w].			w]</body><body package="Opentalk-STST">nextSortedCollection	| newCollection elements |	elements :=  self nextArray.	newCollection := SortedCollection new: elements size.	newCollection sortBlock: self nextCleanOrCopyBlockClosure.	newCollection addAllWithoutSorting: elements.	^newCollection</body><body package="Opentalk-STST">nextString	| ba type |	type := self next.	(type == 1 or: [type == 2])		ifFalse: [self error: (#StringFormatError &lt;&lt; #opentalk &gt;&gt; 'String format error')].	ba := self nextByteArraySize: self nextLength.	type == 1		ifTrue: [ByteString adoptInstance: ba]		ifFalse:			[TwoByteString adoptInstance: ba.			swap ifTrue: [ba reverseByteOrder]].	^ba</body><body package="Opentalk-STST">nextSymbol	^self nextString asSymbol</body><body package="Opentalk-STST">nextText	^Text		string: self unmarshalObjectRecursively		runs: (RunArray				runs: self unmarshalObjectRecursively				values: self unmarshalObjectRecursively)</body><body package="Opentalk-STST">nextTime	^( Time new )		hours: self nextLength		minutes: self nextLength		seconds: self nextLength</body><body package="Opentalk-STST">nextTimestamp	^( Timestamp new )		year: self nextLength;		month: self nextLength;		day: self nextLength;		hour: self nextLength;		minute: self nextLength;		second: self nextLength;		millisecond: self nextLength;		yourself</body><body package="Opentalk-STST">nextTwoByteString	| ba |	ba := self nextByteArraySize: self nextLength.	TwoByteString adoptInstance: ba.	swap ifTrue: [ ba reverseByteOrder ].	^ba</body><body package="Opentalk-STST">nextTwoByteSymbol	^self nextTwoByteString asSymbol</body><body package="Opentalk-STST">nextUninterpretedBytes	^(self nextByteArraySize: self nextLength)		changeClassTo: UninterpretedBytes</body><body package="Opentalk-STST">nextWordArray	| wa |	wa := (self nextByteArraySize: self nextLength) changeClassTo: WordArray.	swap ifTrue: [wa reverseByteOrder].	^wa</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>marshaling - api</category><body package="Opentalk-STST">marshalObject: anObject 	"The is the 'top' marshaling entrance point.  It should, therefore, *never* be called recursively during the marshaling.  Use 'marshalObjectRecursively:' instead."	objectToIndex := IdentityDictionary new: 40.	nextIndex := 0.	[ self marshalObjectRecursively: anObject ] 		on:	Error		do:	[:ex | OtEMarshaling raiseSignal: ex errorString ]</body><body package="Opentalk-STST">resetHeader: aPackageHeader	"Put the package header as bytes at the very beginning."	| oldPosition |	oldPosition := position.	position := 0.	self nextPutAll: aPackageHeader.	position := oldPosition.</body><body package="Opentalk-STST">setHeader: aPackageHeader	"Put the package header as bytes at the very beginning."	self nextPutAll: aPackageHeader.</body><body package="Opentalk-STST">setReadLimit: anInteger 	readLimit := anInteger min: collection size.	self reset.</body><body package="Opentalk-STST">skipHeader	self next: TransportPackageBytes headerSize</body><body package="Opentalk-STST">unmarshalObject	"The is the 'top' unmarshaling entrance point.  It should, therefore, *never* be called recursively during the marshaling.  Use 'unmarshalObjectRecursively' instead.  No other method should reinitialize the buffers used to maintain object identity within pass-by-value objects."	index := OrderedCollection new: 40.	objects := IdentitySet new: 40.	^[self unmarshalObjectRecursively]		on: Error		do: 			[:ex | 			OtEMarshaling raiseSignal: ex errorString]</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>marshaling - high-level encoding</category><body package="Opentalk-STST">marshalForwardReference: objectIndex	self nextPut: self forwardReferenceTag.	self nextPutSmallInteger: objectIndex</body><body package="Opentalk-STST">marshalObjectAsOID: anObjectOrPassModeWrapper	| obj ot oid |	anObjectOrPassModeWrapper _type == PassModeWrapper		ifTrue:	[ obj := anObjectOrPassModeWrapper object ]		ifFalse:	[ obj := anObjectOrPassModeWrapper ].	ot := self manager objectTable. 	oid := ot oidByObject: obj.	self marshalObjectRecursively: oid</body><body package="Opentalk-STST">marshalObjectAsObjRef: anObjectOrPassModeWrapper	| obj |	anObjectOrPassModeWrapper _type == PassModeWrapper		ifTrue:	[ obj := anObjectOrPassModeWrapper object ]		ifFalse:	[ obj := anObjectOrPassModeWrapper ].	self nextPutObjRef: ( self manager export: obj )</body><body package="Opentalk-STST">marshalObjectInstVars: anObject 	| passMode |	passMode := anObject passInstVars.	1 to: ( anObject class ) instSize		do:	[ :i | ( i &lt;= anObject passInstVars size )					ifTrue:	[ ( self passModeDispatchWith: ( passMode at: i ) )								value: self								value: ( anObject instVarAt: i )							]					ifFalse:	[ self marshalObjectRecursively: ( anObject instVarAt: i ) ] ]</body><body package="Opentalk-STST">marshalObjectRecursively: anObject 	"... marshals anObject, and may be called recursively.  Object identity is enforced at this level, which implies that the marshaling and unmarshaling call structures must be consistent.  Note the code is written on the assumption that there are exactly four pass modes (pass-by-value, pass-by-reference, pass-by-name, and pass-by-OID) and that pass-by-name is *never* the default pass mode."	| obj ind mBlock |	obj := anObject.	"... forward references."	( ( ind := objectToIndex at: obj ifAbsent: [] ) isNil )		ifFalse:	[ ^self marshalForwardReference: ind ].	"... existing references."	( obj _isRemote )		ifTrue:	[ ^self marshalRemoteObject: obj ].	"... singletons, which unlike other objects are not registered for object identity preservation."	( obj isSingleton )		ifTrue:	[ ^self marshalSingleton: obj ].	"... pass by reference objects."	( obj isPassedByReference ) 		ifTrue:	[ ^self marshalPassByReferenceObject: obj ].		"... pass by name objects."	( obj isPassedByName ) 		ifTrue:	[ ^self marshalPassByNameObject: obj ].		"... pass by OID objects."	( obj isPassedByOID ) 		ifTrue:	[ ^self marshalPassByOIDObject: obj ].		"... unwrap pass by value wrappers."	( obj _type == PassModeWrapper )		ifTrue:	[ obj := obj object ].	"... the remainder."	mBlock := self typeDispatchWith: obj _type.	^( mBlock isNil )		ifTrue:	[ self marshalUntaggedObject: obj ]				"... the untagged generics."		ifFalse:	[ self marshalTaggedObject: obj with: mBlock ]	"... the tagged."</body><body package="Opentalk-STST">marshalPassByNameObject: anObjectOrPassModeWrapper	"We do not register objects passed by name in order to preserve object identity relationships.  The receiving side has that responsibility."	| obj mBlock |	anObjectOrPassModeWrapper _type == PassModeWrapper		ifTrue:	[ obj := anObjectOrPassModeWrapper object ]		ifFalse:	[ obj := anObjectOrPassModeWrapper ].	mBlock := self typeDispatchWith: obj class name.	( mBlock isNil )		ifTrue:	[ self nextPutClassByName: obj ]		ifFalse:	[ self nextPutTaggedClassByName: obj with: mBlock ]</body><body package="Opentalk-STST">marshalPassByOIDObject: anObject	self nextPut: self passByOIDTag.	self marshalObjectAsOID: anObject.	self registerMarshaledObject: anObject</body><body package="Opentalk-STST">marshalPassByReferenceObject: anObject	"There is a slight problem here, entailed by the case where the same object is passed by reference and by value in the same message."	self nextPut: self passByReferenceTag.	self marshalObjectAsObjRef: anObject.	self registerMarshaledObject: anObject</body><body package="Opentalk-STST">marshalRemoteObject: aRemoteObject	"There is a need to register the object."	self nextPut: self passByReferenceTag.	self nextPutObjRef: aRemoteObject _objRef.	self registerMarshaledObject: aRemoteObject</body><body package="Opentalk-STST">marshalSingleton: anObjectOrPassModeWrapper	"There is no need to register the object."	| obj |	anObjectOrPassModeWrapper _type == PassModeWrapper		ifTrue:	[ obj := anObjectOrPassModeWrapper object ]		ifFalse:	[ obj := anObjectOrPassModeWrapper ].	( self typeDispatchWith: obj _type )		value: self		value: obj</body><body package="Opentalk-STST">marshalTaggedObject: anObject with: marshalingBlock	""	marshalingBlock		value: self		value: anObject.	self registerMarshaledObject: anObject</body><body package="Opentalk-STST">marshalUntaggedObject: anObject	"... implicitly pass-by-value.  Be sure to register the object first, before 'marshalWith:' begins drilling into the instVars."	self nextPut: self genericTag.	self nextPutSharedName: anObject _type fullName.	self registerMarshaledObject: anObject.	anObject marshalWith: self.</body><body package="Opentalk-STST">registerMarshaledObject: anObject	"... registers a marshaled object in the 'forward reference' table that is used to maintain object identity.  We do not register nil, true, or false."	objectToIndex at: anObject put: self nextIndex</body></methods><methods><class-id>Opentalk.STSTStream</class-id> <category>marshaling - high-level decoding</category><body package="Opentalk-STST">registerUnmarshaledObject: anObject	"... registers a marshaled object in the 'forward reference' table that is used to maintain object identity.  We do not register nil, true, or false."	(objects includes: anObject) ifFalse: [		objects add: anObject.		index add: anObject ].	^anObject</body><body package="Opentalk-STST">unmarshalForwardReference	"Supply the result of a former unmarshaling to preserve object identity relationships.  We do not, of course, re-appy 'postPassByValue' or re-register the object."	^[	index at: self nextSmallInteger	]	on:	IndexNotFoundError		do:	[ :ex | ex resignalAs: (				OtEMarshaling new					parameter: ex index;					messageText: (#UndefinedForwardReference &lt;&lt; #opentalk &gt;&gt; 'Undefined forward reference');					raise ) ]</body><body package="Opentalk-STST">unmarshalObjectRecursively	"... unmarshals anObject, and may be called recursively.  Object identity within pass-by-value objects is enforced at this level, which implies that the marshaling and unmarshaling call structures must be consistent."	| tag |	( ( tag := self next ) isNil )		ifTrue:	[ ^OtENullPackage raiseSignal: (#NullReadStream &lt;&lt; #opentalk &gt;&gt; 'Null read stream.') ].	( tag == self forwardReferenceTag )		ifTrue:	[ ^self unmarshalForwardReference ].	( tag == self genericTag )		ifTrue:	[ ^self unmarshalUntaggedObject ].	( tag &lt;= self lastSingletonTag )		ifTrue:	[ ^self unmarshalSingletonTagged: tag ].	^self unmarshalObjectTagged: tag</body><body package="Opentalk-STST">unmarshalObjectTagged: tag	"Read an object identified by a type tag."	| uo |	uo := ( self tagDispatchWith: tag ) value: self.	self registerUnmarshaledObject: uo.	^uo</body><body package="Opentalk-STST">unmarshalSingletonTagged: tag	"Answer the singleton identified by 'tag'."	^( self tagDispatchWith: tag ) value: self</body><body package="Opentalk-STST">unmarshalUntaggedObject	"This method is the default regimen for pass by value.  Read an object identified by a class name; apply 'postPassByValue' actions; then register the object to handle possible back references to it in subsequent portions of the encoded message."	^self registerUnmarshaledObject: ( self nextSharedName unmarshalWith: self ) postPassByValue</body></methods><methods><class-id>Opentalk.STSTStream class</class-id> <category>configuration</category><body package="Opentalk-STST">addSpecialType: aClass dispatchAs: aBlock	SpecialTypeDispatchTable at: aClass put: aBlock</body><body package="Opentalk-STST">addTag: anInteger dispatchAs: aBlock	TagDispatchTable at: anInteger put: aBlock</body></methods><methods><class-id>Opentalk.STSTStream class</class-id> <category>initialization</category><body package="Opentalk-STST">initialize	"Pay special regard to the method comment of  'initializeSpecialTypeDispatchTable'."	"((( STSTStream initialize )))"	self initializePassModeTable.	self initializeSpecialTypeDispatchTable.	self initializeTagDispatchTable.</body><body package="Opentalk-STST">initializePassModeTable	PassModeTable := IdentityDictionary new: 10.	PassModeTable		at: #reference		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: anObject asPassedByReference ].	PassModeTable 		at: #value		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: anObject asPassedByValue ].	PassModeTable 		at: #name		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: anObject asPassedByName ].	PassModeTable 		at: #oid		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: anObject asPassedByOID ].	PassModeTable		at: #default		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: anObject ].	PassModeTable		at: #true		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: anObject ].	PassModeTable		at: true		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: anObject ].	PassModeTable 		at: #skip		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: nil ].	PassModeTable 		at: #false		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: nil ].	PassModeTable 		at: false		put: [ :mySelf :anObject | mySelf marshalObjectRecursively: nil ]</body><body package="Opentalk-STST">initializeSpecialTypeDispatchTable 	"This method defines the marshaling dispatch table for immutable types and special, optimized STST package types.  Note that all immutable type objects are passed by value and NOT optimized to use the in stream reference.  As a direct consequence, immutable types may *not* recursively refer to themselves.  Note particularly that all object tag definitions absolutely *must* be in sync with those present in 'STSTStream class&gt;&gt;initializeTagDispatchTable'."	SpecialTypeDispatchTable := IdentityDictionary new.	SpecialTypeDispatchTable		"000-007: the generic case and select immediate types"			at: UndefinedObject		put: [:mySelf :anObject | 											mySelf nextPut: 1 ];			at: True					put: [:mySelf :anObject | 											mySelf nextPut: 2 ];			at: False				put: [:mySelf :anObject | 											mySelf nextPut: 3 ];		"008-015: Characters, Integers, LimitedPrecisionReals"			at: Character			put: [:mySelf :anObject | 											mySelf nextPut: 8.											mySelf nextPutCharacter: anObject ];			at: SmallInteger			put: [:mySelf :anObject |											(anObject &lt; -536870912)												ifTrue: [ mySelf nextPut: 11; nextPutLength: anObject digitLength; nextPutPositiveMediumInteger: anObject negated ]												ifFalse: [ (anObject &gt; 536870911)														ifTrue: [ mySelf nextPut: 10; nextPutLength: anObject digitLength; nextPutPositiveMediumInteger: anObject ]														ifFalse: [ mySelf nextPut: 9; nextPutSmallInteger: anObject ] ] ];			at: LargePositiveInteger	put: [:mySelf :anObject | 											mySelf nextPut: 10.											mySelf nextPutLargePositiveInteger: anObject ];			at: LargeNegativeInteger	put: [:mySelf :anObject | 											mySelf nextPut: 11.											mySelf nextPutLargeNegativeInteger: anObject ];			at: Float				put: [:mySelf :anObject | 											mySelf nextPut: 12.											mySelf nextPutFloat: anObject ];			at: Double				put: [:mySelf :anObject | 											mySelf nextPut: 13.											mySelf nextPutDouble: anObject ];			at: SmallDouble				put: [:mySelf :anObject | 											mySelf nextPut: 13.											mySelf nextPutDouble: anObject ];		"016-023: Other Magnitudes 1"			at: Point				put: [:mySelf :anObject | 											mySelf nextPut: 16.											mySelf nextPutPoint: anObject ];			at: Fraction				put: [:mySelf :anObject | 											mySelf nextPut: 17.											mySelf nextPutFraction: anObject ];			at: FixedPoint			put: [:mySelf :anObject | 											mySelf nextPut: 18.											mySelf nextPutFixedPoint: anObject ];		"024-031: Other Magnitudes 2"			at: Date					put: [:mySelf :anObject | 											mySelf nextPut: 24.											mySelf nextPutDate: anObject ];			at: Time					put: [:mySelf :anObject | 											mySelf nextPut: 25.											mySelf nextPutTime: anObject ];			at: Timestamp				put: [:mySelf :anObject | 											mySelf nextPut: 26.											mySelf nextPutTimestamp: anObject ];		"032-039: Other Magnitudes 3"		"040-047: Strings and Symbols 1"			at: ByteString				put: [:mySelf :anObject | 												mySelf nextPut: 40.												mySelf nextPutByteString: anObject];			at: TwoByteString			put: [:mySelf :anObject | 												mySelf nextPut: 41.												mySelf nextPutTwoByteString: anObject];			at: FourByteString			put: [:mySelf :anObject | 												mySelf nextPut: 42.												mySelf nextPutFourByteString: anObject];			at: Text						put: [:mySelf :anObject | 												mySelf nextPut: 43.												mySelf nextPutText: anObject ];		"048-055: Strings and Symbols 2"			at: ByteSymbol				put: [:mySelf :anObject | 												mySelf nextPut: 48.												mySelf nextPutByteSymbol: anObject ];			at: TwoByteSymbol			put: [:mySelf :anObject | 												mySelf nextPut: 49.												mySelf nextPutTwoByteSymbol: anObject ];			at: FourByteSymbol			put: [:mySelf :anObject | 												mySelf nextPut: 50.												mySelf nextPutFourByteSymbol: anObject ];		"056-063: Arrays"			at: Array					put: [:mySelf :anObject | 												mySelf nextPut: 56.												mySelf nextPutArray: anObject ];			at: ByteArray				put: [:mySelf :anObject | 												mySelf nextPut: 57.												mySelf nextPutByteArray: anObject ];			at: WordArray				put: [:mySelf :anObject | 												mySelf nextPut: 58.												mySelf nextPutWordArray: anObject ];			at: DwordArray				put: [:mySelf :anObject | 												mySelf nextPut: 59.												mySelf nextPutDwordArray: anObject ];			at: UninterpretedBytes		put: [:mySelf :anObject | 												mySelf nextPut: 60.												mySelf nextPutUninterpretedBytes: anObject ];		"064-071: Collections 1"			at: Bag						put: [:mySelf :anObject | 												mySelf nextPut: 64.												mySelf nextPutBag: anObject ];			at: Interval					put: [:mySelf :anObject | 												mySelf nextPut: 65.												mySelf nextPutInterval: anObject ];			at: OrderedCollection		put: [:mySelf :anObject | 												mySelf nextPut: 66.												mySelf nextPutOrderedCollection: anObject ];			at: SortedCollection			put: [:mySelf :anObject | 												mySelf nextPut: 67.												mySelf nextPutSortedCollection: anObject ];		"072-079: Collections 2"			at: Set						put: [:mySelf :anObject | 												mySelf nextPut: 72.												mySelf nextPutSet: anObject ];			at: IdentitySet				put: [:mySelf :anObject | 												mySelf nextPut: 73.												mySelf nextPutIdentitySet: anObject ];			at: Dictionary				put: [:mySelf :anObject | 												mySelf nextPut: 74.												mySelf nextPutDictionary: anObject ];			at: IdentityDictionary			put: [:mySelf :anObject | 												mySelf nextPut: 75.												mySelf nextPutIdentityDictionary: anObject ];		"080-087: Collections 3"		"088-095: System Classes 1"			at: BlockClosure			put: [:mySelf :anObject | 												mySelf nextPut: 88.												mySelf nextPutCleanOrCopyBlockClosure: anObject ];		"096-103: System Classes 2"		"104-111: System Classes 3"		"112-119: Messaging Essentials"			"112 = readForwardReference"			"113 = passByReference"			"114 = passByOID"		"120-127: Messaging Essentials: Pass-By-Name 1"			"120 = passClassByName"			at: #NameSpace				put: [:mySelf :anObject | 												mySelf nextPut: 121.												mySelf nextPutNameSpaceByName: anObject ];			at: #NameSpaceOfClass				put: [:mySelf :anObject | 												mySelf nextPut: 122.												mySelf nextPutNameSpaceOfClassByName: anObject ];			at: #Signal					put: [:mySelf :anObject | 												mySelf nextPut: 123.												mySelf nextPutSignalByName: anObject ];			at: #BindingReference		put: [:mySelf :anObject | 												mySelf nextPut: 124.												mySelf nextPutBindingReferenceByName: anObject ];			at: #LiteralBindingReference	put: [:mySelf :anObject | 												mySelf nextPut: 125.												mySelf nextPutLiteralBindingReferenceByName: anObject ];		"128-135: Messaging Essentials: Pass-By-Name 2"		"136-143: Basic Message Types"			at: STSTRequest			put: [:mySelf :anObject | 												mySelf nextPut: 136.												mySelf nextPutSTSTRequest: anObject ];			"at: STSTOnewayRequest	put: [:mySelf :anObject | 												mySelf nextPut: 137.												mySelf nextPutSTSTRequest: anObject];"			at: STSTReply				put: [:mySelf :anObject | 												mySelf nextPut: 138.												mySelf nextPutSTSTReply: anObject ];		"144-151: unallocated and reserved"		"152-159: unallocated and reserved"		"160-167: unallocated and reserved"		"168-175: unallocated and reserved"		"176-183: unallocated and reserved"		"184-191: unallocated and reserved"		"192-199: unallocated and reserved"		"200-207: unallocated and reserved"		"208-215: unallocated and reserved"		"216-223: set aside for customer use"		"224-231: set aside for customer use"		"232-230: set aside for customer use"		"240-247: seta side for customer use"		"248-255:  experimental tags"			at: STSTErrorReply			put: [:mySelf :anObject | 												mySelf nextPut: 248.												mySelf nextPutSTSTErrorReply: anObject ];			at: STSTCloseConnection	put: [:mySelf :anObject | 												mySelf nextPut: 249 ]</body><body package="Opentalk-STST">initializeTagDispatchTable    	"Defines the dispatch table for version 2.0 of the Opentalk ST-ST protocol.  Tags are allocated in groups of 8, and they are no longer reserved for types that, under a very strict interporetation, are immutable.  Note that this method absolutely must be in sync with 'STSTStream class&gt;&gt;initializeSpecialTypeDispatchTable'."	TagDispatchTable := Array new: 255.	TagDispatchTable 		"000-007: the generic case and select immediate types"			"at: 0	put: [ :obj | obj privateReadObject ];"			at: 1	put: [ :obj | nil ]; 			at: 2	put: [ :obj | true ]; 			at: 3	put: [ :obj | false ];		"008-015: Characters, Integers, LimitedPrecisionReals"			at: 8	put: [ :obj | obj nextCharacter ];			at: 9	put: [ :obj | obj nextSmallInteger ];			at: 10	put: [ :obj | obj nextLargePositiveInteger ];			at: 11	put: [ :obj | obj nextLargeNegativeInteger ];			at: 12	put: [ :obj | obj nextFloat ];			at: 13	put: [ :obj | obj nextDouble ];		"016-023: Other Magnitudes 1"			at: 16	put: [ :obj | obj nextPoint ];			at: 17	put: [ :obj | obj nextFraction ];			at: 18	put: [ :obj | obj nextFixedPoint ];		"024-031: Other Magnitudes 2"			at: 24	put: [ :obj | obj nextDate ];			at: 25	put: [ :obj | obj nextTime ];			at: 26	put: [ :obj | obj nextTimestamp ];		"032-039: Other Magnitudes 3"		"040-047: Strings and Symbols 1"			at: 40	put: [ :obj | obj nextByteString ];			at: 41	put: [ :obj | obj nextTwoByteString ];			at: 42	put: [ :obj | obj nextFourByteString ];			at: 43	put: [ :obj | obj nextText ];		"048-055: Strings and Symbols 2"			at: 48	put: [ :obj | obj nextByteSymbol ];			at: 49	put: [ :obj | obj nextTwoByteSymbol ];			at: 50	put: [ :obj | obj nextFourByteSymbol ];		"056-063: Arrays"			at: 56	put: [ :obj | obj nextArray ];			at: 57	put: [ :obj | obj nextByteArray ];			at: 58	put: [ :obj | obj nextWordArray ];			at: 59	put: [ :obj | obj nextDwordArray ];			at: 60	put: [ :obj | obj nextUninterpretedBytes ];		"064-071: Collections 1"			at: 64	put: [ :obj | obj nextBag ];			at: 65	put: [ :obj | obj nextInterval ];			at: 66	put: [ :obj | obj nextOrderedCollection ];			at: 67	put: [ :obj | obj nextSortedCollection ];		"072-079: Collections 2"			at: 72	put: [ :obj | obj nextSet ];			at: 73	put: [ :obj | obj nextIdentitySet ];			at: 74	put: [ :obj | obj nextDictionary ];			at: 75	put: [ :obj | obj nextIdentityDictionary ];		"080-087: Collections 3"		"088-095: System Classes 1"			at: 88	put: [ :obj | obj nextCleanOrCopyBlockClosure ];		"096-103: System Classes 2"		"104-111: System Classes 3"		"112-119: Messaging Essentials"			at: 112	put: [ :obj | obj unmarshalForwardReference ];			at: 113	put: [ :obj | obj nextObjectByReference ];			at: 114	put: [ :obj | obj nextPassByOID ];		"120-127: Messaging Essential: Pass-By-Name 1"			at: 120	put: [ :obj | obj nextClassByName ];			at: 121	put: [ :obj | obj nextNameSpaceByName ];			at: 122	put: [ :obj | obj nextNameSpaceOfClassByName ];			at: 123	put: [ :obj | obj nextSignalByName ];			at: 124	put: [ :obj | obj nextBindingReferenceByName ];			at: 125	put: [ :obj | obj nextLiteralBindingReferenceByName ];		"128-135: Messaging Essential: Pass-By-Name 2"		"136-143: Basic Message Types"			at: 136 put: [ :obj | obj nextSTSTRequest ];			"at: 137 put: [ :obj | obj nextSTSTOnewayRequest ];"			at: 138 put: [ :obj | obj nextSTSTReply ];		"144-151: unallocated and reserved"		"152-159: unallocated and reserved"		"160-167: unallocated and reserved"		"168-175: unallocated and reserved"		"176-183: unallocated and reserved"		"184-191: unallocated and reserved"		"192-199: unallocated and reserved"		"200-207: unallocated and reserved"		"208-215: unallocated and reserved"		"216-223: set aside for customer use"		"224-231: set aside for customer use"		"232-230: set aside for customer use"		"240-247: seta side for customer use"		"248-255:  experimental tags"		at: 248	put: [ :obj | obj nextSTSTErrorReply ];		at: 249	put: [ :obj | STSTCloseConnection theOne].		"at: 250	put: [ :obj | obj nextSTSTDebuggableRequest];"		"at: 251	put: [ :obj | obj nextSTSTProfilingRequest];"		"at: 252	put: [ :obj | obj nextSTSTProfilingReply]."</body></methods><methods><class-id>Opentalk.STSTStream class</class-id> <category>marshaling - low-level encoding</category><body package="Opentalk-STST">encodingLimit"	Answer the encoding limit as the max value of 24-bit unsigned integer."	^ 16rFFFFFF</body></methods><methods><class-id>Opentalk.TCPTransportConfiguration</class-id> <category>accessing</category><body package="Opentalk-STST">componentClass	^TCPTransport</body></methods><methods><class-id>Opentalk.STSTCloseConnection</class-id> <category>events-message processing</category><body package="Opentalk-STST">receivingMessageIn: aTransport	"aTransport manager receivingRequest: self in: aTransport"</body><body package="Opentalk-STST">sendingMessageIn: aTransport	"aTransport manager sendingRequest: self in: aTransport"</body></methods><methods><class-id>Opentalk.STSTCloseConnection</class-id> <category>invocation</category><body package="Opentalk-STST">send: aTransport	"self interceptorDispatcher: aTransport provideInterceptorDispatcher.	aTransport manager sendingRequest: self in: aTransport."	aTransport sendPackage: self onErrorDo: [ :ex | "Do nothing" ]</body></methods><methods><class-id>Opentalk.STSTCloseConnection</class-id> <category>dispatching</category><body package="Opentalk-STST">dispatchFor: aTransport 	"Force close aTransport."	"self interceptorDispatcher: aTransport provideInterceptorDispatcher.	aTransport manager receivingRequest: self in: aTransport."	aTransport peerClose.</body></methods><methods><class-id>Opentalk.STSTCloseConnection class</class-id> <category>instance access</category><body package="Opentalk-STST">theOne	"One is enough"	^TheOne isNil		ifTrue:[TheOne := self new]		ifFalse:[TheOne]</body></methods><methods><class-id>Opentalk.STSTCloseConnection class</class-id> <category>accessing</category><body package="Opentalk-STST">msgType	^2</body></methods><methods><class-id>Opentalk.UDPTransport</class-id> <category>accessing</category><body package="Opentalk-STST">getSocketAddress	^socket getName</body><body package="Opentalk-STST">soReuseAddr	^configuration soReuseAddr ifNil: [		self class defaultSoReuseAddr ]</body><body package="Opentalk-STST">socketIsInactiveOrNil		^socket isNil or: [ socket isActive not ]</body></methods><methods><class-id>Opentalk.UDPTransport</class-id> <category>private</category><body package="Opentalk-STST">checkHeader	readBuffer isValid ifFalse: [		OtEProtocol raiseSignal: (#ProtocolMismatch &lt;&lt; #opentalk &gt;&gt; 'Protocol Mismatch')].</body><body package="Opentalk-STST">maxPackageSize	"The maximum datagram size in ...."	^4000</body><body package="Opentalk-STST">readTransportPackage	| ipAddr size readSize |	ipAddr := IPSocketAddress new.	[	[ 	readSize := socket				receiveFrom: ipAddr				buffer: readBuffer				start: 1				for: readBuffer size.		]	on: socket class notReadySignal do: [:ex |				(Delay forMilliseconds: 100) wait.				ex restart]	]	on: OsError do: [ :ex |			ex resignalAs: (				OtECommunicationFailure new					messageText: (						(#x1sFailed2s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; failed - &lt;2s&gt;')							expandMacrosWith: self printString							with: ex description);					yourself) ].	self checkHeader.	size := readBuffer totalSize.	size &gt; self maxPackageSize ifTrue: [		^OtEProtocol raiseSignal: (#MaxPackageSizeExceeded &lt;&lt; #opentalk &gt;&gt; 'Max package size exceeded')].	size = readSize ifFalse: [		^OtECommunicationFailure raiseSignal: (			(#x1sSocketReadFailed2s3s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket read failed. Expected &lt;2s&gt; and got &lt;3s&gt;')				expandMacrosWith: self printString				with: size printString				with: readSize printString) ].	^(TransportPackage newOn: readBuffer)		peerAccessPoint: ipAddr;		yourself</body><body package="Opentalk-STST">readyToHandleIncomingMessage"Let's wait untill there's a message ready"	^super readyToHandleIncomingMessage and: [ socket readWait. true ]</body><body package="Opentalk-STST">sendTransportPackage: aTransportPackage	super sendTransportPackage: aTransportPackage.	aTransportPackage position &gt; self maxPackageSize 		ifTrue: [^OtEProtocol raiseSignal: (#MaxPackageSizeExceeded &lt;&lt; #opentalk &gt;&gt; 'Max package size exceeded')].	[	[	| writeSize pkgSize |			pkgSize := aTransportPackage position.			writeSize := socket				sendTo: aTransportPackage peerAccessPoint				buffer: aTransportPackage buffer				start: 1				for: pkgSize.			writeSize = pkgSize ifFalse: [				OtECommunicationFailure raiseSignal: (					(#x1sSocketWriteFailed2s3s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket write failed. Wanted &lt;2s&gt; and got &lt;3s&gt;')						expandMacrosWith: self printString						with: pkgSize printString						with: writeSize printString) ]		]	on: socket class notReadySignal do: [:ex |				(Delay forMilliseconds: 100) wait.				ex restart]	]	on: OsError do: [ :ex |			ex resignalAs: (				OtECommunicationFailure new					messageText: (						(#x1sFailed2s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; failed - &lt;2s&gt;')							expandMacrosWith: self printString							with: ex description);							yourself) ]</body><body package="Opentalk-STST">serverProcessBody	super serverProcessBody.	tryRestart	ifTrue: [		tryRestart := false.		self tryRestart]</body><body package="Opentalk-STST">socket	^socket</body></methods><methods><class-id>Opentalk.UDPTransport</class-id> <category>protocol-API</category><body package="Opentalk-STST">doStart	tryRestart := false.	self createSocket.	super doStart.</body><body package="Opentalk-STST">doStop	super doStop.	socket isNil ifFalse: [		socket close.		socket := nil]</body></methods><methods><class-id>Opentalk.UDPTransport</class-id> <category>initialize-release</category><body package="Opentalk-STST">createSocket	| address |	address := IPSocketAddress hostAddress: manager bindAddress port: port.	socket := SocketAccessor			family: address domainCode			type: SocketAccessor SOCK_DGRAM.	self setOptionsOn: socket.	socket bindTo: address</body><body package="Opentalk-STST">setManager: aConnectionManager at: anAccessPoint	port := anAccessPoint port.	super setManager: aConnectionManager at: anAccessPoint.</body><body package="Opentalk-STST">setOptionsOn: aSocketAccessor	self soReuseAddr ifTrue: [		aSocketAccessor otReuseAddress: true ]</body></methods><methods><class-id>Opentalk.UDPTransport class</class-id> <category>accessing</category><body package="Opentalk-STST">protocolTag	^'udp'</body></methods><methods><class-id>Opentalk.UDPTransport class</class-id> <category>defaults-accessing</category><body package="Opentalk-STST">defaultSoReuseAddr	^defaultSoReuseAddr ifNil: [		self defaultSoReuseAddrValue ]</body><body package="Opentalk-STST">defaultSoReuseAddr: aBoolean	defaultSoReuseAddr := aBoolean</body></methods><methods><class-id>Opentalk.UDPTransport class</class-id> <category>defaults-constants</category><body package="Opentalk-STST">defaultSoReuseAddrValue	^false</body></methods><methods><class-id>Opentalk.UDPTransport class</class-id> <category>deprecated</category><body package="Opentalk-STST">soReuseAddr	^self defaultSoReuseAddr</body><body package="Opentalk-STST">soReuseAddr: aBoolean	self defaultSoReuseAddr: aBoolean</body></methods><methods><class-id>Opentalk.STSTMarshaler</class-id> <category>initialize-release</category><body package="Opentalk-STST">initialize: aConfiguration	super initialize: aConfiguration.	ststStream := STSTStream on: (ByteArray new: self bufferSize)</body><body package="Opentalk-STST">setManager: aManager	super setManager: aManager.	ststStream manager: aManager</body></methods><methods><class-id>Opentalk.STSTMarshaler</class-id> <category>accessing</category><body package="Opentalk-STST">bufferSize	^configuration bufferSize ifNil: [		self class defaultBufferSize ]</body></methods><methods><class-id>Opentalk.STSTMarshaler</class-id> <category>marshaling</category><body package="Opentalk-STST">marshalTransportPayloadOf: anSTSTMessage into: aTransportPackage	| pos |	anSTSTMessage sendingMessageIn: self transport.	pos := aTransportPackage position.	ststStream		on: aTransportPackage buffer swap: false size: pos;		skip: pos;		marshalObject: anSTSTMessage.	^aTransportPackage		msgSize: ststStream contentSize - aTransportPackage headerSize;		position: ststStream position;		yourself</body><body package="Opentalk-STST">unmarshalTransportPayloadFrom: aTransportPackage	| msg |	ststStream		on: aTransportPackage buffer		swap: aTransportPackage swap		size: aTransportPackage msgSize + aTransportPackage headerSize.	ststStream skip: aTransportPackage headerSize.	msg := ststStream unmarshalObject.	msg receivingMessageIn: self transport.	^msg</body></methods><methods><class-id>Opentalk.STSTMarshaler class</class-id> <category>accessing</category><body package="Opentalk-STST">requestClass	^STSTRequest</body></methods><methods><class-id>Opentalk.STSTMarshaler class</class-id> <category>defaults-accessing</category><body package="Opentalk-STST">defaultBufferSize	^defaultBufferSize ifNil: [		self defaultBufferSizeValue ]</body><body package="Opentalk-STST">defaultBufferSize: aSmallInteger	defaultBufferSize := aSmallInteger</body></methods><methods><class-id>Opentalk.STSTMarshaler class</class-id> <category>defaults-constants</category><body package="Opentalk-STST">defaultBufferSizeValue	^1024</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	^#CompiledCodeInspector</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#reference</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	"Open a WindowBrowser, not a basic inspector.  Components can get one by	evaluating 'foo topComponent inspect'"	^#WindowBrowser</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Kernel.QualifiedName</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^Opentalk.OtEMarshalingPassByName 		raiseSignal: (#MustNotPassByName &lt;&lt; #opentalk &gt;&gt; 'Only instances of Class, NameSpace, NameSpaceofClass, Signal, BindingReference, and LiteralBindingReference may be passed by name.')</body></methods><methods><class-id>Kernel.BindingReference</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^( self isPassedByName )		ifTrue:	[ self ]		ifFalse:	[ Opentalk.PassModeWrapper newOn: self passMode: #name ]</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>local-execution</category><body package="Opentalk-STST">asPassedByReference	^self</body><body package="Opentalk-STST">asPassedByValue	^self</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>forwarding</category><body package="Opentalk-STST">copy	"Get a local copy of the remote object."	^self _sendMessage: (Message selector: #_remoteCopy)</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>local-testing</category><body package="Opentalk-STST">passMode	"A remote object is a special case with regard to passing mode, for it must be passed as the object reference that it holds."	^#reference</body><body package="Opentalk-STST">ping	^requestBroker ping: objRef accessPoint</body></methods><methods><class-id>Core.Set</class-id> <category>opentalk-stst</category><body package="Opentalk-STST">postPassByValue	self rehash.	^self</body></methods><methods><class-id>Core.Signal</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^( self isPassedByName )		ifTrue:	[ self ]		ifFalse:	[ Opentalk.PassModeWrapper newOn: self passMode: #name ]</body><body package="Opentalk-STST">passMode	^#reference</body></methods><methods><class-id>Core.Object class</class-id> <category>marshaling</category><body package="Opentalk-STST">unmarshalWith: aMarshaler	^aMarshaler nextObject: self.</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk-stst</category><body package="Opentalk-STST">_remoteCopy	"Make a copy of the receiver at the remote location.  This	method is intended *only* for STST internal use."	^self asPassedByValue</body><body package="Opentalk-STST">asPassedByName	^Opentalk.OtEMarshalingPassByName 		raiseSignal: (#MustNotPassByName &lt;&lt; #opentalk &gt;&gt; 'Only instances of Class, NameSpace, NameSpaceofClass, Signal, BindingReference, and LiteralBindingReference may be passed by name.')</body><body package="Opentalk-STST">asPassedByOID	^( self isPassedByOID )		ifTrue:	[ self ]		ifFalse:	[  Opentalk.PassModeWrapper newOn: self passMode: #oid ]</body><body package="Opentalk-STST">asPassedByReference	^( self isPassedByReference )		ifTrue:	[ self ]		ifFalse:	[  Opentalk.PassModeWrapper newOn: self passMode: #reference ]</body><body package="Opentalk-STST">asPassedByValue	^( self passMode = #value )		ifTrue:	[ self ]		ifFalse:	[  Opentalk.PassModeWrapper newOn: self passMode: #value ]</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk</category><body package="Opentalk-STST">indexOfInstVarName: aString	"This speeds up remote inspection."	^self class allInstVarNames indexOf: aString</body><body package="Opentalk-STST">inspectorClass	^Smalltalk at: self inspectorClassName ifAbsent: [ Inspector ]</body><body package="Opentalk-STST">inspectorClassName	^#Inspector</body><body package="Opentalk-STST">isKindOf: aClass 	"Answer a Boolean as to whether the class, aClass, is a superclass or class of	the receiver.  Note: aClass may be a remote class, and in that case we just 	compare the class names."	^( aClass _isRemote )		ifTrue:	[ self class includesBehaviorNamed: aClass fullName ]		ifFalse:	[ self class includesBehavior: aClass ]</body><body package="Opentalk-STST">isMemberOf: aClass 	"Answer a Boolean as to whether the receiver is an instance of the class, aClass.  Note that aClass may be a remote class, and in that case we just compare the class names."	^( aClass _isRemote )		ifTrue:	[ self class fullName = aClass fullName	]		ifFalse:	[ self class ==  aClass	]</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk-stst</category><body package="Opentalk-STST">isPassedByName	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #name</body><body package="Opentalk-STST">isPassedByOID	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #oid</body><body package="Opentalk-STST">isPassedByReference	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #reference</body><body package="Opentalk-STST">isPassedByValue	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #value</body><body package="Opentalk-STST">isSingleton	^false</body><body package="Opentalk-STST">marshalWith: aMarshaler	aMarshaler nextPutObject: self.</body><body package="Opentalk-STST">passInstVars	"This method allows a class to supersede the default pass mode of instance variables.  The method supersede instance variable pass modes positionally by answering an Array, containing Symbols that indicate the desired pass mode.  Those symbols are: #default, #skip, #value, #reference, #name, and #oid.  For example, if the method 'passInstVars' answers the literal array '#( #default #skip #value #reference #name #oid)' then:		the 1st instVar is passed according to its own default pass mode specification,		the 2nd instVar is not passed (resulting in a remote nil),		the 3rd instVar is passed by value, and		the 4th instVar is passed by reference,		the 5th instVar is passed by name,		the 6th instVar is passed by OID, and		all subsequent instVars are passed according to their own default specifications."	^#()</body><body package="Opentalk-STST">passMode	"The default pass mode is pass-by-reference."	^#reference</body><body package="Opentalk-STST">passModeForIndexedSlot: index value: anObject	^#default</body><body package="Opentalk-STST">ping	^true</body><body package="Opentalk-STST">postPassByValue	"By default, do nothing."	^self</body></methods><methods><class-id>Core.Exception</class-id> <category>marshaling</category><body package="Opentalk-STST">marshalWith: aMarshaler	originator isSingleton ifFalse: [		originator := originator asPassedByReference ].	super marshalWith: aMarshaler</body><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Opentalk.Transport</class-id> <category>stst</category><body package="Opentalk-STST">nonTransportEnvironmentAssociationsFrom: message	^message environmentAssociations</body><body package="Opentalk-STST">transportEnvironmentAssociationsFor: message	^#()</body></methods><methods><class-id>Kernel.Context</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	"Create and schedule an Inspector in which the user can examine the	receiver's variables."	^#CompiledCodeInspector</body></methods><methods><class-id>Core.Timestamp</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#reference</body></methods><methods><class-id>Opentalk.TransportConfiguration class</class-id> <category>types</category><body package="Opentalk-STST">tcp	^TCPTransportConfiguration new</body><body package="Opentalk-STST">udp	^UDPTransportConfiguration new</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>UI.Menu</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Kernel.RemoteString</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Kernel.NameSpaceOfClass</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^( self isPassedByName )		ifTrue:	[ self ]		ifFalse:	[ Opentalk.PassModeWrapper newOn: self passMode: #name ]</body></methods><methods><class-id>Kernel.MethodDictionary</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	^#DictionaryInspector</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	^#OrderedCollectionInspector</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>marshaling</category><body package="Opentalk-STST">isSingleton	^true</body><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Core.Message</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Core.UninterpretedBytes</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	^#CompiledCodeInspector</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>opentalk-stst</category><body package="Opentalk-STST">passModeForIndexedSlot: index value: anObject	^(anObject isKindOf: BlockClosure)		ifTrue: [#value]		ifFalse: [#default]</body></methods><methods><class-id>Core.Behavior</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByValue	"Behavior should be always passed by reference"	self notify: (#MustNotPassByValue &lt;&lt; #opentalk &gt;&gt; 'Pass-by-value is not supported for Behavior objects').	^self</body></methods><methods><class-id>Core.Behavior</class-id> <category>testing class hierarchy</category><body package="Opentalk-STST">includesBehaviorNamed: aDottedClassName 	"Answer whether the argument, aClassName, is equal to 'self name' or is on the receiver's superclass name chain."	^( self fullName = aDottedClassName ) or:		[ superclass notNil and:			[ superclass includesBehaviorNamed: aDottedClassName ] ]</body></methods><methods><class-id>Core.Behavior</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	"Do not change!  Behaviors should be passed by reference by default, and by name only in cases where identity of implementation is assured."	^#reference</body></methods><methods><class-id>Core.Interval</class-id> <category>opentalk</category><body package="Opentalk-STST">stop	^stop</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	"Code changed to return the name rather than the class	to enforce pass-by-name."	^#ChangeSetInspector</body></methods><methods><class-id>Opentalk.StreamTransport</class-id> <category>stst</category><body package="Opentalk-STST">nonTransportEnvironmentAssociationsFrom: message	^(message isReply not and: [ manager isBiDirectional ])		ifTrue: [ message environmentAssociations reject: [ :asc |				self processEnvironmentAssociation: asc ] ]		ifFalse: [ message environmentAssociations ]</body><body package="Opentalk-STST">peerAccessPoint: address	peerId := address.	manager peerAccessPointFor: self is: address</body><body package="Opentalk-STST">processEnvironmentAssociation: asc	asc key = #STSTAccessPoint ifTrue: [		self peerAccessPoint: asc value. ^true ].	^false</body><body package="Opentalk-STST">transportEnvironmentAssociationsFor: message	^(message isReply not and: [ manager isBiDirectional and: [ message isFirst ]])		ifTrue: [ Array with: (#STSTAccessPoint -&gt; manager accessPoint) ]		ifFalse: [ #() ]</body></methods><methods><class-id>Core.Boolean</class-id> <category>marshaling</category><body package="Opentalk-STST">isSingleton	^true</body><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Graphics.Geometric</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Opentalk.LocalDependents</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#reference</body></methods><methods><class-id>Kernel.NameSpaceImport</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^Opentalk.OtEMarshalingPassByName 		raiseSignal: (#MustNotPassByName &lt;&lt; #opentalk &gt;&gt; 'Only instances of Class, NameSpace, NameSpaceofClass, Signal, BindingReference, and LiteralBindingReference may be passed by name.')</body></methods><methods><class-id>Core.String</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	^#SequenceableCollectionInspector</body></methods><methods><class-id>Core.Magnitude</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Core.Dictionary</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	^#DictionaryInspector</body></methods><methods><class-id>Core.Dictionary</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#reference</body></methods><methods><class-id>Opentalk.BasicRequestBroker class</class-id> <category>instance creation</category><body package="Opentalk-STST">newStstTcpAt: anIPSocketAddress	^(StandardBrokerConfiguration new		adaptor: (ConnectionAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (TCPTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAt: anIPSocketAddress</body><body package="Opentalk-STST">newStstTcpAtPort: aNumber	^(StandardBrokerConfiguration new		adaptor: (ConnectionAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (TCPTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAtPort: aNumber</body><body package="Opentalk-STST">newStstUdpAt: anIPSocketAddress	^(StandardBrokerConfiguration new		adaptor: (ConnectionLessAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (UDPTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAt: anIPSocketAddress</body><body package="Opentalk-STST">newStstUdpAtPort: aNumber	^(StandardBrokerConfiguration new		adaptor: (ConnectionLessAdaptorConfiguration new			requestDispatcher: RequestDispatcherConfiguration standard;			transport: (UDPTransportConfiguration new				marshaler: STSTMarshalerConfiguration new				)))		newAtPort: aNumber</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^( self isPassedByName )		ifTrue:	[ self ]		ifFalse:	[ Opentalk.PassModeWrapper newOn: self passMode: #name ]</body></methods><methods><class-id>OS.IPv4SocketAddress</class-id> <category>opentalk</category><body package="Opentalk-STST">_type	"This is a hack to make IPv4SocketAddress marshal in a backward-compatible way, i.e. as an untagged IPSocketAddress.	This should be removed with the next protocol revision (hopefully marshaling addresses more efficiently as well).	See 68126: [STST] Forward compatible IPv6 changes broke backward-compatibility of STST"	^IPSocketAddress</body></methods><methods><class-id>Kernel.ChangeSupportClassProxy</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^Opentalk.OtEMarshalingPassByName 		raiseSignal: (#MustNotPassByName &lt;&lt; #opentalk &gt;&gt; 'Only instances of Class, NameSpace, NameSpaceofClass, Signal, BindingReference, and LiteralBindingReference may be passed by name.')</body></methods><methods><class-id>OS.Filename</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Opentalk.ObjRef</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	" ... for now by reference, as a reasonable default for SortedCollection and all of its subclasses.  Nevertheless it is safe to pass SortedCollections themselves by reference, so long as their 'sortBlock' is not a full block."	^#reference</body></methods><methods><class-id>Graphics.StopsDictionary</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName		^#DictionaryInspector</body></methods><methods><class-id>Core.Collection</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Core.ByteEncodedString class</class-id> <category>marshaling</category><body package="Opentalk-STST">unmarshalWith: aMarshaler	^aMarshaler nextString</body></methods><methods><class-id>Core.ByteEncodedString</class-id> <category>marshaling</category><body package="Opentalk-STST">marshalWith: aMarshaler	^aMarshaler nextPutString: self</body></methods><methods><class-id>Opentalk.RemoteMessage</class-id> <category>accessing</category><body package="Opentalk-STST">isFirst	^requestId = 1</body></methods><methods><class-id>Opentalk.RemoteMessage</class-id> <category>marshaling</category><body package="Opentalk-STST">passMode	^#value</body></methods><methods><class-id>Kernel.LiteralBindingReference</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^( self isPassedByName )		ifTrue:	[ self ]		ifFalse:	[ Opentalk.PassModeWrapper newOn: self passMode: #name ]</body></methods><methods><class-id>Core.Character</class-id> <category>marshaling</category><body package="Opentalk-STST">isSingleton	^true</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>marshaling</category><body package="Opentalk-STST">isSingleton	^self between: -536870912 and: 536870911</body></methods><methods><class-id>Protocols.ProtoObject class</class-id> <category>marshaling</category><body package="Opentalk-STST">unmarshalWith: aMarshaler	^aMarshaler nextObject: self.</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>opentalk-stst</category><body package="Opentalk-STST">_remoteCopy	"Make a copy of the receiver at the remote location.  This	method is intended *only* for STST internal use."	^self asPassedByValue</body><body package="Opentalk-STST">asPassedByName	^Opentalk.OtEMarshalingPassByName 		raiseSignal: (#MustNotPassByName &lt;&lt; #opentalk &gt;&gt; 'Only instances of Class, NameSpace, NameSpaceofClass, Signal, BindingReference, and LiteralBindingReference may be passed by name.')</body><body package="Opentalk-STST">asPassedByOID	^( self isPassedByOID )		ifTrue:	[ self ]		ifFalse:	[  Opentalk.PassModeWrapper newOn: self passMode: #oid ]</body><body package="Opentalk-STST">asPassedByReference	^( self isPassedByReference )		ifTrue:	[ self ]		ifFalse:	[  Opentalk.PassModeWrapper newOn: self passMode: #reference ]</body><body package="Opentalk-STST">asPassedByValue	^( self passMode = #value )		ifTrue:	[ self ]		ifFalse:	[  Opentalk.PassModeWrapper newOn: self passMode: #value ]</body><body package="Opentalk-STST">isPassedByName	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #name</body><body package="Opentalk-STST">isPassedByOID	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #oid</body><body package="Opentalk-STST">isPassedByReference	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #reference</body><body package="Opentalk-STST">isPassedByValue	"Override 'passMode', not this method, if you want to change the default pass of an object."	^self passMode == #value</body><body package="Opentalk-STST">isSingleton	^false</body><body package="Opentalk-STST">marshalWith: aMarshaler	aMarshaler nextPutObject: self.</body><body package="Opentalk-STST">passInstVars	"This method allows a class to supersede the default pass mode of instance variables.  The method supersede instance variable pass modes positionally by answering an Array, containing Symbols that indicate the desired pass mode.  Those symbols are: #default, #skip, #value, #reference, #name, and #oid.  For example, if the method 'passInstVars' answers the literal array '#( #default #skip #value #reference #name #oid)' then:		the 1st instVar is passed according to its own default pass mode specification,		the 2nd instVar is not passed (resulting in a remote nil),		the 3rd instVar is passed by value, and		the 4th instVar is passed by reference,		the 5th instVar is passed by name,		the 6th instVar is passed by OID, and		all subsequent instVars are passed according to their own default specifications."	^#()</body><body package="Opentalk-STST">passMode	"The default pass mode is pass-by-reference."	^#reference</body><body package="Opentalk-STST">passModeForIndexedSlot: index value: anObject	^#default</body><body package="Opentalk-STST">ping	^true</body><body package="Opentalk-STST">postPassByValue	"By default, do nothing."	^self</body></methods><methods><class-id>Core.Bag</class-id> <category>opentalk</category><body package="Opentalk-STST">contents: aDictionary	contents := aDictionary</body></methods><methods><class-id>Opentalk.MarshalerConfiguration class</class-id> <category>types</category><body package="Opentalk-STST">stst	^STSTMarshalerConfiguration new</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>marshaling</category><body package="Opentalk-STST">unmarshalWith: aMarshaler	^aMarshaler nextIPSocketAddress.</body></methods><methods><class-id>OS.IPSocketAddress</class-id> <category>marshaling</category><body package="Opentalk-STST">marshalWith: aMarshaler	^aMarshaler nextPutIPSocketAddress: self.</body></methods><methods><class-id>Core.IntegerArray</class-id> <category>user interface</category><body package="Opentalk-STST">inspectorClassName	^#SequenceableCollectionInspector</body></methods><methods><class-id>Core.Class</class-id> <category>marshaling</category><body package="Opentalk-STST">asPassedByName	^( self isPassedByName )		ifTrue:	[ self ]		ifFalse:	[ Opentalk.PassModeWrapper newOn: self passMode: #name ]</body></methods><initialize><class-id>Opentalk.STSTStream</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Message</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Signal</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent mayProceed notifierString nameClass nameMessage exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>RemoteMessage</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId interceptorDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Proxy</name><environment>Opentalk</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>objRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core-Support</package></attributes></class><class><name>ProtoObject</name><environment>Protocols</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>ObjRef</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint oid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>StopsDictionary</name><environment>Graphics</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Text Scanning</category><attributes><package>Graphics-Text Scanning</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>OtEMarshaling</name><environment>Opentalk</environment><super>Opentalk.OtSystemException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>BindingReference</name><environment>Kernel</environment><super>Kernel.GeneralBindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseClass environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>NameSpaceImport</name><environment>Kernel</environment><super>Kernel.BindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>drillDown private </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ChangeSet</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectChanges objectRemoves componentChanges specialDoIts initializationOrder </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>IPSocketAddress</name><environment>OS</environment><super>OS.SocketAddress</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>IPv4SocketAddress</name><environment>OS</environment><super>OS.IPSocketAddress</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OS-Sockets</package></attributes></class><class><name>Bag</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Transport</name><environment>Opentalk</environment><super>Opentalk.GenericProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager serverProcess sendLock marshaler unmarshaler readBuffer writeBuffer configuration </inst-vars><class-inst-vars>defaultBufferSize defaultServerPriority </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>RemoteObject</name><environment>Opentalk</environment><super>Opentalk.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestBroker dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>StreamTransport</name><environment>Opentalk</environment><super>Opentalk.RequestTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id peerId writeStream readStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>MethodDictionary</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>MarshalerConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>DatagramTransport</name><environment>Opentalk</environment><super>Opentalk.RequestTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>RemoteString</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>NameSpaceOfClass</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ReadWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteEncodedString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars>encoder </class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>LocalDependents</name><environment>Opentalk</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>ChangeSupportClassProxy</name><environment>Kernel</environment><super>Kernel.BindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>meta objectType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>RemoteRequest</name><environment>Opentalk</environment><super>Opentalk.RemoteMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target message timeout promise reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>StreamTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.TransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Geometric</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>LiteralBindingReference</name><environment>Kernel</environment><super>Kernel.GeneralBindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>QualifiedName</name><environment>Kernel</environment><super>Kernel.BindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>outerMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Menu</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items groupSizes adornment selectionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>RemoteReply</name><environment>Opentalk</environment><super>Opentalk.RemoteMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Marshaler</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>DatagramTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.TransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soReuseAddr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>IntegerArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class></st-source>