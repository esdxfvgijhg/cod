<?xml version="1.0"?><st-source><!-- Name: MemoryMonitorNotice: Copyright (c) 1995-2009 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This package contains a memory monitor that displays the status of VisualWorks garbage collector and the sizes of its various memory segments.DbIdentifier: bear73DbTrace: 454390DbUsername: thomasbDbVersion: 1.41DevelopmentPrerequisites: #(#(#any 'Refactory-Namespace' '') #(#any 'UIPainter' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: MemoryMonitorParcel: #('MemoryMonitor')ParcelName: MemoryMonitorPrerequisiteDescriptions: #(#(#name 'Refactory-Namespace') #(#name 'UIPainter' #componentType #package))PrerequisiteParcels: #(#('Refactory-Namespace' '') #('UIPainter' ''))PrintStringCache: (1.41,thomasb)Version: 1.41Date: 7:23:10 AM January 9, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (jan15.1) of January 9, 2015 on January 9, 2015 at 7:23:10 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>MemoryMonitorNamespace</name><environment>Refactory</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>MemoryMonitor</package></attributes></name-space><class><name>BoundedList</name><environment>Refactory.MemoryMonitorNamespace</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents size startingIndex list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Memory Monitor</category><attributes><package>MemoryMonitor</package></attributes></class><comment><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id><body>BoundedList is a list with a maximum size. If a new item is added and the max size has been reached, it removes the first item in the list.Instance Variables:	dependents	&lt;Object&gt;	our dependents	list	&lt;Array&gt;	the elements	size	&lt;Integer&gt;	the current number of elements in list	startingIndex	&lt;Integer&gt;	the index of the first element</body></comment><class><name>AreaGraphWidget</name><environment>Refactory.MemoryMonitorNamespace</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>minHolder maxHolder points </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Memory Monitor</category><attributes><package>MemoryMonitor</package></attributes></class><comment><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget</class-id><body>AreaGraphWidget displays a simple area graph.Instance Variables	maxHolder	&lt;ValueModel on: Number&gt;	the maximum value for the y axis if nil, the max will be computed from the abs value of the points	minHolder	&lt;ValueModel on: Number&gt;	the minimum value for the y axis if nil, the min will be the negated computed max	points	&lt;Array of: Number&gt;	the y value of the points to graph</body></comment><class><name>AreaGraphWidgetSpec</name><environment>Refactory.MemoryMonitorNamespace</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maxFixedNumber minFixedNumber minModel maxModel maxType minType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Memory Monitor</category><attributes><package>MemoryMonitor</package></attributes></class><comment><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec</class-id><body>AreaGraphWidgetSpec is the spec for the AreaGraphWidget.Instance Variables	maxFixedNumber	&lt;Number&gt;	max value constant	maxModel	&lt;Symbol&gt;	the symbol for the max model	maxType	&lt;Symbol&gt;	the type of the max value model -- fixed, model or computed	minFixedNumber	&lt;Number&gt;	min value constant	minModel	&lt;Symbol&gt;	the symbol for the min model	minType	&lt;Symbol&gt;	the type of the min value model -- fixed, model or computed</body></comment><class><name>MemoryMonitor</name><environment>Refactory.MemoryMonitorNamespace</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process processRatchet igcState survivorUsedBytes permUsedBytes largeUsedBytes edenUsedBytes oldUsedBytes survivorPercentageUsed permPercentageUsed edenPercentageUsed oldPercentageUsed largePercentageUsed schedulingDelay schedulingPriority allocatedMemoryList scavengesList allocatedMemoryMin scavenges allocatedMemory allocatedMemoryMax scavengesMax fixedPercentageUsed fixedUsedBytes scavengesLast fixedSegments largeSegments permSegments survivorSegments edenSegments oldSegments stackSpills igcMarkedBytes igcMarkedWeakBytes igcNilledBytes igcReclaimedBytes igcMarkedObjects igcMarkedWeakObjects igcReclaimedObjects igcSweepAllocatedObjects igcNilledObjects igcUnmarkedObjects igcSweepAllocatedBytes igcSweptObjects mapActive logToFile logFilename igcCount ggcCount gcCount markStackOverflows weakListOverflows logMutex snapshotMutex numJITCacheSpills igcAbortedCount igcMarkStackOverflows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Memory Monitor</category><attributes><package>MemoryMonitor</package></attributes></class><comment><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id><body>MemoryMonitor displays status of the VisualWorks garbage collector and the sizes of the memory segments.</body></comment><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id> <category>removing</category><body package="MemoryMonitor">removeFirst	| element |	size == 0 ifTrue: [self subscriptBoundsError: 1].	element := self first.	startingIndex := (startingIndex + 1) \\ list size.	size := size - 1.	self changed: #removeFirst with: element.	^element</body><body package="MemoryMonitor">removeLast	| element |	size == 0 ifTrue: [self subscriptBoundsError: 1].	element := self at: size.	size := size - 1.	self changed: #removeLast with: element.	^element</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id> <category>enumerating</category><body package="MemoryMonitor">do: aBlock 	| index |	size == 0 ifTrue: [^self].	index := self indexFor: size.	startingIndex &lt; index 		ifTrue: [startingIndex + 1 to: index do: [:i | aBlock value: (list at: i)]]		ifFalse: 			[startingIndex + 1 to: list size do: [:i | aBlock value: (list at: i)].			1 to: index do: [:i | aBlock value: (list at: i)]]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id> <category>copying</category><body package="MemoryMonitor">postCopy	super postCopy.	self breakDependents</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id> <category>accessing</category><body package="MemoryMonitor">at: anIndex	anIndex &gt; size ifTrue: [self subscriptBoundsError: anIndex].	^list at: (self indexFor: anIndex)</body><body package="MemoryMonitor">size	^size</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id> <category>initialize-release</category><body package="MemoryMonitor">size: anIndex 	list := Array new: anIndex.	startingIndex := 0.	size := 0</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id> <category>adding</category><body package="MemoryMonitor">add: anElement	list at: (self indexFor: size + 1) put: anElement.	size == list size		ifTrue: [startingIndex := (startingIndex + 1) \\ list size]		ifFalse: [size := size + 1].	self changed: #add: with: anElement</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList</class-id> <category>private</category><body package="MemoryMonitor">indexFor: anIndex	^(startingIndex + anIndex - 1 \\ list size) + 1</body><body package="MemoryMonitor">myDependents	^dependents</body><body package="MemoryMonitor">myDependents: dependentsOrNil	dependents := dependentsOrNil</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.BoundedList class</class-id> <category>instance creation</category><body package="MemoryMonitor">new	^self new: 10</body><body package="MemoryMonitor">new: anIndex 	^(self basicNew)		size: anIndex;		yourself</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget</class-id> <category>bounds accessing</category><body package="MemoryMonitor">preferredBounds	^Screen default bounds</body><body package="MemoryMonitor">preferredExtent		^ Screen default bounds extent</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget</class-id> <category>displaying</category><body package="MemoryMonitor">displayOn: graphicsContext	| min max dist yScale extent |	model isEmpty ifTrue: [^self].	graphicsContext paint: self backgroundColor.	self bounds displayFilledOn: graphicsContext.	min := self min.	max := self max.	extent := self bounds extent.	(min = max or: [model size == 1])		ifTrue: [^self bounds displayFilledOn: graphicsContext].	yScale := extent y asFloat / (max - min).	dist := extent x asFloat / (model size - 1).	(points isNil or: [points size ~~ (model size + 2)])		ifTrue: [points := Array new: model size + 2].	points		at: 1 put: extent x @ (yScale * min + extent y) rounded;		at: 2 put: 0 @ (yScale * min + extent y) rounded.	1 to: model size do: 		[:i |			| newPoint |			newPoint := (dist * (i - 1)) rounded				@ (yScale * (min - (model at: i)) + extent y) rounded.			points at: i + 2 put: newPoint		].	graphicsContext		paint: self selectionForegroundColor;		displayPolygon: points;		paint: self foregroundColor;		displayPolyline: points</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget</class-id> <category>private</category><body package="MemoryMonitor">computeMaximum	^model inject: 0 into: [:sum :each | sum max: each abs]</body><body package="MemoryMonitor">max	^maxHolder isNil ifTrue: [self computeMaximum] ifFalse: [maxHolder value]</body><body package="MemoryMonitor">min	^minHolder isNil ifTrue: [self computeMaximum negated] ifFalse: [minHolder value]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget</class-id> <category>accessing</category><body package="MemoryMonitor">maxHolder: aMaxHolder 	maxHolder := aMaxHolder.</body><body package="MemoryMonitor">minHolder: aMinHolder 	minHolder := aMinHolder.</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget</class-id> <category>updating</category><body package="MemoryMonitor">update: aspectSymbol 	self invalidate.	self repairDamage</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget class</class-id> <category>instance creation</category><body package="MemoryMonitor">model: aList min: minHolder max: maxHolder	^(self model: aList)		minHolder: minHolder;		maxHolder: maxHolder;		yourself</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget class</class-id> <category>dialogs</category><body package="MemoryMonitor">openOn: aModel label: aLabel	"A simple window that displays aLabel and the area graph view on aModel."	| wrapper topView upperView lowerView size graphic |	graphic := (aLabel isKindOf: VisualComponent)				ifTrue: [aLabel]				ifFalse: [aLabel asText asComposedText].	wrapper := CompositePart new.	upperView := CompositePart new.	lowerView := CompositePart new.	upperView add: graphic		in: (LayoutFrame				leftFraction: 0.5				offset: (graphic bounds extent // 2) x negated				rightFraction: 0.5				offset: (graphic bounds extent // 2) x				topFraction: 0.5				offset: (graphic bounds extent // 2) y negated				bottomFraction: 0.5				offset: (graphic bounds extent // 2) y).	lowerView add: (self model: aModel) in: (0 @ 0 corner: 1 @ 1).	wrapper add: upperView		in: ((LayoutFrame new)				leftFraction: 0;				rightFraction: 1;				topFraction: 0.0;				bottomFraction: 0.0 offset: graphic bounds extent y + 10;				yourself).	wrapper add: lowerView		borderedIn: ((LayoutFrame new)				leftFraction: 0;				rightFraction: 1;				topFraction: 0.0 offset: graphic bounds extent y + 10;				bottomFraction: 1;				yourself).	topView := ScheduledWindow new.	topView damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	topView label: ''.	topView component: wrapper.	size := (graphic bounds extent x + 20 max: 250)				@ ((graphic bounds extent y + 10) * 2 max: 100).	topView		minimumSize: size;		maximumSize: size.	topView openDisplayAt: Screen default bounds extent // 2 - (size // 2).	^topView controller</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidget class</class-id> <category>examples</category><body package="MemoryMonitor">example	"self example"	| windowController aModel random |	aModel := BoundedList new: 10.	windowController := self openOn: aModel				label: 'This is a test' asText allBold.	random := Random new.	1 to: 20		do: 			[:i |			aModel add: random next.			(Delay forMilliseconds: 400) wait].	windowController closeAndUnschedule</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec</class-id> <category>aspects</category><body package="MemoryMonitor">maxFixedNumber	^maxFixedNumber</body><body package="MemoryMonitor">maxFixedNumber: aNumber	maxFixedNumber := aNumber</body><body package="MemoryMonitor">maxModel	^maxModel</body><body package="MemoryMonitor">maxModel: aSymbol	maxModel := aSymbol</body><body package="MemoryMonitor">maxType	^maxType</body><body package="MemoryMonitor">maxType: aSymbol	maxType := aSymbol</body><body package="MemoryMonitor">minFixedNumber	^minFixedNumber</body><body package="MemoryMonitor">minFixedNumber: aNumber	minFixedNumber := aNumber</body><body package="MemoryMonitor">minModel	^minModel</body><body package="MemoryMonitor">minModel: aSymbol	minModel := aSymbol</body><body package="MemoryMonitor">minType	^minType</body><body package="MemoryMonitor">minType: aSymbol	minType := aSymbol</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec</class-id> <category>initialize</category><body package="MemoryMonitor">initialize	super initialize.	maxType := minType := #dynamic.	maxFixedNumber := minFixedNumber := 0</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec</class-id> <category>private</category><body package="MemoryMonitor">defaultModel	^BoundedList		with: 3		with: 2		with: 4		with: 1</body><body package="MemoryMonitor">dispatchTo: policy with: builder 	| component mdl |	mdl := self modelInBuilder: builder.	component := AreaGraphWidget new model: mdl.	self minType == #fixedUsedBytes 		ifTrue: [component minHolder: self minFixedNumber asValue].	self minType == #model 		ifTrue: 			[component 				minHolder: (self boundsModelFor: self minModel inBuilder: builder)].	self maxType == #fixedUsedBytes 		ifTrue: [component maxHolder: self maxFixedNumber asValue].	self maxType == #model 		ifTrue: 			[component 				maxHolder: (self boundsModelFor: self maxModel inBuilder: builder)].	builder component: component.	policy 		setDispatcherOf: component		fromSpec: self		builder: builder.	builder wrapWith: policy borderedWrapperClass new.	builder wrapper border: policy inputFieldBorder.	builder wrapper inset: 0.	builder applyLayout: self layout.	builder wrapWith: (policy 				simpleWidgetWrapperOn: builder				spec: self				state: WidgetState new).	^policy</body><body package="MemoryMonitor">getBoundsBindingFor: aSymbol in: builder	| m |	m := builder aspectAt: aSymbol.	m isNil ifFalse: [^m].	builder isEditing		ifFalse: [^builder raiseErrorMessage: 'binding: &lt;1p&gt; not found!' with: aSymbol].	m := nil.	builder cacheWhileEditing ifTrue: [builder actionAt: aSymbol put: m].	^m</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec</class-id> <category>accessing</category><body package="MemoryMonitor">boundsModelFor: aSymbol inBuilder: builder 	model isNil ifTrue: [^nil].	^model isSymbol 		ifTrue: [self getBoundsBindingFor: aSymbol in: builder]		ifFalse: [model]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec class</class-id> <category>private-interface building</category><body package="MemoryMonitor">addBindingsTo: env for: inst channel: aChannel 	super 		addBindingsTo: env		for: inst		channel: aChannel.	#(#maxFixedNumber #maxModel #maxType #minFixedNumber #minModel #minType) 		do: 			[:each | 			env at: each				put: (self 						adapt: inst						forAspect: each						channel: aChannel)]</body><body package="MemoryMonitor">componentName	^'Bar Graph Widget'</body><body package="MemoryMonitor">slices	^#(	(Basics basicsEditSpec)		(Color propSpec ColorToolModel) 		(Position propSpec PositionToolModel) )</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>aspects - space percentage bars</category><body package="MemoryMonitor">edenPercentageUsed	^edenPercentageUsed isNil		ifTrue: [edenPercentageUsed := 0 asValue]		ifFalse: [edenPercentageUsed]</body><body package="MemoryMonitor">fixedPercentageUsed	^fixedPercentageUsed isNil		ifTrue: [fixedPercentageUsed := 0 asValue]		ifFalse: [fixedPercentageUsed]</body><body package="MemoryMonitor">largePercentageUsed	^largePercentageUsed isNil		ifTrue: [largePercentageUsed := 0 asValue]		ifFalse: [largePercentageUsed]</body><body package="MemoryMonitor">oldPercentageUsed	^oldPercentageUsed isNil		ifTrue: [oldPercentageUsed := 0 asValue]		ifFalse: [oldPercentageUsed]</body><body package="MemoryMonitor">permPercentageUsed	^permPercentageUsed isNil		ifTrue: [permPercentageUsed := 0 asValue]		ifFalse: [permPercentageUsed]</body><body package="MemoryMonitor">survivorPercentageUsed	^survivorPercentageUsed isNil		ifTrue: [survivorPercentageUsed := 0 asValue]		ifFalse: [survivorPercentageUsed]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>private - updating</category><body package="MemoryMonitor">updateProcessIteration	| objectMemory |	objectMemory := self objectMemoryInstance.	self updateProcessIterationGCWith: objectMemory.	self updateProcessIterationIGCWith: objectMemory.	self updateProcessIterationSpaceSizesWith: objectMemory.	self updateProcessIterationSpaceCountsWith: objectMemory.	self updateProcessIterationScavengesWith: objectMemory.	self updateProcessIterationPerformanceWith: objectMemory</body><body package="MemoryMonitor">updateProcessIterationGCWith: anObjectMemory	self gcCount uniqueValue: anObjectMemory numGCs.	self ggcCount uniqueValue: anObjectMemory numGlobalGCs.	self markStackOverflows uniqueValue: anObjectMemory numMarkStackOverflows.	self weakListOverflows uniqueValue: anObjectMemory numWeakObjectListOverflows</body><body package="MemoryMonitor">updateProcessIterationIGCWith: anObjectMemory	self igcState uniqueValue: anObjectMemory incrementalGCState.	self igcCount uniqueValue: anObjectMemory numIncGCs.	self igcMarkedBytes uniqueValue: anObjectMemory incMarkedBytes.	self igcMarkedObjects uniqueValue: anObjectMemory incMarkedObjects.	self igcMarkedWeakBytes uniqueValue: anObjectMemory incMarkedWeakBytes.	self igcMarkedWeakObjects uniqueValue: anObjectMemory incMarkedWeakObjects.	self igcNilledBytes uniqueValue: anObjectMemory incNilledBytes.	self igcNilledObjects uniqueValue: anObjectMemory incNilledObjects.	self igcReclaimedBytes uniqueValue: anObjectMemory incReclaimedBytes.	self igcReclaimedObjects uniqueValue: anObjectMemory incReclaimedObjects.	self igcSweepAllocatedBytes uniqueValue: anObjectMemory incSweepAllocatedBytes.	self igcSweepAllocatedObjects uniqueValue: anObjectMemory incSweepAllocatedObjects.	self igcSweptObjects uniqueValue: anObjectMemory incSweptObjects.	self igcUnmarkedObjects uniqueValue: anObjectMemory incUnmarkedObjects.	self igcAbortedCount uniqueValue:		([anObjectMemory incAbortedCount]			on: MessageNotUnderstood  "Supported after VW 7.8 only"			do: [:ex | ex return: 0]).	self igcMarkStackOverflows uniqueValue:		([anObjectMemory incMarkStackOverflows]			on: MessageNotUnderstood  "Supported after VW 7.8 only"			do: [:ex | ex return: 0])</body><body package="MemoryMonitor">updateProcessIterationPerformanceWith: anObjectMemory	self stackSpills uniqueValue: anObjectMemory nativeStackSpills.	self numJITCacheSpills uniqueValue:		([anObjectMemory numCompactNMethods]			on: MessageNotUnderstood  "Supported after VW 7.7 only"			do: [:ex | ex return: 0])</body><body package="MemoryMonitor">updateProcessIterationScavengesWith: anObjectMemory	| numScavenges newNumScavenges oldNumScavenges |	newNumScavenges := anObjectMemory numScavenges.	oldNumScavenges := self scavengesLast value ifNil: [newNumScavenges].	numScavenges := newNumScavenges - oldNumScavenges.	numScavenges &lt; 0 ifTrue:		[numScavenges := numScavenges + (self counterOverflowCorrectionFor: anObjectMemory)].	self graphListSize - self scavengesList size + 1		timesRepeat: [self scavengesList add: numScavenges].	self scavenges uniqueValue: numScavenges.	self scavengesMax uniqueValue: (self scavengesList inject: 0 into: [:largest :each | largest max: each]).	self scavengesLast uniqueValue: newNumScavenges</body><body package="MemoryMonitor">updateProcessIterationSpaceCountsWith: anObjectMemory	"Assume at most 1 perm segment.  Also, assume a fixed count of	1 eden space, 2 survivor semi spaces, and 1 large space"	| newPermSegments |	self fixedSegments uniqueValue: anObjectMemory fixedSegments.	self oldSegments uniqueValue: anObjectMemory oldSegments.	newPermSegments := anObjectMemory permBytes min: 1.	self permSegments uniqueValue: (self permSegments value max: newPermSegments)</body><body package="MemoryMonitor">updateProcessIterationSpaceSizesWith: anObjectMemory	| newTotalMemory newEdenUsedBytes newSurvivorUsedBytes newLargeUsedBytes newFixedUsedBytes newOldUsedBytes newPermUsedBytes |	newEdenUsedBytes := anObjectMemory edenUsedBytes.	self edenUsedBytes uniqueValue: newEdenUsedBytes.	self edenPercentageUsed uniqueValue: newEdenUsedBytes asFloat / (anObjectMemory edenBytes asFloat max: 1.0).	newSurvivorUsedBytes := anObjectMemory survUsedBytes.	self survivorUsedBytes uniqueValue: newSurvivorUsedBytes.	self survivorPercentageUsed uniqueValue: newSurvivorUsedBytes asFloat / (anObjectMemory survBytes asFloat max: 1.0).	newLargeUsedBytes := anObjectMemory largeUsedBytes.	self largeUsedBytes uniqueValue: newLargeUsedBytes.	self largePercentageUsed uniqueValue: newLargeUsedBytes asFloat / (anObjectMemory largeBytes asFloat max: 1.0).	newFixedUsedBytes := anObjectMemory fixedUsedBytes.	self fixedUsedBytes uniqueValue: newFixedUsedBytes.	self fixedPercentageUsed uniqueValue: newFixedUsedBytes asFloat / (anObjectMemory fixedBytes asFloat max: 1.0).	newOldUsedBytes := anObjectMemory oldDataBytes		+ (anObjectMemory otEntriesToBytes: anObjectMemory oldOTEs - anObjectMemory threadedOTEntries)		- anObjectMemory threadedDataBytes.	self oldUsedBytes uniqueValue: newOldUsedBytes.	self oldPercentageUsed uniqueValue: newOldUsedBytes asFloat / (anObjectMemory oldBytes asFloat max: 1.0).	newPermUsedBytes := anObjectMemory permDataBytes + (anObjectMemory otEntriesToBytes: anObjectMemory permOTEs).	self permUsedBytes uniqueValue: newPermUsedBytes.	self permPercentageUsed uniqueValue: newPermUsedBytes asFloat / (anObjectMemory permBytes asFloat max: 1.0).	newTotalMemory := newEdenUsedBytes + newSurvivorUsedBytes + newLargeUsedBytes + newFixedUsedBytes + newOldUsedBytes + newPermUsedBytes.	self graphListSize - self allocatedMemoryList size + 1		timesRepeat: [self allocatedMemoryList add: newTotalMemory].	self allocatedMemoryMax uniqueValue: (self allocatedMemoryList inject: 0 into: [:largest :each | largest max: each]).	self allocatedMemoryMin uniqueValue: newPermUsedBytes.	self allocatedMemory uniqueValue: newTotalMemory</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>private - bounded lists</category><body package="MemoryMonitor">graphListSize	^40</body><body package="MemoryMonitor">newBoundedList	^BoundedList new: self graphListSize</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>events</category><body package="MemoryMonitor">noticeOfWindowClose: aWindow	super noticeOfWindowClose: aWindow.	self terminateMonitoringActivities</body><body package="MemoryMonitor">updateGUIPriority	self builder isNil ifTrue: [^self].	self builder window windowProcess priority: self schedulingPriority value</body><body package="MemoryMonitor">updateSchedulingDelay	self processRatchet isNil ifTrue: [^self].	self processRatchet resume</body><body package="MemoryMonitor">updateSchedulingPriority	self updateGUIPriority.	self process isNil ifTrue: [^self].	self process priority: self schedulingPriority value</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>private - accessing</category><body package="MemoryMonitor">logFilename	^logFilename</body><body package="MemoryMonitor">logFilename: aString	logFilename := aString</body><body package="MemoryMonitor">logMutex	^logMutex</body><body package="MemoryMonitor">logMutex: aSemaphore	logMutex := aSemaphore</body><body package="MemoryMonitor">logToFile	^logToFile ifNil: [false]</body><body package="MemoryMonitor">logToFile: aBoolean	logToFile := aBoolean.	aBoolean ifFalse: [self logFilename: nil]</body><body package="MemoryMonitor">mapActive	^mapActive ifNil: [false]</body><body package="MemoryMonitor">mapActive: aBoolean	mapActive := aBoolean</body><body package="MemoryMonitor">process	^process</body><body package="MemoryMonitor">process: aProcess	process notNil ifTrue: [process terminate].	process := aProcess</body><body package="MemoryMonitor">processRatchet	^processRatchet</body><body package="MemoryMonitor">processRatchet: anObject	processRatchet := anObject</body><body package="MemoryMonitor">scavengesList: anObject	scavengesList := anObject</body><body package="MemoryMonitor">snapshotMutex	^snapshotMutex</body><body package="MemoryMonitor">snapshotMutex: anObject	snapshotMutex := anObject</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>aspects - graphs</category><body package="MemoryMonitor">allocatedMemory	^allocatedMemory isNil		ifTrue: [allocatedMemory := 0 asValue]		ifFalse: [allocatedMemory]</body><body package="MemoryMonitor">allocatedMemoryList	allocatedMemoryList notNil ifTrue: [^allocatedMemoryList].	allocatedMemoryList := self newBoundedList.	^allocatedMemoryList</body><body package="MemoryMonitor">allocatedMemoryMax	^allocatedMemoryMax isNil 		ifTrue: [allocatedMemoryMax := 0 asValue]		ifFalse: [allocatedMemoryMax]</body><body package="MemoryMonitor">allocatedMemoryMin	| om |	allocatedMemoryMin notNil ifTrue: [^allocatedMemoryMin].	om := self objectMemoryInstance.	allocatedMemoryMin := (om permDataBytes + (om otEntriesToBytes: om permOTEs)) asValue.	^allocatedMemoryMin</body><body package="MemoryMonitor">scavenges	^scavenges isNil		ifTrue: [scavenges := 0 asValue]		ifFalse: [scavenges]</body><body package="MemoryMonitor">scavengesLast	^scavengesLast isNil		ifTrue: [scavengesLast := nil asValue]		ifFalse: [scavengesLast]</body><body package="MemoryMonitor">scavengesList	scavengesList notNil ifTrue: [^scavengesList].	scavengesList := self newBoundedList.	^scavengesList</body><body package="MemoryMonitor">scavengesMax	^scavengesMax isNil 		ifTrue: [scavengesMax := 0 asValue]		ifFalse: [scavengesMax]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>process</category><body package="MemoryMonitor">defaultSchedulingPriority	^self class defaultSchedulingPriority</body><body package="MemoryMonitor">monitoringProcess	[		self snapshotMutex critical:			[				self doOrQueueEventFor:					[						self updateProcessIteration.						self dumpStatusToFile					]			].		self processRatchet: (Delay forSeconds: self schedulingDelay value).		self processRatchet wait	] repeat</body><body package="MemoryMonitor">startMonitoringActivities	| newProcess |	newProcess := [self monitoringProcess] newProcess.	newProcess isSystemProcess: true.	newProcess name: 'MemoryMonitor update process'.	newProcess priority: self schedulingPriority value.	newProcess resume.	self process: newProcess</body><body package="MemoryMonitor">terminateMonitoringActivities	self process notNil ifTrue: [self process terminate]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>aspects - igc</category><body package="MemoryMonitor">igcAbortedCount	^igcAbortedCount isNil		ifTrue: [igcAbortedCount := 0 asValue]		ifFalse: [igcAbortedCount]</body><body package="MemoryMonitor">igcCount	^igcCount isNil		ifTrue: [igcCount := 0 asValue]		ifFalse: [igcCount]</body><body package="MemoryMonitor">igcMarkStackOverflows	^igcMarkStackOverflows isNil		ifTrue: [igcMarkStackOverflows := 0 asValue]		ifFalse: [igcMarkStackOverflows]</body><body package="MemoryMonitor">igcMarkedBytes	^igcMarkedBytes isNil		ifTrue: [igcMarkedBytes := 0 asValue]		ifFalse: [igcMarkedBytes]</body><body package="MemoryMonitor">igcMarkedObjects	^igcMarkedObjects isNil		ifTrue: [igcMarkedObjects := 0 asValue]		ifFalse: [igcMarkedObjects]</body><body package="MemoryMonitor">igcMarkedWeakBytes	^igcMarkedWeakBytes isNil		ifTrue: [igcMarkedWeakBytes := 0 asValue]		ifFalse: [igcMarkedWeakBytes]</body><body package="MemoryMonitor">igcMarkedWeakObjects	^igcMarkedWeakObjects isNil		ifTrue: [igcMarkedWeakObjects := 0 asValue]		ifFalse: [igcMarkedWeakObjects]</body><body package="MemoryMonitor">igcNilledBytes	^igcNilledBytes isNil		ifTrue: [igcNilledBytes := 0 asValue]		ifFalse: [igcNilledBytes]</body><body package="MemoryMonitor">igcNilledObjects	^igcNilledObjects isNil		ifTrue: [igcNilledObjects := 0 asValue]		ifFalse: [igcNilledObjects]</body><body package="MemoryMonitor">igcReclaimedBytes	^igcReclaimedBytes isNil		ifTrue: [igcReclaimedBytes := 0 asValue]		ifFalse: [igcReclaimedBytes]</body><body package="MemoryMonitor">igcReclaimedObjects	^igcReclaimedObjects isNil		ifTrue: [igcReclaimedObjects := 0 asValue]		ifFalse: [igcReclaimedObjects]</body><body package="MemoryMonitor">igcState	^igcState isNil		ifTrue: [igcState := '&lt;no state&gt;' asValue]		ifFalse: [igcState]</body><body package="MemoryMonitor">igcSweepAllocatedBytes	^igcSweepAllocatedBytes isNil		ifTrue: [igcSweepAllocatedBytes := 0 asValue]		ifFalse: [igcSweepAllocatedBytes]</body><body package="MemoryMonitor">igcSweepAllocatedObjects	^igcSweepAllocatedObjects isNil		ifTrue: [igcSweepAllocatedObjects := 0 asValue]		ifFalse: [igcSweepAllocatedObjects]</body><body package="MemoryMonitor">igcSweptObjects	^igcSweptObjects isNil		ifTrue: [igcSweptObjects := 0 asValue]		ifFalse: [igcSweptObjects]</body><body package="MemoryMonitor">igcUnmarkedObjects	^igcUnmarkedObjects isNil		ifTrue: [igcUnmarkedObjects := 0 asValue]		ifFalse: [igcUnmarkedObjects]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>private</category><body package="MemoryMonitor">doOrQueueEventFor: aBlock	self builder isNil		ifTrue: [aBlock value]		ifFalse: [aBlock uiEventFor: self builder window]</body><body package="MemoryMonitor">imageReturnedFromSnapshot	self snapshotMutex critical:		[			self doOrQueueEventFor:				[					self scavengesList size timesRepeat: [self scavengesList add: 0].					self scavengesLast uniqueValue: nil.					self scavengesMax uniqueValue: 0				]		]</body><body package="MemoryMonitor">initialize	super initialize.	self logMutex: Semaphore forMutualExclusion.	self snapshotMutex: Semaphore forMutualExclusion</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>private - object memory</category><body package="MemoryMonitor">counterOverflowCorrectionFor: anObjectMemory	^anObjectMemory class is64Bit		ifTrue: [1 bitShift: 64]		ifFalse: [1 bitShift: 32]</body><body package="MemoryMonitor">objectMemory	^ObjectMemory</body><body package="MemoryMonitor">objectMemoryInstance	^self objectMemory current</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>actions</category><body package="MemoryMonitor">flushNewSpaceButton	&lt;primitive: 322&gt;	^self</body><body package="MemoryMonitor">garbageCollectButton	self objectMemory garbageCollect</body><body package="MemoryMonitor">globalGarbageCollectButton	self objectMemory globalGarbageCollect</body><body package="MemoryMonitor">incrementalGarbageCollectButton	self objectMemory quickGC</body><body package="MemoryMonitor">multiAllocationProfilerButton	| map |	map := #{MultiAllocationProfiler} valueOrDo: [nil].	map isNil ifTrue: [^self].	self mapActive		ifTrue: [map stopProfiling]		ifFalse: [map startProfiling].	self mapActive: self mapActive not</body><body package="MemoryMonitor">toggleLogButton	self logMutex critical: [self logToFile: self logToFile not]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>aspects - space sizes</category><body package="MemoryMonitor">edenUsedBytes	^edenUsedBytes isNil		ifTrue: [edenUsedBytes := 0 asValue]		ifFalse: [edenUsedBytes]</body><body package="MemoryMonitor">fixedUsedBytes	^fixedUsedBytes isNil		ifTrue: [fixedUsedBytes := 0 asValue]		ifFalse: [fixedUsedBytes]</body><body package="MemoryMonitor">largeUsedBytes	^largeUsedBytes isNil		ifTrue: [largeUsedBytes := 0 asValue]		ifFalse: [largeUsedBytes]</body><body package="MemoryMonitor">oldUsedBytes	^oldUsedBytes isNil		ifTrue: [oldUsedBytes := 0 asValue]		ifFalse: [oldUsedBytes]</body><body package="MemoryMonitor">permUsedBytes	^permUsedBytes isNil		ifTrue: [permUsedBytes := 0 asValue]		ifFalse: [permUsedBytes]</body><body package="MemoryMonitor">survivorUsedBytes	^survivorUsedBytes isNil		ifTrue: [survivorUsedBytes := 0 asValue]		ifFalse: [survivorUsedBytes]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>aspects</category><body package="MemoryMonitor">gcCount	^gcCount isNil		ifTrue: [gcCount := 0 asValue]		ifFalse: [gcCount]</body><body package="MemoryMonitor">ggcCount	^ggcCount isNil		ifTrue: [ggcCount := 0 asValue]		ifFalse: [ggcCount]</body><body package="MemoryMonitor">markStackOverflows	^markStackOverflows isNil		ifTrue: [markStackOverflows := 0 asValue]		ifFalse: [markStackOverflows]</body><body package="MemoryMonitor">numJITCacheSpills	^numJITCacheSpills isNil		ifTrue: [numJITCacheSpills := 0 asValue]		ifFalse: [numJITCacheSpills]</body><body package="MemoryMonitor">stackSpills	^stackSpills isNil		ifTrue: [stackSpills := 0 asValue]		ifFalse: [stackSpills]</body><body package="MemoryMonitor">weakListOverflows	^weakListOverflows isNil		ifTrue: [weakListOverflows := 0 asValue]		ifFalse: [weakListOverflows]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>aspects - space counts</category><body package="MemoryMonitor">edenSegments	^edenSegments isNil		ifTrue: [edenSegments := 1 asValue]		ifFalse: [edenSegments]</body><body package="MemoryMonitor">fixedSegments	^fixedSegments isNil		ifTrue: [fixedSegments := 1 asValue]		ifFalse: [fixedSegments]</body><body package="MemoryMonitor">largeSegments	^largeSegments isNil		ifTrue: [largeSegments := 1 asValue]		ifFalse: [largeSegments]</body><body package="MemoryMonitor">oldSegments	^oldSegments isNil		ifTrue: [oldSegments := 1 asValue]		ifFalse: [oldSegments]</body><body package="MemoryMonitor">permSegments	^permSegments isNil		ifTrue: [permSegments := 0 asValue]		ifFalse: [permSegments]</body><body package="MemoryMonitor">survivorSegments	^survivorSegments isNil		ifTrue: [survivorSegments := 2 asValue]		ifFalse: [survivorSegments]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>logging</category><body package="MemoryMonitor">basicDumpCSVColumnsToFile	self logFileStreamDo:		[:log |			log nextPutAll: self timestampLogString; space.			#('Time' 'Eden' 'Eden %' 'Survivor' 'Survivor %'				'Large' 'Large %' 'Perm' 'Perm %'				'Fixed segments' 'Fixed' 'Fixed %'				'Old segments' 'Old' 'Old %'				'Scavenges' 'IGC state' 'IGCs' 'GCs' 'GGCs'				'Stack spills' 'Mark stack spills' 'Weak list spills'				'IGC mark stack spills' 'IGC mark aborts'				)					do: [:each | log nextPutAll: each]					separatedBy: [log nextPut: $,].			log cr		]</body><body package="MemoryMonitor">basicDumpCSVStatusToFile	self logFileStreamDo:		[:log |			log				nextPutAll: self timestampLogString; nextPut: $,;				print: self edenUsedBytes value; nextPut: $,;				print: self edenPercentageUsed value * 100.0; nextPut: $,;				print: self survivorUsedBytes value; nextPut: $,;				print: self survivorPercentageUsed value * 100.0; nextPut: $,;				print: self largeUsedBytes value; nextPut: $,;				print: self largePercentageUsed value * 100.0; nextPut: $,;				print: self permUsedBytes value; nextPut: $,;				print: self permPercentageUsed value * 100.0; nextPut: $,;				print: self fixedSegments value; nextPut: $,;				print: self fixedUsedBytes value; nextPut: $,;				print: self fixedPercentageUsed value * 100.0; nextPut: $,;				print: self oldSegments value; nextPut: $,;				print: self oldUsedBytes value; nextPut: $,;				print: self oldPercentageUsed value * 100.0; nextPut: $,;				print: self scavengesLast value; nextPut: $,;				nextPutAll: self igcState value; nextPut: $,;				print: self igcCount value; nextPut: $,;				print: self gcCount value; nextPut: $,;				print: self ggcCount value; nextPut: $,;				print: self stackSpills value; nextPut: $,;				print: self markStackOverflows value; nextPut: $,;				print: self weakListOverflows value; nextPut: $,;				print: self igcMarkStackOverflows value; nextPut: $,;				print: self igcAbortedCount value;				cr		]</body><body package="MemoryMonitor">basicDumpStatusToFile	self useCSVLog		ifTrue: [self basicDumpCSVStatusToFile]		ifFalse: [self basicDumpVerboseStatusToFile]</body><body package="MemoryMonitor">basicDumpVerboseStatusToFile	self logFileStreamDo:		[:log |			log print: Time now; cr.			log				nextPutAll: 'Eden: ';				print: self edenUsedBytes value;				nextPutAll: ', ';				print: (self edenPercentageUsed value * 100.0) rounded;				nextPut: $%;				tab;				nextPutAll: 'survivor: ';				print: self survivorUsedBytes value;				nextPutAll: ', ';				print: (self survivorPercentageUsed value * 100.0) rounded;				nextPut: $%;				tab;				nextPutAll: 'large: ';				print: self largeUsedBytes value;				nextPutAll: ', ';				print: (self largePercentageUsed value * 100.0) rounded;				nextPut: $%;				cr.			log				nextPutAll: 'Perm: ';				print: self permUsedBytes value;				nextPutAll: ', ';				print: (self permPercentageUsed value * 100.0) rounded;				nextPut: $%;				tab;				nextPutAll: 'fixed(';				print: self fixedSegments value;				nextPutAll: '): ';				print: self fixedUsedBytes value;				nextPutAll: ', ';				print: (self fixedPercentageUsed value * 100.0) rounded;				nextPut: $%;				tab;				nextPutAll: 'old(';				print: self oldSegments value;				nextPutAll: '): ';				print: self oldUsedBytes value;				nextPutAll: ', ';				print: (self oldPercentageUsed value * 100.0) rounded;				nextPut: $%;				cr.			log				nextPutAll: 'IGC: ';				nextPutAll: self igcState value;				tab;				nextPutAll: 'Scavenges: ';				print: self scavengesLast value;				tab;				nextPutAll: 'Stack spills: ';				print: self stackSpills value;				cr.			log				nextPutAll: 'IGCs: ';				print: self igcCount value;				tab;				nextPutAll: 'GCs: ';				print: self gcCount value;				tab;				nextPutAll: 'GGCs: ';				print: self ggcCount value;				cr.			log cr		]</body><body package="MemoryMonitor">dumpStatusToFile	self logMutex critical:		[			self logToFile ifFalse: [^self].			self logFilename isNil ifTrue: [self startLogFile].			self basicDumpStatusToFile		]</body><body package="MemoryMonitor">logFileStreamDo: aBlock	| log |	log := self logFilename asFilename appendStream.	[aBlock value: log] ensure: [log close]</body><body package="MemoryMonitor">startLogFile	| filenameBase filenameExtension |	filenameBase := 'memoryMonitor', Timestamp now asSeconds printString.	filenameExtension := self useCSVLog ifTrue: ['.csv'] ifFalse: ['.log'].	self logFilename: filenameBase, filenameExtension.	self useCSVLog ifTrue: [self basicDumpCSVColumnsToFile]</body><body package="MemoryMonitor">useCSVLog	"Use ^false for a verbose log"	^true</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>aspects - scheduling</category><body package="MemoryMonitor">schedulingDelay	schedulingDelay notNil ifTrue: [^schedulingDelay].	schedulingDelay := 0.75 asValue.	schedulingDelay onChangeSend: #updateSchedulingDelay to: self.	^schedulingDelay</body><body package="MemoryMonitor">schedulingPriority	schedulingPriority notNil ifTrue: [^schedulingPriority].	schedulingPriority := self defaultSchedulingPriority asValue.	schedulingPriority onChangeSend: #updateSchedulingPriority to: self.	^schedulingPriority</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>private - logging</category><body package="MemoryMonitor">timestampLogString	^TimestampPrintPolicy		print: self timestampNow		using: 'yyyy-mm-dd hh:mm:ss.ffff'</body><body package="MemoryMonitor">timestampNow	"Use a compatibility check for images that do not implement #nowUTC"	| answer |	(Timestamp respondsTo: #nowUTC) ifTrue: [^Timestamp nowUTC].	answer := Timestamp zero addMilliseconds: Time millisecondClockValue.	answer year: answer year + 1901.	^answer</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor</class-id> <category>interface opening</category><body package="MemoryMonitor">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self updateGUIPriority.	self startMonitoringActivities</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor class</class-id> <category>private - process</category><body package="MemoryMonitor">defaultSchedulingPriority	^Processor userInterruptPriority + 1</body><body package="MemoryMonitor">imageReturnedFromSnapshot	self allInstances do: [:each | each imageReturnedFromSnapshot]</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor class</class-id> <category>instance creation</category><body package="MemoryMonitor">runHeadless	^self runHeadlessAtPriority: self defaultSchedulingPriority</body><body package="MemoryMonitor">runHeadlessAtPriority: anInteger	| answer |	answer := self new.	answer logToFile: true.	answer schedulingPriority value: anInteger.	answer startMonitoringActivities.	^answer</body></methods><methods><class-id>UI.ValueHolder</class-id> <category>accessing</category><body package="MemoryMonitor">uniqueValue: aValue	"Only change the value if aValue is different"	self value = aValue ifTrue: [^self].	self value: aValue</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec class</class-id> <category>interface specs</category><body package="MemoryMonitor">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 243 ) 			#max: #(#{Core.Point} 300 243 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1100 843 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: 'Graph Widget' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 55 0 0 1 ) 					#label: 'Aspect:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 87 0 0 1 ) 					#label: 'ID:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 28 0 -10 1 53 0 ) 					#model: #model 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 60 0 -10 1 85 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 96 0 -5 1 179 0 ) 					#label: 'Max' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 113 0 -10 1 138 0 ) 					#name: #maxModel 					#model: #maxModel 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 148 ) 					#name: #fixedMin 					#model: #maxType 					#label: 'Fixed:' 					#select: #fixedUsedBytes ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.75 146 0 0.5 0 ) 					#model: #maxType 					#label: 'Dynamic' 					#select: #dynamic ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 144 0 0 0.5 169 0 ) 					#model: #maxFixedNumber 					#menu: #fieldMenu 					#alignment: #right 					#type: #number ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 115 ) 					#model: #maxType 					#label: 'Model:' 					#select: #model ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 189 0 -5 1 267 0 ) 					#label: 'Min' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 207 ) 					#model: #minType 					#label: 'Model:' 					#select: #model ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 205 0 -10 1 230 0 ) 					#name: #minModel 					#model: #minModel 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 240 ) 					#name: #fixedMin 					#model: #minType 					#label: 'Fixed:' 					#select: #fixedUsedBytes ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.75 238 0 0.5 0 ) 					#model: #minType 					#label: 'Dynamic' 					#select: #dynamic ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 236 0 0 0.5 261 0 ) 					#model: #minFixedNumber 					#menu: #fieldMenu 					#alignment: #right 					#type: #number ) ) ) )</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec class</class-id> <category>resources</category><body package="MemoryMonitor">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: ColorValue blue; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 3693 scaledGreen: 3693 scaledBlue: 3693); at: 5 put: (ColorValue scaledRed: 6617 scaledGreen: 6617 scaledBlue: 6617); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@H"H"H"H"H"H"H"H#@@@@@BQDQDQDQDQDQDQDP0@@@@@$QDQDQDQDQDQDQDL@@@@@IDQDQDQDQDQDQDQC@@@@@BQDQDQDQDQDQDQDP0@@@@@$QDQDQDQDQDQDQDL@@@@@IDP@@@@@@@@@@DQC@@@@@BQDADQDQDQDQDIDP0@@@@@$Q@QDPTQDQDQBQDL@@@@@IDPDQADTEDQDP$QC@@@@@BQDADDQDQEDPTIDP0@@@@@$Q@PQDQDQEADRQDL@@@@@IDPADQDQDQDQD$QC@@@@@BQD@QDQDQDQDQIDP0@@@@@$Q@DQDQDQDQDRQDL@@@@@IDP"H"H"H"H"H$QC@@@@@BQDQDQDQDQDQDQDP0@@@@@$QDQDQDQDQDQDQDL@@@@@IDQDQDQDQDQDQDQC@@@@@BQDQDQDQDQDQDQDP0@@@@@$QDQDQDQDQDQDQDL@@@@@IDQDQDQDQDQDQDQC@@@@@BQDQDQDQDQDQDQDP0@@@@@3L3L3L3L3L3L3L3L@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="MemoryMonitor">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 3693 scaledGreen: 3693 scaledBlue: 3693); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@UUUUUUUV@@AUUUUUUUX@@EUUUUUUU @@UUUUUUUV@@AUUUUUUUX@@EUUUUUUU @@UP@@@@AV@@AUEUUUUEX@@ETUQUUTU @@UQTAEUQV@@AUE@@EQEX@@ETP@@D@U @@UP@@@@AV@@AU@@@@@EX@@ET@@@@@U @@UP@@@@AV@@AUUUUUUUX@@EUUUUUUU @@UUUUUUUV@@AUUUUUUUX@@EUUUUUUU @@UUUUUUUV@@AUUUUUUUX@@J******* @@@@@@@@@@@@@@a'))</body></methods><methods><class-id>Refactory.MemoryMonitorNamespace.MemoryMonitor class</class-id> <category>interface specs</category><body package="MemoryMonitor">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Memory Monitor' 			#min: #(#{Core.Point} 695 646 ) 			#max: #(#{Core.Point} 1024 646 ) 			#bounds: #(#{Graphics.Rectangle} 464 164 1159 810 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 30 0 -150 0.5 51 0 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #edenPercentageUsed 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 55 0 -150 0.5 76 0 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #survivorPercentageUsed 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 80 0 -150 0.5 101 0 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #oldPercentageUsed 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.5 0 0 1 0.5 115 0 ) 					#name: #Divider1 					#orientation: #vertical ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0.5 30 0 -150 1 51 0 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #largePercentageUsed 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0.5 55 0 -150 1 76 0 ) 					#name: #PercentDoneBar1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #fixedPercentageUsed 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0.5 80 0 -150 1 101 0 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #permPercentageUsed 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 115 0 0 1 117 0 ) 					#name: #Divider2 ) 				#(#{Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 150 0 -5 1 200 0 ) 					#name: #scavengesList 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) 						#setSelectionForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #scavengesList 					#maxFixedNumber: 0 					#minFixedNumber: 0 					#maxModel: #scavengesMax 					#maxType: #model 					#minType: #fixedUsedBytes ) 				#(#{Refactory.MemoryMonitorNamespace.AreaGraphWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 240 0 -5 1 290 0 ) 					#name: #allocatedMemoryList 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #blue ) 						#setSelectionForegroundColor: #(#{Graphics.ColorValue} #blue ) ) 					#model: #allocatedMemoryList 					#maxFixedNumber: 0 					#minFixedNumber: 0 					#minModel: #allocatedMemoryMin 					#maxModel: #allocatedMemoryMax 					#maxType: #model 					#minType: #model ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 298 0 0 1 300 0 ) 					#name: #Divider3 ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -170 1 300 0 -168 1 0 1.0 ) 					#name: #Divider4 					#orientation: #vertical ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -115 1 -170 1 -113 1 ) 					#name: #Divider5 ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 340 0 -170 1 342 0 ) 					#name: #Divider6 ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#label: 'IGC state:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 0 245 24 ) 							#name: #igcState 							#flags: 0 							#model: #igcState 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #string ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 0 ) 							#name: #Label25 							#label: 'IGCs:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 0 515 24 ) 							#name: #InputField25 							#flags: 0 							#model: #igcCount 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 25 515 49 ) 							#name: #InputField19 							#flags: 0 							#model: #igcMarkedObjects 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 25 ) 							#name: #Label19 							#label: 'Marked objects:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 25 245 49 ) 							#name: #InputField13 							#flags: 0 							#model: #igcMarkedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 25 ) 							#name: #Label13 							#label: 'Marked bytes:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 50 ) 							#name: #Label14 							#label: 'Marked weak bytes:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 50 245 74 ) 							#name: #InputField14 							#flags: 0 							#model: #igcMarkedWeakBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 50 ) 							#name: #Label20 							#label: 'Marked weak objects:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 50 515 74 ) 							#name: #InputField20 							#flags: 0 							#model: #igcMarkedWeakObjects 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 75 515 99 ) 							#name: #InputField21 							#flags: 0 							#model: #igcNilledObjects 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 75 ) 							#name: #Label21 							#label: 'Nilled objects:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 75 245 99 ) 							#name: #InputField16 							#flags: 0 							#model: #igcNilledBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 75 ) 							#name: #Label16 							#label: 'Nilled bytes:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 100 ) 							#name: #Label15 							#label: 'Reclaimed bytes:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 100 245 124 ) 							#name: #InputField15 							#flags: 0 							#model: #igcReclaimedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 100 ) 							#name: #Label22 							#label: 'Reclaimed objects:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 100 515 124 ) 							#name: #InputField22 							#flags: 0 							#model: #igcReclaimedObjects 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 125 515 149 ) 							#name: #InputField24 							#flags: 0 							#model: #igcUnmarkedObjects 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 125 ) 							#name: #Label24 							#label: 'Unmarked objects:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 125 245 149 ) 							#name: #InputField18 							#flags: 0 							#model: #igcSweptObjects 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 125 ) 							#name: #Label18 							#label: 'Swept objects:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 150 ) 							#name: #Label17 							#label: 'Sweep alloc. bytes:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 150 245 174 ) 							#name: #InputField17 							#flags: 0 							#model: #igcSweepAllocatedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 150 ) 							#name: #Label23 							#label: 'Sweep alloc. objects:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 150 515 174 ) 							#name: #InputField23 							#flags: 0 							#model: #igcSweepAllocatedObjects 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 5 350 520 524 ) 						#name: #igcStats ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #Label3 							#label: 'Bytes used' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.694444 0 0 ) 							#name: #Label4 							#label: 'Segs' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0694444 25 0 0 0.694444 50 0 ) 							#flags: 0 							#model: #edenUsedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.763889 25 0 0 1.0 50 0 ) 							#name: #InputField2 							#flags: 0 							#model: #edenSegments 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0694444 50 0 0 0.694444 75 0 ) 							#flags: 0 							#model: #survivorUsedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.763889 50 0 0 1.0 75 0 ) 							#name: #InputField3 							#flags: 0 							#model: #survivorSegments 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0694444 75 0 0 0.694444 100 0 ) 							#flags: 0 							#model: #oldUsedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.763889 75 0 0 1.0 100 0 ) 							#name: #InputField4 							#flags: 0 							#model: #oldSegments 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 198 5 342 105 ) 						#name: #Composite1 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #Label6 							#label: 'Bytes used' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.689655 0 0 ) 							#name: #Label7 							#label: 'Segs' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0689655 25 0 0 0.689655 50 0 ) 							#flags: 0 							#model: #largeUsedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.758621 25 0 0 1.0 50 0 ) 							#name: #InputField5 							#flags: 0 							#model: #largeSegments 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0689655 50 0 0 0.689655 75 0 ) 							#name: #InputField1 							#flags: 0 							#model: #fixedUsedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.758621 50 0 0 1.0 75 0 ) 							#name: #InputField6 							#flags: 0 							#model: #fixedSegments 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.758621 75 0 0 1.0 100 0 ) 							#name: #InputField7 							#flags: 0 							#model: #permSegments 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0689655 75 0 0 0.689655 100 0 ) 							#flags: 0 							#model: #permUsedBytes 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 545 5 690 105 ) 						#name: #Composite2 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #Label2 							#label: 'Space' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 25 ) 							#label: 'Eden' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 50 ) 							#label: 'Survivor' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 75 ) 							#label: 'Old' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 5 5 56 104 ) 						#name: #Composite3 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #Label5 							#label: 'Space' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 25 0 ) 							#label: 'Large' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 50 0 ) 							#name: #Label1 							#label: 'Fixed' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 75 0 ) 							#label: 'Perm' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 353 5 392 104 ) 						#name: #Composite4 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.854015 0 0 0 1.0 24 0 ) 							#name: #InputField9 							#flags: 0 							#model: #scavengesMax 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.788321 0 0 ) 							#name: #Label9 							#label: 'peak:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.573723 0 0 0 0.719708 24 0 ) 							#name: #InputField8 							#flags: 0 							#model: #scavenges 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.508029 0 0 ) 							#name: #Label8 							#label: 'last:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 105 0 205 24 ) 							#flags: 0 							#model: #scavengesLast 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#label: 'Scavenges:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 5 120 690 144 ) 						#name: #Composite5 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#label: 'Used memory:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 105 0 205 24 ) 							#flags: 0 							#model: #allocatedMemory 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.508029 0 0 ) 							#name: #Label10 							#label: 'min:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.573723 0 0 0 0.719708 24 0 ) 							#name: #InputField10 							#flags: 0 							#model: #allocatedMemoryMin 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.788321 0 0 ) 							#name: #Label11 							#label: 'peak:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.854015 0 0 0 1.0 24 0 ) 							#name: #InputField11 							#flags: 0 							#model: #allocatedMemoryMax 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 5 210 690 234 ) 						#name: #Composite6 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #Label26 							#label: 'GCs:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 145 0 245 24 ) 							#name: #InputField26 							#flags: 0 							#model: #gcCount 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 270 0 ) 							#name: #Label27 							#label: 'GCCs:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 0 515 24 ) 							#name: #InputField27 							#flags: 0 							#model: #ggcCount 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 5 310 520 334 ) 						#name: #Composite7 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #Label12 							#label: 'Stack spills:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 145 0 0 0 245 0 0 0.242424 ) 							#name: #InputField12 							#flags: 0 							#model: #stackSpills 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 270 0 0 0 ) 							#name: #Label30 							#label: 'JIT cache spills:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 0 515 24 ) 							#name: #InputField30 							#flags: 0 							#model: #numJITCacheSpills 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 415 25 515 49 ) 							#name: #InputField31 							#flags: 0 							#model: #igcAbortedCount 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 270 0 0 0.252525 ) 							#name: #Label31 							#label: 'IGC mark aborts:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 145 0 0 0.252525 245 0 0 0.494949 ) 							#name: #InputField32 							#flags: 0 							#model: #igcMarkStackOverflows 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0.252525 ) 							#name: #Label32 							#label: 'IGC stack overflows:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0.50505 ) 							#name: #Label28 							#label: 'Mark stack overflows:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 145 0 0 0.50505 245 0 0 0.747475 ) 							#name: #InputField28 							#flags: 0 							#model: #markStackOverflows 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0.757576 ) 							#name: #Label29 							#label: 'Weak list overflows:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 145 0 0 0.757576 245 0 0 1.0 ) 							#name: #InputField29 							#flags: 0 							#model: #weakListOverflows 							#tabable: false 							#alignment: #right 							#isReadOnly: true 							#type: #number 							#formatString: '#,##0' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 5 541 520 640 ) 						#name: #Composite8 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 40 0 0 0 1 0 ) 							#label: 'Delay:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 1.0 0 0 1 0 ) 							#label: 'Priority:' ) 						#(#{UI.SliderSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0416667 30 0 0 0.291667 0 0.89426 ) 							#model: #schedulingDelay 							#orientation: #vertical 							#start: 0.0625 							#stop: 10 							#step: 0.0625 ) 						#(#{UI.SliderSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.666667 30 0 0 0.916667 0 0.89426 ) 							#model: #schedulingPriority 							#orientation: #vertical 							#start: 1 							#stop: 89 							#step: 1 ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0416667 0 0.924471 0 0.291667 0 1.0 ) 							#flags: 0 							#model: #schedulingDelay 							#tabable: false 							#alignment: #center 							#isReadOnly: true 							#type: #number ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.666667 0 0.924471 0 0.916667 0 1.0 ) 							#flags: 0 							#model: #schedulingPriority 							#tabable: false 							#alignment: #center 							#isReadOnly: true 							#type: #number ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 554 310 674 641 ) 						#name: #Composite9 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 35 0 0 1.0 ) 							#name: #ActionButton1 							#model: #incrementalGarbageCollectButton 							#label: 'IGC' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 40 0 0 0 75 0 0 1.0 ) 							#name: #ActionButton2 							#model: #garbageCollectButton 							#label: 'GC' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 80 0 0 0 115 0 0 1.0 ) 							#name: #ActionButton3 							#model: #globalGarbageCollectButton 							#label: 'GGC' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 120 0 0 0 155 0 0 1.0 ) 							#name: #ActionButton4 							#model: #flushNewSpaceButton 							#label: 'FNS' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 160 0 0 0 195 0 0 1.0 ) 							#name: #ActionButton5 							#model: #multiAllocationProfilerButton 							#label: 'MAP' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.857143 0 0 0 1.0 0 1.0 ) 							#name: #ActionButton6 							#model: #toggleLogButton 							#label: 'Log' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 275 616 520 640 ) 						#name: #Composite10 ) ) ) ) )</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="MemoryMonitor">notifyMemoryMonitor	&lt;triggerAtSystemEvent: #returnFromSnapshot&gt;	Refactory.MemoryMonitorNamespace.MemoryMonitor imageReturnedFromSnapshot</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>As yet unclassified</category><body package="MemoryMonitor">openMemoryMonitor	&lt;menuItem: 'Memory Monitor'		nameKey: nil		menu: #(#menuBar #tools)		position: 30.00&gt;	Refactory.MemoryMonitorNamespace.MemoryMonitor open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>WidgetSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model callbacksSpec tabable helpText helpField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>DependentPart</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>