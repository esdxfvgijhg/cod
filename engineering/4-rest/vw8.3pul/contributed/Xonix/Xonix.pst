<?xml version="1.0"?><st-source><!-- Name: XonixComment: Xonix, a VisualWorks remake of the arcade/early PC classic.Vassili Bykov, 2001DbIdentifier: bear73DbTrace: 443674DbUsername: kgreekDbVersion: 8.0 - 1PackageName: XonixParcel: #('Xonix')ParcelName: XonixPrintStringCache: (8.0 - 1,kgreek)Version: 8.0 - 1Date: 10:03:13 AM August 1, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (aug14.1) of August 1, 2014 on August 1, 2014 at 10:03:13 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>XonixController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>XonixObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>world </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>Cell</name><environment>Smalltalk</environment><super>XonixObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>XonixView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellSize overlay </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>TrialCell</name><environment>Smalltalk</environment><super>Cell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>futureReplacement </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>Critter</name><environment>Smalltalk</environment><super>XonixObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>location picture </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>Hero</name><environment>Smalltalk</environment><super>Critter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>direction inTheOpen trailCellLocations happyFace scaredFace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>NoSoundPlayer</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>BouncingCritter</name><environment>Smalltalk</environment><super>Critter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>direction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>OuterBouncingCritter</name><environment>Smalltalk</environment><super>BouncingCritter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>heroTrampled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>EmptyCell</name><environment>Smalltalk</environment><super>Cell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>Win32SoundPlayer</name><environment>Smalltalk</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gameOverPath gotchaPath grabPath introPath levelStartPath levelWinPath </inst-vars><class-inst-vars></class-inst-vars><imports>			private Win32SoundPlayerDictionary.*			</imports><category>VB-Xonix</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>winmm.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Xonix</package></attributes></class><class><name>HeroNukedNotification</name><environment>Smalltalk</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>TrailCell</name><environment>Smalltalk</environment><super>Cell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>XonixWorld</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>soundPlayer random width height empty solid hero badGuys takenOverCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>CritterStuckError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>Xonix</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xonixView heartbeat mutex levelHolder takenOverHolder livesHolder scoreHolder levelSwitchCountdown timeoutAction state paused baseScore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><class><name>SolidCell</name><environment>Smalltalk</environment><super>Cell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Xonix</category><attributes><package>Xonix</package></attributes></class><shared-variable><name>Win32SoundPlayerDictionary</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Xonix</package></attributes></shared-variable><shared-variable><name>HighScores</name><environment>Xonix</environment><private>false</private><constant>false</constant><category>scores</category><initializer>OrderedCollection new</initializer><attributes><package>Xonix</package></attributes></shared-variable><methods><class-id>XonixController</class-id> <category>accessing</category><body package="Xonix">desiresFocus	^true</body></methods><methods><class-id>XonixController</class-id> <category>private</category><body package="Xonix">directionKeys	^#(Left Right Up Down)</body></methods><methods><class-id>XonixController</class-id> <category>events</category><body package="Xonix">keyPressedEvent: anEvent	| key |	key := anEvent keyValue.	(self directionKeys includes: key)		ifTrue: [model startMovingHero: key]</body><body package="Xonix">keyReleasedEvent: anEvent	| key |	key := anEvent keyValue.	(self directionKeys includes: key)		ifTrue: [model stopMovingHero: key]</body></methods><methods><class-id>XonixObject</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	world := aXonixWorld</body></methods><methods><class-id>XonixObject class</class-id> <category>instance creation</category><body package="Xonix">in: aXonixWorld	^self new 		initializeWorld: aXonixWorld</body></methods><methods><class-id>Cell</class-id> <category>accessing</category><body package="Xonix">asNormal	"Some cells only exist temporarily, such as trail cells.	The answer of this is always the most appropriate non-temporary	cell to replace the receiver."	^self</body><body package="Xonix">asTrail	^self</body><body package="Xonix">color	^color</body><body package="Xonix">color: aColorValue	color := aColorValue</body></methods><methods><class-id>Cell</class-id> <category>running</category><body package="Xonix">badGuyArrived	"So what?"</body><body package="Xonix">heroArrived	"So what?"</body></methods><methods><class-id>Cell</class-id> <category>displaying</category><body package="Xonix">displayOn: aGraphicsContext inside: boundsRectangle	aGraphicsContext		paint: color;		displayRectangle: boundsRectangle</body></methods><methods><class-id>Cell</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aWorld	super initializeWorld: aWorld.	color := ColorValue black</body></methods><methods><class-id>Cell</class-id> <category>testing</category><body package="Xonix">isFillable	^false</body><body package="Xonix">isSolid	^false</body><body package="Xonix">isTrailCell	^false</body></methods><methods><class-id>XonixView</class-id> <category>private</category><body package="Xonix">boundsOfCellX: xInteger y: yInteger	| left top |	left := xInteger - 1 * cellSize.	top := yInteger - 1 * cellSize.	^left @ top extent: cellSize @ cellSize</body><body package="Xonix">cellBoundsOf: displayRectangle	| left top right bottom |	left := displayRectangle left // cellSize + 1 max: 1.	top := displayRectangle top // cellSize + 1 max: 1.	right := displayRectangle right // cellSize + 1 min: model width.	bottom := displayRectangle bottom // cellSize + 1 min: model height.	^Rectangle left: left right: right + 1 top: top bottom: bottom + 1</body><body package="Xonix">displayBoundsOfCell: aPoint	| left top |	left := aPoint x - 1 * cellSize.	top := aPoint y - 1 * cellSize.	^left @ top extent: cellSize @ cellSize</body><body package="Xonix">overlayBounds	| box |	^overlay isNil		ifTrue: [self bounds center extent: 0@0]		ifFalse: 			[box := overlay preferredBounds.			box align: box center with: self bounds center]</body></methods><methods><class-id>XonixView</class-id> <category>accessing</category><body package="Xonix">cellSize	^cellSize</body><body package="Xonix">cellSize: anInteger	cellSize := anInteger</body><body package="Xonix">defaultControllerClass	^XonixController</body><body package="Xonix">model: aModel	super model: aModel.	self invalidate</body><body package="Xonix">overlay: aComponentOrNil	| damagedBox |	damagedBox := self overlayBounds.	overlay := aComponentOrNil.	damagedBox := damagedBox merge: self overlayBounds.	self invalidateRectangle: damagedBox repairNow: true</body></methods><methods><class-id>XonixView</class-id> <category>displaying</category><body package="Xonix">displayCellsOn: aGraphicsContext in: invalidRectangle	model rectangle: invalidRectangle do:		[:x :y | | cell |		cell := model atX: x y: y.		cell 			displayOn: aGraphicsContext			inside: (self boundsOfCellX: x y: y)]</body><body package="Xonix">displayCritter: critter on: aGraphicsContext in: invalidRectangle	| location |	location := critter location.	(invalidRectangle containsPoint: location) ifTrue:		[critter			displayOn: aGraphicsContext			inside: (self displayBoundsOfCell: location)]</body><body package="Xonix">displayEmptyBackgroundOn: aGraphicsContext in: aRectangle	aGraphicsContext 		paint: model emptyCell color;		displayRectangle: aRectangle</body><body package="Xonix">displayOn: aGraphicsContext	| boundsToRepaint cellsToRepaint |	boundsToRepaint := aGraphicsContext clippingBounds.	cellsToRepaint := self cellBoundsOf: boundsToRepaint.	self 		displayEmptyBackgroundOn: aGraphicsContext in: boundsToRepaint;		displayCellsOn: aGraphicsContext in: cellsToRepaint;		displayCritter: model hero on: aGraphicsContext in: cellsToRepaint.	model badGuys do:		[:each |		self displayCritter: each on: aGraphicsContext in: cellsToRepaint].	overlay notNil ifTrue:		[overlay			displayOn: aGraphicsContext			at: self overlayBounds origin].	"aGraphicsContext		paint: ColorValue black;		displayRectangularBorder: (boundsToRepaint insetBy: 1)"</body></methods><methods><class-id>XonixView</class-id> <category>initialize-release</category><body package="Xonix">initialize	cellSize := 10</body></methods><methods><class-id>XonixView</class-id> <category>measurements</category><body package="Xonix">preferredBounds	^0 @ 0 extent: model width * cellSize @ (model height * cellSize)</body></methods><methods><class-id>XonixView</class-id> <category>notifications</category><body package="Xonix">update: aspect with: aParameter	#cell == aspect ifTrue:		[^self invalidateRectangle: (self displayBoundsOfCell: aParameter)].	#quickFix == aspect ifTrue:		[^self repairDamage].	self invalidate</body></methods><methods><class-id>TrialCell</class-id> <category>accessing</category><body package="Xonix">asNormal	^futureReplacement</body><body package="Xonix">beFutureEmpty	futureReplacement := world emptyCell</body></methods><methods><class-id>TrialCell</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld.	futureReplacement := world solidCell</body></methods><methods><class-id>Critter</class-id> <category>displaying</category><body package="Xonix">displayOn: aGraphicsContext inside: boundsRectangle	picture 		displayOn: aGraphicsContext		at: boundsRectangle origin</body></methods><methods><class-id>Critter</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld.	location := 0 @ 0</body></methods><methods><class-id>Critter</class-id> <category>accessing</category><body package="Xonix">location	^location</body><body package="Xonix">location: aPoint	location := aPoint</body></methods><methods><class-id>Hero</class-id> <category>running</category><body package="Xonix">checkBounds	(world bounds containsPoint: location + direction)		ifFalse: [self stopMoving]</body><body package="Xonix">step	self checkBounds.	direction isZero ifFalse:		[self leaveLocation.		world invalidate: location.		location := location + direction.		world invalidate: location.		self enterLocation]</body></methods><methods><class-id>Hero</class-id> <category>private</category><body package="Xonix">direction: directionSymbol	#Left == directionSymbol ifTrue: [^-1 @ 0].	#Right == directionSymbol ifTrue: [^1 @ 0].	#Up == directionSymbol ifTrue: [^0 @ -1].	#Down == directionSymbol ifTrue: [^0 @ 1].	self error: 'invalid direction symbol'</body><body package="Xonix">enterLocation	| cell |	cell := world at: location.	cell heroArrived.	cell isSolid ifFalse:		[picture := scaredFace.		inTheOpen ifFalse: 			[trailCellLocations := OrderedCollection new: 50].		inTheOpen := true.		trailCellLocations add: location.		world at: location put: (world at: location) asTrail].	cell isSolid &amp; inTheOpen ifTrue:		[picture := happyFace.		inTheOpen := false.		world solidifyTrail]</body><body package="Xonix">leaveLocation</body></methods><methods><class-id>Hero</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld.	direction := 0 @ 0.	inTheOpen := false.	picture := happyFace := OpaqueImage 		figure: self class happyFace		shape: self class mask.	scaredFace := OpaqueImage 		figure: self class scaredFace		shape: self class mask</body></methods><methods><class-id>Hero</class-id> <category>controlling</category><body package="Xonix">startMoving: directionSymbol	direction := self direction: directionSymbol</body><body package="Xonix">stopMoving	direction := 0 @ 0</body><body package="Xonix">stopMoving: directionSymbol	| vector |	vector := self direction: directionSymbol.	vector x ~= 0 ifTrue: [direction x: 0].	vector y ~= 0 ifTrue: [direction y: 0]</body></methods><methods><class-id>Hero</class-id> <category>accessing</category><body package="Xonix">trailCellLocations	^trailCellLocations</body></methods><methods><class-id>NoSoundPlayer</class-id> <category>accessing</category><body package="Xonix">playGameOverSound</body><body package="Xonix">playGotchaSound</body><body package="Xonix">playGrabSound</body><body package="Xonix">playIntroSound</body><body package="Xonix">playLevelStartSound</body><body package="Xonix">playLevelWinSound</body><body package="Xonix">stopSound</body></methods><methods><class-id>BouncingCritter</class-id> <category>private</category><body package="Xonix">bounceBack	direction := direction negated</body><body package="Xonix">bounceBack: iterationCount	direction := direction negated.	self checkForBounce: iterationCount</body><body package="Xonix">bounceHorizontally: iterationCount	direction := direction x negated @ direction y.	self checkForBounce: iterationCount</body><body package="Xonix">bounceVertically: iterationCount	direction := direction x @ direction y negated.	self checkForBounce: iterationCount</body><body package="Xonix">checkForBounce: iterationCount	"Check the cells ahead and change direction if some of them are solid.	After the direction is changed, another check for bounce is needed in	the direction changing method because the new cells ahead may bounce	as well. Normally at most three bounces at the same location would be needed	for a critter to bounce back free.  However to protect against infinite recusrion in case	of abnormalities we keep count of rebound attempts."	| touchMap action |	iterationCount &gt; 4 ifTrue: [CritterStuckError raise].	touchMap := self		touchMapHorizontal: (self realOrFakeCellAt: location + (1 @ 0 * direction))		headOn: (self realOrFakeCellAt: location + direction)		vertical: (self realOrFakeCellAt: location + (0 @ 1 * direction)).	action := #(	noBounce: "000"				bounceVertically: "001"				bounceBack: "010"				bounceVertically: "011"		  		bounceHorizontally: "100"				bounceBack: "101"				bounceHorizontally: "110" 				bounceBack: "111")			at: touchMap + 1.	self perform: action with: iterationCount + 1</body><body package="Xonix">noBounce</body><body package="Xonix">noBounce: iterationCount</body><body package="Xonix">realOrFakeCellAt: aPoint	^(world bounds containsPoint: aPoint)		ifTrue: [world at: aPoint]		ifFalse: [world emptyCell]</body><body package="Xonix">touchMapHorizontal: brushedH headOn: headOn vertical: brushedV	^(brushedH isSolid ifTrue: [4] ifFalse: [0])		+ (headOn isSolid ifTrue: [2] ifFalse: [0])		+ (brushedV isSolid ifTrue: [1] ifFalse: [0])</body></methods><methods><class-id>BouncingCritter</class-id> <category>accessing</category><body package="Xonix">direction	^direction</body><body package="Xonix">direction: aPoint	direction := aPoint</body></methods><methods><class-id>BouncingCritter</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld.	direction := 1 @ 1.	picture := OpaqueImage 		figure: self class picture 		shape: self class pictureMask</body></methods><methods><class-id>BouncingCritter</class-id> <category>running</category><body package="Xonix">step	[self checkForBounce: 1]		on: CritterStuckError		do: [:ex |			"This has never happened in my experience but I have no proof			it can't ever.  A debugging action here is to pass the exception to			look at the circumstances, but the normal one is to get rid of the			critter and proceed."			"ex pass."			^world removeBadGuy: self].	world invalidate: location.	location := location + direction.	world invalidate: location.	(world at: location) badGuyArrived</body></methods><methods><class-id>OuterBouncingCritter</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld</body></methods><methods><class-id>OuterBouncingCritter</class-id> <category>private</category><body package="Xonix">realOrFakeCellAt: aPoint	^(world bounds containsPoint: aPoint)		ifTrue: 			[world hero location = aPoint ifTrue: 				[heroTrampled := true].			world at: aPoint]		ifFalse: [world emptyCell]</body><body package="Xonix">touchMapHorizontal: brushedH headOn: headOn vertical: brushedV	^(brushedH isSolid ifFalse: [4] ifTrue: [0])		+ (headOn isSolid ifFalse: [2] ifTrue: [0])		+ (brushedV isSolid ifFalse: [1] ifTrue: [0])</body></methods><methods><class-id>OuterBouncingCritter</class-id> <category>running</category><body package="Xonix">step	heroTrampled := false.	super step.	heroTrampled ifTrue: [world nukeHero]</body></methods><methods><class-id>EmptyCell</class-id> <category>accessing</category><body package="Xonix">asTrail	^TrailCell in: world</body></methods><methods><class-id>EmptyCell</class-id> <category>displaying</category><body package="Xonix">displayOn: aGraphicsContext inside: boundsRectangle	"Nothing to do for empty cell because the whole damaged	rectangle is already painted the empty color.  Overriding this	method to do nothing really saves on the amount of time 	spent actually drawing empty cells."</body></methods><methods><class-id>EmptyCell</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld.	color := world emptyAreaColor</body></methods><methods><class-id>EmptyCell</class-id> <category>testing</category><body package="Xonix">isFillable	^true</body></methods><methods><class-id>Win32SoundPlayer</class-id> <category>types</category><body package="Xonix">DWORD	&lt;C: typedef unsigned int DWORD&gt;</body><body package="Xonix">HMODULE	&lt;C: typedef unsigned int HMODULE&gt;</body><body package="Xonix">LPCSTR	&lt;C: typedef char * LPCSTR&gt;</body></methods><methods><class-id>Win32SoundPlayer</class-id> <category>defines</category><body package="Xonix">SND_ALIAS	&lt;C: #define SND_ALIAS 65536	&gt;</body><body package="Xonix">SND_ASYNC	&lt;C: #define SND_ASYNC 0x0001	&gt;</body><body package="Xonix">SND_FILENAME	&lt;C: #define SND_FILENAME 131072	&gt;</body><body package="Xonix">SND_NODEFAULT	&lt;C: #define SND_NODEFAULT 0x0002	&gt;</body><body package="Xonix">SND_NOWAIT	&lt;C: #define SND_NOWAIT 512	&gt;</body><body package="Xonix">SND_SYNC	&lt;C: #define SND_SYNC 0	&gt;</body></methods><methods><class-id>Win32SoundPlayer</class-id> <category>accessing</category><body package="Xonix">hasFiles	^gameOverPath asFilename exists 		&amp; gotchaPath asFilename exists		&amp; grabPath asFilename exists		&amp; introPath asFilename exists		&amp; levelStartPath asFilename exists		&amp; levelWinPath asFilename exists</body><body package="Xonix">playGameOverSound	self playSoundFile: gameOverPath</body><body package="Xonix">playGotchaSound	self playSoundFile: gotchaPath</body><body package="Xonix">playGrabSound	self playSoundFile: grabPath</body><body package="Xonix">playIntroSound	self playSoundFile: introPath</body><body package="Xonix">playLevelStartSound	self playSoundFile: levelStartPath</body><body package="Xonix">playLevelWinSound	self playSoundFile: levelWinPath</body><body package="Xonix">stopSound	self 		PlaySoundA: nil		with: 0		with: 0</body></methods><methods><class-id>Win32SoundPlayer</class-id> <category>initialize-release</category><body package="Xonix">initialize: baseDirectoryName	gameOverPath := baseDirectoryName constructString: 'gameover.wav'.	gotchaPath := baseDirectoryName constructString: 'gotcha.wav'.	grabPath := baseDirectoryName constructString: 'grab.wav'.	introPath := baseDirectoryName constructString: 'intro.wav'.	levelStartPath := baseDirectoryName constructString: 'levelstart.wav'.	levelWinPath := baseDirectoryName constructString: 'levelwin.wav'</body></methods><methods><class-id>Win32SoundPlayer</class-id> <category>private</category><body package="Xonix">playSoundFile: aString	self 		PlaySoundA: aString		with: 0		with: (self SND_FILENAME bitOr: (self SND_ASYNC bitOr: self SND_NODEFAULT))</body><body package="Xonix">playSoundNamed: aString	self 		PlaySoundA: aString		with: 0		with: (self SND_ALIAS bitOr: (self SND_ASYNC bitOr: self SND_NODEFAULT))</body></methods><methods><class-id>Win32SoundPlayer class</class-id> <category>instance creation</category><body package="Xonix">new	^super new		initialize: self wavFileDirectoryName</body></methods><methods><class-id>Win32SoundPlayer class</class-id> <category>parameters</category><body package="Xonix">wavFileDirectoryName	^(Filename fromComponents: #('$(VISUALWORKS)' 'contributed' 'Xonix')) asFilename</body></methods><methods><class-id>TrailCell</class-id> <category>accessing</category><body package="Xonix">asNormal	^world emptyCell</body><body package="Xonix">badGuyArrived	world nukeHero</body><body package="Xonix">heroArrived	world nukeHero</body></methods><methods><class-id>TrailCell</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld.	color := world trailColor</body></methods><methods><class-id>TrailCell</class-id> <category>testing</category><body package="Xonix">isTrailCell	^true</body></methods><methods><class-id>XonixWorld</class-id> <category>accessing</category><body package="Xonix">addBadGuyAt: aPoint	badGuys := badGuys copyWith:		((BouncingCritter in: self)			location: aPoint;			direction: self randomDirection)</body><body package="Xonix">badGuys	^badGuys</body><body package="Xonix">bounds	^1 @ 1 extent: self extent</body><body package="Xonix">emptyCell	^empty</body><body package="Xonix">extent	^width @ height</body><body package="Xonix">gameAreaBounds	^self bounds insetBy: 3</body><body package="Xonix">height	^height</body><body package="Xonix">hero	^hero</body><body package="Xonix">hideHero	self invalidate: hero location.	hero 		location: (100@100) negated;		stopMoving</body><body package="Xonix">removeBadGuy: aCritter	badGuys := badGuys copyWithout: aCritter.	self invalidate: aCritter location</body><body package="Xonix">solidCell	^solid</body><body package="Xonix">soundPlayer	^soundPlayer</body><body package="Xonix">takenOverCount	^takenOverCount</body><body package="Xonix">width	^width</body></methods><methods><class-id>XonixWorld</class-id> <category>accessing-cells</category><body package="Xonix">at: aPoint	^self atX: aPoint x y: aPoint y</body><body package="Xonix">at: aPoint put: anObject	^self atX: aPoint x y: aPoint y put: anObject</body><body package="Xonix">atX: xInteger y: yInteger	^self basicAt: yInteger - 1 * width + xInteger</body><body package="Xonix">atX: xInteger y: yInteger put: anObject	^self basicAt:  yInteger - 1 * width + xInteger put: anObject</body><body package="Xonix">cellsDo: aBlock	self do: [:x :y | aBlock value: (self atX: x y: y)]</body><body package="Xonix">cellsInflict: aBlock	self do:		[:x :y |		self atX: x y: y put: (aBlock value: (self atX: x y: y))].</body><body package="Xonix">do: aBlock	self rectangle: self bounds do: aBlock</body><body package="Xonix">gameAreaCellsInflict: aBlock	self gameAreaDo:		[:x :y |		self atX: x y: y put: (aBlock value: (self atX: x y: y))].</body><body package="Xonix">gameAreaDo: aBlock	self rectangle: self gameAreaBounds do: aBlock</body><body package="Xonix">gameAreaPointsDo: aBlock	self rectangle: self gameAreaBounds do: 		[:x :y | aBlock value: x @ y]</body><body package="Xonix">invalidate: aPoint	self changed: #cell with: aPoint</body><body package="Xonix">pointsDo: aBlock	self rectangle: self bounds do: 		[:x :y | aBlock value: x @ y]</body><body package="Xonix">rectangle: aRectangle do: aBlock	aRectangle left to: aRectangle right - 1 do:		[:x |		aRectangle top to: aRectangle bottom - 1 do:			[:y |			aBlock value: x value: y]]</body><body package="Xonix">x: xInterval y: yInterval do: aBlock	xInterval do:		[:x |		yInterval do:			[:y |			aBlock value: x value: y]]</body></methods><methods><class-id>XonixWorld</class-id> <category>parameters</category><body package="Xonix">borderAreaColor	^ColorValue red: 0.3 green: 0.3 blue: 0.4</body><body package="Xonix">emptyAreaColor	^ColorValue red: 0.7 green: 0.7 blue: 0.9</body><body package="Xonix">trailColor	^ColorValue red: 0.5 green: 0.5 blue: 1</body></methods><methods><class-id>XonixWorld</class-id> <category>private</category><body package="Xonix">clear	takenOverCount := 0.	self 		rectangle: self bounds 		do: [:x :y | self atX: x y: y put: solid];		rectangle: (self bounds insetBy: 3)		do: [:x :y | self atX: x y: y put: empty]</body><body package="Xonix">fillAt: aPoint with: aTrialCell badGuyLocations: aCollection	| cell |	cell := self at: aPoint.	cell isFillable ifFalse: [^self].	(aCollection includes: aPoint) ifTrue: [aTrialCell beFutureEmpty].	self 		at: aPoint put: aTrialCell;		fillAt: -1 @ 0 + aPoint with: aTrialCell badGuyLocations: aCollection;		fillAt: 1 @ 0 + aPoint with: aTrialCell badGuyLocations: aCollection;		fillAt: 0 @ -1 + aPoint with: aTrialCell badGuyLocations: aCollection;		fillAt: 0 @ 1 + aPoint with: aTrialCell badGuyLocations: aCollection</body><body package="Xonix">normalizeCells	takenOverCount := 0.	self gameAreaCellsInflict: 		[:each | | cell |		cell := each asNormal.		cell isSolid ifTrue: [takenOverCount := takenOverCount + 1].		cell]</body></methods><methods><class-id>XonixWorld</class-id> <category>initialize-release</category><body package="Xonix">initialize: sizePoint 	width := sizePoint x.	height := sizePoint y.	empty := EmptyCell in: self.	solid := SolidCell in: self.	random := Random new.	self setupSoundPlayer.	self clear.	badGuys := #()</body><body package="Xonix">setupHero	hero := (Hero in: self)		location: width // 2 @ 1.</body><body package="Xonix">setupInnerCritters: anInteger	| emptyArea |	emptyArea := self gameAreaBounds.	badGuys := (1 to: anInteger) collect: 		[:i | 		(BouncingCritter in: self)			location: (self randomPointIn: emptyArea);			direction: self randomDirection]</body><body package="Xonix">setupOuterCritters: anInteger	| outerBadGuys |	outerBadGuys := (1 to: anInteger) collect: 		[:i | 		(OuterBouncingCritter in: self)			location: (self randomBetween: 1 and: width) @ height;			direction: self randomDirection].	badGuys := badGuys, outerBadGuys</body><body package="Xonix">setupSoundPlayer	OSHandle currentOS = #win32 ifTrue: 		[soundPlayer := Win32SoundPlayer new.		soundPlayer hasFiles ifTrue: [^self]].	soundPlayer := NoSoundPlayer new</body></methods><methods><class-id>XonixWorld</class-id> <category>running</category><body package="Xonix">nukeHero	soundPlayer playGotchaSound.	self		setupHero;		cellsInflict: [:each | each asNormal];		changed: #area;		changed: #heroDied.	HeroNukedNotification raise</body><body package="Xonix">solidifyTrail	| locations |	self changed: #quickFix. "make the hero visible now"	soundPlayer playGrabSound.	locations := badGuys collect: [:each | each location].	hero trailCellLocations do: 		[:location |		self 			fillAt: -1 @ 0 + location with: (TrialCell in: self) badGuyLocations: locations;			fillAt: 1 @ 0 + location with: (TrialCell in: self) badGuyLocations: locations;			fillAt: 0 @ -1 + location with: (TrialCell in: self) badGuyLocations: locations;			fillAt: 0 @ 1 + location with: (TrialCell in: self) badGuyLocations: locations;			at: location put: solid].	self 		normalizeCells;		changed: #area</body><body package="Xonix">startMovingHero: directionSymbol	hero startMoving: directionSymbol</body><body package="Xonix">step	badGuys do: [:each | each step].	[hero step]		on: HeroNukedNotification		do: [:ex | ex return]</body><body package="Xonix">stopMovingHero: directionSymbol	hero stopMoving: directionSymbol</body></methods><methods><class-id>XonixWorld</class-id> <category>random</category><body package="Xonix">random	^random next</body><body package="Xonix">randomBetween: anInteger and: anotherInteger	^self randomBetween: anInteger andExclusive: anotherInteger + 1</body><body package="Xonix">randomBetween: anInteger andExclusive: anotherInteger	^anInteger + (random next * (anotherInteger - anInteger)) floor</body><body package="Xonix">randomDirection	| axisDirections |	axisDirections := #(-1 1).	^(self randomOf: axisDirections) @ (self randomOf: axisDirections)</body><body package="Xonix">randomOf: aCollection	^aCollection at: (self randomBetween: 1 and: aCollection size)</body><body package="Xonix">randomPointIn: aRectangle	^(self randomBetween: aRectangle left andExclusive: aRectangle right)		@ (self randomBetween: aRectangle top andExclusive: aRectangle bottom)</body></methods><methods><class-id>XonixWorld class</class-id> <category>instance creation</category><body package="Xonix">new: aPoint badInside: anInteger outside: anInteger2	| instance |	instance := self new: aPoint x * aPoint y.	instance 		initialize: aPoint;		setupHero;		setupInnerCritters: anInteger;		setupOuterCritters: anInteger2.	^instance</body></methods><methods><class-id>Xonix</class-id> <category>actions</category><body package="Xonix">advanceLevel	self levelHolder value: self levelHolder value + 1.	self livesHolder value: self livesHolder value + 1.	self scoreHolder value: baseScore.	self installLevel.	self xonixView overlay: nil</body><body package="Xonix">endLevel	| extra bonus |	extra := self xonixWorld takenOverCount - 		(self xonixWorld gameAreaBounds area * 0.7).	bonus := (extra * self levelHolder value) rounded.	self xonixWorld soundPlayer playLevelWinSound.	self showText: 'Bonus points: ', bonus printString.	levelSwitchCountdown := 30.	timeoutAction := #advanceLevel.	self xonixWorld hideHero.	baseScore := self scoreHolder value + bonus</body><body package="Xonix">gameOver	self xonixWorld soundPlayer playGameOverSound.	self showText: 'GAME\OVER' withCRs forSeconds: 3.	self class checkForHighScore: self scoreHolder value.	self showHallOfFame</body><body package="Xonix">help	Dialog warn: self helpText</body><body package="Xonix">start	self scheduleHeartbeat</body><body package="Xonix">step	levelSwitchCountdown = 0 ifFalse:		[levelSwitchCountdown := levelSwitchCountdown - 1.		levelSwitchCountdown = 0 ifTrue:			[^self perform: timeoutAction]].	[self xonixWorld step]		on: Error		do: [:ex | self stop. ex pass].	builder window displayPendingInvalidation</body><body package="Xonix">stop	mutex critical: 		[heartbeat notNil ifTrue: 			[heartbeat terminate.			heartbeat := nil]]</body><body package="Xonix">togglePause	paused := paused not.	paused		ifTrue: 			[self showText: 'Paused'.			self stop]		ifFalse: 			[xonixView overlay: nil.			self start]</body></methods><methods><class-id>Xonix</class-id> <category>private</category><body package="Xonix">closeTitle	(Delay forSeconds: 2) wait.	self setupGame</body><body package="Xonix">createTitleWorld	| world |	world := self createWorldFromImage: self class xonixTitle asImage.	self rehashBadGuysIn: world.	^world</body><body package="Xonix">createWorld	| level |	level := self levelHolder value.	^XonixWorld		new: 60 @ 40		badInside: level		outside: level // 4</body><body package="Xonix">hallOfFameComponent	| strings pixmap gc maxWidth baseline |	strings := OrderedCollection new.	strings add: 'HIGH SCORES'; add: ''.	(HighScores asSortedCollection: [:a :b | a first &gt; b first]) keysAndValuesDo:		[:i :score |		strings add: ('&lt;1p&gt; by &lt;2s&gt;' expandMacrosWith: score first with: score last)].	pixmap := Pixmap extent: 1@1.	gc := pixmap graphicsContext.	maxWidth := strings inject: 0 into: [:max :each | max max: (gc widthOfString: each)].	pixmap := Pixmap extent: 10 @ 10 + (maxWidth @ (strings size * 20)).	gc := pixmap graphicsContext.	baseline := 20.	strings do:		[:string |		gc displayString: string 			at: (pixmap width - (gc widthOfString: string) // 2 @ baseline).		baseline := baseline + 20].	^pixmap asImage</body><body package="Xonix">heartbeat	self		scheduleHeartbeat;		step</body><body package="Xonix">helpText	^'How to play XonixUsing the arrow keys, move the "hero" into the open area, surround some territorywith the trail the hero leaves, then return to the safe border to capture that territory.While out in the open, do not let any of the bouncing critters touch the heroor the trail, and do not cross the trail yourself.  At each level, the goal is to capture70% of the territory.Vassili Bykov &lt;vbykov@cincom.com&gt;Summer 2001'</body><body package="Xonix">installFirstLevel	xonixView overlay: nil.	self setupGame</body><body package="Xonix">installLevel	self installWorld: self createWorld.	self takenOverHolder value: 0.</body><body package="Xonix">installTitle	state := #title.	self installWorld: self createTitleWorld.	levelSwitchCountdown := 16.	timeoutAction := #closeTitle</body><body package="Xonix">installWorld: aXonixWorld	xonixView model: aXonixWorld.	aXonixWorld addDependent: self</body><body package="Xonix">keyboardEvent: anEvent	((anEvent isKindOf: KeyPressedEvent) and: [anEvent keyValue = Character space])		ifTrue: 			[state == #title ifTrue: [^self setupGame].			self togglePause]</body><body package="Xonix">positionWindow	| desiredExtent currentExtent currentBox desiredBox |	desiredExtent := xonixView preferredBounds extent.	currentExtent := (builder componentAt: #xonixView) widget bounds extent.	currentBox := builder window displayBox.	desiredBox := currentBox origin extent: currentBox extent + desiredExtent - currentExtent.	desiredBox := desiredBox align: desiredBox center with: Screen default bounds center.	builder window displayBox: desiredBox</body><body package="Xonix">scheduleHeartbeat	paused ifTrue: [^self].	heartbeat := 		[self tickDelay wait.		mutex critical:			[builder window isOpen ifTrue:				[[self heartbeat] uiEventNowFor: builder window].			heartbeat := nil]]		forkAt: Processor userInterruptPriority</body><body package="Xonix">setupGame	levelSwitchCountdown := 0.	state := #game.	xonixView overlay: nil.	self levelHolder value: 1.	self livesHolder value: 4.	self scoreHolder value: 0.	baseScore := 0.	self installLevel.</body><body package="Xonix">show: aVisualComponent	xonixView overlay: aVisualComponent</body><body package="Xonix">show: aVisualComponent forSeconds: anInteger	xonixView overlay: aVisualComponent.	(Delay forSeconds: anInteger) wait.	xonixView overlay: nil</body><body package="Xonix">showHallOfFame	HighScores isEmpty ifFalse: 		[self show: self hallOfFameComponent.		self xonixWorld hideHero.		levelSwitchCountdown := 100.		state := #title.		timeoutAction := #installFirstLevel]</body><body package="Xonix">showText: aText	| banner bannerBounds component |	banner := CompositePart new.	component := aText asText allBold asComposedText.	bannerBounds := 0 @ 0 extent: 10 @ 10 + component preferredBounds extent.	banner add: ((GraphicsAttributesWrapper on: bannerBounds asFiller)		attributes: (GraphicsAttributes new paint: ColorValue lightYellow)).	banner 		add: ((GraphicsAttributesWrapper on: component)			attributes: (GraphicsAttributes new paint: ColorValue navy))		at: 5 @ 5.	self show: banner</body><body package="Xonix">showText: aText forSeconds: anInteger	| banner bannerBounds component |	banner := CompositePart new.	component := aText asText allBold asComposedText.	bannerBounds := 0 @ 0 extent: 10 @ 10 + component preferredBounds extent.	banner add: ((GraphicsAttributesWrapper on: bannerBounds asFiller)		attributes: (GraphicsAttributes new paint: ColorValue darkRed)).	banner 		add: ((GraphicsAttributesWrapper on: component)			attributes: (GraphicsAttributes new paint: ColorValue lightYellow))		at: 5 @ 5.	self show: banner forSeconds: anInteger</body></methods><methods><class-id>Xonix</class-id> <category>private-title screen</category><body package="Xonix">createWorldFromImage: anImage	| world origin gameArea |	world := XonixWorld new: 60 @ 40 badInside: 0 outside: 0.	world hideHero.	gameArea := world gameAreaBounds.	origin := gameArea extent - anImage extent // 2 + gameArea origin.	0 to: anImage width - 1 do: 		[:x |		0 to: anImage height - 1 do: 			[:y | | point |			point := x @ y.			(anImage atPoint: point) ~= 0 ifTrue:				[world addBadGuyAt: point + origin]]].	^world</body><body package="Xonix">rehashBadGuysIn: aWorld	15 timesRepeat: [aWorld step].	aWorld badGuys do: [:each | each bounceBack]</body></methods><methods><class-id>Xonix</class-id> <category>parameters</category><body package="Xonix">emptyAreaColor	^ColorValue lightYellow</body><body package="Xonix">safeAreaColor	^ColorValue brown</body><body package="Xonix">tickDelay	"This is the game time quantum.	Reduce it if you think you are tough."	^Delay forMilliseconds: 80</body></methods><methods><class-id>Xonix</class-id> <category>notifications</category><body package="Xonix">heroDied	self livesHolder value: self livesHolder value - 1.	self livesHolder value = 0 ifTrue:		[self gameOver]</body><body package="Xonix">moreTakenOver	| thisLevelGain takenOver |	thisLevelGain := self xonixWorld takenOverCount.	takenOver := thisLevelGain / self xonixWorld gameAreaBounds area.	self takenOverHolder value: takenOver.	self scoreHolder value: baseScore + thisLevelGain.	takenOver &gt;= 0.7 ifTrue: [self endLevel]</body><body package="Xonix">update: aspect	super update: aspect.	#area == aspect ifTrue: [^self moreTakenOver].	#heroDied == aspect ifTrue: [^self heroDied]</body><body package="Xonix">windowEvent: anEvent from: aWindow	super windowEvent: anEvent from: aWindow.	#timer == anEvent key ifTrue: [anEvent value execute]</body></methods><methods><class-id>Xonix</class-id> <category>initialize-release</category><body package="Xonix">initialize	mutex := Semaphore forMutualExclusion.	xonixView := XonixView new.	levelSwitchCountdown := 0.	paused := false.	self installTitle</body><body package="Xonix">postBuildWith: aBuilder	| topBarHeight extent |	topBarHeight := 20.	extent := xonixView preferredBounds extent.	(aBuilder window keyboardProcessor)		focusedView: xonixView;		keyboardHook: 				[:event :controller |				self keyboardEvent: event.				event].	(aBuilder componentAt: #xonixView) layout		leftFraction: 0.5 offset: extent x negated // 2 - 2;		rightFraction: 0.5 offset: extent x // 2 + 2;		topFraction: 0.5 offset: extent y negated // 2 + topBarHeight - 2;		bottomFraction: 0.5 offset: extent y // 2 + topBarHeight + 2</body><body package="Xonix">postOpenWith: aBuilder	aBuilder window		application: self;		damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new;		sendWindowEvents: #(timer).	self start.	self xonixWorld soundPlayer playIntroSound</body></methods><methods><class-id>Xonix</class-id> <category>aspects</category><body package="Xonix">levelHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^levelHolder isNil		ifTrue:			[levelHolder := 0 asValue]		ifFalse:			[levelHolder]</body><body package="Xonix">livesHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^livesHolder isNil		ifTrue:			[livesHolder := 0 asValue]		ifFalse:			[livesHolder]</body><body package="Xonix">scoreHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^scoreHolder isNil		ifTrue:			[scoreHolder := 0 asValue]		ifFalse:			[scoreHolder]</body><body package="Xonix">takenOverHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^takenOverHolder isNil		ifTrue:			[takenOverHolder := 0 asValue]		ifFalse:			[takenOverHolder]</body></methods><methods><class-id>Xonix</class-id> <category>accessing</category><body package="Xonix">preferredDisplayBox	| desiredBox |	desiredBox := 0 @ 0 extent: 20 @ 50 + xonixView preferredBounds extent.	^desiredBox align: desiredBox center with: Screen default bounds center</body><body package="Xonix">xonixView	^xonixView</body><body package="Xonix">xonixWorld	^xonixView model</body></methods><methods><class-id>Xonix class</class-id> <category>accessing</category><body package="Xonix">addHighScore: anInteger	| reply |	reply := Dialog request: ('High score: &lt;1p&gt;!&lt;n&gt;Your name?'		expandMacrosWith: anInteger).	reply isEmpty ifTrue: [reply := '&lt;anonymous&gt;'].	HighScores add: (Array with: anInteger with: Date today with: reply)</body><body package="Xonix">checkForHighScore: anInteger	| scores |	HighScores size &lt; 5 ifTrue: [^self addHighScore: anInteger].	scores := HighScores asSortedCollection: [:a :b | a first &lt;= b first].	scores first first &lt; anInteger ifTrue:		[HighScores remove: scores first.		self addHighScore: anInteger]</body></methods><methods><class-id>Xonix class</class-id> <category>instance opening</category><body package="Xonix">open	| instance |	instance := self new.	instance allButOpenInterface: #windowSpec.	instance finallyOpenIn: instance preferredDisplayBox withType: #normal</body></methods><methods><class-id>SolidCell</class-id> <category>initialize-release</category><body package="Xonix">initializeWorld: aXonixWorld	super initializeWorld: aXonixWorld.	color := world borderAreaColor</body></methods><methods><class-id>SolidCell</class-id> <category>testing</category><body package="Xonix">isSolid	^true</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>event driven events</category><body package="Xonix">timerEvent: aTimerEvent	self reportWindowEvent: #timer with: aTimerEvent.	^nil</body></methods><methods><class-id>Hero class</class-id> <category>resources</category><body package="Xonix">happyFace	"UIMaskEditor new openOnClass: self andSelector: #happyFace"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: #[84 1 80 0 81 84 80 0 69 85 16 0 22 89 64 0 21 85 64 0 21 85 64 0 22 89 64 0 69 165 16 0 81 84 80 0 84 1 80 0])</body><body package="Xonix">mask	"UIMaskEditor new openOnClass: self andSelector: #mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[30 0 0 0 63 0 0 0 127 128 0 0 255 192 0 0 255 192 0 0 255 192 0 0 255 192 0 0 127 128 0 0 63 0 0 0 30 0 0 0])</body><body package="Xonix">picture	"UIMaskEditor new openOnClass: self andSelector: #picture"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: #[84 1 80 0 81 84 80 0 69 85 16 0 22 89 64 0 21 85 64 0 21 85 64 0 22 89 64 0 69 165 16 0 81 84 80 0 84 1 80 0])</body><body package="Xonix">scaredFace	"UIMaskEditor new openOnClass: self andSelector: #scaredFace"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: #[84 1 80 0 81 84 80 0 69 85 16 0 22 89 64 0 21 85 64 0 21 85 64 0 21 165 64 0 69 165 16 0 81 84 80 0 84 1 80 0])</body></methods><methods><class-id>BouncingCritter class</class-id> <category>resources</category><body package="Xonix">picture	"UIMaskEditor new openOnClass: self andSelector: #picture"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue darkRed; at: 3 put: Graphics.ColorValue red; at: 4 put: Graphics.ColorValue white; yourself)) usingBits: #[252 3 240 0 241 84 240 0 198 165 48 0 27 233 64 0 27 233 64 0 26 169 64 0 22 165 64 0 197 85 48 0 241 84 240 0 252 3 240 0])</body><body package="Xonix">pictureMask	"UIMaskEditor new openOnClass: self andSelector: #pictureMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[30 0 0 0 63 0 0 0 127 128 0 0 255 192 0 0 255 192 0 0 255 192 0 0 255 192 0 0 127 128 0 0 63 0 0 0 30 0 0 0])</body></methods><methods><class-id>OuterBouncingCritter class</class-id> <category>resources</category><body package="Xonix">picture	"UIMaskEditor new openOnClass: self andSelector: #picture"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue yellow; at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[168 2 160 0 161 84 160 0 133 85 32 0 22 149 64 0 22 149 64 0 21 85 64 0 21 85 64 0 133 85 32 0 161 84 160 0 168 2 160 0])</body></methods><methods><class-id>Xonix class</class-id> <category>resources</category><body package="Xonix">xonixTitle	"UIMaskEditor new openOnClass: self andSelector: #xonixTitle"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 40@11 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 97 159 24 205 134 0 0 0 97 177 156 205 134 0 0 0 51 49 156 204 204 0 0 0 30 49 158 204 120 0 0 0 12 49 158 204 48 0 0 0 30 49 155 204 120 0 0 0 51 49 153 204 204 0 0 0 97 177 153 205 134 0 0 0 97 159 24 205 134 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Xonix class</class-id> <category>interface specs</category><body package="Xonix">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Xonix' 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 502 555 1082 970 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 100 0 25 0 ) 					#name: #GroupBox1 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 200 0 25 0 ) 					#name: #GroupBox2 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 200 0 0 0 300 0 25 0 ) 					#name: #GroupBox3 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 300 0 0 0 450 0 25 0 ) 					#name: #GroupBox4 ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 0 1 0 1 ) 					#name: #xonixView 					#component: #xonixView ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 2 0 23 0 0 1 ) 					#name: #levelLabel 					#label: 'Level:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0 2 0 98 0 23 0 ) 					#name: #level 					#flags: 0 					#model: #levelHolder 					#alignment: #right 					#isReadOnly: true 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 102 0 23 0 0 1 ) 					#name: #Label1 					#label: 'Captured:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 176 0 10 0 214 0 23 0 ) 					#name: #takenOver 					#flags: 0 					#model: #takenOverHolder 					#alignment: #right 					#isReadOnly: true 					#type: #number 					#formatString: '0%' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 229 0 23 0 0 1 ) 					#name: #livesLabel 					#label: 'Lives:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 272 0 10 0 310 0 23 0 ) 					#name: #lives 					#flags: 0 					#model: #livesHolder 					#alignment: #right 					#isReadOnly: true 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 315 0 23 0 0 1 ) 					#name: #Label2 					#label: 'Score:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 370 0 9 0 448 0 23 0 ) 					#name: #score 					#flags: 0 					#model: #scoreHolder 					#alignment: #right 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 462 0 6 0 532 0 25 0 ) 					#name: #help 					#model: #help 					#tabable: false 					#label: 'Help' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Win32SoundPlayer</class-id> <category>procedures</category><body package="Xonix">PlaySoundA: arg1 with: arg2 with: arg3	&lt;C: int PlaySoundA(LPCSTR arg1, HMODULE arg2, DWORD arg3)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>