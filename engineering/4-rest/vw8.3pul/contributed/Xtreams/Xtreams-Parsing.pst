<?xml version="1.0"?><st-source><!-- Name: Xtreams-ParsingNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: This package implements PEG parsing support for Xtreams. The package includes some sample grammars that can be readily used (e.g. PEG, Smalltalk, JSON, XML, Wiki, etc). The grammars are conventionally stored in class methods on Parser in protocol 'grammars'.A Parser is created from a PEG grammar by parsing the grammar rules using the ParserParser.{{{	wikiGrammar := PEG.Parser grammarWiki reading.	wikiParser := PEG.Parser parserPEG parse: 'Grammar' stream: wikiGrammar actor: ParserParser new.}}}The parser then can be applied in the same fashion using arbitrary Actor to act on the parsing results. In the following example we'll use the wiki parser to generate an XML document from a text marked up with wiki syntax (The WikiGenerator class can be found in the parsing tests package).{{{	input := 'Single paragraph with *bold* and _italic_ text and a [link]' reading.	wikiParser parse: 'Page' stream: input actor: PEG.WikiGenerator new}}}We'll describe Actor creation using the simple arithmetic expression grammar example from [http://en.wikipedia.org/wiki/Parsing_expression_grammarwikipedia]{{{	grammar := '               Number                <- [0-9]+               Parenthesised      <- "(" Expr ")"               Value                   <- Number / Parenthesised               Product                <- Value (("*" / "/") Value)*               Sum                     <- Product (("+" / "-") Product)*               Expr                     <- Sum		'.}}}As was shown above, the parser is created by parsing the grammar text and using the ParserParser as the actor. {{{	parser := PEG.Parser parserPEG				parse: 'Grammar'				stream: grammar				actor: ParserParser new.}}}The resulting parser object can be immediately used to parse expressions (note that the grammar as written does not support whitespace){{{	parser parse: 'Expr' stream: '3+4*(4-3)' actor: nil}}}This will yield the following (roughly formatted to show some semblance of the parse tree of the expression sample){{{	#(#(OrderedCollection ($3 "16r0033") OrderedCollection ())	OrderedCollection (#		('+' #(OrderedCollection ($4 "16r0034")			OrderedCollection (				#('*' #(					'('						#(#(OrderedCollection ($4 "16r0034") OrderedCollection ())						OrderedCollection (#							('-' #(OrderedCollection ($3 "16r0033") OrderedCollection ()))))					')' )))))))}}}Let's say we'd like to evaluate the expression and return the result. While it's possible, rather than taking the above output apart and working with the pieces, it's easier to create an Actor that will will receive rule specific callbacks and transform the output on the fly. To do that we'll make a subclass of Actor. Let's call it ArithmeticEvaluator. To make the job easier, the Actor class provides a pragma based mechanism for expressing the rule specific callbacks. All it takes is writing a method for each rule where we want to transform the output. The method is linked to the rule by a pragma and the corresponding action is the method body. Here is an example method for the Number rule that turns the digit collection into a number:{{{	ArithmeticEvaluator>>Number: digits		<action: 'Number'>		^digits inject: 0 into: [ :total :digit | total * 10 + ('0123456789' indexOf: digit) - 1 ]}}}As soon as we have this method we can parse simple numbers{{{	parser parse: 'Number' stream: '3456' reading actor: ArithmeticEvaluator new}}}Now let's try to multiply. We'll need a method for the Product rule, but first we need to discuss the input into the callbacks in a bit more detail. The format of the input depends on the rule definition, specifically on the terms of the right side of the rule. The Product rule is defined as follows{{{	Product <- Value (("*" / "/") Value)*}}}This means that you'll get an array of whatever comes out of Value and then zero or more pairs of string `*` or `/` and another Value result. The "zero or more"  (star) operator always yields a collection (possibly empty). The easiest way to figure out the specifics is to add the rule with just a halt in it and then examining what comes in, for example:{{{	parser parse: 'Product' stream: '3*4*5*6*7' reading actor: ArithmeticEvaluator new}}}yields this{{{	#(	3		OrderedCollection (			#('*' 4)			#('*' 5)			#('*' 6)			#('*' 7)))}}}So Product will get a two element Array where the first element is the first Value and the second is a collection of pairs (possibly empty), where each pair is either `*` or `/` and then another Value. That's easy to deal with:{{{	Product: terms		<action: 'Product'>		^terms last inject: terms first into: [ :total :pair |			(pair first = '*')				ifTrue: [ total * pair last ]				ifFalse: [ total / pair last ] ]}}}The Actor pragmas provide another convenience for taking more complex input apart. You can also write the above as{{{	Product: first rest: pairs		<action: 'Product' arguments: #(1 2)>		^pairs inject: first into: [ :total :pair |			(pair first = '*')				ifTrue: [ total * pair last ]				ifFalse: [ total / pair last ] ]}}}The *arguments:* keyword simply says invoke this method with elements 1 and 2 of the rule input (terms) as arguments. Obviously the method must take the corresponding number of arguments as well. With the Product action in place the sample input should yield 2520.The Sum rule handling is analogous:{{{	Sum: first rest: pairs		<action: 'Sum' arguments: #(1 2)>		^pairs inject: first into: [ :total :pair |			(pair first = '+')				ifTrue: [ total + pair last ]				ifFalse: [ total - pair last ] ]}}}The last thing we need to deal with are parentheses. That turns out to be rather simple. The rule looks like this:{{{	Parenthesised <- "(" Expr ")"	}}}So the callback will get a 3 element array of left bracket, an Expression value and a right bracket. All we really need to do is strip the brackets and return the Expr value.{{{Parenthesised: expression	<action: 'Parenthesised' arguments: #(2)>	^expression}}}And that's it. We covered the whole grammar. So let's run our actor through a final test example.{{{	parser parse: 'Expr' stream: '((3+4)*2-4)/2' actor: ArithmeticEvaluator new}}}Hopefully the result of the above is 5.DbIdentifier: bear73DbTrace: 468775DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'AT MetaNumerics' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Terminals' ''))DialectVersion: VisualWorks 7.9ExplicitPrerequisites: #()IgnoredPrerequisites: #()Namespace: Smalltalk.XtreamsParsingPackageName: Xtreams-ParsingParcel: #('Xtreams-Parsing')PrerequisiteDescriptions: #(#(#name 'AT MetaNumerics') #(#name 'Xtreams-Core') #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package))PrerequisiteParcels: #(#('AT MetaNumerics' '') #('Xtreams-Core' '') #('Xtreams-Transforms' '') #('Xtreams-Terminals' ''))PrintStringCache: (8.2 - 0,tkogan)Version: 8.2 - 0Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>PEG</name><environment>Smalltalk</environment><private>false</private><imports>			private Core.*			private Xtreams.*			</imports><category></category><attributes><package>Xtreams-Parsing</package></attributes></name-space><class><name>Actor</name><environment>PEG</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Parsing</package></attributes></class><class><name>ParserGenerator</name><environment>PEG</environment><super>PEG.Actor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Parsing</package></attributes></class><comment><class-id>PEG.ParserGenerator</class-id><body>ParserGenerator generates smalltalk code from a PEG definition that produces a parser.</body></comment><class><name>ParserParser</name><environment>PEG</environment><super>PEG.Actor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser references useCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Parsing</package></attributes></class><comment><class-id>PEG.ParserParser</class-id><body>ParserParser generates a dictionary of evaluatable blocks that parses a given PEG grammar.Instance Variables	parser	&lt;Parser&gt; description of parser	references	&lt;Dictionary&gt; description of references	useCache	&lt;Boolean&gt; description of useCache</body></comment><class><name>Parser</name><environment>PEG</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar stream actor cache caches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Parsing</package></attributes></class><comment><class-id>PEG.Parser</class-id><body>A general recursive-descent-parser that is built by sending messages to ParserParser.</body></comment><shared-variable><name>Failure</name><environment>PEG.Parser</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Object new</initializer><attributes><package>Xtreams-Parsing</package></attributes></shared-variable><methods><class-id>PEG.Actor</class-id> <category>initialize-release</category><body package="Xtreams-Parsing">initialize	super initialize.	actions := Dictionary new.	(Tools.Pragma allNamed: #action:arguments: in: self class)		do: [:pragma | actions at: pragma arguments first put: [:object |			| arguments |			arguments := (pragma arguments at: 2) collect: [:i | i &lt;= object size ifTrue: [object at: i] ifFalse: [nil]].			self perform: pragma selector withArguments: arguments]].	(Tools.Pragma allNamed: #action: in: self class)		do: [:pragma | actions at: pragma arguments first put: [:object |			self perform: pragma selector with: object]].</body><body package="Xtreams-Parsing">process: name object: object start: start stop: stop	| action |	action := actions at: name ifAbsent: [^object].	^action value: object</body></methods><methods><class-id>PEG.Actor class</class-id> <category>instance creation</category><body package="Xtreams-Parsing">new	^super new initialize</body></methods><methods><class-id>PEG.ParserGenerator</class-id> <category>private</category><body package="Xtreams-Parsing">collection: aCollection	| stream |	stream := String new writing.	stream write: '(OrderedCollection new'.	aCollection do: [:each |		stream write: ' add: '.		stream write: each.		stream write: ';'].	stream write: ' yourself)'.	^stream contents</body></methods><methods><class-id>PEG.ParserParser</class-id> <category>initialize-release</category><body package="Xtreams-Parsing">dontUseCache	useCache := false</body><body package="Xtreams-Parsing">initialize	super initialize.	useCache := false.	parser := Parser new.	references := Dictionary new</body><body package="Xtreams-Parsing">useCache	useCache := true</body></methods><methods><class-id>PEG.Parser</class-id> <category>operations</category><body package="Xtreams-Parsing">all: expressions	| result object position |	position := stream position.	result := Array new: expressions size.	expressions keysAndValuesDo: [:index :expression |		(object := expression value) == Failure			ifTrue: [stream position: position. ^Failure].		result at: index put: object].	^result</body><body package="Xtreams-Parsing">any: expressions	| position object |	position := stream position.	expressions do: [:expression |		(object := expression value) == Failure			ifTrue:	[stream position: position]			ifFalse:	[^object]].	stream position: position.	^Failure</body><body package="Xtreams-Parsing">anything	| position |	position := stream position.	[stream read: 1 into: cache at: 1] on: Incomplete do: [stream position: position. ^Failure].	^cache at: 1</body><body package="Xtreams-Parsing">definition: expression name: name	| object position |	position := stream position.	object := expression value.	object == Failure ifTrue: [^Failure].	actor ifNil: [^object].	^actor process: name object: object start: position stop: stream position</body><body package="Xtreams-Parsing">definition: expression name: name cache: expressionCache	| object position entry |	position := stream position.	entry := expressionCache at: position ifAbsentPut:		[object := expression value.		(object ~~ Failure and: [actor notNil]) ifTrue:			[object := actor process: name object: object start: position stop: stream position].		stream position -&gt; object].	stream position: entry key.	^entry value</body><body package="Xtreams-Parsing">excluding: intervals	| position integer |	position := stream position.	[stream read: 1 into: cache at: 1] on: Incomplete do: [stream position: position. ^Failure].	integer := (cache at: 1) asInteger.	intervals do: [:interval | (interval includes: integer) ifTrue: [stream position: position. ^Failure]].	^cache at: 1</body><body package="Xtreams-Parsing">explore: expression	| object position |	position := stream position.	object := expression value.	stream position: position.	^object</body><body package="Xtreams-Parsing">including: intervals	| position integer |	position := stream position.	[stream read: 1 into: cache at: 1] on: Incomplete do: [stream position: position. ^Failure].	integer := (cache at: 1) asInteger.	intervals do: [:interval | (interval includes: integer) ifTrue: [^cache at: 1]].	stream position: position.	^Failure</body><body package="Xtreams-Parsing">literal: literal	| position |	position := stream position.	[stream read: literal size into: cache at: 1] on: Incomplete do: [stream position: position. ^Failure].	1 to: literal size do: [:i | (cache at: i) == (literal at: i) ifFalse: [stream position: position. ^Failure]].	^literal</body><body package="Xtreams-Parsing">not: expression	| position object |	position := stream position.	object := expression value.	stream position: position.	^object == Failure		ifTrue:	[nil]		ifFalse:	[Failure]</body><body package="Xtreams-Parsing">optional: expression	| object |	^(object := expression value) == Failure		ifTrue:	[nil]		ifFalse:	[object]</body><body package="Xtreams-Parsing">repeat: expression min: min optional: optional	| result object position |	position := stream position.	result := OrderedCollection new: min.	min timesRepeat:		[(object := expression value) == Failure			ifTrue: [stream position: position. ^Failure].		result add: object].	optional timesRepeat:		[position := stream position.		(object := expression value) == Failure			ifTrue: [stream position: position. ^result].		result add: object].	^result</body><body package="Xtreams-Parsing">repeat: expression min: min test: test	| result object position |	position := stream position.	result := OrderedCollection new: min.	min timesRepeat:		[object := test value.		stream position: position.		object == Failure ifFalse: [^Failure].		(object := expression value) == Failure			ifTrue: [stream position: position. ^Failure].		result add: object].	[position := stream position.	test value == Failure] whileTrue:		[stream position: position.		(object := expression value) == Failure			ifTrue: [stream position: position. ^result].		result add: object].	^result</body></methods><methods><class-id>PEG.Parser</class-id> <category>accessing</category><body package="Xtreams-Parsing">caches	^caches</body><body package="Xtreams-Parsing">grammar	^grammar</body></methods><methods><class-id>PEG.Parser</class-id> <category>initialize-release</category><body package="Xtreams-Parsing">bufferSize: aBufferSize	cache size &lt; aBufferSize ifTrue: [cache := String new: aBufferSize]</body><body package="Xtreams-Parsing">clear	caches do: [:each | each become: Dictionary new]</body><body package="Xtreams-Parsing">initialize	grammar := Dictionary new.	cache := String new: 1.	caches := OrderedCollection new</body></methods><methods><class-id>PEG.Parser</class-id> <category>parsing</category><body package="Xtreams-Parsing">parse: definition stream: aStream actor: anActor	"Parse @definition from aStream using @anActor to act on the matching rules.	""	definition	&lt;String&gt;			identifies the rule of the grammar to apply to the input		aStream		&lt;ReadStream&gt;	the input to parse		anActor		&lt;Actor&gt;			receives callbacks from the parser for the successfully rules with the matching the input		^			&lt;Object&gt;		result of the actor action for the @definition	"	| object |	actor := anActor.	stream := aStream reading.	self clear.	object := (grammar at: definition) value.	^object == Failure		ifTrue:	[nil]		ifFalse:	[object]</body><body package="Xtreams-Parsing">validate: definition stream: aStream	actor := nil.	stream := aStream reading.	self clear.	^(grammar at: definition) value ~~ Failure</body></methods><methods><class-id>PEG.Parser class</class-id> <category>instance creation</category><body package="Xtreams-Parsing">new	^super new initialize</body></methods><methods><class-id>PEG.Parser class</class-id> <category>grammars</category><body package="Xtreams-Parsing">grammarCSS3^'/* CSS3 grammar: *//* Tokenization: */ident 				&lt;-	MINUS? nmstart nmchar*name 				&lt;-	nmchar+nmstart 				&lt;-	[a-zA-Z] / UNDERSCORE / nonascii / escape/* The unicode chars larger than \x00FFFF do not produce correct character codes. nonascii 			&lt;-	[\x000080-\x00D7FF] / [\x00E000-\x00FFFD] / [\x010000-\x10FFFF] */nonascii 			&lt;-	[\x000080-\x00D7FF\x00E000-\x00FFFD]unicode 				&lt;-	BACKSLASH [0-9a-fA-F]{1,6} wc?escape 				&lt;-	unicode / BACKSLASH [\x000020-\x00007E\x000080-\x00D7FF\x00E000-\x00FFFD\x010000-\x10FFFF]nmchar 				&lt;-	[a-zA-Z0-9] / MINUS / UNDERSCORE / nonascii / escapenum 				&lt;-	DECIMALDIGIT+ / DECIMALDIGIT* DOT DECIMALDIGIT+string 				&lt;-	DOUBLEQUOTE (stringchar / SINGLEQUOTE)* DOUBLEQUOTE					/	SINGLEQUOTE (stringchar / DOUBLEQUOTE)* SINGLEQUOTEstringchar 			&lt;-	urlchar / [\x000020] / BACKSLASH nlurlchar 				&lt;-	[\x000009\x000021\x000023-\x000026\x000027-\x00007E] / nonascii / escapenl 					&lt;-	[\x00000A] / [\x00000D] [\x00000A] / [\x00000D] / [\x00000C]w 					&lt;-	wc*wc 					&lt;-	[\x000009] / [\x00000A] / [\x00000C] / [\x00000D] / [\x000020]/* CSS3 Tokens: */IDENT 				&lt;-	identATKEYWORD 		&lt;-	AT identSTRING 			&lt;-	stringHASH 				&lt;-	HASHCHAR nameNUMBER 			&lt;-	numPERCENTAGE 		&lt;-	num PERCENTSIGNDIMENSION 			&lt;-	num identURI 				&lt;-	cU cR cL OPEN w (string / urlchar*) w CLOSEUNICODERANGE 	&lt;-	cU PLUS [0-9A-F]{1,6} (MINUS [0-9A-F]{1,6})?CDO 				&lt;-	"&lt;!--"CDC 				&lt;-	"--&gt;"S 					&lt;-	wc+COMMENT 			&lt;-	FORWARDSLASH ASTERISK [^*]* ASTERISK+ ([^/] [^*]* ASTERISK+)* FORWARDSLASHFUNCTION 			&lt;-	ident OPENINCLUDES 			&lt;-	"~="DASHMATCH 		&lt;-	"|="PREFIXMATCH 		&lt;-	"^="SUFFIXMATCH 		&lt;-	"$="SUBSTRINGMATCH 	&lt;-	"*="CHAR 				&lt;-	!(&amp;DOUBLEQUOTE) !(&amp;SINGLEQUOTE) .BOM 				&lt;-	[\x00FEFF] /* CSS2 grammar follows: */stylesheet			&lt;-	(CHARSETSYM STRING SEMICOLON)?						(S / CDO / CDC)* ( import ( CDO S* / CDC S* )* )*						(namespace (S / CDO / CDC)* )*						( ( ruleset / media / page ) ( CDO S* / CDC S* )* )*						S* !.import 				&lt;-	IMPORTSYM S*						(STRING / URI) S* medialist? SEMICOLON S*namespace 			&lt;-	NAMESPACESYM S* (namespaceprefix S*)? (STRING / URI) S*namespaceprefix 	&lt;-	IDENTmedia 				&lt;-	MEDIASYM S* medialist OPENCURLY S* ruleset* CLOSECURLY S*medialist 			&lt;-	medium ( COMMA S* medium)*medium 				&lt;-	IDENT S*page 				&lt;-	PAGESYM S* pseudopage?						OPENCURLY S* declaration? ( SEMICOLON S* declaration? )* CLOSECURLY S*pseudopage 		&lt;-	COLON IDENT S*operator 			&lt;-	FORWARDSLASH S* / COMMA S* /* / EMPTY */combinator 			&lt;-	PLUS S* / GREATER S* /* / EMPTY */unaryoperator 		&lt;-	MINUS / PLUSproperty 			&lt;-	IDENT S*ruleset 				&lt;-	selector (COMMA S* selector)*						OPENCURLY S* (declaration ( SEMICOLON S* declaration? )*)? CLOSECURLY S*selector 				&lt;-	simpleselector (combinator selector / S+ ( combinator? selector )? )?simpleselector 		&lt;-	elementname? ( HASH / class / attrib / pseudo )* S*class 				&lt;-	DOT IDENTelementname 		&lt;-	IDENT / ASTERISKattrib 				&lt;-	OPENSQUARE S* IDENT S* ( ( EQUAL / INCLUDES / DASHMATCH ) S* ( IDENT / STRING ) S* )? CLOSESQUAREpseudo 				&lt;-	COLON ( IDENT / FUNCTION S* (IDENT S*)? CLOSE )declaration 			&lt;-	property COLON S* expr prio?prio 				&lt;-	IMPORTANTSYM S*expr 				&lt;-	term ( operator term )*term 				&lt;-	unaryoperator? (( PERCENTAGE / LENGTH / EMS / EXS / ANGLE / TIME / FREQ / NUMBER ) S* / function)					/	(STRING / IDENT / URI / UNICODERANGE) S*					/	hexcolorfunction 				&lt;-	FUNCTION S* expr CLOSE S*hexcolor 			&lt;-	HASHCHAR h h h					/	HASHCHAR h h h h h h/* Lexical Syntax */h 					&lt;-	[0-9a-fA-F]CHARSETSYM 		&lt;-	AT cC cH cA cR cS cE cTIMPORTSYM 		&lt;-	AT cI cM cP cO cR cTMEDIASYM 			&lt;-	AT cM cE cD cI cAPAGESYM 			&lt;-	AT cP cA cG cEFONTFACESYM 		&lt;-	AT cF cO cN cT DASH cF cA cC cENAMESPACESYM 	&lt;-	AT cN cA cM cE cS cP cA cC cEIMPORTANTSYM 	&lt;-	EXCLAMATION w  cI cM cP cO cR cT cA cN cTEMS 				&lt;-	num cE cMEXS 				&lt;-	num cE cXLENGTH 			&lt;-	num (cP cX / cC cM / cM cM / cI cN / cP cT / cP cC)ANGLE 				&lt;-	num (cD cE cG / cG? cR cA cD)TIME 				&lt;-	num cM? cSFREQ 				&lt;-	num cK? cH cZDIMEN 				&lt;-	num ident/* CSS is case-insensitive. Moreover, letters may be expressed in hex form. cA - cZ definitions address this. */cA 					&lt;-	[aA] / BACKSLASH [0]{0,4} ([46] [1]) nl?cB 					&lt;-	[bB] / BACKSLASH [0]{0,4} ([46] [2]) nl?cC 					&lt;-	[cC] / BACKSLASH [0]{0,4} ([46] [3]) nl?cD 					&lt;-	[dD] / BACKSLASH [0]{0,4} ([46] [4]) nl?cE 					&lt;-	[eE] / BACKSLASH [0]{0,4} ([46] [5]) nl?cF 					&lt;-	[fF] / BACKSLASH [0]{0,4} ([46] [6]) nl?cG 					&lt;-	[gG] / BACKSLASH [0]{0,4} ([46] [7]) nl?cH 					&lt;-	[hH] / BACKSLASH [0]{0,4} ([46] [8]) nl?cI 					&lt;-	[iI] / BACKSLASH [0]{0,4} ([46] [9]) nl?cJ 					&lt;-	[jJ] / BACKSLASH [0]{0,4} ([46] [aA]) nl?cK 					&lt;-	[kK] / BACKSLASH [0]{0,4} ([46] [bB]) nl?cL 					&lt;-	[lL] / BACKSLASH [0]{0,4} ([46] [cC]) nl?cM 					&lt;-	[mM] / BACKSLASH [0]{0,4} ([46] [dD]) nl?cN 					&lt;-	[nN] / BACKSLASH [0]{0,4} ([46] [eE]) nl?cO 					&lt;-	[oO] / BACKSLASH [0]{0,4} ([46] [fF]) nl?cP 					&lt;-	[pP] / BACKSLASH [0]{0,4} ([57] [0]) nl?cQ 					&lt;-	[qQ] / BACKSLASH [0]{0,4} ([57] [1]) nl?cR 					&lt;-	[rR] / BACKSLASH [0]{0,4} ([57] [2]) nl?cS 					&lt;-	[sS] / BACKSLASH [0]{0,4} ([57] [3]) nl?cT 					&lt;-	[tT] / BACKSLASH [0]{0,4} ([57] [4]) nl?cU 					&lt;-	[uU] / BACKSLASH [0]{0,4} ([57] [5]) nl?cV 					&lt;-	[vV] / BACKSLASH [0]{0,4} ([57] [6]) nl?cW 					&lt;-	[wW] / BACKSLASH [0]{0,4} ([57] [7]) nl?cX 					&lt;-	[xX] / BACKSLASH [0]{0,4} ([57] [8]) nl?cY 					&lt;-	[yY] / BACKSLASH [0]{0,4} ([57] [9]) nl?cZ 					&lt;-	[zZ] / BACKSLASH [0]{0,4} ([57] [aA]) nl?AT 					&lt;-	"@"ASTERISK 			&lt;-	"*"BACKSLASH 		&lt;-	"\\"CLOSE 				&lt;-	")"CLOSECURLY 		&lt;-	"}"CLOSESQUARE 		&lt;-	"]"COLON 				&lt;-	":"COMMA 			&lt;-	","DASH 				&lt;-	"-"DECIMALDIGIT 		&lt;-	[0-9]DOT 				&lt;-	"."DOUBLEQUOTE 		&lt;-	"\""EMPTY 				&lt;-	""EQUAL 				&lt;-	"="EXCLAMATION 		&lt;-	"!"FORWARDSLASH 	&lt;-	"/"GREATER 			&lt;-	"&gt;"HASHCHAR 		&lt;-	"#"MINUS 				&lt;-	"-"PERCENTSIGN 		&lt;-	"%"PLUS 				&lt;-	"+"OPEN 				&lt;-	"("OPENCURLY 		&lt;-	"{"OPENSQUARE 		&lt;-	"["s 					&lt;-	WS+SEMICOLON 		&lt;-	";"SINGLEQUOTE 		&lt;-	"''"UNDERSCORE 		&lt;-	"_"w 					&lt;-	s?WS 				&lt;-	[ \t\r\n\x00000C]/* End of file */'</body><body package="Xtreams-Parsing">grammarHttpUrl^'/* This is an example grammar for toying with */Http			&lt;-	HTTP User? Host Port? Components? Query? !.User		&lt;-	Username (COLON Password)? ATPort			&lt;-	COLON [0-9]+Components	&lt;-	(SLASH Component)* SLASH?Host 		&lt;- Ident (DOT Host)?Ident 		&lt;- IdentStart IdentCont*IdentStart 	&lt;- [a-zA-Z]IdentCont 	&lt;- IdentStart / [_0-9] / "-"Query 		&lt;- QUESTION KeyValue (AMP KeyValue)*KeyValue 	&lt;- Key EQUAL Value?Key			&lt;- IdentValue		&lt;- IdentUsername	&lt;- IdentPassword	&lt;- IdentCont+Component	&lt;- Ident (DOT Component)?AMP 		&lt;- "&amp;"AT			&lt;- "@"COLON		&lt;- ":"DOT 		&lt;- "."EQUAL 		&lt;- "="HTTP		&lt;- "http://"QUESTION 	&lt;- "?"SLASH		&lt;- "/"'</body><body package="Xtreams-Parsing">grammarJSON^'object		&lt;-	"{" associations? "}"associations	&lt;-	association ("," association)*association	&lt;-	string ":" valuearray		&lt;-	"[" values? "]"values		&lt;-	value ("," value)*value		&lt;-	string / number / object / array / true / false / nulltrue			&lt;-	"true"false		&lt;-	"false"null			&lt;-	"null"string		&lt;-	["] character{["]}character	&lt;-	"\\" ["\\/bfnrt]			/	"\\u" [0-9A-Fa-f]{4}number		&lt;-	"-"? [0-9]+ ("." [0-9]+)? ([eE] [+-]? [0-9]+)?'</body><body package="Xtreams-Parsing">grammarJavascript^'/* Lexical Grammar *//* SourceCharacter 			&lt;- . *//* WhiteSpace 					&lt;- TAB / VT / FF/ SPACE / NBSP / USP */WhiteSpace 					&lt;- [\s\t\x00000B\x00000C]/* LineTerminator 				&lt;- LF / CR / LS / PS */LineTerminator 				&lt;- LF / CRComment 					&lt;- MultiLineComment 							/ SingleLineCommentMultiLineComment 			&lt;- [/] [*] MultiLineCommentChars? [*] [/] MultiLineCommentChars 		&lt;- MultiLineNotAsteriskChar+ 							/ ASTERISK PostAsteriskCommentChars?PostAsteriskCommentChars 	&lt;- MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars? 							/ ASTERISK PostAsteriskCommentChars?MultiLineNotAsteriskChar 		&lt;- !ASTERISKMultiLineNotForwardSlashOrAsteriskChar 	&lt;- !(FORWARDSLASH / ASTERISK)SingleLineComment 			&lt;- "//" .{[\x00000A\x00000D]}ReservedWord 				&lt;- BooleanLiteral							/ NullLiteral							/ KeywordKeyword 					&lt;- RETURN / BREAK / CASE / CATCH / CONTINUE / DEFAULT / DELETE / DO							/ ELSE / FINALLY / FOR / FUNCTION / IF / IN / INSTANCEOF							/ NEW / SWITCH / THIS / THROW / TRY / TYPEOF							/ VAR / VOID / WHILE / WITHIdentifier 					&lt;- !(ReservedWord (WhiteSpace / Punctuator)) IdentifierNameIdentifierName 				&lt;- IdentifierStart IdentifierPart*IdentifierStart 				&lt;- [A-Za-z$_]							/ BACKSLASH UnicodeEscapeSequenceIdentifierPart 				&lt;- IdentifierStart							/ DecimalDigitHexDigit 					&lt;- [0123456789abcdefABCDEF]Punctuator 					&lt;- "{" / "}" / "(" / ")" / "[" / "]" / "." / SEMICOLON / "," / "&lt;" / "&gt;" / "&lt;=" / "&gt;="							/ "==" / "!=" / "===" / "!==" / "+" / "-" / "*" / PERCENT / "++" / "--" / "&lt;&lt;" / "&gt;&gt;"							/ "&gt;&gt;&gt;" / AMP / VERTICALBAR / "^" / EXCLAMATION / TILDE / (AMP AMP) / "||" / QUESTION / COLON / EQUAL							/ "+=" / "-=" / "*=" / "%=" / "&lt;&lt;=" / "&gt;&gt;=" / "&gt;&gt;&gt;=" / "&amp;=" / "|=" / "^="DivPunctuator 				&lt;- "/" / "/="Literal 						&lt;- NullLiteral							/ BooleanLiteral							/ StringLiteral							/ NumericLiteralNullLiteral 					&lt;- "null"BooleanLiteral 				&lt;- "true" / "false"NumericLiteral 				&lt;- DecimalLiteral							/ HexIntegerLiteralDecimalLiteral 				&lt;- DecimalIntegerLiteral (DOT DecimalDigits?)? ExponentPart?							/ DOT DecimalDigits ExponentPart?							/ DecimalIntegerLiteral ExponentPart?DecimalIntegerLiteral 		&lt;- NonZeroDigit DecimalDigits?							/ [0]DecimalDigits 				&lt;- [0123456789]*NonZeroDigit 				&lt;- [123456789]DecimalDigit 				&lt;- [0123456789]ExponentPart 				&lt;- ExponentIndicator SignedIntegerExponentIndicator 			&lt;- [eE]SignedInteger 				&lt;- (PLUS / MINUS)? DecimalDigitsHexIntegerLiteral 			&lt;- [0] [xX] HexDigit+StringLiteral 					&lt;- DOUBLEQUOTE DoubleStringCharacters? DOUBLEQUOTE							/ SINGLEQUOTE SingleStringCharacters? SINGLEQUOTEDoubleStringCharacters 		&lt;- DoubleStringCharacter+SingleStringCharacters 		&lt;- SingleStringCharacter+DoubleStringCharacter 		&lt;- !(&amp;(DOUBLEQUOTE / BACKSLASH / LineTerminator)) .							/ BACKSLASH EscapeSequenceSingleStringCharacter 		&lt;- !(&amp;(SINGLEQUOTE / BACKSLASH / LineTerminator)) .							/ BACKSLASH EscapeSequenceEscapeSequence 			&lt;- CharacterEscapeSequence							/ HexEscapeSequence							/ UnicodeEscapeSequence							/ [0] &amp;(!DecimalDigit)CharacterEscapeSequence 	&lt;- SingleEscapeCharacter							/ NonEscapeCharacterSingleEscapeCharacter 		&lt;- [\''\"\\bfnrtv]NonEscapeCharacter 		&lt;- !(&amp;(EscapeCharacter / LineTerminator)) .EscapeCharacter 			&lt;- SingleEscapeCharacter							/ DecimalDigit							/ [xu]HexEscapeSequence 		&lt;- [x] HexDigit HexDigitUnicodeEscapeSequence 	&lt;- [u] HexDigit HexDigit HexDigit HexDigitRegularExpressionLiteral 		&lt;- FORWARDSLASH RegularExpressionBody FORWARDSLASH RegularExpressionFlagsRegularExpressionBody 		&lt;- RegularExpressionFirstChar RegularExpressionCharsRegularExpressionChars 		&lt;- RegularExpressionChar*RegularExpressionFirstChar 	&lt;- BackslashSequence							/ !(&amp;(ASTERISK / BACKSLASH / FORWARDSLASH)) NonTerminatorRegularExpressionChar 		&lt;- BackslashSequence							/ !(&amp;(BACKSLASH / FORWARDSLASH)) NonTerminatorBackslashSequence 			&lt;- BACKSLASH NonTerminatorNonTerminator 				&lt;- !(&amp;LineTerminator) .RegularExpressionFlags 		&lt;- IdentifierPart*/* Number Conversions */StringNumericLiteral 			&lt;- StrWhiteSpace? (StrNumericLiteral StrWhiteSpace?)?StrWhiteSpace 				&lt;- StrWhiteSpaceChar StrWhiteSpace?/* This is according to EcmaScript grammar. NBSP, USP, LS &amp; PS - what are their definitions?StrWhiteSpaceChar 			&lt;- TAB / SPACE / NBSP / FF / VT / CR / LF / LS / PS / USP */StrWhiteSpaceChar 			&lt;- TAB / SPACE  / FF / VT / CR / LFStrNumericLiteral 			&lt;- StrDecimalLiteral							/ HexIntegerLiteralStrDecimalLiteral 			&lt;- (PLUS / MINUS)? StrUnsignedDecimalLiteralStrUnsignedDecimalLiteral 	&lt;- INFINITY							/ DecimalDigits (DOT DecimalDigits)? ExponentPart?							/ DOT DecimalDigits ExponentPart?/* Expressions: */PrimaryExpression 			&lt;- ArrayLiteral							/ ObjectLiteral							/ OPEN Expression CLOSE							/ THIS							/ Literal							/ IdentifierArrayLiteral 					&lt;- OPENSQUARE SS ElementList? (COMMA Elision)? SS CLOSESQUAREElementList 					&lt;- Elision? SS AssignmentExpression (Elision? SS AssignmentExpression)*Elision 						&lt;- SS COMMA (SS COMMA)*ObjectLiteral 				&lt;- OPENCURLY SS PropertyNameAndValueList? CLOSECURLY / ObjectLiteralErrorObjectLiteralError			&lt;- OPENCURLY .{CLOSECURLY}PropertyNameAndValueList 	&lt;- (PropertyName SS [:] SS PropertyValue SS)+PropertyValue				&lt;- AssignmentExpression (SS [,] SS PropertyNameAndValueList)?PropertyName 				&lt;- Identifier							/ StringLiteral							/ NumericLiteralMemberExpression 			&lt;- (PrimaryExpression / FunctionExpression) (OPENSQUARE SS Expression SS CLOSESQUARE / DOT Identifier)*							/ NEW SS MemberExpression SS ArgumentsNewExpression 				&lt;- MemberExpression							/ NEW SS NewExpressionCallExpression 				&lt;- MemberExpression SS Arguments (								(SS Arguments								/ OPENSQUARE SS Expression SS CLOSESQUARE								/ DOT Identifier) )*Arguments 					&lt;- OPEN SS (ArgumentList SS)? CLOSEArgumentList 				&lt;- AssignmentExpression (SS COMMA SS AssignmentExpression)*LeftHandSideExpression 		&lt;- CallExpression							/ NewExpressionPostfixExpression 			&lt;- LeftHandSideExpression (WSNT ("++" / "--"))?UnaryExpression 			&lt;- PostfixExpression							/ ( DELETE / VOID / TYPEOF / "++" / "--" / PLUS / MINUS / TILDE / EXCLAMATION ) SS UnaryExpressionMultiplicativeExpression 		&lt;- UnaryExpression (SS (ASTERISK / FORWARDSLASH / PERCENT) SS UnaryExpression)*AdditiveExpression 			&lt;- MultiplicativeExpression (SS (PLUS / MINUS) SS MultiplicativeExpression)*ShiftExpression 				&lt;- AdditiveExpression (SS ("&lt;&lt;" / "&gt;&gt;&gt;" / "&gt;&gt;" ) SS AdditiveExpression)*RelationalExpression 		&lt;- ShiftExpression (SS ("&lt;=" / "&gt;=" / "&lt;" / "&gt;" / INSTANCEOF / IN) SS ShiftExpression)*RelationalExpressionNoIn 	&lt;- ShiftExpression (SS ("&lt;=" / "&gt;=" / "&lt;" / "&gt;" / INSTANCEOF ) SS ShiftExpression)*EqualityExpression 			&lt;- RelationalExpression (SS ("===" / "!===" / "==" / "!=" ) SS RelationalExpression)*EqualityExpressionNoIn 		&lt;- RelationalExpressionNoIn (SS ( "===" / "!===" / "==" / "!=" ) SS RelationalExpressionNoIn)*BitwiseANDExpression 		&lt;- EqualityExpression (SS AMP SS EqualityExpression)*BitwiseANDExpressionNoIn 	&lt;- EqualityExpressionNoIn (SS AMP SS EqualityExpressionNoIn)*BitwiseXORExpression 		&lt;- BitwiseANDExpression (SS "^" SS BitwiseANDExpression)*BitwiseXORExpressionNoIn 	&lt;- BitwiseANDExpressionNoIn (SS "^" SS BitwiseANDExpressionNoIn)*BitwiseORExpression 		&lt;- BitwiseXORExpression (SS VERTICALBAR SS BitwiseXORExpression)*BitwiseORExpressionNoIn 	&lt;- BitwiseXORExpressionNoIn (SS VERTICALBAR SS BitwiseXORExpressionNoIn)*LogicalANDExpression 		&lt;- BitwiseORExpression (SS "&amp;&amp;" SS BitwiseORExpression)*LogicalANDExpressionNoIn 	&lt;- BitwiseORExpressionNoIn (SS "&amp;&amp;" SS BitwiseORExpressionNoIn)*LogicalORExpression 		&lt;- LogicalANDExpression (SS "||" SS LogicalANDExpression)*LogicalORExpressionNoIn 	&lt;- LogicalANDExpressionNoIn (LogicalORExpressionNoIn SS "||" SS LogicalANDExpressionNoIn)*ConditionalExpression 		&lt;- LogicalORExpression (SS QUESTION SS AssignmentExpression SS COLON SS AssignmentExpression)?ConditionalExpressionNoIn 	&lt;- LogicalORExpressionNoIn (SS QUESTION SS AssignmentExpressionNoIn SS COLON SS AssignmentExpressionNoIn)?AssignmentExpression 		&lt;- LeftHandSideExpression SS AssignmentOperator SS AssignmentExpression							/ ConditionalExpressionAssignmentExpressionNoIn 	&lt;- LeftHandSideExpression SS AssignmentOperator SS AssignmentExpressionNoIn							/ ConditionalExpressionNoInAssignmentOperator 			&lt;- EQUAL / "*=" / "/=" / "%=" / "+=" / "-=" / "&lt;&lt;=" / "&gt;&gt;=" / "&gt;&gt;&gt;=" / "&amp;=" / "^=" / "|="Expression 					&lt;- AssignmentExpression (SS COMMA SS AssignmentExpression)*ExpressionNoIn 				&lt;- AssignmentExpressionNoIn (SS COMMA SS AssignmentExpressionNoIn)*/* Statements: */Statement 					&lt;- SS !(&amp;CLOSECURLY) (Block							/ VariableStatement							/ EmptyStatement							/ IfStatement							/ IterationStatement							/ ContinueStatement							/ BreakStatement							/ ReturnStatement							/ WithStatement							/ LabelledStatement							/ SwitchStatement							/ ThrowStatement							/ ExpressionStatement							/ TryStatement)StatementOrError				&lt;- Statement / NoStatementErrorNoStatementError			&lt;- .{EndOfSource / StartOfStatement}Block 						&lt;- OPENCURLY SS (StatementList SS)? CloseBlockCloseBlock					&lt;- CLOSECURLY / CloseBlockErrorCloseBlockError				&lt;- .{CLOSECURLY / EndOfSource}StatementList 				&lt;- Statement+VariableStatement 			&lt;- VAR SS VariableDeclarationList EndOfStatementVariableDeclarationList 		&lt;- VariableDeclaration (SS COMMA SS VariableDeclaration)*VariableDeclarationListNoIn 	&lt;- VariableDeclarationNoIn (SS COMMA SS VariableDeclarationNoIn)*VariableDeclaration 			&lt;- Identifier SS Initialiser?VariableDeclarationNoIn 		&lt;- Identifier SS InitialiserNoIn?Initialiser 					&lt;- EQUAL SS AssignmentExpressionInitialiserNoIn 				&lt;- EQUAL SS AssignmentExpressionNoInEmptyStatement 				&lt;- SEMICOLON SSExpressionStatement 			&lt;- !(&amp;(OPENCURLY / FUNCTION)) Expression EndOfStatementIfStatement 					&lt;- IF SS OPEN SS Expression SS CLOSE SS Statement (SS ELSE SS Statement)?IterationStatement 			&lt;- DoStatement / WhileStatement / ForStatementContinueStatement 			&lt;- CONTINUE WSNT Identifier?BreakStatement 				&lt;- BREAK WSNT Identifier?ReturnStatement 				&lt;- RETURN WSNT Expression?WithStatement 				&lt;- WITH SS OPEN SS Expression SS CLOSE StatementSwitchStatement 				&lt;- SWITCH SS OPEN SS Expression SS CLOSE CaseBlockCaseBlock 					&lt;- OPENCURLY SS (CaseClauses SS)? (DefaultClause SS (CaseClauses SS)?)? CLOSECURLYCaseClauses 				&lt;- CaseClause (SS CaseClause)*CaseClause 					&lt;- CASE SS Expression SS COLON SS StatementList?DefaultClause 				&lt;- DEFAULT SS COLON SS StatementList?LabelledStatement 			&lt;- Identifier SS COLON SS StatementThrowStatement 				&lt;- THROW WSNT Expression EndOfStatementTryStatement 				&lt;- TRY SS Block SS (Catch SS Finally / Catch / Finally)Catch 						&lt;- CATCH SS OPEN SS Identifier SS CLOSE SS BlockFinally 						&lt;- FINALLY SS Block/* Iteration statements */DoStatement					&lt;- DO StatementOrError WhileClause EndOfStatementWhileStatement				&lt;- WhileClause StatementOrErrorForStatement				&lt;- ForClause StatementOrErrorWhileClause					&lt;- SS WHILE SS RestOfWhileClauseRestOfWhileClause			&lt;- OPEN SS Expression SS CLOSE / WhileClauseErrorWhileClauseError			&lt;- OPEN SS CLOSE / .{BRACKET / EndOfSource}ForClause					&lt;- FOR SS RestOfForClauseRestOfForClause				&lt;- OPEN SS ForConditions SS CLOSE / ForClauseErrorForClauseError				&lt;- OPEN SS CLOSE / .{SEMICOLON / BRACKET / EndOfSource}ForConditions				&lt;- ForConditionsVAR / ForConditionsLeft / ForConditionsNoInForConditionsVAR			&lt;- VAR SS (								VariableDeclarationNoIn SS IN Expression								/ VariableDeclarationListNoIn SS SEMICOLON SS Expression? SS SEMICOLON SS Expression?)ForConditionsLeft			&lt;- LeftHandSideExpression SS IN SS ExpressionForConditionsNoIn			&lt;- ExpressionNoIn? SS SEMICOLON SS Expression? SS SEMICOLON SS Expression?								/* Functions and Programs */FunctionDeclaration 			&lt;- SS FUNCTION WhiteSpace+ Identifier SS FunctionDefinitionFunctionExpression 			&lt;- SS FUNCTION (WhiteSpace+ Identifier)? SS FunctionDefinitionFunctionDefinition 			&lt;- SS OpenList SS FormalParameterList? SS CloseList SS OpenFunction SS FunctionBody SS CloseFunctionOpenFunction 				&lt;- OPENCURLY / OpenFunctionErrorOpenFunctionError 			&lt;- .{OPENCURLY / EndOfSource}OpenList 					&lt;- OPEN / OpenListErrorOpenListError 				&lt;- .{OPEN / EndOfSource}CloseFunction				&lt;- CLOSECURLY / CloseFunctionErrorCloseFunctionError			&lt;- .{CLOSECURLY / EndOfSource}CloseList 					&lt;- CLOSE / CloseListErrorCloseListError 				&lt;- .{CLOSE / EndOfSource}FormalParameterList 			&lt;- Identifier (SS COMMA SS Identifier)*FunctionBody 				&lt;- SourceElements?Program 					&lt;- SourceElements SS EndOfSource / ProgramErrorProgramError 				&lt;- .{EndOfSource}SourceElements 				&lt;- SourceElement+SourceElement 				&lt;- FunctionDeclaration / Statement/* Universal Resource Identifier Character Classes */uri 							&lt;- uriCharacters?uriCharacters 				&lt;- uriCharacter+uriCharacter 					&lt;- uriReserved							/ uriUnescaped							/ uriEscapeduriReserved 					&lt;- SEMICOLON / FORWARDSLASH / QUESTION / COLON / AT / AMP / EQUAL / PLUS / DOLLAR / COMMAuriUnescaped 				&lt;- uriAlpha							/ DecimalDigit							/ uriMarkuriEscaped 					&lt;- PERCENT HexDigit HexDigituriAlpha 					&lt;- [a-zA-Z]uriMark 						&lt;- MINUS / UNDERSCORE / DOT / EXCLAMATION / TILDE / ASTERISK / SINGLEQUOTE / OPEN / CLOSE/* Regular Expressions: */Pattern 						&lt;- DisjunctionDisjunction 					&lt;- Alternative (SS VERTICALBAR SS Alternative)*Alternative 					&lt;- (SS Term)*Term 						&lt;- Assertion / Atom Quantifier?Assertion 					&lt;- "^" / DOLLAR / BACKSLASH [bB]Quantifier 					&lt;- QuantifierPrefix QUESTION?QuantifierPrefix 				&lt;- ASTERISK							/ PLUS							/ QUESTION							/ OPENCURLY SS DecimalDigits (SS COMMA (SS DecimalDigits)?)? SS CLOSECURLYAtom 						&lt;- PatternCharacter							/ DOT							/ BACKSLASH AtomEscape							/ CharacterClass							/ OPEN (QUESTION (COLON / EQUAL / EXCLAMATION))? Disjunction CLOSEPatternCharacter 			&lt;- !(&amp;[^$\\.*+?()\[\]{}|]) .AtomEscape 				&lt;- DecimalEscape							/ CharacterEscape							/ CharacterClassEscapeCharacterEscape 			&lt;- ControlEscape							/ "c" ControlLetter							/ HexEscapeSequence							/ UnicodeEscapeSequence							/ IdentityEscapeControlEscape 				&lt;- [fnrtv]ControlLetter 				&lt;- [a-zA-Z]IdentityEscape 				&lt;- !(&amp;IdentifierPart) .DecimalEscape 				&lt;- DecimalIntegerLiteral !(&amp;DecimalDigit)CharacterClassEscape 		&lt;- [dDsSwW]CharacterClass 				&lt;- OPENSQUARE "^"? ClassRanges CLOSESQUAREClassRanges 				&lt;- NonemptyClassRanges?NonemptyClassRanges 		&lt;- ClassAtom (NonemptyClassRangesNoDash / MINUS ClassAtom ClassRanges)NonemptyClassRangesNoDash 	&lt;- ClassAtom							/ ClassAtomNoDash (NonemptyClassRangesNoDash / MINUS ClassAtom ClassRanges)ClassAtom 					&lt;- MINUS							/ ClassAtomNoDashClassAtomNoDash 			&lt;- !(&amp;(BACKSLASH / CLOSESQUARE / MINUS)) .							/ BACKSLASH ClassEscapeClassEscape 				&lt;- DecimalEscape							/ [b]							/ CharacterEscape							/ CharacterClassEscape/* The following are not part of the ECMAScript grammar. They are added for clarity and simplicity of the above grammar rule definitions. */SS 							&lt;- ([\s\t\x00000A\x00000B\x00000C\x00000D] / Comment)*WSNT 						&lt;- (!(&amp;LineTerminator) (WhiteSpace / Comment))*AMP 						&lt;- "&amp;" ASTERISK 					&lt;- "*"AT 							&lt;- "@"BACKSLASH 				&lt;- "\\"BREAK 						&lt;- "break"BRACKET					&lt;- OPEN / OPENCURLY / OPENSQUARE / CLOSE / CLOSECURLY / CLOSESQUARECASE 						&lt;- "case"CATCH 						&lt;- "catch"CLOSE 						&lt;- ")"CLOSECURLY 				&lt;- "}"CLOSESQUARE 				&lt;- "]"COLON 						&lt;- ":"COMMA 					&lt;- ","CONTINUE 					&lt;- "continue"CR 							&lt;- "\x00000D"DEFAULT 					&lt;- "default"DELETE 					&lt;- "delete"DO 							&lt;- "do"DOLLAR 					&lt;- "$"DOT 						&lt;- "."DOUBLEQUOTE 				&lt;- "\""EndOfStatement 				&lt;- SS (EndOfSource / !(&amp;CLOSECURLY) SEMICOLON / &amp;CLOSECURLY SEMICOLON? )StartOfStatement				&lt;- OPENCURLY / VAR / FOR / DO / WITH / SWITCH / THROW / TRY / BRACKET / WHILE / IF / CONTINUE / BREAK / RETURNEndOfSource 				&lt;- !.ELSE 						&lt;- "else"EMPTY 						&lt;- ""EQUAL 						&lt;- "="EXCLAMATION 				&lt;- "!"FF 							&lt;- [\x00000C]FINALLY 					&lt;- "finally"FOR 						&lt;- "for"FORWARDSLASH 			&lt;- "/"FUNCTION 					&lt;- "function"IF 							&lt;- "if"IN 							&lt;- "in"INFINITY 					&lt;- "Infinity"INSTANCEOF 				&lt;- "instanceof"LF 							&lt;- "\x00000A"MINUS 						&lt;- "-"NEW 						&lt;- "new"OPEN 						&lt;- "("OPENCURLY 				&lt;- "{"OPENSQUARE 				&lt;- "["PERCENT 					&lt;- "%"PLUS 						&lt;- "+"QUESTION 					&lt;- "?"RETURN 					&lt;- "return"SEMICOLON 				&lt;- ";"SINGLEQUOTE 				&lt;- "''"SPACE 						&lt;- " "SWITCH 					&lt;- "switch" TAB 						&lt;- [\t]THROW 					&lt;- "throw"THIS 						&lt;- "this"TILDE 						&lt;- "~"TRY 						&lt;- "try"TYPEOF 					&lt;- "typeof"UNDERSCORE 				&lt;- "_"VAR 						&lt;- "var"VERTICALBAR 				&lt;- "|"VOID 						&lt;- "void"VT 							&lt;- "\x00000B"WHILE 						&lt;- "while"WITH 						&lt;- "with"'</body><body package="Xtreams-Parsing">grammarPEG^'Grammar			&lt;-	Definition+ !.Definition			&lt;-	s Identifier s (ASSIGN / DefinitionError) s Expression sDefinitionError		&lt;-	(!S .)*Expression			&lt;-	Sequence ((SLASH s Sequence) / (SequenceError s))*Sequence			&lt;-	Node+SequenceError		&lt;-	SLASHNode				&lt;-	Prefix? Primary Suffix? s					/	!SLASH !(Identifier s ASSIGN) !CLOSE_PAREN !CLOSE_BRACE NodeError sNodeError			&lt;-	.Primary				&lt;-	Reference / Group / Literal / Range / DOTReference			&lt;-	Identifier s !ASSIGNGroup				&lt;-	OPEN_PAREN s Expression s CLOSE_PARENPrefix				&lt;-	AND / NOTSuffix				&lt;-	Cardinality / QUESTION / STAR / PLUSLiteral				&lt;-	QUOTE LiteralEntity{QUOTE}					/	DOUBLE_QUOTE LiteralEntity{DOUBLE_QUOTE}LiteralEntity			&lt;-	Escape / .Range				&lt;-	OPEN_BRACKET s "^"? RangeSet{1,CLOSE_BRACKET}RangeSet			&lt;-	s LiteralEntity DASH LiteralEntity s					/	s LiteralEntity sCardinality			&lt;-	OPEN_BRACE s (CardinalityRange / CardinalityLoopMin / CardinalityRangeMin / CardinalityLoop) s CLOSE_BRACECardinalityRangeMin	&lt;-	NumLiteralCardinalityRange	&lt;-	NumLiteral s COMMA s NumLiteralCardinalityLoopMin	&lt;-	NumLiteral s COMMA s ExpressionCardinalityLoop		&lt;-	ExpressionIdentifier				&lt;-	[a-zA-Z_] [a-zA-Z0-9_]*NumLiteral			&lt;-	"Infinity" / "0" / [1-9] [0-9]*Escape				&lt;-	BACKSLASH [x] [0-9A-F]{6}					/	BACKSLASH [nrts\-\\\[\]\''\"]					/	EscapeErrorEscapeError			&lt;-	BACKSLASH .s					&lt;-	S*S					&lt;-	whitespace+					/	commentcomment			&lt;-	OPEN_COMMENT comment_body{CLOSE_COMMENT}comment_body		&lt;-	comment					/	.whitespace			&lt;-	[\s\t\n\r]ASSIGN				&lt;-	"&lt;-"SLASH				&lt;-	"/"BACKSLASH		&lt;-	"\\"AND				&lt;-	"&amp;"NOT				&lt;-	"!"COMMA				&lt;-	","QUESTION			&lt;-	"?"STAR				&lt;-	"*"PLUS				&lt;-	"+"DASH				&lt;-	"-"DOT				&lt;-	"."QUOTE				&lt;-	"''"DOUBLE_QUOTE	&lt;-	''"''OPEN_BRACKET	&lt;-	"["CLOSE_BRACKET	&lt;-	"]"OPEN_PAREN		&lt;-	"("CLOSE_PAREN		&lt;-	")"OPEN_BRACE		&lt;-	"{"CLOSE_BRACE		&lt;-	"}"OPEN_COMMENT	&lt;-	"/*"CLOSE_COMMENT	&lt;-	"*/"'</body><body package="Xtreams-Parsing">grammarSmalltalk^'/* Lexical Primitives */Token 					&lt;- Number / Keyword / BinarySelector / Identifier / BlockArgument / AssignmentOperator / CharacterConstant / String / SpecialCharacterDigit					&lt;- [0-9] Letter					&lt;- [A-Za-z] BinaryCharacter			&lt;-[+/\\*~&lt;&gt;=@%|&amp;?!,]WhitespaceCharacter 	&lt;- [\t\s\n\r]EndOfMethod 			&lt;- WhitespaceCharacter* !.BACKQUOTE 			&lt;- "`"CLOSE 					&lt;- ")"CLOSECURLY			&lt;- "}"CLOSEPRAGMA 		&lt;- "&gt;"CLOSESQUARE			&lt;- "]"COLON					&lt;- ":"DASH 					&lt;- "-"DOUBLEQUOTE 			&lt;- "\""EQUALS 				&lt;- "="FALSELITERAL			&lt;- "false"HASH 					&lt;- "#"NILLITERAL				&lt;- "nil"OPEN 					&lt;- "("OPENCURLY			&lt;- "{"OPENPRAGMA 			&lt;- "&lt;"OPENSQUARE			&lt;- "["PERIOD 				&lt;- "."RETURN 				&lt;- "^"SELF 					&lt;- "self"SEMICOLON 			&lt;- ";"SINGLEQUOTE 			&lt;- "''"SUPER 					&lt;- "super"THISCONTEXT			&lt;- "thisContext"TRUELITERAL 			&lt;- "true"UNDERSCORE 			&lt;- "_"VERTICALBAR 			&lt;- "|"NonQuoteCharacter		&lt;- Digit / Letter / BinaryCharacter / WhitespaceCharacter / BACKQUOTE / UNDERSCORE / OPEN / CLOSE / OPENSQUARE / CLOSESQUARE / OPENCURLY / CLOSECURLY / RETURN / COLON / SEMICOLON / PERIOD / DASH / HASHDigits 					&lt;- Digit+BigDigits 				&lt;- (Digit / Letter)+Number 					&lt;- Digits ("r" DASH? BigDigits / OptionalFractionAndExponent)NotANumber 			&lt;- !(&amp;Number) TokenOptionalFractionAndExponent &lt;- (PERIOD Digits)? ([eds] DASH? Digits)?ExtendedLetter 			&lt;- Letter / UNDERSCOREIdentifier 				&lt;- ExtendedLetter (ExtendedLetter / Digit)*BlockArgument 			&lt;- Separator? COLON Separator? Identifier / BlockArgumentErrorBlockArgumentError 		&lt;- Separator? (COLON / Identifier) Separator? (COLON / &amp;VERTICALBAR / &amp;CLOSESQUARE / EndOfMethod / !Identifier)AssignmentOperator 		&lt;- ":="Keyword 				&lt;- Identifier COLONBinarySelector 			&lt;- (DASH / BinaryCharacter) (DASH / BinaryCharacter)?UnarySelector 			&lt;- Identifier !COLONCharacterConstant 		&lt;- "$" (NonQuoteCharacter / DOUBLEQUOTE / SINGLEQUOTE)Symbol 					&lt;- Identifier / BinarySelector / Keyword+String 					&lt;- SINGLEQUOTE ((NonQuoteCharacter / SINGLEQUOTE SINGLEQUOTE / DOUBLEQUOTE)* SINGLEQUOTE) / StringErrorStringError 				&lt;- SINGLEQUOTE (NonQuoteCharacter / SINGLEQUOTE SINGLEQUOTE / DOUBLEQUOTE)* !SINGLEQUOTE						/ SINGLEQUOTE NonQuoteCharacter+ SINGLEQUOTE !(&amp;Separator) NonQuoteCharacter+ SINGLEQUOTEComment 				&lt;- DOUBLEQUOTE (NonQuoteCharacter / SINGLEQUOTE)* DOUBLEQUOTE / UnterminatedCommentErrorUnterminatedCommentError 	&lt;- DOUBLEQUOTE (NonQuoteCharacter / SINGLEQUOTE)* !DOUBLEQUOTESeparator 				&lt;- (WhitespaceCharacter / Comment)+SpecialCharacter 		&lt;- [#$@\[\\\]{|}~] / [\x0000A1-\x0000A7\x0000A9-\x0000AE\x0000B0-\x0000B3\x0000B5-\x0000B7\x0000B9-\x0000BF]						/ [\x0000C6\x0000D0\x0000D7\x0000D8\x0000DE\x0000DF\x0000E6\x0000F0\x0000F7\x0000F8\x0000FE]						/ [\x000110\x000111\x000126\x000127\x000131-\x000133\x000138\x00013F\x000140-\x000142\x000149-\x00014B]						/ [\x000152\x000153\x000166\x000167\x002018\x002019\x00201C\x00201D\x0020AC\x002122\x002126\x00215B]						/ [\x00215B-\x00215E\x002190-\x002193\x00266A\x00FC10]/* Atomic Terms */Literal 					&lt;- DASH? Number / NamedLiteral / SymbolLiteral / CharacterConstant / String / ArrayLiteral / ByteArrayLiteral / BindingLiteralNamedLiteral 			&lt;- NILLITERAL / TRUELITERAL / FALSELITERALSymbolLiteral 			&lt;- HASH (Symbol / String) / SymbolErrorSymbolError 				&lt;- HASH !(&amp;(OPEN / OPENSQUARE)) !(Symbol / String)ArrayLiteral 				&lt;- HASH ArrayLiteralBodyArrayLiteralBody 			&lt;- OPEN Separator? ArrayLiteralElement? (Separator ArrayLiteralElement)* Separator? CLOSEArrayLiteralElement		&lt;- (Literal / Symbol / ArrayLiteralBody / ByteArrayLiteralBody)ByteArrayLiteral 			&lt;- HASH ByteArrayLiteralBody / ByteArrayErrorByteArrayLiteralBody 		&lt;- OPENSQUARE ByteArrayNumbers CLOSESQUAREByteArrayNumbers 		&lt;- Separator? Number? (Separator Number)* Separator?ByteArrayError 			&lt;- HASH OPENSQUARE (Separator? (Number Separator)* NotANumber (Separator Number)* Separator? CLOSESQUARE / ByteArrayNumbers !CLOSESQUARE)BindingLiteral 			&lt;- ExtendedBindingName / BindingReferenceBindingName 			&lt;- BindingNameError / !(NamedLiteral / PseudoVariableName / SUPER) IdentifierBindingNameError 		&lt;- Identifier SINGLEQUOTEExtendedBindingName 	&lt;- BindingName (PERIOD BindingName)* / ExtendedBindingErrorExtendedBindingError 	&lt;- ((PERIOD BindingName)+ / (BindingName PERIOD)+ / PERIOD) (Separator / &amp;CLOSECURLY)BindingReference 		&lt;- HASH OPENCURLY Separator? ExtendedBindingName Separator? CLOSECURLY/* Expressions and Statements */Primary 					&lt;- ExtendedBindingName / BindingReference / PseudoVariableName / Literal / BlockConstructor / OPEN Expression CLOSEPseudoVariableName 	&lt;- SELF / THISCONTEXTUnaryMessage 			&lt;- Separator? UnarySelectorBinaryMessage 			&lt;- Separator? BinarySelector Separator? BinaryMessageArgumentBinaryMessageArgument 	&lt;- Primary (Separator UnaryMessage)*KeywordMessage 		&lt;- (Separator? Keyword Separator? KeywordMessageArgument / InvalidKeywordMessageError)+KeywordMessageArgument 	&lt;- Primary (Separator UnaryMessage)* Separator? BinaryMessage*InvalidKeywordMessageError 	&lt;- Keyword Separator? !(&amp;KeywordMessageArgument)CascadedMessages 		&lt;- (Separator? CascadedMessage)*CascadedMessage 		&lt;- CascadeError / SEMICOLON (KeywordMessage / BinaryMessage / UnaryMessage )CascadeError 			&lt;- SEMICOLON !(&amp;(KeywordMessage / BinaryMessage / UnaryMessage))Messages 				&lt;- Separator? (UnaryMessage+ BinaryMessage* KeywordMessage? / BinaryMessage+ KeywordMessage? / KeywordMessage)RestOfExpression 		&lt;- (Messages CascadedMessages)?Expression 				&lt;- (SUPER Messages CascadedMessages / SuperError)						/ (ExtendedBindingName / BindingReference) Separator? (AssignmentOperator Separator? Expression / RestOfExpression) 						/ Keyword EQUALS Expression						/ Primary RestOfExpression						/ ExpressionErrorExpressionError 			&lt;- Separator? AssignmentOperator PERIOD?SuperError 				&lt;- SUPER Separator? !MessagesExpressionList 			&lt;- Expression (PERIOD Expression)* PERIOD?Temporaries 			&lt;- Separator? (VERTICALBAR TemporaryList? VERTICALBAR / TemporariesError)TemporariesError 		&lt;- VERTICALBAR TemporaryList? !VERTICALBARTemporaryList 			&lt;-Separator? Identifier (Separator Identifier)* Separator?DeclaredVariableName 	&lt;- BindingNameStatements 				&lt;- Separator? (ReturnStatement / Expression Separator? (PERIOD Statements)? )?ReturnStatement 			&lt;- RETURN Separator? Expression (PERIOD (Separator? StatementError)?)? / ReturnErrorReturnError 				&lt;- RETURN Separator? (CLOSESQUARE / CLOSE / EndOfMethod)StatementError 			&lt;- (!(&amp;CLOSESQUARE) Token)+ CLOSESQUARE						/ (!(&amp;CLOSE) Token)+ CLOSE						/ Token+ EndOfMethodBlockConstructor 		&lt;- OPENSQUARE Separator? BlockDeclarations? Statements Separator? CLOSESQUARE / UnterminatedBlockErrorUnterminatedBlockError 	&lt;- OPENSQUARE Separator? BlockDeclarations? Separator? (&amp;PERIOD / Statements) Separator? !(&amp;CLOSESQUARE)BlockDeclarations 		&lt;- Temporaries 						/ BlockArgument+ Separator? VERTICALBAR Temporaries?BlockDeclarationError 	&lt;- (COLON Separator?)* BlockArgument? (COLON Separator?)* &amp;VERTICALBAR?/* Methods */Method 					&lt;- Separator? MessagePattern MethodBody Separator? (EndOfMethod / MethodError)MethodBody				&lt;- Pragmas? Temporaries? Statements?						/ Temporaries? Pragmas? Statements?MethodError 				&lt;- .* !.MessagePattern 			&lt;- KeywordPattern / BinaryPattern / UnarySelectorBinaryPattern 			&lt;- BinarySelector Separator MessageArgument / BinaryPatternErrorBinaryPatternError 		&lt;- BinarySelector !(Separator MessageArgument)KeywordPattern 			&lt;- KeywordWithArgument (Separator KeywordWithArgument)* / KeywordPatternErrorKeywordWithArgument 	&lt;- KeywordPatternError / Keyword Separator? MessageArgumentKeywordPatternError 		&lt;- Keyword Separator? Keyword / Keyword !(Separator? MessageArgument)MessageArgument 		&lt;- IdentifierPragma 					&lt;- OPENPRAGMA PragmaBody CLOSEPRAGMA / PragmaErrorPragmaKeyword 			&lt;- Keyword Separator? LiteralPragmaBody 			&lt;- Separator? ((PragmaKeyword (Separator PragmaKeyword)*) / UnarySelector) Separator?PragmaError 			&lt;- OPENPRAGMA (							EndOfMethod							/ Separator? (PragmaKeyword Separator)* (Keyword Separator?)+ Separator? (PragmaKeyword Separator)* Separator? CLOSEPRAGMA?							/ PragmaBody !CLOSEPRAGMA							/ Separator? Token (Separator? !(&amp;CLOSEPRAGMA) Token)* Separator? (CLOSEPRAGMA / EndOfMethod)						)Pragmas 				&lt;- Separator? Pragma (Separator? Pragma)*'</body><body package="Xtreams-Parsing">grammarWiki	"This syntax is variation of google wiki syntax (http://code.google.com/p/support/wiki/WikiSyntax). It is used to mark up the package comments so that they can be turned into web pages. It is important that the mark-up isn't visually obtrusive so that the comments are still comfortably readable.	The three major players in wiki syntax are:		http://code.google.com/p/support/wiki/WikiSyntax		http://en.wikipedia.org/wiki/Help:Wiki_markup		http://c2.com/cgi/wiki?TextFormattingRules	"	^'Page &lt;- (Preformatted / Code / UnorderedList / OrderedList / Heading / Table / Paragraph / Empty)*LineCharacter &lt;- [^\n]Flow &lt;- Escape / Bold / Italic / LinkShort / LinkFull / LineCharacterEscape &lt;- "**" / "__" / "[["Bold &lt;- "*" Flow{"*"}Italic &lt;- "_" Flow{"_"}LinkShort &lt;- "[" .{&amp;[&gt;\]]} "]"LinkFull &lt;- "[" Flow{"&gt;"} .{"]"}Line &lt;- Flow{1,"\n"}Paragraph &lt;- LineEmpty &lt;- "\n"Preformatted &lt;- "---\n" .{"---\n"} Code &lt;- "{{{\n" .{"}}}\n"} Whitespace &lt;- [\t\s]*Heading		&lt;-	Heading4 / Heading3 / Heading2 / Heading1Heading1	&lt;-	Whitespace "= " Flow{" =\n"}Heading2	&lt;-	Whitespace "== " Flow{" ==\n"}Heading3	&lt;-	Whitespace "=== " Flow{" ===\n"}Heading4	&lt;-	Whitespace "==== " Flow{" ====\n"}Bullet1 &lt;-	Whitespace "*" LineBullet2 &lt;-	Whitespace "**" LineBullet3 &lt;-	Whitespace "***" LineUnorderedList &lt;- (UnorderedList2 / Bullet1)+UnorderedList2 &lt;- (UnorderedList3 / Bullet2)+UnorderedList3 &lt;- Bullet3+Hash1 &lt;- Whitespace "#" LineHash2 &lt;- Whitespace "##" LineHash3 &lt;- Whitespace "###" LineOrderedList &lt;- (OrderedList2 / Hash1)+OrderedList2 &lt;- (OrderedList3 / Hash2)+OrderedList3 &lt;- Hash3+Table &lt;-	HeadingRow TableRow*HeadingRow &lt;-	Whitespace "||" HeadingCell{"\n"}HeadingCell	&lt;-	Flow{"||"}TableRow &lt;-	Whitespace "||" Cell{"\n"}Cell	&lt;-	Flow{"||"}'</body><body package="Xtreams-Parsing">grammarXML^'/* Documents */document			&lt;-	prolog element Misc*/* Characters */Char				&lt;-	[\x000001-\x00D7FF \x00E000-\x00FFFD \x010000-\x10FFFF]RestrictedChar		&lt;-	[\x000001-\x000008 \x00000B-\x00000C \x00000E-\x00001F \x00007F-\x000084 \x000086-\x00009F]/* Common Syntactic Constructs */S					&lt;-	[\s\t\r\n]+NameStartChar		&lt;-	[: A-Z _ a-z \x0000C0-\x0000D6 \x0000D8-\x0000F6 \x0000F8-\x0002FF \x000370-\x00037D \x00037F-\x001FFF						\x00200C-\x00200D \x002070-\x00218F \x002C00-\x002FEF \x003001-\x00D7FF \x00F900-\x00FDCF						\x00FDF0-\x00FFFD /* The following range is beyond javascripts character set: \x010000-\x0EFFFF */]NameChar			&lt;-	NameStartChar / [\- . 0-9 \x0000B7 \x000300-\x00036F \x00203F-\x002040]Name				&lt;-	NameStartChar NameChar*Names				&lt;-	Name ("\s" Name)*Nmtoken			&lt;-	NameChar+Nmtokens			&lt;-	Nmtoken ("\s" Nmtoken)*EntityValue			&lt;-	["] ([^%&amp;"] / PEReference / Reference)* ["]					/	[''] ([^%&amp;''] / PEReference / Reference)* ['']AttValue				&lt;-	["] ([^&lt;&amp;"] / Reference)* ["]					/	[''] ([^&lt;&amp;''] / Reference)* ['']SystemLiteral		&lt;-	(["] [^"]* ["]) / ([''] [^'']* [''])PubidLiteral			&lt;-	["] PubidChar{["]} / [''] PubidChar{['']} ['']PubidChar			&lt;-	[\s \n \r a-zA-Z0-9 \-''()+,./:=?;!*#@$_%]/* Character Data and Markup */CharData			&lt;-	[^&lt;&amp;]{"]]&gt;"}/* Comments */Comment			&lt;-	"&lt;!--" Char{"--&gt;"} "--&gt;"/* Processing Instructions */PI					&lt;-	"&lt;?" PITarget (S Char{"?&gt;"})? "?&gt;"PITarget				&lt;-	!([Xx] [Mm] [Ll]) Name/* CData Sections */CDSect				&lt;-	CDStart CData CDEndCDStart				&lt;-	"&lt;![CDATA["CData				&lt;-	Char{CDEnd}CDEnd				&lt;-	"]]&gt;"/* Prolog and Document Type Declaration */prolog				&lt;-	XMLDecl Misc* (doctypedecl Misc*)?XMLDecl			&lt;-	"&lt;?xml" VersionInfo EncodingDecl? SDDecl? S? "?&gt;"VersionInfo			&lt;-	S "version" Eq ([''] VersionNum [''] / ["] VersionNum ["])Eq					&lt;-	S? "=" S?VersionNum			&lt;-	"1.0" / "1.1"Misc				&lt;-	Comment / PI / Sdoctypedecl			&lt;-	"&lt;!DOCTYPE" S Name (S ExternalID)? S? ("[" intSubset "]" S?)? "&gt;"DeclSep				&lt;-	PEReference / SintSubset			&lt;-	(markupdecl / DeclSep)*markupdecl			&lt;-	elementdecl / AttlistDecl / EntityDecl / NotationDecl / PI / CommentextSubset			&lt;-	TextDecl? extSubsetDeclextSubsetDecl		&lt;-	(markupdecl / conditionalSect / DeclSep)*/* Standard Document Declaration */SDDecl				&lt;-	S "standalone" Eq (([''] ("yes" / "no") ['']) / (["] ("yes" / "no") ["]))/* Logical Structures */element				&lt;-	EmptyElemTag					/	STag content ETag/* Start-Tags, End-Tags, Empty-Element Tags */STag				&lt;-	"&lt;" Name (S Attribute)* S? "&gt;"Attribute				&lt;-	Name Eq AttValueETag				&lt;-	"&lt;/" Name S? "&gt;"content				&lt;-	CharData? ((element / Reference / CDSect / PI / Comment / ElementError) CharData?)*EmptyElemTag		&lt;-	"&lt;" Name (S Attribute)* S? "/&gt;"ElementError		&lt;-	!"&lt;/" "&lt;"/* Element Type Declaration */elementdecl			&lt;-	"&lt;!ELEMENT" S Name contentspec S? "&gt;"contentspec			&lt;-	"EMPTY" / "ANY" / Mixed / children/* Element Content */children				&lt;-	(choice / seq) [?*+]?cp					&lt;-	(Name / choice / seq) [?*+]?choice				&lt;-	"(" S? cp (S? "|" S? cp)+ S? ")"seq					&lt;-	"(" S? cp (S? "," S? cp)* S? ")"Mixed				&lt;-	"(" S? "#PCDATA" (S? "|" S? Name)* S? ")*"					/	"(" S? "#PCDATA" S? ")"/* Attribute-List Declaration */AttlistDecl			&lt;-	"&lt;!ATTLIST" S Name AttDef* S? "&gt;"AttDef				&lt;-	S Name AttType S DefaultDeclAttType				&lt;-	StringType / TokenizedType / EnumeratedTypeStringType			&lt;-	"CDATA"TokenizedType		&lt;-	"IDREFS" / "IDREF" / "ID" / "ENTITY" / "ENTITIES" / "NMTOKENS" / "NMTOKEN"EnumeratedType		&lt;-	NotationType / EnumerationNotationType		&lt;-	"NOTATION" S "(" S? Name (S? "|" Name)* S? ")"Enumeration			&lt;-	"(" S? Nmtoken (S? "|" S? Nmtoken)* S? ")"DefaultDecl			&lt;-	"#REQUIRED" / "#IMPLIED" / ("#FIXED" S)? AttValue/* Conditional Sections */conditionalSect		&lt;-	includeSect / ignoreSectincludeSect			&lt;-	"&lt;![" S? "INCLUDE" S? "[" extSubsetDecl "]]&gt;"ignoreSect			&lt;-	"&lt;![" S? "IGNORE" S? "[" ignoreSectContents* "]]&gt;"ignoreSectContents	&lt;-	Ignore ("&lt;![" ignoreSectContents "]]&gt;" Ignore)*Ignore				&lt;-	Char{"&lt;![" / "]]&gt;"}/* Character and Entity References */CharRef				&lt;-	"&amp;#" [0-9]+ ";"					/	"&amp;#x" [0-9 a-f A-F]+ ";"Reference			&lt;-	EntityRef / CharRef / ReferenceErrorEntityRef			&lt;-	"&amp;" Name ";"PEReference		&lt;-	"%" Name ";"ReferenceError		&lt;-	"&amp;"/* Entity Declarations */EntityDecl			&lt;-	GEDecl / PEDeclGEDecl				&lt;-	"&lt;!ENTITY" S Name S EntityDef S? "&gt;"PEDecl				&lt;-	"&lt;!ENTITY" S "%" S Name S PEDef S? "&gt;"EntityDef			&lt;-	EntityValue / (ExternalID NDataDecl?)PEDef				&lt;-	EntityValue / ExternalIDExternalID			&lt;-	"SYSTEM" S SystemLiteral					/	"PUBLIC" S PubidLiteral S SystemLiteralNDataDecl			&lt;-	S "NDATA" S Name/* Parsed Entities */TextDecl			&lt;-	"&lt;?xml" VersionInfo? EncodingDecl S? "?&gt;"extParsedEnt		&lt;-	(TextDecl? content)EncodingDecl		&lt;-	S "encoding" Eq (["] EncName ["] / [''] EncName [''])EncName			&lt;-	[A-Z a-z] [A-Z a-z 0-9 . _ \-]*/* Notation Declarations */NotationDecl			&lt;-	"&lt;!NOTATION" S Name S (ExternalID / PublicID) S? "&gt;"PublicID				&lt;-	"PUBLIC" S PubidLiteral'</body></methods><methods><class-id>PEG.Parser class</class-id> <category>parsers</category><body package="Xtreams-Parsing">parserBootstrap	"WARNING: This method was generated with the following code:		PEG.Parser parserPEG parse: 'Grammar' stream: PEG.Parser grammarPEG actor: PEG.ParserGenerator new	 *** This is circular. You need a working bootstrap to get a PEG parser to then generate source code to generate a PEG parser.	 *** Do not replace this method unless you are 100% sure your new parser code is correct"	| generator definitions |	definitions := OrderedCollection new.	generator := PEG.ParserParser new.	definitions add: (generator Definition: 'Grammar' expression: (generator Sequence: (OrderedCollection new add: (generator Node: (generator Reference: 'Definition') modifier: nil cardinality: generator PLUS); add: (generator Node: generator DOT modifier: generator NOT cardinality: nil); yourself))).	definitions add: (generator Definition: 'Definition' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 's'); add: (generator Reference: 'Identifier'); add: (generator Reference: 's'); add: (generator Expression: (generator Reference: 'ASSIGN') rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Reference: 'DefinitionError')); yourself)); add: (generator Reference: 's'); add: (generator Reference: 'Expression'); add: (generator Reference: 's'); yourself))).	definitions add: (generator Definition: 'DefinitionError' expression: (generator Node: (generator Sequence: (OrderedCollection new add: (generator Node: (generator Reference: 'S') modifier: generator NOT cardinality: nil); add: generator DOT; yourself)) modifier: nil cardinality: generator STAR)).	definitions add: (generator Definition: 'Expression' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'Sequence'); add: (generator Node: (generator Expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'SLASH'); add: (generator Reference: 's'); add: (generator Reference: 'Sequence'); yourself)) rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Sequence: (OrderedCollection new add: (generator Reference: 'SequenceError'); add: (generator Reference: 's'); yourself))); yourself)) modifier: nil cardinality: generator STAR); yourself))).	definitions add: (generator Definition: 'Sequence' expression: (generator Node: (generator Reference: 'Node') modifier: nil cardinality: generator PLUS)).	definitions add: (generator Definition: 'SequenceError' expression: (generator Reference: 'SLASH')).	definitions add: (generator Definition: 'Node' expression: (generator Expression: (generator Sequence: (OrderedCollection new add: (generator Node: (generator Reference: 'Prefix') modifier: nil cardinality: generator QUESTION); add: (generator Reference: 'Primary'); add: (generator Node: (generator Reference: 'Suffix') modifier: nil cardinality: generator QUESTION); add: (generator Reference: 's'); yourself)) rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Sequence: (OrderedCollection new add: (generator Node: (generator Reference: 'SLASH') modifier: generator NOT cardinality: nil); add: (generator Node: (generator Sequence: (OrderedCollection new add: (generator Reference: 'Identifier'); add: (generator Reference: 's'); add: (generator Reference: 'ASSIGN'); yourself)) modifier: generator NOT cardinality: nil); add: (generator Node: (generator Reference: 'CLOSE_PAREN') modifier: generator NOT cardinality: nil); add: (generator Node: (generator Reference: 'CLOSE_BRACE') modifier: generator NOT cardinality: nil); add: (generator Reference: 'NodeError'); add: (generator Reference: 's'); yourself))); yourself))).	definitions add: (generator Definition: 'NodeError' expression: generator DOT).	definitions add: (generator Definition: 'Primary' expression: (generator Expression: (generator Reference: 'Reference') rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Reference: 'Group')); add: (Array with: '/' with: #() with: (generator Reference: 'Literal')); add: (Array with: '/' with: #() with: (generator Reference: 'Range')); add: (Array with: '/' with: #() with: (generator Reference: 'DOT')); yourself))).	definitions add: (generator Definition: 'Reference' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'Identifier'); add: (generator Reference: 's'); add: (generator Node: (generator Reference: 'ASSIGN') modifier: generator NOT cardinality: nil); yourself))).	definitions add: (generator Definition: 'Group' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'OPEN_PAREN'); add: (generator Reference: 's'); add: (generator Reference: 'Expression'); add: (generator Reference: 's'); add: (generator Reference: 'CLOSE_PAREN'); yourself))).	definitions add: (generator Definition: 'Prefix' expression: (generator Expression: (generator Reference: 'AND') rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Reference: 'NOT')); yourself))).	definitions add: (generator Definition: 'Suffix' expression: (generator Expression: (generator Reference: 'Cardinality') rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Reference: 'QUESTION')); add: (Array with: '/' with: #() with: (generator Reference: 'STAR')); add: (Array with: '/' with: #() with: (generator Reference: 'PLUS')); yourself))).	definitions add: (generator Definition: 'Literal' expression: (generator Expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'QUOTE'); add: (generator Node: (generator Reference: 'LiteralEntity') modifier: nil cardinality: (generator CardinalityLoop: (generator Reference: 'QUOTE'))); yourself)) rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Sequence: (OrderedCollection new add: (generator Reference: 'DOUBLE_QUOTE'); add: (generator Node: (generator Reference: 'LiteralEntity') modifier: nil cardinality: (generator CardinalityLoop: (generator Reference: 'DOUBLE_QUOTE'))); yourself))); yourself))).	definitions add: (generator Definition: 'LiteralEntity' expression: (generator Expression: (generator Reference: 'Escape') rest: (OrderedCollection new add: (Array with: '/' with: #() with: generator DOT); yourself))).	definitions add: (generator Definition: 'Range' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'OPEN_BRACKET'); add: (generator Reference: 's'); add: (generator Node: (generator Literal: '^') modifier: nil cardinality: generator QUESTION); add: (generator Node: (generator Reference: 'RangeSet') modifier: nil cardinality: (generator CardinalityLoopMin: 1 test: (generator Reference: 'CLOSE_BRACKET'))); yourself))).	definitions add: (generator Definition: 'RangeSet' expression: (generator Expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 's'); add: (generator Reference: 'LiteralEntity'); add: (generator Reference: 'DASH'); add: (generator Reference: 'LiteralEntity'); add: (generator Reference: 's'); yourself)) rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Sequence: (OrderedCollection new add: (generator Reference: 's'); add: (generator Reference: 'LiteralEntity'); add: (generator Reference: 's'); yourself))); yourself))).	definitions add: (generator Definition: 'Cardinality' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'OPEN_BRACE'); add: (generator Reference: 's'); add: (generator Expression: (generator Reference: 'CardinalityRange') rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Reference: 'CardinalityLoopMin')); add: (Array with: '/' with: #() with: (generator Reference: 'CardinalityRangeMin')); add: (Array with: '/' with: #() with: (generator Reference: 'CardinalityLoop')); yourself)); add: (generator Reference: 's'); add: (generator Reference: 'CLOSE_BRACE'); yourself))).	definitions add: (generator Definition: 'CardinalityRangeMin' expression: (generator Reference: 'NumLiteral')).	definitions add: (generator Definition: 'CardinalityRange' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'NumLiteral'); add: (generator Reference: 's'); add: (generator Reference: 'COMMA'); add: (generator Reference: 's'); add: (generator Reference: 'NumLiteral'); yourself))).	definitions add: (generator Definition: 'CardinalityLoopMin' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'NumLiteral'); add: (generator Reference: 's'); add: (generator Reference: 'COMMA'); add: (generator Reference: 's'); add: (generator Reference: 'Expression'); yourself))).	definitions add: (generator Definition: 'CardinalityLoop' expression: (generator Reference: 'Expression')).	definitions add: (generator Definition: 'Identifier' expression: (generator Sequence: (OrderedCollection new add: (generator Range: nil sets: (OrderedCollection new add: (97 to: 122); add: (65 to: 90); add: (95 to: 95); yourself)); add: (generator Node: (generator Range: nil sets: (OrderedCollection new add: (97 to: 122); add: (65 to: 90); add: (48 to: 57); add: (95 to: 95); yourself)) modifier: nil cardinality: generator STAR); yourself))).	definitions add: (generator Definition: 'NumLiteral' expression: (generator Expression: (generator Literal: 'Infinity') rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Literal: '0')); add: (Array with: '/' with: #() with: (generator Sequence: (OrderedCollection new add: (generator Range: nil sets: (OrderedCollection new add: (49 to: 57); yourself)); add: (generator Node: (generator Range: nil sets: (OrderedCollection new add: (48 to: 57); yourself)) modifier: nil cardinality: generator STAR); yourself))); yourself))).	definitions add: (generator Definition: 'Escape' expression: (generator Expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'BACKSLASH'); add: (generator Range: nil sets: (OrderedCollection new add: (120 to: 120); yourself)); add: (generator Node: (generator Range: nil sets: (OrderedCollection new add: (48 to: 57); add: (65 to: 70); yourself)) modifier: nil cardinality: (generator CardinalityRangeMin: 6)); yourself)) rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Sequence: (OrderedCollection new add: (generator Reference: 'BACKSLASH'); add: (generator Range: nil sets: (OrderedCollection new add: (110 to: 110); add: (114 to: 114); add: (116 to: 116); add: (115 to: 115); add: (45 to: 45); add: (92 to: 92); add: (91 to: 91); add: (93 to: 93); add: (39 to: 39); add: (34 to: 34); yourself)); yourself))); add: (Array with: '/' with: #() with: (generator Reference: 'EscapeError')); yourself))).	definitions add: (generator Definition: 'EscapeError' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'BACKSLASH'); add: generator DOT; yourself))).	definitions add: (generator Definition: 's' expression: (generator Node: (generator Reference: 'S') modifier: nil cardinality: generator STAR)).	definitions add: (generator Definition: 'S' expression: (generator Expression: (generator Node: (generator Reference: 'whitespace') modifier: nil cardinality: generator PLUS) rest: (OrderedCollection new add: (Array with: '/' with: #() with: (generator Reference: 'comment')); yourself))).	definitions add: (generator Definition: 'comment' expression: (generator Sequence: (OrderedCollection new add: (generator Reference: 'OPEN_COMMENT'); add: (generator Node: (generator Reference: 'comment_body') modifier: nil cardinality: (generator CardinalityLoop: (generator Reference: 'CLOSE_COMMENT'))); yourself))).	definitions add: (generator Definition: 'comment_body' expression: (generator Expression: (generator Reference: 'comment') rest: (OrderedCollection new add: (Array with: '/' with: #() with: generator DOT); yourself))).	definitions add: (generator Definition: 'whitespace' expression: (generator Range: nil sets: (OrderedCollection new add: (32 to: 32); add: (9 to: 9); add: (13 to: 13); add: (10 to: 10); yourself))).	definitions add: (generator Definition: 'ASSIGN' expression: (generator Literal: '&lt;-')).	definitions add: (generator Definition: 'SLASH' expression: (generator Literal: '/')).	definitions add: (generator Definition: 'BACKSLASH' expression: (generator Literal: '\')).	definitions add: (generator Definition: 'AND' expression: (generator Literal: '&amp;')).	definitions add: (generator Definition: 'NOT' expression: (generator Literal: '!')).	definitions add: (generator Definition: 'COMMA' expression: (generator Literal: ',')).	definitions add: (generator Definition: 'QUESTION' expression: (generator Literal: '?')).	definitions add: (generator Definition: 'STAR' expression: (generator Literal: '*')).	definitions add: (generator Definition: 'PLUS' expression: (generator Literal: '+')).	definitions add: (generator Definition: 'DASH' expression: (generator Literal: '-')).	definitions add: (generator Definition: 'DOT' expression: (generator Literal: '.')).	definitions add: (generator Definition: 'QUOTE' expression: (generator Literal: '''')).	definitions add: (generator Definition: 'DOUBLE_QUOTE' expression: (generator Literal: '"')).	definitions add: (generator Definition: 'OPEN_BRACKET' expression: (generator Literal: '[')).	definitions add: (generator Definition: 'CLOSE_BRACKET' expression: (generator Literal: ']')).	definitions add: (generator Definition: 'OPEN_PAREN' expression: (generator Literal: '(')).	definitions add: (generator Definition: 'CLOSE_PAREN' expression: (generator Literal: ')')).	definitions add: (generator Definition: 'OPEN_BRACE' expression: (generator Literal: '{')).	definitions add: (generator Definition: 'CLOSE_BRACE' expression: (generator Literal: '}')).	definitions add: (generator Definition: 'OPEN_COMMENT' expression: (generator Literal: '/*')).	definitions add: (generator Definition: 'CLOSE_COMMENT' expression: (generator Literal: '*/')).	^generator Grammar: definitions</body><body package="Xtreams-Parsing">parserPEG	^self parserBootstrap parse: 'Grammar' stream: self grammarPEG reading positioning actor: ParserParser new</body></methods><methods><class-id>PEG.Actor class</class-id> <category>pragmas</category><body package="Xtreams-Parsing">pragmas	&lt;pragmas: #instance&gt;	^#( action: action:arguments: )</body></methods><methods><class-id>PEG.ParserGenerator</class-id> <category>structural</category><body package="Xtreams-Parsing">Definition: identifier expression: expression	&lt;action: 'Definition' arguments: #( 2 6 )&gt;	^'(generator Definition: ', identifier, ' expression: ', expression, ')'</body><body package="Xtreams-Parsing">Expression: first rest: rest	&lt;action: 'Expression' arguments: #( 1 2 )&gt;	rest isEmpty ifTrue: [^first].	^'(generator Expression: ', first, ' rest: ', (self collection: (rest collect: [:each | '(Array with: ''/'' with: #() with: ', each last, ')'])), ')'</body><body package="Xtreams-Parsing">Grammar: definitions	&lt;action: 'Grammar' arguments: #( 1 )&gt;	| stream |	stream := String new writing.	stream		tab; write: '| generator definitions |'; cr;		tab; write: 'definitions := OrderedCollection new.'; cr;		tab; write: 'generator := PEG.ParserParser new.'; cr.	definitions do: [:source | stream tab; write: 'definitions add: '; write: source; write: $.; cr].	stream tab; write: '^generator Grammar: definitions'.	^stream contents</body><body package="Xtreams-Parsing">Group: expression	&lt;action: 'Group' arguments: #( 3 )&gt;	^expression</body><body package="Xtreams-Parsing">Node: primary modifier: modifier cardinality: cardinality	&lt;action: 'Node' arguments: #( 2 1 3 )&gt;	(modifier isNil and: [cardinality isNil]) ifTrue: [^primary].	^'(generator Node: ', primary,		' modifier: ', (modifier ifNil: ['nil'] ifNotNil: [modifier]),		' cardinality: ', (cardinality ifNil: ['nil'] ifNotNil: [cardinality]), ')'</body><body package="Xtreams-Parsing">Sequence: nodes	&lt;action: 'Sequence'&gt;	nodes size = 1 ifTrue: [^nodes first].	^'(generator Sequence: ', (self collection: nodes), ')'</body></methods><methods><class-id>PEG.ParserGenerator</class-id> <category>lexical</category><body package="Xtreams-Parsing">Escape: backslash character: character hexes: hexes	&lt;action: 'Escape' arguments: #( 1 2 3 )&gt;	backslash = '\' ifTrue:		[character = $s ifTrue: [^Character space].		character = $t ifTrue: [^Character tab].		character = $n ifTrue: [^Character cr].		character = $r ifTrue: [^Character lf].		character = $x ifTrue: [^('16r', (String withAll: hexes)) asNumber asCharacter]].	^character</body><body package="Xtreams-Parsing">Identifier: first rest: rest	&lt;action: 'Identifier' arguments: #( 1 2 )&gt;	| stream |	stream := (String new: rest size + 3) writing.	stream put: $'.	stream put: first.	rest notEmpty ifTrue: [stream write: rest].	stream put: $'.	^stream contents</body><body package="Xtreams-Parsing">NumLiteral: digit rest: digits	&lt;action: 'NumLiteral' arguments: #( 1 2 )&gt;	| number |	number := String new writing.	number put: digit.	digits isEmpty ifFalse: [number write: digits].	^number contents</body><body package="Xtreams-Parsing">RangeSet: first to: second	&lt;action: 'RangeSet' arguments: #( 2 4 )&gt;	second ifNil: [^(Interval from: first asInteger to: first asInteger) printString].	^(Interval from: first asInteger to: second asInteger) printString</body></methods><methods><class-id>PEG.ParserGenerator</class-id> <category>terminals</category><body package="Xtreams-Parsing">DOT	&lt;action: 'DOT' arguments: #()&gt;	^'generator DOT'</body><body package="Xtreams-Parsing">Literal: characters	&lt;action: 'Literal' arguments: #( 2 )&gt;	| stream |	stream := String new writing.	stream write: '(generator Literal: '''.	(stream transforming: [:in :out | | each |		each := in get.		each = $' ifTrue: [out put: $'].		out put: each]) write: characters.	stream write: ''')'.	^stream contents</body><body package="Xtreams-Parsing">Range: excluding sets: sets	&lt;action: 'Range' arguments: #( 3 4 )&gt;	^'(generator Range: ', (excluding ifNil: ['nil'] ifNotNil: [excluding]), ' sets: ', (self collection: sets), ')'</body><body package="Xtreams-Parsing">Reference: identifier	&lt;action: 'Reference' arguments: #( 1 )&gt;	^'(generator Reference: ', identifier, ')'</body></methods><methods><class-id>PEG.ParserGenerator</class-id> <category>cardinality</category><body package="Xtreams-Parsing">Cardinality: cardinality	&lt;action: 'Cardinality' arguments: #( 3 )&gt;	^cardinality</body><body package="Xtreams-Parsing">CardinalityLoop: test	&lt;action: 'CardinalityLoop'&gt;	^'(generator CardinalityLoop: ', test, ')'</body><body package="Xtreams-Parsing">CardinalityLoopMin: min test: test	&lt;action: 'CardinalityLoopMin' arguments: #( 1 5 )&gt;	^'(generator CardinalityLoopMin: ', min, ' test: ', test, ')'</body><body package="Xtreams-Parsing">CardinalityRange: min max: max	&lt;action: 'CardinalityRange' arguments: #( 1 5 )&gt;	^'(generator CardinalityRangeMin: ', min, ' max: ', max, ')'</body><body package="Xtreams-Parsing">CardinalityRangeMin: min	&lt;action: 'CardinalityRangeMin'&gt;	^'(generator CardinalityRangeMin: ', min, ')'</body><body package="Xtreams-Parsing">PLUS	&lt;action: 'PLUS' arguments: #()&gt;	^'generator PLUS'</body><body package="Xtreams-Parsing">QUESTION	&lt;action: 'QUESTION' arguments: #()&gt;	^'generator QUESTION'</body><body package="Xtreams-Parsing">STAR	&lt;action: 'STAR' arguments: #()&gt;	^'generator STAR'</body></methods><methods><class-id>PEG.ParserGenerator</class-id> <category>modifiers</category><body package="Xtreams-Parsing">AND	&lt;action: 'AND' arguments: #()&gt;	^'generator AND'</body><body package="Xtreams-Parsing">NOT	&lt;action: 'NOT' arguments: #()&gt;	^'generator NOT'</body></methods><methods><class-id>PEG.ParserParser</class-id> <category>structural</category><body package="Xtreams-Parsing">Definition: identifier expression: expression	&lt;action: 'Definition' arguments: #( 2 6 )&gt;	| cache |	useCache ifFalse: [ ^identifier -&gt; [parser definition: expression name: identifier] ].	parser caches add: (cache := Dictionary new).	^identifier -&gt; [parser definition: expression name: identifier cache: cache]</body><body package="Xtreams-Parsing">Expression: first rest: rest	&lt;action: 'Expression' arguments: #( 1 2 )&gt;	| sequences |	rest isEmpty ifTrue: [^first].	sequences := (Array with: first), (rest collect: [:each | each last]).	^[parser any: sequences]</body><body package="Xtreams-Parsing">Grammar: definitions	&lt;action: 'Grammar' arguments: #( 1 )&gt;	| defines |	defines := Dictionary new.	defines addAll: definitions.	references keysAndValuesDo: [:name :dummy | dummy become: (defines at: name)].	parser grammar addAll: references.	defines keysAndValuesDo: [:name :definition | definition class == Object ifFalse: [parser grammar at: name put: definition]].	^parser</body><body package="Xtreams-Parsing">Group: expression	&lt;action: 'Group' arguments: #( 3 )&gt;	^expression</body><body package="Xtreams-Parsing">Node: primary modifier: modifier cardinality: cardinality	&lt;action: 'Node' arguments: #( 2 1 3 )&gt;	| expression |	expression := primary.	cardinality ifNotNil: [expression := cardinality value: expression].	modifier ifNotNil: [expression := modifier value: expression].	^expression</body><body package="Xtreams-Parsing">Sequence: nodes	&lt;action: 'Sequence'&gt;	nodes size = 1 ifTrue: [^nodes first].	^[parser all: nodes]</body></methods><methods><class-id>PEG.ParserParser</class-id> <category>modifiers</category><body package="Xtreams-Parsing">AND	&lt;action: 'AND' arguments: #()&gt;	^[:expression | [parser explore: expression]]</body><body package="Xtreams-Parsing">NOT	&lt;action: 'NOT' arguments: #()&gt;	^[:expression | [parser not: expression]]</body></methods><methods><class-id>PEG.ParserParser</class-id> <category>lexical</category><body package="Xtreams-Parsing">Escape: backslash character: character hexes: hexes	&lt;action: 'Escape' arguments: #( 1 2 3 )&gt;	backslash = '\' ifTrue:		[character = $s ifTrue: [^Character space].		character = $t ifTrue: [^Character tab].		character = $n ifTrue: [^Character cr].		character = $r ifTrue: [^Character lf].		character = $x ifTrue: [^('16r', (String withAll: hexes)) asNumber asCharacter]].	^character</body><body package="Xtreams-Parsing">Identifier: first rest: rest	&lt;action: 'Identifier' arguments: #( 1 2 )&gt;	| stream |	stream := (String new: rest size + 1) writing.	stream put: first.	rest notEmpty ifTrue: [stream write: rest].	^stream contents</body><body package="Xtreams-Parsing">NumLiteral: digit rest: digits	&lt;action: 'NumLiteral' arguments: #( 1 2 )&gt;	| number |	digit = 'Infinity' ifTrue: [^Infinity positive].	digit = '0' ifTrue: [^0].	number := String new writing.	number put: digit.	digits isEmpty ifFalse: [number write: digits].	^number contents asNumber</body><body package="Xtreams-Parsing">RangeSet: first to: second	&lt;action: 'RangeSet' arguments: #( 2 4 )&gt;	second ifNil: [^Interval from: first asInteger to: first asInteger].	^Interval from: first asInteger to: second asInteger</body></methods><methods><class-id>PEG.ParserParser</class-id> <category>terminals</category><body package="Xtreams-Parsing">DOT	&lt;action: 'DOT' arguments: #()&gt;	^[parser anything]</body><body package="Xtreams-Parsing">Literal: characters	&lt;action: 'Literal' arguments: #( 2 )&gt;	| stream literal |	stream := (String new: characters size) writing.	characters do: [:each | stream put: each].	literal := stream contents.	parser bufferSize: literal size.	^[parser literal: literal]</body><body package="Xtreams-Parsing">Range: excluding sets: sets	&lt;action: 'Range' arguments: #( 3 4 )&gt;	sets isEmpty ifTrue: [		^excluding			ifNil:	[self DOT]			ifNotNil:	[ [parser not: [parser anything]] ]].	^excluding		ifNil:	[ [parser including: sets] ]		ifNotNil:	[ [parser excluding: sets] ]</body><body package="Xtreams-Parsing">Reference: identifier	&lt;action: 'Reference' arguments: #( 1 )&gt;	^references at: identifier ifAbsentPut: [Object new]</body></methods><methods><class-id>PEG.ParserParser</class-id> <category>cardinality</category><body package="Xtreams-Parsing">Cardinality: cardinality	&lt;action: 'Cardinality' arguments: #( 3 )&gt;	^cardinality</body><body package="Xtreams-Parsing">CardinalityLoop: test	&lt;action: 'CardinalityLoop'&gt;	^[:expression | [parser repeat: expression min: 0 test: test]]</body><body package="Xtreams-Parsing">CardinalityLoopMin: min test: test	&lt;action: 'CardinalityLoopMin' arguments: #( 1 5 )&gt;	^[:expression | [parser repeat: expression min: min test: test]]</body><body package="Xtreams-Parsing">CardinalityRange: min max: max	&lt;action: 'CardinalityRange' arguments: #( 1 5 )&gt;	| optional |	optional := max - min.	^(min isZero and: [max = 1])		ifTrue:	[ [:expression | [parser optional: expression]] ]		ifFalse:	[ [:expression | [parser repeat: expression min: min optional: optional]] ]</body><body package="Xtreams-Parsing">CardinalityRangeMin: min	&lt;action: 'CardinalityRangeMin'&gt;	^[:expression | [parser repeat: expression min: min optional: 0]]</body><body package="Xtreams-Parsing">PLUS	&lt;action: 'PLUS' arguments: #()&gt;	^[:expression | [parser repeat: expression min: 1 optional: Infinity positive]]</body><body package="Xtreams-Parsing">QUESTION	&lt;action: 'QUESTION' arguments: #()&gt;	^[:expression | [parser optional: expression]]</body><body package="Xtreams-Parsing">STAR	&lt;action: 'STAR' arguments: #()&gt;	^[:expression | [parser repeat: expression min: 0 optional: Infinity positive]]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>