<?xml version="1.0"?><st-source><!-- Name: Xtreams-IRCNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: {{{	username := 'xtreams', (Random new reading get * 1000000) floor printString.	connection := Xtreams.IRC new.	connection when: #input do: [:command :origin :args |		Transcript cr; nextPutAll: '> '; nextPutAll: command; space; print: args].	connection when: #output do: [:command :origin :args |		Transcript cr; nextPutAll: '< '; nextPutAll: command; space; print: args].	connection when: #PRIVMSG do: [:origin :args |		Transcript			cr; tab; nextPutAll: args first; nextPutAll: ' | ';			nextPutAll: (connection nickname: origin); nextPutAll: ' > '; nextPutAll: args last].	connection when: #PRIVMSG_ACTION do: [:origin :args |		Transcript			cr; tab; nextPutAll: args first; nextPutAll: ' | * ';			nextPutAll: (connection nickname: origin); space; nextPutAll: args last].		connection connect: 'irc.parcplace.net'.	connection login: username realname: 'Xtreams IRC Experiment'.	connection join: '#smalltalk'.		connection part: '#smalltalk'.	connection disconnect.}}}DbIdentifier: bear73DbTrace: 468784DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'Xtreams-Core' '') #(#any 'Xtreams-Parsing' '') #(#any 'Xtreams-Substreams' '') #(#any 'Xtreams-Support' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Terminals' ''))DialectVersion: VisualWorks 7.9PackageName: Xtreams-IRCParcel: #('Xtreams-IRC')PrerequisiteDescriptions: #(#(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Parsing' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package) #(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Core' '') #('Xtreams-Parsing' '') #('Xtreams-Substreams' '') #('Xtreams-Support' '') #('Xtreams-Transforms' '') #('Xtreams-Terminals' ''))PrintStringCache: (8.2 - 0,tkogan)Version: 8.2 - 0Date: 11:27:50 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IRC</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-IRC</package></attributes></class><comment><class-id>Xtreams.IRC</class-id><body>IRC has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.http://www.irchelp.org/irchelp/rfc/rfc2810.txthttp://www.irchelp.org/irchelp/rfc/rfc2811.txthttp://www.irchelp.org/irchelp/rfc/rfc2812.txthttp://www.irchelp.org/irchelp/rfc/rfc2813.txthttp://www.irchelp.org/irchelp/rfc/ctcpspec.htmlhttp://www.mirc.net/raws/Instance Variables	mutex	&lt;Semaphore&gt;	make sure only one process is sending a command at once	output	&lt;WriteStream&gt;	private, output stream to the irc server</body></comment><shared-variable><name>Replies</name><environment>Xtreams.IRC</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Xtreams.IRC initializeReplies</initializer><attributes><package>Xtreams-IRC</package></attributes></shared-variable><methods><class-id>Xtreams.IRC</class-id> <category>commands - misc</category><body package="Xtreams-IRC">kill: nickname comment: comment"   The KILL command is used to cause a client-server connection to be   closed by the server which has the actual connection.  Servers   generate KILL messages on nickname collisions.  It MAY also be   available available to users who have the operator status."	self send: 'KILL' with: nickname text: comment</body><body package="Xtreams-IRC">ping: server1"   The PING command is used to test the presence of an active client or   server at the other end of the connection.  Servers send a PING   message at regular intervals if no other activity detected coming   from a connection.  If a connection fails to respond to a PING   message within a set amount of time, that connection is closed.  A   PING message MAY be sent even if the connection is active."	self send: 'PING' with: server1</body><body package="Xtreams-IRC">ping: server1 and: server2"   The PING command is used to test the presence of an active client or   server at the other end of the connection.  Servers send a PING   message at regular intervals if no other activity detected coming   from a connection.  If a connection fails to respond to a PING   message within a set amount of time, that connection is closed.  A   PING message MAY be sent even if the connection is active."	self send: 'PING' with: server1 with: server2</body><body package="Xtreams-IRC">pong: server1"   PONG message is a reply to ping message.  If parameter &lt;server2&gt; is   given, this message MUST be forwarded to given target.  The &lt;server&gt;   parameter is the name of the entity who has responded to PING message   and generated this message."	self send: 'PONG' with: server1</body><body package="Xtreams-IRC">pong: server1 and: server2"   PONG message is a reply to ping message.  If parameter &lt;server2&gt; is   given, this message MUST be forwarded to given target.  The &lt;server&gt;   parameter is the name of the entity who has responded to PING message   and generated this message."	self send: 'PONG' with: server1 with: server2</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>commands - ctcp</category><body package="Xtreams-IRC">ctcp_clientinfo: target	self send: 'PRIVMSG' ctcp: 'CLIENTINFO' from: nil withArguments: (Array with: target) text: nil</body><body package="Xtreams-IRC">ctcp_finger: target	self send: 'PRIVMSG' ctcp: 'FINGER' from: nil withArguments: (Array with: target) text: nil</body><body package="Xtreams-IRC">ctcp_ping: target	self send: 'PRIVMSG' ctcp: 'PING' from: nil withArguments: (Array with: target) text: nil</body><body package="Xtreams-IRC">ctcp_source: target	self send: 'PRIVMSG' ctcp: 'SOURCE' from: nil withArguments: (Array with: target) text: nil</body><body package="Xtreams-IRC">ctcp_time: target	self send: 'PRIVMSG' ctcp: 'TIME' from: nil withArguments: (Array with: target) text: nil</body><body package="Xtreams-IRC">ctcp_userinfo: target	self send: 'PRIVMSG' ctcp: 'USERINFO' from: nil withArguments: (Array with: target) text: nil</body><body package="Xtreams-IRC">ctcp_version: target	self send: 'PRIVMSG' ctcp: 'VERSION' from: nil withArguments: (Array with: target) text: nil</body><body package="Xtreams-IRC">notice_errmsg: target message: message	self send: 'NOTICE' ctcp: 'ERRMSG' from: nil withArguments: (Array with: target) text: message</body><body package="Xtreams-IRC">notice_ping: target	self send: 'NOTICE' ctcp: 'PING' from: nil withArguments: (Array with: target) text: Timestamp now printString</body><body package="Xtreams-IRC">notice_source: target comment: comment	self send: 'NOTICE' ctcp: 'SOURCE' from: nil withArguments: (Array with: target) text: comment</body><body package="Xtreams-IRC">notice_time: target	self send: 'NOTICE' ctcp: 'TIME' from: nil withArguments: (Array with: target) text: Timestamp now printString</body><body package="Xtreams-IRC">notice_version: target comment: comment	self send: 'NOTICE' ctcp: 'VERSION' from: nil withArguments: (Array with: target) text: comment</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>commands - optional</category><body package="Xtreams-IRC">away: text"  With the AWAY command, clients can set an automatic reply string for   any PRIVMSG commands directed at them (not to a channel they are on).   The server sends an automatic reply to the client sending the PRIVMSG   command.  The only replying server is the one to which the sending   client is connected to."	self send: 'AWAY' text: text</body><body package="Xtreams-IRC">ison: nicknames"   The ISON command was implemented to provide a quick and efficient   means to get a response about whether a given nickname was currently   on IRC. ISON only takes one (1) type of parameter: a space-separated   list of nicks."	self send: 'ISON' withArguments: nicknames</body><body package="Xtreams-IRC">server_connect: target_server port: port"   The CONNECT command can be used to request a server to try to   establish a new connection to another server immediately.  CONNECT is   a privileged command and SHOULD be available only to IRC Operators.   If a &lt;remote server&gt; is given and its mask doesn't match name of the   parsing server, the CONNECT attempt is sent to the first match of   remote server. Otherwise the CONNECT attempt is made by the server   processing the request."	self send: 'CONNECT' with: target_server with: port</body><body package="Xtreams-IRC">server_connect: target_server port: port remote: remote_server"   The CONNECT command can be used to request a server to try to   establish a new connection to another server immediately.  CONNECT is   a privileged command and SHOULD be available only to IRC Operators.   If a &lt;remote server&gt; is given and its mask doesn't match name of the   parsing server, the CONNECT attempt is sent to the first match of   remote server. Otherwise the CONNECT attempt is made by the server   processing the request."	self send: 'CONNECT' with: target_server with: port with: remote_server</body><body package="Xtreams-IRC">server_die"   An operator can use the DIE command to shutdown the server.  This   message is optional since it may be viewed as a risk to allow   arbitrary people to connect to a server as an operator and execute   this command."	self send: 'DIE'</body><body package="Xtreams-IRC">server_rehash"   The rehash command is an administrative command which can be used by   an operator to force the server to re-read and process its   configuration file."	self send: 'REHASH'</body><body package="Xtreams-IRC">server_restart"   An operator can use the restart command to force the server to   restart itself.  This message is optional since it may be viewed as a   risk to allow arbitrary people to connect to a server as an operator   and execute this command, causing (at least) a disruption to service."	self send: 'RESTART'</body><body package="Xtreams-IRC">summon: user"   The SUMMON command can be used to give users who are on a host   running an IRC server a message asking them to please join IRC.  This   message is only sent if the target server (a) has SUMMON enabled, (b)   the user is logged in and (c) the server process can write to the   user's tty (or similar)."	self send: 'SUMMON' with: user</body><body package="Xtreams-IRC">summon: user target: target"   The SUMMON command can be used to give users who are on a host   running an IRC server a message asking them to please join IRC.  This   message is only sent if the target server (a) has SUMMON enabled, (b)   the user is logged in and (c) the server process can write to the   user's tty (or similar)."	self send: 'SUMMON' with: user with: target</body><body package="Xtreams-IRC">summon: user target: target channel: channel"   The SUMMON command can be used to give users who are on a host   running an IRC server a message asking them to please join IRC.  This   message is only sent if the target server (a) has SUMMON enabled, (b)   the user is logged in and (c) the server process can write to the   user's tty (or similar)."	self send: 'SUMMON' with: user with: target with: channel</body><body package="Xtreams-IRC">unaway"  With the AWAY command, clients can set an automatic reply string for   any PRIVMSG commands directed at them (not to a channel they are on).   The server sends an automatic reply to the client sending the PRIVMSG   command.  The only replying server is the one to which the sending   client is connected to."	self send: 'AWAY'</body><body package="Xtreams-IRC">userhost: nicknames"   The USERHOST command takes a list of up to 5 nicknames, each   separated by a space character and returns a list of information   about each nickname that it found.  The returned list has each reply   separated by a space."	self send: 'USERHOST' withArguments: nicknames</body><body package="Xtreams-IRC">users"   The USERS command returns a list of users logged into the server in a   format similar to the UNIX commands who(1), rusers(1) and finger(1).   If disabled, the correct numeric MUST be returned to indicate this."	self send: 'USERS'</body><body package="Xtreams-IRC">users: target"   The USERS command returns a list of users logged into the server in a   format similar to the UNIX commands who(1), rusers(1) and finger(1).   If disabled, the correct numeric MUST be returned to indicate this."	self send: 'USERS' with: target</body><body package="Xtreams-IRC">wallops: text"   The WALLOPS command is used to send a message to all currently   connected users who have set the 'w' user mode for themselves.  (See   Section 3.1.5 User modes)."	self send: 'WALLOPS' textchunks: text</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>private - receiving</category><body package="Xtreams-IRC">messageGrammar^'message	&lt;-	prefix? (command / reply) param* trailing? newlineprefix		&lt;-	":" .{1, space}command	&lt;-	[a-zA-Z]+reply		&lt;-	[0-9]{3}param		&lt;-	space !":" [^\s\n\r]+trailing		&lt;-	space ":" [^\n\r]+space		&lt;-	[\s]newline		&lt;-	[\n\r]'</body><body package="Xtreams-IRC">process: name object: object start: start stop: stop	name = 'message' ifTrue:		[ | command origin parameters |		origin := object at: 1.		command := object at: 2.		parameters := (object at: 4) isNil			ifTrue:	[(object at: 3) asArray]			ifFalse:	[(object at: 3) asArray, (Array with: (object at: 4))].		"Handle CTCP commands in a naive way (don't bother with embedded commands)"		((command = #PRIVMSG or: [command = #NOTICE]) and: [parameters last first = 1 asCharacter]) ifTrue:			[ | textstream text subcommand |			textstream := parameters last reading.			textstream ++ 1.			subcommand := (textstream ending: Character space) rest.			subcommand last = 1 asCharacter ifTrue: [subcommand := subcommand allButLast: 1].			text := (textstream ending: 1 asCharacter) rest.			parameters at: parameters size put: text.			command := (command, '_', subcommand) asSymbol].		self triggerEvent: #input withArguments: (Array with: command with: origin with: parameters).		self triggerEvent: command withArguments: (Array with: origin with: parameters).		^object].	name = 'command' ifTrue: [^(String withAll: object) asSymbol].	name = 'reply' ifTrue:		[ | number |		number := (String withAll: object) asNumber.		number &gt; Replies size ifTrue: [^number printString asSymbol].		^(Replies at: number) ifNil: [number printString asSymbol]].	name = 'trailing' ifTrue: [^String withAll: (object at: 3)].	name = 'prefix' ifTrue: [^String withAll: (object at: 2)].	name = 'param' ifTrue: [^String withAll: (object at: 3)].	^object</body><body package="Xtreams-IRC">receiving: aSocketAccessor encoding: anEncoding	| parser input message |	parser := PEG.Parser parserPEG parse: 'Grammar' stream: self messageGrammar reading positioning actor: PEG.ParserParser new.	input := aSocketAccessor reading encoding: anEncoding.	[message := parser parse: 'message' stream: input positioning actor: self.	message == nil] whileFalse.	output := nil</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>queries - server</category><body package="Xtreams-IRC">admin"   The admin command is used to find information about the administrator   of the given server, or current server if &lt;target&gt; parameter is   omitted.  Each server MUST have the ability to forward ADMIN messages   to other servers."	self send: 'ADMIN'</body><body package="Xtreams-IRC">admin: target"   The admin command is used to find information about the administrator   of the given server, or current server if &lt;target&gt; parameter is   omitted.  Each server MUST have the ability to forward ADMIN messages   to other servers."	self send: 'ADMIN' with: target</body><body package="Xtreams-IRC">info"   The INFO command is REQUIRED to return information describing the   server: its version, when it was compiled, the patchlevel, when it   was started, and any other miscellaneous information which may be   considered to be relevant."	self send: 'INFO'</body><body package="Xtreams-IRC">info: target"   The INFO command is REQUIRED to return information describing the   server: its version, when it was compiled, the patchlevel, when it   was started, and any other miscellaneous information which may be   considered to be relevant."	self send: 'INFO' with: target</body><body package="Xtreams-IRC">links"   With LINKS, a user can list all servernames, which are known by the   server answering the query.  The returned list of servers MUST match   the mask, or if no mask is given, the full list is returned."	self send: 'LINKS'</body><body package="Xtreams-IRC">links: mask"   With LINKS, a user can list all servernames, which are known by the   server answering the query.  The returned list of servers MUST match   the mask, or if no mask is given, the full list is returned."	self send: 'LINKS' with: mask</body><body package="Xtreams-IRC">links: remote_server mask: mask"   With LINKS, a user can list all servernames, which are known by the   server answering the query.  The returned list of servers MUST match   the mask, or if no mask is given, the full list is returned."	self send: 'LINKS' with: remote_server with: mask</body><body package="Xtreams-IRC">lusers"   The LUSERS command is used to get statistics about the size of the   IRC network.  If no parameter is given, the reply will be about the   whole net."	self send: 'LUSERS'</body><body package="Xtreams-IRC">lusers: mask"   The LUSERS command is used to get statistics about the size of the   IRC network.  If no parameter is given, the reply will be about the   whole net."	self send: 'LUSERS' with: mask</body><body package="Xtreams-IRC">lusers: mask server: server"   The LUSERS command is used to get statistics about the size of the   IRC network.  If no parameter is given, the reply will be about the   whole net."	self send: 'LUSERS' with: mask with: server</body><body package="Xtreams-IRC">motd"   The MOTD command is used to get the 'Message Of The Day' of the given   server, or current server if &lt;target&gt; is omitted."	self send: 'MOTD'</body><body package="Xtreams-IRC">motd: target"   The MOTD command is used to get the 'Message Of The Day' of the given   server, or current server if &lt;target&gt; is omitted."	self send: 'MOTD' with: target</body><body package="Xtreams-IRC">stats"   The stats command is used to query statistics of certain server.  If   &lt;query&gt; parameter is omitted, only the end of stats reply is sent   back."	self send: 'STATS'</body><body package="Xtreams-IRC">stats: query"   The stats command is used to query statistics of certain server.  If   &lt;query&gt; parameter is omitted, only the end of stats reply is sent   back."	self send: 'STATS' with: query</body><body package="Xtreams-IRC">stats: query server: server"   The stats command is used to query statistics of certain server.  If   &lt;query&gt; parameter is omitted, only the end of stats reply is sent   back."	self send: 'STATS' with: query with: server</body><body package="Xtreams-IRC">time"   The time command is used to query local time from the specified   server. If the &lt;target&gt; parameter is not given, the server receiving   the command must reply to the query."	self send: 'TIME'</body><body package="Xtreams-IRC">time: target"   The time command is used to query local time from the specified   server. If the &lt;target&gt; parameter is not given, the server receiving   the command must reply to the query."	self send: 'TIME' with: target</body><body package="Xtreams-IRC">trace"   TRACE command is used to find the route to specific server and   information about its peers.  Each server that processes this command   MUST report to the sender about it.  The replies from pass-through   links form a chain, which shows route to destination.  After sending   this reply back, the query MUST be sent to the next server until   given &lt;target&gt; server is reached."	self send: 'TRACE'</body><body package="Xtreams-IRC">trace: target"   TRACE command is used to find the route to specific server and   information about its peers.  Each server that processes this command   MUST report to the sender about it.  The replies from pass-through   links form a chain, which shows route to destination.  After sending   this reply back, the query MUST be sent to the next server until   given &lt;target&gt; server is reached."	self send: 'TRACE' with: target</body><body package="Xtreams-IRC">version"   The VERSION command is used to query the version of the server   program.  An optional parameter &lt;target&gt; is used to query the version   of the server program which a client is not directly connected to."	self send: 'VERSION'</body><body package="Xtreams-IRC">version: target"   The VERSION command is used to query the version of the server   program.  An optional parameter &lt;target&gt; is used to query the version   of the server program which a client is not directly connected to."	self send: 'VERSION' with: target</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>private - sending</category><body package="Xtreams-IRC">send: aCommand	self send: aCommand from: nil withArguments: #() text: nil</body><body package="Xtreams-IRC">send: aCommand ctcp: subCommand from: anOrigin withArguments: anArray text: aText	| buffer |	buffer := String new writing.	anOrigin == nil ifFalse: [buffer write: ':'; write: anOrigin; space].	buffer write: aCommand.	anArray do: [:each | buffer space; write: each].	buffer write: ' :'; put: 1 asCharacter; write: subCommand.	aText == nil ifFalse: [buffer space; write: aText].	buffer write: 1 asCharacter; cr.	buffer position &gt; 512 ifTrue: [self error: 'packet too long, shorten parameters'].	mutex critical: [output write: buffer conclusion].	self		triggerEvent: #output		withArguments: (Array			with: (aCommand, '_', subCommand) asSymbol			with: anOrigin			with: (aText == nil ifTrue: [anArray] ifFalse: [anArray, (Array with: aText)]))</body><body package="Xtreams-IRC">send: aCommand ctcp: subCommand from: anOrigin withArguments: anArray textchunks: aText	| buffer header |	buffer := String new writing.	anOrigin == nil ifFalse: [buffer write: ':'; write: anOrigin; space].	buffer write: aCommand.	anArray do: [:each | buffer space; write: each].	buffer write: ' :'.	header := buffer conclusion.	header size &gt;= (507 - subCommand size) ifTrue: [self error: 'packet too long, shorten parameters'].	(aText reading limiting: (507- subCommand size  - header size)) slicing do: [:textchunkstream |		| textchunk |		textchunk := textchunkstream rest.		mutex critical: [output write: header; put: 1 asCharacter; write: subCommand; space; write: textchunk; put: 1 asCharacter; cr].		self triggerEvent: #output withArguments: (Array with: (aCommand, '_', subCommand) asSymbol with: anOrigin with: (anArray, (Array with: textchunk)))]</body><body package="Xtreams-IRC">send: aCommand from: anOrigin withArguments: anArray text: aText	| buffer |	buffer := String new writing.	anOrigin == nil ifFalse: [buffer write: ':'; write: anOrigin; space].	buffer write: aCommand.	anArray do: [:each | buffer space; write: each].	aText == nil ifFalse: [buffer write: ' :'; write: aText].	buffer cr.	buffer position &gt; 512 ifTrue: [self error: 'packet too long, shorten parameters'].	mutex critical: [output write: buffer conclusion].	self		triggerEvent: #output		withArguments: (Array			with: aCommand			with: anOrigin			with: (aText == nil ifTrue: [anArray] ifFalse: [anArray, (Array with: aText)]))</body><body package="Xtreams-IRC">send: aCommand from: anOrigin withArguments: anArray textchunks: aText	| buffer header |	buffer := String new writing.	anOrigin == nil ifFalse: [buffer write: ':'; write: anOrigin; space].	buffer write: aCommand.	anArray do: [:each | buffer space; write: each].	buffer write: ' :'.	header := buffer conclusion.	header size &gt;= 510 ifTrue: [self error: 'packet too long, shorten parameters'].	(aText reading limiting: (510 - header size)) slicing do: [:textchunkstream |		| textchunk |		textchunk := textchunkstream rest.		mutex critical: [output write: header; write: textchunk; cr].		self triggerEvent: #output withArguments: (Array with: aCommand with: anOrigin with: (anArray, (Array with: textchunk)))]</body><body package="Xtreams-IRC">send: aCommand text: aText	self send: aCommand from: nil withArguments: #() text: aText</body><body package="Xtreams-IRC">send: aCommand textchunks: aText	self send: aCommand from: nil withArguments: #() textchunks: aText</body><body package="Xtreams-IRC">send: aCommand with: arg1	self send: aCommand from: nil withArguments: (Array with: arg1) text: nil</body><body package="Xtreams-IRC">send: aCommand with: arg1 actionchunks: aText	self send: aCommand ctcp: 'ACTION' from: nil withArguments: (Array with: arg1) textchunks: aText</body><body package="Xtreams-IRC">send: aCommand with: arg1 text: aText	self send: aCommand from: nil withArguments: (Array with: arg1) text: aText</body><body package="Xtreams-IRC">send: aCommand with: arg1 textchunks: aText	self send: aCommand from: nil withArguments: (Array with: arg1) textchunks: aText</body><body package="Xtreams-IRC">send: aCommand with: arg1 with: arg2	self send: aCommand from: nil withArguments: (Array with: arg1 with: arg2) text: nil</body><body package="Xtreams-IRC">send: aCommand with: arg1 with: arg2 text: aText	self send: aCommand from: nil withArguments: (Array with: arg1 with: arg2) text: aText</body><body package="Xtreams-IRC">send: aCommand with: arg1 with: arg2 with: arg3	self send: aCommand from: nil withArguments: (Array with: arg1 with: arg2 with: arg3) text: nil</body><body package="Xtreams-IRC">send: aCommand with: arg1 with: arg2 with: arg3 text: aText	self send: aCommand from: nil withArguments: (Array with: arg1 with: arg2 with: arg3) text: aText</body><body package="Xtreams-IRC">send: aCommand withArguments: anArray	self send: aCommand from: nil withArguments: anArray text: nil</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>commands - channel</category><body package="Xtreams-IRC">invite: nickname to: channel"   The INVITE command is used to invite a user to a channel.  The   parameter &lt;nickname&gt; is the nickname of the person to be invited to   the target channel &lt;channel&gt;.  There is no requirement that the   channel the target user is being invited to must exist or be a valid   channel.  However, if the channel exists, only members of the channel   are allowed to invite other users.  When the channel has invite-only   flag set, only channel operators may issue INVITE command."	self send: 'INVITE' with: nickname with: channel</body><body package="Xtreams-IRC">join: channel"   The JOIN command is used by a user to request to start listening to   the specific channel.  Servers MUST be able to parse arguments in the   form of a list of target, but SHOULD NOT use lists when sending JOIN   messages to clients."	self send: 'JOIN' with: channel"	| queue semaphore |	semaphore := Semaphore new.	self when: ('JOIN ', channel) asSymbol send: #signal to: semaphore.	self send: 'JOIN' with: channel.	semaphore wait.	self removeActionsForEvent: ('JOIN ', channel) asSymbol.	queue := SharedQueue new.	self when: ('PRIVMSG ', channel) asSymbol do: [:from :text | queue add: (Array with: from with: text)].	^queue reading"</body><body package="Xtreams-IRC">join: channel password: password"   The JOIN command is used by a user to request to start listening to   the specific channel.  Servers MUST be able to parse arguments in the   form of a list of target, but SHOULD NOT use lists when sending JOIN   messages to clients."	self send: 'JOIN' with: channel with: password</body><body package="Xtreams-IRC">kick: nickname from: channel"   The KICK command can be used to request the forced removal of a user   from a channel.  It causes the &lt;user&gt; to PART from the &lt;channel&gt; by   force.  For the message to be syntactically correct, there MUST be   either one channel parameter and multiple user parameter, or as many   channel parameters as there are user parameters.  If a 'comment' is   given, this will be sent instead of the default message, the nickname   of the user issuing the KICK."	self send: 'KICK' with: nickname with: channel</body><body package="Xtreams-IRC">kick: nickname from: channel reason: reason"   The KICK command can be used to request the forced removal of a user   from a channel.  It causes the &lt;user&gt; to PART from the &lt;channel&gt; by   force.  For the message to be syntactically correct, there MUST be   either one channel parameter and multiple user parameter, or as many   channel parameters as there are user parameters.  If a 'comment' is   given, this will be sent instead of the default message, the nickname   of the user issuing the KICK."	self send: 'KICK' with: nickname with: channel text: reason</body><body package="Xtreams-IRC">list"   The list command is used to list channels and their topics.  If the   &lt;channel&gt; parameter is used, only the status of that channel is   displayed."	self send: 'LIST'</body><body package="Xtreams-IRC">list: channel"   The list command is used to list channels and their topics.  If the   &lt;channel&gt; parameter is used, only the status of that channel is   displayed."	self send: 'LIST' with: channel</body><body package="Xtreams-IRC">names"   By using the NAMES command, a user can list all nicknames that are   visible to him. For more details on what is visible and what is not,   see 'Internet Relay Chat: Channel Management' [IRC-CHAN].  The   &lt;channel&gt; parameter specifies which channel(s) to return information   about.  There is no error reply for bad channel names."	self send: 'NAMES'</body><body package="Xtreams-IRC">names: channel"   By using the NAMES command, a user can list all nicknames that are   visible to him. For more details on what is visible and what is not,   see 'Internet Relay Chat: Channel Management' [IRC-CHAN].  The   &lt;channel&gt; parameter specifies which channel(s) to return information   about.  There is no error reply for bad channel names."	self send: 'NAMES' with: channel</body><body package="Xtreams-IRC">notice: target text: text"   The NOTICE command is used similarly to PRIVMSG.  The difference   between NOTICE and PRIVMSG is that automatic replies MUST NEVER be   sent in response to a NOTICE message.  This rule applies to servers too."	self send: 'NOTICE' with: target textchunks: text</body><body package="Xtreams-IRC">part: channel"   The PART command causes the user sending the message to be removed   from the list of active members for all given channels listed in the   parameter string.  If a 'Part Message' is given, this will be sent   instead of the default message, the nickname.  This request is always   granted by the server."	self send: 'PART' with: channel</body><body package="Xtreams-IRC">privmsg: target action: action"   PRIVMSG is used to send private messages between users, as well as to   send messages to channels.  &lt;msgtarget&gt; is usually the nickname of   the recipient of the message, or a channel name."	self send: 'PRIVMSG' with: target actionchunks: action</body><body package="Xtreams-IRC">privmsg: target text: text"   PRIVMSG is used to send private messages between users, as well as to   send messages to channels.  &lt;msgtarget&gt; is usually the nickname of   the recipient of the message, or a channel name."	self send: 'PRIVMSG' with: target textchunks: text</body><body package="Xtreams-IRC">topic: channel description: description"   The TOPIC command is used to change or view the topic of a channel.   The topic for channel &lt;channel&gt; is returned if there is no &lt;topic&gt;   given.  If the &lt;topic&gt; parameter is present, the topic for that   channel will be changed, if this action is allowed for the user   requesting it.  If the &lt;topic&gt; parameter is an empty string, the   topic for that channel will be removed."	self send: 'TOPIC' with: channel text: description</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>queries - user</category><body package="Xtreams-IRC">nickname: fullname	^(fullname reading ending: $!) rest</body><body package="Xtreams-IRC">who: mask"   The WHO command is used by a client to generate a query which returns   a list of information which 'matches' the &lt;mask&gt; parameter given by   the client.  In the absence of the &lt;mask&gt; parameter, all visible   (users who aren't invisible (user mode +i) and who don't have a   common channel with the requesting client) are listed.  The same   result can be achieved by using a &lt;mask&gt; of 0 or any wildcard which   will end up matching every visible user."	self send: 'WHO' with: mask</body><body package="Xtreams-IRC">who_o: mask"   The WHO command is used by a client to generate a query which returns   a list of information which 'matches' the &lt;mask&gt; parameter given by   the client.  In the absence of the &lt;mask&gt; parameter, all visible   (users who aren't invisible (user mode +i) and who don't have a   common channel with the requesting client) are listed.  The same   result can be achieved by using a &lt;mask&gt; of 0 or any wildcard which   will end up matching every visible user."	self send: 'WHO' with: mask with: 'o'</body><body package="Xtreams-IRC">whois"   This command is used to query information about particular user.   The server will answer this command with several numeric messages   indicating different statuses of each user which matches the mask (if   you are entitled to see them).  If no wildcard is present in the   &lt;mask&gt;, any information about that nick which you are allowed to see   is presented."	self send: 'WHOIS'</body><body package="Xtreams-IRC">whois: target"   This command is used to query information about particular user.   The server will answer this command with several numeric messages   indicating different statuses of each user which matches the mask (if   you are entitled to see them).  If no wildcard is present in the   &lt;mask&gt;, any information about that nick which you are allowed to see   is presented."	self send: 'WHOIS' with: target</body><body package="Xtreams-IRC">whois: target mask: mask"   This command is used to query information about particular user.   The server will answer this command with several numeric messages   indicating different statuses of each user which matches the mask (if   you are entitled to see them).  If no wildcard is present in the   &lt;mask&gt;, any information about that nick which you are allowed to see   is presented."	self send: 'WHOIS' with: target with: mask</body><body package="Xtreams-IRC">whowas: nickname"   Whowas asks for information about a nickname which no longer exists.   This may either be due to a nickname change or the user leaving IRC.   In response to this query, the server searches through its nickname   history, looking for any nicks which are lexically the same (no wild   card matching here).  The history is searched backward, returning the   most recent entry first.  If there are multiple entries, up to   &lt;count&gt; replies will be returned (or all of them if no &lt;count&gt;   parameter is given).  If a non-positive number is passed as being   &lt;count&gt;, then a full search is done."	self send: 'WHOWAS' with: nickname</body><body package="Xtreams-IRC">whowas: nickname count: count"   Whowas asks for information about a nickname which no longer exists.   This may either be due to a nickname change or the user leaving IRC.   In response to this query, the server searches through its nickname   history, looking for any nicks which are lexically the same (no wild   card matching here).  The history is searched backward, returning the   most recent entry first.  If there are multiple entries, up to   &lt;count&gt; replies will be returned (or all of them if no &lt;count&gt;   parameter is given).  If a non-positive number is passed as being   &lt;count&gt;, then a full search is done."	self send: 'WHOWAS' with: nickname with: count</body><body package="Xtreams-IRC">whowas: nickname count: count target: target"   Whowas asks for information about a nickname which no longer exists.   This may either be due to a nickname change or the user leaving IRC.   In response to this query, the server searches through its nickname   history, looking for any nicks which are lexically the same (no wild   card matching here).  The history is searched backward, returning the   most recent entry first.  If there are multiple entries, up to   &lt;count&gt; replies will be returned (or all of them if no &lt;count&gt;   parameter is given).  If a non-positive number is passed as being   &lt;count&gt;, then a full search is done."	self send: 'WHOWAS' with: nickname with: count with: target</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>queries - service</category><body package="Xtreams-IRC">servlist"   The SERVLIST command is used to list services currently connected to   the network and visible to the user issuing the command.  The   optional parameters may be used to restrict the result of the query   (to matching services names, and services type)."	self send: 'SERVLIST'</body><body package="Xtreams-IRC">servlist: mask"   The SERVLIST command is used to list services currently connected to   the network and visible to the user issuing the command.  The   optional parameters may be used to restrict the result of the query   (to matching services names, and services type)."	self send: 'SERVLIST' with: mask</body><body package="Xtreams-IRC">servlist: mask type: type"   The SERVLIST command is used to list services currently connected to   the network and visible to the user issuing the command.  The   optional parameters may be used to restrict the result of the query   (to matching services names, and services type)."	self send: 'SERVLIST' with: mask with: type</body><body package="Xtreams-IRC">squery: servicename text: text"   The SQUERY command is used similarly to PRIVMSG.  The only difference   is that the recipient MUST be a service.  This is the only way for a   text message to be delivered to a service."	self send: 'SQUERY' with: servicename text: text</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>commands - connection</category><body package="Xtreams-IRC">mode: nickname changes: anArray"   The user MODE's are typically changes which affect either how the   client is seen by others or what 'extra' messages the client is sent."	self send: 'MODE' withArguments: (Array with: nickname), anArray</body><body package="Xtreams-IRC">nick: nickname"   NICK command is used to give user a nickname or change the existing   one."	self send: 'NICK' with: nickname</body><body package="Xtreams-IRC">oper: opername password: password"   A normal user uses the OPER command to obtain operator privileges."	self send: 'OPER' with: opername with: password</body><body package="Xtreams-IRC">pass: password"   The PASS command is used to set a 'connection password'.  The   optional password can and MUST be set before any attempt to register   the connection is made.  Currently this requires that user send a   PASS command before sending the NICK/USER combination."	self send: 'PASS' with: password</body><body package="Xtreams-IRC">quit"   A client session is terminated with a quit message.  The server   acknowledges this by sending an ERROR message to the client."	self send: 'QUIT'</body><body package="Xtreams-IRC">service: nickname distribution: distribution type: type info: info"   The SERVICE command to register a new service.  Command parameters   specify the service nickname, distribution, type and info of a new   service."	self send: 'SERVICE' from: nil withArguments: (OrderedCollection new		add: nickname;		add: '*';		add: distribution;		add: type;		add: '0';		yourself) asArray text: info</body><body package="Xtreams-IRC">squit: server comment: comment"   The SQUIT command is available only to operators.  It is used to   disconnect server links.  Also servers can generate SQUIT messages on   error conditions.  A SQUIT message may also target a remote server   connection.  In this case, the SQUIT message will simply be sent to   the remote server without affecting the servers in between the   operator and the remote server."	self command: 'SQUIT' with: server text: comment</body><body package="Xtreams-IRC">user: user mode: mode realname: realname"   The USER command is used at the beginning of connection to specify   the username, hostname and realname of a new user."	self send: 'USER' with: user with: mode with: '*' text: realname</body></methods><methods><class-id>Xtreams.IRC</class-id> <category>connect / disconnect</category><body package="Xtreams-IRC">connect: hostname	self connect: hostname port: 6667</body><body package="Xtreams-IRC">connect: hostname port: port	self connect: hostname port: port encoding: #utf8</body><body package="Xtreams-IRC">connect: hostname port: port encoding: anEncoding	| socket |	output == nil ifFalse: [self error: 'already connected'].	"Handle the PING/PONG challenge"	self when: #PING do: [:origin :args | self pong: args first].	"Respond to various default CTCP requests"	self when: #PRIVMSG_VERSION do: [:origin :args | self notice_version: (self nickname: origin) comment: 'Xtreams IRC Client 0.1'].	self when: #PRIVMSG_SOURCE do: [:origin :args | self notice_source: (self nickname: origin) comment: 'http://www.cincomsmalltalk.com'].	self when: #PRIVMSG_TIME do: [:origin :args | self notice_time: (self nickname: origin)].	self when: #PRIVMSG_PING do: [:origin :args | self notice_ping: (self nickname: origin)].	socket := OS.SocketAccessor newTCPclientToHost: hostname port: port.	mutex := Semaphore forMutualExclusion.	output := (socket writing encoding: anEncoding) setLineEndCRLF.	"The following process will self-terminate when the socket disconnects."	[self receiving: socket encoding: anEncoding] fork		name: 'irc connection to: ', hostname, ':', port printString</body><body package="Xtreams-IRC">disconnect	output == nil ifTrue: [^self].	self quit</body><body package="Xtreams-IRC">login: nickname mode: mode realname: realname	self nick: nickname.	self user: nickname mode: mode realname: realname</body><body package="Xtreams-IRC">login: nickname password: password mode: mode realname: realname	self pass: password.	self nick: nickname.	self user: nickname mode: mode realname: realname</body><body package="Xtreams-IRC">login: nickname realname: realname	self nick: nickname.	self user: nickname mode: '0' realname: realname</body></methods><methods><class-id>Xtreams.IRC class</class-id> <category>private</category><body package="Xtreams-IRC">initializeReplies	^(Array new: 606)		at: 001 put: #RPL_WELCOME;		at: 002 put: #RPL_YOURHOST;		at: 003 put: #RPL_CREATE;		at: 004 put: #RPL_MYINFO;		at: 005 put: #RPL_BOUNCE;		at: 302 put: #RPL_USERHOST;		at: 303 put: #RPL_ISON;		at: 301 put: #RPL_AWAY;		at: 305 put: #RPL_UNAWAY;		at: 306 put: #RPL_NOAWAY;		at: 311 put: #RPL_WHOISUSER;		at: 312 put: #RPL_WHOISSERVER;		at: 313 put: #RPL_WHOISOPERATOR;		at: 317 put: #RPL_WHOISIDLE;		at: 318 put: #RPL_ENDOFWHOIS;		at: 319 put: #RPL_WHOISCHANNELS;		at: 314 put: #RPL_WHOWASUSER;		at: 369 put: #RPL_ENDOFWHOWAS;		at: 321 put: #RPL_LISTSTART;		at: 322 put: #RPL_LIST;		at: 323 put: #RPL_LISTEND;		at: 325 put: #RPL_UNIQOPIS;		at: 324 put: #RPL_CHANNELMODEIS;		at: 331 put: #RPL_NOTOPIC;		at: 332 put: #RPL_TOPIC;		at: 333 put: #RPL_TOPICINFO;		at: 341 put: #RPL_INVITING;		at: 342 put: #RPL_SUMMONING;		at: 346 put: #RPL_INVITELIST;		at: 347 put: #RPL_ENDOFINVITELIST;		at: 348 put: #RPL_EXCEPTLIST;		at: 349 put: #RPL_ENDOFEXCEPTLIST;		at: 351 put: #RPL_VERSION;		at: 352 put: #RPL_WHOREPLY;		at: 315 put: #RPL_ENDOFWHO;		at: 353 put: #RPL_NAMEREPLY;		at: 366 put: #RPL_ENDOFNAMES;				at: 364 put: #RPL_LINKS;		at: 365 put: #RPL_ENDOFLINKS;		at: 367 put: #RPL_BANLIST;		at: 368 put: #RPL_ENDOFBANLIST;		at: 371 put: #RPL_INFO;		at: 374 put: #RPL_ENDOFINFO;		at: 375 put: #RPL_MOTDSTART;		at: 372 put: #RPL_MOTD;		at: 376 put: #RPL_ENDOFMOTD;		at: 381 put: #RPL_YOUREOPER;		at: 382 put: #RPL_REHASHING;		at: 383 put: #RPL_YOURESERVICE;		at: 391 put: #RPL_TIME;		at: 392 put: #RPL_USERSSTART;		at: 393 put: #RPL_USERS;		at: 394 put: #RPL_ENDOFUSERS;		at: 395 put: #RPL_NOUSERS;		at: 200 put: #RPL_TRACELINK;		at: 201 put: #RPL_TRACECONNECTING;		at: 202 put: #RPL_TRACEHANDSHAKE;		at: 203 put: #RPL_TRACEUNKNOWN;		at: 204 put: #RPL_TRACEOPERATOR;		at: 205 put: #RPL_TRACEUSER;		at: 206 put: #RPL_TRACESERVER;		at: 207 put: #RPL_TRACESERVICE;		at: 208 put: #RPL_TRACENEWTYPE;		at: 209 put: #RPL_TRACECLASS;		at: 210 put: #RPL_TRACERECONNET;		at: 261 put: #RPL_TRACELOG;		at: 262 put: #RPL_TRACEEND;		at: 211 put: #RPL_STATSLINKINFO;		at: 212 put: #RPL_STATSCOMMANDS;		at: 219 put: #RPL_ENDOFSTATS;		at: 242 put: #RPL_STATSUPTIME;		at: 243 put: #RPL_STATSOLINE;		at: 265 put: #RPL_STATSLUSERS;		at: 266 put: #RPL_STATSGUSERS;		at: 221 put: #RPL_UMODEIS;		at: 234 put: #RPL_SERVLIST;		at: 235 put: #RPL_SERVLISTEND;		at: 251 put: #RPL_LUSERCLIENT;		at: 252 put: #RPL_LUSEROP;		at: 253 put: #RPL_LUSERUNKNOWN;		at: 254 put: #RPL_LUSERCHANNELS;		at: 255 put: #RPL_LUSERME;		at: 256 put: #RPL_ADMINME;		at: 257 put: #RPL_ADMINLOC1;		at: 258 put: #RPL_ADMINLOC2;		at: 259 put: #RPL_ADMINEMAIL;		at: 263 put: #RPL_TRYAGAIN;		at: 401 put: #ERR_NOSUCHNICK;		at: 402 put: #ERR_NOSUCHSERVER;		at: 403 put: #ERR_NOSUCHCHANNEL;		at: 404 put: #ERR_CANNOTSENDTOCHAN;		at: 405 put: #ERR_TOOMANYCHANNELS;		at: 406 put: #ERR_WASNOSUCHNICK;		at: 407 put: #ERR_TOOMANYTARGETS;		at: 408 put: #ERR_NOSUCHSERVICE;		at: 409 put: #ERR_NOORIGIN;		at: 411 put: #ERR_NORECIPIENT;		at: 412 put: #ERR_NOTEXTTOSEND;		at: 413 put: #ERR_NOTOPLEVEL;		at: 414 put: #ERR_WILDTOPLEVEL;		at: 415 put: #ERR_BADMASK;		at: 421 put: #ERR_UNKNOWNCOMMAND;		at: 422 put: #ERR_NOMOTD;		at: 423 put: #ERR_NOADMININFO;		at: 424 put: #ERR_FILEERROR;		at: 431 put: #ERR_NONICKNAMEGIVEN;		at: 432 put: #ERR_ERRORNEOUSNICKNAME;		at: 433 put: #ERR_NICKNAMEINUSE;		at: 436 put: #ERR_NICKCOLLISION;		at: 437 put: #ERR_UNAVAILRESOURCE;		at: 441 put: #ERR_USERNOTINCHANNEL;		at: 442 put: #ERR_NOTONCHANNEL;		at: 443 put: #ERR_USERONCHANNEL;		at: 444 put: #ERR_NOLOGIN;		at: 445 put: #ERR_SUMMONDISABLED;		at: 446 put: #ERR_USERSDISABLED;		at: 451 put: #ERR_NOTREGISTERED;		at: 461 put: #ERR_NEEDMOREPARAMS;		at: 462 put: #ERR_ALREADYREGISTERED;		at: 463 put: #ERR_NOPERMFORHOST;		at: 464 put: #ERR_PASSWORDMISMATCH;		at: 465 put: #ERR_YOUREBANNECREEP;		at: 466 put: #ERR_YOUWILLBEBANNED;		at: 467 put: #ERR_KEYSET;		at: 471 put: #ERR_CHANNELISFULL;		at: 472 put: #ERR_UNKNOWNMODE;		at: 473 put: #ERR_INVITEONLYCHAN;		at: 474 put: #ERR_BANNEDFROMCHAN;		at: 475 put: #ERR_BADCHANNELKEY;		at: 476 put: #ERR_BADCHANMASK;		at: 477 put: #ERR_NOCHANMODES;		at: 478 put: #ERR_BANLISTFULL;		at: 481 put: #ERR_NO_PRIVILEGES;		at: 482 put: #ERR_CHANOPPRIVSNEEDED;		at: 483 put: #ERR_CANTKILLSERVER;		at: 484 put: #ERR_RESTRICTED;		at: 485 put: #ERR_UNIQOPPRIVSNEEDED;		at: 491 put: #ERR_NOOPERHOST;		at: 501 put: #ERR_UMODEUNKNOWNFLAG;		at: 502 put: #ERR_USERSDONTMATCH;		at: 510 put: #ERR_MUSTRESOLVENICKNAME;		at: 511 put: #ERR_SILENTLISTFULL;		at: 512 put: #ERR_NOSUCHGLINE;		at: 513 put: #ERR_CANNOTHANDLEPINGPONG;		at: 600 put: #RPL_WATCHOFFLINE;		at: 601 put: #RPL_WATCHONLINE;		at: 602 put: #RPL_STOPPEDWATCHING;		at: 603 put: #RPL_WATCHINFO;		at: 604 put: #RPL_WATCHISONLINE;		at: 605 put: #RPL_WATCHISOFFLINE;		at: 606 put: #RPL_WATCH;				"Deprecated, Reserved or non-generic features:"		at: 231 put: #RPL_SERVEINFO;		at: 232 put: #RPL_ENDOFSERVICES;		at: 233 put: #RPL_SERVICE;		at: 300 put: #RPL_NONE;		at: 316 put: #RPL_WHOISCHANOP;		at: 361 put: #RPL_KILLDONE;		at: 362 put: #RPL_CLOSING;		at: 363 put: #RPL_CLOSEEND;		at: 373 put: #RPL_INFOSTART;		at: 384 put: #RPL_MYPORTIS;		at: 213 put: #RPL_STATSCLINE;		at: 214 put: #RPL_STATNCLINE;		at: 215 put: #RPL_STATSILINE;		at: 216 put: #RPL_STATSKLINE;		at: 217 put: #RPL_STATSQLINE;		at: 218 put: #RPL_STATSYLINE;		at: 240 put: #RPL_STATSVLINE;		at: 241 put: #RPL_STATSLLINE;		at: 244 put: #RPL_STATSHLINE;		at: 245 put: #RPL_STATSSLINE;		at: 246 put: #RPL_STATSPING;		at: 247 put: #RPL_STATSBLINE;		at: 250 put: #RPL_STATSDLINE;		at: 492 put: #ERR_NOSERVICEHOST;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>