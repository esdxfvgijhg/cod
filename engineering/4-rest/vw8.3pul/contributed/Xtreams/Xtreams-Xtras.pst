<?xml version="1.0"?><st-source><!-- Name: Xtreams-XtrasNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: This package contains various specialized streams that are not considered part of the core framework.	== CPointers ==The ability to stream over external heap is useful when there's a need to communicate larger amounts of objects of the same type with an external library. A common use case would be when there's a need for a buffer that can be shared between Smalltalk and the external library conveniently. The CPointer stream allows to stream over a buffer allocated on the heap seamlessly as if it is a local smalltalk object. The elements of the stream are instances corresponding to the CType associated with the CPointer.{{{	| buffer |	buffer := CIntegerType unsignedChar malloc: 50.	[	buffer writing			length: 50;			write: 'Hello World!'.		buffer reading			length: 12;			contentsSpecies: ByteString;			rest	] ensure: [ buffer free ]}}}The write streams behave similarly to collection write streams. They know their length and they will automatically attempt to reallocate and grow their heap space if necessary. Similarly closing the write stream will reallocate and shrink the write stream to its position at that time. It is possible to set length of a read stream as well to avoid running past the allocated memory accidentally. The stream will signal Incomplete when it reaches its end.DbIdentifier: bear73DbTrace: 468781DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Substreams' '') #(#any 'Compression-ZLib' '') #(#any 'DLLCC' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #()Namespace: Smalltalk.XtreamsPackageName: Xtreams-XtrasParcel: #('Xtreams-Xtras')ParcelName: Xtreams-XtrasPrerequisiteDescriptions: #(#(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core') #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package) #(#name 'Compression-ZLib' #componentType #package) #(#name 'DLLCC' #componentType #package #applicability #store))PrerequisiteParcels: #(#('Xtreams-Support' '') #('Xtreams-Core' '') #('Xtreams-Transforms' '') #('Xtreams-Substreams' '') #('Compression-ZLib' ''))PrintStringCache: (8.2 - 0,tkogan)Version: 8.2 - 0Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PointerWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>length position contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.CIntegerType.UnsignedChar			private OS.*			</imports><category>My Classes</category><attributes><package>Xtreams-Xtras</package></attributes></class><comment><class-id>Xtreams.PointerWriteStream</class-id><body>Write stream on external heap, commonly used to marshal input for an external library call. The terminal is a CPointer and its associated CType is used to interpret the bytes on the heap. The length of the stream must be set, to avoid writing past the allocated memory space. If more objects are written than can fit in the pre-allocated space, a new larger heap chunk is automatically allocated to accommodate it (the contents of the old chunk are copied over and the chunk is deallocated). Similarly closing the write stream will reallocate and shrink the write stream to its position at that time.{{{	| buffer |	buffer := CIntegerType unsignedChar malloc: 50.	[	buffer writing			length: 50;			write: 'Hello World!'.		buffer reading			length: 12;			contentsSpecies: ByteString;			rest	] ensure: [ buffer free ]}}}Instance Variables	length	&lt;Integer&gt; allocated size of the stream as a number of elements of associated CType	position	&lt;Integer&gt; current position of the stream	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream</body></comment><class><name>PointerReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>length contentsSpecies position </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.CIntegerType.UnsignedChar			</imports><category>My Classes</category><attributes><package>Xtreams-Xtras</package></attributes></class><comment><class-id>Xtreams.PointerReadStream</class-id><body>Read stream on external heap, commonly used to unmarshal output or an external library call. The terminal is a CPointer and its associated CType is used to interpret the bytes on the heap. The length of the stream should be set, to avoid reading past the allocated memory space.{{{	| buffer |	buffer := CIntegerType unsignedChar malloc: 50.	[	buffer writing			length: 50;			write: 'Hello World!'.		buffer reading			length: 12;			contentsSpecies: ByteString;			rest	] ensure: [ buffer free ]}}}Instance Variables	length	&lt;Integer&gt; allocated size of the stream as a number of elements of associated CType	contentsSpecies	&lt;Class&gt; species for collections of elements of this stream	position	&lt;Integer&gt; current position of the stream</body></comment><methods><class-id>Xtreams.PointerWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Xtras">close	self resizeTo: position</body><body package="Xtreams-Xtras">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Xtras">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Xtras">flush</body><body package="Xtreams-Xtras">length: anObject	length := anObject</body><body package="Xtreams-Xtras">on: aPointer	super on: aPointer.	contentsSpecies := Array.	length := 1.	position := 0</body></methods><methods><class-id>Xtreams.PointerWriteStream</class-id> <category>seeking</category><body package="Xtreams-Xtras">++ anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := self available min: anInteger.	position := position + count.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Xtras">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := position min: anInteger.	position := position - count.	count = anInteger ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Xtras">length	^length</body><body package="Xtreams-Xtras">position	^position</body><body package="Xtreams-Xtras">position: aPosition	" Return to a bookmarked position on this stream. "	aPosition &lt; 0 ifTrue: [Incomplete zero raise].	aPosition &gt; length ifFalse: [ ^position := aPosition ].	position := length.	^(Incomplete count: length) raise</body></methods><methods><class-id>Xtreams.PointerWriteStream</class-id> <category>testing</category><body package="Xtreams-Xtras">isPositionable	^true</body></methods><methods><class-id>Xtreams.PointerWriteStream</class-id> <category>private</category><body package="Xtreams-Xtras">copyFrom: aSequenceableCollection size: anInteger startingAt: startIndex	destination type = UnsignedChar		ifTrue: [ 	destination copyAt: position from: aSequenceableCollection size: anInteger startingAt: startIndex. ]		ifFalse: [			0 to: anInteger - 1 do: [ :i |				destination at: position + i put: (aSequenceableCollection at: startIndex + i) ] ]</body><body package="Xtreams-Xtras">resizeTo: anInteger	| replacement beGC |	length = anInteger ifTrue: [^self].	replacement := destination type baseReferentType malloc: anInteger.	OSSystemSupport concreteClass new copyMemoryTo: replacement from: destination size: (length min: anInteger).	beGC := CPointer.GarbageCollectablePointers includes: destination.	destination free.	destination referentAddress: replacement referentAddress.	beGC ifTrue: [destination beGarbageCollectable].	length := anInteger</body></methods><methods><class-id>Xtreams.PointerWriteStream</class-id> <category>accessing</category><body package="Xtreams-Xtras">contents	| cache |	cache := self contentsSpecies withSize: position.	destination copyAt: 0 to: cache size: position startingAt: 1.	^cache</body><body package="Xtreams-Xtras">insert: anInteger from: aSequenceableCollection at: startIndex	| shift |	shift := length - position.	self resizeTo: length + anInteger.	OSSystemSupport concreteClass new copyMemoryTo: destination + position + anInteger from: destination + position size: shift.	self copyFrom: aSequenceableCollection size: anInteger startingAt: startIndex.	position := position + anInteger.	^anInteger</body><body package="Xtreams-Xtras">put: anObject	| free |	free := length - position.	free &lt; 1 ifTrue: [self resizeTo: length + 1].	destination at: position put: anObject.	position := position + 1</body><body package="Xtreams-Xtras">write: anInteger from: aSequenceableCollection at: startIndex	| available |	available := length - position.	available &lt; anInteger ifTrue: [self resizeTo: length + anInteger - available].	self copyFrom: aSequenceableCollection size: anInteger startingAt: startIndex.	position := position + anInteger.	^anInteger</body></methods><methods><class-id>Xtreams.PointerReadStream</class-id> <category>seeking</category><body package="Xtreams-Xtras">++ anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := self available ifNil: [ anInteger ] ifNotNil: [ :available | available min: anInteger ].	position := position + anInteger.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Xtras">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := position min: anInteger.	position := position - count.	count = anInteger ifTrue: [^anInteger].	(Incomplete count: count) raise</body><body package="Xtreams-Xtras">available	^self length ifNotNil: [ super available ]</body><body package="Xtreams-Xtras">length	^length</body><body package="Xtreams-Xtras">position	^position</body><body package="Xtreams-Xtras">position: aPosition	aPosition &lt; 0 ifTrue: [Incomplete zero raise].	length ifNil: [ ^position := aPosition ].	aPosition &gt; length ifFalse: [ ^position := aPosition ].	position := length.	^(Incomplete count: length) raise</body></methods><methods><class-id>Xtreams.PointerReadStream</class-id> <category>testing</category><body package="Xtreams-Xtras">isPositionable	^true</body></methods><methods><class-id>Xtreams.PointerReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Xtras">close</body><body package="Xtreams-Xtras">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Xtras">contentsSpecies: aClass	contentsSpecies := aClass</body><body package="Xtreams-Xtras">length: anObject	length := anObject</body><body package="Xtreams-Xtras">on: aPointer	super on: aPointer.	contentsSpecies := Array.	position := 0</body></methods><methods><class-id>Xtreams.PointerReadStream</class-id> <category>private</category><body package="Xtreams-Xtras">streamingInsertInto: aWriteStream	^length		ifNil: [ self error: 'Cannot stream from an unbounded stream' ]		ifNotNil: [ super streamingInsertInto: aWriteStream ]</body><body package="Xtreams-Xtras">streamingWriteInto: aWriteStream	^length		ifNil: [ self error: 'Cannot stream from an unbounded stream' ]		ifNotNil: [ super streamingWriteInto: aWriteStream ]</body></methods><methods><class-id>Xtreams.PointerReadStream</class-id> <category>accessing</category><body package="Xtreams-Xtras">get	| object |	(length isNil or: [ position &lt; length ]) ifFalse: [ Incomplete zero raise ].	object := source at: position.	position := position + 1.	^object</body><body package="Xtreams-Xtras">read: anInteger into: aSequenceableCollection at: startIndex		| count |	count := self available ifNil: [ anInteger ] ifNotNil: [ :available | available min: anInteger ].	source type referentType = UnsignedChar		ifTrue: [ source copyAt: position to: aSequenceableCollection size: anInteger startingAt: startIndex. ]		ifFalse: [ startIndex to: startIndex + count - 1 do: [ :i | aSequenceableCollection at: i put: self get ] ].	position := position + count.	^count &lt; anInteger		ifTrue: [ (Incomplete on: aSequenceableCollection count: count at: startIndex) raise ]		ifFalse: [ count ]</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>procedures</category><body package="Xtreams-Xtras">copyMemoryTo: destination from: source size: length	self memmove: destination with: source with: length</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="Xtreams-Xtras">depairing	"Transform a stream of associations in to a stream of elements made up of the key and value association components."	^self transforming: [:in :out |		| association |		association := in get.		out put: association key.		out put: association value]</body><body package="Xtreams-Xtras">pairing	"Transform a stream of elements in to a stream of associations between even+odd elements of the stream. This expects the stream to have an even number of elements"	^self transforming: [:in :out | out put: (Association key: in get value: in get)]</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="Xtreams-Xtras">copyMemoryTo: destination from: source size: length	self RtlMoveMemory: destination with: source with: length</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>transforming</category><body package="Xtreams-Xtras">depairing	"Transform a stream of associations in to a stream of elements made up of the key and value association components."	^self transforming: [:in :out |		| association |		association := in get.		out put: association key.		out put: association value]</body><body package="Xtreams-Xtras">pairing	"Transform a stream of elements in to a stream of associations between even+odd elements of the stream. This expects the stream to have an even number of elements"	^self transforming: [:in :out | out put: (Association key: in get value: in get)]</body></methods><methods><class-id>External.CPointer</class-id> <category>converting</category><body package="Xtreams-Xtras">reading	^PointerReadStream on: self</body><body package="Xtreams-Xtras">writing	^PointerWriteStream on: self</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>types</category><body package="Xtreams-Xtras">size_t	&lt;C: typedef unsigned int size_t&gt;</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>procedures</category><body package="Xtreams-Xtras">memmove: s1 with: s2 with: n	&lt;C: void *memmove(void *s1, const void *s2, size_t n)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="Xtreams-Xtras">RtlMoveMemory: Destination with: Source with: Length	&lt;C: void RtlMoveMemory(PVOID Destination, const VOID* Source, SIZE_T Length)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CPointer</name><environment>External</environment><super>External.CDatum</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>UnixSystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.UnixSystemSupportDictionary.*			</imports><category>OS-Unix</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item type="sym">linkedIn</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Unix</package></attributes></class></st-source>