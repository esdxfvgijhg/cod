<?xml version="1.0"?><st-source><!-- Name: SIXX-CoreComment: SIXX 0.3 for VisualWorksCopyright (C) 2002-2009 Masashi Umezawa, Tetsuya Kurihara, Kazuki MinamitaniSIXX is a multi-platform XML serializer/deserializer for Smalltalk. You can exchange various Smalltalk objects among different (dialect) images.<<0.3 Release Note>>http://swikis.ddo.jp/umejava/44<<How to use>>[Basic writing/reading]SIXX is very easy to use. Like #storeString, You can generate a SIXX string by #sixxString.array := Array with: 1 with: 'Hello' with: Date today.array sixxString.This code generates a SIXX string below:'<sixx.object sixx.id="0" sixx.type="Array" >        <sixx.object sixx.id="1" sixx.type="SmallInteger" >1</sixx.object>        <sixx.object sixx.id="2" sixx.type="String" >Hello</sixx.object>        <sixx.object sixx.id="3" sixx.type="Date" >16 June 2002</sixx.object></sixx.object>'This string can be read by #readSixxFrom:.Object readSixxFrom: sixxString. "sixxString is the above string"[Stream writing/reading]SixxWriteStream and SixxReadStream are provided so that you can write/read Smalltalk objects like a binary-object-stream way (BOSS in VW, and the ReferenceStream in Squeak).In order to write objects to an external file, you can:sws := SixxWriteStream newFileNamed: 'obj.sixx'.sws nextPut: <object>.sws nextPutAll: <collection of object>.sws close.And to read objects from an external file:srs := SixxReadStream readOnlyFileNamed: 'obj.sixx'.objects := srs contents.srs close.<<SIXX Hooks>>[Customizing serialization]Object>>sixxPrepareWrite	It is called before the instance is written in SIXX. Object>>sixxWriteValue	Return the object actually serialized.Object>>sixxIgnorableInstVarNames	Specify the instance variables that are not written in SIXX Object>>sixxNonReferencableInstVarNames	Specify the instance variables that should not be referenced in SIXX. Values are always written redundantly. It is useful for small literal objects like String, Number, etc.Object>>sixxReferenceIdInContext:	Return unique id that can be referenced from other objects in SIXX. It is useful when objects have their own unique id.[Customizing deserialization]Object>>sixxInitialize	It is called immediately after the instance is read from SIXX Object>>sixxReadValue	Return the object for the client from the deserialized instance. <<ShapeChanger>>SixxShapeChanger enables you to read "class shape changed" instances. It supports renamed, removed and newly added instance variables.srs := SixxShapeChangeReadStream on: oldSixx readStream.srs shapeChangers at:#SmallIntegerOLD put: SmallInteger . "simple renaming"srs shapeChangers at: #SixxShapeChangedObject put: SixxMockShapeChanger. "You can implement ShapeChanger for more complex conversion."To define a new ShapeChanger, you should subclass base ShapeChanger class and override three methods.YourShapeChanger>>shapeChangedObjectClass	Return a newly introduced class for old instances.YourShapeChanger>>sixxInstVarNamed: varName put: value	Override this method for setting converted values to the shape changed object.YourShapeChanger>>initializeShapeChangedObject	Override this method for setting newly introduced values to the shape changed object.For example: (YourShapeChanger>>sixxInstVarNamed: varName put:)sixxInstVarNamed: varName put: value  "#oldNamedVar1 instance variable was renamed to #renamedAtt1"  varName == #oldNamedVar1 ifTrue: [^self attributesMap at: #renamedAtt1 put: value].  "#oldNamedVar2 inst var was removed."  varName == #oldNamedVar2 ifTrue: [^self].  super sixxInstVarNamed: varName put: valueFrom SIXX 0.3, you can apply ShapeChanger(s) without using SixxShapeChangeReadStream.obj := SixxContext evaluate: [Object readSixxFrom: oldSixx]  shapeChangersBy: [:shapeChangers | shapeChangers at: #SixxShapeChangedObject put: SixxSomeShapeChanger].<<Formatter>>Formatter is a new SIXX function for customizing SIXX format without subclassing.Normally, you can customize SIXX serialization format by overriding hooks such as #sixxWriteValue, #sixxIgnorableInstVarNames. However, sometimes you would like to customize serialization format more dynamically.For example, you may want to change default Array serialization format to compact one, if the array includes only primitive (literal) elements.Suppose there is an array like:array := #(1 2 3 4 5).By default, the array will be sixxed out if you evaluate:array sixxString. "print it"'<sixx.object sixx.id="0" sixx.type="Array" ><sixx.object sixx.id="1" sixx.type="SmallInteger" >1</sixx.object><sixx.object sixx.id="2" sixx.type="SmallInteger" >2</sixx.object><sixx.object sixx.id="3" sixx.type="SmallInteger" >3</sixx.object><sixx.object sixx.id="4" sixx.type="SmallInteger" >4</sixx.object><sixx.object sixx.id="5" sixx.type="SmallInteger" >5</sixx.object></sixx.object>'This format is reasonable for supporting complex array, but the format could be space-consuming if the array contains only primitive (literal) elements. By setting a Formatter, you can use more compact format for Array.SixxContext formatters: {SixxMockLiteralArrayFormatter on: Array}.After that, the format will be:'<sixx.object sixx.id="0" sixx.type="Array" sixx.formatter="SixxMockLiteralArrayFormatter" ><sixx.object sixx.id="1" sixx.type="String" >&#35;&#40;1 2 3 4 5&#41;</sixx.object></sixx.object>'You can reset the formatter by:SixxContext resetFormatters.For convenience, there is a method to switch formatter temporarily.SixxContext applyFormatters: {SixxMockLiteralArrayFormatter on: Array} while: [  array sixxString.]Or, you can even use:SixxContext evaluate: [array sixxString]  formattersBy: [:formatters | formatters add: (SixxMockLiteralArrayFormatter on: Array)].In short, Formatter can be used:- For customizing SIXX format dynamically.- For overriding SIXX format of the existing classes temporarily. <<More info>>http://www.mars.dti.ne.jp/~umejava/smalltalk/sixx/index.htmlHideSource: falsePackageName: SIXX-CoreParcel: #('SIXX-Core')ParcelName: SIXX-CorePrerequisiteParcels: #(#('SIXX-VW' '0.3c'))SaveSource: trueVersion: 8.2-0.3cDate: 10:28:13 AM November 13, 2015 --><time-stamp>From VisualWorksÂ®, 7.10.1 of February 6, 2014 on November 13, 2015 at 10:28:13 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SixxCustomStoreLoadExample</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id cachedData </inst-vars><class-inst-vars>instances cachedData </class-inst-vars><imports></imports><category>SIXX-Examples</category><attributes><package>SIXX-Core</package></attributes></class><comment><class-id>Sixx.SixxCustomStoreLoadExample</class-id><body>I am an example of SIXX custom serialization.SIXX normally writes/reads all attribute values (instance variables).But sometimes this behavior is not appropriate. For example, I would like to omit writing/reading a "cachedData" value, because it is only a cache.By overriding hook methods below, you can customize what attributes are written or read.(instance methods)#sixxContentOn: aStream indent: level context: dictionary (for writing)#sixxInstVarNamed: instVarName put: aValue (for reading)(class methods)#createInstanceOf: aClass withSixxElement: sixxElement (for writing)(This method is not overridden in me. It is useful for variable objects. See implementors.)---MU 6/14/2002 11:12</body></comment><class><name>SixxSettings</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>useCDATA useEnvironment useRecoveryRead useNCR suppressNilWrite </class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxXmlParseError</name><environment>Sixx</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalError </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxWarning</name><environment>Sixx</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className element context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxInvalidDeserialization</name><environment>Sixx</environment><super>Sixx.SixxWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxConstants</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xmlVersion xmlEncoding sixxVersion xmlDeclaration </inst-vars><class-inst-vars>current </class-inst-vars><imports>			private Sixx.ConstantsDetectionMap.*			private Sixx.ConstantsDetectionMapByRoot.*			</imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxCompactConstants</name><environment>Sixx</environment><super>Sixx.SixxConstants</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxNoTypeDefinition</name><environment>Sixx</environment><super>Sixx.SixxInvalidDeserialization</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxResolver</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementsDict </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxFormatterResolver</name><environment>Sixx</environment><super>Sixx.SixxResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxContext</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>objectsDictionary classResolver formatterResolver </inst-vars><class-inst-vars>protoClassResolver protoFormatterResolver </class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxXmlParserAdapter</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-ParserAdapter</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxVwXmlParserAdapter</name><environment>Sixx</environment><super>Sixx.SixxXmlParserAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-ParserAdapter</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxShapeChanger</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shapeChangedObject attributesMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><comment><class-id>Sixx.SixxShapeChanger</class-id><body>I can be used for reading shape-changed instances.Basically, you should subclass me and override three methods.(YourShapeChanger &gt;&gt; shapeChangedObjectClass) Return a newly introduced class for old instances.(YourShapeChanger &gt;&gt; sixxInstVarNamed: varName put: value) Override this method for setting converted values to the shape changed object. Example:	"#oldNamedVar1 inst var was renamed to #renamedAtt1"	varName == #oldNamedVar1 ifTrue: [^self attributesMap at: #renamedAtt1 put: value].	"#oldNamedVar2 inst var was removed."	varName == #oldNamedVar2 ifTrue: [^self].	super sixxInstVarNamed: varName put: value (YourShapeChanger &gt;&gt; initializeShapeChangedObject )Override this method for setting newly introduced values to the shape changed object.---[:masashi | ^umezawa]</body></comment><class><name>SixxFormatterNotFound</name><environment>Sixx</environment><super>Sixx.SixxWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxInvalidSerialization</name><environment>Sixx</environment><super>Sixx.SixxWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxXmlUtil</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>convertCharDict parserAdapter settings </class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxClassResolver</name><environment>Sixx</environment><super>Sixx.SixxResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxError</name><environment>Sixx</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxNewFailed</name><environment>Sixx</environment><super>Sixx.SixxWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alternativeInstance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxCustomSerializationExample</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>varTime varString varNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Examples</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxReadStream</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream sixxElements contextDictionary position limit cachedObjects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><comment><class-id>Sixx.SixxReadStream</class-id><body>I represent a ReadStream for SIXX format.I can be used as follows:srs := SixxReadStream readOnlyFileNamed: ('obj.sixx').obj := srs next.srs close.obj inspect.srs := SixxReadStream readOnlyFileNamed: ('objs.sixx').objs := srs contents.srs close.objs inspect.---[:masashi | ^umezawa]</body></comment><class><name>SixxShapeChangeReadStream</name><environment>Sixx</environment><super>Sixx.SixxReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shapeChangeClassResolver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><comment><class-id>Sixx.SixxShapeChangeReadStream</class-id><body>I can read class shape changed instances. I support renamed, removed and newly added instance variables.srs := SixxShapeChangeReadStream on: oldSixx readStream.srs shapeChangers at:#SmallIntegerOLD put: SmallInteger . "simple renaming"srs shapeChangers at: #SixxShapeChangedObject put: SixxMockShapeChanger."You can implement ShapeChanger for more complex conversion."---[:masashi | ^umezawa]</body></comment><class><name>SixxInvalidFormat</name><environment>Sixx</environment><super>Sixx.SixxError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxReducedConstants</name><environment>Sixx</environment><super>Sixx.SixxConstants</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxFormatter</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name targetClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><class><name>SixxWriteStream</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream contextDictionary isStartTagPut isEndTagPut </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><comment><class-id>Sixx.SixxWriteStream</class-id><body>I represent a WriteStream for SIXX format.I can be used as follows:srs := SixxWriteStream newFileNamed: ('obj.sixx').srs nextPut: &lt;object&gt;.srs close.srs := SixxWriteStream newFileNamed: ('objs.sixx').srs nextPutAll: &lt;collection of object&gt;.srs close.---[:masashi | ^umezawa]</body></comment><class><name>SixxExamples</name><environment>Sixx</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Examples</category><attributes><package>SIXX-Core</package></attributes></class><comment><class-id>Sixx.SixxExamples</class-id><body>SIXX basic examples: see class side.---MU 6/14/2002 11:12</body></comment><class><name>SixxClassNotFound</name><environment>Sixx</environment><super>Sixx.SixxWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SIXX-Core</category><attributes><package>SIXX-Core</package></attributes></class><shared-variable><name>ConstantsDetectionMap</name><environment>Sixx</environment><private>true</private><constant>false</constant><category>SIXX-Core</category><initializer>nil</initializer><attributes><package>SIXX-Core</package></attributes></shared-variable><shared-variable><name>ConstantsDetectionMapByRoot</name><environment>Sixx</environment><private>true</private><constant>false</constant><category>SIXX-Core</category><initializer>nil</initializer><attributes><package>SIXX-Core</package></attributes></shared-variable><methods><class-id>Sixx.SixxCustomStoreLoadExample</class-id> <category>accessing</category><body package="SIXX-Core">cachedData	^cachedData</body><body package="SIXX-Core">cachedData: aValue 	cachedData := aValue</body><body package="SIXX-Core">id	^id</body><body package="SIXX-Core">id: aNumber 	id := aNumber</body></methods><methods><class-id>Sixx.SixxCustomStoreLoadExample</class-id> <category>sixx writing/reading</category><body package="SIXX-Core">sixxIgnorableInstVarNames	^#(#cachedData)</body></methods><methods><class-id>Sixx.SixxCustomStoreLoadExample class</class-id> <category>examples</category><body package="SIXX-Core">example1	"SixxCustomStoreLoadExample example1"	"Writing custom serialization object"	| inst xml |	inst := SixxCustomStoreLoadExample random.	xml := inst sixxString.	Transcript cr; show: self name , ' instance sixx is...'; cr; show: xml.	^xml</body><body package="SIXX-Core">example2	"SixxCustomStoreLoadExample example2"	"Reading custom serialization object"	| xml inst |	xml := self example1.	inst := Object readSixxFrom: xml.	Transcript cr; show: self name , ' instance is load from XML...'; cr; show: inst printString.	^inst inspect</body><body package="SIXX-Core">example3	"SixxCustomStoreLoadExample example3"	"Writing custom serialization class object"	| cls xml |	cls := SixxCustomStoreLoadExample.	xml := cls sixxString.	Transcript cr; show: self name , ' class instance sixx is...'; cr; show: xml.	^xml</body><body package="SIXX-Core">example4	"SixxCustomStoreLoadExample example4"	"Reading custom serialization object"	| xml cls |	xml := self example3.	self instances: nil.	"class instances variable is set to nil"	cls := self readSixxFrom: xml.	Transcript cr; show: self name , ' cls instance is load from XML...'; cr; show: cls printString.	"now class instances variable has been set"	^self instances inspect</body></methods><methods><class-id>Sixx.SixxCustomStoreLoadExample class</class-id> <category>instance creation</category><body package="SIXX-Core">id: anInteger 	| inst |	inst := (self new) id: anInteger; cachedData: thisContext; yourself.	self instances add: inst.	^inst</body><body package="SIXX-Core">random	^self id: Random new next</body></methods><methods><class-id>Sixx.SixxCustomStoreLoadExample class</class-id> <category>sixx writing/reading</category><body package="SIXX-Core">sixxContentOn: aStream indent: level context: dictionary 	"override if you like"	aStream cr.	self instances		sixxOn: aStream		name: 'instances'		indent: level + 1		context: dictionary.	aStream tab: level</body><body package="SIXX-Core">sixxInstVarNamed: instVarName put: aValue 	"override if you like"	instVarName asString = 'instances' ifTrue: [self instances: aValue]</body></methods><methods><class-id>Sixx.SixxCustomStoreLoadExample class</class-id> <category>accessing</category><body package="SIXX-Core">instances	instances isNil ifTrue: [instances := OrderedCollection new].	^instances</body><body package="SIXX-Core">instances: aValue 	instances := aValue</body></methods><methods><class-id>Sixx.SixxCustomStoreLoadExample class</class-id> <category>class initialization</category><body package="SIXX-Core">initialize	"SixxCustomStoreLoadExample initialize"	instances := OrderedCollection new.	"some unstorable cache data"	cachedData := thisContext</body></methods><methods><class-id>Sixx.SixxSettings class</class-id> <category>accessing</category><body package="SIXX-Core">suppressNilWrite	suppressNilWrite ifNil: [suppressNilWrite := true].	^suppressNilWrite</body><body package="SIXX-Core">suppressNilWrite: aBoolean	suppressNilWrite := aBoolean == true</body><body package="SIXX-Core">useCDATA	useCDATA isNil ifTrue: [useCDATA := false].	^useCDATA</body><body package="SIXX-Core">useCDATA: aBoolean 	useCDATA := aBoolean</body><body package="SIXX-Core">useCompactTags	^SixxConstants useCompactTags</body><body package="SIXX-Core">useCompactTags: aBoolean	SixxConstants useCompactTags: aBoolean</body><body package="SIXX-Core">useEnvironment	useEnvironment isNil ifTrue: [useEnvironment := false].	^useEnvironment</body><body package="SIXX-Core">useEnvironment: aBoolean	useEnvironment := aBoolean</body><body package="SIXX-Core">useNCR	useNCR ifNil: [useNCR := false].	^useNCR</body><body package="SIXX-Core">useNCR: aBoolean	useNCR := aBoolean == true</body><body package="SIXX-Core">useNormalTags	^(self useCompactTags or: [self useReducedTags]) not</body><body package="SIXX-Core">useNormalTags: aBoolean 	self useCompactTags: aBoolean not.	self useReducedTags: aBoolean not</body><body package="SIXX-Core">useRecoveryRead	useRecoveryRead isNil ifTrue: [useRecoveryRead := false].	^useRecoveryRead</body><body package="SIXX-Core">useRecoveryRead: aBoolean	useRecoveryRead := aBoolean</body><body package="SIXX-Core">useReducedTags	^SixxConstants useReducedTags</body><body package="SIXX-Core">useReducedTags: aBoolean	SixxConstants useReducedTags: aBoolean</body></methods><methods><class-id>Sixx.SixxXmlParseError</class-id> <category>accessing</category><body package="SIXX-Core">originalError	^originalError</body><body package="SIXX-Core">originalError: anError	originalError := anError</body></methods><methods><class-id>Sixx.SixxXmlParseError class</class-id> <category>instance creation</category><body package="SIXX-Core">originalError: anError	^self new originalError: anError</body></methods><methods><class-id>Sixx.SixxWarning</class-id> <category>accessing</category><body package="SIXX-Core">className	^className</body><body package="SIXX-Core">className: aValue 	className := aValue</body><body package="SIXX-Core">context	^context</body><body package="SIXX-Core">context: aValue 	context := aValue</body><body package="SIXX-Core">element	^element</body><body package="SIXX-Core">element: aValue 	element := aValue</body></methods><methods><class-id>Sixx.SixxWarning</class-id> <category>exceptionDescription</category><body package="SIXX-Core">defaultAction	Transcript cr; show: '#warning# ' , self description.	self resume</body></methods><methods><class-id>Sixx.SixxWarning class</class-id> <category>instance creation</category><body package="SIXX-Core">signal: className	^self signal: className context: nil </body><body package="SIXX-Core">signal: className context: dictionary 	^self signal: className element: nil context: dictionary </body><body package="SIXX-Core">signal: className element: xmlElement 	^self signal: className element: xmlElement context: nil </body><body package="SIXX-Core">signal: className element: xmlElement context: dictionary 	| inst |	inst := self new.	inst className: className.	inst element: xmlElement.	inst context: dictionary.	^SixxPortableUtil signalException: inst</body><body package="SIXX-Core">signalElement: xmlElement context: dictionary 	^self signal: nil element: xmlElement context: dictionary</body></methods><methods><class-id>Sixx.SixxInvalidDeserialization</class-id> <category>exceptionDescription</category><body package="SIXX-Core">description	"Return a textual description of the exception."	^ super description , ': ' , self className printString</body></methods><methods><class-id>Sixx.SixxConstants</class-id> <category>constants-tag name</category><body package="SIXX-Core">envTagName	^'sixx.env'</body><body package="SIXX-Core">formatterTagName	^'sixx.formatter'</body><body package="SIXX-Core">idrefTagName	^'sixx.idref'</body><body package="SIXX-Core">idTagName	^'sixx.id'</body><body package="SIXX-Core">nameTagName	^'sixx.name'</body><body package="SIXX-Core">objectTagName	^'sixx.object'</body><body package="SIXX-Core">rootTagName	^'sixx'</body><body package="SIXX-Core">typeTagName	^'sixx.type'</body><body package="SIXX-Core">versionTagName	^'sixx.version'</body></methods><methods><class-id>Sixx.SixxConstants</class-id> <category>accessing</category><body package="SIXX-Core">sixxVersion	sixxVersion isNil ifTrue: [sixxVersion := '1.0'].	^sixxVersion</body><body package="SIXX-Core">sixxVersion: versionString 	sixxVersion := versionString</body><body package="SIXX-Core">xmlEncoding	xmlEncoding isNil ifTrue: [xmlEncoding := 'utf-8'].	^xmlEncoding</body><body package="SIXX-Core">xmlEncoding: encodingString 	xmlDeclaration := nil.	xmlEncoding := encodingString</body><body package="SIXX-Core">xmlVersion	xmlVersion isNil ifTrue: [xmlVersion := '1.0'].	^xmlVersion</body><body package="SIXX-Core">xmlVersion: versionString 	xmlDeclaration := nil.	xmlVersion := versionString</body></methods><methods><class-id>Sixx.SixxConstants</class-id> <category>constants-root</category><body package="SIXX-Core">sixxEndTag	^SixxXmlUtil contentsWithEndTagNamed: self rootTagName</body><body package="SIXX-Core">sixxStartTag	^SixxXmlUtil contentsWithStartTagNamed: self rootTagName do: [:wStr | 		wStr nextPutAll: self versionTagName;		 nextPutAll: '="';		 nextPutAll: self sixxVersion;		 nextPutAll: '"'.	] </body><body package="SIXX-Core">xmlDeclaration	xmlDeclaration isNil ifTrue: [xmlDeclaration := '&lt;?xml version="', self xmlVersion, '" encoding="', self xmlEncoding, '"?&gt;'].	^xmlDeclaration	</body></methods><methods><class-id>Sixx.SixxConstants</class-id> <category>initialize-release</category><body package="SIXX-Core">initialize	xmlVersion := nil.	xmlEncoding := nil.	sixxVersion := nil.	xmlDeclaration := nil</body></methods><methods><class-id>Sixx.SixxConstants class</class-id> <category>accessing</category><body package="SIXX-Core">constantsDetectionMap	ConstantsDetectionMap isNil ifTrue: [ConstantsDetectionMap := Dictionary new].	^ConstantsDetectionMap</body><body package="SIXX-Core">constantsDetectionMapByRoot	ConstantsDetectionMapByRoot isNil ifTrue: [ConstantsDetectionMapByRoot := Dictionary new].	^ConstantsDetectionMapByRoot</body><body package="SIXX-Core">current	current isNil ifTrue: [current := self new].	^current</body><body package="SIXX-Core">current: aSixxConstants	current := aSixxConstants</body><body package="SIXX-Core">rootTagNames	^self constantsDetectionMapByRoot keys</body></methods><methods><class-id>Sixx.SixxConstants class</class-id> <category>utility</category><body package="SIXX-Core">setCurrentConstantsBy: sixxElement	| extrancedName constantClass |	extrancedName := (SixxXmlUtil nameFrom: sixxElement) asString.	constantClass := self constantsDetectionMapByRoot at: extrancedName ifAbsent:[			self constantsDetectionMap at: extrancedName ifAbsent:[]	].	"no detected constants"	constantClass isNil ifTrue: [^nil].	^self current: constantClass new.	</body><body package="SIXX-Core">useCompactTags	"SixxConstants useCompactTags"	^ self current isMemberOf: SixxCompactConstants</body><body package="SIXX-Core">useCompactTags: aBoolean 	"SixxConstants useCompactTags: true"	"SixxConstants useCompactTags: false"	self		current: (aBoolean				ifTrue: [SixxCompactConstants new]				ifFalse: [self new])</body><body package="SIXX-Core">useReducedTags	"SixxConstants useReducedTags"	^ self current isMemberOf: SixxReducedConstants</body><body package="SIXX-Core">useReducedTags: aBoolean 	"SixxConstants useReducedTags: true"	"SixxConstants useReducedTags: false"	self		current: (aBoolean				ifTrue: [SixxReducedConstants new]				ifFalse: [self new])</body></methods><methods><class-id>Sixx.SixxConstants class</class-id> <category>class initialization</category><body package="SIXX-Core">initConstantsDetectionMaps	"SixxConstants initConstantsDetectionMaps"	ConstantsDetectionMap := nil.	self registerToDetectionMaps.	self allSubclasses do: [:each | each registerToDetectionMaps]. </body><body package="SIXX-Core">initialize	"SixxConstants initialize"	current := nil.	self initConstantsDetectionMaps	</body></methods><methods><class-id>Sixx.SixxConstants class</class-id> <category>private</category><body package="SIXX-Core">registerToDetectionMaps	| inst |	inst := self new.	self constantsDetectionMap at: inst objectTagName put: self.	self constantsDetectionMapByRoot at: inst rootTagName put: self</body></methods><methods><class-id>Sixx.SixxCompactConstants</class-id> <category>constants-tag name</category><body package="SIXX-Core">envTagName	^'e'</body><body package="SIXX-Core">formatterTagName	^'f'</body><body package="SIXX-Core">idrefTagName	^'r'</body><body package="SIXX-Core">idTagName	^'i'</body><body package="SIXX-Core">nameTagName	^'n'</body><body package="SIXX-Core">objectTagName	^'o'</body><body package="SIXX-Core">rootTagName	^'cixx'</body><body package="SIXX-Core">typeTagName	^'t'</body><body package="SIXX-Core">versionTagName	^'v'</body></methods><methods><class-id>Sixx.SixxNoTypeDefinition</class-id> <category>exceptionDescription</category><body package="SIXX-Core">description	^self class name, ': No type attribute in XML element'</body></methods><methods><class-id>Sixx.SixxResolver</class-id> <category>resolving</category><body package="SIXX-Core">classAt: classOrMetaclassName	^self classAt: classOrMetaclassName in: nil</body><body package="SIXX-Core">classAt: classOrMetaclassName in: environmentQualifier	| isClassClass className retClass |	isClassClass := false.	className := (classOrMetaclassName includes: Character space)				ifTrue: [isClassClass := true.					classOrMetaclassName readStream upTo: Character space]				ifFalse: [classOrMetaclassName].	retClass := SixxPortableUtil classAt: className in: environmentQualifier.	isClassClass ifTrue: [retClass := retClass class].	^retClass</body><body package="SIXX-Core">elementAt: key	^self elementAt: key in: nil</body><body package="SIXX-Core">elementAt: key in: environmentQualifier	| element |	element := self basicElementAt: key in: environmentQualifier.	element isNil ifTrue: [element := self basicElementAt: key in: self defaultEnvironmentQualifier].	^element</body></methods><methods><class-id>Sixx.SixxResolver</class-id> <category>private</category><body package="SIXX-Core">basicElementAt: key in: environmentQualifier	| envKey elements element |	self elementsDict isEmpty ifTrue: [^nil].	envKey := self envKeyFor: environmentQualifier.	elements := self elementsIn: envKey.	element := elements at: key ifAbsent:[].	^element</body><body package="SIXX-Core">envKeyFor: environmentQualifier	^environmentQualifier isNil ifTrue: [self defaultEnvironmentQualifier] ifFalse: [environmentQualifier].</body></methods><methods><class-id>Sixx.SixxResolver</class-id> <category>actions</category><body package="SIXX-Core">elements	^self elementsIn: self defaultEnvironmentQualifier</body><body package="SIXX-Core">elementsIn: environmentQualifier	^self elementsDict at: environmentQualifier ifAbsentPut: [Dictionary new].</body><body package="SIXX-Core">putElements: elements	^self putElements: elements in: self defaultEnvironmentQualifier</body><body package="SIXX-Core">putElements: elements in: environmentQualifier	^self elementsDict at: environmentQualifier put: elements</body></methods><methods><class-id>Sixx.SixxResolver</class-id> <category>defaults</category><body package="SIXX-Core">defaultEnvironmentQualifier	^SixxPortableUtil defaultEnvironmentQualifier</body></methods><methods><class-id>Sixx.SixxResolver</class-id> <category>accessing</category><body package="SIXX-Core">elementsDict	elementsDict isNil ifTrue: [elementsDict := Dictionary new].	^ elementsDict</body><body package="SIXX-Core">elementsDict: aDictionary		elementsDict := aDictionary</body></methods><methods><class-id>Sixx.SixxResolver</class-id> <category>initialize-release</category><body package="SIXX-Core">initialize	elementsDict := nil</body></methods><methods><class-id>Sixx.SixxResolver class</class-id> <category>class initialization</category><body package="SIXX-Core">initialize	default := nil</body></methods><methods><class-id>Sixx.SixxResolver class</class-id> <category>accessing</category><body package="SIXX-Core">default	default ifNil: [default := self new].	^default</body><body package="SIXX-Core">default: aResolver	default := aResolver</body></methods><methods><class-id>Sixx.SixxFormatterResolver</class-id> <category>actions</category><body package="SIXX-Core">formatters	^self elements</body><body package="SIXX-Core">formattersIn: environmentQualifier	^self elementsIn: environmentQualifier</body><body package="SIXX-Core">putFormatters: formatters	^self putElements: formatters</body><body package="SIXX-Core">putFormatters: formatters in: environmentQualifier	^self putElements: formatters in: environmentQualifier</body></methods><methods><class-id>Sixx.SixxFormatterResolver</class-id> <category>resolving</category><body package="SIXX-Core">formatterAt: classOrMetaclass	^self elementAt: classOrMetaclass</body><body package="SIXX-Core">formatterAt: classOrMetaclass in: environmentQualifier	^self elementAt: classOrMetaclass in: environmentQualifier</body></methods><methods><class-id>Sixx.SixxContext</class-id> <category>accessing</category><body package="SIXX-Core">classResolver	classResolver isNil ifTrue: [classResolver := SixxClassResolver default].	^classResolver</body><body package="SIXX-Core">classResolver: aClassResolver	classResolver := aClassResolver</body><body package="SIXX-Core">formatterResolver	formatterResolver isNil ifTrue: [formatterResolver := SixxFormatterResolver default].	^formatterResolver</body><body package="SIXX-Core">formatterResolver: aFormatterResolver	formatterResolver := aFormatterResolver</body><body package="SIXX-Core">objectsDictionary	objectsDictionary isNil ifTrue: [objectsDictionary := IdentityDictionary new].	^objectsDictionary</body><body package="SIXX-Core">objectsDictionary: anIdentityDictionary	objectsDictionary := anIdentityDictionary</body><body package="SIXX-Core">settings	"currently, just uses global settings"	^SixxPortableUtil settings</body></methods><methods><class-id>Sixx.SixxContext</class-id> <category>initialize-release</category><body package="SIXX-Core">initialize	objectsDictionary := classResolver := formatterResolver := nil.</body><body package="SIXX-Core">setUpResolvers	"set up context - ShapeChanger, Formatter, etc"	self classResolver: self class protoClassResolver.	self formatterResolver: self class protoFormatterResolver.</body></methods><methods><class-id>Sixx.SixxContext</class-id> <category>actions-dictionary</category><body package="SIXX-Core">at: key	^self objectsDictionary at: key</body><body package="SIXX-Core">at: key ifAbsent: block	^self objectsDictionary at: key ifAbsent: block</body><body package="SIXX-Core">at: key ifAbsentPut: value	^self objectsDictionary at: key ifAbsentPut: value</body><body package="SIXX-Core">at: key put: value	^self objectsDictionary at: key put: value</body><body package="SIXX-Core">includesKey: key 	^self objectsDictionary includesKey: key </body><body package="SIXX-Core">keys	^self objectsDictionary keys</body><body package="SIXX-Core">keysAndValuesDo: block	^self objectsDictionary keysAndValuesDo: block</body><body package="SIXX-Core">removeKey: key 	^self objectsDictionary removeKey: key</body><body package="SIXX-Core">removeKey: key ifAbsent: block	^self objectsDictionary removeKey: key ifAbsent: block</body><body package="SIXX-Core">size	^self objectsDictionary size</body><body package="SIXX-Core">values	^self objectsDictionary values</body></methods><methods><class-id>Sixx.SixxContext class</class-id> <category>actions-formatter</category><body package="SIXX-Core">applyFormatters: formatters while: block 	^ [self formatters: formatters.	block value]		ensure: [self resetFormatters]</body><body package="SIXX-Core">evaluate: block  formattersBy: registeringBlock	| formatters |	formatters := OrderedCollection new.	registeringBlock value: formatters.	^self applyFormatters: formatters while: block </body><body package="SIXX-Core">formatters: formattersCollection	| resolver |	resolver := SixxFormatterResolver new.	formattersCollection do: [:each |		resolver formatters at: each targetClass put: each 	].	self protoFormatterResolver: resolver</body><body package="SIXX-Core">resetFormatters	^self formatters: #()</body></methods><methods><class-id>Sixx.SixxContext class</class-id> <category>accessing</category><body package="SIXX-Core">protoClassResolver	"Answer the value of protoClassResolver"	^ protoClassResolver</body><body package="SIXX-Core">protoClassResolver: anObject	"Set the value of protoClassResolver"	protoClassResolver := anObject</body><body package="SIXX-Core">protoFormatterResolver	"Answer the value of protoFormatterResolver"	^ protoFormatterResolver</body><body package="SIXX-Core">protoFormatterResolver: anObject	"Set the value of protoFormatterResolver"	protoFormatterResolver := anObject</body></methods><methods><class-id>Sixx.SixxContext class</class-id> <category>actions-shapeChanger</category><body package="SIXX-Core">applyShapeChangers: shapeChangers while: block 	^ [self shapeChangers: shapeChangers.	block value]		ensure: [self resetShapeChangers]</body><body package="SIXX-Core">evaluate: block  shapeChangersBy: registeringBlock	| shapeChangers |	shapeChangers := Dictionary new.	registeringBlock value: shapeChangers.	^self applyShapeChangers: shapeChangers while: block </body><body package="SIXX-Core">resetShapeChangers	^self shapeChangers: Dictionary new</body><body package="SIXX-Core">shapeChangers: shapeChangerDictionary	"Association: #NameInXML -&gt; ShapeChanger"	| resolver |	resolver := SixxClassResolver new.	shapeChangerDictionary associationsDo: [:each |		resolver shapeChangers at: each key put: each value	].	self protoClassResolver: resolver</body></methods><methods><class-id>Sixx.SixxContext class</class-id> <category>class initialization</category><body package="SIXX-Core">initialize	protoClassResolver := protoFormatterResolver := nil</body></methods><methods><class-id>Sixx.SixxContext class</class-id> <category>instance creation</category><body package="SIXX-Core">forRead	"optimization for reading"	^ self new objectsDictionary: Dictionary new;		 yourself</body><body package="SIXX-Core">forWrite	^self new</body><body package="SIXX-Core">new	^super new initialize setUpResolvers</body></methods><methods><class-id>Sixx.SixxXmlParserAdapter class</class-id> <category>actions-parse</category><body package="SIXX-Core">attributeAt: attributeName from: sixxElement 	self subclassResponsibility</body><body package="SIXX-Core">characterDataFrom: sixxElement 	self subclassResponsibility</body><body package="SIXX-Core">elementsFrom: sixxElement 	self subclassResponsibility</body><body package="SIXX-Core">isTextFrom: sixxElement 	^sixxElement isText</body><body package="SIXX-Core">nameFrom: sixxElement 	self subclassResponsibility</body></methods><methods><class-id>Sixx.SixxXmlParserAdapter class</class-id> <category>actions</category><body package="SIXX-Core">parseXml: xmlStringOrStream 	self subclassResponsibility</body></methods><methods><class-id>Sixx.SixxVwXmlParserAdapter class</class-id> <category>actions-parse</category><body package="SIXX-Core">attributeAt: attributeName from: sixxElement 	| attr |	attr := sixxElement attributes detect: [:each | each key type = attributeName asString]				ifNone: [^nil].	^attr value</body><body package="SIXX-Core">characterDataFrom: sixxElement 	^sixxElement characterData</body><body package="SIXX-Core">elementsFrom: sixxElement 	^sixxElement elements select: [:each | each isText not]</body><body package="SIXX-Core">nameFrom: sixxElement 	^sixxElement tag type</body><body package="SIXX-Core">parseXml: xmlStringOrStream 	| stream parser |	stream := xmlStringOrStream isString ifFalse: [xmlStringOrStream]				ifTrue: [ReadStream on: xmlStringOrStream].	parser := XMLParser on: stream.	parser validate: false.	^parser scanDocument root</body></methods><methods><class-id>Sixx.SixxShapeChanger</class-id> <category>override hooks</category><body package="SIXX-Core">createShapeChangedObject	"override if shapeChangedObjectClass does not understand #new"	^self shapeChangedObjectClass new.	</body><body package="SIXX-Core">initializeShapeChangedObject		"By default, do nothing"	"You can override this for initializing the shape changed object"</body><body package="SIXX-Core">shapeChangedObjectClass	"override"	"Return the class of shape changed object"	self subclassResponsibility</body><body package="SIXX-Core">sixxInstVarNamed: varName put: value		"override"	"You can override this for setting values to the shape changed object like:		(YourShapeChanger &gt;&gt; sixxInstVarNamed: varName put: value)			varName == #oldNamedVar1 ifTrue: [^self attributesMap at: #renamedAtt1 put: value].			super sixxInstVarNamed: varName put: value "	self attributesMap at: varName asString put: value</body></methods><methods><class-id>Sixx.SixxShapeChanger</class-id> <category>accessing</category><body package="SIXX-Core">attributesMap	"Answer the value of attributesMap"	attributesMap isNil ifTrue: [attributesMap := Dictionary new].	^ attributesMap</body><body package="SIXX-Core">attributesMap: anObject	attributesMap := anObject</body><body package="SIXX-Core">shapeChangedObject	"Answer the value of shapeChangedObject"	shapeChangedObject isNil ifTrue: [		shapeChangedObject := self createShapeChangedObject.		self preInitShapeChangedObject.		self initializeShapeChangedObject.	].	^ shapeChangedObject</body><body package="SIXX-Core">shapeChangedObject: anObject	shapeChangedObject := anObject</body><body package="SIXX-Core">sixxReadValue	^self shapeChangedObject</body></methods><methods><class-id>Sixx.SixxShapeChanger</class-id> <category>private</category><body package="SIXX-Core">preInitShapeChangedObject	"pre-initialize default values by attributesMap"	self attributesMap		keysAndValuesDo: [:key :value | self shapeChangedObject perform: (key , ':') asSymbol with: value].	</body></methods><methods><class-id>Sixx.SixxShapeChanger</class-id> <category>testing</category><body package="SIXX-Core">circularReference	"override if your shape-changing object is referencing the same shape-changing class's objects"	^false</body><body package="SIXX-Core">isSixxShapeChanger	^true</body></methods><methods><class-id>Sixx.SixxShapeChanger</class-id> <category>actions</category><body package="SIXX-Core">sixxBecomeTo: newInst	"override if your object does not support (oneway) become - in that case, use proxy pattern"	SixxPortableUtil becomeFrom: self to: newInst</body></methods><methods><class-id>Sixx.SixxFormatterNotFound</class-id> <category>accessing</category><body package="SIXX-Core">formatterName	^self className</body></methods><methods><class-id>Sixx.SixxFormatterNotFound</class-id> <category>exceptionDescription</category><body package="SIXX-Core">description	"Return a textual description of the exception."	self formatterName isNil ifTrue: [ ^super description , ': ', 'Formatter cannot be found in the image'].	^ super description , ': ' , self formatterName</body></methods><methods><class-id>Sixx.SixxInvalidSerialization</class-id> <category>exceptionDescription</category><body package="SIXX-Core">description	"Return a textual description of the exception."	^ super description , ': ' , self className printString</body></methods><methods><class-id>Sixx.SixxXmlUtil class</class-id> <category>accessing</category><body package="SIXX-Core">convertCharDict	^convertCharDict</body><body package="SIXX-Core">parserAdapter	parserAdapter isNil ifTrue: [parserAdapter := self environment at: #SixxVwXmlParserAdapter].	^parserAdapter</body><body package="SIXX-Core">parserAdapter: aSixxXmlParserAdapter 	parserAdapter := aSixxXmlParserAdapter</body><body package="SIXX-Core">settings	settings isNil		ifTrue: [settings := Smalltalk						at: #SixxSettings						ifAbsent: [self error: 'SixxSettings is needed to run SIXX']].	^ settings</body></methods><methods><class-id>Sixx.SixxXmlUtil class</class-id> <category>actions-parse</category><body package="SIXX-Core">attributeAt: attributeName from: sixxElement 	^self parserAdapter attributeAt: attributeName from: sixxElement</body><body package="SIXX-Core">characterDataFrom: sixxElement 	^self parserAdapter characterDataFrom: sixxElement</body><body package="SIXX-Core">elementsFrom: sixxElement 	^self parserAdapter elementsFrom: sixxElement</body><body package="SIXX-Core">isTextFrom: sixxElement 	^self parserAdapter isTextFrom: sixxElement</body><body package="SIXX-Core">nameFrom: sixxElement 	^self parserAdapter nameFrom: sixxElement</body></methods><methods><class-id>Sixx.SixxXmlUtil class</class-id> <category>actions</category><body package="SIXX-Core">asXmlText: aString 	| wStr |	wStr := WriteStream on: (String new: aString size).	^(self writeXmlText: aString on: wStr) contents</body><body package="SIXX-Core">attributeSymbolAt: attribName from: sixxElement	| value |	(self isTextFrom: sixxElement) ifTrue: [^nil].	value := self attributeAt: attribName from: sixxElement .	^ value isNil		ifFalse: [value asSymbol]</body><body package="SIXX-Core">contentsWithEmptyTagNamed: tagName do: block 	| wStr |	wStr := (String new: 16) writeStream.	self writeEmptyTagNamed: tagName attributesDo: block on: wStr.	^ wStr contents</body><body package="SIXX-Core">contentsWithEndTagNamed: tagName	| wStr |	wStr := (String new: 16) writeStream.	self writeEndTagNamed: tagName on: wStr.	^wStr contents</body><body package="SIXX-Core">contentsWithStartTagNamed: tagName do: block 	"backward compatibility"	| wStr |	wStr := (String new: 16) writeStream.	self writeStartTagNamed: tagName attributesDo: block on: wStr.	^ wStr contents</body><body package="SIXX-Core">contentsWithXmlDeclaration: aString 	| wStr |	wStr := WriteStream				on: (String new: 1024).	self writeXmlDeclaration: aString on: wStr.	^ wStr contents</body><body package="SIXX-Core">parseXml: xmlStringOrStream 	^[self parserAdapter parseXml: xmlStringOrStream] on: Error		do: [:ex | SixxPortableUtil signalException: (SixxXmlParseError originalError: ex)]</body><body package="SIXX-Core">writeAttribute: attName value: attValue on: aWriteStream 	attValue isNil ifTrue: [^self].	aWriteStream nextPutAll: attName;		 nextPutAll: '="';		 nextPutAll: attValue;		 nextPutAll: '" '.	^aWriteStream</body><body package="SIXX-Core">writeBasicSixxAttributesOf: object on: aStream name: nameString	| constants |	constants := SixxConstants current.	self writeAttribute: constants nameTagName value: nameString on: aStream.	self writeAttribute: constants typeTagName value: object sixxType on: aStream.	self settings useEnvironment				ifTrue: [self						writeAttribute: constants envTagName						value: object sixxEnv						on: aStream]</body><body package="SIXX-Core">writeEmptyTagNamed: tagName attributesDo: block on: wStr	wStr nextPut: $&lt;;		nextPutAll: tagName;		space.	block value: wStr.	wStr nextPut:$/;		nextPut: $&gt;.	</body><body package="SIXX-Core">writeEndTagNamed: tagName on: wStr	wStr nextPutAll: '&lt;/';		nextPutAll: tagName;		nextPut: $&gt;.</body><body package="SIXX-Core">writeStartTagNamed: tagName attributesDo: block on: wStr	wStr nextPut: $&lt;;		nextPutAll: tagName;		space.	block value: wStr.	wStr nextPut: $&gt;.	</body><body package="SIXX-Core">writeTagNamed: tagName attributesDo: attributesBlock contentDo: contentBlock on: aWriteStream	self writeStartTagNamed: tagName attributesDo: attributesBlock on: aWriteStream.	contentBlock value: aWriteStream.	self writeEndTagNamed: tagName on: aWriteStream</body><body package="SIXX-Core">writeXmlDeclaration: aString on: wStr	wStr nextPutAll: SixxConstants current xmlDeclaration.	2		timesRepeat: [wStr nextPut: Character cr.			wStr nextPut: Character lf].	wStr nextPutAll: aString.</body><body package="SIXX-Core">writeXmlText: aString on: aWriteStream 	self settings useCDATA		ifTrue: 			[aWriteStream nextPutAll: '&lt;![CDATA['.			aWriteStream nextPutAll: aString.			aWriteStream nextPutAll: ']]&gt;']		ifFalse: [self convertWriteXmlText: aString on: aWriteStream]</body></methods><methods><class-id>Sixx.SixxXmlUtil class</class-id> <category>private-initialize</category><body package="SIXX-Core">initConvertCharDict	"SixxXmlUtil initConvertCharDict"	convertCharDict := Dictionary new.	0 to: 47 do: [:each | convertCharDict at: each put: '&amp;#', each printString, ';'].	convertCharDict 		at: $&amp; asInteger put: '&amp;amp;';		at: $&lt; asInteger put: '&amp;lt;';		at: $&gt; asInteger put: '&amp;gt;';		at: $' asInteger put: '&amp;apos;';		at: $" asInteger put: '&amp;quot;'.	convertCharDict 		removeKey: Character space asInteger;		removeKey: Character tab asInteger;		removeKey: Character cr asInteger;		removeKey: Character lf asInteger.	convertCharDict 		removeKey: $/ asInteger;		removeKey: $+ asInteger;		removeKey: $- asInteger;		removeKey: $. asInteger.</body></methods><methods><class-id>Sixx.SixxXmlUtil class</class-id> <category>class initialization</category><body package="SIXX-Core">initialize	"SixxXmlUtil initialize"	self initConvertCharDict.	parserAdapter := nil.	settings := nil.</body></methods><methods><class-id>Sixx.SixxXmlUtil class</class-id> <category>private</category><body package="SIXX-Core">convertWriteXmlText: aString on: aWriteStream 	| cDict wStr |	cDict := self convertCharDict.	wStr := aWriteStream.	aString		do: 			[:eachChar | 			| val |			val := (SixxPortableUtil charCodeOf: eachChar).			val &gt;= 127				ifTrue: [self writeUnicodeChar: eachChar on: wStr]				ifFalse: 					[| conv |					conv := cDict at: val ifAbsent: [].					conv isNil						ifTrue: [wStr nextPut: eachChar]						ifFalse: [wStr nextPutAll: conv]]].	^wStr</body><body package="SIXX-Core">writeUnicodeChar: aCharacter on: aWriteStream 	self settings useNCR		ifTrue: [aWriteStream nextPutAll: '&amp;#';				 nextPutAll: (SixxPortableUtil charCodeOf: aCharacter) printString;				 nextPut: $;]		ifFalse: [aWriteStream nextPut: aCharacter]</body></methods><methods><class-id>Sixx.SixxClassResolver</class-id> <category>actions</category><body package="SIXX-Core">putShapeChangers: shapeChangers 	^self putElements: shapeChangers</body><body package="SIXX-Core">putShapeChangers: shapeChangers in: environmentQualifier	^self putElements: shapeChangers in: environmentQualifier</body><body package="SIXX-Core">shapeChangers	^self elements</body><body package="SIXX-Core">shapeChangersIn: environmentQualifier	^self elementsIn: environmentQualifier</body></methods><methods><class-id>Sixx.SixxClassResolver</class-id> <category>resolving</category><body package="SIXX-Core">classAt: classOrMetaclassName in: environmentQualifier	| retClass |	retClass := self shareChangedClassAt: classOrMetaclassName in: environmentQualifier.	retClass isNil ifFalse: [^retClass].	^super classAt: classOrMetaclassName in: environmentQualifier</body><body package="SIXX-Core">shareChangedClassAt: classOrMetaclassName in: environmentQualifier	| elem |	elem := self elementAt: classOrMetaclassName in: environmentQualifier.	^elem</body></methods><methods><class-id>Sixx.SixxError class</class-id> <category>instance creation</category><body package="SIXX-Core">signal: aString	| inst |	inst := self new.	inst messageText: aString.	^SixxPortableUtil signalException: inst</body></methods><methods><class-id>Sixx.SixxCustomSerializationExample</class-id> <category>printing-sixx</category><body package="SIXX-Core">sixxContentOn: aStream indent: level context: dictionary	aStream nextPutAll: self varTime sixxContentString.	aStream nextPut: $;.	aStream nextPutAll: self varString.	aStream nextPut: $;.	aStream nextPutAll: self varNumber printString.	aStream nextPut: $;.</body></methods><methods><class-id>Sixx.SixxCustomSerializationExample</class-id> <category>accessing</category><body package="SIXX-Core">varNumber	^varNumber</body><body package="SIXX-Core">varNumber: anObject	varNumber := anObject</body><body package="SIXX-Core">varString	^varString</body><body package="SIXX-Core">varString: anObject	varString := anObject</body><body package="SIXX-Core">varTime	^varTime</body><body package="SIXX-Core">varTime: anObject	varTime := anObject</body></methods><methods><class-id>Sixx.SixxCustomSerializationExample class</class-id> <category>examples</category><body package="SIXX-Core">example1	"self example1"	| instA sixx instB |	instA := self new varTime: Time now; varString: 'Testing'; varNumber: 123.	sixx := instA sixxString.	instB := Object readSixxFrom: sixx.		sixx inspect.	(Array with:instA with: instB) inspect.</body></methods><methods><class-id>Sixx.SixxCustomSerializationExample class</class-id> <category>instance creation-sixx</category><body package="SIXX-Core">createInstanceOf: aClass withSixxElement: sixxElement	| stream inst |	stream := ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement).	inst := self new.	inst varTime: (Time readSixxContentStringFrom: (stream upTo: $;) readStream).	inst varString: (stream upTo: $;).	inst varNumber: (stream upTo: $;) asNumber.	^inst</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>file open/close</category><body package="SIXX-Core">close	self stream close</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>reading</category><body package="SIXX-Core">contents	^(self next: self size) asArray</body><body package="SIXX-Core">next	^self atEnd		ifFalse: 			[position := position + 1.			self cachedObjects at: position ifAbsentPut: [self readSixxFromSixxElement: (sixxElements at: position)]]</body><body package="SIXX-Core">next: anInteger 	| ord |	anInteger &lt; 0 ifTrue: [^nil].	ord := OrderedCollection new: anInteger.	anInteger timesRepeat: [self atEnd ifFalse: [ord add: self next]].	^ord</body><body package="SIXX-Core">peek	| nextObj |	nextObj := self next.	self privatePosition: self position - 1.	^nextObj</body><body package="SIXX-Core">position	^position</body><body package="SIXX-Core">position: anInteger 	(anInteger &lt; 0 and: [anInteger &gt; limit])		ifTrue: [self error: 'out of bounds'].	self reset.	self next: anInteger</body><body package="SIXX-Core">reset	self privatePosition: 0</body><body package="SIXX-Core">size	^self limit</body><body package="SIXX-Core">skip: anInteger 	self position: self position + anInteger</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>testing</category><body package="SIXX-Core">atEnd	^self position &gt;= self limit</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>initializing</category><body package="SIXX-Core">initialize	contextDictionary := SixxContext forRead.	position := 0.	sixxElements := self parseStream: stream.	limit := sixxElements isNil				ifTrue: [0]				ifFalse: [sixxElements size].	cachedObjects := Dictionary new</body><body package="SIXX-Core">on: aStream 	stream := aStream.	self initialize</body><body package="SIXX-Core">readOnlyFileNamed: fileName 	stream := SixxPortableUtil readFileStreamNamed: fileName.	self initialize</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>accessing</category><body package="SIXX-Core">cachedObjects	^cachedObjects</body><body package="SIXX-Core">contextDictionary	^contextDictionary</body><body package="SIXX-Core">limit	^limit</body><body package="SIXX-Core">sixxElements	^sixxElements</body><body package="SIXX-Core">stream	^stream</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>private-accessing</category><body package="SIXX-Core">privatePosition: anInteger 	position := anInteger</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>private-recovery</category><body package="SIXX-Core">findStringIndexes: subString from: sourceString 	| foundIndexes index |	foundIndexes := OrderedCollection new.	index := 1.	[index = 0]		whileFalse: [index := sourceString findString: subString startingAt: index.			index = 0				ifFalse: [foundIndexes add: index.					index := index + 1]].	^ foundIndexes</body><body package="SIXX-Core">recoveredStreamFrom: aStream 	| contents objectTagName objectTagStart objectTagEnd startIndexes endIndexes recoverStream  |	contents := aStream contents.	objectTagName := SixxConstants current objectTagName.	objectTagStart := '&lt;', objectTagName.	objectTagEnd := SixxXmlUtil contentsWithEndTagNamed: objectTagName.	startIndexes := self findStringIndexes: objectTagStart from: contents.	endIndexes := self findStringIndexes: objectTagEnd from: contents.	recoverStream := ReadWriteStream with: (contents copyFrom: 1 to: (startIndexes last -1)).	(startIndexes size - endIndexes size -1) timesRepeat: [recoverStream nextPutAll: objectTagEnd].	recoverStream nextPutAll: (SixxConstants current sixxEndTag).	^ recoverStream reset</body></methods><methods><class-id>Sixx.SixxReadStream</class-id> <category>private</category><body package="SIXX-Core">checkSixxElement: sixxElement 	| detected |	detected := SixxConstants setCurrentConstantsBy: sixxElement.	detected isNil		ifTrue: [SixxInvalidFormat signal: 'unexpected element: ' , (SixxXmlUtil nameFrom: sixxElement) printString]</body><body package="SIXX-Core">initialElementsFrom: rootOrElements 	| extractedName |	extractedName := SixxXmlUtil nameFrom: rootOrElements.	^ (SixxConstants rootTagNames includes: extractedName asString)		ifTrue: [SixxXmlUtil elementsFrom: rootOrElements]		ifFalse: [OrderedCollection with: rootOrElements] "we allow no root tag"</body><body package="SIXX-Core">parseStream: aStream 	| root str recoverTried |	(aStream isNil or: [aStream size = 0])	ifTrue: [^nil].	str := aStream.	recoverTried := false.	[root := SixxXmlUtil parseXml: str]		on: SixxXmlParseError do: [:ex | (SixxSettings useRecoveryRead and: [recoverTried not])			ifTrue: 				[str := self recoveredStreamFrom: str.				recoverTried := true.				ex retry]			ifFalse: [ex pass]].	self checkSixxElement: root.	^self initialElementsFrom: root</body><body package="SIXX-Core">readSixxFromSixxElement: sixxElement	^Object readSixxFromSixxElement: sixxElement context: self contextDictionary</body></methods><methods><class-id>Sixx.SixxReadStream class</class-id> <category>instance creation</category><body package="SIXX-Core">new	SixxError signal: 'Streams are created with on:'</body><body package="SIXX-Core">on: readStream 	^self basicNew on: readStream</body><body package="SIXX-Core">readOnlyFileNamed: fileName 	^self basicNew readOnlyFileNamed: fileName</body></methods><methods><class-id>Sixx.SixxShapeChangeReadStream</class-id> <category>accessing</category><body package="SIXX-Core">shapeChangeClassResolver	shapeChangeClassResolver ifNil: [shapeChangeClassResolver := SixxClassResolver new].	^ shapeChangeClassResolver</body><body package="SIXX-Core">shapeChangeClassResolver: anObject		shapeChangeClassResolver := anObject</body><body package="SIXX-Core">shapeChangers	"shortcut - for returning global scoped (Smalltalk) shape changers"	^self shapeChangeClassResolver shapeChangers</body><body package="SIXX-Core">shapeChangers: shapeChangers	self shapeChangeClassResolver putShapeChangers: shapeChangers </body></methods><methods><class-id>Sixx.SixxShapeChangeReadStream</class-id> <category>initializing</category><body package="SIXX-Core">initialize	super initialize.	shapeChangeClassResolver := nil.	self setUpContextDictionary </body><body package="SIXX-Core">setUpContextDictionary	self contextDictionary classResolver: self shapeChangeClassResolver</body></methods><methods><class-id>Sixx.SixxReducedConstants</class-id> <category>constants-tag name</category><body package="SIXX-Core">envTagName	^'env'</body><body package="SIXX-Core">formatterTagName	^'formatter'</body><body package="SIXX-Core">idrefTagName	^'idref'</body><body package="SIXX-Core">idTagName	^'id'</body><body package="SIXX-Core">nameTagName	^'name'</body><body package="SIXX-Core">objectTagName	^'object'</body><body package="SIXX-Core">rootTagName	^'rixx'</body><body package="SIXX-Core">typeTagName	^'type'</body><body package="SIXX-Core">versionTagName	^'version'</body></methods><methods><class-id>Sixx.SixxFormatter</class-id> <category>accessing</category><body package="SIXX-Core">name	name isNil ifTrue: [name := self class name].	^name</body><body package="SIXX-Core">name: anObject	"Set the value of name"	name := anObject</body><body package="SIXX-Core">targetClass	"Answer the value of targetClass"	^ targetClass</body><body package="SIXX-Core">targetClass: anObject	"Set the value of targetClass"	targetClass := anObject</body></methods><methods><class-id>Sixx.SixxFormatter</class-id> <category>override hooks</category><body package="SIXX-Core">createInstanceOf: aClass withSixxElement: sixxElement	"override"	^aClass createInstanceOf: aClass withSixxElement: sixxElement.</body><body package="SIXX-Core">format: anObject on: aStream indent: level context: dictionary	"override"		^anObject sixxContentOn: aStream indent: level context: dictionary </body><body package="SIXX-Core">initialize: anObject fromSixxElement: sixxElement context: aDictionary	"override"	^anObject</body></methods><methods><class-id>Sixx.SixxFormatter class</class-id> <category>instance creation</category><body package="SIXX-Core">on: aClass	^self new targetClass: aClass; yourself</body></methods><methods><class-id>Sixx.SixxWriteStream</class-id> <category>accessing</category><body package="SIXX-Core">contextDictionary	^contextDictionary</body><body package="SIXX-Core">contextDictionary: aValue 	contextDictionary := aValue</body><body package="SIXX-Core">isEndTagPut	^isEndTagPut</body><body package="SIXX-Core">isEndTagPut: aValue 	isEndTagPut := aValue</body><body package="SIXX-Core">isStartTagPut	^isStartTagPut</body><body package="SIXX-Core">isStartTagPut: aValue 	isStartTagPut := aValue</body><body package="SIXX-Core">stream	^stream</body><body package="SIXX-Core">stream: aValue 	stream := aValue</body></methods><methods><class-id>Sixx.SixxWriteStream</class-id> <category>writing</category><body package="SIXX-Core">cr	self stream cr</body><body package="SIXX-Core">endTag	(self isStartTagPut and: [self isEndTagPut not])		ifTrue: 			[self stream nextPutAll: SixxConstants current sixxEndTag.			self isEndTagPut: true]</body><body package="SIXX-Core">nextPut: anObject 	self startTag.	anObject		sixxOn: self stream		indent: 1		context: self contextDictionary</body><body package="SIXX-Core">nextPutAll: aCollection 	aCollection do: [:obj | self nextPut: obj]</body><body package="SIXX-Core">startTag	self isStartTagPut		ifFalse: 			[self stream nextPutAll: SixxConstants current sixxStartTag.			self isStartTagPut: true.			self cr]</body><body package="SIXX-Core">xmlDeclaration	(self stream) nextPutAll: SixxConstants current xmlDeclaration; cr</body></methods><methods><class-id>Sixx.SixxWriteStream</class-id> <category>file open/close</category><body package="SIXX-Core">close	self endTag.	self stream close</body></methods><methods><class-id>Sixx.SixxWriteStream</class-id> <category>initializing</category><body package="SIXX-Core">initialize	contextDictionary := SixxContext forWrite.	isStartTagPut := false.	isEndTagPut := false</body><body package="SIXX-Core">newFileNamed: fileName 	stream := SixxPortableUtil writeFileStreamNamed: fileName.	self initialize</body><body package="SIXX-Core">on: aStream 	stream := aStream</body></methods><methods><class-id>Sixx.SixxWriteStream</class-id> <category>actions</category><body package="SIXX-Core">contents	^self close; rawContents</body><body package="SIXX-Core">rawContents	^self stream contents</body></methods><methods><class-id>Sixx.SixxWriteStream class</class-id> <category>instance creation</category><body package="SIXX-Core">new	^super new initialize</body><body package="SIXX-Core">newFileNamed: fileName 	^self new newFileNamed: fileName</body><body package="SIXX-Core">on: writeStream 	^self new on: writeStream</body><body package="SIXX-Core">onWithDeclaration: writeStream 	^(self on: writeStream) xmlDeclaration</body></methods><methods><class-id>Sixx.SixxExamples class</class-id> <category>examples</category><body package="SIXX-Core">example1	"SixxExamples example1"	"Create a SIXX string from an object (like #storeString)"	| dict array xmlString |	dict := Dictionary new.	dict at: #Smalltalk put: 'Best'.	dict at: #Ruby put: 'Cool'.	dict at: #Java put: 'Forget it'.	array := Array new: 3.	array at: 1 put: 'Language Impressions'.	array at: 2 put: dict.	array at: 3 put: Date today.	xmlString := array sixxString.	Transcript cr; show: '##This is sixx xml instance##'.	Transcript cr; show: xmlString.	^xmlString</body><body package="SIXX-Core">example2	"SixxExamples example2"	"Read a SIXX string and restore an instance (like #readFrom:)"	| xmlString obj |	xmlString := SixxExamples example1.	obj := Object readSixxFrom: xmlString.	obj inspect</body><body package="SIXX-Core">example3	"SixxExamples example3"	"Resolve circular and shared objects"	| rootOrdered sharedDict subOrdered subArray xmlString obj |	rootOrdered := OrderedCollection new.	sharedDict := Dictionary new.	sharedDict at: #hello put: 'Hello'.	sharedDict at: #recurHello put: sharedDict.	subOrdered := OrderedCollection new.	subOrdered add: sharedDict.	subOrdered add: Time now.	subArray := Array new: 2.	subArray at: 1 put: sharedDict.	subArray at: 2 put: Date today.	rootOrdered add: subOrdered; add: subArray.	xmlString := rootOrdered sixxString.	Transcript cr; show: '##This is sixx xml instance##'.	Transcript cr; show: xmlString.	obj := Object readSixxFrom: xmlString.	Transcript cr; show: '##Shared object comparison##'.	Transcript cr; show: (obj first first = obj last first) printString.	</body><body package="SIXX-Core">example4	"SixxExamples example4"	"Save and load Preferences data"		"| preferences |	preferences := Preferences allPreferenceObjects sixxString.	preferences := Object readSixxFrom: preferences.	^preferences inspect."	</body><body package="SIXX-Core">example5	"SixxExamples example5"	"Write object data to an external file"		| sws |	sws := SixxWriteStream newFileNamed: ('obj.sixx').	sws nextPut: ColorValue red.	sws nextPut: Rectangle fromUser.	sws close.</body><body package="SIXX-Core">example6	"SixxExamples example6"	"Read object data from an external file"		| srs objects |	srs := SixxReadStream readOnlyFileNamed: ('obj.sixx').	objects := OrderedCollection new.	[srs atEnd] whileFalse: [objects add: srs next].	srs close.	objects inspect.</body><body package="SIXX-Core">example7	"SixxExamples example7"	"Write object data to an external file"	| sws dic |	sws := SixxWriteStream newFileNamed: 'obj2.sixx'.	sws nextPut: Color red.	sws nextPut: Rectangle fromUser.	sws nextPut: true.	sws nextPut: false.	sws nextPut: $a.	sws nextPut: $(.	sws nextPut: (OrderedCollection with: 1 with: Date today).	sws nextPut: Time now.	sws nextPut: nil.	sws nextPut: (ByteArray			with: 10			with: 20			with: 30).	dic := Dictionary new.	dic at: 'first' put: '111'.	dic at: 'second' put: '222'.	sws nextPut: dic.	sws close</body></methods><methods><class-id>Sixx.SixxClassNotFound</class-id> <category>exceptionDescription</category><body package="SIXX-Core">description	"Return a textual description of the exception."	self className isNil ifTrue: [^super description , ': ' , 'Type cannot be detected from XML'].	^super description , ': ' , self className</body></methods><initialize><class-id>Sixx.SixxCustomStoreLoadExample</class-id></initialize><initialize><class-id>Sixx.SixxConstants</class-id></initialize><initialize><class-id>Sixx.SixxResolver</class-id></initialize><initialize><class-id>Sixx.SixxContext</class-id></initialize><initialize><class-id>Sixx.SixxXmlUtil</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>