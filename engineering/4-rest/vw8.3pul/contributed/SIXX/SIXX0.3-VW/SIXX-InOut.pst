<?xml version="1.0"?><st-source><!-- Name: SIXX-InOutComment: SIXX 0.3 for VisualWorksCopyright (C) 2002-2009 Masashi Umezawa, Tetsuya Kurihara, Kazuki MinamitaniSIXX is a multi-platform XML serializer/deserializer for Smalltalk. You can exchange various Smalltalk objects among different (dialect) images.<<0.3 Release Note>>http://swikis.ddo.jp/umejava/44<<How to use>>[Basic writing/reading]SIXX is very easy to use. Like #storeString, You can generate a SIXX string by #sixxString.array := Array with: 1 with: 'Hello' with: Date today.array sixxString.This code generates a SIXX string below:'<sixx.object sixx.id="0" sixx.type="Array" >        <sixx.object sixx.id="1" sixx.type="SmallInteger" >1</sixx.object>        <sixx.object sixx.id="2" sixx.type="String" >Hello</sixx.object>        <sixx.object sixx.id="3" sixx.type="Date" >16 June 2002</sixx.object></sixx.object>'This string can be read by #readSixxFrom:.Object readSixxFrom: sixxString. "sixxString is the above string"[Stream writing/reading]SixxWriteStream and SixxReadStream are provided so that you can write/read Smalltalk objects like a binary-object-stream way (BOSS in VW, and the ReferenceStream in Squeak).In order to write objects to an external file, you can:sws := SixxWriteStream newFileNamed: 'obj.sixx'.sws nextPut: <object>.sws nextPutAll: <collection of object>.sws close.And to read objects from an external file:srs := SixxReadStream readOnlyFileNamed: 'obj.sixx'.objects := srs contents.srs close.<<SIXX Hooks>>[Customizing serialization]Object>>sixxPrepareWrite	It is called before the instance is written in SIXX. Object>>sixxWriteValue	Return the object actually serialized.Object>>sixxIgnorableInstVarNames	Specify the instance variables that are not written in SIXX Object>>sixxNonReferencableInstVarNames	Specify the instance variables that should not be referenced in SIXX. Values are always written redundantly. It is useful for small literal objects like String, Number, etc.Object>>sixxReferenceIdInContext:	Return unique id that can be referenced from other objects in SIXX. It is useful when objects have their own unique id.[Customizing deserialization]Object>>sixxInitialize	It is called immediately after the instance is read from SIXX Object>>sixxReadValue	Return the object for the client from the deserialized instance. <<ShapeChanger>>SixxShapeChanger enables you to read "class shape changed" instances. It supports renamed, removed and newly added instance variables.srs := SixxShapeChangeReadStream on: oldSixx readStream.srs shapeChangers at:#SmallIntegerOLD put: SmallInteger . "simple renaming"srs shapeChangers at: #SixxShapeChangedObject put: SixxMockShapeChanger. "You can implement ShapeChanger for more complex conversion."To define a new ShapeChanger, you should subclass base ShapeChanger class and override three methods.YourShapeChanger>>shapeChangedObjectClass	Return a newly introduced class for old instances.YourShapeChanger>>sixxInstVarNamed: varName put: value	Override this method for setting converted values to the shape changed object.YourShapeChanger>>initializeShapeChangedObject	Override this method for setting newly introduced values to the shape changed object.For example: (YourShapeChanger>>sixxInstVarNamed: varName put:)sixxInstVarNamed: varName put: value  "#oldNamedVar1 instance variable was renamed to #renamedAtt1"  varName == #oldNamedVar1 ifTrue: [^self attributesMap at: #renamedAtt1 put: value].  "#oldNamedVar2 inst var was removed."  varName == #oldNamedVar2 ifTrue: [^self].  super sixxInstVarNamed: varName put: valueFrom SIXX 0.3, you can apply ShapeChanger(s) without using SixxShapeChangeReadStream.obj := SixxContext evaluate: [Object readSixxFrom: oldSixx]  shapeChangersBy: [:shapeChangers | shapeChangers at: #SixxShapeChangedObject put: SixxSomeShapeChanger].<<Formatter>>Formatter is a new SIXX function for customizing SIXX format without subclassing.Normally, you can customize SIXX serialization format by overriding hooks such as #sixxWriteValue, #sixxIgnorableInstVarNames. However, sometimes you would like to customize serialization format more dynamically.For example, you may want to change default Array serialization format to compact one, if the array includes only primitive (literal) elements.Suppose there is an array like:array := #(1 2 3 4 5).By default, the array will be sixxed out if you evaluate:array sixxString. "print it"'<sixx.object sixx.id="0" sixx.type="Array" ><sixx.object sixx.id="1" sixx.type="SmallInteger" >1</sixx.object><sixx.object sixx.id="2" sixx.type="SmallInteger" >2</sixx.object><sixx.object sixx.id="3" sixx.type="SmallInteger" >3</sixx.object><sixx.object sixx.id="4" sixx.type="SmallInteger" >4</sixx.object><sixx.object sixx.id="5" sixx.type="SmallInteger" >5</sixx.object></sixx.object>'This format is reasonable for supporting complex array, but the format could be space-consuming if the array contains only primitive (literal) elements. By setting a Formatter, you can use more compact format for Array.SixxContext formatters: {SixxMockLiteralArrayFormatter on: Array}.After that, the format will be:'<sixx.object sixx.id="0" sixx.type="Array" sixx.formatter="SixxMockLiteralArrayFormatter" ><sixx.object sixx.id="1" sixx.type="String" >&#35;&#40;1 2 3 4 5&#41;</sixx.object></sixx.object>'You can reset the formatter by:SixxContext resetFormatters.For convenience, there is a method to switch formatter temporarily.SixxContext applyFormatters: {SixxMockLiteralArrayFormatter on: Array} while: [  array sixxString.]Or, you can even use:SixxContext evaluate: [array sixxString]  formattersBy: [:formatters | formatters add: (SixxMockLiteralArrayFormatter on: Array)].In short, Formatter can be used:- For customizing SIXX format dynamically.- For overriding SIXX format of the existing classes temporarily. <<More info>>http://www.mars.dti.ne.jp/~umejava/smalltalk/sixx/index.htmlHideSource: falsePackageName: SIXX-InOutParcel: #('SIXX-InOut')ParcelName: SIXX-InOutPrerequisiteParcels: #(#('SIXX-Core' '0.3c'))SaveSource: trueVersion: 8.2-0.3cDate: 10:28:27 AM November 13, 2015 --><time-stamp>From VisualWorksÂ®, 7.10.1 of February 6, 2014 on November 13, 2015 at 10:28:27 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.Fraction class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement	^ self readSixxContentStringFrom: (ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement))	</body></methods><methods><class-id>Core.Fraction class</class-id> <category>private-sixx</category><body package="SIXX-InOut">readSixxContentStringFrom: aStream	| numerator denominator |	aStream next. "skip $("	numerator := aStream upTo: $/ .	denominator := aStream upTo: $).	^ self numerator: numerator asNumber denominator: denominator asNumber</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	| instVars startIndex |	aStream cr.	instVars := self class allInstVarNames.	startIndex := Object class allInstVarNames size + 1.	startIndex		to: instVars size		do: [:idx | self				sixxInstVarNamed: (instVars at: idx)				value: (self instVarAt: idx)				on: aStream				indent: level + 1				context: dictionary]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting-sixx</category><body package="SIXX-InOut">asByteArray	^ByteArray withAll: self</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^self readSixxContentStringFrom: (ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement))</body></methods><methods><class-id>Core.Date</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: self sixxContentString</body></methods><methods><class-id>Core.Object</class-id> <category>private-sixx</category><body package="SIXX-InOut">basicSixxOn: aStream originator: originator name: nameString indent: level context: dictionary 	| idStr |	(dictionary includesKey: originator)		ifTrue: [^self sixxRefOn: aStream id: (dictionary at: originator) name: nameString indent: level context: dictionary].	idStr := self sixxReferenceIdInContext: dictionary.	dictionary at: originator put: idStr.	self writeSixxTagOn: aStream id: idStr name: nameString indent: level context: dictionary </body></methods><methods><class-id>Core.Object</class-id> <category>initializing-sixx</category><body package="SIXX-InOut">initializeFromSixxElement: sixxElement context: aDictionary 	self class isBits 		ifTrue: 			[^self initializeIndexFieldsFromSixxElement: sixxElement				context: aDictionary].	self class isVariable 		ifTrue: 			[^self initializeMixedFieldsFromSixxElement: sixxElement				context: aDictionary].	self initializeInstVarsFromSixxElement: sixxElement context: aDictionary</body><body package="SIXX-InOut">initializeIndexFieldsFromSixxElement: sixxElement context: aDictionary 	| idx nonameElems |	idx := 1.	nonameElems := (SixxXmlUtil elementsFrom: sixxElement) 				select: [:each | (self class nameFromSixxElement: each) isNil].	nonameElems isEmpty 		ifFalse: 			[nonameElems do: 					[:elem | 					| childInst |					(SixxXmlUtil isTextFrom: elem) 						ifFalse: 							[childInst := self class fromSixxElement: elem context: aDictionary.							self sixxAt: idx put: childInst.							idx := idx + 1]]]</body><body package="SIXX-InOut">initializeInstVarsFromSixxElement: sixxElement context: aDictionary 	(SixxXmlUtil elementsFrom: sixxElement) do: 			[:elem | 			| varName |			(SixxXmlUtil isTextFrom: elem) 				ifFalse: 					[varName := self class nameFromSixxElement: elem.					varName notNil 						ifTrue: 							[| childInst |							childInst := self class fromSixxElement: elem context: aDictionary.							self sixxInstVarNamed: varName put: childInst]]]</body><body package="SIXX-InOut">initializeMixedFieldsFromSixxElement: sixxElement context: aDictionary 	self initializeInstVarsFromSixxElement: sixxElement context: aDictionary.	self initializeIndexFieldsFromSixxElement: sixxElement context: aDictionary</body></methods><methods><class-id>Core.Object</class-id> <category>testing-sixx</category><body package="SIXX-InOut">isSixxShapeChanger	^false</body></methods><methods><class-id>Core.Object</class-id> <category>initializing-sixx</category><body package="SIXX-InOut">sixxAt: index put: aValue 	"override if you like"	self at: index put: aValue</body></methods><methods><class-id>Core.Object</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxChildrenContentsOn: aStream indent: level context: dictionary 	self class isBits		ifTrue: [aStream nextPutAll: '#( '.			1 to: self size do: [:idx | 				aStream nextPutAll: (self at: idx) printString; space			].			aStream nextPutAll: ')'.			^ self].			self class isVariable		ifTrue: [^ self				sixxMixedFieldsOn: aStream				indent: level				context: dictionary].				self		sixxInstVarsOn: aStream		indent: level		context: dictionary</body></methods><methods><class-id>Core.Object</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	"Override if you like"	"Typically usable for a customized serialization of the receiver's elements"	self		sixxChildrenContentsOn: aStream		indent: level + 1		context: dictionary.	aStream tab: level</body></methods><methods><class-id>Core.Object</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxEnv	^SixxPortableUtil environmentQualifierOf: self class</body><body package="SIXX-InOut">sixxIgnorableInstVarNames	"Override if you wish"	"If you would like to omit some inst vars in serialization, List their names here."	^#()</body><body package="SIXX-InOut">sixxIndexFieldsOn: aStream indent: level context: dictionary 	"override if you like"	| size |	size := self basicSize.	size = 0 ifTrue: [^self].	1 to: size		do: 			[:i | 			| element |			element := self basicAt: i.			element 				sixxOn: aStream				indent: level				context: dictionary]</body></methods><methods><class-id>Core.Object</class-id> <category>initializing-sixx</category><body package="SIXX-InOut">sixxInitialize	"override if you like"	"The method is called after the loading of the receiver - just like #initializaAfterLoad in Envy"	"It is useful to initializa attributes that cannot be stored in SIXX (Block, Context, etc)"	</body><body package="SIXX-InOut">sixxInstVarNamed: instVarName put: aValue 	"override if you like"	"can be used for changing shape"	| index |	index := self class allInstVarNames indexOf: instVarName asString.	index = 0 ifTrue: [^self].	self instVarAt: index put: aValue</body></methods><methods><class-id>Core.Object</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxInstVarNamed: varName value: varValue on: aStream indent: level context: dictionary 	"override if you wish"	(dictionary settings suppressNilWrite and: [varValue isNil]) ifTrue: [^self].	((self sixxIgnorableInstVarNames collect: [:each | each asString]) includes: varName) ifTrue: [^ self].	(((self sixxNonReferencableInstVarNames collect: [:each | each asString]) includes: varName)			and: [varValue notNil])		ifTrue: [^ varValue				sixxNoRefOn: aStream				name: varName				indent: level				context: dictionary].	varValue		sixxOn: aStream		name: varName		indent: level		context: dictionary</body><body package="SIXX-InOut">sixxInstVarsOn: aStream indent: level context: dictionary 	| instVars ind |	aStream cr.	instVars := self class allInstVarNames.	ind := 0.	instVars		do: [:nm | 			ind := ind + 1.			self				sixxInstVarNamed: nm				value: (self instVarAt: ind)				on: aStream				indent: level				context: dictionary]</body><body package="SIXX-InOut">sixxMixedFieldsOn: aStream indent: level context: dictionary 	self 		sixxInstVarsOn: aStream		indent: level		context: dictionary.	self 		sixxIndexFieldsOn: aStream		indent: level		context: dictionary</body><body package="SIXX-InOut">sixxNonReferencableInstVarNames	"Override if you wish"	"If you would like to omit some inst vars in serialization, List their names here."	^#()</body><body package="SIXX-InOut">sixxNoRefOn: aStream name: nameString indent: level context: dictionary 	"For non-sharable objects"	self writeSixxTagOn: aStream id: nil name: nameString indent: level context: dictionary </body></methods><methods><class-id>Core.Object</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxOn: aStream 	self		sixxOn: aStream		indent: 0		context: SixxContext forWrite</body><body package="SIXX-InOut">sixxOn: aStream indent: level context: dictionary 	^self		sixxOn: aStream		name: nil		indent: level		context: dictionary</body><body package="SIXX-InOut">sixxOn: aStream name: nameString indent: level context: dictionary 	self sixxPrepareWrite.	self sixxWriteValue		basicSixxOn: aStream		originator: self		name: nameString		indent: level		context: dictionary</body></methods><methods><class-id>Core.Object</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxPrepareWrite	"Override if you like"	"It is used for preparing the receiver's states for serialization "</body><body package="SIXX-InOut">sixxReadValue	"Override if you wish"	"It can be useful when memento would like to return real object"	^self</body><body package="SIXX-InOut">sixxReferenceIdInContext: dictionary	"override if you would like to generate id by yourself"	^dictionary size printString</body><body package="SIXX-InOut">sixxRefOn: aStream id: idString name: nameString indent: level context: dictionary 	self		writeEmptySixxTagOn: aStream		attributesDo: [:wStr | 			self writeSixxAttributeOn: wStr name: nameString.			self writeSixxAttributeOn: wStr idref: idString]		name: nameString		indent: level		context: dictionary</body><body package="SIXX-InOut">sixxRefTagStartString: idString name: nameString 	| constants |	constants := SixxConstants current.	^SixxXmlUtil contentsWithStartTagNamed: constants objectTagName do: [:wStr |   		SixxXmlUtil writeAttribute: constants idrefTagName value: idString on: wStr.		SixxXmlUtil writeAttribute: constants nameTagName value: nameString on: wStr.	]</body></methods><methods><class-id>Core.Object</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxString	| wStr |	wStr := (String new: 128) writeStream.	self sixxOn: wStr.	^wStr contents</body></methods><methods><class-id>Core.Object</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxType	^self class name</body><body package="SIXX-InOut">sixxWriteValue	"Override if you wish"	"It can be useful when you would like to store the receiver in a memento (minimal representation) form."	^self</body><body package="SIXX-InOut">writeBasicSixxAttributesOn: aStream name: nameString	SixxXmlUtil writeBasicSixxAttributesOf: self on: aStream name: nameString</body><body package="SIXX-InOut">writeEmptySixxTagOn: aStream attributesDo: block name: nameString indent: level context: dictionary 	| constants |	aStream tab: level.	constants := SixxConstants current.	SixxXmlUtil		writeEmptyTagNamed: constants objectTagName		attributesDo: [:wStr | block value: wStr]		on: aStream.	aStream cr</body><body package="SIXX-InOut">writeSixxAttributeOn: aStream formatter: formatter	formatter isNil ifTrue: [^self].	SixxXmlUtil writeAttribute: SixxConstants current formatterTagName value: formatter name on: aStream.</body><body package="SIXX-InOut">writeSixxAttributeOn: aStream id: idString	idString isNil ifTrue: [^self].	SixxXmlUtil writeAttribute: SixxConstants current idTagName value: idString on: aStream.</body><body package="SIXX-InOut">writeSixxAttributeOn: aStream idref: idrefString	SixxXmlUtil writeAttribute: SixxConstants current idrefTagName value: idrefString on: aStream.</body><body package="SIXX-InOut">writeSixxAttributeOn: aStream name: nameString	SixxXmlUtil writeAttribute: SixxConstants current nameTagName value: nameString on: aStream.</body><body package="SIXX-InOut">writeSixxTagOn: aStream id: idStr name: nameString indent: level context: dictionary 	| constants formatter |	aStream tab: level.	constants := SixxConstants current.	formatter := dictionary formatterResolver				formatterAt: self class				in: self sixxEnv.	SixxXmlUtil		writeTagNamed: constants objectTagName		attributesDo: [:wStr | 			self writeSixxAttributeOn: wStr id: idStr.			self writeBasicSixxAttributesOn: wStr name: nameString.			self writeSixxAttributeOn: wStr formatter: formatter]		contentDo: [:wStr | formatter isNil				ifTrue: [self						sixxContentOn: wStr						indent: level						context: dictionary]				ifFalse: [formatter						format: self						on: wStr						indent: level						context: dictionary]]		on: aStream.	aStream cr</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	"For old format"	(SixxXmlUtil elementsFrom: sixxElement ) isEmpty ifFalse: [		^super createInstanceOf: aClass withSixxElement: sixxElement	].	^ self readSixxContentStringFrom: (ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement))</body></methods><methods><class-id>Kernel.Context</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: self printString</body></methods><methods><class-id>Core.Number class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^(SixxXmlUtil characterDataFrom: sixxElement) asNumber</body></methods><methods><class-id>Core.Number</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: self sixxContentString</body></methods><methods><class-id>Core.Number</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxContentString	^self printString</body></methods><methods><class-id>Core.False class</class-id> <category>printing-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^false</body></methods><methods><class-id>Core.UndefinedObject class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement	^ nil</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxOn: aStream name: nameString indent: level context: dictionary 	self		writeEmptySixxTagOn: aStream		attributesDo: [:wStr | 			self writeBasicSixxAttributesOn: wStr name: nameString]		name: nameString		indent: level		context: dictionary</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^self readSixxContentStringFrom: (ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement))</body></methods><methods><class-id>Core.Time</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: self sixxContentString</body></methods><methods><class-id>Core.Integer class</class-id> <category>instance creation</category><body package="SIXX-InOut">readShortHexFrom: aStream 	| digit value startPos |	value := 0.	startPos := aStream position.	[aStream atEnd] whileFalse: 			[digit := aStream next digitValue.			(digit &lt; 0 or: [digit &gt;= 16]) 				ifTrue: 					[aStream skip: -1.					aStream position = startPos 						ifTrue: [self error: 'At least one digit expected here'].					^value]				ifFalse: [value := value * 16 + digit]].	^value</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="SIXX-InOut">shortHexString	| current letters digits quo i |	digits := '0123456789ABCDEF'.	current := self.	i := self digitLength * 8.	letters := String new: i.	[current &lt; 16] whileFalse: 			[quo := current quo: 16.			letters at: i put: (digits at: current - (quo * 16) + 1).			i := i - 1.			current := quo].	letters at: i put: (digits at: current + 1).	^letters copyFrom: i to: letters size</body></methods><methods><class-id>Core.WordArray class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	| col |	col := Array readFrom: (ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement)).	^self withAll: col</body></methods><methods><class-id>Core.WordArray</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: '#( '.	self do: [:each | aStream nextPutAll: each printString; space].	aStream nextPutAll: ')'</body></methods><methods><class-id>Core.Behavior</class-id> <category>private-sixx</category><body package="SIXX-InOut">classFromSixxElement: sixxElement context: dictionary 	|  type env resolver retClass |	type := self typeFromSixxElement: sixxElement.	type isNil ifFalse:[		env := self envFromSixxElement: sixxElement.		resolver := dictionary classResolver.		retClass :=  resolver classAt: type in: env.	].	^ retClass isNil		ifTrue: [SixxClassNotFound				signal: type				element: sixxElement				context: dictionary]		ifFalse: [retClass]</body></methods><methods><class-id>Core.Behavior</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	"override if you like"	^aClass isVariable 		ifTrue: 			[self createMixedFieldsInstanceOf: aClass withSixxElement: sixxElement]		ifFalse: [self sixxNew: aClass withSixxElement: sixxElement]</body><body package="SIXX-InOut">createMixedFieldsInstanceOf: aClass withSixxElement: sixxElement 	"override if you like"	| nonameElems size |	nonameElems := (SixxXmlUtil elementsFrom: sixxElement) 				select: [:each | (self nameFromSixxElement: each) isNil].	size := nonameElems isEmpty ifTrue: [0] ifFalse: [nonameElems size].	^self 		sixxNew: aClass		size: size		withSixxElement: sixxElement</body></methods><methods><class-id>Core.Behavior</class-id> <category>private-sixx</category><body package="SIXX-InOut">envFromSixxElement: sixxElement 	^SixxXmlUtil attributeSymbolAt: SixxConstants current envTagName from: sixxElement.</body><body package="SIXX-InOut">formatterFromSixxElement: sixxElement for: aClass context: dictionary 	| formatterName env resolver formatter |	formatterName := self formatterNameFromSixxElement: sixxElement. 	formatterName isNil ifTrue: [^nil].	env := self envFromSixxElement: sixxElement.	resolver := dictionary formatterResolver.	formatter :=  resolver formatterAt: aClass in: env.		^ formatter isNil		ifTrue: [SixxFormatterNotFound				signal: formatterName				element: sixxElement				context: dictionary]		ifFalse: [formatter]</body><body package="SIXX-InOut">formatterNameFromSixxElement: sixxElement 	^SixxXmlUtil attributeSymbolAt: SixxConstants current formatterTagName from: sixxElement.</body><body package="SIXX-InOut">fromSixxElement: sixxElement context: aDictionary 	^(self includesRefInstanceFromSixxElement: sixxElement context: aDictionary)		ifTrue: [self refInstanceFromSixxElement: sixxElement context: aDictionary]		ifFalse: [self newInstanceFromSixxElement: sixxElement context: aDictionary]</body><body package="SIXX-InOut">idFromSixxElement: sixxElement 	| sixxKey |	sixxKey := SixxXmlUtil attributeAt: SixxConstants current idTagName from: sixxElement.	^sixxKey isNil ifTrue: [''] ifFalse: [sixxKey]</body><body package="SIXX-InOut">idrefFromSixxElement: sixxElement	^SixxXmlUtil attributeAt: SixxConstants current idrefTagName from: sixxElement.</body><body package="SIXX-InOut">includesRefInstanceFromSixxElement: sixxElement context: aDictionary 	| idref |	idref := self idrefFromSixxElement: sixxElement.	^idref isNil		ifTrue: [false]		ifFalse: [aDictionary includesKey: idref]</body><body package="SIXX-InOut">nameFromSixxElement: sixxElement 	^SixxXmlUtil attributeSymbolAt: SixxConstants current nameTagName from: sixxElement.	</body><body package="SIXX-InOut">newInstanceFromSixxElement: sixxElement context: aDictionary 	| class formatter inst elemId newInst |	class := self classFromSixxElement: sixxElement context: aDictionary.	class isNil ifTrue: [^nil].	elemId := self idFromSixxElement: sixxElement.	formatter := self formatterFromSixxElement: sixxElement for: class context: aDictionary.	formatter isNil ifTrue: [		inst :=  class createInstanceOf: class withSixxElement: sixxElement.		aDictionary at: elemId put: inst.		inst initializeFromSixxElement: sixxElement context: aDictionary.	] ifFalse: [		inst :=  formatter createInstanceOf: class withSixxElement: sixxElement.		aDictionary at: elemId put: inst.		formatter initialize: inst fromSixxElement: sixxElement context: aDictionary.	].	inst sixxInitialize.	newInst := inst sixxReadValue.	aDictionary at: elemId put: newInst.	(inst isSixxShapeChanger and: [inst circularReference])		ifTrue: [inst sixxBecomeTo: newInst].	^ newInst</body></methods><methods><class-id>Core.Behavior</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">readSixxFrom: xmlStringOrStream 	^self readSixxFrom: xmlStringOrStream context: SixxContext forRead</body><body package="SIXX-InOut">readSixxFrom: xmlStringOrStream context: aDictionary 	| topElem |	topElem := SixxXmlUtil parseXml: xmlStringOrStream.	^self readSixxFromSixxElement: topElem context: aDictionary</body><body package="SIXX-InOut">readSixxFromSixxElement: sixxElement context: aDictionary 	| rootClass typeAttr |	typeAttr := self typeFromSixxElement: sixxElement.	^typeAttr isNil		ifTrue: [(self includesRefInstanceFromSixxElement: sixxElement context: aDictionary)				ifTrue: [self refInstanceFromSixxElement: sixxElement context: aDictionary]				ifFalse:[SixxNoTypeDefinition signalElement: sixxElement context: aDictionary]]		ifFalse: [rootClass := self classFromSixxElement: sixxElement context: aDictionary.			rootClass isNil				ifFalse: [rootClass fromSixxElement: sixxElement context: aDictionary]]</body></methods><methods><class-id>Core.Behavior</class-id> <category>private-sixx</category><body package="SIXX-InOut">refInstanceFromSixxElement: sixxElement context: aDictionary 	| idref |	idref := self idrefFromSixxElement: sixxElement.	^aDictionary at: idref</body></methods><methods><class-id>Core.Behavior</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">sixxNew: aClass size: size withSixxElement: sixxElement 	^[aClass new: size] on: Error		do: 			[:ex | 			| alterClass |			alterClass := SixxNewFailed signal: aClass name element: sixxElement.			alterClass isNil 				ifTrue: 					[[aClass basicNew: size] on: Error						do: [self sixxNew: aClass withSixxElement: sixxElement]]				ifFalse: [alterClass basicNew: size]]</body><body package="SIXX-InOut">sixxNew: aClass withSixxElement: sixxElement 	^[aClass new] on: Error		do: 			[:ex | 			| alterClass |			alterClass := SixxNewFailed signal: aClass name element: sixxElement.			alterClass isNil ifTrue: [aClass basicNew] ifFalse: [alterClass basicNew]]</body></methods><methods><class-id>Core.Behavior</class-id> <category>private-sixx</category><body package="SIXX-InOut">typeFromSixxElement: sixxElement 	^SixxXmlUtil attributeSymbolAt: SixxConstants current typeTagName from: sixxElement.	</body></methods><methods><class-id>Core.Symbol class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^(super createInstanceOf: aClass withSixxElement: sixxElement) asSymbol</body></methods><methods><class-id>Core.Symbol</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxType	^#Symbol</body></methods><methods><class-id>Core.Interval class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^self readFrom: (ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement))</body></methods><methods><class-id>Core.Interval</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: self printString</body></methods><methods><class-id>Core.Boolean</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxOn: aStream name: nameString indent: level context: dictionary	self		writeEmptySixxTagOn: aStream		attributesDo: [:wStr | 			self writeBasicSixxAttributesOn: wStr name: nameString]		name: nameString		indent: level		context: dictionary	</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^SixxXmlUtil characterDataFrom: sixxElement</body></methods><methods><class-id>Core.String</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	SixxXmlUtil writeXmlText: self on: aStream</body><body package="SIXX-InOut">sixxType	^#String</body></methods><methods><class-id>Core.ArrayedCollection</class-id> <category>initializing-sixx</category><body package="SIXX-InOut">initializeFromSixxElement: sixxElement context: aDictionary 	"override to use #initializeMixedFieldsFromSixxElement:context: if having some inst vars"	| idx |	idx := 1.	(SixxXmlUtil elementsFrom: sixxElement) do: 			[:elem | 			| childInst |			(SixxXmlUtil isTextFrom: elem) 				ifFalse: 					[childInst := self class fromSixxElement: elem context: aDictionary.					self at: idx put: childInst.					idx := idx + 1]]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxDo: aBlock	self associationsDo: aBlock</body></methods><methods><class-id>Core.True class</class-id> <category>printing-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^true</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^aClass isMeta		ifTrue: [aClass soleInstance]		ifFalse: [aClass]</body></methods><methods><class-id>Core.Text</class-id> <category>initializing-sixx</category><body package="SIXX-InOut">initializeFromSixxElement: sixxElement context: aDictionary 	(SixxXmlUtil elementsFrom: sixxElement)		do: 			[:elem | 			| varName |			(SixxXmlUtil isTextFrom: elem)				ifFalse: 					[varName := self class nameFromSixxElement: elem.					varName notNil						ifTrue: 							[| childInst |							childInst := self class fromSixxElement: elem context: aDictionary.							self sixxInstVarNamed: varName put: childInst]]]</body></methods><methods><class-id>Core.Text</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	self		sixxChildrenContentsOn: aStream		indent: level + 1		context: dictionary.	aStream tab: level</body></methods><methods><class-id>Core.Collection class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	"override to use #createMixedFieldsInstanceOf:withSixxElement: if you have extra inst vars"	^self 		sixxNew: aClass		size: (SixxXmlUtil elementsFrom: sixxElement) size		withSixxElement: sixxElement</body></methods><methods><class-id>Core.Collection</class-id> <category>initializing-sixx</category><body package="SIXX-InOut">initializeFromSixxElement: sixxElement context: aDictionary 	"override to use #initializeMixedFieldsFromSixxElement:context: if having some inst vars"	(SixxXmlUtil elementsFrom: sixxElement) do: 			[:elem | 			| childInst |			childInst := self class fromSixxElement: elem context: aDictionary.			self add: childInst]</body></methods><methods><class-id>Core.Collection</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary	"default just uses #sixxDo: - override it to use #sixxMixedFieldsOn:indent:context: if your collection need to store some inst vars"	self isEmpty ifFalse: [aStream cr].	self		sixxDo: [:each | each				sixxOn: aStream				indent: level + 1				context: dictionary].	self isEmpty ifFalse: [aStream tab: level].</body></methods><methods><class-id>Core.Collection</class-id> <category>private-sixx</category><body package="SIXX-InOut">sixxDo: aBlock	self do: aBlock</body><body package="SIXX-InOut">sixxIndexFieldsOn: aStream indent: level context: dictionary 	self size = 0 ifTrue: [^self].	aStream cr.	self sixxDo: 			[:each | 			each 				sixxOn: aStream				indent: level				context: dictionary]</body><body package="SIXX-InOut">sixxMixedFieldsOn: aStream indent: level context: dictionary 	"override"	"Usually Collection's inst vars are not needed for serialization"	self 		sixxIndexFieldsOn: aStream		indent: level		context: dictionary</body></methods><methods><class-id>Core.Point class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	| readStr xString yString x y |	readStr := ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement).	xString := readStr upTo: $@.	yString := readStr upToEnd.	x := (xString indexOf: $/) &gt; 0 ifTrue: [Fraction readSixxContentStringFrom: xString readStream] ifFalse: [xString asNumber].	y := (yString indexOf: $/) &gt; 0 ifTrue: [Fraction readSixxContentStringFrom: yString readStream] ifFalse: [yString asNumber].	^self x: x y: y</body></methods><methods><class-id>Core.Point</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: x printString.	aStream nextPut: $@.	aStream nextPutAll: y printString</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	| rawStr col |	rawStr := ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement).	col := rawStr peek = $# 				ifTrue: [Array readFrom: rawStr]				ifFalse: [self readShortHexFrom: rawStr].	^self withAll: col</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="SIXX-InOut">readShortHexFrom: aStream	| sz inst |	sz := aStream size // 2.	inst := self new: sz.	1 to: sz do: [:idx | 	inst byteAt: idx put: (Integer readShortHexFrom: (aStream next: 2) readStream)	].	^inst</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="SIXX-InOut">shortHexString	| sz stream |	sz := self size.	stream := WriteStream on: (String new: sz * 2).	1 to: sz		do: 			[:idx | 			| elem |			elem := self byteAt: idx.			elem &lt; 16 ifTrue: [stream nextPut: $0].			stream nextPutAll: elem shortHexString].	^stream contents</body></methods><methods><class-id>Core.ByteArray</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	1 to: self size		do: 			[:idx | 			| elem |			elem := self byteAt: idx.			elem &lt; 16 ifTrue: [aStream nextPut: $0].			aStream nextPutAll: elem shortHexString]</body></methods><methods><class-id>Core.Character class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	^self readFrom: (ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement))</body></methods><methods><class-id>Core.Character</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream nextPutAll: self storeString</body></methods><methods><class-id>Core.RunArray</class-id> <category>initializing-sixx</category><body package="SIXX-InOut">initializeFromSixxElement: sixxElement context: aDictionary 	(SixxXmlUtil elementsFrom: sixxElement)		do: 			[:elem | 			| varName |			(SixxXmlUtil isTextFrom: elem)				ifFalse: 					[varName := self class nameFromSixxElement: elem.					varName notNil						ifTrue: 							[| childInst |							childInst := self class fromSixxElement: elem context: aDictionary.							self sixxInstVarNamed: varName put: childInst]]]</body></methods><methods><class-id>Core.RunArray</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	aStream cr.	self runs		sixxOn: aStream		name: 'runs'		indent: level + 1		context: dictionary.	self values		sixxOn: aStream		name: 'values'		indent: level + 1		context: dictionary.	aStream tab: level</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>instance creation-sixx</category><body package="SIXX-InOut">createInstanceOf: aClass withSixxElement: sixxElement 	| readStr origin corner |	"For old format"	(SixxXmlUtil elementsFrom: sixxElement ) isEmpty ifFalse: [		^super createInstanceOf: aClass withSixxElement: sixxElement	].	readStr := ReadStream on: (SixxXmlUtil characterDataFrom: sixxElement).	origin := ((readStr upTo: $@) asNumber) @ (readStr upTo: Character space) asNumber.	readStr upTo: $:; upTo: Character space. "For portability"	corner := ((readStr upTo: $@) asNumber) @ (readStr upToEnd) asNumber.	^origin corner: corner</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>printing-sixx</category><body package="SIXX-InOut">sixxContentOn: aStream indent: level context: dictionary 	self origin sixxContentOn: aStream indent: level context: dictionary.	aStream nextPutAll: ' corner: '.	self corner sixxContentOn: aStream indent: level context: dictionary.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>WordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>