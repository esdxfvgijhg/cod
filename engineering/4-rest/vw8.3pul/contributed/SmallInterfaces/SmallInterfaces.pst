<?xml version="1.0"?><st-source><!-- Name: SmallInterfacesComment: Look at the class side documentation protocol of Interface, especially: Interface class>>_5_What_can_you_do_with_SmallInterfacesSee also:Benny Sadeh, Stéphane Ducasse: "Adding Dynamic Interfaces to Smalltalk", in Journal of Object Technology, vol. 1, no. 1, May-June 2002, pp. 63-79http://www.jot.fm/issues/issue_2002_05/article1SmallInterfaces was first developed by Benny Sadeh.DbIdentifier: psql_public_cst_2007DbTrace: 65853HideSource: falseNotification: Copyright © 1999 Benny Sadeh.This software is provided under the Artistic License terms.PackageName: SmallInterfacesParcel: #('SmallInterfaces')ParcelName: SmallInterfacesPrintStringCache: (2.0.3,niallr)SaveSource: trueVersion: 2.0.3Pre-Load Block: 	[ :pkg |  ]Post-Load Block: 	[ :pkg |  ]Date: 9:46:52 AM October 16, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (sep09.3) of September 18, 2009 on October 16, 2009 at 9:46:52 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Interface</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallInterfaces</category><attributes><package>SmallInterfaces</package></attributes></class><comment><class-id>Interface</class-id><body>An Interface is an abstract Type, unlike Class which is a concrete Type. An interface specifies a set of messages that an object of any class conforming to it would respond to. Therefore, it is orthogonal to Class, which propagates the implementation of a message to its instances. For a more comprehensive explanation and a tutorial, look at the 'documentation' protocol (on the class side) </body></comment><class><name>InterfaceHome</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>singleton </class-inst-vars><imports></imports><category>SmallInterfaces</category><attributes><package>SmallInterfaces</package></attributes></class><comment><class-id>InterfaceHome</class-id><body>InterfaceHome is the access point for all interfaces.Its sole responsibility is to provide 'slice &amp; dice' views on interfaces.As of now it is a pseudo-repository. However, it has a hook to facilitate streaming in &amp; out of interfaces.This should be done via by implementing a different singltone access.Class Instance Variables:singleton	&lt;InterfaceHome&gt;	holds the current InterfaceHome.</body></comment><class><name>InterfaceConfiguration</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discardInterfacesOnShutDown notifyOnDerivationDiscovery removeOnlyStubs selectorForInterfaceInheritance selectorForClassInterfaces synchronize synchronizeSelectively synchronizeWithConformers synchronizeWithExtenders </inst-vars><class-inst-vars>singleton </class-inst-vars><imports></imports><category>SmallInterfaces</category><attributes><package>SmallInterfaces</package></attributes></class><comment><class-id>InterfaceConfiguration</class-id><body>InterfaceConfiguration is responsible for the system-wide behavior of interfaces.The current configuration can be switched by either configuring the current singletone, or by replacing the current singletone with another configuration.Look at #reset and #setDefaults for suggested configurations.Instance Variables:discardInterfacesOnShutDown		&lt;Boolean&gt;	... should all cached repertoires be discarded each time the image is saved?notifyOnDerivationDiscovery			&lt;Boolean&gt;	... should the user be notifyied upon a discovery of derivation from an interface? 									this happen when a behavior had just added a new message and it is now inferred to derive from an interface.removeOnlyStubbs					&lt;Boolean&gt;	... when unimplementing an interface for a class, should only stubbed methods be removed?selectorForInterfaceInheritance		&lt;Symbol&gt;	determines which interfaces should be shown in the definition string (e.g.: all extended).selectorForClassInterfaces			&lt;Symbol&gt;	determines which interfaces should be shown in the definition string (e.g. all understood).synchronize							&lt;Boolean&gt;	... should an interface change be synchronized with affected relatives (conformers &amp; extenders)?synchronizeSelectively				&lt;Boolean&gt;	... selectively choose which relatives to upgrade/downgrade when synchronizing a change?synchronizeWithConformers			&lt;Boolean&gt;	... synchronize an interface change with conforming behaviors?synchronizeWithExtenders			&lt;Boolean&gt;	... synchronize an interface change with extending interfaces? Class Instance Variables:singleton	&lt;InterfaceConfiguration&gt;	holds the current InterfaceConfiguration.</body></comment><class><name>RepertoireHome</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classRepertoiresDictionary </inst-vars><class-inst-vars>singleton </class-inst-vars><imports></imports><category>SmallInterfaces</category><attributes><package>SmallInterfaces</package></attributes></class><comment><class-id>RepertoireHome</class-id><body></body></comment><shared-variable><name>GenericMetaRepertoire</name><environment>RepertoireHome</environment><private>false</private><constant>false</constant><category>Meta interface</category><attributes><package>SmallInterfaces</package></attributes></shared-variable><methods><class-id>Interface class</class-id> <category>accessing-methods</category><body package="SmallInterfaces" selector="compilableMetaSelectors">compilableMetaSelectors	^#(#isSealed #mustBeImplemented)</body><body package="SmallInterfaces" selector="methodsImplementedBy:">methodsImplementedBy: aBehavior	^self repertoire &amp; aBehavior repertoireImplemented</body><body package="SmallInterfaces" selector="methodsNotImplementedBy:">methodsNotImplementedBy: aBehavior	^self repertoire - aBehavior repertoireImplemented</body><body package="SmallInterfaces" selector="methodsNotUnderstoodBy:">methodsNotUnderstoodBy: aBehavior	^self repertoire - aBehavior repertoire</body><body package="SmallInterfaces" selector="methodsStubedIn:">methodsStubedIn: aBehavior	^self repertoire &amp; (aBehavior whichSelectorsReferTo: self selectorForStubedImplementation)</body><body package="SmallInterfaces" selector="methodsStubedIn:for:">methodsStubedIn: aBehavior for: anInterface	"Note: this method is useful in the following scenario:	interface A repertoire = #(a b c).	interface B repertoire = #(b c d).	class C was declared to understand both A and B, and as a result it has #(a b c d) stubbed.	If we wanted to delete A without affecting &lt;C understands: B&gt;, we could use this method to	figure out which methods are specifically stubbed for &lt;anInterface&gt;."		^(anInterface methodsStubedIn: aBehavior) &amp;	(aBehavior allSelectorsReferencing: anInterface)</body></methods><methods><class-id>Interface class</class-id> <category>errors</category><body package="SmallInterfaces" selector="basicNew">basicNew	self error: 'I am an Interface. I can not be instantiated!'</body><body package="SmallInterfaces" selector="implementorsResponsibility">implementorsResponsibility	"This method is invoked via: 'anObject shouldImplementFor: anInterface'.	It is intended to serve as an implementation hook for the behavior of &lt;anObject&gt;.	This can be achieved after extracting the sender (such as via thisContext), then using 	a default implementation (such as via valueWithReceiver:arguments:)."	self error: 'My implementing class should have overridden one of my messages.'</body><body package="SmallInterfaces" selector="new">new	self error: 'I am an Interface. I can not be instantiated!'</body></methods><methods><class-id>Interface class</class-id> <category>class creation</category><body package="SmallInterfaces" selector="asClass">asClass	^self asClassNamed: self defaultClassName</body><body package="SmallInterfaces" selector="asClassNamed:">asClassNamed: aSymbol	^self 		asClassNamed: aSymbol 		super: Object</body><body package="SmallInterfaces" selector="asClassNamed:super:">asClassNamed: aSymbol super: aClass 	^self		asClassNamed: aSymbol		super: aClass		namespace: self environment</body><body package="SmallInterfaces" selector="asClassNamed:super:namespace:">asClassNamed: aSymbol super: aClass namespace: aNameSpace 	^aNameSpace		defineClass: aSymbol		superclass: aClass fullyQualifiedReference		indexedType: aClass behaviorType		private: (self environment bindingFor: self name) isPrivate		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: (aClass asNameSpace importString)		category: (self environment organization class defaultProtocol)		interfaces: (self name asString)</body><body package="SmallInterfaces" selector="asMetaclass">asMetaclass	^self asMetaclassNamed: self defaultClassName</body><body package="SmallInterfaces" selector="asMetaclassNamed:">asMetaclassNamed: aSymbol	^self 		asMetaclassNamed: aSymbol 		super: Object</body><body package="SmallInterfaces" selector="asMetaclassNamed:super:">asMetaclassNamed: aSymbol super: aClass 	^self		asMetaclassNamed: aSymbol		super: aClass		namespace: self environment</body><body package="SmallInterfaces" selector="asMetaclassNamed:super:namespace:">asMetaclassNamed: aSymbol super: aClass namespace: aNameSpace 	| meta |		"a quick and dirty way..."	meta := (self				asClassNamed: aSymbol				super: aClass				namespace: aNameSpace) class.	meta removeMethods: self repertoire.	meta implement: self</body></methods><methods><class-id>Interface class</class-id> <category>interface creation</category><body package="SmallInterfaces" selector="newNamed:">newNamed: aSymbol 	"self isPrivateMethod."	| interface |	self ~~ Interface 		ifTrue: [self error: 'an interface must be a direct subclass of Interface!'].	(self home includesInterfaceNamed: aSymbol) 		ifTrue: [^self error: aSymbol asString, ' interface already exists!'].	interface := self 		subclass: aSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: (Interface configuration defaultCategory)		interfaces: ''.			interface resetRepertoire.	^interface</body><body package="SmallInterfaces" selector="newNamed:extending:">newNamed: aSymbol extending: stringOfInterfaces	^self		newNamed: aSymbol 		extending: stringOfInterfaces		additionalSelectors: #()</body><body package="SmallInterfaces" selector="newNamed:extending:additionalSelectors:">newNamed: aSymbol extending: stringOfInterfaces additionalSelectors: selectors	| interface |	interface := self newNamed: aSymbol.	Interface valueWithoutSynchronization:		[interface extendAll: (Interface interfacesFromString: stringOfInterfaces).		interface createMethods: selectors asSet].	interface resetRepertoire.	^interface</body><body package="SmallInterfaces" selector="newNamed:from:">newNamed: aSymbol from: aClass	| interface | 	Interface valueWithoutSynchronization:		[interface := self 			newNamed: aSymbol 			withSelectors: aClass selectors 			from: aClass].	^interface</body><body package="SmallInterfaces" selector="newNamed:withSelectors:">newNamed: aSymbol withSelectors: selectors	| interface | 	Interface valueWithoutSynchronization:		[interface := (self newNamed: aSymbol) createMethods: selectors].	^interface</body><body package="SmallInterfaces" selector="newNamed:withSelectors:from:">newNamed: aSymbol withSelectors: selectors from: aClass	| interface | 	Interface valueWithoutSynchronization:		[interface := (self newNamed: aSymbol)			createMethods: selectors 			from: aClass].	^interface</body><body package="SmallInterfaces" selector="superclass:">superclass: aClass 	aClass ~~ Interface 		ifTrue: [self error: 'an interface must be a direct subclass of Interface!'].	super superclass: aClass.</body><body package="SmallInterfaces" selector="template:">template: category 	"Answer an expression that can be edited and evaluated in order to define a new Interface."	^'Interface subclass: #NameOfInterface	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''', category asString storeString, '	interfaces: '''' '</body></methods><methods><class-id>Interface class</class-id> <category>testing</category><body package="SmallInterfaces" selector="extends:">extends: anInterface	^(self ~~ anInterface) and:	[self repertoire includesAll: anInterface repertoire]</body><body package="SmallInterfaces" selector="hasEquivalents">hasEquivalents	^self equivalents notEmpty</body><body package="SmallInterfaces" selector="hasParents">hasParents	"A simple interface is an orphan"	^self parents notEmpty</body><body package="SmallInterfaces" selector="isEmbodiedIn:">isEmbodiedIn: anObject	^anObject conformsTo: self</body><body package="SmallInterfaces" selector="isEmpty">isEmpty	^self repertoire isEmpty</body><body package="SmallInterfaces" selector="isEquivalentTo:">isEquivalentTo: anInterface	^self repertoire consistsOf: anInterface repertoire</body><body package="SmallInterfaces" selector="isExtended">isExtended	"Note: not using 'self extendingInterfaces notEmpty' for speed"	^self home allInterfaces contains: [:each | self isExtendedBy: each]</body><body package="SmallInterfaces" selector="isExtendedBy:">isExtendedBy: anInterface	^anInterface extends: self</body><body package="SmallInterfaces" selector="isExtending">isExtending	^self home allInterfaces contains: [:each | self extends: each]</body><body package="SmallInterfaces" selector="isImmutable">isImmutable	"Can I be modified?	Interfaces which should be left as is (such as ANSI Protocols) should override with ^true.	See: #makeImmutable:"		^false</body><body package="SmallInterfaces" selector="isImplementedBy:">isImplementedBy: aClass	"Does &lt;aClass&gt; directly implement all of my repertoire?"	^aClass repertoireImplemented includesAll: self repertoire</body><body package="SmallInterfaces" selector="isInterface">isInterface	"All subclass are considered as interfeces, excluding the superclass - Interface."	^self ~~ Interface</body><body package="SmallInterfaces" selector="isOrphan">isOrphan	"A composite interface has parents"		^self hasParents not</body><body package="SmallInterfaces" selector="isUnderstoodBy:">isUnderstoodBy: aBehavior	"Can &lt;aBehavior&gt; understand all of &lt;anInterface&gt; repertoire?"	^aBehavior repertoire includesAll: self repertoire</body><body package="SmallInterfaces" selector="mustBeImplemented">mustBeImplemented	"Indicating the way I should be implemented by a class. 	Consider the case of #hash and #=. How can we indicate that if a class implements one, 	it should implement the other? (By overriding this method to return true.)	The default is false, which means it is sufficient that I am understood by the implementing class."	^false</body><body package="SmallInterfaces" selector="truelyExtends:">truelyExtends: anInterface	^(self extends: anInterface) and: 	[(self isEquivalentTo: anInterface) not]</body></methods><methods><class-id>Interface class</class-id> <category>printing</category><body package="SmallInterfaces" selector="ancestorsString">ancestorsString	| writer ancestors  |	writer := String newLarge writeStream.	(ancestors := self ancestors) notEmpty		ifTrue:			[writer 				crtab; 				nextPutAll: 'ancestors: {'.			ancestors do: [:each | writer nextPutAll: each fullName; space].			writer 				skip: -1; 				nextPutAll: '}'].	^writer contents</body><body package="SmallInterfaces" selector="definition">definition	| writer extendedInterfaces equivalentInterfaces |	self == Interface ifTrue: [^super definition].		extendedInterfaces := (self perform: self configuration selectorForInterfaceInheritance) asSortedCollection: Class sortBlock.	equivalentInterfaces := self equivalents.	writer := String newLarge writeStream.	writer 		nextPutAll: super definition; crtab; 		nextPutAll: 'interfaces: '; 		nextPut: $'.	extendedInterfaces do: [:each | writer nextPutAll: each fullName; space].	writer nextPut: $'.	equivalentInterfaces notEmpty		ifTrue:			[writer cr; cr; nextPutAll: '"Equivalent interfaces:'.			equivalentInterfaces do: [:each | writer cr; tab; nextPutAll: each fullName].			writer cr; nextPut: $"].	^writer contents</body><body package="SmallInterfaces" selector="definitionWithInterfaces">definitionWithInterfaces	^self definition</body><body package="SmallInterfaces" selector="familyString">familyString	^String newLarge writeStream		nextPutAll: self fullName;		nextPutAll: self ancestorsString;		nextPutAll: self progenyString;		contents</body><body package="SmallInterfaces" selector="progenyString">progenyString	| writer progeny |	writer := String newLarge writeStream.	(progeny := self progeny) notEmpty		ifTrue:			[writer 				crtab; 				nextPutAll: 'progeny: {'.			progeny do: [:each | writer nextPutAll: each fullName; space].			writer 				skip: -1; 				nextPutAll: '}'].	^writer contents</body></methods><methods><class-id>Interface class</class-id> <category>utilities</category><body package="SmallInterfaces" selector="consolidate:">consolidate: interfaces	"out of &lt;interfaces&gt;, return the minimal descriptive set.	mostly, these are the interfaces which are not extended by any of the others."	^interfaces select: [:each | (interfaces contains: [:interface | interface truelyExtends: each]) not]</body><body package="SmallInterfaces" selector="interfacesFromString:">interfacesFromString: stringOfInterfaces	^((stringOfInterfaces subStrings collect: 		[:each | each asClass]) select: 			[:each | each notNil]) select: 				[:each | each isInterface]</body><body package="SmallInterfaces" selector="templateWithInterfaces">templateWithInterfaces	"Answer an expression that can be edited and evaluated in order to define a new interface."	^'Smalltalk.Root defineClass: #NameOfInterface	superclass: #{Smalltalk.Interface}	indexedType: #none	private: false	instanceVariableNames: ''''	classInstanceVariableNames: ''''	imports: ''''	category: ''''	interfaces: '''' '</body><body package="SmallInterfaces" selector="valueWithoutSynchronization:">valueWithoutSynchronization: aBlock 	| currentState |	currentState := Interface configuration synchronize.	Interface configuration synchronize: false.	[aBlock value] ensure: [Interface configuration synchronize: currentState]</body></methods><methods><class-id>Interface class</class-id> <category>documentation</category><body package="SmallInterfaces" selector="_1_Why_should_you_bother_with_Interfaces">_1_Why_should_you_bother_with_Interfaces"In the realm of domain analysis, the use of roles (also known as facets) has emerged as an important technique for classifying the features of objects. Roles reflect the various aspects of the object they describe, and the different roles that an object may play in relationship to other objects. More so, the assignment of responsibilities to an object depends on the role(s) it plays in a system of objects. Roles serve as an increasingly important metaphor for communicating object-oriented software designs and recognition of their importance has grown in recent years. For example, the codification of object-oriented software design knowledge in design patterns is founded in part on using the metaphor of roles. Software design patterns describe reusable collaborations between design elements. Each design element plays an identifiable role with well-defined responsibilities.Now, a design process and a programming language work well together when there is support and clean translation from the design process conceptual units, to the programming language abstraction and composition mechanisms. An interface is such programming language mechanism which maps the design process role concept. The mental process that leads us from design to implementation can be summarized as:Responsibilities beget Roles, Roles beget Interfaces,  Interfaces beget Objects.So interfaces are a very basic mechanism for thinking in terms of objects; they both define and organize the services objects provide. This is why designing good interfaces for objects becomes such an important endeavor when building applications using objects."	^self commentOnly</body><body package="SmallInterfaces" selector="_2_What_is_an_Interface">_2_What_is_an_Interface" The concept of an interface is central to object-oriented methodologies, most commonly referred to as Type. An interface is an abstract type, unlike class, which is a concrete type. An interface specifies a set of messages, where a class implements a set of messages. Therefore, the concept of an interface is orthogonal to that of a class.Said differently, an interface specifies which messages an object will execute but it has no method implementations for those messages, where a class specifies how those messages will be executed by specifying the method implementations for those messages.Each interface specifies a set of messages, which together constitutes what we term as its repertoire. In turn, each message declaration specifies the message's name (selector), and its arguments. For various languages, specifying the arguments for a message can mean different things, and there are many opinions and debates with regard to this issue. Enough said."	^self commentOnly</body><body package="SmallInterfaces" selector="_3_Interfaces_and_Smalltalk">_3_Interfaces_and_Smalltalk"Interfaces are not about static typing. In principle, they are merely about typing. More specifically, they can be used to solely specify a behavior, detached from data. In other words, an interface specifies which messages an object will execute, unlike a class, which specifies how those messages will be executed.Some OO languages have Interface and Class as two distinct concepts. For example, Java reifies both to some extent and includes syntax for defining and implementing interfaces, while Microsoft COM and OMG CORBA both have their own software object interface definition languages (IDLs).In Smalltalk however, the interfaces of an object are implicit and folded into its class implementation. This is not to say that interfaces in Smalltalk can not be harvested and become tangible, first-class objects. On the contrary, this is exactly what SmallInterfaces sets to achieve - the reification of interfaces in Smalltalk.For a dynamically typed language like Smalltalk it is sufficient for a message declaration to specify (implicitly) the number of arguments. That is what SmallInterfaces does. However, there exists another meaningful scheme for Smalltalk, where the type (interface or class) of each parameter (input variable) would be specified as well. With such scheme it is also desirable to specify the return value as well. Such scheme would be very useful for component-based development. Since SmallInterfaces aims to help the design and development process itself, it is taking the first and simpler approach."	^self commentOnly</body><body package="SmallInterfaces" selector="_4_An_Ontology_of_Interfaces_for_Smalltalk">_4_An_Ontology_of_Interfaces_for_Smalltalk"Each interface specifies a set of messages, which together constitutes its Repertoire.Repertoires are not mutually exclusive; a message can be part of many repertoires (N:N relationship).Interfaces are organized in heterarchies, so that one interface can be declared as being a composite of other interfaces. A composite interface is an interface that extends other interfaces; it inherits messages from the interfaces it extends, and may add additional messages of its own. A composite interface also referred to as an extending interface. The above interface classifications are not mutually exclusive; an interface can be Extended and Extending at the same time.At the top of the heterarchy are root interfaces, which are parentless interfaces; they extend no other interfaces. At the bottom of the heterarchy are the leaf interfaces, which are childless interfaces; no other interfaces extend them. These interface classifications also are not mutually exclusive. Consider the case where an environment contains a single interface; that singleton interface is both a root and a leaf at the same time.An interface with no repertoire is referred to as an empty interface. In SmallInterfaces such interface is not very useful and is considered to be meaningless (though it causes no harm).A behavior (class or metaclass) is an Understander (or a Conformer) of an interface if it can respond to all messages of the interface's repertoire. A behavior can conform to many interfaces, and an interface can be understood by many behaviors.An object conformsTo: aType if &lt; aType&gt; is one of: a) its class (or one of its superclasses), or b) one of the interfaces its class understands.Within a universe (such as the Smalltalk image), interfaces form a-cyclical directed graphs that are not necessarily connected. Since this universe is dynamic in Smalltalk, the inter-relationships among interfaces is dynamic as well, and may change whenever an interface is added to or removed from the universe, or whenever a message is added to or removed from an interface. The relationships between classes and interfaces is also dynamic, and may change for similar reasons. So the classes &lt;--&gt; interfaces relationships as well as interfaces &lt;--&gt; interfaces relationships are always inferred from the actual current composition of classes and interfaces in the universe."	^self commentOnly</body><body package="SmallInterfaces" selector="_5_What_can_you_do_with_SmallInterfaces">_5_What_can_you_do_with_SmallInterfaces"1. Declare an interface and specify its behavior. This can be done in three distinct ways:	- Directly, by specifying its name and selectors. (Look under the ''interface creation'' protocol under Interface.)	- By composing from other interfaces.	- By converting a class as a template (Look at the various asInterface* methods under ClassDescription.)2. Declare a behavior as conforming to (or understanding) one or more interfaces. This can be done in two distinct ways:	- By adding a 'interfaces: stringOfInterfaceNames' to the behavior 's definition. 	  (Look under the 'compiling' protocols under Class and Metaclass.)	- By sending implement: to the behavior 's definition. 	  (Look at the various implement* methods under ClassDescription.)	- By converting an interface to a class (Look at the various asClass* methods under Interface.)	All methods will create stubbed methods as necessary on behalf of the to-be-understood interface(s)3. Given a behavior (class or metaclass), you can ask: 	- What interfaces it understands (conforms to)? (its interfaces)4. Given an interface, you can ask: 	- Which behaviors understand it? (its conformers)5. Given an interface, you can ask: 	- Which interfaces extend it? (its extenders)	- Which interfaces it extends? (its extended)	- Which interfaces immediately extend it? (its children) 	- Which interfaces it immediately extends? (its parents)	- Which interfaces share its parents? (its siblings)	- Which interfaces are equivalent to it? (its twins)	- Which interfaces it extends? (its lineage)	- Which interfaces and behaviors are related to it? (its relatives)6. Given an interface or a behavior, you can ask: 	- What is the set of messages it is comprised of? (its repertoire)7. Given an object, you can ask: 	- Which are its types? (behaviors and interfaces)	- Does it conform to a type?"	^self commentOnly</body><body package="SmallInterfaces" selector="_6_Some_important_implementation_notes">_6_Some_important_implementation_notes"The classes &lt;--&gt; interfaces relationships as well as interfaces &lt;--&gt; interfaces relationships are of a dynamic nature. This is to say that the web of relationships is always inferred from the actual composition of classes and interfaces every time a query is attempted. This is neat, but also very inefficient, especially when a query for all conforming classes is executed for an interface. Therefore, a caching scheme is implemented under the wings of RepertoireHome.The notion that an interface is a composite is implicit; when a new interface is composed from other interfaces, the repertoires of these interfaces are copied over.In SmallInterfaces, when a class is added/changed/removed to/from the environment, all relevant interfaces are immediately affected by the event (causal connection). The same holds true when an interface is added/changed/removed to/from the environment; all relevant classes and interfaces are immediately affected by the event. This causal connection is a byproduct of dynamically inferencing the relationships among classes and interfaces.We refer to the activity which facilitates such causal connection as: synchronization.The granularity of synchronization is controlled by (within InterfaceConfiguration):	synchronize	synchronizeWithConformers	synchronizeWithExtenders	removeOnlyStubbsWhere removeOnlyStubbs controls whether or not existing stubbed methods would be removed when a class declares it understands a different set of interfaces."	^self commentOnly</body><body package="SmallInterfaces" selector="tutorial">tutorial"I guess the biggest question everybody has is: 	'How would I use one of 'them interfaces in Smalltalk?'Within the context of Smalltalk, interfaces can be useful in three major areas: 	Design, Documentation, and Exploration.	For each aspect, see the corresponding tutorial.Note that all interfaces are classes, and as such can be browsed and modified using a generic browser. So once you have created an interface, you can use a generic browser to add some methods, and/or remove other methods."	^self commentOnly</body><body package="SmallInterfaces" selector="tutorial_Designing">tutorial_Designing"The concept of interfaces can help us do a better job with using Responsibility Driven Design by facilitating a higher level of abstraction than that of a class. The gist of Responsibility Driven Design is that when one designs an object (in the context of a society of objects), one wants to concentrate on what services an object needs to offer to its clients.  What we are really after is figuring out what are the pure 'working relationships' an object has within its society. We do not care about *how* the object is going to work it out, nor what state it needs to maintain in order to do so.  Each service an object is contracted to supply, or said differently - each role it plays, is embodied within an interface.So, designing using interfaces can be a mind liberating experience. With interfaces one can better concentrate on the question: 'What are the responsibilities of a given object?' in terms of: 'What should be its repertoire?' Designing is then broken down into searching for the answer to: 'What messages this and that are supposed to communicate and understand in order to get a certain functionality/aspect accomplished?'If we follow this design mode, we have: 	Responsibilities beget Roles, 		Roles beget Interfaces,  			Interfaces beget Objects.With that in mind, let us put this theory into practice using an example.  Say you have a domain where you need the ability to price some objects.  Some objects have no price, some have a fixed price, and some have a dynamic price.  The dynamic price may depend on various factors such as time and locale.  Also, that price needs to be quoted in a parameterized way, such as: in a currency, in goods (as in: 'I'll give you three loaves of bread for two of these'), or in services (as in: 'will be president for food').  An important aspect of these objects is that they can be priced; they are priceable (clink, clink...). Some of these objects have the capability to compute their price; others would use a helper pricer to do the job, and others yet, might do one or the other - depending on the context. What they all have in common is that they all need to understand (and respond to) the following group of messages:	price	priceAsOf: aTemporal   (such as Date, Timestamp, etc.)	priceAsOf: aTemporal quantifyUsing: aTradable   (such as Money, Product, WorkService)	defaultTemporal	defaultTradable	pricerThis group of messages, this repertoire, has semantic meaning on its own, and as such it deserves to be a first class object. We call such reification - an interface. And the above repertoire defines the Priceable interface. From that point on, we no longer need to say: 'Money or Product or WorkService or whatever' - we can refer to those entities as Priceables.As an exercise, you might want to try and define the Pricer interface.  Note that a pricer for: 5 cubic miles of irrigation water in the Sahara for the summer of 1999 might have very little in common with a pricer for: 10,000 IBM stocks on the New York Exchange for 1/1/2000.If you still got energy, go a head and define the Tradable and Temporal interfaces. Note that the price answered is a Quantifiable. Define that too.Can you start to see the advantages of 'thinking' in interfaces?When you are done with this little design you end up with capturing the core of your business. Furthermore, there is enough content in this design to facilitate some simulations of business scenarios, and by doing so, validating your understanding of the problem at hand.Maybe you can also imagine that the actual classes that will be used to implement this design would cross hierarchies. For example, some objects' prices will be date-specific, some location-specific, some will be time &amp; location specific, some will have to consider all factors or none - depending on the context when they are asked (like by whom).Now you can use SmallInterfaces to make the first step in implementing this design - declaring those interfaces.Using SmallInterfaces you can create interfaces programmatically by one of three ways:	1. define the interface and its methods directly	2. define the interface and its methods from a group of interfaces	3. define the interface and its methods from a classUsing the Priceable interface as an example for the first way, we would execute:	&lt;Interface 		newNamed: #Priceable		withSelectors: #(price priceAsOf: priceAsOf:quantifyUsing: defaultTemporal defaultTradable pricer)&gt;Using an example from the attached ToyInterfaces package to illustrate the second way, we would execute:	&lt;Interface 		newNamed: #ReadableWritable		extending: 'Readable Writable'		additionalSelectors: #()&gt;Now assuming you want to use Magnitude as a template for the Quantifiable interface, you could use the third way and execute:	&lt;Magnitude asInterfaceNamed: #Quantifiable&gt; or:	&lt;Interface 		newNamed: #Quantifiable 		from: Magnitude&gt;Remember that all interfaces are classes, and can be browsed and modified using the generic browser. So, for example, after creating Quantifiable from Magnitude, you might want to remove some methods, and/or add some others.Now you are ready for the next step - implementing some classes based on those interfaces.Assuming you had Priceable &amp; Quantifiable in mind, and you wanted to create Price &amp; Quantity, you would execute something like:	&lt;Priceable asClassNamed: #Price super: MyDomainObject&gt;and:	&lt;Quantifiable asClassNamed: #Quantity&gt;The Price &amp; Quantity classes would now hold stubbed method implementations for Priceable &amp; Quantifiable repertoires (including comments, if you had any).All the above operations and more are easily performed using the Interface Browser GUI."	^self commentOnly</body><body package="SmallInterfaces" selector="tutorial_Documenting">tutorial_Documenting"Using interfaces we can write a better self-documenting code, since we have a higher level of abstraction at our disposal. We can use interfaces to make the implicit explicit, thus helping the original design surface and stay visible as the code evolves. Their presence should help providing direction for the refactoring process. Consider the following implementation snippet for the example in the design section:WorkService&gt;&gt;priceAsOf: aTemporal quantifyUsing: aTradable			^self pricer 		price: self		in: self location		asOf: aTemporal		quotingIn: aTradableNotice that pricer, aTemporal, aTradable, and possibly location, represent interfaces. The actual possible objects that can occupy each slot are not necessarily sharing the same hierarchy!Now consider how the very same code snippet would look without 'thinking in interfaces':WorkService&gt;&gt;priceAsOf: aDateOrTimeOrTimestamp quantifyUsing: aMoneyOrProductOrWorkService			^self pricer 		price: self		in: self location		asOf: aDateOrTimeOrTimestamp		quotingIn: MoneyOrProductOrWorkServiceWhich version is better at self-documenting?Interfaces can also be used in design validation. After specifying a #requiredInterfaces method on the class side of aClass, we now can use &lt;aClass understandsRequiredInterfaces&gt; in our code, like in a testcase: 	&lt;self should: [someObject class understandsRequiredInterfaces]&gt;A more explicit way of indicating the original design, is a variation of the #isSomething usage.For example, all classes that understand Priceable will implement isPriceable to return true, while their superclasses will implement it to return false. Now we can have phrases such as:	&lt;anObject isPriceable		ifTrue: [self charge: aCustomer for: anObject]		ifFalse: [self giveAway: anObject to: aCustomer]&gt;Also, we can now sprinkle in our code statements like:	&lt;groupOfObjectsWhichSupposadlyAreKeyable do:		[:each | 		(each conformsTo: Keyable)  			ifTrue: [each at: someplaceSafe put: somethingGood]				ifFalse: [self giveMe: somethingGood]]&gt;Note that SmallInterfaces can automate some of these schemes, but does not."	^self commentOnly</body><body package="SmallInterfaces" selector="tutorial_Exploring">tutorial_Exploring"Interfaces can give us another mental navigation tool while browsing the environment. My contention is that if interfaces had been more explicit in Smalltalk then one could have used them to learn a Smalltalk environment faster.Following are a few examples taken from the VisualWorks environment to illustrate how interfaces could be used in system exploration.VisualWorks has Model which has a specialized implementation of the Observable interface found in Object. Now let's say you want to find out if the environment has a specialized Observable collection as well. You look and you don't seem to see one under the Model hierarchy. So you might want to create an Observable interface with #myDependents: and #myDependents as its repertoire and search for conformers (understanders) of Observable. To create an Observable interface you would execute:	&lt;Interface	newNamed: # Observable	withSelectors: #(#myDependents: #myDependents)&gt;To look for its conformers you would execute:	&lt;Observable conformers&gt; Depending on your environment the result would be something like:	{Object TableAdaptor TwoDList Model WidgetWrapper List ScrollWrapper WeakArray}.Notice List and WeakArray - they might be what you were looking for. Notice the others too - if you are one of the curious kinds, it might be interesting for you to try and figure why the others have a specialized implementation of the Observable interface.You can now refine your Observable interface by adding other messages you think are integral to it, and use it as a template to create other observable objects. For example, how about implementing an observable process: one that has dependents who can be notified when it is completed its task (like Promise or Future for asynchronous messaging). Such a class would probably implement a Runnable interface as well...Another example is related to extending the environment:If you happened to add your own extensions to base classes you probably extended Dictionary as well. When doing so, did you think it might be useful to add the same extension to KeyedCollection as well?  If not, why? After all, KeyedCollection and Dictionary are both keyable...A similar connection exists between SequenceableCollection and Stream, especially String and Stream."	^self commentOnly</body></methods><methods><class-id>Interface class</class-id> <category>synchronizing</category><body package="SmallInterfaces" selector="conformersToSynchronize">conformersToSynchronize	^Interface configuration synchronizeWithConformers 		ifTrue: [self allConformers]		ifFalse: [#()]</body><body package="SmallInterfaces" selector="extendersToSyncronize">extendersToSyncronize	^Interface configuration synchronizeWithExtenders 		ifTrue: [self extenders]		ifFalse: [#()]</body><body package="SmallInterfaces" selector="relativesToSynchronize">relativesToSynchronize	^IdentitySet new		addAll: self conformersToSynchronize;		addAll: self extendersToSyncronize;		yourself.</body><body package="SmallInterfaces" selector="synchronizeChangeOf:usingSelector:">synchronizeChangeOf: aspect usingSelector: selector	self relativesToSynchronize do:		[:each | 		(aspect == #removeClass:) ifTrue: [each unimplement: self].		(aspect == #removeSelector:class:) 			ifTrue: 				[each 					synchronizeWith: self					removalOf: selector]].</body><body package="SmallInterfaces" selector="synchronizeWith:removalOf:">synchronizeWith: anInterface removalOf: selector 	self removeMethods: (Array with: selector)</body></methods><methods><class-id>Interface class</class-id> <category>mutability</category><body package="SmallInterfaces" selector="beMutable">beMutable	(self isInterface and: [self isSealed]) 		ifTrue: 			[self class 				removeSelector: #isSealed;				removeAllEmptyCategories]</body><body package="SmallInterfaces" selector="beSealed">beSealed	"Note: the current implementation uses method compilation. 	alternatively, we can use a special registry (such as in InterfaceHome)."		(self isInterface and: [self isMutable])		ifTrue: 			[self class				compile: 'isSealed\\	^true' withCRs				classified: #testing				notifying: nil]</body><body package="SmallInterfaces" selector="isMutable">isMutable	"Can I be modified?"		^self isSealed not</body><body package="SmallInterfaces" selector="isSealed">isSealed	"Am I 'final'?"		^false</body></methods><methods><class-id>Interface class</class-id> <category>defaults</category><body package="SmallInterfaces" selector="defaultCategory">defaultCategory	^self configuration defaultCategory</body><body package="SmallInterfaces" selector="defaultClassName">defaultClassName	"This method is called for the purpose of generating a 'real' class from an interface."	^(self name, 'Implementation') asSymbol</body><body package="SmallInterfaces" selector="defaultClassification">defaultClassification	^self name</body><body package="SmallInterfaces" selector="defaultInterfaceName">defaultInterfaceName	"This method is called for the purpose of generating an interface from a 'real' class.	Since I am an interface, reaching this method is probably an error."		^self error: 'I am an interface; you should not create an inteface for me!'</body><body package="SmallInterfaces" selector="selectorForImplementation">selectorForImplementation	"The selector to be embeded within any method of an Interface"	^#implementorsResponsibility</body><body package="SmallInterfaces" selector="selectorForStubedImplementation">selectorForStubedImplementation	"This selector is embeded as a stub within a method as initial implementation for an Interface"	^#shouldImplementFor:</body></methods><methods><class-id>Interface class</class-id> <category>accessing-interfaces</category><body package="SmallInterfaces" selector="ancestors">ancestors	"Return all interfaces which I extend (in bredth-first order).	In other words: the lineage chain from the roots of my 'family tree'."	| family elders ancestors |	family := self extended.		"now put an order within this family; oldest generation first, youngen last..."	ancestors := OrderedCollection new: family size.	elders := family select: [:each | each isOrphan].		[ancestors addAll: elders.	family removeAll: elders.	family notEmpty] whileTrue:		[elders := family select: [:each | ancestors includesAny: each parents]].	^ancestors</body><body package="SmallInterfaces" selector="children">children	"Return my children, which are the interfaces immidiately extending me."	| family children |	family := self extenders.	family isEmpty ifTrue: [^family].		"now gradually trim the family's youngest generation, until only 		the oldest generation remains. these are my immediate children."	[children := Interface consolidate: family.	family removeAll: children.	family notEmpty] whileTrue.	^children</body><body package="SmallInterfaces" selector="descendants">descendants	^self progeny</body><body package="SmallInterfaces" selector="equivalents">equivalents	^self home allInterfaces select: [:each | each ~~ self and: [each isEquivalentTo: self]]</body><body package="SmallInterfaces" selector="extended">extended	"Return all intefaces which I extend directly or indirectly.	In other words: all my originating interfaces."	self isEmpty ifTrue: [^Set new].	^(self home allNonEmptyInterfaces select: [:each | self extends: each]) 		reject: [:each | self isEquivalentTo: each	"remove circularities"]</body><body package="SmallInterfaces" selector="extenders">extenders	"Return all intefaces which extend me (directly or indirectly).	In other words: all (composite) interfaces for which I am a progenator."	self isEmpty ifTrue: [^Set new].	^(self home allInterfaces select: 		[:each | each extends: self]) reject: 			[:each | self isEquivalentTo: each]	"remove circularities"</body><body package="SmallInterfaces" selector="parents">parents	"Return my parents, which are the interfaces I immidiately extend.	Note: a simple (root) interface is an orphan, while a composite 	interface is a child of unlimitted number of parents."	^Interface consolidate: self extended</body><body package="SmallInterfaces" selector="progeny">progeny	"Return all interfaces which extend me (in bredth-first order).	In other words: the branches of my 'family tree' eminating from me."	| family children descendants |	family := self extenders.		"now put an order within this family; my children first, their children after ..."	descendants := OrderedCollection new: family size.	[children := Interface consolidate: family.		children isEmpty 	"case of existing equivalents"		ifTrue: [children := family select: [:each | each hasEquivalents]].	descendants addAll: children.	family removeAll: children.	family notEmpty] whileTrue.	^descendants reversed</body><body package="SmallInterfaces" selector="semiSiblings">semiSiblings		^self home allInterfaces select: [:each | each ~~ self and: [each parents includesAll: self parents]]</body><body package="SmallInterfaces" selector="siblings">siblings	"My siblings are considered to be semiSiblings; they have to share all of my parents.	Note: For siblings = only as those that have identical parents, =&gt; use trueSiblings instead.	For siblings = only as those that share at list one of the parents, =&gt; use stepSiblings instead."	^self semiSiblings</body><body package="SmallInterfaces" selector="stepSiblings">stepSiblings		^self home allInterfaces select: [:each | each ~~ self and: [each parents includesAny: self parents]]</body><body package="SmallInterfaces" selector="trueSiblings">trueSiblings		^self home allInterfaces select: [:each | each ~~ self and: [each parents consistsOf: self parents]]</body><body package="SmallInterfaces" selector="twins">twins		^self equivalents</body></methods><methods><class-id>Interface class</class-id> <category>interface calculus</category><body package="SmallInterfaces" selector="&amp;">&amp; anInterface	^self intersectionWith: anInterface</body><body package="SmallInterfaces" selector="+">+ anInterface	^self unionWith: anInterface</body><body package="SmallInterfaces" selector="-">-  anInterface	^self differenceFrom: anInterface</body><body package="SmallInterfaces" selector="differenceFrom:">differenceFrom: anInterface 	^self 		differenceFrom: anInterface 		named: (self name , 'Minus' , anInterface name) asSymbol</body><body package="SmallInterfaces" selector="differenceFrom:named:">differenceFrom: anInterface named: aSymbol	| repertoire interface |	repertoire := self repertoire reject: [:each| anInterface repertoire includes: each].	interface := (self home interfaceWithRepertoire: repertoire) 		ifNil: 			[Interface 				newNamed: aSymbol 				withSelectors: repertoire].	^interface</body><body package="SmallInterfaces" selector="intersectionWith:">intersectionWith: anInterface 	^self 		intersectionWith: anInterface 		named: (self name , 'IntersectionWith' , anInterface name) asSymbol</body><body package="SmallInterfaces" selector="intersectionWith:named:">intersectionWith: anInterface named: aSymbol	| repertoire interface |	repertoire := self repertoire &amp; anInterface repertoire.	interface := (self home interfaceWithRepertoire: repertoire) 		ifNil: 			[Interface 				newNamed: aSymbol 				withSelectors: repertoire].	^interface</body><body package="SmallInterfaces" selector="unionWith:">unionWith: anInterface 	^self 		unionWith: anInterface 		named: (self name , 'Plus' , anInterface name) asSymbol</body><body package="SmallInterfaces" selector="unionWith:named:">unionWith: anInterface named: aSymbol	| repertoire interface |	repertoire := self repertoire + anInterface repertoire.	interface := (self home interfaceWithRepertoire: repertoire) 		ifNil: 			[Interface 				newNamed: aSymbol 				withSelectors: repertoire].	^interface</body></methods><methods><class-id>Interface class</class-id> <category>code generation</category><body package="SmallInterfaces" selector="createMethod:from:">createMethod: selector from: aClass	| source category |	source := self methodSourceFor: selector from: aClass.	category := aClass isNil		ifTrue: [#repertoire]		ifFalse: [aClass organization categoryOfElement: selector].	self compile: source classified: category</body><body package="SmallInterfaces" selector="createMethods:">createMethods: selectors	self createMethods: selectors from: nil</body><body package="SmallInterfaces" selector="createMethods:from:">createMethods: selectors from: aClass	selectors do: [:each | self createMethod: each from: aClass]</body><body package="SmallInterfaces" selector="createStubbedMethodFor:from:">createStubbedMethodFor: selector from: aClass	"Create a stub method implementation for a selector in &lt;aClass&gt; on behalf of me."	| interfaceOwningSelector |	interfaceOwningSelector := self ancestors 		detect: [:each | each repertoire includes: selector] 		ifNone: [self].	aClass 		compile: (self methodSourceFor: selector from: self)		classified: (interfaceOwningSelector defaultClassification)</body><body package="SmallInterfaces" selector="implementationStringForInterface">implementationStringForInterface	^String newLarge writeStream		nextPutAll: '^self';		space;		nextPutAll: self selectorForStubedImplementation asString;		space;		nextPutAll: self name asString;		contents</body><body package="SmallInterfaces" selector="methodSourceFor:from:">methodSourceFor: selector from: aClass	^aClass isNil		ifTrue: 			[self				methodSourceWithHeader: selector asSelectorStringWithArgumentsString 				comment: ''				implementation: Class implementationStringForInterface]		ifFalse: 			[self				methodSourceWithHeader: (aClass&gt;&gt;selector) headerString	 				comment: (aClass&gt;&gt;selector) commentString				implementation: aClass implementationStringForInterface]</body><body package="SmallInterfaces" selector="methodSourceWithHeader:comment:implementation:">methodSourceWithHeader: header comment: comment implementation: implementationString	| writer |	writer := String newLarge writeStream.	writer nextPutAll: header.	comment isEmpty ifFalse: [writer crtab; nextPutAll: comment].	writer cr; crtab; nextPutAll: implementationString.	^writer contents</body></methods><methods><class-id>Interface class</class-id> <category>compiling</category><body package="SmallInterfaces" selector="compile:classified:notifying:">compile: code classified: heading notifying: requestor	"An interface method can not have an implementation. 	This method attempts to enforce just that...		Note: if the method compiled is new, then the interface change is synchronized."	| toSynchronize selector result |	self isSealed ifTrue: [^nil].		selector := Parser new parseSelector: code.	"the better implementation is:	selector := (RBParser parseMethod: code) selector."	toSynchronize := (self selectors includes: selector) not		ifTrue: [self relativesToSynchronize]		ifFalse: [#()].			result := super 		compile: (self interfaceMethodSourceBasedOn: code)		classified: heading		notifying: requestor.	self synchronizeChangeOf: selector with: toSynchronize.	^result</body><body package="SmallInterfaces" selector="interfaceMethodSourceBasedOn:">interfaceMethodSourceBasedOn: source 	| parser selector headerString comments commentString |	parser := Parser new.	selector := parser parseSelector: source.	headerString := selector isUnary 		ifTrue: [selector asString]		ifFalse:			[| writer argumentNames |			writer := WriteStream on: String newLarge.			argumentNames := (parser scanFieldNames: source) 				copyFrom: 1 				to: (selector keywords size).			selector keywords with: argumentNames do:				[:eachKeyword :eachArgument | 				writer 					nextPutAll: eachKeyword; space; 					nextPutAll: eachArgument; space].			writer contents].	comments := parser parseMethodComment: source setPattern: [:x |].	commentString := comments notEmpty		ifTrue: [comments first asComment]		ifFalse: [''].	^self		methodSourceWithHeader: headerString		comment: commentString		implementation: Class implementationStringForInterface"	| methodNode |	methodNode := RBParser parseMethod: source.	^self		methodSourceWithHeader: methodNode headerString		comment: methodNode commentString		implementation: Class implementationStringForInterface"</body><body package="SmallInterfaces" selector="synchronizeChangeOf:with:">synchronizeChangeOf: selector with: behaviors	(self selectToSynchronizeFrom: behaviors) do: 		[:each | 		(each repertoire includes: selector) not			ifTrue: [self createStubedMethodFor: selector from: each]]</body></methods><methods><class-id>Interface class</class-id> <category>message creation-removal</category><body package="SmallInterfaces" selector="createStubedMethodFor:from:">createStubedMethodFor: selector from: aClass	"Create a stub method implementation for a selector in &lt;aClass&gt; on behalf of me."	| interfaceOwningSelector |	interfaceOwningSelector := self ancestors 		detect: [:each | each repertoire includes: selector] 		ifNone: [self].	aClass 		compile: (self methodSourceFor: selector from: self)		classified: (interfaceOwningSelector defaultClassification)</body><body package="SmallInterfaces" selector="extend:">extend: anInterface	anInterface repertoire do: 		[:each | | classification |		classification := anInterface organization categoryOfElement: each.		(classification == #repertoire or:		[(self environment hasClassNamed: classification) not])			ifTrue: [classification := anInterface name].		self 			compile: (anInterface sourceCodeAt: each)			classified: classification]</body><body package="SmallInterfaces" selector="extendAll:">extendAll: interfaces 	(self extended - interfaces) do: [:each | self unimplement: each].	(Interface consolidate: interfaces) do: [:each | self extend: each]</body><body package="SmallInterfaces" selector="implementAll:">implementAll: interfaces 	self extendAll: interfaces</body><body package="SmallInterfaces" selector="removeSelector:ifAbsent:">removeSelector: selector ifAbsent: exceptionHandler	self isSealed ifTrue: [^self].	^super removeSelector: selector ifAbsent: exceptionHandler</body><body package="SmallInterfaces" selector="unimplement:">unimplement: anInterface	"Remove implementations for all of &lt;anInterface&gt; repertoire I already implement."	self removeMethods: anInterface repertoire.</body></methods><methods><class-id>Interface class</class-id> <category>accessing</category><body package="SmallInterfaces" selector="configuration">configuration	^InterfaceConfiguration current</body><body package="SmallInterfaces" selector="home">home	^InterfaceHome current</body><body package="SmallInterfaces" selector="selectorsForRepertoire">selectorsForRepertoire	^self selectors asIdentitySet</body><body package="SmallInterfaces" selector="theExtentedFamily">theExtentedFamily	"All relevant Classes and Interfaces"	^(Set with: self)		addAll: self extended;		addAll: self extenders;		addAll: self allConformers;		yourself</body></methods><methods><class-id>Interface class</class-id> <category>accessing-behaviors</category><body package="SmallInterfaces" selector="allConformers">allConformers	^self isEmpty		ifTrue: [IdentitySet new]		ifFalse: [self environment allNonInterfaceBehaviors select: [:each | each understands: self]]</body><body package="SmallInterfaces" selector="conformers">conformers	^self allConformers reject: 		[:each | each superclass notNil and: [each superclass understands: self]]</body></methods><methods><class-id>InterfaceHome</class-id> <category>querying</category><body package="SmallInterfaces" selector="allExtendedInterfaces">allExtendedInterfaces	^self allInterfaces select: [:each | each isExtended]</body><body package="SmallInterfaces" selector="allExtendingInterfaces">allExtendingInterfaces	^self allInterfaces select: [:each | each isExtending]</body><body package="SmallInterfaces" selector="allInterfaces">allInterfaces	^IdentitySet withAll: Interface subclasses</body><body package="SmallInterfaces" selector="allNonEmptyInterfaces">allNonEmptyInterfaces	^self allInterfaces reject: [:each | each isEmpty]</body><body package="SmallInterfaces" selector="childlessInterfaces">childlessInterfaces	^self leafInterfaces</body><body package="SmallInterfaces" selector="classesNotFullyImplemented">classesNotFullyImplemented	| resultSet behaviors |	behaviors := self environment allNonInterfaceBehaviors.	resultSet := self allInterfaces 		inject: Set new		into: 			[:set :eachInterface | | nonFullyImplemented |			nonFullyImplemented := behaviors select: 				[:eachBehavior | (eachInterface methodsStubedIn: eachBehavior) notEmpty].			set addAll: nonFullyImplemented; yourself].	^resultSet collect: [:each | each homeClass].</body><body package="SmallInterfaces" selector="emptyInterfaces">emptyInterfaces	^self allInterfaces select: [:each | each isEmpty]</body><body package="SmallInterfaces" selector="equivalentInterfaces">equivalentInterfaces	"Return all interfaces who has other interfaces which are equivalent to them."	^self allInterfaces select: [:each | each hasEquivalents]</body><body package="SmallInterfaces" selector="immutables">immutables	^self allInterfaces select: [:each | each isSealed]</body><body package="SmallInterfaces" selector="includesInterfaceNamed:">includesInterfaceNamed: aSymbol	^self allInterfaces contains: [:each | each name == aSymbol]</body><body package="SmallInterfaces" selector="interfaceNamed:">interfaceNamed: aSymbol	^self allInterfaces 		detect: [:each | each name == aSymbol] 		ifNone: [nil]</body><body package="SmallInterfaces" selector="interfaceWithRepertoire:">interfaceWithRepertoire: repertoire	^self allInterfaces 		detect: [:each | each repertoire consistsOf: repertoire]		ifNone: [nil]</body><body package="SmallInterfaces" selector="interfacesWithRepertoire:">interfacesWithRepertoire: repertoire	^self allInterfaces select: [:each | each repertoire includesAll: repertoire]</body><body package="SmallInterfaces" selector="leafInterfaces">leafInterfaces	^Interface consolidate: self allInterfaces</body><body package="SmallInterfaces" selector="mutables">mutables	^self allInterfaces reject: [:each | each isSealed]</body><body package="SmallInterfaces" selector="rootInterfaces">rootInterfaces	^self rootsOfTheInterfaceWorld</body><body package="SmallInterfaces" selector="rootsOfTheInterfaceWorld">rootsOfTheInterfaceWorld	^self allInterfaces select: [:each | each isOrphan]</body></methods><methods><class-id>InterfaceHome</class-id> <category>actions</category><body package="SmallInterfaces" selector="removeEmptyInterfaces">removeEmptyInterfaces	self emptyInterfaces do: [:each | each removeFromSystem]</body></methods><methods><class-id>InterfaceHome class</class-id> <category>fileIn/Out</category><body package="SmallInterfaces" selector="prerequisitesForLoading">prerequisitesForLoading	^super prerequisitesForLoading		add: Interface;		yourself</body></methods><methods><class-id>InterfaceHome class</class-id> <category>instance creation</category><body package="SmallInterfaces" selector="current">current	^singleton ifNil: [singleton := super new]</body><body package="SmallInterfaces" selector="new">new	^self current</body><body package="SmallInterfaces" selector="nuke">nuke	singleton := nil</body></methods><methods><class-id>InterfaceHome class</class-id> <category>class initialization</category><body package="SmallInterfaces" selector="obsolete">obsolete	self nuke</body></methods><methods><class-id>InterfaceConfiguration</class-id> <category>accessing</category><body package="SmallInterfaces" selector="defaultCategory">defaultCategory	^'Interfaces'</body><body package="SmallInterfaces" selector="discardInterfacesOnShutDown">discardInterfacesOnShutDown 	^discardInterfacesOnShutDown</body><body package="SmallInterfaces" selector="discardInterfacesOnShutDown:">discardInterfacesOnShutDown: aBoolean	discardInterfacesOnShutDown := aBoolean</body><body package="SmallInterfaces" selector="notifyOnDerivationDiscovery">notifyOnDerivationDiscovery	^notifyOnDerivationDiscovery and: [self environment isHeadless not]</body><body package="SmallInterfaces" selector="notifyOnDerivationDiscovery:">notifyOnDerivationDiscovery: aBoolean	notifyOnDerivationDiscovery := aBoolean</body><body package="SmallInterfaces" selector="removeOnlyStubs">removeOnlyStubs	^removeOnlyStubs</body><body package="SmallInterfaces" selector="removeOnlyStubs:">removeOnlyStubs: aBoolean 	removeOnlyStubs := aBoolean</body><body package="SmallInterfaces" selector="selectorForClassInterfaces">selectorForClassInterfaces	^selectorForClassInterfaces</body><body package="SmallInterfaces" selector="selectorForClassInterfaces:">selectorForClassInterfaces: selectorSymbol	selectorForClassInterfaces := selectorSymbol</body><body package="SmallInterfaces" selector="selectorForInterfaceInheritance">selectorForInterfaceInheritance	^selectorForInterfaceInheritance</body><body package="SmallInterfaces" selector="selectorForInterfaceInheritance:">selectorForInterfaceInheritance: selectorSymbol	selectorForInterfaceInheritance := selectorSymbol</body><body package="SmallInterfaces" selector="synchronize">synchronize 	^synchronize</body><body package="SmallInterfaces" selector="synchronize:">synchronize: aBoolean	synchronize := aBoolean</body><body package="SmallInterfaces" selector="synchronizeSelectively">synchronizeSelectively	^synchronizeSelectively and: [self environment isHeadless not]</body><body package="SmallInterfaces" selector="synchronizeSelectively:">synchronizeSelectively: aBoolean	synchronizeSelectively := aBoolean</body><body package="SmallInterfaces" selector="synchronizeWithConformers">synchronizeWithConformers	^synchronizeWithConformers</body><body package="SmallInterfaces" selector="synchronizeWithConformers:">synchronizeWithConformers: aBoolean 	synchronizeWithConformers := aBoolean</body><body package="SmallInterfaces" selector="synchronizeWithExtenders">synchronizeWithExtenders	^synchronizeWithExtenders</body><body package="SmallInterfaces" selector="synchronizeWithExtenders:">synchronizeWithExtenders: aBoolean 	synchronizeWithExtenders := aBoolean</body></methods><methods><class-id>InterfaceConfiguration</class-id> <category>initialize-release</category><body package="SmallInterfaces" selector="initialize">initialize 	 	self setDefaults</body><body package="SmallInterfaces" selector="reset">reset	self		discardInterfacesOnShutDown: true;		notifyOnDerivationDiscovery: false;			removeOnlyStubs: true;		selectorForClassInterfaces: #interfaces;		selectorForInterfaceInheritance: #parents;		synchronize: false;		synchronizeSelectively: false;		synchronizeWithConformers: false;		synchronizeWithExtenders: false</body><body package="SmallInterfaces" selector="setDefaults">setDefaults	self		discardInterfacesOnShutDown: true;		notifyOnDerivationDiscovery: true;			removeOnlyStubs: true;		selectorForClassInterfaces: #interfaces;		selectorForInterfaceInheritance: #parents;		synchronize: true;		synchronizeSelectively: true;		synchronizeWithConformers: true;		synchronizeWithExtenders: true</body></methods><methods><class-id>InterfaceConfiguration class</class-id> <category>instance creation</category><body package="SmallInterfaces" selector="current">current	^singleton ifNil: [singleton := super new initialize]</body><body package="SmallInterfaces" selector="new">new	^self current</body><body package="SmallInterfaces" selector="nuke">nuke	singleton := nil</body></methods><methods><class-id>InterfaceConfiguration class</class-id> <category>class initialization</category><body package="SmallInterfaces" selector="addSettings">addSettings	| launcher |	UISettings addPreferenceSection: #addSmallInterfacesSectionTo:development:runtime:.	launcher := Smalltalk at: #VisualLauncher ifAbsent: nil.	(launcher respondsTo: #checkInstalledComponents)		ifTrue: [launcher checkInstalledComponents]</body><body package="SmallInterfaces" selector="initialize">initialize	"InterfaceConfiguration initialize."	| launcher |	UISettings addPreferenceSection: #addSmallInterfacesSectionTo:development:runtime:.	launcher := Smalltalk at: #VisualLauncher ifAbsent: nil.	(launcher respondsTo: #checkInstalledComponents)		ifTrue: [launcher checkInstalledComponents].			Interface configuration setDefaults.</body><body package="SmallInterfaces" selector="obsolete">obsolete	| launcher |	super obsolete.	self nuke.	UISettings removePreferenceSection: #addSmallInterfacesSectionTo:development:runtime:.	launcher := Smalltalk at: #VisualLauncher ifAbsent: nil.	(launcher respondsTo: #checkInstalledComponents)		ifTrue: [launcher checkInstalledComponents]</body><body package="SmallInterfaces" selector="removeSettings">removeSettings	| launcher |	UISettings removePreferenceSection: #addSmallInterfacesSectionTo:development:runtime:.	launcher := Smalltalk at: #VisualLauncher ifAbsent: nil.	(launcher respondsTo: #checkInstalledComponents)		ifTrue: [launcher checkInstalledComponents]</body></methods><methods><class-id>RepertoireHome</class-id> <category>cache management</category><body package="SmallInterfaces" selector="clearEntryFor:">clearEntryFor: aBehavior	classRepertoiresDictionary 		removeKey: aBehavior		ifAbsent: []</body><body package="SmallInterfaces" selector="clearRepertoires">clearRepertoires	classRepertoiresDictionary := IdentityDictionary new</body><body package="SmallInterfaces" selector="computeRepertoires">computeRepertoires	Interface valueWithoutSynchronization: 		[self clearRepertoires.		#{ProgressWidgetView}			ifDefinedDo: [:widget | self computeRepertoiresWithGuiFeedback]			elseDo: [self computeRepertoiresWithoutGuiFeedback]]</body><body package="SmallInterfaces" selector="computeRepertoiresWithGuiFeedback">computeRepertoiresWithGuiFeedback	| classes tally model counter controller |	classes := self environment allNonInterfaceBehaviors.	tally := classes size.	model := 0 asValue.	counter := 0.0.	controller := ProgressWidgetView 		progressOpenOn: model		label: 'Caching repertoires for all classes...'.				[classes do: 		[:each | 		self createEntryFor: each.		counter := counter + 1.		model value: counter / tally]] ensure: [controller closeAndUnschedule]</body><body package="SmallInterfaces" selector="computeRepertoiresWithoutGuiFeedback">computeRepertoiresWithoutGuiFeedback	Cursor execute showWhile: 		[self environment allNonInterfaceBehaviors do: [:each | self createEntryFor: each]]</body><body package="SmallInterfaces" selector="createEntryFor:">createEntryFor: aBehavior 	classRepertoiresDictionary 		at: aBehavior		put: aBehavior selectorsForRepertoire</body></methods><methods><class-id>RepertoireHome</class-id> <category>querying</category><body package="SmallInterfaces" selector="repertoireFor:">repertoireFor: aBehavior	^classRepertoiresDictionary 		at: aBehavior		ifAbsentPut: [aBehavior selectorsForRepertoire]</body></methods><methods><class-id>RepertoireHome</class-id> <category>initialize-release</category><body package="SmallInterfaces" selector="aspectsOfInterest">aspectsOfInterest	"For the purpose of synchronizing with interfaces, which system changes should we care about?	Note: we are not interested in:		#changeClass: - because a class' state has no effect on it behavior.		#addClass: - because a class repertoire is retrieved lazily."			^#(removeClass: 	addSelector:class: 	removeSelector:class:)</body><body package="SmallInterfaces" selector="connectToChangeNotifications">connectToChangeNotifications	ChangeSet addDependent: self.	ObjectMemory addDependent: self.</body><body package="SmallInterfaces" selector="disconnectFromChangeNotifications">disconnectFromChangeNotifications	ChangeSet removeDependent: self.	ObjectMemory removeDependent: self.</body><body package="SmallInterfaces" selector="initialize">initialize	self 		computeRepertoires;		connectToChangeNotifications</body><body package="SmallInterfaces" selector="release">release	super release.	self disconnectFromChangeNotifications.</body></methods><methods><class-id>RepertoireHome</class-id> <category>updating</category><body package="SmallInterfaces" selector="shutDown">shutDown 	"The cached repertoires can take a huge amount of space (&gt; 10 Mbytes). 	To allow for a smaller size image, each time the image is exited the cache can be discarded.	Note: nuking the singleton is followed by a globalGarbageCollect."		Interface configuration discardInterfacesOnShutDown ifTrue: [RepertoireHome nuke]</body><body package="SmallInterfaces" selector="update:with:from:">update: aspect with: aParameter from: sender 		(sender == ChangeSet and: 	[Interface configuration synchronize and:	[self aspectsOfInterest includes: aspect]]) 		ifTrue:			[| selector behavior |				"Note: &lt;aParameter&gt; usually consists of: #(aSymbol aBehavior)"			selector := aParameter detect: [:each | each isSymbol] ifNone: [nil].			behavior := aParameter detect: [:each | each isBehavior].			behavior 				synchronizeChangeOf: aspect 				usingSelector: selector.			self clearEntryFor: behavior].				((sender == ObjectMemory) and: [aspect == #aboutToSnapshot]) 		ifTrue: [self shutDown]</body></methods><methods><class-id>RepertoireHome class</class-id> <category>instance creation</category><body package="SmallInterfaces" selector="current">current	^singleton ifNil: [singleton := super new initialize]</body><body package="SmallInterfaces" selector="new">new	^self current</body><body package="SmallInterfaces" selector="nuke">nuke	"Note: nuking the singleton is followed by a globalGarbageCollect."	singleton notNil ifTrue: [singleton release].	singleton := nil.	ObjectMemory globalGarbageCollect.</body></methods><methods><class-id>RepertoireHome class</class-id> <category>class initialization</category><body package="SmallInterfaces" selector="genericMetaRepertoire">genericMetaRepertoire	"Repertoire of the meta chain from Class up to Behavior.	This one, all classes (instances of Metaclass) share."	GenericMetaRepertoire 		ifNil:			[GenericMetaRepertoire := (Class withAllSuperclasses remove: Object; yourself)					inject: (IdentitySet new: 700)				into: [:set :each | set addAll: each selectors; yourself]].	^GenericMetaRepertoire copy</body><body package="SmallInterfaces" selector="initialize">initialize	self nuke.	self current.</body><body package="SmallInterfaces" selector="obsolete">obsolete	self nuke</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallInterfaces" selector="conformsTo:">conformsTo: anInterface	"Can I respond to any message in &lt;anInterface&gt; repertoire?"	^self class understands: anInterface</body><body package="SmallInterfaces" selector="ends:">ends: aSequenceableCollection	"Answer whether the last element of aSequenceableCollection is equal to the receiver."	^aSequenceableCollection last = self</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="SmallInterfaces" selector="environment">environment	^self class environment</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallInterfaces" selector="equalsLiteral:">equalsLiteral: literal	"Answer whether the receiver which is a literal of a method	 equals the literal."	^self = literal</body></methods><methods><class-id>Core.Object</class-id> <category>message handling</category><body package="SmallInterfaces" selector="ifNil:">ifNil: ignored 	"since I am not nil, return myself.	NOTE: this message should be inlined by compiler."	^self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallInterfaces" selector="isClass">isClass	"Answer whether the receiver is a class."	^false</body><body package="SmallInterfaces" selector="isCollection">isCollection	"Answer whether the receiver is an instance of a kind of Collection."	^false</body><body package="SmallInterfaces" selector="isInterface">isInterface	^false</body><body package="SmallInterfaces" selector="isTypeOf:">isTypeOf: aClassOrInterface	^aClassOrInterface isEmbodiedIn: self</body></methods><methods><class-id>Core.Object</class-id> <category>indicating</category><body package="SmallInterfaces" selector="shouldImplementFor:">shouldImplementFor: anInterface 	"This method is used to mark a method as one generated (and stubbed) for an interface."	^anInterface implementorsResponsibility</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="SmallInterfaces" selector="starts:">starts: aSequenceableCollection	"Answer whether the first element of aSequenceableCollection is equal to the receiver."	^aSequenceableCollection first = self</body></methods><methods><class-id>Core.Object</class-id> <category>indicating</category><body package="SmallInterfaces" selector="subclassesShouldOverride">subclassesShouldOverride	"Unlike #subclassResponsibility, this is a recommendation only."</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="SmallInterfaces" selector="types">types	"Which are all the types which I embody?	Definition: Type = (Class | Interface)"	^self class allSuperclasses 		add: self class;		addAll: self class allInterfaces;		yourself</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="SmallInterfaces" selector="asClass">asClass	"Answer the class I designate."	^self asSymbol asClass</body><body package="SmallInterfaces" selector="subStrings">subStrings	"Answer an array which contains the words in the receiver."	^self asArrayOfSubstrings</body><body package="SmallInterfaces" selector="trimSeparators">trimSeparators	"Return a copy of the receiver that has leading and trailing separators removed."	| size index |	(size := self size) == 0 ifTrue: [^self].	index := 1.	[(self at: index) isSeparator] whileTrue: [		index = size ifTrue: [^''].		index := index + 1].	[(self at: size) isSeparator] whileTrue: [		index = size ifTrue: [^''].		size := size - 1].	^self copyFrom: index to: size</body></methods><methods><class-id>Core.Metaclass</class-id> <category>compiling-st80</category><body package="SmallInterfaces" selector="classImplementationErrorMessage">classImplementationErrorMessage 	^'Sorry, but the semantics of an Interface prohibit it from having any implementation on its class side...'</body><body package="SmallInterfaces" selector="compile:classified:notifying:">compile: code classified: heading notifying: requestor 	| before result after selector |	(self homeClass isInterface and: 	[selector := Parser new parseSelector: code.	"the better implementation is:		selector := (RBParser parseMethod: code) selector."	(Interface compilableMetaSelectors includes: selector) not])		ifTrue: 			[requestor notNil ifTrue: [Dialog warn: self classImplementationErrorMessage].			^nil].	before := self interfaces.	result := super compile: code classified: heading notifying: requestor. 	after := self interfaces.	self 		notify: requestor 		onDiscoveryOf: (after - before).	self resetRepertoire.	^result</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing</category><body package="SmallInterfaces" selector="conformsTo:">conformsTo: anInterface	"Can I respond to any message in &lt;anInterface&gt; repertoire?"	^self understands: anInterface</body></methods><methods><class-id>Core.Metaclass</class-id> <category>interfaces creation</category><body package="SmallInterfaces" selector="defaultInterfaceName">defaultInterfaceName	^(self homeClass name, 'Factory') asSymbol</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="SmallInterfaces" selector="homeClass">homeClass	"I am a metaclass - return the class I am meta for."	^self soleInstance</body></methods><methods><class-id>Core.Metaclass</class-id> <category>compiling-st80</category><body package="SmallInterfaces" selector="instanceVariableNames:interfaces:">instanceVariableNames: stringOfInstVars interfaces: stringOfInterfaces 	self homeClass isInterface 		ifTrue: 			[Dialog warn: self classImplementationErrorMessage.			^nil].		self instanceVariableNames: stringOfInstVars.	self implementInterfacesNamed: stringOfInterfaces.</body></methods><methods><class-id>Core.Metaclass</class-id> <category>repertoire</category><body package="SmallInterfaces" selector="selectorsForRepertoire">selectorsForRepertoire	^RepertoireHome genericMetaRepertoire 		addAll: self allSelectors;		yourself</body></methods><methods><class-id>Core.Collection class</class-id> <category>instance creation</category><body package="SmallInterfaces" selector="newLarge">newLarge	^self new: 100</body></methods><methods><class-id>Core.Collection</class-id> <category>adding</category><body package="SmallInterfaces" selector=",">, aCollection 	"Answer a copy of the receiver agregated with the argument, aCollection."	^self copy 		addAll: aCollection;		yourself</body></methods><methods><class-id>Core.Collection</class-id> <category>set operations</category><body package="SmallInterfaces" selector="+">+ aCollection 	^self , aCollection</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallInterfaces" selector="allSatisfy:">allSatisfy: aBlock 	"Note that an empty collection will return true!	&lt;'some' allSatisfy: [:each | each isCharacter]&gt;	&lt;#() allSatisfy: [:each | each isNumber]&gt;	&lt;'some' allSatisfy: [:each | each == true]&gt;"		^(self select: aBlock) includesAll: self</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="SmallInterfaces" selector="asIdentitySet">asIdentitySet	^IdentitySet withAll: self</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallInterfaces" selector="consistsOf:">consistsOf: aCollection 	"Returns true if the contents of the receiver and &lt;aCollection&gt; 	are exactly the same - order doesn't matter."	^self size = aCollection size and: [self includesAllOccurrences: aCollection]</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="SmallInterfaces" selector="flattened">flattened	"Answer a new collection containing all my elements, flattened,	which means: if an element is a collection, then flatten it as well (recursively).	&lt;#(1 #(2 3 4) #(10 #(12 13 14 #(#(100) 200 #(251 252) 300 400)))) flattened&gt;"	| newCollection |	newCollection := self species new: self size.	self do: 		[:each | 		each isCollection			ifTrue: [newCollection addAll: each flattened]			ifFalse: [newCollection add: each]].	^newCollection</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallInterfaces" selector="includesAll:">includesAll: aCollection	"Answer whether the receiver includes each element of aCollection."	self size &lt; aCollection size ifTrue: [^false].	aCollection do: [:each | (self includes: each) ifFalse: [^false]].	^true</body><body package="SmallInterfaces" selector="includesAllOccurrences:">includesAllOccurrences: aCollection 	"Return true if the receiver includes all elements in aCollection. 	If aCollection contains duplicate elements, the receiver must have one for each of them."	| meAsBag otherBag |	aCollection size &gt; self size ifTrue: [^false].	otherBag := aCollection asBag.	meAsBag := self asBag.	otherBag do: [:each | (meAsBag occurrencesOf: each) &lt; (otherBag occurrencesOf: each) ifTrue: [^false]].	^true</body><body package="SmallInterfaces" selector="includesAny:">includesAny: aCollection	"Return true if the receiver includes any of the elements in aCollection."	aCollection do: [:each | (self includes: each) ifTrue: [^true]].	^false</body></methods><methods><class-id>Core.Collection</class-id> <category>set operations</category><body package="SmallInterfaces" selector="intersectionWith:">intersectionWith: anotherCollection	"Return the elements in common with receiver and anotherCollection 	as an appropriate collection with one instance of each element."	^anotherCollection intersectionWithSet: self asSet</body><body package="SmallInterfaces" selector="intersectionWithIdentitySet:">intersectionWithIdentitySet: identitySet	"Return the elements in common with receiver and identitySet 	as a set with one instance of each element."	^self intersectionWithSet: identitySet</body><body package="SmallInterfaces" selector="intersectionWithSet:">intersectionWithSet: aSet	"Return the elements in common with receiver and anotherCollection 	as an appropriate collection with one instance of each element."	^self asSet intersectionWithSet: aSet</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallInterfaces" selector="isCollection">isCollection	"Answer whether the receiver is a &lt;Collection&gt;."	^true</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SmallInterfaces" selector="keysAndValuesDo:">keysAndValuesDo: a2ArgBlock 	"Evaluate &lt;a2ArgBlock&gt; with each of the receiver's key/value pairs as the arguments,	where an arbitrary index is the key, and element is the value.	&lt;'ABC' asSet keysAndValuesDo: [:index :each | Transcript show: index printString; tab; show: each; cr]&gt;"	| index |	index := 0.	self do: [:each | a2ArgBlock value: (index := index + 1) value: each]</body></methods><methods><class-id>Core.Class class</class-id> <category>sorting</category><body package="SmallInterfaces" selector="sortBlock">sortBlock		"Answer a sort block for sorting classes alphabetically."	^[:a :b | a name &lt;= b name]</body></methods><methods><class-id>Core.Class class</class-id> <category>instance creation</category><body package="SmallInterfaces" selector="templateWithInterfaces:">templateWithInterfaces: category	"Answer an expression that can be edited and evaluated in order to define a new interface."	^(self template: category),'	interfaces: '''' '</body></methods><methods><class-id>Core.Class</class-id> <category>compiling</category><body package="SmallInterfaces" selector="compile:classified:notifying:">compile: code classified: heading notifying: requestor	| before result after |	before := self interfaces.	result := super compile: code classified: heading notifying: requestor. 	after := self interfaces.	self 		notify: requestor 		onDiscoveryOf: (after - before).	self resetRepertoire.	^result</body></methods><methods><class-id>Core.Class</class-id> <category>interfaces creation</category><body package="SmallInterfaces" selector="defaultInterfaceName">defaultInterfaceName	^(self name, 'Interface') asSymbol</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="SmallInterfaces" selector="homeClass">homeClass	"I am the home class, so me."	^self</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="SmallInterfaces" selector="isClass">isClass	"Answer whether the receiver is a class."	^true</body><body package="SmallInterfaces" selector="isEmbodiedIn:">isEmbodiedIn: anObject	^anObject isKindOf: self</body></methods><methods><class-id>Core.Class</class-id> <category>repertoire</category><body package="SmallInterfaces" selector="selectorsForRepertoire">selectorsForRepertoire	^self allSelectors asIdentitySet</body></methods><methods><class-id>Core.Class</class-id> <category>subclass creation</category><body package="SmallInterfaces" selector="subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:interfaces:">subclass: className	instanceVariableNames: stringOfInstVars	classVariableNames: stringOfClassVars	poolDictionaries: stringOfPoolNames	category: category 	interfaces: stringOfInterfaces	"Create or modify class so it would adhere to the declared Interfaces."	^self environment		defineClass: className		superclass: self fullyQualifiedReference		indexedType: #none		private: (self environment bindingFor: self name) isPrivate		instanceVariableNames: stringOfInstVars		classInstanceVariableNames: ''		imports: (self asNameSpace importString)		category: category		interfaces: stringOfInterfaces</body></methods><methods><class-id>Core.Class</class-id> <category>updating</category><body package="SmallInterfaces" selector="synchronizeWith:removalOf:">synchronizeWith: anInterface removalOf: selector 	((anInterface methodsStubedIn: self) includes: selector) 		ifTrue: 			[self removeSelector: selector ifAbsent: [].			self removeAllEmptyCategories]</body></methods><methods><class-id>Core.Class</class-id> <category>subclass creation</category><body package="SmallInterfaces" selector="variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:interfaces:">variableByteSubclass: className	instanceVariableNames: stringOfInstVars	classVariableNames: stringOfClassVars	poolDictionaries: stringOfPoolNames	category: category 	interfaces: stringOfInterfaces	"Create or modify class so it would adhere to the declared Interfaces."	^self environment		defineClass: className		superclass: self fullyQualifiedReference		indexedType: #bytes		private: (self environment bindingFor: self name) isPrivate		instanceVariableNames: stringOfInstVars		classInstanceVariableNames: ''		imports: (self asNameSpace importString)		category: category		interfaces: stringOfInterfaces</body><body package="SmallInterfaces" selector="variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:interfaces:">variableSubclass: className	instanceVariableNames: stringOfInstVars	classVariableNames: stringOfClassVars	poolDictionaries: stringOfPoolNames	category: category 	interfaces: stringOfInterfaces	"Create or modify class so it would adhere to the declared Interfaces."	^self environment		defineClass: className		superclass: self fullyQualifiedReference		indexedType: #objects		private: (self environment bindingFor: self name) isPrivate		instanceVariableNames: stringOfInstVars		classInstanceVariableNames: ''		imports: (self asNameSpace importString)		category: category		interfaces: stringOfInterfaces</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>interfaces</category><body package="SmallInterfaces" selector="allInterfaces">allInterfaces	^Interface home allInterfaces select: [:each | self understands: each]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>organization</category><body package="SmallInterfaces" selector="allSelectorsReferencing:">allSelectorsReferencing: literal	^(self whichMethodsReferenceLiteral: literal) collect: [:each | each selector]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>interfaces creation</category><body package="SmallInterfaces" selector="asInterface">asInterface	^self asInterfaceNamed: self defaultInterfaceName</body><body package="SmallInterfaces" selector="asInterfaceNamed:">asInterfaceNamed: aSymbol	(Interface home includesInterfaceNamed: aSymbol) 		ifTrue: [^self error: aSymbol asString, ' interface already exists!'].	^Interface newNamed: aSymbol from: self</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>querying</category><body package="SmallInterfaces" selector="commentFor:">commentFor: selector		"Return the comment entered for selector."	| cm |	cm := self compiledMethodAt: selector ifAbsent: [^''].	^cm commentString</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>printing</category><body package="SmallInterfaces" selector="definitionWithInterfaces">definitionWithInterfaces 	| writer classInterfacesSelector classInterfaces |	writer := String newLarge writeStream.	writer		nextPutAll: self definition;		crtab;		nextPutAll: 'interfaces: ';		nextPut: $'.	classInterfacesSelector := Interface configuration selectorForClassInterfaces.	classInterfaces := (self perform: classInterfacesSelector) asSortedCollection: Class sortBlock.	classInterfaces do: [:each | writer nextPutAll: each name asString; space].	writer nextPut: $'.	^writer contents</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>message creation-removal</category><body package="SmallInterfaces" selector="detachableMethodsFor:">detachableMethodsFor: anInterface	^Interface configuration removeOnlyStubs		ifTrue: [anInterface methodsStubedIn: self]		ifFalse: [anInterface methodsImplementedBy: self]</body><body package="SmallInterfaces" selector="detachFromAllInterfacesBut:">detachFromAllInterfacesBut: interfaces	"Note: Since interfaces can overlap, we need to remove only the non-overlapping portion."	| interfacesToDiscard discardable collective |	interfacesToDiscard := self allInterfaces - interfaces.	discardable := interfacesToDiscard 		inject: Set new		into: [:repertoire :each | repertoire addAll: (self detachableMethodsFor: each); yourself].	collective := interfaces		inject: Set new		into: [:repertoire :each | repertoire addAll: (self detachableMethodsFor: each); yourself].	self removeMethods: (discardable - collective).</body><body package="SmallInterfaces" selector="implement:">implement: anInterface 	"Create implementations for all of &lt;anInterface&gt; methods which I do not understand yet."	self implement: anInterface enforce: false</body><body package="SmallInterfaces" selector="implement:enforce:">implement: anInterface enforce: enforcing	"Create methods implementations on behalf of &lt;anInterface&gt;.	If &lt;enforcing&gt;, create implementations for all of &lt;anInterface&gt;'s repetoire (rather then merely 	understand it). If not, create implementations only for the part I do not understand yet."	| selectorsToBeImplemented |	selectorsToBeImplemented := (enforcing or: [anInterface mustBeImplemented])		ifTrue: [anInterface methodsNotImplementedBy: self]		ifFalse: [anInterface methodsNotUnderstoodBy: self].	selectorsToBeImplemented do: [:each | anInterface createStubedMethodFor: each from: self]</body><body package="SmallInterfaces" selector="implementAll:">implementAll: interfaces 	interfaces do: [:each | self implement: each]</body><body package="SmallInterfaces" selector="implementAll:discardExisting:">implementAll: interfaces discardExisting: discarding 	"Create implementations for &lt;interfaces&gt;.	If &lt;discarding&gt;, discard existing implementations of interfaces not in &lt;interfaces&gt;."	discarding ifTrue: [self detachFromAllInterfacesBut: interfaces].	self implementAll: interfaces.	self resetRepertoire.</body><body package="SmallInterfaces" selector="implementationStringForInterface">implementationStringForInterface	^String newLarge writeStream		nextPutAll: '^self';		space;		nextPutAll: Interface selectorForImplementation asString;		contents</body><body package="SmallInterfaces" selector="implementInterfacesNamed:">implementInterfacesNamed: stringOfInterfaces 	self 		implementAll: (Interface interfacesFromString: stringOfInterfaces)		discardExisting: true.</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>interfaces</category><body package="SmallInterfaces" selector="interfaces">interfaces	"The minimal set of interfaces which fully describe the repertoire of all interfaces I understand."	^Interface consolidate: self allInterfaces</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>compiling</category><body package="SmallInterfaces" selector="notify:onDiscoveryOf:">notify: requestor onDiscoveryOf: interfaces	(Interface configuration notifyOnDerivationDiscovery and:	[interfaces notEmpty and: 	[requestor notNil]])		ifTrue: 			[| writer |			writer := String new writeStream.			writer nextPutAll: self printString; nextPutAll: ' is now also conforming to: '.			(interfaces asSortedCollection: Class sortBlock) do: 				[:each | writer cr; nextPutAll: '   - '; nextPutAll: each printString].			Dialog warn: writer contents]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>documentation</category><body package="SmallInterfaces" selector="providedInterfaces">providedInterfaces	"This method is a template which aims to facilitate documenting the interfaces a class should be providing.	At that point the question &lt;aBehavior suppliesProvidedInterfaces&gt; becomes meaningful."		self subclassesShouldOverride.	^#()</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>organization</category><body package="SmallInterfaces" selector="removeAllEmptyCategories">removeAllEmptyCategories	self organization removeEmptyCategories</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>message creation-removal</category><body package="SmallInterfaces" selector="removeMethods:">removeMethods: selectors	selectors do: [:each | self removeSelector: each ifAbsent: []].	self removeAllEmptyCategories.</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>repertoire</category><body package="SmallInterfaces" selector="repertoire">repertoire	"Note: the original implementation was - ^self allSelectors.	However, since this was very slow, a new caching scheme can be used instead."	^RepertoireHome current repertoireFor: self</body><body package="SmallInterfaces" selector="repertoireImplemented">repertoireImplemented	^self selectors</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>documentation</category><body package="SmallInterfaces" selector="requiredInterfaces">requiredInterfaces	"This method is a template which aims to facilitate documenting the interfaces a class should be able to understand.	At that point the question &lt;aBehavior understandsRequiredInterfaces&gt; becomes meaningful."		self subclassesShouldOverride.	^#()</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>repertoire</category><body package="SmallInterfaces" selector="resetRepertoire">resetRepertoire	RepertoireHome current clearEntryFor: self</body><body package="SmallInterfaces" selector="selectorsForRepertoire">selectorsForRepertoire	^self subclassResponsibility</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>querying</category><body package="SmallInterfaces" selector="selectorsInCategory:">selectorsInCategory: categoryName 	Symbol 		hasInterned: categoryName 		ifTrue: [:sym | ^self organization listAtCategoryNamed: sym].	^#()</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>synchronizing</category><body package="SmallInterfaces" selector="selectToSynchronizeFrom:">selectToSynchronizeFrom: behaviors	^Interface configuration synchronize 		ifTrue: 			[| candidates | 			candidates := behaviors asSortedCollection: Class sortBlock.			(candidates notEmpty and:			[Interface configuration synchronizeSelectively])				ifTrue: 					[SimpleDialog						chooseMultiple: 'Choose which candidates to synchronize:'						fromList: (candidates collect: [:each | each name])						values: candidates						lines: 8]			ifFalse: [candidates]]		ifFalse: [#()].</body><body package="SmallInterfaces" selector="synchronizeChangeOf:usingSelector:">synchronizeChangeOf: aspect usingSelector: selector	(aspect == #removeClass:) 		ifTrue: 			[RepertoireHome current 				clearEntryFor: self;				clearEntryFor: self class]</body><body package="SmallInterfaces" selector="synchronizeWith:removalOf:">synchronizeWith: anInterface removalOf: selector 	((anInterface methodsStubedIn: self) includes: selector) 		ifTrue: [self removeMethods: (Array with: selector)]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>interfaces</category><body package="SmallInterfaces" selector="understands:">understands: anInterface	"Can my instances respond to all of &lt;anInterface&gt; repertoire?	Note the difference between implementing and understanding."	^anInterface isUnderstoodBy: self</body><body package="SmallInterfaces" selector="understandsAll:">understandsAll: collectionOfInterfaces	"This method aims to help with design validation"		^collectionOfInterfaces		inject: true		into: 			[:truth :interface |			truth and: [self understands: interface]]</body><body package="SmallInterfaces" selector="understandsRepertoire:">understandsRepertoire: repertoire	"Can I understand all of repertoire (collection of messages)?"	^self repertoire includesAll: repertoire</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>documentation</category><body package="SmallInterfaces" selector="understandsRequiredInterfaces">understandsRequiredInterfaces	"This method aims to help with design validation"		^self requiredInterfaces		inject: true		into: 			[:truth :interface |			truth and: [self understands: interface]]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>message creation-removal</category><body package="SmallInterfaces" selector="unimplement:">unimplement: anInterface	"Remove implementations for all of &lt;anInterface&gt; repertoire I already implement.	If &lt;removeOnlyStubbs&gt;, remove only the the stubbed implementations.	Otherwise, remove all methods implemented on behalf of &lt;anInterface&gt;.	Note: methods I understand but do not implement would not be removed"	self removeMethods: (self detachableMethodsFor: anInterface).</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="SmallInterfaces" selector="asClass">asClass	"Answer the class I designate. Return nil if no such class exists.	&lt;#String asClass&gt;	&lt;'Array' asClass&gt;	&lt;'foo' asClass&gt;"	^Smalltalk allClasses 		detect: [:each | each name == self]  		ifNone: [nil]</body></methods><methods><class-id>Core.Symbol</class-id> <category>printing</category><body package="SmallInterfaces" selector="asSelectorStringWithArgumentsString">asSelectorStringWithArgumentsString	"&lt;#at:put: asSelectorStringWithArguments&gt;	&lt;#halt asSelectorStringWithArguments&gt;	&lt;#@ asSelectorStringWithArguments&gt;"		| writer |	self isUnary ifTrue: [^self asString].	self isBinary ifTrue: [^self asString, ' anObject'].	writer := WriteStream on: String newLarge.	self keywords withIndexDo: 		[:index :each |		writer 			nextPutAll: each;			nextPutAll: ' arg';			nextPutAll: index printString;			space].	^writer contents</body></methods><methods><class-id>Core.Symbol</class-id> <category>testing</category><body package="SmallInterfaces" selector="isBinary">isBinary	"if I am to be interpreted as a message selector, am I a binary method? (such as #&lt;).	&lt;#@ isBinary&gt;	&lt;#== isBinary&gt;	&lt;#halt isBinary&gt;	&lt;#at: isBinary&gt;"	^self numArgs = 1 and: [(self endsWith: $:) not]</body><body package="SmallInterfaces" selector="isUnary">isUnary	"if I am to be interpreted as a message selector, am I an unary method? (such as #class).	&lt;#@ isUnary&gt;	&lt;#halt isUnary&gt;	&lt;#at: isUnary&gt;"	^self numArgs = 0</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="SmallInterfaces" selector="ends:">ends: aSequenceableCollection 	"Answer whether the last elements of aSequenceableCollection are equal to the elements of the reciever."	^self reverse starts: aSequenceableCollection reverse</body><body package="SmallInterfaces" selector="endsWith:">endsWith: aSequenceableCollectionOrObject  	"if aSequenceableCollectionOrObject is a &lt;SequenceableCollection&gt;, answer whether the 	last elements of the receiver, respectively, are equal to the elements of the &lt;SequenceableCollection&gt;.	if aSequenceableCollectionOrObject is any other kind of object, answer whether the 	last element of the receiver equals to that &lt;Object&gt;."	^aSequenceableCollectionOrObject ends: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="SmallInterfaces" selector="reversed">reversed	^self reverse</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="SmallInterfaces" selector="starts:">starts: aSequenceableCollection 	"Answer whether the first elements of aSequenceableCollection are equal to the elements of the reciever.	&lt;'in' starts: 'in the beginning...' &gt;"	(self isEmpty or:	[aSequenceableCollection size &lt; self size]) ifTrue: [^false].			1 to: self size do: [:each | (aSequenceableCollection at: each) = (self at: each) ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="SmallInterfaces" selector="withIndexDo:">withIndexDo: a2ArgBlock 	"Evaluate &lt;a2ArgBlock&gt; with each of the receiver's key/value pairs as the arguments,	where index is the key, and element is the value.	&lt;'ABC' withIndexDo: [:index :each | Transcript show: index printString; tab; show: each; cr]&gt;"		^self keysAndValuesDo: a2ArgBlock</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>testing</category><body package="SmallInterfaces" selector="equalsLiteral:">equalsLiteral: literal	"Answer whether the receiver or a contained block	 references literal. The object can either be an element	 of an array or the key or value of an association."	^self == literal or: [		self referencesLiteral: literal]</body><body package="SmallInterfaces" selector="referencesLiteral:">referencesLiteral: literal	"Answer whether the receiver or a contained block	 references literal. The object can either be an element	 of an array or the key or value of an association."	1 to: self numLiterals do: [:i |		((self basicAt: i) equalsLiteral: literal) ifTrue: [^true]].	^false</body></methods><methods><class-id>Core.Set</class-id> <category>adding</category><body package="SmallInterfaces" selector=",">, aCollection 	"Answer a copy of the receiver concatenated with the argument, aCollection."		^self copy		addAll: aCollection asSet;		yourself</body></methods><methods><class-id>Core.Set</class-id> <category>set operations</category><body package="SmallInterfaces" selector="&amp;">&amp; aSet 	"Set intersection"	^self intersectionWith: aSet</body><body package="SmallInterfaces" selector="intersectionWith:">intersectionWith: aSet	"Intersection of two sets."	^self select: [:each | aSet includes: each]</body><body package="SmallInterfaces" selector="intersectionWithSet:">intersectionWithSet: aSet	"Return the elements in common with receiver and aSet as a set with one instance of each element.	&lt;#(1 2 3) asSet intersectionWithSet: #(2 3 4) asSet&gt;"	^(self size &lt;= aSet size)		ifTrue: [self select: [:each | aSet includes: each]]		ifFalse: [aSet intersectionWithSet: self]</body></methods><methods><class-id>Core.ArrayedCollection</class-id> <category>converting</category><body package="SmallInterfaces" selector="flattened">flattened	"Answer a new collection containing all my elements, flattened,	which means: if an element is a collection, then flatten it as well (recursively).	Note: overriding super since it is adding to an ArrayedCollection is not appropriate."	| newCollection |	newCollection := OrderedCollection new: self size.	self do: 		[:each | 		each isCollection			ifTrue: [newCollection addAll: each flattened]			ifFalse: [newCollection add: each]].	^newCollection</body></methods><methods><class-id>Core.Dictionary</class-id> <category>set operations</category><body package="SmallInterfaces" selector="intersectionWithSet:">intersectionWithSet: aSet	"Return the elements in common with receiver and aSet 	as a set with one instance of each value in receiver that is equal to one in aSet"	^self values asSet intersectionWithSet: aSet</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>message handling</category><body package="SmallInterfaces" selector="ifNil:">ifNil: aBlock 	"since I am nil, return the evaluation of aBlock.	NOTE: this message should be inlined by compiler."	^aBlock value</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>compiling-st80</category><body package="SmallInterfaces" selector="subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:interfaces:">subclass: className	instanceVariableNames: stringOfInstVars	classVariableNames: stringOfClassVars	poolDictionaries: stringOfPoolNames	category: category 	interfaces: stringOfInterfaces	"Create or modify class so it would adhere to the declared Interfaces."	^self environment		defineClass: className		superclass: self		indexedType: #none		private: (self environment bindingFor: self name) isPrivate		instanceVariableNames: stringOfInstVars		classInstanceVariableNames: ''		imports: (self asNameSpace importString)		category: category		interfaces: stringOfInterfaces</body><body package="SmallInterfaces" selector="variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:interfaces:">variableByteSubclass: className	instanceVariableNames: stringOfInstVars	classVariableNames: stringOfClassVars	poolDictionaries: stringOfPoolNames	category: category 	interfaces: stringOfInterfaces	"Create or modify class so it would adhere to the declared Interfaces."	^self environment		defineClass: className		superclass: self		indexedType: #bytes		private: (self environment bindingFor: self name) isPrivate		instanceVariableNames: stringOfInstVars		classInstanceVariableNames: ''		imports: (self asNameSpace importString)		category: category		interfaces: stringOfInterfaces</body><body package="SmallInterfaces" selector="variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:interfaces:">variableSubclass: className	instanceVariableNames: stringOfInstVars	classVariableNames: stringOfClassVars	poolDictionaries: stringOfPoolNames	category: category 	interfaces: stringOfInterfaces	"Create or modify class so it would adhere to the declared Interfaces."	^self environment		defineClass: className		superclass: self		indexedType: #objects		private: (self environment bindingFor: self name) isPrivate		instanceVariableNames: stringOfInstVars		classInstanceVariableNames: ''		imports: (self asNameSpace importString)		category: category		interfaces: stringOfInterfaces</body></methods><methods><class-id>Core.IdentitySet</class-id> <category>converting</category><body package="SmallInterfaces" selector="asIdentitySet">asIdentitySet	^self</body></methods><methods><class-id>UI.SimpleDialog class</class-id> <category>user queries</category><body package="SmallInterfaces" selector="chooseMultiple:fromList:values:lines:">chooseMultiple: messageString fromList: list values: listValues lines: maxLines	^self new 		chooseMultiple: messageString		fromList: list		values: listValues		buttons: #()		values: #()		lines: maxLines		cancel: [nil]		for: nil</body></methods><methods><class-id>Core.LookupKey</class-id> <category>testing</category><body package="SmallInterfaces" selector="equalsLiteral:">equalsLiteral: literal	"Answer whether the receiver, its key or value is equal to the literal.	 Assumes the key and literal would both be symbols."	^self == literal or: [self key == literal or: [self value == literal]]</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="SmallInterfaces" selector="&gt;&gt;">&gt;&gt; aSelector	"Answer a MethopdDefinition for the compiled method at aSelector."	^MethodDefinition class: self selector: aSelector</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="SmallInterfaces" selector="errorAbsentSelector:">errorAbsentSelector: selector	"Private - Handle the error of the receiver looking for a method named	 selector when it does not define one."	^self error: self name, '&gt;&gt;#', selector, ' is not defined'</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing</category><body package="SmallInterfaces" selector="methodDictionary">methodDictionary	"Answer the receiver's method dictionary"	^methodDict</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="SmallInterfaces" selector="removeSelector:ifAbsent:">removeSelector: selector ifAbsent: exceptionHandler	(self methodDictionary includesKey: selector) ifFalse: [^exceptionHandler value].	^self removeSelector: selector</body></methods><methods><class-id>Core.Behavior</class-id> <category>testing</category><body package="SmallInterfaces" selector="specialSelectorIndexFor:">specialSelectorIndexFor: selector	"Private - Answer the special selector index for the vm."	^CompiledMethod specialSelectorIndexFor: selector</body></methods><methods><class-id>Core.Behavior</class-id> <category>testing method dictionary</category><body package="SmallInterfaces" selector="whichMethodsReferenceLiteral:">whichMethodsReferenceLiteral: literal	"Answer the methods defined by the receiver which reference the	 literal object."	| methods |	methods := OrderedCollection new.	self methodsDo: [:cm |		(cm referencesLiteral: literal) ifTrue: [			methods add: cm]].	^methods</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>testing</category><body package="SmallInterfaces" selector="equalsLiteral:">equalsLiteral: literal	"Answer whether the receiver's method references the literal."	^self == literal or: [		self method equalsLiteral: literal]</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="SmallInterfaces" selector="addSmallInterfacesSectionTo:development:runtime:">addSmallInterfacesSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs	"Add SmallInterfaces's set of preferences and settings slices to the arguments."	| configuration |	configuration := Interface configuration.	self ensure: aDictionary		hasModelFor: #discardInterfacesOnShutDown		editing: #discardInterfacesOnShutDownEditing		default: configuration discardInterfacesOnShutDown.	self ensure: aDictionary		hasModelFor: #notifyOnDerivationDiscovery		editing: #notifyOnDerivationDiscoveryEditing		default: configuration notifyOnDerivationDiscovery.	self ensure: aDictionary		hasModelFor: #removeOnlyStubs		editing: #removeOnlyStubsEditing		default: configuration removeOnlyStubs.	self ensure: aDictionary		hasModelFor: #synchronize		editing: #synchronizeEditing		default: configuration synchronize.	self ensure: aDictionary		hasModelFor: #synchronizeSelectively		editing: #synchronizeSelectivelyEditing		default: configuration synchronizeSelectively.	self ensure: aDictionary		hasModelFor: #synchronizeWithConformers		editing: #synchronizeWithConformersEditing		default: configuration synchronizeWithConformers.	self ensure: aDictionary		hasModelFor: #synchronizeWithExtenders		editing: #synchronizeWithExtendersEditing		default: configuration synchronizeWithExtenders.	self ensure: aDictionary		hasModelFor: #selectorForInterfaceInheritance		editing: #selectorForInterfaceInheritanceEditing		default: configuration selectorForInterfaceInheritance.	self ensure: aDictionary		hasModelFor: #selectorForClassInterfaces		editing: #selectorForClassInterfacesEditing		default: configuration selectorForClassInterfaces.	aDictionary		at: #smallInterfacesConfigurationAccept put: [self smallInterfacesConfigurationAccept];		at: #smallInterfacesConfigurationReset put: [self smallInterfacesConfigurationReset].	devSpecs add: 'Smallinterfaces'-&gt;#(#SmallInterfacesSpec #SmallInterfacesHelp).</body></methods><methods><class-id>UI.UISettings class</class-id> <category>resources</category><body package="SmallInterfaces" selector="selectorForClassInterfacesMenu">selectorForClassInterfacesMenu	| mb |	mb := MenuBuilder new.	#(interfaces allInterfaces repertoire) do: [:each | mb add: (each asString-&gt;each)].	^mb menuHolder</body><body package="SmallInterfaces" selector="selectorForInterfaceInheritanceMenu">selectorForInterfaceInheritanceMenu	| mb |	mb := MenuBuilder new.	#(conformers allConformers parents siblings twins children ancestors descendants extended extenders repertoire) do: 		[:each | mb add: (each asString-&gt;each)].	^mb menu</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="SmallInterfaces" selector="smallInterfacesConfigurationAccept">smallInterfacesConfigurationAccept	"Accept the new configuration for SmallInterfaces"	| configuration |	configuration := Interface configuration.	configuration discardInterfacesOnShutDown: (self preferenceFor: #discardInterfacesOnShutDownEditing).	configuration notifyOnDerivationDiscovery: (self preferenceFor: #notifyOnDerivationDiscoveryEditing).	configuration removeOnlyStubs: (self preferenceFor: #removeOnlyStubsEditing).	configuration synchronize: (self preferenceFor: #synchronizeEditing).	configuration synchronizeSelectively: (self preferenceFor: #synchronizeSelectivelyEditing).	configuration synchronizeWithConformers: (self preferenceFor: #synchronizeWithConformersEditing).	configuration synchronizeWithExtenders: (self preferenceFor: #synchronizeWithExtendersEditing).	configuration selectorForInterfaceInheritance: (self preferenceFor: #selectorForInterfaceInheritanceEditing).	configuration selectorForClassInterfaces: (self preferenceFor: #selectorForClassInterfacesEditing).</body><body package="SmallInterfaces" selector="smallInterfacesConfigurationReset">smallInterfacesConfigurationReset	"Reset the configuration for SmallInterfaces to its value prior to user editing."	| configuration |	configuration := Interface configuration.	(self preferenceModelFor: #discardInterfacesOnShutDownEditing) value: configuration discardInterfacesOnShutDown.	(self preferenceModelFor: #notifyOnDerivationDiscoveryEditing) value: configuration notifyOnDerivationDiscovery.	(self preferenceModelFor: #removeOnlyStubsEditing) value: configuration removeOnlyStubs.	(self preferenceModelFor: #synchronizeEditing) value: configuration synchronize.	(self preferenceModelFor: #synchronizeSelectivelyEditing) value: configuration synchronizeSelectively.	(self preferenceModelFor: #synchronizeWithConformersEditing) value: configuration synchronizeWithConformers.	(self preferenceModelFor: #synchronizeWithExtendersEditing) value: configuration synchronizeWithExtenders.	(self preferenceModelFor: #selectorForInterfaceInheritanceEditing) value: configuration selectorForInterfaceInheritance.	(self preferenceModelFor: #selectorForClassInterfacesEditing) value: configuration selectorForClassInterfaces.</body></methods><methods><class-id>UI.UISettings</class-id> <category>help</category><body package="SmallInterfaces" selector="SmallInterfacesHelp">SmallInterfacesHelp	^'SmallInterfaces Configuration SetupSet the preferences for system-wide behavior of interfaces.Discard Interfaces On Image Save	- should all cached repertoires be discarded each time the image is saved?  Remove Only Stubs	- when unimplementing an interface for a class, which parts of the implementation should be removed?  Synchronization On	- should an interface change be synchronized with affected behaviors (conformers &amp; extenders)?Synchronize with Conformers	- synchronize an interface change with conforming classes?Synchronize with Extenders	- synchronize an interface change with extending interfaces?Selector for Interface Inheritance	- which interfaces should be shown in the definition string?Selector for Class Interfaces	- which interfaces should be shown in the definition string?'</body></methods><methods><class-id>Core.Stream class</class-id> <category>instance creation</category><body package="SmallInterfaces" selector="newLarge">newLarge	^self on: self contentsSpecies newLarge</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>querying</category><body package="SmallInterfaces" selector="allNonInterfaceBehaviors">allNonInterfaceBehaviors	| classes metaclasses |	self isEmpty ifTrue: [^Set new].	classes := self allNonInterfaceClasses.	metaclasses := classes collect: [:each | each class].	^(classes, metaclasses)</body><body package="SmallInterfaces" selector="allNonInterfaceClasses">allNonInterfaceClasses	^Smalltalk allClasses reject: [:each | each isInterface]</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="SmallInterfaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:interfaces:">defineClass: className 	superclass: superID 	indexedType: typeName 	private: isPrivate 	instanceVariableNames: iVars 	classInstanceVariableNames: ciVars 	imports: pools 	category: category 	attributes: attributes 	interfaces: stringOfInterfaces 	"Create or modify class so it would adhere to the declared Interfaces."	| class |	class := self				defineClass: className				superclass: superID				indexedType: typeName				private: isPrivate				instanceVariableNames: iVars				classInstanceVariableNames: ciVars				imports: pools				category: category				attributes: attributes.	class implementInterfacesNamed: stringOfInterfaces.	^class</body><body package="SmallInterfaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:interfaces:">defineClass: className 	superclass: superID 	indexedType: typeName 	private: isPrivate 	instanceVariableNames: iVars 	classInstanceVariableNames: ciVars 	imports: pools 	category: category 	interfaces: stringOfInterfaces 	"Create or modify class so it would adhere to the declared Interfaces."	^self		defineClass: className		superclass: superID		indexedType: typeName		private: isPrivate		instanceVariableNames: iVars		classInstanceVariableNames: ciVars		imports: pools		category: category		attributes: #()		interfaces: stringOfInterfaces</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>querying</category><body package="SmallInterfaces" selector="hasClassNamed:">hasClassNamed: aSymbol	^bindings contains: [:each | each key == aSymbol]</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>testing</category><body package="SmallInterfaces" selector="isHeadless">isHeadless	"Answer whether the image is headless."	^self includesKey: #HeadlessImage</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="SmallInterfaces" selector="asArrayOfSubstrings">asArrayOfSubstrings	"Create an array of substrings. 	Each element is a whitespace bounded word."	| first last collection |	collection := OrderedCollection new.	last := 0.		[first := self findFirst: [:ch | ch isSeparator not] startingAt: last + 1.	first ~= 0] whileTrue: 		[last := (self findFirst: [:ch | ch isSeparator] startingAt: first) - 1.			last &lt; 0 ifTrue: [last := self size].			collection add: (self copyFrom: first to: last)].	^Array withAll: collection</body><body package="SmallInterfaces" selector="asComment">asComment	^self species new writeStream		nextPut: $";		nextPutAll: self;		nextPut: $";		contents</body><body package="SmallInterfaces" selector="asSequenceableCollection:">asSequenceableCollection: aChar 	"Answer a Collection of lines in me. 	The end-of-line character is aChar."	| lines lastEOL |	lines := OrderedCollection new.	lastEOL := 0.	1 to: self size do: 		[:i | 		(self at: i) = aChar			ifTrue: 				[lines addLast: (self copyFrom: lastEOL + 1 to: i - 1).				lastEOL := i]].		"deal with last line if not terminated"	lastEOL = self size ifFalse: [lines addLast: (self copyFrom: lastEOL + 1 to: self size)].	^lines</body></methods><methods><class-id>Core.Array</class-id> <category>testing</category><body package="SmallInterfaces" selector="equalsLiteral:">equalsLiteral: literal	"Answer whether the receiver is the same as the literal or	 contains it."	self = literal ifTrue: [^true].	self do: [:element | element = literal ifTrue: [^true]].	^false</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>printing</category><body package="SmallInterfaces" selector="commentString">commentString	"the better implementation is:	^(RBParser parseMethod: self sourceString) commentString"	| comments |	comments := Parser new parseMethodComment: self getSource setPattern: [:x | ].	^comments notEmpty		ifTrue: [comments first asComment]		ifFalse: ['']</body><body package="SmallInterfaces" selector="headerString">headerString	"the better implementation is:	^self sourceString isEmpty 		ifTrue: [self selector asSelectorStringWithArgumentsString]		ifFalse:[ (RBParser parseMethod: self sourceString) headerString]"	^self sourceString isEmpty 		ifTrue: [self selector asSelectorStringWithArgumentsString]		ifFalse:			[self selector isUnary 				ifTrue: [self selector asString]				ifFalse:					[| writer argumentNames |					writer := WriteStream on: String newLarge.					argumentNames := (Parser new scanFieldNames: self sourceString) 						copyFrom: 1 						to: (self selector keywords size).					self selector keywords with: argumentNames do:						[:eachKeyword :eachArgument | 						writer 							nextPutAll: eachKeyword; space; 							nextPutAll: eachArgument; space].					writer contents]]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SmallInterfaces" selector="methodClass">methodClass	"Answer the class which contains the receiver."	^mclass</body><body package="SmallInterfaces" selector="selector">selector	"Answer the receiver's selector."	| result selector |	(result := self who) isNil 		ifTrue: 			[result := Array 				with: self methodClass 				with: (self methodClass defaultSelectorForMethod: self)].	selector := result at: 2.	^selector</body><body package="SmallInterfaces" selector="sourceString">sourceString	"Return the source code for the receiver."	^self getSource</body></methods><methods><class-id>UI.UISettings class</class-id> <category>interface specs</category><body package="SmallInterfaces" selector="SmallInterfacesSpec">SmallInterfacesSpec	"UIPainter new openOnClass: self andSelector: #SmallInterfacesSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 334 182 591 442 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.494163 2 0 0.5 0 ) 					#label: 'SmallInterfaces Configuration' ) 				#(#CheckBoxSpec 					#layout: #(#Point 18 33 ) 					#model: #discardInterfacesOnShutDownEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: 'Discard cache on image save' ) 				#(#CheckBoxSpec 					#layout: #(#Point 18 79 ) 					#model: #removeOnlyStubsEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: 'Remove only stubs' ) 				#(#ActionButtonSpec 					#layout: #(#Point 18 322 ) 					#name: #acceptButton 					#flags: 40 					#model: #smallInterfacesConfigurationAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 103 322 ) 					#name: #resetButton 					#flags: 40 					#model: #smallInterfacesConfigurationReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 184 322 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 18 0 201 0 -17 1 250 0 ) 					#label: 'Interface Inheritance Selector' ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 23 222 233 244 ) 					#name: #InterfaceInheritanceSelector 					#model: #selectorForInterfaceInheritanceEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#menu: #selectorForInterfaceInheritanceMenu ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 23 279 233 301 ) 					#name: #ClassInterfacesSelector 					#model: #selectorForClassInterfacesEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#menu: #selectorForClassInterfacesMenu ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 18 0 259 0 -17 1 308 0 ) 					#label: 'Class Interfaces Selector ' ) 				#(#CheckBoxSpec 					#layout: #(#Point 18 102 ) 					#model: #synchronizeEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: 'Synchronize interface changes' ) 				#(#CheckBoxSpec 					#layout: #(#Point 35 148 ) 					#model: #synchronizeWithConformersEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: 'Synchronize with Conformers' ) 				#(#CheckBoxSpec 					#layout: #(#Point 36 172 ) 					#model: #synchronizeWithExtendersEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: 'Synchronize with Extenders' ) 				#(#CheckBoxSpec 					#layout: #(#Point 18 125 ) 					#model: #synchronizeSelectivelyEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: 'Synchronize selectively' ) 				#(#CheckBoxSpec 					#layout: #(#Point 18 56 ) 					#model: #notifyOnDerivationDiscoveryEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: 'Notify on derivation discovery' ) ) ) )</body></methods><initialize><class-id>InterfaceConfiguration</class-id></initialize><initialize><class-id>RepertoireHome</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>UISettings</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentitySet</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>LookupKey</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class></st-source>