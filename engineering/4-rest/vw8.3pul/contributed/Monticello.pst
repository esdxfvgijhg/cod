<?xml version="1.0"?><st-source><!-- Name: MonticelloNotice: Copyright © 2010-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: A preliminary Monticello load/merge/importDbIdentifier: bear73DbTrace: 285424DevelopmentPrerequisites: #(#(#bundle 'Base VisualWorks' '') #(#bundle 'Glorp' '') #(#package 'HTTP' '') #(#any 'Compression-Zip' '') #(#bundle 'StoreBase' '') #(#package 'URISupport' '') #(#package 'UUID' ''))ExplicitPrerequisites: #('HTTP')Id: 9f8eca5e-4c7e-48db-98c5-3f6e4e52621cIgnoredPrerequisites: #('Seaside-Platform')Namespace: Smalltalk.MonticelloPackageName: MonticelloParcel: #('Monticello')PrerequisiteParcels: #(#('Base VisualWorks' '') #('Glorp' '') #('HTTP' '') #('Compression-Zip' '') #('StoreBase' '') #('URISupport' '') #('UUID' ''))PrintStringCache: (7.7 - mls.18 1,mlucas-smith)Url: http://www.squeaksource.com/MonticelloVW/Monticello-mls.18.mczVersion: 7.7 - mls.18 1Date: 9:55:48 AM January 28, 2011 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:55:48 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Monticello</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Monticello</package></attributes></name-space><class><name>MCMethodDefinition</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classIsMeta source category selector className timeStamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCMethodDefinition</class-id><body>MCMethodDefinition defines a method to be installed on a class.Instance Variables	category	&lt;Symbol&gt;	the protocol of the method	classIsMeta	&lt;Boolean&gt;	is this method on the class side	className	&lt;Symbol&gt;	name of the class to be resolved relative to our namespace	selector	&lt;Symbol&gt;	the selector of the method	source	&lt;String&gt;	the source code for the method	timeStamp	&lt;String&gt;	timestamp of the method in the format of "&lt;initials&gt; &lt;month/day/year&gt; &lt;hh:mm&gt;"</body></comment><class><name>MCClassVariableDefinition</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCClassVariableDefinition</class-id><body>MCClassVariableDefinition defines a shared variable on an MCClassDefinition.Instance Variables	name	&lt;String&gt;		the name of the variable</body></comment><class><name>MCClassInstanceVariableDefinition</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCClassInstanceVariableDefinition</class-id><body>MCClassInstanceVariableDefinition defines a class instance variable on an MCClassDefinition.Instance Variables	name	&lt;String&gt;		the name of the variable</body></comment><class><name>MCSnapshot</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCSnapshot</class-id><body>MCSnapshot is a representation of a package of code at a moment in time.Instance Variables	definitions	&lt;Collection&gt;	a collection of MC*Definition instances</body></comment><class><name>MCClassDefinition</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name superclassName variables category type comment commentStamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCClassDefinition</class-id><body>MCClassDefinition defines a class.Instance Variables	category	&lt;String&gt;	the class category, these are deprecated in VisualWorks, but classes still have a slot for them	comment	&lt;String&gt;	the classes comment	commentStamp	&lt;String&gt;	the timestamp of when the comment was written and by who	name	&lt;Symbol&gt;	the short name of the class	superclassName	&lt;Symbol&gt;	the short name of the superclass	type	&lt;Symbol&gt;	type of the class	variables	&lt;Collection of: (MCInstanceVariableDefinition | MCClassVariableDefinition | MCClassInstanceVariableDefinition)&gt;	variables for the class</body></comment><class><name>DataStream</name><environment>Monticello</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Object Storage</category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.DataStream</class-id><body>DataStream is like BOSS, but comes from the Squeak world. This is a specialized version that doesn't introduce lots of extensions all over our base classes. It is meant to safely contain the idea of importing/exporting objects using the Squeak binary format. There is also a ReferenceStream in Squeak which allows circular references to be written. Since we're here for Monticello and Monticello doesn't do that, we're not going to include that behavior.Instance Variables	stream	&lt;Stream&gt;	binary stream to read/write from/to</body></comment><class><name>Unknown</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name instanceVariableNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Object Storage</category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.Unknown</class-id><body>Unknown represents a class that exists in Squeak but not in our VisualWorks image.Instance Variables	instanceVariableNames	&lt;SequenceableCollection of: (String)&gt;	name the slots if you want to have getters/setters	name	&lt;Symbol&gt;	name of the class that was missing</body></comment><class><name>MCRepository</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages url names </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCRepository</class-id><body>MCRepository is a cache of packages urls and unique package names at a url location.Instance Variables	names	&lt;(Collection of: (String))&gt;	names of packages without versions	packages	&lt;(Collection of: (URLwithPath))&gt;	urls of all packages in this resposity	url	&lt;URLwithPath&gt;	address of this repository</body></comment><class><name>MCPackage</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url name metadata snapshot environment version timestamp author </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCPackage</class-id><body>MCPackage is a package version of a monticello package.Instance Variables	author	&lt;String&gt;		the initials of the author	environment	&lt;NameSpace&gt;	the environment we're going to install into	metadata	&lt;Dictionary&gt;		version history and properties	name	&lt;String&gt;		name of the package	snapshot	&lt;MCSnapshot&gt;	the versioned objects for this package	timestamp	&lt;Timestamp&gt;	timestamp of this package	url	&lt;URI&gt;	source location of this package	version	&lt;String&gt;		the version of this package</body></comment><class><name>MCInstanceVariableDefinition</name><environment>Monticello</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Monticello</package></attributes></class><comment><class-id>Monticello.MCInstanceVariableDefinition</class-id><body>MCInstanceVariableDefinition defines an instance variable on an MCClassDefinition.Instance Variables	name	&lt;String&gt;		the name of the variable</body></comment><shared-variable><name>Cache</name><environment>Monticello.MCRepository</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Monticello.MCRepository defaultRepositories</initializer><attributes><package>Monticello</package></attributes></shared-variable><shared-variable><name>TypeMap</name><environment>Monticello.DataStream</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>DataStream typeMap</initializer><attributes><package>Monticello</package></attributes></shared-variable><methods><class-id>Monticello.MCMethodDefinition</class-id> <category>converting</category><body package="Monticello" selector="asStoreMethod:">asStoreMethod: package	| fullClassName |	fullClassName := package resolveFullClassName: className.	classIsMeta ifTrue: [fullClassName := fullClassName, ' class'].	^Store.Glorp.StoreMethod new		className: fullClassName;		isMetaclass: classIsMeta;		protocol: category;		name: selector asString;		source: source;		timestamp: package timestamp;		username: package author;		yourself</body></methods><methods><class-id>Monticello.MCMethodDefinition</class-id> <category>accessing</category><body package="Monticello" selector="category">category	^category</body><body package="Monticello" selector="category:">category: anObject	category := anObject</body><body package="Monticello" selector="classIsMeta">classIsMeta	^classIsMeta</body><body package="Monticello" selector="classIsMeta:">classIsMeta: anObject	classIsMeta := anObject</body><body package="Monticello" selector="className">className	^className</body><body package="Monticello" selector="className:">className: anObject	className := anObject</body><body package="Monticello" selector="selector">selector	^selector</body><body package="Monticello" selector="selector:">selector: anObject	selector := anObject</body><body package="Monticello" selector="source">source	^source</body><body package="Monticello" selector="source:">source: anObject	source := anObject</body><body package="Monticello" selector="sourceTrimmed">sourceTrimmed	| stream |	stream := source reverse readStream.	[stream atEnd or: [stream peek isSeparator]] whileTrue: [stream next].	^stream upToEnd reverse</body><body package="Monticello" selector="timeStamp">timeStamp	^timeStamp</body><body package="Monticello" selector="timeStamp:">timeStamp: anObject	timeStamp := anObject</body></methods><methods><class-id>Monticello.MCMethodDefinition</class-id> <category>printing</category><body package="Monticello" selector="printOn:">printOn: aStream	aStream nextPutAll: className, '&gt;&gt;', selector</body></methods><methods><class-id>Monticello.MCMethodDefinition</class-id> <category>testing</category><body package="Monticello" selector="isLike:">isLike: aMethodDefinition	^aMethodDefinition category = category and: [aMethodDefinition classIsMeta = classIsMeta and:		[aMethodDefinition className = className and: [aMethodDefinition selector = selector and:			[aMethodDefinition source = self sourceTrimmed]]]]</body></methods><methods><class-id>Monticello.MCClassVariableDefinition</class-id> <category>converting</category><body package="Monticello" selector="asStoreSharedVariable:environmentName:">asStoreSharedVariable: package environmentName: environmentName	| definition |	definition :=environmentName, ' defineSharedVariable: #', name, '	private: false	constant: false	category: ''accessing''	initializer: nil'.	^Store.Glorp.StoreSharedVariable new		name: name;		environmentName: environmentName;		protocol: 'accessing';		isClassVariable: true;		definition: definition;		timestamp: package timestamp;		username: package author;		yourself</body></methods><methods><class-id>Monticello.MCClassVariableDefinition</class-id> <category>accessing</category><body package="Monticello" selector="name">name	^name</body><body package="Monticello" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Monticello.MCClassInstanceVariableDefinition</class-id> <category>accessing</category><body package="Monticello" selector="name">name	^name</body><body package="Monticello" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Monticello.MCSnapshot</class-id> <category>accessing</category><body package="Monticello" selector="classDefinitions">classDefinitions	^definitions select: [:each | each class = MCClassDefinition]</body><body package="Monticello" selector="definitions">definitions	^definitions</body><body package="Monticello" selector="definitions:">definitions: anObject	definitions := anObject</body><body package="Monticello" selector="methodDefinitions">methodDefinitions	^definitions select: [:each | each class = MCMethodDefinition]</body></methods><methods><class-id>Monticello.MCClassDefinition</class-id> <category>accessing</category><body package="Monticello" selector="category">category	^category</body><body package="Monticello" selector="category:">category: anObject	category := anObject</body><body package="Monticello" selector="classInstanceVariableDefinitions">classInstanceVariableDefinitions	^variables select: [:each | each class = MCClassInstanceVariableDefinition]</body><body package="Monticello" selector="comment">comment	^comment</body><body package="Monticello" selector="comment:">comment: anObject	comment := anObject</body><body package="Monticello" selector="commentStamp">commentStamp	^commentStamp</body><body package="Monticello" selector="commentStamp:">commentStamp: anObject	commentStamp := anObject</body><body package="Monticello" selector="instanceVariableDefinitions">instanceVariableDefinitions	^variables select: [:each | each class = MCInstanceVariableDefinition]</body><body package="Monticello" selector="name">name	^name</body><body package="Monticello" selector="name:">name: anObject	name := anObject</body><body package="Monticello" selector="sharedVariableDefinitions">sharedVariableDefinitions	^variables select: [:each | each class = MCClassVariableDefinition]</body><body package="Monticello" selector="superclassName">superclassName	^superclassName</body><body package="Monticello" selector="superclassName:">superclassName: anObject	superclassName := anObject</body><body package="Monticello" selector="type">type	^type</body><body package="Monticello" selector="type:">type: anObject	type := anObject</body><body package="Monticello" selector="unknownVariableDeclarations">unknownVariableDeclarations	^variables select: [:each | each class = Unknown]</body><body package="Monticello" selector="variables">variables	^variables</body><body package="Monticello" selector="variables:">variables: anObject	variables := anObject</body></methods><methods><class-id>Monticello.MCClassDefinition</class-id> <category>converting</category><body package="Monticello" selector="asStoreClassDefinition:">asStoreClassDefinition: package	| definition instanceVariables classInstanceVariables indexedType |	instanceVariables := self instanceVariableDefinitions inject: '' into: [:all :each | all, each name, ' '].	classInstanceVariables := self classInstanceVariableDefinitions inject: '' into: [:all :each | all, each name, ' '].	indexedType := nil.	type = #normal ifTrue: [indexedType := 'none'].	type = #variable ifTrue: [indexedType := 'objects'].	indexedType ifNil: [self halt].	definition :=package environment absoluteName, ' defineClass: #', name, '	superclass: #{', (package resolveFullClassName: superclassName), '}	indexedType: #', indexedType, '	private: false	instanceVariableNames: ', instanceVariables printString, '	classInstanceVariableNames: ', classInstanceVariables printString, '	imports: ''''	category: ', category printString.	^Store.Glorp.StoreClassDefinition new		name: name asString;		superclassName: (package resolveFullClassName: superclassName);		environmentName: package environment absoluteName;		definition: definition;		comment: comment;		timestamp: package timestamp;		username: package author;		yourself</body><body package="Monticello" selector="asStoreMetaclassDefinition:">asStoreMetaclassDefinition: package	^Store.Glorp.StoreClassDefinition new		name: name, ' class';		superclassName: (package resolveFullClassName: superclassName), ' class';		environmentName: package environment absoluteName;		definition: '';		timestamp: package timestamp;		username: package author;		yourself</body></methods><methods><class-id>Monticello.MCClassDefinition</class-id> <category>testing</category><body package="Monticello" selector="isLike:">isLike: aClassDefinition	(aClassDefinition name = name and: [aClassDefinition superclassName = superclassName and:		[aClassDefinition type = type and: [aClassDefinition category = category and:			[aClassDefinition comment = comment]]]]) ifFalse: [^false].	(self instanceVariableDefinitions allSatisfy: [:each | aClassDefinition instanceVariableDefinitions anySatisfy: [:ea | ea name = each name]]) ifFalse: [^false].	(self classInstanceVariableDefinitions allSatisfy: [:each | aClassDefinition classInstanceVariableDefinitions anySatisfy: [:ea | ea name = each name]]) ifFalse: [^false].	(self sharedVariableDefinitions allSatisfy: [:each | aClassDefinition sharedVariableDefinitions anySatisfy: [:ea | ea name = each name]]) ifFalse: [^false].	^true</body></methods><methods><class-id>Monticello.MCClassDefinition</class-id> <category>printing</category><body package="Monticello" selector="printOn:">printOn: aStream	aStream nextPutAll: self name</body></methods><methods><class-id>Monticello.DataStream</class-id> <category>reading</category><body package="Monticello" selector="readArray">readArray	| size array |	size := self privateNextNumber: 4.	array := Array new: size.	1 to: size do: [:i | array at: i put: self next].	^array</body><body package="Monticello" selector="readByteArray">readByteArray	^stream next: (self privateNextNumber: 4)</body><body package="Monticello" selector="readFalse">readFalse	^false</body><body package="Monticello" selector="readFloat">readFloat	| float |	float := Double new: 2.	float basicAt: 1 put: (self privateNextNumber: 4).	float basicAt: 2 put: (self privateNextNumber:  4).	^float</body><body package="Monticello" selector="readInstance">readInstance	| size instSize basicSize symbol class object |	size := (self privateNextNumber: 4) - 1.	symbol := self next asSymbol.	symbol = #OrderedCollection ifTrue: [^self readOrderedCollection].	class := self class environment at: symbol ifAbsent: [^self readUnknown: symbol size: size].	basicSize := size - class instSize.	instSize := size - basicSize.	object := class isVariable		ifTrue:	[class basicNew: basicSize]		ifFalse:	[class basicNew].	1 to: instSize do: [:i | object instVarAt: i put: self next].	1 to: basicSize do: [:i | object basicAt: i put: self next].	^object</body><body package="Monticello" selector="readInteger">readInteger	| integer |	integer := 0.	1 to: 4 do: [:i | integer := (integer bitShift: 8) + stream next].	^(integer bitAnd: 16r80000000) = 0		ifTrue:	[integer]		ifFalse:	[^-1 - (integer bitXor: 16rFFFFFFFF)]</body><body package="Monticello" selector="readNil">readNil	^nil</body><body package="Monticello" selector="readOrderedCollection">readOrderedCollection	" Squeak OrderedCollection is 'array, firstIndex, lastIndex', so we have to emulate that here "	| collection size |	stream next "Array's type byte, which is 8".	size := self privateNextNumber: 4.	collection := OrderedCollection basicNew: size.	1 to: size do: [:i | collection basicAt: i put: self next].	collection instVarAt: 1 put: self next.	collection instVarAt: 2 put: self next.	^collection</body><body package="Monticello" selector="readString">readString	| string size |	size := stream next.	size &gt;= 192 ifTrue:		[size := size - 192.		1 to: 3 do: [:ii | size := size * 256 + stream next]].	string := String new: size.	1 to: size do: [:i | string at: i put: stream next asCharacter].	^string</body><body package="Monticello" selector="readStringOld">readStringOld	| string size |	size := stream next.	size &gt;= 192 ifTrue: [size := (size - 192) * 256 + stream next].	string := String new: size.	1 to: size do: [:i | string at: i put: stream next asCharacter].	^string</body><body package="Monticello" selector="readSymbol">readSymbol	^self readString asSymbol</body><body package="Monticello" selector="readTrue">readTrue	^true</body><body package="Monticello" selector="readUnknown:size:">readUnknown: aSymbol size: aSize	| unknown |	unknown := Unknown basicNew: aSize.	unknown _name: aSymbol.	1 to: aSize do: [:i | unknown basicAt: i put: self next].	^unknown</body><body package="Monticello" selector="readWordLike">readWordLike	| symbol size object |	symbol := self next. "class name"	size := self privateNextNumber: 4.	"We only support WideString right now, which we do with String"	symbol = #WideString ifFalse:		[size do: [self privateNextNumber: 4].		^nil].	object := String new: size.	1 to: size do: [:index |		| byte |		byte := self privateNextNumber: 4.		byte &gt; SmallInteger maxVal ifTrue: [byte := 32].		object at: index put: byte asCharacter].	^object</body></methods><methods><class-id>Monticello.DataStream</class-id> <category>accessing</category><body package="Monticello" selector="contents">contents	^stream contents</body><body package="Monticello" selector="flush">flush	stream flush</body><body package="Monticello" selector="next">next	"Answer the next object in the receiver."	| type selector |	type := stream next.	selector := self readSelectors at: type.	^self perform: selector</body><body package="Monticello" selector="nextPut:">nextPut: anObject 	"Put the argument, anObject, at the next position in the receiver.	Answer anObject."	| type selector |	type := self typeFor: anObject.	stream nextPut: type.	selector := self writeSelectors at: type.	^self perform: selector with: anObject</body></methods><methods><class-id>Monticello.DataStream</class-id> <category>private</category><body package="Monticello" selector="privateNextNumber:">privateNextNumber: n	| integer |	integer := 0.	1 to: n do: [:i | integer := (integer bitShift: 8) bitOr: stream next asInteger].	^integer compressed</body><body package="Monticello" selector="privateNextNumber:put:">privateNextNumber: n put: anInteger	1 to: n do: [:i | stream nextPut: (anInteger digitAt: n + 1 - i)]</body><body package="Monticello" selector="readSelectors">readSelectors	^#(		readNil readTrue readFalse readInteger	"&lt;-4"		readStringOld readSymbol readByteArray		"&lt;-7"		readArray readInstance readReference nil	"&lt;-11"		nil nil readFloat nil nil 	"&lt;-16"		readString nil nil 	"&lt;-19"		readWordLike readMethod "&lt;-21"	)</body><body package="Monticello" selector="typeFor:">typeFor: anObject	^TypeMap at: anObject class ifAbsent: [9]</body><body package="Monticello" selector="writeSelectors">writeSelectors	^ #(		writeNil: writeTrue: writeFalse: writeInteger: 		nil writeSymbol: writeByteArray:		writeArray: writeInstance: nil nil		nil nil writeFloat: nil == "&lt;-16 short inst" 		writeString: nil nil		writeWordLike: writeInstance: "CompiledMethod"	)</body></methods><methods><class-id>Monticello.DataStream</class-id> <category>writing</category><body package="Monticello" selector="writeArray:">writeArray: anArray	self privateNextNumber: 4 put: anArray basicSize.	1 to: anArray basicSize do: [:i | self nextPut: (anArray basicAt: i)]</body><body package="Monticello" selector="writeByteArray:">writeByteArray: aByteArray	self privateNextNumber: 4 put: aByteArray size.	stream nextPutAll: aByteArray</body><body package="Monticello" selector="writeFalse:">writeFalse: aBoolean</body><body package="Monticello" selector="writeFloat:">writeFloat: aFloat	self privateNextNumber: 4 put: (aFloat asDouble basicAt: 1).	self privateNextNumber: 4 put: (aFloat asDouble basicAt: 2)</body><body package="Monticello" selector="writeInstance:">writeInstance: anObject	anObject class = OrderedCollection ifTrue: [^self writeOrderedCollection: anObject].	anObject class = Unknown ifTrue: [^self writeUnknown: anObject].	self privateNextNumber: 4 put: anObject class instSize + anObject basicSize + 1.	self nextPut: anObject class name.	1 to: anObject class instSize do: [:i | self nextPut: (anObject instVarAt: i)].	1 to: anObject basicSize do: [:i | self nextPut: (anObject basicAt: i)]</body><body package="Monticello" selector="writeInteger:">writeInteger: anInteger	| positive |	positive := anInteger &lt; 0		ifTrue:	[((0 - anInteger) bitXor: 16rFFFFFFFF) + 1]		ifFalse:	[anInteger].	1 to: 4 do: [:i | stream nextPut: (positive digitAt: 5 - i)]</body><body package="Monticello" selector="writeNil:">writeNil: theNil</body><body package="Monticello" selector="writeOrderedCollection:">writeOrderedCollection: anObject	" Squeak OrderedCollections are defined as 'array, firstIndex, lastIndex' "	self privateNextNumber: 4 put: 3 + 1.	self nextPut: anObject class name.	stream nextPut: (TypeMap at: Array).	self writeArray: anObject.	self nextPut: (anObject instVarAt: 1).	self nextPut: (anObject instVarAt: 2)</body><body package="Monticello" selector="writeString:">writeString: aString	| size |	(size := aString size) &lt; 192		ifTrue: [stream nextPut: size]		ifFalse:			[stream nextPut: (size digitAt: 4) + 192.			stream nextPut: (size digitAt: 3).			stream nextPut: (size digitAt: 2).			stream nextPut: (size digitAt: 1)].	aString do: [:each | stream nextPut: each asInteger]</body><body package="Monticello" selector="writeSymbol:">writeSymbol: aSymbol	self writeString: aSymbol</body><body package="Monticello" selector="writeTrue:">writeTrue: aBoolean</body><body package="Monticello" selector="writeUnknown:">writeUnknown: anObject	self privateNextNumber: 4 put: anObject basicSize + 1.	self nextPut: anObject _name.	1 to: anObject basicSize do: [:i | self nextPut: (anObject basicAt: i)]</body><body package="Monticello" selector="writeWordLike:">writeWordLike: aString	self writeSymbol: #WideString.	self privateNextNumber: 4 put: aString size.	1 to: aString size do: [:each | self privateNextNumber: 4 put: each asInteger]</body></methods><methods><class-id>Monticello.DataStream</class-id> <category>initialize-release</category><body package="Monticello" selector="on:">on: aStream	stream := aStream</body></methods><methods><class-id>Monticello.DataStream</class-id> <category>testing</category><body package="Monticello" selector="atEnd">atEnd	^stream atEnd</body><body package="Monticello" selector="isReadable">isReadable	^stream isReadable</body><body package="Monticello" selector="isWritable">isWritable	^stream isWritable</body></methods><methods><class-id>Monticello.DataStream class</class-id> <category>instance creation</category><body package="Monticello" selector="on:">on: aStream	^self basicNew on: aStream</body></methods><methods><class-id>Monticello.DataStream class</class-id> <category>private</category><body package="Monticello" selector="typeMap">typeMap	| map |	map := Dictionary new.	map at: UndefinedObject put: 1.	map at: True put: 2.	map at: False put: 3.	map at: SmallInteger put: 4.	map at: ByteSymbol put: 6.	map at: ByteArray put: 7.	map at: Array put: 8.	map at: Float put: 14.	map at: Double put: 14.	map at: ByteString put: 17.	^map</body></methods><methods><class-id>Monticello.Unknown</class-id> <category>accessing</category><body package="Monticello" selector="_instanceVariableNames">_instanceVariableNames	^instanceVariableNames</body><body package="Monticello" selector="_instanceVariableNames:">_instanceVariableNames: aCollection	instanceVariableNames := aCollection</body><body package="Monticello" selector="_name">_name	^name</body><body package="Monticello" selector="_name:">_name: aName	name := aName</body></methods><methods><class-id>Monticello.Unknown</class-id> <category>error handling</category><body package="Monticello" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	| index |	aMessage arguments isEmpty ifTrue:		[(index := instanceVariableNames indexOf: aMessage selector asString) = 0 ifTrue: [^super doesNotUnderstand: aMessage].		^self basicAt: index].	aMessage arguments size = 1 ifTrue:		[(index := instanceVariableNames indexOf: (aMessage selector allButLast: 1)) = 0 ifTrue: [^super doesNotUnderstand: aMessage].		^self basicAt: index put: aMessage arguments first].	^super doesNotUnderstand: aMessage</body></methods><methods><class-id>Monticello.MCRepository</class-id> <category>accessing</category><body package="Monticello" selector="names">names	^names</body><body package="Monticello" selector="packages">packages	^packages</body><body package="Monticello" selector="packagesNamed:">packagesNamed: aName	^packages select: [:each | each tail beginsWith: aName]</body><body package="Monticello" selector="url">url	^url</body></methods><methods><class-id>Monticello.MCRepository</class-id> <category>printing</category><body package="Monticello" selector="printOn:">printOn: aStream	aStream nextPutAll: url asString.	aStream space.	aStream nextPutAll: 'Packages: '.	aStream nextPutAll: packages size printString</body></methods><methods><class-id>Monticello.MCRepository</class-id> <category>initialize-release</category><body package="Monticello" selector="initialize:">initialize: aUrl	url := aUrl.	self refresh</body></methods><methods><class-id>Monticello.MCRepository</class-id> <category>api</category><body package="Monticello" selector="acquirePackagesList">acquirePackagesList	url protocol = 'http' ifTrue: [^self acquirePackagesListViaHTTP].	url protocol = 'file' ifTrue: [^self acquirePackagesListViaFILE].	self error: 'unsupport protocol'</body><body package="Monticello" selector="acquirePackagesListViaFILE">acquirePackagesListViaFILE	url asFilename exists ifFalse: [^self].	(url asFilename filenamesMatching: '*.mcz') do: [:each | packages add: url, each tail]</body><body package="Monticello" selector="acquirePackagesListViaHTTP">acquirePackagesListViaHTTP	| stream package |	stream := url resource stream.	[stream atEnd] whileFalse:		[stream upToAll: 'href='.		stream upTo: $".		package := stream upTo: $".		package := url, package asURI.		(package tail asLowercase endsWith: '.mcz') ifTrue: [packages add: package]].</body><body package="Monticello" selector="refresh">refresh	packages := SortedCollection sortBlock: [:a :b |		| versionA versionB nameA nameB |		nameA := a tail first: (a tail lastIndexOf: $-).		nameB := b tail first: (b tail lastIndexOf: $-).		versionA := (a tail tokensBasedOn: $.) reverse at: 2.		versionB := (b tail tokensBasedOn: $.) reverse at: 2.		nameA = nameB			ifTrue: [versionA asNumber &gt; versionB asNumber]			ifFalse: [nameA &lt; nameB]].	self acquirePackagesList.	names := Set new.	packages do: [:each |		| version name |		version := each tail allButLast: 4.		name := (version reverse readStream upTo: $-; upToEnd) reverse.		names add: name].	names := names asSortedCollection</body></methods><methods><class-id>Monticello.MCRepository class</class-id> <category>accessing</category><body package="Monticello" selector="at:">at: url	^Cache at: url asURI ifAbsentPut: [self new initialize: url asURI]</body><body package="Monticello" selector="hasRepository:">hasRepository: url	^Cache includesKey: url asURI</body><body package="Monticello" selector="removeRepository:">removeRepository: url	Cache removeKey: url asURI ifAbsent: []</body><body package="Monticello" selector="repositories">repositories	^Cache keys asSortedCollection: [:a :b | a tail &lt;= b tail]</body></methods><methods><class-id>Monticello.MCRepository class</class-id> <category>private</category><body package="Monticello" selector="defaultRepositories">defaultRepositories	'package-cache' asFilename exists ifFalse: ['package-cache' asFilename makeDirectory].	^Dictionary new		at: 'file:///./package-cache/' asURI put: (self new initialize: 'file:///./package-cache/' asURI);		yourself</body></methods><methods><class-id>Monticello.MCPackage</class-id> <category>accessing</category><body package="Monticello" selector="author">author	^author</body><body package="Monticello" selector="author:">author: anObject	author := anObject</body><body package="Monticello" selector="environment">environment	^environment</body><body package="Monticello" selector="filename">filename	^Filename fromComponents: (Array with: 'package-cache' with: url tail)</body><body package="Monticello" selector="metadata">metadata	^metadata</body><body package="Monticello" selector="metadata:">metadata: anObject	metadata := anObject</body><body package="Monticello" selector="name">name	^name</body><body package="Monticello" selector="name:">name: anObject	name := anObject</body><body package="Monticello" selector="snapshot">snapshot	^snapshot</body><body package="Monticello" selector="snapshot:">snapshot: anObject	snapshot := anObject</body><body package="Monticello" selector="timestamp">timestamp	^timestamp</body><body package="Monticello" selector="timestamp:">timestamp: anObject	timestamp := anObject</body><body package="Monticello" selector="url">url	^url</body><body package="Monticello" selector="url:">url: anObject	url := anObject</body><body package="Monticello" selector="version">version	^version</body><body package="Monticello" selector="version:">version: anObject	version := anObject</body></methods><methods><class-id>Monticello.MCPackage</class-id> <category>initialize-release</category><body package="Monticello" selector="collapse:">collapse: aDictionary	| collapsed value |	collapsed := Array new: aDictionary keys size * 2.	aDictionary keys asOrderedCollection keysAndValuesDo: [:i :key |		collapsed at: i * 2 - 1 put: key.		value := aDictionary at: key.		value class == Array ifTrue: [value := value collect: [:each | self collapse: each]].		value class == Dictionary ifTrue: [value := self collapse: value].		collapsed at: i * 2 put: value].	^collapsed</body><body package="Monticello" selector="expand:">expand: anArray	| expanded |	expanded := Dictionary new.	1 to: anArray size by: 2 do: [:i |		| key value |		key := anArray at: i.		value := anArray at: i + 1.		(value isKindOf: Array) ifTrue: [value := value collect: [:each | self expand: each]].		expanded at: key put: value].	^expanded</body><body package="Monticello" selector="initialize:">initialize: aUrl	url := aUrl.	self filename exists		ifTrue:	[self refresh: self filename]		ifFalse:	[self refresh]</body><body package="Monticello" selector="initializeEnvironment">initializeEnvironment	(Store.Registry packageNamed: name) ifNotNil: [:existing |		(existing properties at: #namespace ifAbsent: [nil]) ifNotNil: [:namespaceName |			(namespaceName asStrictReference valueOrDo: [nil]) ifNotNil: [:namespace |				^environment := namespace]]].	environment := (name readStream upTo: $-) asStrictReference valueOrDo: [Smalltalk].	environment isNameSpace ifFalse: [ environment := Smalltalk ]</body><body package="Monticello" selector="initializeMetadata:">initializeMetadata: archive	| entry contents |	entry := archive entries detect: [:each | each fileName = 'version'].	contents := entry contents asStringEncoding: #source.	metadata := self expand: (Compiler evaluate: ('#', contents))</body><body package="Monticello" selector="initializeName:">initializeName: archive	| entry contents array |	entry := archive entries detect: [:each | each fileName = 'package'].	contents := entry contents asStringEncoding: #source.	array := Compiler evaluate: ('#', contents).	name := array at: 2</body><body package="Monticello" selector="initializeSnapshot:">initializeSnapshot: archive	| entry |	entry := archive entries detect: [:each | each fileName = 'snapshot.bin'].	snapshot := (DataStream on: entry contents readStream) next</body><body package="Monticello" selector="refresh:">refresh: filename	| stream archive |	stream := filename readStream.	[archive := OS.Zip.Archive on: stream binary.	self initializeName: archive.	self initializeMetadata: archive.	self initializeSnapshot: archive]		ensure: [stream close].	self initializeEnvironment.	author := metadata at: #author.	version := (metadata at: #name) allButFirst: name size + author size + 2.	timestamp := Timestamp fromDate: (Date readFrom: (metadata at: #date) readStream) andTime: (Time readFrom: (metadata at: #time) readStream).</body></methods><methods><class-id>Monticello.MCPackage</class-id> <category>converting</category><body package="Monticello" selector="asStorePackage">asStorePackage	| package classDefinitions methodDefinitions sharedVariableDefinitions |	package := Store.Glorp.StorePackage new.	" Classes "	classDefinitions := snapshot classDefinitions collect: [:each |		Store.Glorp.StoreClassDefinitionInPackage new			package: package;			definition: (each asStoreClassDefinition: self);			metaclass: (each asStoreMetaclassDefinition: self)].	" Methods "	methodDefinitions := snapshot methodDefinitions collect: [:each |		Store.Glorp.StoreMethodInPackage new			package: package;			definition: (each asStoreMethod: self)].	" Class Shared Variables "	sharedVariableDefinitions := OrderedCollection new.	snapshot classDefinitions do: [:classDefinition |		sharedVariableDefinitions addAll: (classDefinition sharedVariableDefinitions collect: [:each |			Store.Glorp.StoreSharedVariableInPackage new				package: package;				definition: (each asStoreSharedVariable: self environmentName: (self resolveFullClassName: classDefinition name))])].	package name: name.	package version: version.	package timestamp: timestamp.	package username: author.	package classDefinitions addAll: classDefinitions.	package methodDefinitions addAll: methodDefinitions.	package sharedVariableDefinitions addAll: sharedVariableDefinitions.	package properties at: #id put: (metadata at: #id).	package properties at: #url put: url asString.	package properties at: #version put: version.	package properties at: #namespace put: environment name.	package properties at: #parcelName put: name.	^package</body></methods><methods><class-id>Monticello.MCPackage</class-id> <category>loading</category><body package="Monticello" selector="import">import	" Loads this version in to the image and reconciles against its ancestor in the database. "	| session ancestor |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	ancestor := self ancestorStorePackageIn: session.	self loadIn: session.	ancestor ifNil: [^self].	self reconcile: ancestor</body><body package="Monticello" selector="load">load	" Loads this code in to the image without any database links. "	self loadIn: Store.Glorp.StoreLoginFactory currentStoreSession</body><body package="Monticello" selector="merge">merge	" Merges this version in to the image. "	| session model existing |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	model := (Store.Registry packageNamed: name) ifNil: [^self load].	(existing := model asStorePundleEvenIfModifiedIn: session) ifNil: [^self load].	self loadIn: session.	self reconcile: existing</body><body package="Monticello" selector="refresh">refresh	| reading writing  |	'package-cache' asFilename exists ifFalse: ['package-cache' asFilename makeDirectory].	reading := url resource stream binary.	[writing := self filename writeStream binary.	writing nextPutAll: reading upToEnd]		ensure: [writing close. reading close].	self refresh: self filename</body></methods><methods><class-id>Monticello.MCPackage</class-id> <category>private</category><body package="Monticello" selector="ancestorStorePackageIn:">ancestorStorePackageIn: session	" Using the metadata's ancestor tree, find the newest ancestor that we have published in to the database. "	| ancestors ancestor ancestorName ancestorVersion query package |	ancestors := OrderedCollection with: metadata.	[ancestor := ancestors removeFirst.	ancestors addAll: (ancestor at: #ancestors ifAbsent: [#()]).	(ancestorName := ancestor at: #name ifAbsent: [nil]) ifNotNil:		[ancestorVersion := ancestorName copyFrom: (ancestorName lastIndexOf: $-) + 1 to: ancestorName size.		ancestorName := ancestorName allButLast: ancestorVersion size + 1.		query := Glorp.Query returningOneOf: Store.Glorp.StorePackage where: [:each | (each name = ancestorName) &amp; (each version like: '%', ancestorVersion, '%')].		query orderBy: [:each | each timestamp descending].		package := session execute: query.		package ifNotNil: [^package]].	ancestors notEmpty] whileTrue.	^nil</body><body package="Monticello" selector="applyGRPackage">applyGRPackage	" Monticello1 does not include comments or prerequisites as part of its metadata. To get around this, some projects add their own metadata.. Grease is the only one that has popped up of importance so far. "	| package wapackage dependencies vwName |	wapackage := (environment at: 'GRPackage' asSymbol ifAbsent: [^self]) packages		detect:	[:each | each name = name]		ifNone:	[^self].	package := Store.Registry packageNamed: name.	package comment: wapackage description.	dependencies := OrderedCollection new.	wapackage dependencies		do: [:each | dependencies add: each name.			(each name indexOf: $-  ifAbsent: [nil])				ifNotNil: [ :index | 						vwName := (each name copyFrom: 1 to: index),									'VisualWorks-',									(each name copyFrom: index + 1 to: each name size ).						(Store.Registry packageNamed: vwName) ifNotNil: [ :vwPackage | dependencies add: vwPackage name ]]			].	package propertyAt: #prerequisiteParcels put:		(package propertyAt: #prerequisiteParcels ifAbsent: [#()]), 		(dependencies collect: [:each | Array with: each  with: '']) asArray .	package propertyAt: #developmentPrerequisites put:		(package propertyAt: #developmentPrerequisites ifAbsent: [#()]),		( dependencies collect: [:each | Array with: #any with: each  with: '']) asArray</body><body package="Monticello" selector="applyNamespacePrerequisite">applyNamespacePrerequisite	"A package provides us with our namespace, so we need to make sure it's a prerequisite."	| package namespacePackage |	package := Store.Registry packageNamed: name.	namespacePackage := environment package.	package = namespacePackage ifTrue: [^self].	package propertyAt: #prerequisiteParcels put: (Array with: (Array with: namespacePackage name with: '')).	package propertyAt: #developmentPrerequisites put: (Array with: (Array with: #any with: namespacePackage name with: ''))</body><body package="Monticello" selector="loadIn:">loadIn: session	" Loads this code in to the image without any database links. "	self asStorePackage		session: session;		loadSource.	self applyNamespacePrerequisite.	self applyGRPackage</body><body package="Monticello" selector="reconcile:">reconcile: aStorePackage	(Store.Registry packageNamed: name) ifNotNil: [:model |		"If we have no copyright and our ancestor does, apply that to us"		model copyrightNotice ifNil: [model copyrightNotice: aStorePackage copyrightNotice].		model reconcileWithDb: aStorePackage]</body><body package="Monticello" selector="resolveFullClassName:">resolveFullClassName: className	| classDefinition |	classDefinition := snapshot classDefinitions detect: [:each | each name = className] ifNone: [nil].	^classDefinition		ifNil: [(environment at: className asSymbol ifAbsent: [SystemUtils undeclaredName: className]) absoluteName]		ifNotNil: [environment absoluteName, '.', classDefinition name]</body></methods><methods><class-id>Monticello.MCPackage</class-id> <category>saving</category><body package="Monticello" selector="writeArray:on:">writeArray: anArray on: aStream	aStream nextPutAll: '('.	anArray do: [:each |		each class == Array			ifTrue:	[self writeArray: each on: aStream]			ifFalse:				[each isSymbol					ifTrue:	[aStream nextPutAll: each]					ifFalse:	[aStream print: each]]]		separatedBy: [aStream space].	aStream nextPutAll: ')'</body><body package="Monticello" selector="writePackageOn:">writePackageOn: aStream	aStream		nextPutAll: '(name ';		nextPutAll: name printString;		nextPutAll: ')'</body><body package="Monticello" selector="writeSnapshotOn:">writeSnapshotOn: aStream	(DataStream on: aStream) nextPut: snapshot</body><body package="Monticello" selector="writeToDisk">writeToDisk	self writeToDisk: ((metadata at: #name), '.mcz') asFilename</body><body package="Monticello" selector="writeToDisk:">writeToDisk: aFilename	| stream |	stream := ('package' asFilename withEncoding: #source) writeStream.	[self writePackageOn: stream] ensure: [stream close].	stream := ('version' asFilename withEncoding: #source) writeStream.	[self writeVersionOn: stream] ensure: [stream close].	stream := 'snapshot.bin' asFilename writeStream binary.	[self writeSnapshotOn: stream] ensure: [stream close].	ExternalProcess shOne: 'zip "package-cache/', aFilename asString, '" package version snapshot.bin'.	'package' asFilename delete.	'version' asFilename delete.	'snapshot.bin' asFilename delete</body><body package="Monticello" selector="writeVersionOn:">writeVersionOn: aStream	self writeArray: (self collapse: metadata) on: aStream</body></methods><methods><class-id>Monticello.MCPackage</class-id> <category>printing</category><body package="Monticello" selector="printOn:">printOn: aStream	name ifNil: [^super printOn: aStream].	aStream nextPutAll: name.	aStream nextPutAll: ' ('.	aStream nextPutAll: self author.	aStream nextPutAll: '.'.	aStream nextPutAll: self version.	aStream nextPutAll: ')'</body></methods><methods><class-id>Monticello.MCPackage class</class-id> <category>accessing</category><body package="Monticello" selector="at:">at: url	^self new initialize: url asURI</body></methods><methods><class-id>Monticello.MCInstanceVariableDefinition</class-id> <category>accessing</category><body package="Monticello" selector="name">name	^name</body><body package="Monticello" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>converting</category><body package="Monticello" selector="asMCClassDefinition:">asMCClassDefinition: ancestorClasses	| stream classDefinition ancestor |	stream := String new writeStream.	TimestampPrintPolicy defaultInstance print: self timestamp on: stream using: (TimestampPrintPolicy formatTokensFor: 'm/d/yyyy hh:mm').	(classDefinition := Monticello.MCClassDefinition new)		comment: self comment;		name: self name asSymbol;		superclassName: (self superclassName tokensBasedOn: $.) last asSymbol;		category: self actual category;		variables:			(self actual instVarNames collect: [:each | Monticello.MCInstanceVariableDefinition new name: each]),			(self actual class instVarNames collect: [:each | Monticello.MCClassInstanceVariableDefinition new name: each]),			(self actual asNameSpace localBindings asOrderedCollection collect: [:each | Monticello.MCClassVariableDefinition new name: each key asString]);		type: #normal;		commentStamp: self username, ' ', stream contents.	('*indexedType: #objects*' match: self definition) ifTrue: [classDefinition type: #variable].	classDefinition variables: classDefinition variables asOrderedCollection.	ancestor := ancestorClasses detect: [:each | each isLike: classDefinition] ifNone: [nil].	ancestor ifNotNil:		[ | shares original |		classDefinition commentStamp: ancestor commentStamp.		" Squeak needs the shared variables ordered the same way as they were before "		shares := classDefinition sharedVariableDefinitions.		original := ancestor sharedVariableDefinitions collect: #name.		classDefinition variables removeAll: shares.		shares sort: [:a :b | (original indexOf: a name) &lt;= (original indexOf: b name)].		classDefinition variables addAll: shares.		" Add any pool definitions "		classDefinition variables addAll: ancestor unknownVariableDeclarations].	^classDefinition</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>converting</category><body package="Monticello" selector="asMCMethodDefinition:">asMCMethodDefinition: ancestorMethods	| stream definition ancestor |	stream := String new writeStream.	TimestampPrintPolicy defaultInstance print: self timestamp on: stream using: (TimestampPrintPolicy formatTokensFor: 'm/d/yyyy hh:mm').	(definition := Monticello.MCMethodDefinition new)		classIsMeta: self isMetaclass;		selector: self selector;		source: self source;		category: self protocol asSymbol;		className: (self className tokensBasedOn: $.) last asSymbol;		timeStamp: self username, ' ', stream contents.	ancestor := ancestorMethods detect: [:each | each isLike: definition] ifNone: [^definition].	definition timeStamp: ancestor timeStamp.	definition source: ancestor source.	^definition</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>converting</category><body package="Monticello" selector="asMCPackage:version:author:comment:">asMCPackage: anAncestor version: aVersion author: anAuthor comment: aComment	| package snapshot stream ancestorClasses ancestorMethods |	package := Monticello.MCPackage new.	package snapshot: (snapshot := Monticello.MCSnapshot new).	package name: self name.	package author: anAuthor.	package timestamp: Timestamp now.	package version: aVersion.	package metadata: Dictionary new.	package metadata		at: #author put: anAuthor;		at: #stepChildren put: #();		at: #message put: aComment;		at: #ancestors put: #();		at: #name put: (self name, '-', anAuthor, '.', aVersion);		at: #id put: UUID next printString.	stream := String new writeStream.	TimestampPrintPolicy defaultInstance print: package timestamp on: stream using: (TimestampPrintPolicy formatTokensFor: 'dd mmmm yyyy').	package metadata at: #date put: stream contents.	stream := String new writeStream.	TimestampPrintPolicy defaultInstance print: package timestamp on: stream using: (TimestampPrintPolicy formatTokensFor: 'hh:mm:ss am/pm').	package metadata at: #time put: stream contents.	snapshot definitions: OrderedCollection new.	ancestorClasses := #().	ancestorMethods := #().	anAncestor ifNotNil:		[snapshot definitions addAll: (anAncestor snapshot definitions select: [:each | each class == Monticello.Unknown]).		package metadata at: #ancestors put: (Array with: anAncestor metadata).		ancestorClasses := anAncestor snapshot classDefinitions.		ancestorMethods := anAncestor snapshot methodDefinitions].	snapshot definitions addAll: (methods collect: [:each | each definition asMCMethodDefinition: ancestorMethods]).	snapshot definitions addAll: (classDefinitions collect: [:each | each definition asMCClassDefinition: ancestorClasses]).	^package</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>StorePackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods classDefinitions fullClasses nameSpaces sharedVariables parcel binFile </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><class><name>StoreClassDefinition</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassName </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><class><name>StoreMethod</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version source className isMetaclass protocol comment selector </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>