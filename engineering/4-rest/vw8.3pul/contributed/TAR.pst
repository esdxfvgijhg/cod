<?xml version="1.0"?><st-source><!-- Name: TARNotice: Copyright 2002-2015 Cincom Systems, Inc.  All rights reserved.Comment: Provides TapeArchiver for unpacking tar archives.  Creating tar archives not yet implemented.  Also provides some convenience methods on Filename.DbIdentifier: bear73DbTrace: 472585DbUsername: nrossDbVersion: 8.2 - 2DevelopmentPrerequisites: #(#(#any 'StreamWritingExtensions' '') #(#any 'FileProgress' ''))PackageName: TARParcel: #('TAR')ParcelName: TARPrerequisiteParcels: #(#('StreamWritingExtensions' '') #('FileProgress' ''))PrintStringCache: (8.2 - 2,nross)Version: 8.2 - 2Date: 10:47:27 AM September 25, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (sep15.4) of September 25, 2015 on September 25, 2015 at 10:47:27 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TapeArchiver</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer dialogParentWindow errorPolicy fileAttributes incrementAspect overwritePolicy updateIncrement </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>System-Compression</category><attributes><package>TAR</package></attributes></class><comment><class-id>Tools.TapeArchiver</class-id><body>Implements unpacking tar archives.  Creatiion of tar archives not yet implemented.  Provides progress notification.  See protocol 'archiving' for api.Instance Variables	buffer	&lt;ByteArray&gt;	buffer used for copying files	dialogParentWindow	&lt;WindowOrNil&gt;	used to associate dialogs to the application window	errorPolicy	&lt;Symbol&gt;	#skipAll ignores unwritable files without raising dialog	fileAttributes	&lt;Dictionary&gt;	holds attributes from tar file record headers	incrementAspect	&lt;Symbol&gt;	aspect representing bytes decompressed or extracted	overwritePolicy	&lt;Symbol&gt;	determines when existing files are overwritten	updateIncrement	&lt;SmallInteger&gt;	threshold for forwarding incremental progress updates</body></comment><class><name>PolicyDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applyToAll message resultHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TAR</category><attributes><package>TAR</package></attributes></class><comment><class-id>Tools.PolicyDialog</class-id><body>Abstract class to present policy options to the user, providing the facility to apply the user's choice to the single case in question, or to all similar cases. Cancelling the dialog raises a signal that can be handled by client code. Subclasses should implement #setMessageFor: to set the user message, #windowSpec to provide buttons as needed, and action methods for the button behaviors. Instance Variables:	applyToAll	&lt;ValueModel&gt;	Boolean - tells whether to apply this answer to all existing files	message	&lt;ValueModel&gt;	String - the user prompt	resultHolder	&lt;ValueModel&gt;	SymbolOrNil - the user's choice, or nil for cancel</body></comment><class><name>FileExistsDialog</name><environment>Tools</environment><super>Tools.PolicyDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TAR</category><attributes><package>TAR</package></attributes></class><comment><class-id>Tools.FileExistsDialog</class-id><body>Presents options to overwrite existing files, overwrite only older files, or skip files that already exist.  The choice may be applied to the single file in question, or to all existing files.  Cancelling the dialog raises a signal that can be handled by client code.</body></comment><class><name>FileErrorDialog</name><environment>Tools</environment><super>Tools.PolicyDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TAR</category><attributes><package>TAR</package></attributes></class><comment><class-id>Tools.FileErrorDialog</class-id><body>Presents options to retry failed write attempts or skip.  The choice may be applied to the single file in question, or to all existing files.  Cancelling the dialog raises a signal that can be handled by client code.</body></comment><class><name>UserAbort</name><environment>Tools</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TAR</category><attributes><package>TAR</package></attributes></class><comment><class-id>Tools.UserAbort</class-id><body>Raised when the user cancels the tar extraction in response to FileExistsDialog.</body></comment><shared-variable><name>TARBlockSize</name><environment>Tools.TapeArchiver</environment><private>false</private><constant>false</constant><category>TAR constants</category><initializer>512</initializer><attributes><package>TAR</package></attributes></shared-variable><methods><class-id>Tools.TapeArchiver</class-id> <category>accessing - file attributes</category><body package="TAR">canonicalizedFileString	^self fileAttributes at: #filenameStringCanonicalized</body><body package="TAR">canonicalizedLinkString	^self fileAttributes at: #linknameStringCanonicalized</body><body package="TAR">fileMode	^self fileAttributes at: #fileMode</body><body package="TAR">filePermissions	^self fileAttributes at: #permissions</body><body package="TAR">fileSize	^self fileAttributes at: #size</body><body package="TAR">fileTypeFlag	^self fileAttributes at: #fileType ifAbsent: []</body><body package="TAR">filename	^self fileAttributes at: #targetFile</body><body package="TAR">modTime	^self fileAttributes at: #modTime</body><body package="TAR">resetFileAttributes	^fileAttributes := Dictionary new</body><body package="TAR">setFileMode: aString 	self fileAttributes at: #fileMode put: aString</body><body package="TAR">setFilePermissions: aString 	self fileAttributes at: #permissions put: aString</body><body package="TAR">setFileSize: anInteger 	self fileAttributes at: #size put: anInteger</body><body package="TAR">setFileTypeFlag: aCharacter	self fileAttributes at: #fileType put: aCharacter</body><body package="TAR">setFilename: aFilename 	self fileAttributes at: #targetFile put: aFilename</body><body package="TAR">setFilenameStringCanonicalized: aString 	self fileAttributes at: #filenameStringCanonicalized		put: (self portUnixFileString: aString)</body><body package="TAR">setLinknameStringCanonicalized: aString 	self fileAttributes at: #linknameStringCanonicalized		put: (self portUnixFileString: aString)</body><body package="TAR">setModTime: aTimestamp 	self fileAttributes at: #modTime put: aTimestamp</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>testing</category><body package="TAR">existingFileIsNewer	^self modTime &lt; (Timestamp fromArray: (self filename dates at: #modified))</body><body package="TAR">fileIsDirectory	^self fileTypeFlag = $5</body><body package="TAR">fileIsLink	^'12' includes: self fileTypeFlag</body><body package="TAR">foundLongLink	^'*@LongLink' match: self canonicalizedFileString</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>accessing</category><body package="TAR">buffer	^buffer ifNil: [buffer := ByteArray new: TARBlockSize]</body><body package="TAR">dialogParentWindow: aWindowOrNil 	dialogParentWindow := aWindowOrNil</body><body package="TAR">errorPolicy	^errorPolicy</body><body package="TAR">errorPolicy: aSymbolOrNil 	(aSymbolOrNil isNil or: [#skipAll = aSymbolOrNil]) 		ifFalse: 			[^self error: #inappropriateErrorPolicy &lt;&lt; #dialogs 						&gt;&gt; 'inappropriate error policy'].	errorPolicy := aSymbolOrNil</body><body package="TAR">fileAttributes	^fileAttributes ifNil: [self resetFileAttributes]</body><body package="TAR">overwritePolicy	^overwritePolicy</body><body package="TAR">overwritePolicy: aSymbolOrNil 	(aSymbolOrNil isNil 		or: [#(#overwriteAll #skipAll #updateAll) includes: aSymbolOrNil]) 			ifFalse: 				[^self error: #inappropriateOverwritePolicy &lt;&lt; #dialogs 							&gt;&gt; 'inappropriate overwrite policy'].	overwritePolicy := aSymbolOrNil</body><body package="TAR">updateIncrement	^updateIncrement ifNil: [updateIncrement := 0]</body><body package="TAR">updateIncrement: anInteger	updateIncrement := anInteger</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>archiving-private</category><body package="TAR">copyLinkFrom: aStringOrFilename	| source |	source := aStringOrFilename asFilename.	(self fileTypeFlag = $2 and: [source isRelative])		ifTrue: [source := self filename directory construct: aStringOrFilename].	(source exists and: [source isDirectory not])		ifFalse: 			[^self createFile: self filename fromLink: self canonicalizedLinkString].		[self filename directory ensureDirectoryNotifying: self.	source copyTo: self filename reportProgressTo: self]			on: OsError			do: 				[:ex |				ex class = OsInaccessibleError					ifTrue: 						[(						[self filename makeWritable.						self filename isWritable] on: Error								do: [:error | false]) ifTrue: [ex retry] ifFalse: [ex pass]].				^self changed: #untarLinkFailure with: self canonicalizedLinkString].	self preserveFilePermissions</body><body package="TAR">createFile: aFilename fromLink: linkFile 	| stream |	aFilename directory ensureDirectoryNotifying: self.	stream := aFilename writeStream.	[stream nextPutAll: linkFile asString] ensure: [stream close].	self preserveFilePermissions</body><body package="TAR">preserveFilePermissions	| permissionsString permissions |		[permissionsString := self filePermissions.	permissions := Integer readFrom: permissionsString readStream radix: 8.	self filename setProtection: permissions] 			on: MessageNotUnderstood			do: [:ex | ex return]</body><body package="TAR">processLongLinkFrom: tarStream 	| filenameString writeStream |	writeStream := ByteArray new writeStream.	tarStream 		writeNext: self fileSize		on: writeStream		using: self buffer.	tarStream padTo: TARBlockSize.	filenameString := (writeStream contents readStream upTo: 0) asString.	self		readFileAttributesFrom: tarStream;		setFilenameStringCanonicalized: filenameString</body><body package="TAR">readStreamFrom: tarStream forTextFile: aFilename 	"Read the entire text file into a byteArray.  Change all line ends to cr, then to the appropriate line end for the current platform."	| bytes |	bytes := ByteArray new: self fileSize.	tarStream 		writeNext: bytes size		on: bytes writeStream		using: self buffer		notificationIncrement: self updateIncrement.	bytes := bytes copyReplaceAll: #[13 10] with: #[13].	bytes replaceAll: 10 with: 13.	IOAccessor defaultLineEndConvention = LineEndCRLF 		ifTrue: [^(bytes copyReplaceAll: #[13] with: #[13 10]) readStream].	IOAccessor defaultLineEndConvention = LineEndLF 		ifTrue: [^(bytes replaceAll: 13 with: 10) readStream].	^bytes readStream</body><body package="TAR">retryUntar: aFilename onWriteError: anException 	| newPolicy |	anException class = OsInaccessibleError 		ifTrue: 			[(			[aFilename makeWritable.			aFilename isWritable] on: Error					do: [:ex | false]) ifTrue: [^true]].	self errorPolicy = #skipAll ifTrue: [^false].	newPolicy := self fileErrorDialog: anException.	newPolicy = #skipAll ifTrue: [self errorPolicy: newPolicy].	^newPolicy = #retry</body><body package="TAR">skipExistingTarget	| newPolicy |	self overwritePolicy = #overwriteAll ifTrue: [^false].	self filename exists ifFalse: [^false].	self overwritePolicy = #skipAll ifTrue: [^true].	self overwritePolicy = #updateAll ifTrue: [^self existingFileIsNewer].	newPolicy := self fileExistsDialog.	('*All' match: newPolicy) 		ifTrue: 			[self overwritePolicy: newPolicy.			^self skipExistingTarget].	newPolicy = #update ifTrue: [^self existingFileIsNewer].	^newPolicy = #skip</body><body package="TAR">skipNextFileOn: tarStream 	| fileBytes bytesLeft updateInc |	fileBytes := bytesLeft := self fileSize.	updateInc := self updateIncrement.	updateInc isZero ifTrue: [updateInc := fileBytes].	(fileBytes / updateInc) ceiling timesRepeat: 			[| incBytes |			incBytes := updateInc min: bytesLeft.			tarStream skip: incBytes.			bytesLeft := bytesLeft - incBytes.			self changed: incrementAspect with: incBytes].	tarStream padTo: TARBlockSize</body><body package="TAR">untarFileContentsFrom: tarStream toFile: aFilename 	| writeStream |	aFilename directory ensureDirectoryNotifying: self.	writeStream := [(aFilename withEncoding: #binary) writeStream] on: Error				do: 					[:ex | 					(self retryUntar: aFilename onWriteError: ex) 						ifTrue: [ex retry]						ifFalse: [#untarWriteError]].	writeStream = #untarWriteError 		ifTrue: 			[self skipNextFileOn: tarStream.			^false].		[aFilename hasTextExtension 		ifTrue: 			[(self readStreamFrom: tarStream forTextFile: aFilename)				addDependent: self;				writeAllOn: writeStream					using: self buffer					notificationIncrement: self updateIncrement;				removeDependent: self]		ifFalse: 			[tarStream 				writeNext: self fileSize				on: writeStream				using: self buffer				notificationIncrement: self updateIncrement]] 			ensure: [writeStream close].	tarStream padTo: TARBlockSize.	^true</body><body package="TAR">untarLinkTo: aDirectory	| linkTarget |	self filename directory ensureDirectoryNotifying: self.	linkTarget := self canonicalizedLinkString.		[self fileTypeFlag = $2 ifTrue: [^self filename linkSymbolicTo: linkTarget].	linkTarget asFilename isRelative		ifTrue: [linkTarget := aDirectory asFilename construct: linkTarget asString].	self filename hardLinkTo: linkTarget.	self changed: incrementAspect with: self fileSize]			on: OsError			do: [:ex | ex return: (self copyLinkFrom: linkTarget)]</body><body package="TAR">untarNextFileFrom: tarStream to: aDirectory 	| target |	self readFileAttributesFrom: tarStream.	self fileAttributes isEmpty ifTrue: [^self].	self foundLongLink ifTrue: [self processLongLinkFrom: tarStream].	target := aDirectory construct: self canonicalizedFileString.	self setFilename: target.	self fileIsDirectory ifTrue: [^target ensureDirectoryNotifying: self].	self skipExistingTarget ifTrue: [^self skipNextFileOn: tarStream].	self fileIsLink ifTrue: [^self untarLinkTo: aDirectory].	self changed: #untarFile with: target asString.	self changed: #untarFileInitialize with: self fileSize.	(self untarFileContentsFrom: tarStream toFile: target) ifFalse: [^self].	self preserveFilePermissions.	self changed: #untarFileComplete with: self fileAttributes</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>parsing</category><body package="TAR">readFileAttributesFrom: tarStream 	| bufferReadStream |	self resetFileAttributes.	(tarStream 		nextAvailable: TARBlockSize		into: self buffer		startingAt: 1) &lt; TARBlockSize 		ifTrue: [self error: (#TARPaddingError &lt;&lt; #installer &gt;&gt; 'TAR padding error')].	self buffer first = 0 ifTrue: [^self].	bufferReadStream := self buffer readStream.	self		readFilenameFrom: bufferReadStream;		readFileModeFrom: bufferReadStream;		readPermissionsFrom: bufferReadStream;		readSizeFrom: bufferReadStream;		readModTimeFrom: bufferReadStream;		readTypeFlagFrom: bufferReadStream.	self fileIsLink ifTrue:		[self readLinknameFrom: bufferReadStream]</body><body package="TAR">readFileModeFrom: readStream 	readStream position: 100.	self setFileMode: (readStream next: 8) asString</body><body package="TAR">readFilenameFrom: readStream	"There are 3 cases:		Filenames with size &lt; 100 -- the filename string is null-terminated		Filenames with size = 100 -- the filename string uses the entire space and is not null terminated, so searching for the null byte ends up appending garbage to the string which we must then truncate		Filenames with size &gt; 100 -- apparently if the header has its 'long file name' bit set, the long filename is the first part of the file body and there is no issue with that one being null terminated or not."	| filenameString |	readStream position: 0.	filenameString := (readStream upTo: 0) asString. 	filenameString size &gt; 100		ifTrue: [filenameString := filenameString copyFrom: 1 to: 100].	self setFilenameStringCanonicalized: filenameString</body><body package="TAR">readLinknameFrom: readStream 	| filenameString |	readStream position: 157.	filenameString := (readStream upTo: 0) asString.	self setLinknameStringCanonicalized: filenameString</body><body package="TAR">readModTimeFrom: readStream	"On some linux / unix systems, the OS timezone facilities cannot accept a negative seconds offset:  Jan 1st 1970 00:00:00 is the earliest timstamp that can be handled.  When untarring a long-link-tarred file, the seconds offset is briefly zero while the placeholder is awaiting processing in #processLongLinkFrom:.  The local timestamp is OK in GMT and timezones to its east but is a Dec 31st 1969 pm timestamp in more westerly ones, therefore the conversion to local timestamp fails on these systems in a western timezone.  To avoid that, we pass the unconverted universal timestamp as the placeholder in that case."	| seconds universalTimestamp |	readStream position: 136.	seconds := Integer readFrom: (readStream next: 11) asString readStream radix: 8.	universalTimestamp := TimeZone default secondsToTimestamp: self tarSecondsOffset + seconds.	self setModTime:		(seconds isZero			ifTrue: [universalTimestamp]			ifFalse: [TimeZone default universalToLocal: universalTimestamp]).</body><body package="TAR">readPermissionsFrom: readStream	"The last 3 bytes of the File Mode field"	readStream position: 104.	self setFilePermissions: (readStream next: 3) asString</body><body package="TAR">readSizeFrom: readStream 	| sizeStream nextChar |	readStream position: 124.	sizeStream := String new writeStream.	[(nextChar := Character value: readStream next) isDigit] 		whileTrue: [sizeStream nextPut: nextChar].	self setFileSize: (Integer readFrom: sizeStream contents readStream				radix: 8)</body><body package="TAR">readTypeFlagFrom: readStream 	readStream position: 156.	self setFileTypeFlag: (Character value: readStream next)</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>constants</category><body package="TAR">tarSecondsOffset	"Answer the difference in seconds from the Unix reference date (1 Jan 1970 00:00:00) to the VisualWorks reference date (1 Jan 1901 00:00:00)."	"(Timestamp fromDate: (Date 				newDay: 1				monthNumber: 1				year: 1970)		andTime: (Time fromSeconds: 0)) asSeconds 		- (Timestamp new fromDate: (Date 						newDay: 1						monthNumber: 1						year: 1901)				andTime: (Time fromSeconds: 0)) asSeconds"	^2177452800</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>archiving</category><body package="TAR">untarArchive: tarFile 	self untarArchive: tarFile to: tarFile directory</body><body package="TAR">untarArchive: tarFile to: aDirectory 	self 		untarArchive: tarFile		to: aDirectory		notifying: nil</body><body package="TAR">untarArchive: tarFile to: aDirectory notifying: anObject 		[| tarStream |	self addDependent: anObject.	self changed: #untarArchive with: tarFile.	self changed: #untarArchiveInitialize with: tarFile fileSize.	tarStream := (tarFile withEncoding: #binary) readStream.	[self untarStream: tarStream to: aDirectory] 		ensure: [tarStream close].	self changed: #untarArchiveComplete] 			ensure: [self removeDependent: anObject]</body><body package="TAR">untarStream: tarStream to: aDirectory 	self 		untarStream: tarStream		to: aDirectory		notifying: nil</body><body package="TAR">untarStream: tarStream to: aDirectory notifying: anObject 	incrementAspect := #untarIncrement.		[tarStream addDependent: self.	self addDependent: anObject.	[tarStream atEnd] 		whileFalse: [self untarNextFileFrom: tarStream to: aDirectory]] 			ensure: 				[tarStream removeDependent: self.				self removeDependent: anObject]</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>utils</category><body package="TAR">portUnixFileString: aString 	| fileComponents |	fileComponents := (UnixFilename components: aString asString) 				copyWithout: '.'.	Filename separator = $: 		ifTrue: [fileComponents := fileComponents copy replaceAll: '..' with: ':'].	^(Filename fromComponents: fileComponents) asString</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>updating</category><body package="TAR">update: anAspect with: aParameter 	(#(#increment #bytesCopied) includes: anAspect) 		ifTrue: [^self changed: incrementAspect with: aParameter].	anAspect == #directoryCreated 		ifTrue: [^self changed: anAspect with: aParameter]</body></methods><methods><class-id>Tools.TapeArchiver</class-id> <category>dialogs</category><body package="TAR">fileErrorDialog: anException 	^([Tools.FileErrorDialog for: anException] 		uiEventNowFor: dialogParentWindow) 			ifNil: [UserAbort signalWith: self filename]</body><body package="TAR">fileExistsDialog	^([Tools.FileExistsDialog for: self filename] 		uiEventNowFor: dialogParentWindow) 			ifNil: [UserAbort signalWith: self filename]</body></methods><methods><class-id>Tools.TapeArchiver class</class-id> <category>documentation</category><body package="TAR">tarFileFormat	"`tar' Header Block, from POSIX 1003.1-1990.	POSIX header.	struct posix_header	{                               /* byte offset */	  char name[100];               /*   0 */	  char mode[8];                 /* 100 */	  char uid[8];                  /* 108 */	  char gid[8];                  /* 116 */	  char size[12];                /* 124 */	  char mtime[12];               /* 136 */	  char chksum[8];               /* 148 */	  char typeflag;                /* 156 */	  char linkname[100];           /* 157 */	  char magic[6];                /* 257 */	  char version[2];              /* 263 */	  char uname[32];               /* 265 */	  char gname[32];               /* 297 */	  char devmajor[8];             /* 329 */	  char devminor[8];             /* 337 */	  char prefix[155];             /* 345 */	                                /* 500 */	};		#define TMAGIC   ''ustar''        /* ustar and a null */	#define TMAGLEN  6	#define TVERSION ''00''           /* 00 and no null */	#define TVERSLEN 2		/* Values used in typeflag field.  */	#define REGTYPE  '0'            /* regular file */	#define AREGTYPE '\0'           /* regular file */	#define LNKTYPE  '1'            /* link */	#define SYMTYPE  '2'            /* reserved */	#define CHRTYPE  '3'            /* character special */	#define BLKTYPE  '4'            /* block special */	#define DIRTYPE  '5'            /* directory */	#define FIFOTYPE '6'            /* FIFO special */	#define CONTTYPE '7'            /* reserved */		/* Bits used in the mode field, values in octal.  */	#define TSUID    04000          /* set UID on execution */	#define TSGID    02000          /* set GID on execution */	#define TSVTX    01000          /* reserved file permissions */	#define TUREAD   00400          /* read by owner */	#define TUWRITE  00200          /* write by owner */	#define TUEXEC   00100          /* execute/search by owner */	#define TGREAD   00040          /* read by group */	#define TGWRITE  00020          /* write by group */	#define TGEXEC   00010          /* execute/search by group */	#define TOREAD   00004          /* read by other */	#define TOWRITE  00002          /* write by other */	#define TOEXEC   00001          /* execute/search by other */""16r0000 = filename16r0200 = next filename (or start of file contents)16r0264 = 	0040755 755 is file perms rwxr-xr-x, 0040 is dir			0100444 444 is file perms r--r--r--, 0100 is fileperms			size		date0040755	17				7541443	127	011006	5	bin0040755	17				7541443	161	011601	5	bin/win0100444	17	0130406	7513714	143	013537	0	bin/win/herald.bmp0100644	17	1170340	7513714	143	013562	0	.wav0100644	17	8r0130406	7513714	143	014067	0	heraldcs.bmp0100644	17	0401000	7513714	144	014440	0	linkmaster.dll0100644	17	0012600	7541443	131	013570	0	readme.txt0100555	17	2170000	8r7513714	145	013607	0	visual.exe				8r255134files padded to 16r200 bytes"	^self commentOnly</body></methods><methods><class-id>Tools.PolicyDialog</class-id> <category>initialize-release</category><body package="TAR">resultHolder: aValueHolder 	resultHolder := aValueHolder</body><body package="TAR">setMessageFor: anObject 	self subclassResponsibility</body></methods><methods><class-id>Tools.PolicyDialog</class-id> <category>aspects</category><body package="TAR">applyToAll	^applyToAll ifNil: [applyToAll := false asValue]</body><body package="TAR">message	^message ifNil: [message := String new asValue]</body><body package="TAR">resultHolder	^resultHolder ifNil: [resultHolder := ValueHolder new]</body></methods><methods><class-id>Tools.PolicyDialog class</class-id> <category>interface opening</category><body package="TAR">for: anObject 	| model |	model := ValueHolder new.	^(self for: anObject model: model) ifTrue: [model value]</body><body package="TAR">for: anObject model: aValueHolder 	^self openOn: ((self new)				setMessageFor: anObject;				resultHolder: aValueHolder;				yourself)</body></methods><methods><class-id>Tools.FileExistsDialog</class-id> <category>actions</category><body package="TAR">overwrite	self resultHolder 		value: (self applyToAll value ifTrue: [#overwriteAll] ifFalse: [#overwrite]).	self accept value: true</body><body package="TAR">skip	self resultHolder 		value: (self applyToAll value ifTrue: [#skipAll] ifFalse: [#skip]).	self accept value: true</body><body package="TAR">update	self resultHolder 		value: (self applyToAll value ifTrue: [#updateAll] ifFalse: [#update]).	self accept value: true</body></methods><methods><class-id>Tools.FileExistsDialog</class-id> <category>initialize-release</category><body package="TAR">setMessageFor: aFilenameOrString 	self message 		value: (#fileExistsWhatToDo &lt;&lt; #dialogs 				&gt;&gt; 'The following file already exists.  What action should be taken?&lt;nt&gt;&lt;1s&gt;' 					expandMacrosWith: aFilenameOrString)</body></methods><methods><class-id>Tools.FileErrorDialog</class-id> <category>actions</category><body package="TAR">retry	self resultHolder value: #retry.	self accept value: true</body><body package="TAR">skip	self resultHolder 		value: (self applyToAll value ifTrue: [#skipAll] ifFalse: [#skip]).	self accept value: true</body></methods><methods><class-id>Tools.FileErrorDialog</class-id> <category>initialize-release</category><body package="TAR">setMessageFor: anException 	self message 		value: (#fileErrorWhatToDo &lt;&lt; #dialogs 				&gt;&gt; 'The following error was encountered.  What action should be taken?&lt;nt&gt;&lt;1s&gt;' 					expandMacrosWith: anException messageText)</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>file utilities</category><body package="TAR">hardLinkTo: aStringOrFilename 	UnixProcess 		shOne: ('ln "&lt;1s&gt;" "&lt;2s&gt;"' expandMacrosWith: aStringOrFilename with: self)</body><body package="TAR">linkSymbolicTo: aStringOrFilename 	UnixProcess 		shOne: ('ln -s "&lt;1s&gt;" "&lt;2s&gt;"' expandMacrosWith: aStringOrFilename				with: self)</body></methods><methods><class-id>OS.Filename class</class-id> <category>utilities</category><body package="TAR">isTextExtension: aString 	^#('.htm' '.html' '.inc' '.ini' '.ssp' '.st' '.tld' '.txt') 		includes: aString</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="TAR">ensureDirectoryNotifying: anObject	"This method will make sure that the receiver is currently realized as a path of existing directories. That is, it will create the filesystem directory if need be, after having made sure that my parent directory exists and making it if necessary, and the same for his parent directory, so on and up the tree.	 If any directory path must be created in this loop, notify the named object of the creation."	| myParent |	self exists ifTrue: [^self].	myParent := self directory.	"Avoid looping on non-existent root directories, such as absent removable media."	myParent = self ifTrue: [^self].	myParent ensureDirectoryNotifying: anObject.	self makeDirectory.	anObject update: #directoryCreated with: self.</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="TAR">hasTextExtension	^self class isTextExtension: self extension</body></methods><methods><class-id>OS.Filename</class-id> <category>archiving</category><body package="TAR">untar	self untarTo: self directory</body><body package="TAR">untarTo: aDirectory 	self untarTo: aDirectory notifying: nil</body><body package="TAR">untarTo: aDirectory notifying: anObject 	Tools.TapeArchiver new 		untarArchive: self		to: aDirectory		notifying: anObject</body></methods><methods><class-id>OS.PCFilename</class-id> <category>file utilities</category><body package="TAR">hardLinkTo: aStringOrFilename	"Windows does not understand links.  Raise an exception which will cause a copy operation."	OsIllegalOperation raiseSignal</body><body package="TAR">linkSymbolicTo: aStringOrFilename 	"Windows does not understand links.  Raise an exception which will cause a copy operation."	OsIllegalOperation raiseSignal</body></methods><methods><class-id>Tools.PolicyDialog class</class-id> <category>interface specs</category><body package="TAR">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 480 150 ) 			#bounds: #(#{Graphics.Rectangle} 2140 459 2620 639 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -80 1 ) 					#name: #message 					#flags: 4 					#model: #message 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -10 1 0 1 ) 					#name: #applyToAll 					#model: #applyToAll 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #rememberAnswerHelp 						#defaultString: 'Remember this answer and do not ask again.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #useThisAnswerForAll 						#defaultString: 'Use this answer for all' 						#catalogID: #dialogs ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -120 1 -35 1 -10 1 -10 1 ) 					#name: #cancel 					#model: #cancel 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #abortCurrentOperationHelp 						#defaultString: 'Abort the current operation.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #abortCurrentOperation 						#defaultString: 'Cancel' 						#catalogID: #dialogs ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.FileExistsDialog class</class-id> <category>interface specs</category><body package="TAR">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #fileExists 				#defaultString: 'File exists...' 				#catalogID: #dialogs ) 			#min: #(#{Core.Point} 480 150 ) 			#bounds: #(#{Graphics.Rectangle} 840 416 1320 596 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -80 1 ) 					#name: #message 					#flags: 4 					#model: #message 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -55 0.25 -70 1 55 0.25 -45 1 ) 					#name: #overwrite 					#model: #overwrite 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #overwriteHelp 						#defaultString: 'Overwrite the existing file.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #overwrite 						#defaultString: 'Overwrite' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -55 0.5 -70 1 55 0.5 -45 1 ) 					#name: #update 					#model: #update 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #updateIfOlderHelp 						#defaultString: 'Overwrite only older existing file.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #updateIfOlder 						#defaultString: 'Update' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -55 0.75 -70 1 55 0.75 -45 1 ) 					#name: #skip 					#model: #skip 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #skipFileHelp 						#defaultString: 'Do not overwrite the existing file.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #skipFile 						#defaultString: 'Skip' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -10 1 0 1 ) 					#name: #applyToAll 					#model: #applyToAll 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #rememberAnswerHelp 						#defaultString: 'Remember this answer and do not ask again.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #useForAll 						#defaultString: 'Use this answer for all existing files' 						#catalogID: #dialogs ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -120 1 -35 1 -10 1 -10 1 ) 					#name: #cancel 					#model: #cancel 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #abortCurrentOperationHelp 						#defaultString: 'Abort the current operation.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #abortCurrentOperation 						#defaultString: 'Cancel' 						#catalogID: #dialogs ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.FileErrorDialog class</class-id> <category>interface specs</category><body package="TAR">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #fileExists 				#defaultString: 'File exists...' 				#catalogID: #dialogs ) 			#min: #(#{Core.Point} 480 150 ) 			#bounds: #(#{Graphics.Rectangle} 823 779 1303 959 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -80 1 ) 					#name: #message 					#flags: 4 					#model: #message 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -55 0.333333 -70 1 55 0.333333 -45 1 ) 					#name: #retry 					#model: #retry 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #updateIfOlderHelp 						#defaultString: 'Overwrite only older existing file.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Retry 						#defaultString: 'Retry' 						#catalogID: #installer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -55 0.666666 -70 1 55 0.666666 -45 1 ) 					#name: #skip 					#model: #skip 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #skipFileHelp 						#defaultString: 'Do not overwrite the existing file.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #skipFile 						#defaultString: 'Skip' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -10 1 0 1 ) 					#name: #applyToAll 					#model: #applyToAll 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #rememberAnswerHelp 						#defaultString: 'Remember this answer and do not ask again.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #useForAll 						#defaultString: 'Use this answer for all existing files' 						#catalogID: #dialogs ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -120 1 -35 1 -10 1 -10 1 ) 					#name: #cancel 					#model: #cancel 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #abortCurrentOperationHelp 						#defaultString: 'Abort the current operation.' 						#catalogID: #dialogs ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #abortCurrentOperation 						#defaultString: 'Cancel' 						#catalogID: #dialogs ) 					#defaultable: true ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>PCFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>UnixFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>