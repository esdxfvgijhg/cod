<?xml version="1.0"?><st-source><!-- Name: OpenGL-WindowsNotice: Copyright (c) 2007-2008 Michael Lucas-SmithPermission is hereby granted, free of charge, to any personobtaining a copy of this software and associated documentationfiles (the "Software"), to deal in the Software withoutrestriction, including without limitation the rights to use,copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom theSoftware is furnished to do so, subject to the followingconditions:The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIESOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE ANDNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHTHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISINGFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OROTHER DEALINGS IN THE SOFTWARE.Comment: OpenGL - Cross Platform 3D Graphics. This package provides the interface to run OpenGL on Windows.DbIdentifier: bear73DbTrace: 460428DbUsername: ablakeyDbVersion: 3.0 25DevelopmentPrerequisites: #(#(#any 'DLLCC' '') #(#any 'OpenGL' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #()Namespace: Smalltalk.WGLPackageName: OpenGL-WindowsParcel: #('OpenGL-Windows')ParcelName: OpenGL-WindowsPrerequisiteParcels: #(#('DLLCC' '') #('OpenGL' ''))PrintStringCache: (3.0 25,ablakey)Version: 3.0 25Post-Load Block: 	[:package | WGL.WGLInterface recompileMethods]Post-Unload Block: 	[]Date: 10:00:08 AM April 10, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (apr15.1) of April 10, 2015 on April 10, 2015 at 10:00:08 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>WGL</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private OpenGL.*			</imports><category>OpenGL</category><attributes><package>OpenGL-Windows</package></attributes></name-space><class><name>WGLInterface</name><environment>WGL</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private WGL.WGLInterfaceDictionary.*			</imports><category>OpenGL-External Interfaces</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OpenGL-Windows</package></attributes></class><comment><class-id>WGL.WGLInterface</class-id><body>WGLInterface is an interface to WGL as well as some of win32, enough to render OpenGL.</body></comment><class><name>RenderContextWin32</name><environment>WGL</environment><super>OpenGL.RenderContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xif hdc hglrc old_hdc old_hglrc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL-Windows</package></attributes></class><comment><class-id>WGL.RenderContextWin32</class-id><body>RenderContextCocoa is the abstract superclass for Windows and Pixmaps on Windows for OpenGLSubclasses must implement the following messages:	initialize-release		initializeHDCInstance Variables:	hdc	&lt;Object | WeakProxy&gt;	description of hdc	hglrc	&lt;CPointer | CProcedurePointer | SQLAssist&gt;	description of hglrc	old_hdc	&lt;Object | WeakProxy&gt;	description of old_hdc	old_hglrc	&lt;Object | WeakProxy&gt;	description of old_hglrc	xif	&lt;WGLInterface&gt;	description of xif</body></comment><class><name>RenderContextWin32Pixmap</name><environment>WGL</environment><super>WGL.RenderContextWin32</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL-Windows</package></attributes></class><comment><class-id>WGL.RenderContextWin32Pixmap</class-id><body>RenderContextWin32Pixmap is a Win32 pixmap surface we can render OpenGL on to.Instance Variables	hdc	&lt;Object | WeakProxy&gt;	description of hdc	hglrc	&lt;Object | WeakProxy&gt;	description of hglrc</body></comment><class><name>RenderContextWin32Image</name><environment>WGL</environment><super>WGL.RenderContextWin32</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hiddenWindow hwnd framebuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL-Windows</package></attributes></class><comment><class-id>WGL.RenderContextWin32Image</class-id><body>RenderContextWin32Image is an offscreen surface we can render OpenGL with and copy the framebuffer data back in to a Smalltalk Image object.Instance Variables	hiddenWindow	&lt;Window&gt;	description of hiddenWindow	hwnd	&lt;Object&gt;	description of hwnd</body></comment><class><name>RenderContextWin32FloatArray</name><environment>WGL</environment><super>WGL.RenderContextWin32Image</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extent texture downloadBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL-Windows</package></attributes></class><comment><class-id>WGL.RenderContextWin32FloatArray</class-id><body>RenderContextWin32FloatArray is an offscreen surface we can render OpenGL with and copy the framebuffer data back in to a FloatArray object.Instance Variables:	downloadBuffer	&lt;Buffer&gt;	description of downloadBuffer	extent	&lt;Point&gt;	description of extent	texture	&lt;Texture&gt;	description of texture</body></comment><class><name>RenderContextWin32Window</name><environment>WGL</environment><super>WGL.RenderContextWin32</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hwnd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL-Windows</package></attributes></class><comment><class-id>WGL.RenderContextWin32Window</class-id><body>RenderContextWin32Window is a Win32 Window surface we can render OpenGL on to.Instance Variables	hdc	&lt;Object&gt;	description of hdc	hglrc	&lt;Object&gt;	description of hglrc	hwnd	&lt;Object&gt;	description of hwnd</body></comment><shared-variable><name>PFD_NEED_SYSTEM_PALETTE</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000100</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_DRAW_TO_BITMAP</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000008</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_SUPPORT_DIRECT_DRAW</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00002000</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>WGL_FONT_POLYGONS</name><environment>WGL</environment><private>false</private><constant>false</constant><category>FontOutlines</category><initializer>1</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_SUPPORT_GDI</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000010</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_NEED_PALETTE</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000080</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>WGL_FONT_LINES</name><environment>WGL</environment><private>false</private><constant>false</constant><category>FontOutlines</category><initializer>0</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_TYPE_COLORINDEX</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000001</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_GENERIC_ACCELERATED</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00001000</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>WGLInterfaceDictionary</name><environment>WGL</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_SWAP_LAYER_BUFFERS</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000800</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_GENERIC_FORMAT</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000040</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_DOUBLEBUFFER</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000001</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_TYPE_RGBA</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000000</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_DRAW_TO_WINDOW</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000004</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_SWAP_COPY</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000400</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_SWAP_EXCHANGE</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000200</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_STEREO</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000002</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><shared-variable><name>PFD_SUPPORT_OPENGL</name><environment>WGL</environment><private>false</private><constant>false</constant><category>PixelFormatDescriptor</category><initializer>16r00000020</initializer><attributes><package>OpenGL-Windows</package></attributes></shared-variable><methods><class-id>WGL.WGLInterface</class-id> <category>procedures</category><body package="OpenGL-Windows">ChoosePixelFormat: hDC with: pfd	&lt;C: int _wincall ChoosePixelFormat(HDC hDC, void* pfd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">CreateCompatibleDC: hDC	&lt;C: HDC _wincall CreateCompatibleDC(HDC hDC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">DeleteDC: hDC	&lt;C: BOOL _wincall DeleteDC(HDC hDC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">DescribePixelFormat: hDC with: iPixelFormat with: nbytes with: pfd	&lt;C: int _wincall DescribePixelFormat(HDC hDC, int iPixelFormat, unsigned int nbytes, PIXELFORMATDESCRIPTOR* pfd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">GetDC: hWnd	&lt;C: HDC _wincall GetDC(HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">GetPixelFormat: hDC	&lt;C: int _wincall GetPixelFormat(HDC hDC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">ReleaseDC: hDC with: hWnd	&lt;C: int ReleaseDC(HWND hWnd, HDC hDC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">SelectObject: hDC with: hgdiobj	&lt;C: HGDIOBJ _wincall SelectObject(HDC hDC, HGDIOBJ hgdiobj)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">SetPixelFormat: hDC with: iPixelFormat with: pfd	&lt;C: BOOL _wincall SetPixelFormat(HDC hDC, int iPixelFormat, const PIXELFORMATDESCRIPTOR* pfd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">SwapBuffers: hDC	&lt;C: BOOL _wincall SwapBuffers(HDC hDC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglCopyContext: hglrcSrc with: hglrcDst with: mask	&lt;C: BOOL _wincall wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, unsigned int mask)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglCreateContext: hDC	&lt;C: HGLRC _wincall wglCreateContext(HDC hDC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglCreateLayerContext: hDC with: iLayerPlane	&lt;C: HGLRC _wincall wglCreateLayerContext(HDC hDC, int iLayerPlane)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglDeleteContext: hglrc	&lt;C: BOOL _wincall wglDeleteContext(HGLRC hglrc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglDescribeLayerPlane: hDC with: iPixelFormat with: iLayerPlane with: nBytes with: plpd	&lt;C: BOOL _wincall wglDescribeLayerPlane(HDC hDC, int iPixelFormat, int iLayerPlane, unsigned int nBytes, LAYERPLANEDESCRIPTOR* plpd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglGetCurrentContext	&lt;C: HGLRC wglGetCurrentContext(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglGetCurrentDC	&lt;C: HDC wglGetCurrentDC(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglGetLayerPaletteEntries: hDC with: iLayerPlane with: iStart with: cEntries with: pcr	&lt;C: int _wincall wglGetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglGetProcAddress: name	"Technically we should use _wincall here but we want to handle the NULL case in a special way -- keep the current function."	&lt;C: PROC wglGetProcAddress(char *name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglMakeCurrent: hDC with: hglrc	&lt;C: BOOL _wincall wglMakeCurrent(HDC hDC, HGLRC hglrc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglRealizeLayerPalette: hDC with: iLayerPlane with: bRealize	&lt;C: BOOL _wincall wglRealizeLayerPalette(HDC hDC, int iLayerPlane, BOOL bRealize)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglSetLayerPaletteEntries: hDC with: iLayerPlane with: iStart with: cEntries with: pcr	&lt;C: int _wincall wglSetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglShareLists: hglrc1 with: hglrc2	&lt;C: BOOL _wincall wglShareLists(HGLRC hglrc1, HGLRC hglrc2)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglSwapLayerBuffers: hDC with: fuPlanes	&lt;C: BOOL _wincall wglSwapLayerBuffers(HDC hDC, unsigned int fuPlanes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglUseFontBitmapsA: hDC with: first with: count with: listBase	&lt;C: BOOL _wincall wglUseFontBitmapsA(HDC hDC, DWORD first, DWORD count, DWORD listBase)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglUseFontBitmapsW: hDC with: first with: count with: listBase	&lt;C: BOOL _wincall wglUseFontBitmapsW(HDC hDC, DWORD first, DWORD count, DWORD listBase)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglUseFontOutlinesA: hDC with: first with: count with: listBase with: deviation with: extrusion with: format with: gmf	&lt;C: BOOL _wincall wglUseFontOutlinesA(HDC hDC, DWORD first, DWORD count, DWORD listBase, float deviation, float extrusion, int format, GLYPHMETRICSFLOAT* gmf)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglUseFontOutlinesW: hDC with: first with: count with: listBase with: deviation with: extrusion with: format with: gmf	&lt;C: BOOL _wincall wglUseFontOutlinesW(HDC hDC, DWORD first, DWORD count, DWORD listBase, float deviation, float extrusion, int format, GLYPHMETRICSFLOAT* gmf)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OpenGL.OpenGLInterface</class-id> <category>extension WGL_EXT_extensions_string</category><body package="OpenGL-Windows">wglGetExtensionsString	&lt;C: char *wglGetExtensionsStringEXT(void)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OpenGL.OpenGLInterface</class-id> <category>extension WGL_EXT_swap_control</category><body package="OpenGL-Windows">wglGetSwapIntervalEXT	&lt;C: int wglGetSwapIntervalEXT(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OpenGL-Windows">wglSwapIntervalEXT: interval	&lt;C: int wglSwapIntervalEXT(int interval)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="OpenGL-Windows">RtlMoveMemory: Destination with: Source with: Length	&lt;C: void RtlMoveMemory(PVOID Destination, const VOID* Source, SIZE_T Length)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>WGL.WGLInterface class</class-id> <category>libraries</category><body package="OpenGL-Windows">windows_gdi32_dll	&lt;library: #win&gt;	^'gdi32.dll'</body><body package="OpenGL-Windows">windows_kernel32_dll	&lt;library: #win&gt;	^'kernel32.dll'</body><body package="OpenGL-Windows">windows_opengl32_dll	&lt;library: #win&gt;	^'opengl32.dll'</body><body package="OpenGL-Windows">windows_user32_dll	&lt;library: #win&gt;	^'user32.dll'</body></methods><methods><class-id>OpenGL.OpenGLInterface class</class-id> <category>libraries</category><body package="OpenGL-Windows">windows_opengl32_dll	&lt;library: #win&gt;	^'opengl32.dll'</body></methods><methods><class-id>WGL.WGLInterface</class-id> <category>types</category><body package="OpenGL-Windows">BOOL	&lt;C: typedef int BOOL&gt;</body><body package="OpenGL-Windows">BYTE	&lt;C: typedef unsigned char BYTE&gt;</body><body package="OpenGL-Windows">COLORREF	&lt;C: typedef DWORD COLORREF&gt;</body><body package="OpenGL-Windows">DWORD	&lt;C: typedef unsigned int DWORD&gt;</body><body package="OpenGL-Windows">GLYPHMETRICSFLOAT	&lt;C: typedef struct _GLYPHMETRICSFLOAT { // gmf     float      gmfBlackBoxX;   float      gmfBlackBoxY;   POINTFLOAT gmfptGlyphOrigin;   float      gmfCellIncX;   float      gmfCellIncY; } GLYPHMETRICSFLOAT&gt;</body><body package="OpenGL-Windows">HDC	&lt;C: typedef unsigned long HDC&gt;</body><body package="OpenGL-Windows">HGDIOBJ	&lt;C: typedef unsigned long HGDIOBJ&gt;</body><body package="OpenGL-Windows">HGLRC	&lt;C: typedef void * HGLRC&gt;</body><body package="OpenGL-Windows">HWND	&lt;C: typedef unsigned long HWND&gt;</body><body package="OpenGL-Windows">LAYERPLANEDESCRIPTOR	&lt;C: typedef struct tagLAYERPLANEDESCRIPTOR { // pfd     WORD  nSize;   WORD  nVersion;   DWORD dwFlags;   BYTE  iPixelType;   BYTE  cColorBits;   BYTE  cRedBits;   BYTE  cRedShift;   BYTE  cGreenBits;   BYTE  cGreenShift;   BYTE  cBlueBits;   BYTE  cBlueShift;   BYTE  cAlphaBits;   BYTE  cAlphaShift;   BYTE  cAccumBits;   BYTE  cAccumRedBits;   BYTE  cAccumGreenBits;   BYTE  cAccumBlueBits;   BYTE  cAccumAlphaBits;   BYTE  cDepthBits;   BYTE  cStencilBits;   BYTE  cAuxBuffers;   BYTE  iLayerPlane;  BYTE  bReserved;   COLORREF crTransparent; } LAYERPLANEDESCRIPTOR&gt;</body><body package="OpenGL-Windows">PIXELFORMATDESCRIPTOR	&lt;C: typedef struct tagPIXELFORMATDESCRIPTOR { // pfd     WORD  nSize;   WORD  nVersion;  DWORD dwFlags;   BYTE  iPixelType;   BYTE  cColorBits;   BYTE  cRedBits;   BYTE  cRedShift;   BYTE  cGreenBits;   BYTE  cGreenShift;   BYTE  cBlueBits;   BYTE  cBlueShift;   BYTE  cAlphaBits;   BYTE  cAlphaShift;   BYTE  cAccumBits;   BYTE  cAccumRedBits;   BYTE  cAccumGreenBits;   BYTE  cAccumBlueBits;   BYTE  cAccumAlphaBits;   BYTE  cDepthBits;   BYTE  cStencilBits;   BYTE  cAuxBuffers;   BYTE  iLayerType;   BYTE  bReserved;   DWORD dwLayerMask;   DWORD dwVisibleMask;   DWORD dwDamageMask; } PIXELFORMATDESCRIPTOR&gt;</body><body package="OpenGL-Windows">POINTFLOAT	&lt;C: typedef struct _POINTFLOAT { // ptf     float  x;   float  y; } POINTFLOAT&gt;</body><body package="OpenGL-Windows">PROC	&lt;C: typedef void * PROC&gt;</body><body package="OpenGL-Windows">WORD	&lt;C: typedef unsigned short WORD&gt;</body></methods><methods><class-id>WGL.WGLInterface</class-id> <category>structs</category><body package="OpenGL-Windows">_GLYPHMETRICSFLOAT	&lt;C: struct _GLYPHMETRICSFLOAT {			float gmfBlackBoxX, gmfBlackBoxY;			POINTFLOAT gmfptGlyphOrigin;			float gmfCellIncX, gmfCellIncY;		}&gt;</body><body package="OpenGL-Windows">_POINTFLOAT	&lt;C: struct _POINTFLOAT {			float x, y;		}&gt;</body><body package="OpenGL-Windows">tagLAYERPLANEDESCRIPTOR	&lt;C: struct tagLAYERPLANEDESCRIPTOR {			WORD nSize, nVersion;			DWORD dwFlags;			BYTE iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerPlane, bReserved;			COLORREF crTransparent;		}&gt;</body><body package="OpenGL-Windows">tagPIXELFORMATDESCRIPTOR	&lt;C: struct tagPIXELFORMATDESCRIPTOR {			WORD nSize, nVersion;			DWORD dwFlags;			BYTE iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerType, bReserved;			DWORD dwLayerMask, dwVisibleMask, dwDamageMask;		}&gt;</body></methods><methods><class-id>WGL.RenderContextWin32</class-id> <category>private</category><body package="OpenGL-Windows">activateContext	old_hdc := xif wglGetCurrentDC asInteger.	old_hglrc := xif wglGetCurrentContext.	xif wglMakeCurrent: hdc with: hglrc</body><body package="OpenGL-Windows">deactivateContext	xif wglMakeCurrent: old_hdc with: old_hglrc</body><body package="OpenGL-Windows">newPixelFormatDescriptor	| pfd |	pfd := xif PIXELFORMATDESCRIPTOR gcMalloc.	pfd zeroFill.	pfd memberAt: #nSize put: xif PIXELFORMATDESCRIPTOR sizeof.	pfd memberAt: #nVersion put: 1.	pfd memberAt: #dwFlags put: self pixelFormatFlags.	pfd memberAt: #iPixelType put: PFD_TYPE_RGBA.	^pfd</body></methods><methods><class-id>WGL.RenderContextWin32</class-id> <category>api</category><body package="OpenGL-Windows">resize</body></methods><methods><class-id>WGL.RenderContextWin32</class-id> <category>initialize-release</category><body package="OpenGL-Windows">initialize: aView	xif := WGLInterface new.	super initialize: aView</body><body package="OpenGL-Windows">initializeContext	self initializeHDC.	self initializePixelFormat.	hglrc := xif wglCreateContext: hdc</body><body package="OpenGL-Windows">initializeHDC	self subclassResponsibility</body><body package="OpenGL-Windows">initializeInterface	| lightWeightClass address |	lightWeightClass := OpenGLInterface copy.	lightWeightClass methodDictionary keysAndValuesDo: [:selector :method |		(method class = lightWeightClass externalMethodClass and: [method referentAddress isNil]) ifTrue:			[address := xif wglGetProcAddress: method external asString.			address isNull ifFalse: [method referentAddress: address referentAddress]]].	interface := lightWeightClass new</body><body package="OpenGL-Windows">initializeParameters	super initializeParameters.	version &lt; '2.0' ifTrue: [^self].	extensions addAll: (((interface wglGetExtensionsString copyCStringFromHeap tokensBasedOn: Character space)		select: [:each | each notEmpty]) collect: [:each | (each allButFirst: 4) asSymbol])</body><body package="OpenGL-Windows">initializePixelFormat	| pfd iFormat |	pfd := self newPixelFormatDescriptor.	pfd memberAt: #cColorBits put: view bitsPerPixel.	pfd memberAt: #cDepthBits put: view depth.	iFormat := xif ChoosePixelFormat: hdc with: pfd.	xif SetPixelFormat: hdc with: iFormat with: pfd</body></methods><methods><class-id>WGL.RenderContextWin32</class-id> <category>accessing</category><body package="OpenGL-Windows">isVSyncEnabled	(extensions includes: #EXT_swap_control) ifFalse: [^false].	^interface wglGetSwapIntervalEXT &gt; 0.</body><body package="OpenGL-Windows">isVSyncEnabled: aBoolean	(extensions includes: #EXT_swap_control) ifFalse: [^self].	interface wglSwapIntervalEXT: aBoolean coerceToCInteger</body></methods><methods><class-id>WGL.RenderContextWin32Pixmap</class-id> <category>initialize-release</category><body package="OpenGL-Windows">initializeHDC	"HDC on GetDC is often a void* until recompiled.. this is a hack to get around it because it will crash the VM"	| hBitmap |	hBitmap := view handle unsignedLongAt: 5.	hdc := (xif CreateCompatibleDC: 0) asInteger.	xif SelectObject: hdc with: hBitmap</body><body package="OpenGL-Windows">release	xif wglDeleteContext: hglrc.	xif DeleteDC: hdc.	super release</body></methods><methods><class-id>WGL.RenderContextWin32Pixmap</class-id> <category>api</category><body package="OpenGL-Windows">flush</body></methods><methods><class-id>WGL.RenderContextWin32Pixmap</class-id> <category>private</category><body package="OpenGL-Windows">pixelFormatFlags	^PFD_DRAW_TO_BITMAP bitOr: PFD_SUPPORT_OPENGL</body></methods><methods><class-id>WGL.RenderContextWin32Pixmap class</class-id> <category>private</category><body package="OpenGL-Windows">platformName	^'MS-Windows'</body><body package="OpenGL-Windows">viewClass	^Pixmap</body></methods><methods><class-id>WGL.RenderContextWin32Image</class-id> <category>private</category><body package="OpenGL-Windows">activateContext	super activateContext.	framebuffer ifNil: [^self].	framebuffer bind</body><body package="OpenGL-Windows">pixelFormatFlags	^PFD_DRAW_TO_WINDOW bitOr: PFD_SUPPORT_OPENGL</body></methods><methods><class-id>WGL.RenderContextWin32Image</class-id> <category>api</category><body package="OpenGL-Windows">flush	view textureParameters: [:format :type :buffer | gl ReadPixels: 0 with: 0 with: view width with: view height with: format with: type with: buffer]</body></methods><methods><class-id>WGL.RenderContextWin32Image</class-id> <category>initialize-release</category><body package="OpenGL-Windows">initialize: aView	super initialize: aView.	self whileCurrentDo: [self initializeFramebuffer]</body><body package="OpenGL-Windows">initializeFramebuffer	| renderbuffer |	renderbuffer := RenderBuffer new.	renderbuffer bind.	renderbuffer storage: gl RGBA extent: view extent.	framebuffer := FrameBuffer new.	framebuffer bind.	framebuffer attach: renderbuffer attachment: gl COLOR_ATTACHMENT0_EXT.	framebuffer isComplete ifFalse: [self error: 'Unable to complete the framebuffer in VRAM']</body><body package="OpenGL-Windows">initializeHDC	"HDC on GetDC is often a void* until recompiled.. this is a hack to get around it because it will crash the VM"	hiddenWindow := Window new.	hiddenWindow setDisplayBox: view bounds.	hiddenWindow createSurfaceWithForcedPosition: false.	hwnd := hiddenWindow windowHandle.	hdc := (xif GetDC: hwnd) asInteger</body><body package="OpenGL-Windows">release	xif wglDeleteContext: hglrc.	xif ReleaseDC: hwnd with: hdc.	hiddenWindow close.	super release</body></methods><methods><class-id>WGL.RenderContextWin32Image class</class-id> <category>private</category><body package="OpenGL-Windows">platformName	^'MS-Windows'</body><body package="OpenGL-Windows">viewClass	^Image</body></methods><methods><class-id>WGL.RenderContextWin32FloatArray</class-id> <category>accessing</category><body package="OpenGL-Windows">bounds	^Point zero extent: extent</body><body package="OpenGL-Windows">internalFormat	^gl RGBA32F_ARB</body></methods><methods><class-id>WGL.RenderContextWin32FloatArray</class-id> <category>initialize-release</category><body package="OpenGL-Windows">initializeFramebuffer	| size height |	size := view size / 4.	height := 2 ** (size sqrt log / 2 log) floor.	extent := (size / height) @ height.	texture := Texture new.	texture internalFormat: self internalFormat.	texture minification: gl NEAREST.	texture magnification: gl NEAREST.	texture empty: extent format: gl RGBA dataType: gl FLOAT.	framebuffer := FrameBuffer new.	framebuffer bind.	framebuffer attach: texture attachment: gl COLOR_ATTACHMENT0_EXT.	framebuffer isComplete ifFalse: [self error: 'Unable to complete the framebuffer in VRAM'].	framebuffer unbind.	texture unbind.	downloadBuffer := Buffer newPixelPackBuffer.	downloadBuffer data: gl GLfloat size: view size mode: gl STREAM_READ.	downloadBuffer unbind</body><body package="OpenGL-Windows">initializeHDC	"HDC on GetDC is often a void* until recompiled.. this is a hack to get around it because it will crash the VM"	hiddenWindow := Window new.	hiddenWindow setDisplayBox: (Point zero extent: 1).	hiddenWindow createSurfaceWithForcedPosition: false.	hwnd := hiddenWindow windowHandle.	hdc := (xif GetDC: hwnd) asInteger</body><body package="OpenGL-Windows">initializePixelFormat	| pfd iFormat |	pfd := self newPixelFormatDescriptor.	pfd memberAt: #cColorBits put: 32.	pfd memberAt: #cDepthBits put: 32.	iFormat := xif ChoosePixelFormat: hdc with: pfd.	xif SetPixelFormat: hdc with: iFormat with: pfd</body></methods><methods><class-id>WGL.RenderContextWin32FloatArray</class-id> <category>api</category><body package="OpenGL-Windows">flush	interface Flush.	downloadBuffer bind.	gl ReadPixels: 0 with: 0 with: extent x with: extent y with: gl RGBA with: gl FLOAT with: 0.	gl CheckError.	downloadBuffer copyInto: view</body></methods><methods><class-id>WGL.RenderContextWin32FloatArray class</class-id> <category>private</category><body package="OpenGL-Windows">viewClass	^FloatArray</body></methods><methods><class-id>WGL.RenderContextWin32Window</class-id> <category>initialize-release</category><body package="OpenGL-Windows">initializeContext	"Force the window to non-buffering mode so it doesn't conflict with OpenGL buffering"	view damageRepairPolicy: WindowDisplayPolicy new.	super initializeContext</body><body package="OpenGL-Windows">initializeHDC	"HDC on GetDC is often a void* until recompiled.. this is a hack to get around it because it will crash the VM"	hwnd := view windowHandle.	hdc := (xif GetDC: hwnd) asInteger</body><body package="OpenGL-Windows">release	xif wglDeleteContext: hglrc.	xif ReleaseDC: hwnd with: hdc.	super release</body></methods><methods><class-id>WGL.RenderContextWin32Window</class-id> <category>private</category><body package="OpenGL-Windows">pixelFormatFlags	^	(PFD_DRAW_TO_WINDOW bitOr:		PFD_SUPPORT_OPENGL) bitOr:		PFD_DOUBLEBUFFER</body></methods><methods><class-id>WGL.RenderContextWin32Window</class-id> <category>api</category><body package="OpenGL-Windows">flush	xif SwapBuffers: hdc</body></methods><methods><class-id>WGL.RenderContextWin32Window class</class-id> <category>private</category><body package="OpenGL-Windows">platformName	^'MS-Windows'</body><body package="OpenGL-Windows">viewClass	^Window</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="OpenGL-Windows">copyMemory: source to: destination length: length	self RtlMoveMemory: destination with: source with: length</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>types</category><body package="OpenGL-Windows">SIZE_T	&lt;C: typedef unsigned int SIZE_T&gt;</body><body package="OpenGL-Windows">VOID	&lt;C: typedef void VOID&gt;</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>OpenGLInterface</name><environment>OpenGL</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OpenGL.OpenGLInterfaceDictionary.*			</imports><category></category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OpenGL</package></attributes></class><class><name>RenderContext</name><environment>OpenGL</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface view vendor renderer version program textures texturesHistory extensions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL</package></attributes></class></st-source>