<?xml version="1.0"?><st-source><!-- Name: Windows GoodiesNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel provides a few goodies for those using VisualWorks on any of the MS-Windows Operating systems.Those goodies are:1) The ability to raise a printer dialog so that you can allow a user to decide what printer to use. See the class side method #example1, of RequestingPrinter to see how this is done.2) The ability to start the registered application for a particular file extension.  This is done with Using a minimal interface to the shell32.dll.It provides a minimal interface to shell32.dll (only those that do not require COM). The basic bits that you get acces to are using ShellExecute() to invoke the appropriate application for a known file extension and file-drop from the windows explorer (and other applications that do file drop).  For the ShellExecute() stuff, see the class side of WinNTShellInterface, or open up a new filebrowser and check out the 'Open' menu option on a selected file. For the file drag and drop, open up the old FileBrowser and drag some files to it.It also overrides a few methods, so take care to check the overridden exstensions after loading.3) There are a few extensions to the Win95SystemSuppot for determining disk space usage.  Note, this doesn't work for Windows 95 (but it might work for post OSR2 Win95 releases).4) A minimal wav file playerDbIdentifier: bear73DbTrace: 396397DbUsername: avalloudDbVersion: 7.10 - 3DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))DialectVersion: VisualWorks 7.9PackageName: Windows GoodiesParcel: #('Windows Goodies')ParcelName: Windows GoodiesPrintStringCache: (7.10 - 3,avalloud)Version: 7.10 - 3Pre-Unload Block: 	[ :pkg |  ApplicationModel checkUnloadOfApplicationsDefinedBy: pkg.FileDropManager  unregisterWindows]Date: 10:40:43 AM February 22, 2013 --><time-stamp>From VisualWorks®, Pre-Release 7.10 (feb13.4) of February 22, 2013 on February 22, 2013 at 10:40:43 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DiskSpaceView</name><environment>Examples</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>computeData freeMegaBytes availableMegaBytes percentFull </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Windows Goodies-Examples</category><attributes><package>Windows Goodies</package></attributes></class><comment><class-id>Examples.DiskSpaceView</class-id><body>Just simple view to couple with DiskSpace to display pie-graphs of diskspace usage.Instance Variables:	availableMegaBytes	&lt;Object&gt;	description of availableMegaBytes	computeData	&lt;Boolean&gt;	description of computeData	freeMegaBytes	&lt;ArithmeticValue&gt;	description of freeMegaBytes	percentFull	&lt;ArithmeticValue&gt;	description of percentFull</body></comment><class><name>WindowsMultimedia</name><environment>OS</environment><super>OS.Win32SystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.WindowsMultimediaDictionary.*			</imports><category>Windows Goodies-External Interfaces</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>winmm.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Windows Goodies</package></attributes></class><comment><class-id>OS.WindowsMultimedia</class-id><body>WindowsMultimedia provides a very minimal interface to the Windows Multimedia library.  Perhaps at some point this class will do more then play a wav (riff) file.</body></comment><class><name>DiskSpace</name><environment>Examples</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume freeBytes availableBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Windows Goodies-Examples</category><attributes><package>Windows Goodies</package></attributes></class><comment><class-id>Examples.DiskSpace</class-id><body>Just a simple model for hanging onto the data returned from volumesAndSpaces.  See PCFilename class&gt;&gt;#volumesAndExamples for more information.Instance Variables:	availableBytes	&lt;SmallInteger&gt;	bytes available	freeBytes	&lt;SmallInteger&gt;	free bytes	volume	&lt;String&gt;	name of volume</body></comment><class><name>FileDropManager</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xif </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Windows Goodies-File drag and drop</category><attributes><package>Windows Goodies</package></attributes></class><class><name>PseudoFileDropManager</name><environment>OS</environment><super>OS.FileDropManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Windows Goodies-File drag and drop</category><attributes><package>Windows Goodies</package></attributes></class><class><name>MyFileBrowser</name><environment>Examples</environment><super>Tools.FileBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Windows Goodies</category><attributes><package>Windows Goodies</package></attributes></class><comment><class-id>Examples.MyFileBrowser</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:xif	&lt;WinNTShellInterface&gt;	an ExternalInterface to the Win API shell functionsClass Variables:RecentlyVisitedPaths	&lt;OrderedCollection of: Strings&gt;	The paths that were recently used</body></comment><class><name>WinDropObject</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files point dropInClient </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS Win Interfaces</category><attributes><package>Windows Goodies</package></attributes></class><comment><class-id>OS.WinDropObject</class-id><body>I provide minimal interface to the information that is returned when a window has registered foraccepting file dropping and the  WM_DROPFILES event is sent to that window.Instance Variables:	files			&lt;OrderedCollection of: String&gt;	A collection of filenames that were dropped	point		&lt;Point&gt;	The x,y coordinate of the drop location	dropInClient	&lt;Boolean&gt;	A Boolean indicating whether the drop occured over the client</body></comment><class><name>WindowsFileDropManager</name><environment>OS</environment><super>OS.FileDropManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Windows Goodies-File drag and drop</category><attributes><package>Windows Goodies</package></attributes></class><class><name>MinimalShellInterface</name><environment>OS</environment><super>OS.Win32SystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.MinimalShellInterfaceDictionary.*			</imports><category>Windows Goodies-External Interfaces</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>shell32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Windows Goodies</package></attributes></class><comment><class-id>OS.MinimalShellInterface</class-id><body>MinimalShellInterface provides an binding to the shell32.dll.  This interface only exposes those functions that rely on COM.  The currently implemented API on this class to register windows for file drag and drop, and to start what the application that is registered for a particular file.   Any client of this class should go and read up on the msdn.microsoft.com website on the shell32 library if they want to add or extend this class.  Typical in-image clients would most likely not reference this class directory and instead use other classes that use this one.</body></comment><shared-variable><name>RecentlyVisitedPaths</name><environment>Examples.MyFileBrowser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Windows Goodies</package></attributes></shared-variable><shared-variable><name>MinimalShellInterfaceDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Windows Goodies</package></attributes></shared-variable><shared-variable><name>WindowsMultimediaDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Windows Goodies</package></attributes></shared-variable><shared-variable><name>DebugStream</name><environment>OS.FileDropManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Windows Goodies</package></attributes></shared-variable><shared-variable><name>RegisteredWindows</name><environment>OS.FileDropManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>Core.OrderedCollection new</initializer><attributes><package>Windows Goodies</package></attributes></shared-variable><shared-variable><name>DefaultManager</name><environment>OS.FileDropManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Windows Goodies</package></attributes></shared-variable><shared-variable><name>Current</name><environment>OS.FileDropManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Windows Goodies</package></attributes></shared-variable><methods><class-id>OS.WindowsMultimedia</class-id> <category>procedures</category><body package="Windows Goodies">PlaySoundA: arg1 with: arg2 with: arg3	&lt;C: int PlaySoundA(LPCSTR arg1, HMODULE arg2, DWORD arg3)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.MinimalShellInterface</class-id> <category>procedures</category><body package="Windows Goodies">CreateIcon: hInstance with: nWidth with: nHeight with: cPlanes with: cBitsPixel with: lpbANDbits with: lpbXORbits	&lt;C: HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits,  const BYTE *lpbXORbits)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">DragAcceptFiles: hWnd with: fAccept	&lt;C: void DragAcceptFiles(HWND hWnd, BOOL fAccept)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">DragFinish: hDrop	&lt;C: void DragFinish(HDROP hDrop)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">DragQueryFile: hDrop with: iFile with: lpszFile with: cch	&lt;C: UINT DragQueryFileW(HDROP hDrop, UINT iFile, LPTSTR lpszFile, UINT cch)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">DragQueryPoint: hDrop with: lppt	&lt;C: BOOL DragQueryPoint(HDROP hDrop, LPPOINT lppt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">DragQueryPointer: hDrop with: lppt	&lt;C: BOOL DragQueryPoint(HDROP hDrop, LPPOINT lppt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">ExtractAssociatedIcon: hInst with: lpIconPath with: lpiIcon	&lt;C: HICON ExtractAssociatedIcon(HINSTANCE hInst, LPTSTR lpIconPath, LPWORD lpiIcon)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">ExtractIcon: hInst with: lpszExeFileName with: nIconIndex	&lt;C: HICON ExtractIcon(HINSTANCE hInst, LPCTSTR lpszExeFileName, UINT nIconIndex)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">FindExecutable: lpFile with: lpDirectory with: lpResult	&lt;C: HINSTANCE FindExecutableA(LPCTSTR lpFile, LPCTSTR lpDirectory, LPTSTR lpResult)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">ShellAbout: hWnd with: szApp with: szOtherStuff with: hIcon	&lt;C: int ShellAbout(HWND hWnd, LPCTSTR szApp, LPCTSTR szOtherStuff, HICON hIcon)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">ShellExecute: hwnd with: lpOperation with: lpFile with: lpParameters with: lpDirectory with: nShowCmd	&lt;C: HINSTANCE ShellExecuteA(HWND hwnd,	LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters,	LPCTSTR lpDirectory,int nShowCmd )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">ShellExecuteA: hwnd with: lpOperation with: lpFile with: lpParameters with: lpDirectory with: nShowCmd	&lt;C: HINSTANCE ShellExecuteA(HWND hwnd, LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, int nShowCmd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">ShellExecuteEx: lpExecInfo	&lt;C: BOOL ShellExecuteEx(LPSHELLEXECUTEINFO lpExecInfo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">Shell_NotifyIcon: dwMessage with: lpdata	&lt;C: BOOL Shell_NotifyIcon(DWORD dwMessage, PNOTIFYICONDATA lpdata)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="Windows Goodies">GetDiskFreeSpaceEx: lpDirectoryName with: lpFreeBytesAvailable with: lpTotalNumberOfBytes with: lpTotalNumberOfFreeBytes	&lt;C: BOOL GetDiskFreeSpaceExA(char * lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)&gt;	^self externalAccessFailedWith: _errorCode"http://msdn.microsoft.com/library/psdk/winbase/filesio_8bso.htm	BOOL GetFreeDiskFreeSpaceExA(				LPCTSTR lpDirectoryName,                 // directory name				PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller				PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk				PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk) "</body><body package="Windows Goodies">GetLogicalDrives	&lt;C: DWORD GetLogicalDrives(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Windows Goodies">GetModuleHandle: lpModuleName	&lt;C: HMODULE GetModuleHandleA(LPCTSTR lpModuleName)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Examples.MyFileBrowser class</class-id> <category>resources</category><body package="Windows Goodies">fullMenuBar	"MenuEditor new openOnClass: self andSelector: #fullMenuBar"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: '&amp;File' 				#nameKey: #fileMenu 				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: '&amp;Exit' 							#nameKey: #exit 							#value: #closeRequest ) ) #(1 ) nil ) ) 			#(#MenuItem 				#rawLabel: 'En&amp;coding' 				#nameKey: #encodingMenu 				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: '&amp;Current' 							#nameKey: #currentEncodingMenu ) 						#(#MenuItem 							#rawLabel: 'Default for &amp;Text Files' 							#nameKey: #textEncodingMenu ) 						#(#MenuItem 							#rawLabel: 'Default for &amp;Source Files' 							#nameKey: #sourceEncodingMenu ) ) #(1 2 ) nil ) ) 			#(#MenuItem 				#rawLabel: '&amp;Options' 				#nameKey: #optionsMenu 				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: 'Auto &amp;Read' 							#nameKey: #toggleAutoLoad 							#value: #toggleAutoLoad 							#indication: true ) ) #(1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Windows Goodies">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: '&amp;File' 				#nameKey: #fileMenu 				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: 'Exit' 							#nameKey: #exit 							#value: #closeRequest ) ) #(1 ) nil ) ) 			#(#MenuItem 				#rawLabel: 'En&amp;coding' 				#nameKey: #encodingMenu 				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: '&amp;Current' 							#nameKey: #currentEncodingMenu ) 						#(#MenuItem 							#rawLabel: 'Default for &amp;Text Files' 							#nameKey: #textEncodingMenu ) 						#(#MenuItem 							#rawLabel: 'Default for &amp;Source Files' 							#nameKey: #sourceEncodingMenu ) ) #(1 2 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>file list</category><body package="Windows Goodies">openAssociatedApplication	&lt;menuItem: 'O&amp;pen'		nameKey: nil		menu: #(#fileList)		position: 28.4&gt;	self withSelectedFilenameDo: 		[:name | 					[name hasAssociatedApplication ifFalse: 			[^Dialog warn: 'No associated application to start'].		name startAssociatedApplication]			on: name errorReporter unsupportedOperationSignal			do: [:ex | Dialog warn: 'No support on this platform for this operation']]</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>file name list</category><body package="Windows Goodies">open	"open up the file using the shell"	&lt;menuItem: '&amp;Open'		nameKey: nil		menu: #(fileMenu)		position: 11.00&gt;	|realFilename|	(fileName isEmpty or: [fileName isNil]) ifTrue: [^self].	realFilename := fileName asFilename.	[realFilename hasAssociatedApplication ifFalse: [^Dialog warn: 'No associated application to start'].	realFilename startAssociatedApplication]		on: realFilename errorReporter unsupportedOperationSignal		do: [:ex | Dialog warn: 'No support on this platform for this operation'].</body></methods><methods><class-id>Examples.DiskSpaceView</class-id> <category>updating</category><body package="Windows Goodies">update: aParameter 	(#(#freeBytes #availableBytes) includes: aParameter) ifTrue:		[computeData := true]</body></methods><methods><class-id>Examples.DiskSpaceView</class-id> <category>accessing</category><body package="Windows Goodies">dataString	^'&lt;1s&gt;MB Free&lt;n&gt;&lt;2s&gt;MB Total'		expandMacrosWith:  (NumberPrintPolicy print: freeMegaBytes using: '#') asString		with: (NumberPrintPolicy print: availableMegaBytes using: '#') asString</body><body package="Windows Goodies">helpText	^self dataString</body></methods><methods><class-id>Examples.DiskSpaceView</class-id> <category>private</category><body package="Windows Goodies">computeData	freeMegaBytes := self model freeBytes / (1024 * 1024).	availableMegaBytes := self model availableBytes / (1024 * 1024).	percentFull := freeMegaBytes / availableMegaBytes.	computeData := false.</body></methods><methods><class-id>Examples.DiskSpaceView</class-id> <category>displaying</category><body package="Windows Goodies">displayOn: aGraphicsContext 	| oldPaint circle arc |	super displayOn: aGraphicsContext.	computeData ifTrue: [self computeData].	oldPaint := aGraphicsContext paint.	aGraphicsContext paint: ColorValue red.	circle := Circle center: 25 @ 25 radius: 25.	circle asFiller displayOn: aGraphicsContext.	arc := EllipticalArc				boundingBox: circle bounds				startAngle: -90				sweepAngle: (percentFull * 360) floor.	aGraphicsContext paint: ColorValue green.	arc asFiller displayOn: aGraphicsContext.	self displayTextDataOn: aGraphicsContext.	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>Examples.DiskSpaceView</class-id> <category>private-displaying</category><body package="Windows Goodies">displayTextDataOn: aGraphicsContext 	aGraphicsContext paint: ColorValue black.	aGraphicsContext displayString: self model volume at: 3 @ 25</body></methods><methods><class-id>Examples.DiskSpaceView</class-id> <category>initialize-release</category><body package="Windows Goodies">initialize	super initialize.		computeData := true.</body></methods><methods><class-id>Examples.DiskSpaceView class</class-id> <category>examples</category><body package="Windows Goodies">horizontalExample: data 	"self horizontalExample: PCFilename volumesAndSpaces"	| win comp xDelta yDelta |	comp := CompositePart new.	xDelta := 5.	yDelta := 5.	data keys asSortedCollection do: 			[:volume | 			(data at: volume) ifNotNil: 					[:array | 					comp add: (TranslatingWrapper 								on: (self model: (DiskSpace volume: volume spacesArray: array))								at: xDelta @ yDelta).					xDelta := xDelta + 50]].	win := ApplicationWindow 				model: nil				label: 'Disk space for mounted volumes'				minimumSize: xDelta @ 60.	win component: (BoundedWrapper on: comp).	win open</body><body package="Windows Goodies">toolsDiskSpaceExample	"self toolsDiskSpaceExample"	| selector |	selector := Dialog 				choose: 'Orientation?'				labels: (Array with: 'Horizontal' with: 'Vertical')				values: #(#horizontalExample: #verticalExample:)				default: #horizontalExample:.	Cursor read 		showWhile: [self perform: selector with: PCFilename volumesAndSpaces]</body><body package="Windows Goodies">verticalExample: data 	"self verticalExample: PCFilename volumesAndSpaces."	| win comp xDelta yDelta |	comp := CompositePart new.	xDelta := 5.	yDelta := 5.	data keys asSortedCollection do: 			[:volume | 			(data at: volume) ifNotNil: 					[:array | 					comp add: (TranslatingWrapper 								on: (self model: (DiskSpace volume: volume spacesArray: array))								at: xDelta @ yDelta).					yDelta := yDelta + 50]].	win := ApplicationWindow 				model: nil				label: 'Disk space for mounted volumes'				minimumSize: 20 @ yDelta.	win component: (BoundedWrapper on: comp).	win open</body></methods><methods><class-id>OS.WindowsMultimedia</class-id> <category>types</category><body package="Windows Goodies">LPCSTR	&lt;C: typedef const char * LPCSTR&gt;</body></methods><methods><class-id>OS.WindowsMultimedia</class-id> <category>api</category><body package="Windows Goodies">playSoundFile: filename 	^self playSoundFile: filename loop: false</body><body package="Windows Goodies">playSoundFile: filename loop: shouldLoop 	^self 		PlaySoundA: filename asString		with: 0		with: ((shouldLoop ifTrue: [self SND_LOOP] ifFalse: [0]) 				bitOr: (self SND_FILENAME bitOr: (self SND_ASYNC bitOr: self SND_NODEFAULT)))</body><body package="Windows Goodies">stopSound	self 		PlaySoundA: nil		with: 0		with: 0</body></methods><methods><class-id>OS.WindowsMultimedia</class-id> <category>defines-sound</category><body package="Windows Goodies">SND_ASYNC	"The sound is played asynchronously and PlaySound returns immediately after beginning the sound. To terminate 	 an asynchronously played waveform sound, call PlaySound with pszSound set to NULL."	&lt;C: #define SND_ASYNC 0x0001&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body><body package="Windows Goodies">SND_FILENAME	"The pszSound parameter is a filename"	&lt;C: #define SND_FILENAME 0x20000&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body><body package="Windows Goodies">SND_LOOP	"The sound plays repeatedly until PlaySound is called again with the pszSound parameter 	 set to NULL. You must also specify the SND_ASYNC flag to indicate an asynchronous 	 sound event."	&lt;C: #define SND_LOOP 0x0008&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body><body package="Windows Goodies">SND_MEMORY	"A sound event's file is loaded in RAM. The parameter specified by pszSound must point 	 to an image of a sound in memory"	&lt;C: #define SND_MEMORY 0x0004&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body><body package="Windows Goodies">SND_NODEFAULT	"No default sound event is used. If the sound cannot be found, PlaySound returns silently without playing the default sound."	&lt;C: #define SND_NODEFAULT 0x0002&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body><body package="Windows Goodies">SND_NOSTOP	"The specified sound event will yield to another sound event that is already playing. If a sound cannot 	 be played because the resource needed to generate that sound is busy playing another sound, the 	 function immediately returns FALSE without playing the requested sound. 	 If this flag is not specified, PlaySound attempts to stop the currently playing sound so that the device can  	 be used to play the new sound."	&lt;C: #define SND_NOSTOP 0x0010&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body><body package="Windows Goodies">SND_NOWAIT	"If the driver is busy, return immediately without playing the sound."	&lt;C: #define SND_NOWAIT 0x00002000L&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body><body package="Windows Goodies">SND_SYNC	"Synchronous playback of a sound event. PlaySound returns after the sound event completes."	&lt;C: #define SND_SYNC 0x0000&gt;	"From msdn online API for PlaySound() &amp; winmm.h"</body></methods><methods><class-id>Examples.DiskSpace</class-id> <category>accessing</category><body package="Windows Goodies">availableBytes	^availableBytes isNil		ifTrue: [availableBytes := 0]		ifFalse: [availableBytes]</body><body package="Windows Goodies">availableBytes: aValue 	availableBytes := aValue.	self changed: #availableBytes</body><body package="Windows Goodies">freeBytes	^freeBytes isNil		ifTrue: [freeBytes := 0]		ifFalse: [freeBytes]</body><body package="Windows Goodies">freeBytes: aValue 	freeBytes := aValue.	self changed: #freeBytes</body><body package="Windows Goodies">volume	^volume isNil		ifTrue: [volume := 'unknown']		ifFalse: [volume]</body><body package="Windows Goodies">volume: aValue	volume := aValue.	self changed: #volume</body></methods><methods><class-id>Examples.DiskSpace class</class-id> <category>instance creation</category><body package="Windows Goodies">volume: volume spacesArray: spacesArray 	"An spacesArray is what #volumesAndSpaces would return."	^(self new)		volume: volume;		freeBytes: (spacesArray at: 1);		availableBytes: (spacesArray at: 2);		yourself</body></methods><methods><class-id>OS.FileDropManager</class-id> <category>file drop</category><body package="Windows Goodies">dropObjectFrom: anEvent 	"I suppose the default is to do nothing"</body></methods><methods><class-id>OS.FileDropManager</class-id> <category>initialize-release</category><body package="Windows Goodies">initialize	"Do nothing for now"</body></methods><methods><class-id>OS.FileDropManager</class-id> <category>registration</category><body package="Windows Goodies">registerWindow: aWindow 	RegisteredWindows add: aWindow</body><body package="Windows Goodies">unregisterWindow: aView 	RegisteredWindows remove: aView ifAbsent: [nil]</body><body package="Windows Goodies">unregisterWindows	RegisteredWindows copy do: [:view | self unregisterWindow: view]</body></methods><methods><class-id>OS.FileDropManager class</class-id> <category>instance creation</category><body package="Windows Goodies">concreteClass	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	Current isNil ifTrue:		[Current := self concreteClassFrom: ExternalInterface currentPlatform].	^Current</body><body package="Windows Goodies">concreteClassFrom: platformArray	| platformSymbol |	platformSymbol := platformArray at: 1.	#win32 == platformSymbol		ifTrue:			[^#{WindowsFileDropManager} value].	^#{PseudoFileDropManager} value.</body><body package="Windows Goodies">new	^super new initialize</body></methods><methods><class-id>OS.FileDropManager class</class-id> <category>debugging</category><body package="Windows Goodies">debugStream	^DebugStream</body><body package="Windows Goodies">debugStream: aStream 	"self debugStream: Transcript"	"self debugStream: nil"	DebugStream := aStream</body><body package="Windows Goodies">isDebugging	^self debugStream notNil</body><body package="Windows Goodies">logMessage: aMessage	"Log aMessage to the debug stream"	self isDebugging  ifFalse: [^self].	self debugStream 		nextPutAll: aMessage;		flush</body></methods><methods><class-id>OS.FileDropManager class</class-id> <category>accessing</category><body package="Windows Goodies">default	^DefaultManager isNil		ifTrue: [DefaultManager := self concreteClass new]		ifFalse: [DefaultManager]</body></methods><methods><class-id>OS.FileDropManager class</class-id> <category>class-intialization</category><body package="Windows Goodies">initialize	"FileDropManager initialize"	ObjectMemory removeDependent: self.	ObjectMemory addDependent: self</body><body package="Windows Goodies">install	"Install the drop manager"	"FileDropManager install"	"First nil out the current default and concrete class, so that the correct platform 	manager is used."	DefaultManager := Current := nil.			"Next, unregister, then register the windows again"	RegisteredWindows copy do: [:aWindow |		self default unregisterWindow: aWindow.		self default registerWindow: aWindow].</body><body package="Windows Goodies">obsolete	ObjectMemory removeDependent: self.	super obsolete</body><body package="Windows Goodies">unregisterWindows	"FileDropManager unregisterWindows"	self default unregisterWindows</body></methods><methods><class-id>OS.FileDropManager class</class-id> <category>updating</category><body package="Windows Goodies">update: anAspect with: arguments from: anObject	"Check for return from snapshot to install."	(anObject == ObjectMemory and: [anAspect == #returnFromSnapshot])		ifTrue: [self install]</body></methods><methods><class-id>Examples.MyFileBrowser</class-id> <category>private</category><body package="Windows Goodies">addCurrentPattern	self class addVisitTo: self pattern.</body><body package="Windows Goodies">buildWindowMenu	"Build the Window Menu. If a File is selected, add the fileListMenu. Add visited paths after Exit 	menuitem"	| fileMenu exitItem count menuItems realFileMenu newFileMenu |	newFileMenu := Menu new.	self builder isNil ifTrue: ["Interface is not built yet"		^self].	fileMenu := ((self builder menuAt: #fullMenuBar)				atNameKey: #fileMenu) submenu.	exitItem := fileMenu atNameKey: #exit.	realFileMenu := self fileListMenu.	realFileMenu isNil ifFalse: ["A file is selected"		realFileMenu visibleMenuItemGroups do: [:aGroup | newFileMenu addItemGroup: aGroup]].	newFileMenu addItemGroup: (OrderedCollection with: exitItem).	count := 0.	menuItems := self class visitedPaths				collect: 					[:aPath | 					"Build each path"					| label |					count := count + 1.					label := '&amp;' , count printString , ' ' , (aPath contractTo: self class maxMenuItemWidth).					(MenuItem labeled: label)						value: [(self controllerFor: #pattern) model value: aPath]].	newFileMenu addItemGroup: menuItems.	((self builder menuAt: #fullMenuBar)		atNameKey: #fileMenu)		submenu: newFileMenu.	self builder window menuBar updateMenu</body><body package="Windows Goodies">handleDropEvent: anEvent 	| dropObject patternStream aController files lastIndex |	dropObject := FileDropManager default dropObjectFrom: anEvent.	patternStream := dropObject files inject: (ReadWriteStream on: String new)				into: 					[:aStream :next | 					aStream nextPutAll: next.					aStream nextPut: $;.					aStream].	aController := self controllerFor: #pattern.	aController isNil ifTrue: [^self].	files := patternStream contents.	(lastIndex := files lastIndexOf: $;) ~= 0 ifTrue: 		[files := files copyFrom: 1 to: lastIndex -1].	aController model value: files</body><body package="Windows Goodies">reInstallInterface	"Install the receiver's user interface again. Keep the same window. 	This happens when changing projects, restarting, and look and feel 	changes."	| spec window |	window := self builder window.	window component release.	builder := UIBuilder new.	builder setWindow: window.	builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self preBuildWith: builder.	builder add: spec.	self postBuildWith: builder.	builder doFinalHookup.	self postOpenWith: builder.	^builder</body></methods><methods><class-id>Examples.MyFileBrowser</class-id> <category>file name list</category><body package="Windows Goodies">fileName: selection	super fileName: selection.	self changed: #dasFilename</body></methods><methods><class-id>Examples.MyFileBrowser</class-id> <category>initialize-release</category><body package="Windows Goodies">initialize	super initialize.	self addDependent: self.	(self class dependents includes: self)		ifFalse: ["need to do this because FileBrowser ends up sending #initialize twice... file a bug"			self class addDependent: self]</body><body package="Windows Goodies">release	self removeDependent: self.	self class removeDependent: self.	FileDropManager default unregisterWindow: self builder window.	super release.</body></methods><methods><class-id>Examples.MyFileBrowser</class-id> <category>events</category><body package="Windows Goodies">noticeOfWindowClose: aWindow 	super noticeOfWindowClose: aWindow.	self release.</body><body package="Windows Goodies">windowEvent: anEvent from: aWindow 	"Handle the events we care about. #newGraphicsDevice is sent out when the look changes, which is 	when we want to change our interface. Also, handle the drop from windows"	super windowEvent: anEvent from: aWindow.	(#(#newGraphicsDevice #reopen) includes: anEvent key) ifTrue:		[self reInstallInterface].	anEvent key = #wm_dropfiles ifTrue: [self handleDropEvent: anEvent]</body></methods><methods><class-id>Examples.MyFileBrowser</class-id> <category>interface opening</category><body package="Windows Goodies">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	aBuilder window application: self.		"These events will clue us in to a look change"	aBuilder window sendWindowEvents: #(#newGraphicsDevice #reopen).</body><body package="Windows Goodies">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	FileDropManager default registerWindow: aBuilder window.	"#wm_dropfiles is the window message sent, so watch for it"	aBuilder window sendWindowEvents: #(#wm_dropfiles).	self buildWindowMenu</body></methods><methods><class-id>Examples.MyFileBrowser</class-id> <category>updating</category><body package="Windows Goodies">update: anAspectSymbol 	super update: anAspectSymbol.	(#(#pathAdded #clearPaths #dasFilename) includes: anAspectSymbol) ifTrue:		[self buildWindowMenu].	anAspectSymbol == #fileNameList ifTrue: [self addCurrentPattern]</body></methods><methods><class-id>Examples.MyFileBrowser class</class-id> <category>accessing</category><body package="Windows Goodies">addVisitTo: aPath 	((self visitedPaths includes: aPath)		or: [aPath isEmpty])		ifTrue: [^self].	[self visitedPaths size &gt;= self maxFilesHistory]		whileTrue: [self visitedPaths removeLast].	self visitedPaths addFirst: aPath.	self changed: #pathAdded</body><body package="Windows Goodies">clearFileVisits	RecentlyVisitedPaths := OrderedCollection new.	self changed: #clearPaths</body><body package="Windows Goodies">visitedPaths	^RecentlyVisitedPaths</body></methods><methods><class-id>Examples.MyFileBrowser class</class-id> <category>utilities</category><body package="Windows Goodies">fileEditorInterface	"Answer the interface spec used to open a file editor."	^#fileEditorSpec</body></methods><methods><class-id>Examples.MyFileBrowser class</class-id> <category>class initialization</category><body package="Windows Goodies">initialize	"self initialize"	self clearFileVisits</body></methods><methods><class-id>Examples.MyFileBrowser class</class-id> <category>constants</category><body package="Windows Goodies">maxFilesHistory	^9</body><body package="Windows Goodies">maxMenuItemWidth	"a reasonable width"	^40</body></methods><methods><class-id>OS.WinDropObject</class-id> <category>accessing</category><body package="Windows Goodies">dropInClient: aBoolean	dropInClient := aBoolean</body><body package="Windows Goodies">files	^files</body><body package="Windows Goodies">files: aValue	files := aValue</body><body package="Windows Goodies">point	^point</body><body package="Windows Goodies">point: aValue	point := aValue</body></methods><methods><class-id>OS.WinDropObject</class-id> <category>testing</category><body package="Windows Goodies">inClient	^dropInClient</body></methods><methods><class-id>OS.WinDropObject</class-id> <category>initialize-release</category><body package="Windows Goodies">initialize	point := Point zero.	files := OrderedCollection new.	dropInClient := false</body></methods><methods><class-id>OS.WinDropObject class</class-id> <category>instance creation</category><body package="Windows Goodies">onFiles: anOrderedCollection cursorPoint: aPoint 	| wdo |	wdo := self new.	wdo files: anOrderedCollection.	wdo point: aPoint.	^wdo</body><body package="Windows Goodies">onFiles: anOrderedCollection cursorPoint: aPoint dropInClient: aBoolean	| wdo |	wdo := self new.	wdo files: anOrderedCollection.	wdo point: aPoint.	wdo dropInClient: aBoolean.	^wdo</body></methods><methods><class-id>OS.WindowsFileDropManager</class-id> <category>file drop</category><body package="Windows Goodies">dropObjectFrom: anEvent 	super dropObjectFrom: anEvent.	^[self privateDropObjectFrom: anEvent]		on: Error do: [:ex | self class logMessage: ('Drop Error:&lt;1p&gt; for event:&lt;2p&gt;' expandMacrosWith: ex with: anEvent)]</body></methods><methods><class-id>OS.WindowsFileDropManager</class-id> <category>private</category><body package="Windows Goodies">privateDropObjectFrom: anEvent 	"Return a WinDropObject from this drop event"	| wParam dropHandle |	wParam := (anEvent value at: 10)				longAt: 13.	dropHandle := xif HDROP cast: wParam.	^	[| numberOfFiles oc pointBuffer inClient point |	numberOfFiles := xif numOfFilesDroppedFrom: dropHandle.	oc := OrderedCollection new: numberOfFiles.	1 to: numberOfFiles do: [:anIndex | oc add: (xif extractFileAtIndex: anIndex - 1 fromDropHandle: dropHandle)].	pointBuffer := xif POINT gcMalloc.	inClient := xif DragQueryPoint: dropHandle with: pointBuffer.	point := (pointBuffer memberAt: #x)				@ (pointBuffer memberAt: #y).	WinDropObject		onFiles: oc		cursorPoint: point		dropInClient: inClient = 1]		ensure: [xif DragFinish: dropHandle]</body><body package="Windows Goodies">privateRegisterWindow: aWindow 	| hWnd |	hWnd := xif HWND cast: aWindow windowHandle.	xif DragAcceptFiles: hWnd with: 1</body><body package="Windows Goodies">privateUnregisterWindow: aWindow 	| hWnd |	hWnd := xif HWND cast: aWindow windowHandle.	xif DragAcceptFiles: hWnd with: 0</body></methods><methods><class-id>OS.WindowsFileDropManager</class-id> <category>registration</category><body package="Windows Goodies">registerWindow: aWindow 	super registerWindow: aWindow.	[self privateRegisterWindow: aWindow]		on: Error do: [:ex | self class logMessage: ('Register Error:&lt;1p&gt; for window:&lt;2p&gt;' expandMacrosWith: ex with: aWindow)]</body><body package="Windows Goodies">unregisterWindow: aWindow 	super unregisterWindow: aWindow.	[self privateUnregisterWindow: aWindow]		on: Error do: [:ex | self class logMessage: ('Unregister Error:&lt;1p&gt; for window:&lt;2p&gt;' expandMacrosWith: ex with: aWindow)].</body></methods><methods><class-id>OS.WindowsFileDropManager</class-id> <category>initialize-release</category><body package="Windows Goodies">initialize	super initialize.	xif := MinimalShellInterface new</body></methods><methods><class-id>OS.MinimalShellInterface</class-id> <category>types</category><body package="Windows Goodies">GUID	&lt;C: typedef void * GUID&gt;</body><body package="Windows Goodies">HDROP	&lt;C: typedef HANDLE HDROP&gt;</body><body package="Windows Goodies">HICON	&lt;C: typedef void * HICON&gt;</body><body package="Windows Goodies">HINSTANCE	&lt;C: typedef HANDLE HINSTANCE&gt;</body><body package="Windows Goodies">HWND	&lt;C: typedef HANDLE HWND&gt;</body><body package="Windows Goodies">LPCSTR	&lt;C: typedef const char * LPCSTR&gt;</body><body package="Windows Goodies">LPCTSTR	&lt;C: typedef LPCSTR LPCTSTR&gt;</body><body package="Windows Goodies">LPPOINT	&lt;C: typedef POINT * LPPOINT&gt;</body><body package="Windows Goodies">LPSHELLEXECUTEINFO	&lt;C: typedef void * LPSHELLEXECUTEINFO&gt;</body><body package="Windows Goodies">LPTSTR	&lt;C: typedef void * LPTSTR&gt;</body><body package="Windows Goodies">LPWORD	&lt;C: typedef void * LPWORD&gt;</body><body package="Windows Goodies">NOTIFYICONDATA	&lt;C: typedef struct _NOTIFYICONDATA NOTIFYICONDATA&gt;</body><body package="Windows Goodies">PNOTIFYICONDATA	&lt;C: typedef NOTIFYICONDATA * PNOTIFYICONDATA&gt;</body><body package="Windows Goodies">POINT	&lt;C: typedef struct tagPOINT POINT&gt;</body><body package="Windows Goodies">PVOID	&lt;C: typedef void * PVOID&gt;</body><body package="Windows Goodies">TCHAR	&lt;C: typedef void * TCHAR&gt;</body><body package="Windows Goodies">UINT	&lt;C: typedef unsigned int UINT&gt;</body></methods><methods><class-id>OS.MinimalShellInterface</class-id> <category>structs</category><body package="Windows Goodies">_NOTIFYICONDATA	&lt;C: struct _NOTIFYICONDATA {		    DWORD  cbSize;		    HWND  hWnd;		    UINT  uID;		    UINT  uFlags;		    UINT  uCallbackMessage;		    HICON  hIcon;		    TCHAR  szTip[64];		    DWORD  dwState;		    DWORD  dwStateMask;		    TCHAR  szInfo[256];		    union {			        UINT  uTimeout;			        UINT  uVersion;		    };		    TCHAR  szInfoTitle[64];		    DWORD  dwInfoFlags;		    GUID  guidItem;}&gt;</body><body package="Windows Goodies">tagPOINT	&lt;C: struct tagPOINT {			long x, y;		}&gt;</body></methods><methods><class-id>OS.MinimalShellInterface</class-id> <category>defines</category><body package="Windows Goodies">NIF_ICON	&lt;C:#define NIF_ICON        0x00000002&gt;</body><body package="Windows Goodies">NIF_MESSAGE	&lt;C:#define NIF_MESSAGE     0x00000001&gt;</body><body package="Windows Goodies">NIF_TIP	&lt;C:#define NIF_TIP         0x00000004&gt;</body><body package="Windows Goodies">NIM_ADD	&lt;C:#define NIM_ADD         0x00000000&gt;</body><body package="Windows Goodies">NIM_DELETE	&lt;C:#define NIM_DELETE      0x00000002&gt;</body><body package="Windows Goodies">NIM_MODIFY	&lt;C:#define NIM_MODIFY      0x00000001&gt;</body><body package="Windows Goodies">QUERY_NUM_OF_FILES	&lt;C: #define QUERY_NUM_OF_FILES 4294967295	&gt;</body><body package="Windows Goodies">SW_SHOWNORMAL	&lt;C: #define SW_SHOWNORMAL 1	&gt;</body><body package="Windows Goodies">WM_DROPFILES	&lt;C: #define WM_DROPFILES 563	&gt;</body></methods><methods><class-id>OS.MinimalShellInterface</class-id> <category>API</category><body package="Windows Goodies">filesDroppedFromExternalEvent: anEvent 	"Return an OrderedCollection of the files in the hDrop."	| wParam dropHandle |	wParam := (anEvent value at: 10)				longAt: 13.	dropHandle := self HDROP cast: wParam.	^	[| numberOfFiles oc pointBuffer inClient point |	numberOfFiles := self numOfFilesDroppedFrom: dropHandle.	oc := OrderedCollection new: numberOfFiles.	1 to: numberOfFiles do: [:anIndex | oc add: (self extractFileAtIndex: anIndex - 1 fromDropHandle: dropHandle)].	pointBuffer := self POINT gcMalloc.	inClient := self DragQueryPoint: dropHandle with: pointBuffer.	point := (pointBuffer memberAt: #x)				@ (pointBuffer memberAt: #y).	WinDropObject		onFiles: oc		cursorPoint: point		dropInClient: inClient = 1]		ensure: [self DragFinish: dropHandle]</body><body package="Windows Goodies">registerWindowForDrop: aView 	| hWnd |	hWnd := self HWND cast: aView windowHandle.	self DragAcceptFiles: hWnd with: 1</body><body package="Windows Goodies">unregisterWindowForDrop: aView	| hWnd |	hWnd := self HWND cast: aView windowHandle.	self DragAcceptFiles: hWnd with: 0</body><body package="Windows Goodies">winDropObjectFrom: anEvent 	"Return a WinDropObject from this drop event"	| wParam dropHandle |	wParam := (anEvent value at: 10)				longAt: 13.	dropHandle := self HDROP cast: wParam.	^	[| numberOfFiles oc pointBuffer inClient point |	numberOfFiles := self numOfFilesDroppedFrom: dropHandle.	oc := OrderedCollection new: numberOfFiles.	1 to: numberOfFiles do: [:anIndex | oc add: (self extractFileAtIndex: anIndex - 1 fromDropHandle: dropHandle)].	pointBuffer := self POINT gcMalloc.	inClient := self DragQueryPoint: dropHandle with: pointBuffer.	point := (pointBuffer memberAt: #x)				@ (pointBuffer memberAt: #y).	WinDropObject		onFiles: oc		cursorPoint: point		dropInClient: inClient = 1]		ensure: [self DragFinish: dropHandle]</body></methods><methods><class-id>OS.MinimalShellInterface</class-id> <category>private</category><body package="Windows Goodies">extractFileAtIndex: anIndex fromDropHandle: dropHandle 	| bufferSize buffer |	bufferSize := self				DragQueryFile: dropHandle				with: anIndex				with: nil				with: 0.	buffer := CIntegerType unsignedShort pointerType gcMalloc: bufferSize + 1.	self		DragQueryFile: dropHandle		with: anIndex		with: buffer		with: bufferSize + 1.	^buffer copyUnicodeStringFromHeap</body><body package="Windows Goodies">numOfFilesDroppedFrom: aDropHandle 	"Return the number of files droped from aDropHandle"	^self		DragQueryFile: aDropHandle		with: self QUERY_NUM_OF_FILES		with: nil		with: 0</body></methods><methods><class-id>OS.MinimalShellInterface class</class-id> <category>utilities</category><body package="Windows Goodies">hasAssociation: aFile 	"self hasAssociation: 'team1.html'"	"self hasAssociation: '41773.st'"	| xif lpResult returnValue |	xif := self new.	lpResult := CIntegerType char gcMalloc: 256.	returnValue := xif				FindExecutable: aFile				with: nil				with: lpResult.	^returnValue asInteger &gt; 32</body><body package="Windows Goodies">openFile: aFilename 	"self openFile: 'c:\windows\readme.txt'"	"self openFile: 'team1.html'"	| xif hwnd |	xif := self new.	hwnd := xif HWND cast: ScheduledControllers activeController view windowHandle.	^xif		ShellExecute: hwnd		with: 'open'		with: aFilename asString		with: nil		with: nil		with: xif SW_SHOWNORMAL</body><body package="Windows Goodies">openFile: aFilename from: aWindow	"self openFile: 'c:\windows\readme.txt'"	"self openFile: 'team1.html'"	| xif hwnd |	xif := self new.	hwnd := xif HWND cast: aWindow controller view windowHandle.	^xif		ShellExecute: hwnd		with: 'open'		with: aFilename asString		with: nil		with: nil		with: xif SW_SHOWNORMAL</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>event driven events</category><body package="Windows Goodies">unknownEvent: anEvent	super unknownEvent: anEvent.	"Am I a WM_ENDSESSION? -- might also want to check the platform here	if you are going to be run on non-windows platforms!"	((anEvent at: 10)  longAt: 9) = 22 ifTrue: 		["Report a special shutdown event for my dependents to handle"		self reportWindowEvent: #shutdownEvent with: anEvent].		"Am I a WM_DROPFILES? -- might also want to check the platform here	if you are going to be run on non-windows platforms!"	((anEvent at: 10)  longAt: 9) = 563 ifTrue: 		["Report a special drop event for my dependents to handle"		self reportWindowEvent: #wm_dropfiles with: anEvent].	self reportWindowEvent: #eventUnknown with: anEvent.	^nil</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="Windows Goodies">hasAssociatedApplication	self errorReporter unsupportedOperationSignal raise</body><body package="Windows Goodies">startAssociatedApplication	self errorReporter unsupportedOperationSignal raise</body></methods><methods><class-id>OS.Win32SystemSupport class</class-id> <category>utilities</category><body package="Windows Goodies">getLogicalDrives	"Returns an OrderedCollection of volumes or nil if an error occured."	"self getLogicalDrives"	| xif bitValue aStream oc |	xif := self new.	bitValue := [xif GetLogicalDrives] on: Error do: [:ex | nil].	bitValue isNil ifTrue: [^nil].	aStream := #($A $B $C $D $E $F $G $H $I $J $K $L $M $N $O $P $Q $R $S $T $U $V $W $X $Y $Z) readStream.	oc := OrderedCollection new.	[bitValue = 0] whileFalse: 			[(bitValue bitAnd: 1) = 1 				ifTrue: [oc add: aStream next]				ifFalse: [aStream next].			bitValue := bitValue bitShift: -1].	^oc collect: 			[:aChar | 			String 				with: aChar				with: $:				with: PCFilename separator]</body><body package="Windows Goodies">spacesForVolume: aVolume	"Return either an Array free space information about aVolume.  Note, that aVolume should have a 	 trailing slash."		"self concreteClass spacesForVolume: 'c:\'"	| xif freeBytesToCaller totalBytes freeBytes result |	xif := self new.	freeBytesToCaller := xif ULARGE_INTEGER gcMalloc.	totalBytes := xif ULARGE_INTEGER gcMalloc.	freeBytes := xif ULARGE_INTEGER gcMalloc.	result := xif 					GetDiskFreeSpaceEx: aVolume gcCopyToHeap					with: freeBytesToCaller					with: totalBytes					with: freeBytes.	^result = 0 		ifTrue: [nil]		ifFalse:			[Array 				with: freeBytesToCaller contents 				with: totalBytes contents 				with: freeBytes contents]</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>types</category><body package="Windows Goodies">HICON	&lt;C: typedef HANDLE HICON&gt;</body><body package="Windows Goodies">HINSTANCE	&lt;C: typedef HANDLE HINSTANCE&gt;</body><body package="Windows Goodies">HMODULE	&lt;C: typedef HANDLE HMODULE&gt;</body><body package="Windows Goodies">PULARGE_INTEGER	&lt;C: typedef ULARGE_INTEGER * PULARGE_INTEGER&gt;</body><body package="Windows Goodies">ULARGE_INTEGER	&lt;C: typedef unsigned __int64  ULARGE_INTEGER&gt;</body></methods><methods><class-id>OS.PCFilename class</class-id> <category>utilities</category><body package="Windows Goodies">volumesAndSpaces	| data |	data := Dictionary new.	self volumes collect: 		[:volume | data at: volume put: (OSSystemSupport concreteClass spacesForVolume: volume)].	^data</body></methods><methods><class-id>OS.PCFilename</class-id> <category>utilities</category><body package="Windows Goodies">hasAssociatedApplication	^MinimalShellInterface hasAssociation: self asString</body><body package="Windows Goodies">startAssociatedApplication	"On the various MS-Windows operating systems one is provided with the ability to register file extensions with specific appliations.  When double-clicking these applications in the explorer, that registered application starts up.  For example clicking on a file that has the name of readme.txt might cause notepad to start and load that file.  With this method, the receiver will try to invoke the shell interface and open up the registered application.  Note, that a client has no control over the process was spawned so you will not get notified if the application has quit.  IF this is the level of control that you are looking for, then go visit the OSSystemSupport hierarchy and the CreateProcess functions.  If all you want to do is open up the registered applicatin for this file, then this will do it."	^MinimalShellInterface openFile: self asString</body></methods><initialize><class-id>OS.FileDropManager</class-id></initialize><initialize><class-id>Examples.MyFileBrowser</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FileBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName list myPattern selectionState autoRead lastModified currentFileEncoding defaultEncodings patternAspect menuBar showFullPath isDirty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>PCFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>SimpleView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>FileBrowser</name><environment>Tools.FileTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryTreeHolder patternChoices fileListHolder patternHolder fileSelectionChannel currentViewer statusTextRightHolder statusTextLeftHolder viewerListHolder menuBarHolder encodingChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class></st-source>