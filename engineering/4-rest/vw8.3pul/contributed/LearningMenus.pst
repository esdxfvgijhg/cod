<?xml version="1.0"?><st-source><!-- Name: LearningMenusComment: 19/11/02 Michael Lucas-SmithFirst release. This package re-orders your menus and menu groups depending on which items you use the most. The more you use a menu item, the higher it's score gets.Menu items only shuffle around inside of menu groups (items between - -'s) and menu groups shuffle up and down depending on how much you use them.For popup menus things seem to be working well, but I'm not sure about menu bar menus.. which is why I'm releasing it as 'to review'.Be warned, when you first load it, your menus may be disorderly. Once you start using them, they'll end up in the most 'used' order.Thanks to all the contributors. Troy, Travis, James and thanks to everyone who liked the idea :)DbIdentifier: psql_public_cstDbTrace: 7454PackageName: LearningMenusParcel: #('LearningMenus')PrintStringCache: (1.14,jamesr)Pre-Load Block: 	[:package | UISettings preferenceFor: #useLearningMenus put: true]Date: 5:34:10 pm November 24, 2002 --><time-stamp>From VisualWorksÂ®, Release 7 of June 14, 2002 on November 24, 2002 at 5:34:10 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><shared-variable><name>MenuScores</name><environment>UI.MenuView</environment><private>false</private><constant>false</constant><category>LearningMenus</category><initializer>Dictionary new</initializer><attributes><package>LearningMenus</package></attributes></shared-variable><methods><class-id>UI.MenuView class</class-id> <category>private-learning menus</category><body package="LearningMenus">decayMenuScores	| tooSmall |	"Transcript cr; show: 'decaying menu scores...'."	self menuScores 		keysAndValuesDo: [:key :value | MenuScores at: key put: value * 0.9995].	tooSmall := MenuScores keys select: [:each | (MenuScores at: each) &lt; 0.0001].	tooSmall do: [:each |		"Transcript cr; show: 'retiring: ', each."		MenuScores removeKey: each]</body></methods><methods><class-id>UI.MenuView class</class-id> <category>API-learning menus</category><body package="LearningMenus">dontUseLearningMenus	UISettings preferenceFor: #useLearningMenus put: false</body></methods><methods><class-id>UI.MenuView class</class-id> <category>learning menus</category><body package="LearningMenus">hasScoredMenu: aString 	"Transcript cr; show: 'score for ', aMenuItem, ' is ', (self menuScores at: aMenuItem ifAbsent: [0]) printString."	^self menuScores includesKey: aString</body></methods><methods><class-id>UI.MenuView class</class-id> <category>privileged-learning menus</category><body package="LearningMenus">increaseMenuScore: aString 	"Transcript cr; show: 'increased score for ', aString."	self decayMenuScores.	self menuScores at: aString		put: (self menuScores at: aString ifAbsent: [0]) + 1</body></methods><methods><class-id>UI.MenuView class</class-id> <category>initialize-release</category><body package="LearningMenus">initialize	"MenuView initialize"	(ObjectMemory dependents includes: self) 		ifTrue: [ObjectMemory removeDependent: self].	ObjectMemory addDependent: self.	UI.UISettings addPreferenceSection: #addLearningMenusSectionTo:development:runtime:.</body></methods><methods><class-id>UI.MenuView class</class-id> <category>learning menus</category><body package="LearningMenus">menuScores	^MenuScores ifNil: [MenuScores := Dictionary new]</body></methods><methods><class-id>UI.MenuView class</class-id> <category>initialize-release</category><body package="LearningMenus">obsolete	"MenuView obsolete"	(ObjectMemory dependents includes: self) 		ifTrue: [ObjectMemory removeDependent: self].	UI.UISettings removePreferenceSection: #addLearningMenusSectionTo:development:runtime:</body></methods><methods><class-id>UI.MenuView class</class-id> <category>privileged-learning menus</category><body package="LearningMenus">readScores	| rs count key |	self scoreFilename exists ifFalse: [^self].	rs := self scoreFilename readStream.		[[rs atEnd] whileFalse: 			[count := (rs upTo: Character tab) asNumber.			key := rs upTo: Character cr.			self menuScores at: key put: count]] 			ensure: [rs close]</body></methods><methods><class-id>UI.MenuView class</class-id> <category>API-learning menus</category><body package="LearningMenus">resetLearningMenus	^MenuScores := nil</body></methods><methods><class-id>UI.MenuView class</class-id> <category>privileged-learning menus</category><body package="LearningMenus">scoreFilename	^(UISettings preferenceFor: #learningMenusPreferencesFilename) asFilename</body><body package="LearningMenus">scoreMenu: aString 	"Transcript cr; show: 'score for ', aString, ' is ', (self menuScores at: aString ifAbsent: [0]) printString."	^self menuScores at: aString ifAbsent: [0]</body></methods><methods><class-id>UI.MenuView class</class-id> <category>learning menus</category><body package="LearningMenus">setMenuScoresFrom: aDict	MenuScores := aDict.</body></methods><methods><class-id>UI.MenuView class</class-id> <category>API-learning menus</category><body package="LearningMenus">shouldUseLearningMenus	^(UISettings preferenceFor: #useLearningMenus)</body></methods><methods><class-id>UI.MenuView class</class-id> <category>events</category><body package="LearningMenus">update: anAspect with: arguments from: anObject 	anAspect == #aboutToQuit ifTrue: [^self writeScores].	anAspect == #returnFromSnapshot ifTrue: [^self readScores]</body></methods><methods><class-id>UI.MenuView class</class-id> <category>API-learning menus</category><body package="LearningMenus">useLearningMenus	UISettings preferenceFor: #useLearningMenus put: true</body></methods><methods><class-id>UI.MenuView class</class-id> <category>privileged-learning menus</category><body package="LearningMenus">writeScores	| ws |	ws := self scoreFilename writeStream.		[self menuScores keysAndValuesDo: 			[:key :count | 			ws				print: count;				tab;				nextPutAll: key;				cr]] 			ensure: [ws close]</body></methods><methods><class-id>UI.MenuView</class-id> <category>protected-menu item views</category><body package="LearningMenus">buildMenuItemViews	menuItemViews := self menu visibleMenuItemGroups collect: [:eachGroup | self menuItemViewsForGroup: eachGroup]</body></methods><methods><class-id>UI.MenuView</class-id> <category>private</category><body package="LearningMenus">increaseMenuScore: aMenuViewOrItem	self class increaseMenuScore: aMenuViewOrItem learningMenusScoringKey</body></methods><methods><class-id>UI.MenuView</class-id> <category>protected-menu item views</category><body package="LearningMenus">learntMenuItemViews	"Answer the collection of groups (collections) of menuItemViews for the receiver."	| sortScores |	menuItemViews == nil ifTrue: [self buildMenuItemViews].	sortScores := self menuItemViewSortScores.	SequenceableCollectionSorter sort: menuItemViews using: [:a :b | (sortScores at: a) &gt; (sortScores at: b)].	^menuItemViews</body><body package="LearningMenus">menuItemViews	"Answer the collection of groups (collections) of menuItemViews for the receiver."	^self class shouldUseLearningMenus		ifTrue:	[self learntMenuItemViews]		ifFalse:	[self originalMenuItemViews]</body><body package="LearningMenus">menuItemViewsForGroup: aCollectionOfMenuItems 	| views toSort |	views := self menuItemViewsForMenuItems: aCollectionOfMenuItems.	(toSort := self scoreableMenuItemViews: views) isEmpty ifTrue: [^views].	views := views reject: [:each | toSort includes: each].	SequenceableCollectionSorter sort: toSort using: [:a :b | (self scoreItemView: a) &gt; (self scoreItemView: b)].	^toSort , views</body><body package="LearningMenus">menuItemViewsForMenuItems: aCollectionOfMenuItems 	^aCollectionOfMenuItems collect: [:eachMenuItem | self menuItemViewForMenuItem: eachMenuItem]</body><body package="LearningMenus">menuItemViewSortScores	| sortKeys |	sortKeys := Dictionary new.	menuItemViews keysAndValuesDo: 			[:index :viewGroup | 			| score |			score := self scoreViewGroup: viewGroup.			sortKeys at: viewGroup				put: (score isZero ifTrue: [index negated] ifFalse: [score])].	^sortKeys</body><body package="LearningMenus">originalMenuItemViews	"Answer the collection of groups (collections) of menuItemViews for the receiver."	menuItemViews == nil ifTrue: [		menuItemViews := self menu visibleMenuItemGroups collect: [:eachGroup |			eachGroup collect: [:eachMenuItem |				self menuItemViewForMenuItem: eachMenuItem]]].	^menuItemViews</body><body package="LearningMenus">scoreableMenuItemViews: views 	^views select: [:each | self class hasScoredMenu: each learningMenusScoringKey]</body></methods><methods><class-id>UI.MenuView</class-id> <category>private</category><body package="LearningMenus">scoreItemView: aMenuItemView 	^self class scoreMenu: aMenuItemView learningMenusScoringKey</body><body package="LearningMenus">scoreViewGroup: aCollectionOfItemViews 	aCollectionOfItemViews isEmpty ifTrue: [^0].	^(aCollectionOfItemViews inject: 0		into: [:accum :eachView | accum + (self scoreItemView: eachView)]) 			/ aCollectionOfItemViews size</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-current selection</category><body package="LearningMenus">selectedMenuItem: aMenuItem 	"aMenuItem was fully selected by the user.  This message is sent by the MenuItemView."	self menu selectionMemory: aMenuItem.	self increaseMenuScore: aMenuItem.	selectedValue := aMenuItem.	selectionFinal := true.	self parentMenuItemView ifNil: [^self].	self parentMenuItemView menuView increaseMenuScore: self parentMenuItemView</body></methods><methods><class-id>UI.MenuBar</class-id> <category>private</category><body package="LearningMenus">layoutComponentsForBounds: newBounds 	"The receiver has been sized to the given parameters.  	Re-layout all of the receiver's components."	| offset x top h itemsOnLine |	offset := self leftSpace.	offset &gt; newBounds width ifTrue: [offset := 0].	x := offset.	top := self extraSpaceTop.	h := 0.	itemsOnLine := 0.	self rankedComponents do: 			[:component | 			| box  ch itemBox |			itemBox := component preferredBounds.			ch := itemBox height.			h := h max: ch.			box := x @ top 						extent: ((itemBox width max: self minimumItemWidth) 								min: self maximumItemWidth) @ ch.			box right &gt; newBounds right 				ifTrue: 					[x := offset.					top := top + h + self extraSpaceBetweenLines.					itemsOnLine = 0 						ifFalse: 							[box moveTo: x @ top.							h := ch.							x := x + self spaceBetweenItems + box width]						ifTrue: [h := 0].					itemsOnLine := 1]				ifFalse: 					[h := h max: ch.					itemsOnLine := itemsOnLine + 1.					x := x + self spaceBetweenItems + box width].			component bounds: box].	self computePreferredBounds.	preferredBounds bottom: preferredBounds bottom + extraSpaceBottom</body><body package="LearningMenus">rankedComponents	| sortKeys sorted |	MenuView shouldUseLearningMenus ifFalse: [^components].	sortKeys := Dictionary new.	components keysAndValuesDo: 			[:index :wrapper | 			| score |			score := MenuView 						scoreMenu: wrapper bottomComponent learningMenusScoringKey.			sortKeys at: wrapper				put: (score isZero ifTrue: [index negated] ifFalse: [score])].	sorted := components copy.	SequenceableCollectionSorter sort: sorted		using: [:a :b | (sortKeys at: a) &gt; (sortKeys at: b)].	^sorted</body></methods><methods><class-id>UI.MenuItem</class-id> <category>value</category><body package="LearningMenus">learningMenusScoringKey	^self label</body></methods><methods><class-id>UI.MenuItemView</class-id> <category>value</category><body package="LearningMenus">learningMenusScoringKey	^self composedLabel text string</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="LearningMenus">addLearningMenusSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs 	"Wire up action methods for buttons..."	aDictionary at: #learningMenusAccept put: [self learningMenusAccept].	aDictionary at: #learningMenusReset put: [self learningMenusReset].	aDictionary at: #learningMenusPreferencesFileBrowse put: [self learningMenusPreferencesFileBrowse].	aDictionary at: #learningMenusPreferencesForget put: [self learningMenuPreferencesForget].	"Wire up aspects..."	aDictionary at: #useLearningMenus put: (true asValue).	aDictionary at: #learningMenusPreferencesFilename put: ('LearningMenuScores.txt' asValue).	"Connect the settings tool page..."	devSpecs add: 'Learning Menus' 				-&gt; #(#learningMenusSettingSpec #helpAction).	runtimeSpecs add: 'Learning Menus' 				-&gt; #(#learningMenusSettingSpec #helpAction)</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="LearningMenus">browseForLearnedMenuPreferencesFile	"This stub method was generated by UIDefiner"	^self</body><body package="LearningMenus">forgetLearnedMenuPreferences	"This stub method was generated by UIDefiner"	^self</body><body package="LearningMenus">learningMenuPreferencesForget	"This stub method was generated by UIDefiner"	^self</body><body package="LearningMenus">learningMenusAccept	"This stub method was generated by UIDefiner"	^self</body><body package="LearningMenus">learningMenusPreferencesFileBrowse	"This stub method was generated by UIDefiner"	^self</body><body package="LearningMenus">learningMenusReset	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UI.MenuBarButtonController</class-id> <category>private-menu processor</category><body package="LearningMenus">dispatchMenuSelection: menuSelection 	"A menu pick was made.	Dispatch the selection by using the following rule.		1. If the menuSelection is a symbol use it as the argument of perform:			with the menuMessageReceiver as the receiver.		2. If the menuSelection is a BlockClosure send value: and pass self (the Controller)			as argument.		3. Assume the performer is a ValueModel."	self sensor window keyboardProcessor checkForAutoAccept == false 		ifTrue: [^self].	MenuView increaseMenuScore: self view learningMenusScoringKey.	self view menuBar bounds: self view menuBar bounds.	self view menuBar invalidate.	menuSelection isSymbol ifTrue: [^self dispatchMenuSymbol: menuSelection].	menuSelection class == BlockClosure 		ifTrue: [^self dispatchBlockClosure: menuSelection].	(self performer respondsTo: #value:) 		ifTrue: 			[self requestValueChange 				ifTrue: 					[self performer value: menuSelection.					self valueChange]]</body></methods><methods><class-id>UI.MenuBarButtonView</class-id> <category>menu</category><body package="LearningMenus">learningMenusScoringKey	^'menuBar', self label text string</body></methods><methods><class-id>UI.UISettings class</class-id> <category>interface specs</category><body package="LearningMenus">learningMenusSettingSpec	"UIPainter new openOnClass: self andSelector: #learningMenusSettingSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 287 154 763 502 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 23 21 ) 					#name: #CheckBox1 					#model: #useLearningMenus 					#label: 'Use Learning Menus' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 170 0 270 23 ) 							#name: #InputField1 							#model: #learningMenusPreferencesFilename ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 2 ) 							#name: #Label1 							#label: 'Learning Menus Preferences File:' ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 0 40 270 64 ) 							#name: #ActionButton1 							#model: #learningMenusPreferencesFileBrowse 							#label: 'Browse for Learning Menus Preferences File' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 0 77 270 101 ) 							#name: #ActionButton4 							#model: #learningMenusPreferencesForget 							#label: 'Forget Learned Preferences' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 35 58 305 159 ) 						#name: #Composite1 ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 24 44 323 178 ) 					#name: #GroupBox1 ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 0 0 81 23 ) 							#name: #ActionButton2 							#flags: 40 							#model: #learningMenusAccept 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #undisturb ) 							#label: 'Accept' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 109 0 190 23 ) 							#name: #ActionButton3 							#flags: 40 							#model: #earningMenusReset 							#label: 'Reset' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 218 0 299 23 ) 							#name: #helpAction 							#label: 'Help' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 22 191 321 214 ) 						#name: #Composite2 ) ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>MenuBarButtonController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>MenuItem</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabled label adornment nameKey value position helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>MenuBar</name><environment>UI</environment><super>UI.ComposingComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuChannel performer menuButtons nextMenuButton </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>MenuView</name><environment>UI</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuItemViews parentMenuItemView selectedValue selectionFinal highlightedMenuItemView usedSelectionMemory parentMenuBarButtonView commonTextIndent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>MenuItemView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>MenuBarButtonView</name><environment>UI</environment><super>UI.PushButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder menuBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class></st-source>