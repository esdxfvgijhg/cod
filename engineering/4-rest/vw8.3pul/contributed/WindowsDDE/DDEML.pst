<?xml version="1.0"?><st-source><!-- Name: DDEMLComment: This parcel provides an interface to Microsoft Corporation's Dynamic Data Exchange Management Library (DDEML) protocol.DbIdentifier: bear73DbTrace: 368883DbUsername: nrossDbVersion: 7.9 - 1DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))PackageName: DDEMLParcel: #('DDEML')ParcelName: DDEMLPrintStringCache: (7.9 - 1,nross)Version: 7.9 - 1Date: 10:57:03 AM April 13, 2012 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.9 (apr12.1) of April 13, 2012 on April 13, 2012 at 10:57:03 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DdemlPort</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceID ddeCallback </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.DdemlPortDictionary.*			</imports><category>OS-DDEML</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DDEML</package></attributes></class><comment><class-id>OS.DdemlPort</class-id><body>DdemlPort is an abstract class for server and client objects that utilize Microsoft Corporation's Dynamic Data Exchange Management Library (DDEML) protocol.  Dynamic Data Exchange is a form of interprocess communication that utilizes shared memory to exchange data between applications.  Applications can use DDE for synchronous and asynchronous data transfer.  Transfers can be one-time or continuing conversations.DDEML is Microsoft's API developed to simplify the task of adding DDE capability to a Windows application.  It supports interaction between client and server applications.  Clients initiate data exchange by requesting data or services from a Server.  A server can have multiple clients simultaneously, and a Client can request data from multiple servers.Two subclasses of DdemlPort -- DdemlClient and DdemlServer -- are abstract classes encapsulating the behavior of DDE clients and servers.  See their class comments for information on creating Client and Server objects.Instance Variables:	instanceID &lt;Integer&gt; An integer identifiying the instance with the DDEML machinery.	ddeCallback	&lt;CCallback&gt;	DDEML callback function.Subclasses must implement methods for 	instance protocol		accessing			commandAndFilterFlags		dispatching			dispatchDDEMessage:with:with:with:with:with:with:with:Class Variables:	OpenPorts	&lt;HandleRegistry&gt; Registry for all Port connections.Pool Dictionaries:	DdemlPortDictionary	&lt;ExternalDictionary&gt; Interface to DDEML DLL.</body></comment><class><name>DdemlMonitor</name><environment>OS</environment><super>OS.DdemlPort</super><private>false</private><indexed-type>none</indexed-type><inst-vars>monitorFlags transcript </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.DdemlMonitorDictionary.*			</imports><category>OS-DDEML</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DDEML</package></attributes></class><comment><class-id>OS.DdemlMonitor</class-id><body>DdemlMonitor is used to monitor Dynamic Data Exchange transactions.  Instances of DdemlMonitor are notified whenever a DDE event occurs, passing information about the event to the monitor's callback block.  DdemlMonitorUI provides a user interface to the record of transactions.Instance Variables:	monitorFlags &lt;Integer&gt; A set of flags indicating which DDE messages should be monitored.	transcript &lt;TextCollector&gt; Any object implementing the #show: or #print: protocol.  Usually an instance of TextCollector.</body></comment><class><name>DdemlServer</name><environment>OS</environment><super>OS.DdemlPort</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceName </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.DdemlServerDictionary.*			</imports><category>OS-DDEML</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DDEML</package></attributes></class><comment><class-id>OS.DdemlServer</class-id><body>DdemlServer is an abstract class for DDE servers.  A server is responsible for processing data requests and service requests from various clients.  A DDE server uses a three-tier hierarchy to identify its services and data:	Service name - String (formerly called "application name")	Topic name - String that identifies a logical data context	Item name -  String that uniquely identifies dataInstance Variables:	serviceName	&lt;String&gt;	Registered server name.Subclasses should override the default behavior of the following transactions:	instance protocol		transactions			ddeAdvReq:conversation:topic:item:data:			ddeAdvStart:conversation:topic:item:			ddeAdvStop:conversation:topic:item:			ddeConnect:service:context:serverAppInstance:			ddeConnectConfirm:topic:service:serviceAppInstance:			ddeDisconnect:sameAppInstance:			ddeError:errorCode:			ddeExecute:topic:command:			ddeMask:conversation:string1:string2:data:data1:data2:			ddePoke:conversation:topic:item:data:			ddeRegister:instService:			ddeRequest:conversation:topic:item:			ddeShift:conversation:string1:string2:data:data1:data2:			ddeUnregister:instService:			ddeWildConnect:service:convData:appInst:	class protocol		accessing			serviceName</body></comment><class><name>DdemlClient</name><environment>OS</environment><super>OS.DdemlPort</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conversationID multipleConversations </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.DdemlClientDictionary.*			</imports><category>OS-DDEML</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DDEML</package></attributes></class><comment><class-id>OS.DdemlClient</class-id><body>DdemlClient is an abstract class for all Dynamic Data Exchange (DDE) clients.  A DDE client requests data and services from a DDE server.  Data and services are specified using a three-tier hierarchy	Service name - String (formerly called "application name")	Topic name - String that identifies a logical data context	Item name -  String that uniquely identifies dataInstance Variables	conversationID &lt;SmallInteger|nil&gt; Handle identifying the client instance registered with the DDEML library.	multipleConversations &lt;Boolean&gt; True if the client instance is involved in multiple conversations.Subclasses should override the default behavior of the following transactions:	instance protocol		transactions			ddeAdvData:conversation:topic:item:data:			ddeDisconnect:sameAppInstance:			ddeError:errorCode:			ddeMask:conversation:string1:string2:data:data1:data2:			ddeRegister:instService:			ddeShift:conversation:string1:string2:data:data1:data2:			ddeUnregister:instService:			ddeXactComplete:conversation:topic:item:data:data1:data2:</body></comment><class><name>DdemlDataHandle</name><environment>OS</environment><super>OS.OSHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type instanceID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-DDEML</category><attributes><package>DDEML</package></attributes></class><comment><class-id>OS.DdemlDataHandle</class-id><body>DdemlDataHandle represents an application-generated handle reference to either a String or Data object.  The data handle must be freed by the application when it is no longer in use -- this class provides that mechanism.Instance Variables	type	&lt;Symbol&gt;	#string or #data indicating the handle was created by DdeCreateStringHandle or DdeCreateDataHandle	instanceID &lt;Integer&gt; an integer ID indicating the conversation instance that created the data handleClass Variables	OpenDataHandles	&lt;HandleRegistry&gt;	registry of open DDE data handles</body></comment><class><name>DdemlMonitorUI</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ddemlMonitor callbacks conservations links sendMsgs stringHandles errors postMsgs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-DDEML</category><attributes><package>DDEML</package></attributes></class><comment><class-id>Tools.DdemlMonitorUI</class-id><body>DdemlMonitorUI provides a transcript of events derived from a DdeMonitor.Instance Variables:	ddemlMonitor	&lt;DdemlMonitor&gt;	the monitor collecting events	callbacks		&lt;PluggableAdaptor&gt;	adaptor for turning on or off recording of callbacks	conservations	&lt;PluggableAdaptor&gt;	adaptor for turning on or off recording of conservations	links			&lt;PluggableAdaptor&gt;	adaptor for turning on or off recording of links	sendMsgs		&lt;PluggableAdaptor&gt;	adaptor for turning on or off recording of sendMsgs	stringHandles	&lt;PluggableAdaptor&gt;	adaptor for turning on or off recording of stringHandles	errors			&lt;PluggableAdaptor&gt;	adaptor for turning on or off recording of errors	postMsgs		&lt;PluggableAdaptor&gt;	adaptor for turning on or off recording of postMsgs</body></comment><shared-variable><name>OpenPorts</name><environment>OS.DdemlPort</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DDEML</package></attributes></shared-variable><shared-variable><name>OpenDataHandles</name><environment>OS.DdemlDataHandle</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DDEML</package></attributes></shared-variable><shared-variable><name>DdemlPortDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DDEML</package></attributes></shared-variable><shared-variable><name>DdemlMonitorDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DDEML</package></attributes></shared-variable><shared-variable><name>DdemlServerDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DDEML</package></attributes></shared-variable><shared-variable><name>DdemlClientDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DDEML</package></attributes></shared-variable><methods><class-id>OS.DdemlPort</class-id> <category>types</category><body package="DDEML">BOOL	&lt;C: typedef int BOOL&gt;</body><body package="DDEML">BOOLEAN	&lt;C: typedef BYTE BOOLEAN&gt;</body><body package="DDEML">BYTE	&lt;C: typedef unsigned char BYTE&gt;</body><body package="DDEML">CHAR	&lt;C: typedef char CHAR&gt;</body><body package="DDEML">CONVCONTEXT	&lt;C: typedef struct tagCONVCONTEXT CONVCONTEXT&gt;</body><body package="DDEML">CONVINFO	&lt;C: typedef struct tagCONVINFO CONVINFO&gt;</body><body package="DDEML">DWORD	&lt;C: typedef unsigned long DWORD&gt;</body><body package="DDEML">HANDLE	&lt;C: typedef PVOID HANDLE&gt;</body><body package="DDEML">HCONV	&lt;C: typedef DWORD HCONV&gt;</body><body package="DDEML">HCONVLIST	&lt;C: typedef DWORD HCONVLIST&gt;</body><body package="DDEML">HDDEDATA	&lt;C: typedef DWORD HDDEDATA&gt;</body><body package="DDEML">HSZ	&lt;C: typedef DWORD HSZ&gt;</body><body package="DDEML">HWND	&lt;C: typedef HANDLE HWND&gt;</body><body package="DDEML">LPBYTE	&lt;C: typedef BYTE * LPBYTE&gt;</body><body package="DDEML">LPDWORD	&lt;C: typedef DWORD * LPDWORD&gt;</body><body package="DDEML">LPSTR	&lt;C: typedef CHAR * LPSTR&gt;</body><body package="DDEML">LPWSTR	&lt;C: typedef WCHAR * LPWSTR&gt;</body><body package="DDEML">PCONVCONTEXT	&lt;C: typedef CONVCONTEXT * PCONVCONTEXT&gt;</body><body package="DDEML">PCONVINFO	&lt;C: typedef CONVINFO * PCONVINFO&gt;</body><body package="DDEML">PFNCALLBACK	&lt;C: typedef HDDEDATA (_stdcall * PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv, HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2)&gt;</body><body package="DDEML">PSECURITY_QUALITY_OF_SERVICE	&lt;C: typedef struct _SECURITY_QUALITY_OF_SERVICE * PSECURITY_QUALITY_OF_SERVICE&gt;</body><body package="DDEML">PVOID	&lt;C: typedef void * PVOID&gt;</body><body package="DDEML">SECURITY_CONTEXT_TRACKING_MODE	&lt;C: typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE&gt;</body><body package="DDEML">SECURITY_IMPERSONATION_LEVEL	&lt;C: typedef enum _SECURITY_IMPERSONATION_LEVEL SECURITY_IMPERSONATION_LEVEL&gt;</body><body package="DDEML">SECURITY_QUALITY_OF_SERVICE	&lt;C: typedef struct _SECURITY_QUALITY_OF_SERVICE SECURITY_QUALITY_OF_SERVICE&gt;</body><body package="DDEML">UINT	&lt;C: typedef unsigned int UINT&gt;</body><body package="DDEML">WCHAR	&lt;C: typedef wchar_t WCHAR&gt;</body><body package="DDEML">wchar_t	&lt;C: typedef unsigned short wchar_t&gt;</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>structs</category><body package="DDEML">_SECURITY_QUALITY_OF_SERVICE	&lt;C: struct _SECURITY_QUALITY_OF_SERVICE {			DWORD Length;			SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;			SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;			BOOLEAN EffectiveOnly;		}&gt;</body><body package="DDEML">tagCONVCONTEXT	&lt;C: struct tagCONVCONTEXT {			UINT cb, wFlags, wCountryID;			int iCodePage;			DWORD dwLangID, dwSecurity;			SECURITY_QUALITY_OF_SERVICE qos;		}&gt;</body><body package="DDEML">tagCONVINFO	&lt;C: struct tagCONVINFO {			DWORD cb, hUser;			HCONV hConvPartner;			HSZ hszSvcPartner, hszServiceReq, hszTopic, hszItem;			UINT wFmt, wType, wStatus, wConvst, wLastError;			HCONVLIST hConvList;			CONVCONTEXT ConvCtxt;			HWND hwnd, hwndPartner;		}&gt;</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>enums</category><body package="DDEML">_SECURITY_IMPERSONATION_LEVEL	&lt;C: enum _SECURITY_IMPERSONATION_LEVEL&gt;</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>finalization</category><body package="DDEML">actAsExecutor	"The receiver was created to be an executor for finalization, break all references."	ddeCallback := nil</body><body package="DDEML">executor	"Answer an executor of the receiver for use in Weak referencing objects."	| executor |	executor := super executor.	executor actAsExecutor.	^executor</body><body package="DDEML">finalize	"The receiver's proxy was removed from the system, break the DDE connection."	self instanceID == nil		ifFalse:			[DdemlDataHandle finalizeElementsFor: self instanceID.			self DdeUninitialize: self instanceID].	self instanceID: nil</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>defines</category><body package="DDEML">APPCLASS_MASK	&lt;C: #define APPCLASS_MASK 0x0000000F	&gt;</body><body package="DDEML">APPCLASS_MONITOR	&lt;C: #define APPCLASS_MONITOR 0x00000001	&gt;</body><body package="DDEML">APPCLASS_STANDARD	&lt;C: #define APPCLASS_STANDARD 0x00000000	&gt;</body><body package="DDEML">APPCMD_CLIENTONLY	&lt;C: #define APPCMD_CLIENTONLY 0x00000010	&gt;</body><body package="DDEML">APPCMD_FILTERINITS	&lt;C: #define APPCMD_FILTERINITS 0x00000020	&gt;</body><body package="DDEML">APPCMD_MASK	&lt;C: #define APPCMD_MASK 0x00000FF0	&gt;</body><body package="DDEML">CADV_LATEACK	&lt;C: #define CADV_LATEACK 65535	&gt;</body><body package="DDEML">CBF_FAIL_ADVISES	&lt;C: #define CBF_FAIL_ADVISES 0x00004000	&gt;</body><body package="DDEML">CBF_FAIL_ALLSVRXACTIONS	&lt;C: #define CBF_FAIL_ALLSVRXACTIONS 0x0003F000	&gt;</body><body package="DDEML">CBF_FAIL_CONNECTIONS	&lt;C: #define CBF_FAIL_CONNECTIONS 0x00002000	&gt;</body><body package="DDEML">CBF_FAIL_EXECUTES	&lt;C: #define CBF_FAIL_EXECUTES 0x00008000	&gt;</body><body package="DDEML">CBF_FAIL_POKES	&lt;C: #define CBF_FAIL_POKES 0x00010000	&gt;</body><body package="DDEML">CBF_FAIL_REQUESTS	&lt;C: #define CBF_FAIL_REQUESTS 0x00020000	&gt;</body><body package="DDEML">CBF_FAIL_SELFCONNECTIONS	&lt;C: #define CBF_FAIL_SELFCONNECTIONS 0x00001000	&gt;</body><body package="DDEML">CBF_SKIP_ALLNOTIFICATIONS	&lt;C: #define CBF_SKIP_ALLNOTIFICATIONS 0x003C0000	&gt;</body><body package="DDEML">CBF_SKIP_CONNECT_CONFIRMS	&lt;C: #define CBF_SKIP_CONNECT_CONFIRMS 0x00040000	&gt;</body><body package="DDEML">CBF_SKIP_DISCONNECTS	&lt;C: #define CBF_SKIP_DISCONNECTS 0x00200000	&gt;</body><body package="DDEML">CBF_SKIP_REGISTRATIONS	&lt;C: #define CBF_SKIP_REGISTRATIONS 0x00080000	&gt;</body><body package="DDEML">CBF_SKIP_UNREGISTRATIONS	&lt;C: #define CBF_SKIP_UNREGISTRATIONS 0x00100000	&gt;</body><body package="DDEML">CBR_BLOCK	&lt;C: #define CBR_BLOCK 0xffffffffL&gt;</body><body package="DDEML">CP_WINANSI	&lt;C: #define CP_WINANSI 1004	&gt;</body><body package="DDEML">CP_WINUNICODE	&lt;C: #define CP_WINUNICODE 1200	&gt;</body><body package="DDEML">DDE_FACK	&lt;C: #define DDE_FACK 32768	&gt;</body><body package="DDEML">DDE_FACKREQ	&lt;C: #define DDE_FACKREQ 32768	&gt;</body><body package="DDEML">DDE_FACKRESERVED	&lt;C: #define DDE_FACKRESERVED (~(DDE_FACK | DDE_FBUSY | DDE_FAPPSTATUS))	&gt;</body><body package="DDEML">DDE_FADVRESERVED	&lt;C: #define DDE_FADVRESERVED (~(DDE_FACKREQ | DDE_FDEFERUPD))	&gt;</body><body package="DDEML">DDE_FAPPSTATUS	&lt;C: #define DDE_FAPPSTATUS 0x00FF	&gt;</body><body package="DDEML">DDE_FBUSY	&lt;C: #define DDE_FBUSY 16384	&gt;</body><body package="DDEML">DDE_FDATRESERVED	&lt;C: #define DDE_FDATRESERVED (~(DDE_FACKREQ | DDE_FRELEASE | DDE_FREQUESTED))	&gt;</body><body package="DDEML">DDE_FDEFERUPD	&lt;C: #define DDE_FDEFERUPD 16384	&gt;</body><body package="DDEML">DDE_FNOTPROCESSED	&lt;C: #define DDE_FNOTPROCESSED 0x0000	&gt;</body><body package="DDEML">DDE_FPOKRESERVED	&lt;C: #define DDE_FPOKRESERVED (~(DDE_FRELEASE))	&gt;</body><body package="DDEML">DDE_FRELEASE	&lt;C: #define DDE_FRELEASE 8192	&gt;</body><body package="DDEML">DDE_FREQUESTED	&lt;C: #define DDE_FREQUESTED 4096	&gt;</body><body package="DDEML">DMLERR_ADVACKTIMEOUT	&lt;C: #define DMLERR_ADVACKTIMEOUT 16384	&gt;</body><body package="DDEML">DMLERR_BUSY	&lt;C: #define DMLERR_BUSY 16385	&gt;</body><body package="DDEML">DMLERR_DATAACKTIMEOUT	&lt;C: #define DMLERR_DATAACKTIMEOUT 16386	&gt;</body><body package="DDEML">DMLERR_DLL_NOT_INITIALIZED	&lt;C: #define DMLERR_DLL_NOT_INITIALIZED 16387	&gt;</body><body package="DDEML">DMLERR_DLL_USAGE	&lt;C: #define DMLERR_DLL_USAGE 16388	&gt;</body><body package="DDEML">DMLERR_EXECACKTIMEOUT	&lt;C: #define DMLERR_EXECACKTIMEOUT 16389	&gt;</body><body package="DDEML">DMLERR_FIRST	&lt;C: #define DMLERR_FIRST 16384	&gt;</body><body package="DDEML">DMLERR_INVALIDPARAMETER	&lt;C: #define DMLERR_INVALIDPARAMETER 16390	&gt;</body><body package="DDEML">DMLERR_LAST	&lt;C: #define DMLERR_LAST 16401	&gt;</body><body package="DDEML">DMLERR_LOW_MEMORY	&lt;C: #define DMLERR_LOW_MEMORY 16391	&gt;</body><body package="DDEML">DMLERR_MEMORY_ERROR	&lt;C: #define DMLERR_MEMORY_ERROR 16392	&gt;</body><body package="DDEML">DMLERR_NOTPROCESSED	&lt;C: #define DMLERR_NOTPROCESSED 16393	&gt;</body><body package="DDEML">DMLERR_NO_CONV_ESTABLISHED	&lt;C: #define DMLERR_NO_CONV_ESTABLISHED 16394	&gt;</body><body package="DDEML">DMLERR_NO_ERROR	&lt;C: #define DMLERR_NO_ERROR 0	&gt;</body><body package="DDEML">DMLERR_POKEACKTIMEOUT	&lt;C: #define DMLERR_POKEACKTIMEOUT 16395	&gt;</body><body package="DDEML">DMLERR_POSTMSG_FAILED	&lt;C: #define DMLERR_POSTMSG_FAILED 16396	&gt;</body><body package="DDEML">DMLERR_REENTRANCY	&lt;C: #define DMLERR_REENTRANCY 16397	&gt;</body><body package="DDEML">DMLERR_SERVER_DIED	&lt;C: #define DMLERR_SERVER_DIED 16398	&gt;</body><body package="DDEML">DMLERR_SYS_ERROR	&lt;C: #define DMLERR_SYS_ERROR 16399	&gt;</body><body package="DDEML">DMLERR_UNADVACKTIMEOUT	&lt;C: #define DMLERR_UNADVACKTIMEOUT 16400	&gt;</body><body package="DDEML">DMLERR_UNFOUND_QUEUE_ID	&lt;C: #define DMLERR_UNFOUND_QUEUE_ID 16401	&gt;</body><body package="DDEML">DNS_FILTEROFF	&lt;C: #define DNS_FILTEROFF 0x0008	&gt;</body><body package="DDEML">DNS_FILTERON	&lt;C: #define DNS_FILTERON 0x0004	&gt;</body><body package="DDEML">DNS_REGISTER	&lt;C: #define DNS_REGISTER 0x0001	&gt;</body><body package="DDEML">DNS_UNREGISTER	&lt;C: #define DNS_UNREGISTER 0x0002	&gt;</body><body package="DDEML">EC_DISABLE	&lt;C: #define EC_DISABLE ST_BLOCKED	&gt;</body><body package="DDEML">EC_ENABLEALL	&lt;C: #define EC_ENABLEALL 0	&gt;</body><body package="DDEML">EC_ENABLEONE	&lt;C: #define EC_ENABLEONE ST_BLOCKNEXT	&gt;</body><body package="DDEML">EC_QUERYWAITING	&lt;C: #define EC_QUERYWAITING 2	&gt;</body><body package="DDEML">HDATA_APPOWNED	&lt;C: #define HDATA_APPOWNED 0x0001	&gt;</body><body package="DDEML">MAX_MONITORS	&lt;C: #define MAX_MONITORS 4	&gt;</body><body package="DDEML">MF_CALLBACKS	&lt;C: #define MF_CALLBACKS 134217728	&gt;</body><body package="DDEML">MF_CONV	&lt;C: #define MF_CONV 1073741824	&gt;</body><body package="DDEML">MF_ERRORS	&lt;C: #define MF_ERRORS 268435456	&gt;</body><body package="DDEML">MF_HSZ_INFO	&lt;C: #define MF_HSZ_INFO 16777216	&gt;</body><body package="DDEML">MF_LINKS	&lt;C: #define MF_LINKS 536870912	&gt;</body><body package="DDEML">MF_MASK	&lt;C: #define MF_MASK 4278190080	&gt;</body><body package="DDEML">MF_POSTMSGS	&lt;C: #define MF_POSTMSGS 67108864	&gt;</body><body package="DDEML">MF_SENDMSGS	&lt;C: #define MF_SENDMSGS 33554432	&gt;</body><body package="DDEML">MH_CLEANUP	&lt;C: #define MH_CLEANUP 4	&gt;</body><body package="DDEML">MH_CREATE	&lt;C: #define MH_CREATE 1	&gt;</body><body package="DDEML">MH_DELETE	&lt;C: #define MH_DELETE 3	&gt;</body><body package="DDEML">MH_KEEP	&lt;C: #define MH_KEEP 2	&gt;</body><body package="DDEML">MSGF_DDEMGR	&lt;C: #define MSGF_DDEMGR 32769	&gt;</body><body package="DDEML">QID_SYNC	&lt;C: #define QID_SYNC 4294967295	&gt;</body><body package="DDEML">ST_ADVISE	&lt;C: #define ST_ADVISE 0x0002	&gt;</body><body package="DDEML">ST_BEGINSWP	&lt;C: #define ST_BEGINSWP 0	&gt;</body><body package="DDEML">ST_BLOCKED	&lt;C: #define ST_BLOCKED 0x0008	&gt;</body><body package="DDEML">ST_BLOCKNEXT	&lt;C: #define ST_BLOCKNEXT 0x0080	&gt;</body><body package="DDEML">ST_CLIENT	&lt;C: #define ST_CLIENT 0x0010	&gt;</body><body package="DDEML">ST_CONNECTED	&lt;C: #define ST_CONNECTED 0x0001	&gt;</body><body package="DDEML">ST_ENDSWP	&lt;C: #define ST_ENDSWP 1	&gt;</body><body package="DDEML">ST_INLIST	&lt;C: #define ST_INLIST 0x0040	&gt;</body><body package="DDEML">ST_ISLOCAL	&lt;C: #define ST_ISLOCAL 0x0004	&gt;</body><body package="DDEML">ST_ISSELF	&lt;C: #define ST_ISSELF 256	&gt;</body><body package="DDEML">ST_TERMINATED	&lt;C: #define ST_TERMINATED 0x0020	&gt;</body><body package="DDEML">SZDDESYS_ITEM_FORMATS	&lt;C: #define SZDDESYS_ITEM_FORMATS "Formats"	&gt;</body><body package="DDEML">SZDDESYS_ITEM_HELP	&lt;C: #define SZDDESYS_ITEM_HELP "Help"	&gt;</body><body package="DDEML">SZDDESYS_ITEM_RTNMSG	&lt;C: #define SZDDESYS_ITEM_RTNMSG "ReturnMessage"	&gt;</body><body package="DDEML">SZDDESYS_ITEM_STATUS	&lt;C: #define SZDDESYS_ITEM_STATUS "Status"	&gt;</body><body package="DDEML">SZDDESYS_ITEM_SYSITEMS	&lt;C: #define SZDDESYS_ITEM_SYSITEMS "SysItems"	&gt;</body><body package="DDEML">SZDDESYS_ITEM_TOPICS	&lt;C: #define SZDDESYS_ITEM_TOPICS "Topics"	&gt;</body><body package="DDEML">SZDDESYS_TOPIC	&lt;C: #define SZDDESYS_TOPIC "System"	&gt;</body><body package="DDEML">SZDDE_ITEM_ITEMLIST	&lt;C: #define SZDDE_ITEM_ITEMLIST "TopicItemList"	&gt;</body><body package="DDEML">TIMEOUT_ASYNC	&lt;C: #define TIMEOUT_ASYNC 4294967295	&gt;</body><body package="DDEML">XCLASS_BOOL	&lt;C: #define XCLASS_BOOL 0x1000&gt;</body><body package="DDEML">XCLASS_DATA	&lt;C: #define XCLASS_DATA 0x2000&gt;</body><body package="DDEML">XCLASS_FLAGS	&lt;C: #define XCLASS_FLAGS 0x4000&gt;</body><body package="DDEML">XCLASS_MASK	&lt;C: #define XCLASS_MASK 0xFC00&gt;</body><body package="DDEML">XCLASS_NOTIFICATION	&lt;C: #define XCLASS_NOTIFICATION 0x8000&gt;</body><body package="DDEML">XST_ADVACKRCVD	&lt;C: #define XST_ADVACKRCVD 13	&gt;</body><body package="DDEML">XST_ADVDATAACKRCVD	&lt;C: #define XST_ADVDATAACKRCVD 16	&gt;</body><body package="DDEML">XST_ADVDATASENT	&lt;C: #define XST_ADVDATASENT 15	&gt;</body><body package="DDEML">XST_ADVSENT	&lt;C: #define XST_ADVSENT 11	&gt;</body><body package="DDEML">XST_CONNECTED	&lt;C: #define XST_CONNECTED 2	&gt;</body><body package="DDEML">XST_DATARCVD	&lt;C: #define XST_DATARCVD 6	&gt;</body><body package="DDEML">XST_EXECACKRCVD	&lt;C: #define XST_EXECACKRCVD 10	&gt;</body><body package="DDEML">XST_EXECSENT	&lt;C: #define XST_EXECSENT 9	&gt;</body><body package="DDEML">XST_INCOMPLETE	&lt;C: #define XST_INCOMPLETE 1	&gt;</body><body package="DDEML">XST_INIT1	&lt;C: #define XST_INIT1 3	&gt;</body><body package="DDEML">XST_INIT2	&lt;C: #define XST_INIT2 4	&gt;</body><body package="DDEML">XST_NULL	&lt;C: #define XST_NULL 0	&gt;</body><body package="DDEML">XST_POKEACKRCVD	&lt;C: #define XST_POKEACKRCVD 8	&gt;</body><body package="DDEML">XST_POKESENT	&lt;C: #define XST_POKESENT 7	&gt;</body><body package="DDEML">XST_REQSENT	&lt;C: #define XST_REQSENT 5	&gt;</body><body package="DDEML">XST_UNADVACKRCVD	&lt;C: #define XST_UNADVACKRCVD 14	&gt;</body><body package="DDEML">XST_UNADVSENT	&lt;C: #define XST_UNADVSENT 12	&gt;</body><body package="DDEML">XTYPF_ACKREQ	&lt;C: #define XTYPF_ACKREQ 0x0008	&gt;</body><body package="DDEML">XTYPF_NOBLOCK	&lt;C: #define XTYPF_NOBLOCK 0x0002	&gt;</body><body package="DDEML">XTYPF_NODATA	&lt;C: #define XTYPF_NODATA 0x0004	&gt;</body><body package="DDEML">XTYP_ADVDATA	&lt;C: #define XTYP_ADVDATA (0x0010 | XCLASS_FLAGS)	&gt;</body><body package="DDEML">XTYP_ADVREQ	&lt;C: #define XTYP_ADVREQ (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_ADVSTART	&lt;C: #define XTYP_ADVSTART (0x0030 | XCLASS_BOOL)	&gt;</body><body package="DDEML">XTYP_ADVSTOP	&lt;C: #define XTYP_ADVSTOP (0x0040 | XCLASS_NOTIFICATION)	&gt;</body><body package="DDEML">XTYP_CONNECT	&lt;C: #define XTYP_CONNECT (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_CONNECT_CONFIRM	&lt;C: #define XTYP_CONNECT_CONFIRM (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_DISCONNECT	&lt;C: #define XTYP_DISCONNECT (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_ERROR	&lt;C: #define XTYP_ERROR (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_EXECUTE	&lt;C: #define XTYP_EXECUTE (0x0050 | XCLASS_FLAGS)	&gt;</body><body package="DDEML">XTYP_MASK	&lt;C: #define XTYP_MASK 0x00F0	&gt;</body><body package="DDEML">XTYP_MONITOR	&lt;C: #define XTYP_MONITOR (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_POKE	&lt;C: #define XTYP_POKE (0x0090 | XCLASS_FLAGS)	&gt;</body><body package="DDEML">XTYP_REGISTER	&lt;C: #define XTYP_REGISTER (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_REQUEST	&lt;C: #define XTYP_REQUEST (0x00B0 | XCLASS_DATA)	&gt;</body><body package="DDEML">XTYP_SHIFT	&lt;C: #define XTYP_SHIFT 4	&gt;</body><body package="DDEML">XTYP_UNREGISTER	&lt;C: #define XTYP_UNREGISTER (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_WILDCONNECT	&lt;C: #define XTYP_WILDCONNECT (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)	&gt;</body><body package="DDEML">XTYP_XACT_COMPLETE	&lt;C: #define XTYP_XACT_COMPLETE (0x0080 | XCLASS_NOTIFICATION)	&gt;</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>accessing</category><body package="DDEML">commandAndFilterFlags	"Answer the set of command and filter flags passed as the third argument to DdeInitialize function.  Command flags provide special instructions to the DdeInitialize function.  Filter flags set filters that prevent specific transactions from reaching the callback function.  Subclasses should override this message to implement various client/server configurations."	^0</body><body package="DDEML">defaultDataHandleClass	"Answer the class used to create proxy data handles for finalization."	^DdemlDataHandle</body><body package="DDEML">instanceID	"Answer the instance identifier for the receiver's DDE connection."	^instanceID</body><body package="DDEML">instanceID: aHandle	"Set the instance identifier for the receiver's DDE connection.  The instance ID is used by the DDEML library to identify an individual conversation connection."	instanceID := aHandle</body><body package="DDEML">key	"Answer the key that the receiver is to be registered under."	^self instanceID</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>dispatching</category><body package="DDEML">dispatchDDEMessage: wType with: wFormat with: hConversation with: hszString1 with: hszString2 with: hData with: dwData1 with: dwData2	"A message of type wType was received.  Send the appropriate message to the receiver based on wType.  Subclasses should override to dispatch relevant message types."	^self subclassResponsibility</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>data manipulation</category><body package="DDEML">hDataToString: hData	"Answer a String representation of the data indicated by the handle hData.  Answer nil if the convertion fails."	| length aString |	(length :=		(self DdeGetData: hData			with: nil 	"NULL pointer"			with: 0			with: 0)) = 0		ifTrue:			[Transcript show: 'DdeGetData failed.'.			^nil].	aString := self LPWSTR gcMalloc:  length  .	(self DdeGetData: hData		with: aString		with: length		with: 0) = 0		ifTrue:			[Transcript show: 'DdeGetData failed.'.			^nil].	^aString copyUnicodeStringFromHeap</body><body package="DDEML">hStringToData: aString	"Answer a data handle representing the argument.  Answer nil if the convertion fails."	| szString dataHandle |	szString := aString copyWith: (Character value: 0).	(dataHandle := self DdeCreateDataHandle: self instanceID		with: szString		with: szString size		with: 0		with: nil	"NULL pointer"		with: 1		with: 0) = 0		ifTrue: [Transcript show: 'DdeCreateDataHandle failed.'; cr].	^dataHandle</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>initialize-release</category><body package="DDEML">initialize	"Initialize the receiver and register it with the DDEML library.  Create an instance of a PFNCALLBACK and reference it to avoid its premature garbage collection.  The ddeCallback is used to process all callbacks from the DDEML library.  An exception is raised if the receiver could not be initialized."	|  lpDword initReturnValue |	ddeCallback :=		CCallback			do: self ddeCallbackProc			ofType: self PFNCALLBACK.	lpDword := self DWORD gcMalloc.	lpDword contents: 0.	(initReturnValue := self DdeInitialize: lpDword		with: ddeCallback		with: self commandAndFilterFlags		with: 0) ~= self DMLERR_NO_ERROR		ifTrue: [self error: 'DdeInitialize failed: ', initReturnValue printString].	self instanceID: lpDword contents.	^self</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>string manipulation</category><body package="DDEML">handleToString: hszString	"Answer a string that represents the argument.  Answer nil if the conversion fails."	| stringLength aString |	(stringLength := self stringHandleLength: hszString) == 0		ifTrue: [^nil].	aString := self LPWSTR gcMalloc:   stringLength + 1.	^(self DdeQueryStringW: self instanceID		with: hszString		with: aString		with: stringLength + 1		with: self CP_WINUNICODE) = 0		ifTrue:			[Transcript show: 'DdeQueryString failed.'; cr.			nil]		ifFalse: [aString copyUnicodeStringFromHeap]</body><body package="DDEML">stringHandleLength: aStringHandle	"Answer the length of the string represented by the handle, aStringHandle."	| length |	(length := self DdeQueryString: self instanceID		with: aStringHandle		with: nil	"Modify VM to accept nil as a NULL pointer."		with: 0		with: self CP_WINANSI) = 0		ifTrue: [Transcript show: 'DdeQueryString failed.'; cr].	^length</body><body package="DDEML">stringToHandle: aString	"Answer a handle that represents the argument. Answer nil if the conversion fails."	^DdemlDataHandle fromString: aString instance: self</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>private</category><body package="DDEML">ddeCallbackProc	"Answer an instance of a BlockClosure that represents the DDE callback procedure that will be invoked by the DDEML machinery for each callback message delivered to the receiver.  The transactions that a callback function receives depend on the callback-filter flags that the application specified in the DdeInitialize() function, and whether the application is a client, a server, or both.  The answered block switches on its first argument, 'wType', and sends an appropriate message to the receiver.  Application developers do not need to redefine this block, rather they should re-implement the messages dde&lt;Message&gt;:conversation:string1:string2:data:data1:data2.  See the transactions protocol."	^[:wType :wFormat :hConversation :hszString1 :hszString2 :hData :dwData1 :dwData2 |		self			dispatchDDEMessage: wType			with: wFormat			with: hConversation			with: hszString1			with: hszString2			with: hData			with: dwData1			with: dwData2]</body></methods><methods><class-id>OS.DdemlPort class</class-id> <category>class initialization</category><body package="DDEML">initialize	"self initialize."	OpenPorts := HandleRegistry new</body></methods><methods><class-id>OS.DdemlPort class</class-id> <category>instance creation</category><body package="DDEML">new	"Answer an initialized instance of a DDE port."	| aPort |	aPort := super new initialize.	self register: aPort.	^aPort</body></methods><methods><class-id>OS.DdemlPort class</class-id> <category>class accessing</category><body package="DDEML">register: aPort	"Register the argument in the current list of open ports."	^self registry register: aPort</body><body package="DDEML">registry	"Answer the handle registry used to contain all open ports.  The registry is used to finialize port objects when they are no longer referenced in the system."	^OpenPorts</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>finalization</category><body package="DDEML">actAsExecutor	"The receiver was created to be an executor for finalization, break all references."	super actAsExecutor.	transcript := nil</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>accessing-flags</category><body package="DDEML">commandAndFilterFlags	"Answer the flags indicating the reciever is a Monitor."	^(self APPCLASS_MONITOR) bitOr: self filterFlags</body><body package="DDEML">filterFlags	"Answer the flags indicating what receiver is monitoring."	^((((((self monitorCallbacksFlag)		bitOr: self monitorConversationsFlag)		bitOr: self monitorErrorsFlag)		bitOr: self monitorStringHandlesFlag)		bitOr: self monitorLinksFlag)		bitOr: self monitorPostMsgsFlag)		bitOr: self monitorSendMsgsFlag</body><body package="DDEML">monitorCallbacksFlag	"Answer the flag that indicates callbacks should be monitored."	^self MF_CALLBACKS</body><body package="DDEML">monitorConversationsFlag	"Answer the flag that indicates conversation connection and termination should be monitored."	^self MF_CONV</body><body package="DDEML">monitorErrorsFlag	"Answer the flag that indicates transaction errors should be monitored."	^self MF_ERRORS</body><body package="DDEML">monitorLinksFlag	"Answer the flag that indicates advise loops should be monitored."	^self MF_LINKS</body><body package="DDEML">monitorMasksFlag	"Answer the flag that indicates that all masking should be monitored."	^self MF_MASK</body><body package="DDEML">monitorPostMsgsFlag	"Answer the flag that indicates all system or application DDE message posts should be monitored."	^self MF_POSTMSGS</body><body package="DDEML">monitorSendMsgsFlag	"Answer the flag that indicates all system or application message sends should be monitored."	^self MF_SENDMSGS</body><body package="DDEML">monitorStringHandlesFlag	"Answer the flag that indicates all string handle argument data should be monitored."	^self MF_HSZ_INFO</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>transactions</category><body package="DDEML">ddeMonitor: hEventInfo event: dwEventID	"Dispatch the apppriate message to the receiver based on the dwEventID argument.  Only dispatch the message if the receiver has flagged the receipt of such a message.  Answers 0."	(dwEventID = self monitorCallbacksFlag		and: [self isMonitoring: self monitorCallbacksFlag])		ifTrue: [self monitorCallback: hEventInfo].	(dwEventID = self monitorConversationsFlag		and: [self isMonitoring: self monitorConversationsFlag])		ifTrue: [self monitorConversation: hEventInfo].	(dwEventID = self monitorErrorsFlag		and: [self isMonitoring: self monitorErrorsFlag])		ifTrue: [self monitorError: hEventInfo].	(dwEventID = self monitorStringHandlesFlag		and: [self isMonitoring: self monitorStringHandlesFlag])		ifTrue: [self monitorHszInfo: hEventInfo].	(dwEventID = self monitorLinksFlag		and: [self isMonitoring: self monitorLinksFlag])		ifTrue: [self monitorLink: hEventInfo].	(dwEventID = self monitorPostMsgsFlag		and: [self isMonitoring: self monitorPostMsgsFlag])		ifTrue: [self monitorPostMsg: hEventInfo].	(dwEventID = self monitorSendMsgsFlag		and: [self isMonitoring: self monitorPostMsgsFlag])		ifTrue: [self monitorSendMsg: hEventInfo].	^0</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>dispatching</category><body package="DDEML">dispatchDDEMessage: wType with: wFormat with: hConversation with: hszString1 with: hszString2 with: hData with: dwData1 with: dwData2	"A message of type wType was received.  Send the appropriate message to the receiver based on wType."	(wType == self XTYP_MONITOR)		ifTrue: [^self ddeMonitor: hData event: dwData2].	Transcript show: 'Invalid monitor transaction: ', wType printString; cr.	^0</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>initialize-release</category><body package="DDEML">initialize	"Initialize the receiver to monitor a default set of DDE transactions.  Answer the receiver."	super initialize.	monitorFlags := self filterFlags.	^self</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>testing</category><body package="DDEML">isMonitoring: aMonitorFlag	"Answer true if the receiver is monitoring the transaction represented by monitorFlag, otherwise answer false."	^(monitorFlags bitAnd: aMonitorFlag) ~= 0</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>monitoring</category><body package="DDEML">monitorCallback: hEventInfo	"A callback event was received, do any necessary processing.  The argument identifies a global memory object that contains information about the DDE event.  The application should use the DdeAccessData() function to obtain a pointer to the object."	transcript show: 'Callback'; cr</body><body package="DDEML">monitorConversation: hEventInfo	"A conversation transaction was sent to a DDE callback function in the system."	transcript show: 'Conversation'; cr</body><body package="DDEML">monitorError: hEventInfo	"A DDE error occurred."	transcript show: 'Error'; cr</body><body package="DDEML">monitorHszInfo: hEventInfo	"A DDE application created, freed, or incremented the use count of a string handle; or a string handle was freed as a result of a call to the DdeUninitialize() function."	transcript show: 'HszInfo'; cr</body><body package="DDEML">monitorLink: hEventInfo	"An advise loop was started or stopped."	transcript show: 'Link'; cr</body><body package="DDEML">monitorPostMsg: hEventInfo	"The system or an application posted a DDE message."	transcript show: 'PostMsg'; cr</body><body package="DDEML">monitorSendMsg: hEventInfo	"The system or an application sent a DDE message."	transcript show: 'SendMsg'; cr</body><body package="DDEML">toggleMonitorFlag: aFilterFlag	"The receiver is to start/stop monitoring the filter represented by aFilterFlag."	monitorFlags := (monitorFlags bitXor: aFilterFlag bitInvert) bitInvert</body></methods><methods><class-id>OS.DdemlMonitor</class-id> <category>accessing</category><body package="DDEML">transcript        ^transcript</body><body package="DDEML">transcript: aTranscript	"Set the receiver's monitoring output to be aTranscript."	transcript := aTranscript</body></methods><methods><class-id>OS.DdemlMonitor class</class-id> <category>instance creation</category><body package="DDEML">open	DdemlMonitorUI open</body></methods><methods><class-id>OS.DdemlServer</class-id> <category>finalization</category><body package="DDEML">actAsExecutor	"The receiver was created to be an executor for finalization, break all references."	super actAsExecutor.	serviceName := nil</body><body package="DDEML">finalize	"The receiver's proxy was removed from the system, break the server connection."	self instanceID == nil		ifFalse:			[self DdeNameService: self instanceID				with: 0				with: 0				with: self DNS_UNREGISTER].	super finalize</body></methods><methods><class-id>OS.DdemlServer</class-id> <category>transactions</category><body package="DDEML">ddeAdvReq: wFormat conversation: hConversation topic: hszTopic item: hszItem data: dwData	^0</body><body package="DDEML">ddeAdvStart: wFormat conversation: hConversation topic: hszTopic item: hszItem	^0</body><body package="DDEML">ddeAdvStop: wFormat conversation: hConversation topic: hszTopic item: hszItem	^0</body><body package="DDEML">ddeConnect: hszTopic service: hszService context: dwContext serverAppInstance: dwServerAppInstance	^0</body><body package="DDEML">ddeConnectConfirm: hConversation topic: hszTopic service: hszService serviceAppInstance: dwServerAppInstance	^0</body><body package="DDEML">ddeDisconnect: hConversation sameAppInstance: dwSameAppInstance	^0</body><body package="DDEML">ddeError: hConversation errorCode: dwErrorCode	^0</body><body package="DDEML">ddeExecute: hConversation topic: hszTopic command: hCommand	^self DDE_FNOTPROCESSED</body><body package="DDEML">ddeMask: wFormat conversation: hConversation string1: hszString1 string2: hszString2 data: hData data1: dwData1 data2: dwData2	^0</body><body package="DDEML">ddePoke: wFormat conversation: hConversation topic: hszTopic item: hszItem data: hData	^self DDE_FNOTPROCESSED</body><body package="DDEML">ddeRegister: hszBaseService instService: hszInstService	^0</body><body package="DDEML">ddeRequest: wFormat conversation: hConversation topic: hszTopic item: hszItem	^0</body><body package="DDEML">ddeShift: wFormat conversation: hConversation string1: hszString1 string2: hszString2 data: hData data1: dwData1 data2: dwData2	^0</body><body package="DDEML">ddeUnregister: hszBaseService instService: hszInstService	^0</body><body package="DDEML">ddeWildConnect: hszTopic service: hszService convData: hConvData appInst: dwAppInst	^0</body></methods><methods><class-id>OS.DdemlServer</class-id> <category>dispatching</category><body package="DDEML">dispatchDDEMessage: wType with: wFormat with: hConversation with: hszString1 with: hszString2 with: hData with: dwData1 with: dwData2	"A message of type wType was received.  Send the appropriate message to the receiver based on wType."	(wType == self XTYP_ADVREQ)		ifTrue:			[^self ddeAdvReq: wFormat				conversation: hConversation				topic: hszString1				item: hszString2				data: dwData1].	(wType == self XTYP_ADVSTART)		ifTrue:			[^self ddeAdvStart: wFormat				conversation: hConversation				topic: hszString1				item: hszString2].	(wType == self XTYP_ADVSTOP)		ifTrue:			[^self ddeAdvStop: wFormat				conversation: hConversation				topic: hszString1				item: hszString2].	(wType == self XTYP_CONNECT)		ifTrue:			[^self ddeConnect: hszString1				service: hszString2				context: dwData1				serverAppInstance: dwData2].	(wType == self XTYP_CONNECT_CONFIRM)		ifTrue:			[^self ddeConnectConfirm: hConversation				topic: hszString1				service: hszString2				serviceAppInstance: dwData2].	(wType == self XTYP_DISCONNECT)		ifTrue:			[^self ddeDisconnect: hConversation				sameAppInstance: dwData2].	(wType == self XTYP_ERROR)		ifTrue:			[^self ddeError: hConversation				errorCode: dwData1].	(wType == self XTYP_EXECUTE)		ifTrue:			[^self ddeExecute: hConversation				topic: hszString1				command: hData].	(wType == self XTYP_MASK)		ifTrue:			[^self ddeMask: wFormat				conversation: hConversation				string1: hszString1				string2: hszString2				data: hData				data1: dwData1				data2: dwData2].	(wType == self XTYP_POKE)		ifTrue:			[^self ddePoke: wFormat				conversation: hConversation				topic: hszString1				item: hszString2				data: hData].	(wType == self XTYP_REGISTER)		ifTrue:			[^self ddeRegister: hszString1				instService: hszString2].	(wType == self XTYP_REQUEST)		ifTrue:			[^self ddeRequest: wFormat				conversation: hConversation				topic: hszString1				item: hszString2].	(wType == self XTYP_SHIFT)		ifTrue:			[^self ddeShift: wFormat				conversation: hConversation				string1: hszString1				string2: hszString2				data: hData				data1: dwData1				data2: dwData2].	(wType == self XTYP_UNREGISTER)		ifTrue:			[^self ddeUnregister: hszString1				instService: hszString2].	(wType == self XTYP_WILDCONNECT)		ifTrue:			[^self ddeWildConnect: hszString1				service: hszString2				convData: dwData1				appInst: dwData2].	Transcript show: 'Invalid server transaction: ', wType printString; cr.	^0</body></methods><methods><class-id>OS.DdemlServer</class-id> <category>initialize-release</category><body package="DDEML">initialize	super initialize.	self named: self class serviceName</body><body package="DDEML">named: aName	"Register the receiver as a server named aName."	| aServiceName |	aServiceName := self stringToHandle: aName.	(self DdeNameService: self instanceID		with: aServiceName asParameter		with: 0		with: (self DNS_REGISTER bitOr: self DNS_FILTERON)) = 0		ifTrue:			[self error: 'DdeNameService failed with error: ',				((self DdeGetLastError: self instanceID) printString)].	self serviceName: aServiceName</body></methods><methods><class-id>OS.DdemlServer</class-id> <category>accessing</category><body package="DDEML">serviceName	"Answer a string representing the receiver's service."	^self handleToString: serviceName</body><body package="DDEML">serviceName: aNameHandle	"Remember the handle representing the server's service string identifier."	serviceName := aNameHandle</body></methods><methods><class-id>OS.DdemlServer class</class-id> <category>class accessing</category><body package="DDEML">serviceName	"Answer a string used to register the receiver's service with the DDEML DLL."	^self subclassResponsibility</body></methods><methods><class-id>OS.DdemlClient</class-id> <category>conversations</category><body package="DDEML">beMultipleConversation	"The receiver has established multiple conversations, set a flag indicating this."	multipleConversations := true</body><body package="DDEML">beSingleConversation	"The receiver has established a single conversation, set a flag indicating this."	multipleConversations := false</body><body package="DDEML">execute: itemString	"Send an request to execute itemString to the receiver's service.  Answer the result of the request.  Raises an exception if their is no connection to the service or if the server fails the request."	| result szItemString emptyContainer |	conversationID isNil		ifTrue: [^self error: 'Receiver has not initiated a conversation.'].	szItemString := itemString copyWith: (Character value: 0).	emptyContainer := CIntegerType long gcMalloc.	(result := self DdeClientTransaction: (String defaultPlatformClass fromString: szItemString)		with: szItemString size		with: conversationID		with: 0		with: 1		with: self XTYP_EXECUTE		with: self requestTimeOut		with: emptyContainer) = 0		ifTrue: [self error: 'Request failed.'].	^result</body><body package="DDEML">initiate: service topic: topicName	"Initiate a conversation with service for the given topicName.  Answer an object representing the conversation instance.  Raises an exception if the service is already engaged or is unavailable."	| hConversation hService hTopicName |	conversationID notNil		ifTrue: [^self error: 'Receiver already involved in a conversation.'].	self beSingleConversation.	(service isNil or: [service = ''])		ifTrue:			[hService := nil.	"NULL pointer."			self beMultipleConversation]		ifFalse: [hService := self stringToHandle: service].	(topicName isNil or: [topicName = ''])		ifTrue:			[hTopicName := nil.	"NULL pointer."			self beMultipleConversation]		ifFalse: [hTopicName := self stringToHandle: topicName].	(hConversation := self DdeConnect: self instanceID		with: hService asParameter		with: hTopicName asParameter		with: nil	"NULL Pointer") = 0		ifTrue: [^self error: 'Service ', service, ' for topic ', topicName, ' is unavailable.'].	conversationID := hConversation</body><body package="DDEML">request: itemString	"Send a request for itemString to the receiver's server.  Answer the result of the request.  Raise an exception if there is no conversation or the request fails."	| result hItemString |	conversationID isNil		ifTrue: [^self error: 'Receiver has not initiated a conversation.'].	hItemString := self stringToHandle: itemString.	(result := self DdeClientTransaction: nil	"NULL pointer."		with: 0		with: conversationID		with: hItemString asParameter		with: 1		with: self XTYP_REQUEST		with: self requestTimeOut		with: (UninterpretedBytes new: 4)) = 0		ifTrue: [self error: 'Request failed.'].	^self hDataToString: result</body><body package="DDEML">terminate	"Terminate the conversation between the receiver and another service represented by the receiver's conversation identifier."	conversationID isNil		ifTrue: [^self error: 'Receiver has not initiated a conversation.'].	self hasMultipleConversations		ifTrue:			[(self DdeDisconnectList: conversationID) = 0				ifTrue: [self error: 'DisconnectList failed for conversations: ',						conversationID printString]]		ifFalse:			[(self DdeDisconnect: conversationID) = 0				ifTrue: [self error: 'Disconnect failed for conversation: ',							conversationID printString]].	conversationID := nil</body></methods><methods><class-id>OS.DdemlClient</class-id> <category>transactions</category><body package="DDEML">ddeAdvData: wFormat conversation: hConversation topic: hszTopic item: hszItem data: hData	^self DDE_FNOTPROCESSED</body><body package="DDEML">ddeDisconnect: hConversation sameAppInstance: dwSameAppInstance	^0</body><body package="DDEML">ddeError: hConversation errorCode: dwErrorCode	^0</body><body package="DDEML">ddeMask: wFormat conversation: hConversation string1: hszString1 string2: hszString2 data: hData data1: dwData1 data2: dwData2	^0</body><body package="DDEML">ddeRegister: hszBaseService instService: hszInstService	^0</body><body package="DDEML">ddeShift: wFormat conversation: hConversation string1: hszString1 string2: hszString2 data: hData data1: dwData1 data2: dwData2	^0</body><body package="DDEML">ddeUnregister: hszBaseService instService: hszInstService	^0</body><body package="DDEML">ddeXactComplete: wFormat conversation: hConversation topic: hszTopic item: hszItem data: hData data1: dwData1 data2: dwData2	^0</body></methods><methods><class-id>OS.DdemlClient</class-id> <category>dispatching</category><body package="DDEML">dispatchDDEMessage: wType with: wFormat with: hConversation with: hszString1 with: hszString2 with: hData with: dwData1 with: dwData2	"A message of type wType was received.  Send the appropriate message to the receiver based on wType.  Each argument has a different meaning depending on the value of the wType argument.  See the comment for wType's associated message for more information."	(wType == self XTYP_ADVDATA)		ifTrue:			[^self ddeAdvReq: wFormat				conversation: hConversation				topic: hszString1				item: hszString2				data: dwData1].	(wType == self XTYP_DISCONNECT)		ifTrue:			[^self ddeDisconnect: hConversation				sameAppInstance: dwData2].	(wType == self XTYP_ERROR)		ifTrue:			[^self ddeError: hConversation				errorCode: dwData1].	(wType == self XTYP_MASK)		ifTrue:			[^self ddeMask: wFormat				conversation: hConversation				string1: hszString1				string2: hszString2				data: hData				data1: dwData1				data2: dwData2].	(wType == self XTYP_REGISTER)		ifTrue:			[^self ddeRegister: hszString1				instService: hszString2].	(wType == self XTYP_SHIFT)		ifTrue:			[^self ddeShift: wFormat				conversation: hConversation				string1: hszString1				string2: hszString2				data: hData				data1: dwData1				data2: dwData2].	(wType == self XTYP_UNREGISTER)		ifTrue:			[^self ddeUnregister: hszString1				instService: hszString2].	Transcript show: 'Invalid client transaction: ', wType printString; cr.	^0</body></methods><methods><class-id>OS.DdemlClient</class-id> <category>testing</category><body package="DDEML">hasMultipleConversations	"Answer true if the receiver has established multiple concurrent conversations."	^multipleConversations</body></methods><methods><class-id>OS.DdemlClient</class-id> <category>initialize-release</category><body package="DDEML">initialize	"Initialize the receiver to represent a new DDEML client.  The default is for the client to have only a single conversation."	super initialize.	conversationID := nil.	multipleConversations := false</body></methods><methods><class-id>OS.DdemlClient</class-id> <category>accessing</category><body package="DDEML">requestTimeOut	"Answer the maximim length of time (in milliseconds) that the receiver will wait for a response from a server application in a synchronous transaction.  Use 'self TIMEOUT_ASYNC' for asynchronous transactions."	^1000</body></methods><methods><class-id>OS.DdemlDataHandle</class-id> <category>converting</category><body package="DDEML">asParameter	"Answer an object representing the receiver as the parameter to a foreign function call."	^handle</body></methods><methods><class-id>OS.DdemlDataHandle</class-id> <category>accessing</category><body package="DDEML">dataHandle: aHandle	"Set the receiver's handle to be a data handle."	super handle: aHandle.	type := #data</body><body package="DDEML">instance	"Answer the instanceID of the receiver's data handle."	^instanceID</body><body package="DDEML">instance: instancePortID	"The receiver's data handle was created in context instancePortID, remember that instance."	instanceID := instancePortID</body><body package="DDEML">stringHandle: aHandle	"Set the receiver's handle to be a string handle."	super handle: aHandle.	type := #string</body></methods><methods><class-id>OS.DdemlDataHandle</class-id> <category>finalization</category><body package="DDEML">finalize	"The reciever's proxy was removed from the system, free the data handle."	handle == nil		ifFalse:			[type == #data ifTrue: [DdemlPort DdeFreeDataHandle: handle].			type == #string				ifTrue: [DdemlPort DdeFreeStringHandle: instanceID with: handle]].	handle := instanceID := type := nil</body></methods><methods><class-id>OS.DdemlDataHandle</class-id> <category>initialize-release</category><body package="DDEML">fromData: aDatum instance: instancePort	"Initialize the receiver to be a data handle."	| szDatum dataHandle |	szDatum := aDatum copyWith: (Character value: 0).	(dataHandle := instancePort DdeCreateDataHandle: instancePort instanceID		with: (String defaultPlatformClass fromString: szDatum)		with: szDatum size		with: 0		with: nil	"NULL pointer"		with: 1		with: 0) = 0		ifTrue: [Transcript show: 'DdeCreateDataHandle failed.'; cr].	self dataHandle: dataHandle.	self instance: instancePort instanceID.	^self</body><body package="DDEML">fromString: aString instance: instancePort	"Initialize the receiver to be a string handle."	| aHandle szString |	szString := aString copyWith: (Character value: 0).	(aHandle := instancePort DdeCreateStringHandle: instancePort instanceID			with: (String defaultPlatformClass fromString: szString)			with: instancePort CP_WINANSI) = 0		ifTrue:			[Transcript show: 'DdeCreateStringHandle failed.'; cr.			^nil].	self stringHandle: aHandle.	self instance: instancePort instanceID.	^self</body></methods><methods><class-id>OS.DdemlDataHandle class</class-id> <category>finalization</category><body package="DDEML">finalizeElementsFor: instanceID	"The instanceID connection is being broken, finalize all elements associated with that connection."	| unRegisterHandles |	unRegisterHandles := OrderedCollection new.	OpenDataHandles finalizeElements.	OpenDataHandles values do: [:aHandle |		aHandle instance = instanceID			ifTrue: [unRegisterHandles add: aHandle]].	unRegisterHandles do: [:aHandle |		OpenDataHandles unregister: aHandle.		aHandle finalize]</body></methods><methods><class-id>OS.DdemlDataHandle class</class-id> <category>instance creation</category><body package="DDEML">fromData: aDatum instance: instancePort	"Answer a new data handle instance for aDatum in the given DDE instance instancePort."	| aHandle |	aHandle := super new fromData: aDatum instance: instancePort.	self register: aHandle.	^aHandle</body><body package="DDEML">fromString: aString instance: instancePort	"Answer a new handle instance for aString in the given DDE instance instancePort."	| aHandle |	aHandle := super new fromString: aString instance: instancePort.	self register: aHandle.	^aHandle</body></methods><methods><class-id>OS.DdemlDataHandle class</class-id> <category>class initialization</category><body package="DDEML">initialize	"self initialize"	OpenDataHandles := HandleRegistry new</body></methods><methods><class-id>OS.DdemlDataHandle class</class-id> <category>class accessing</category><body package="DDEML">registry	"Answer the receiver's handle registry."	^OpenDataHandles</body></methods><methods><class-id>Tools.DdemlMonitorUI</class-id> <category>aspects</category><body package="DDEML">callbacks        ^callbacks</body><body package="DDEML">conservations        ^conservations</body><body package="DDEML">ddemlMonitor        "This method was generated by UIDefiner.  Any edits made here        may be lost whenever methods are automatically defined.  The        initialization provided below may have been preempted by an        initialize method."        ^ddemlMonitor isNil                ifTrue:                        [ddemlMonitor := nil asValue]                ifFalse:                        [ddemlMonitor]</body><body package="DDEML">errors        ^errors</body><body package="DDEML">links        ^links</body><body package="DDEML">postMsgs        ^postMsgs</body><body package="DDEML">sendMsgs        ^sendMsgs</body><body package="DDEML">stringHandles        ^stringHandles</body><body package="DDEML">textCollector        ^TextCollectorView model: self ddemlMonitor value transcript</body></methods><methods><class-id>Tools.DdemlMonitorUI</class-id> <category>initialize-release</category><body package="DDEML">initialize        | ddeMon |        super initialize.        ddeMon := DdemlMonitor new.        ddeMon transcript: TextCollector new.        self ddemlMonitor value: ddeMon.        self initializeAdaptors.</body><body package="DDEML">initializeAdaptors        callbacks := (PluggableAdaptor on: self ddemlMonitor value)                        getBlock: [:m | m perform: #isMonitoring: with: m monitorCallbacksFlag]                        putBlock: [:m :v | m perform: #toggleMonitorFlag: with: m monitorCallbacksFlag]                        updateBlock: [:m :a :p | a == #value].        conservations :=  (PluggableAdaptor on: self ddemlMonitor value)                        getBlock: [:m | m perform: #isMonitoring: with: m monitorConversationsFlag]                        putBlock: [:m :v | m perform: #toggleMonitorFlag: with: m monitorConversationsFlag]                        updateBlock: [:m :a :p | a == #value].        links :=  (PluggableAdaptor on: self ddemlMonitor value)                        getBlock: [:m | m perform: #isMonitoring: with: m monitorLinksFlag]                        putBlock: [:m :v | m perform: #toggleMonitorFlag: with: m monitorLinksFlag]                        updateBlock: [:m :a :p | a == #value].        sendMsgs := (PluggableAdaptor on: self ddemlMonitor value)                        getBlock: [:m | m perform: #isMonitoring: with: m monitorSendMsgsFlag]                        putBlock: [:m :v | m perform: #toggleMonitorFlag: with: m monitorSendMsgsFlag]                        updateBlock: [:m :a :p | a == #value].        stringHandles :=  (PluggableAdaptor on: self ddemlMonitor value)                        getBlock: [:m | m perform: #isMonitoring: with: m monitorStringHandlesFlag]                        putBlock: [:m :v | m perform: #toggleMonitorFlag: with: m monitorStringHandlesFlag]                        updateBlock: [:m :a :p | a == #value].        errors :=  (PluggableAdaptor on: self ddemlMonitor value)                        getBlock: [:m | m perform: #isMonitoring: with: m monitorErrorsFlag]                        putBlock: [:m :v | m perform: #toggleMonitorFlag: with: m monitorErrorsFlag]                        updateBlock: [:m :a :p | a == #value].        postMsgs :=  (PluggableAdaptor on: self ddemlMonitor value)                        getBlock: [:m | m perform: #isMonitoring: with: m monitorPostMsgsFlag]                        putBlock: [:m :v | m perform: #toggleMonitorFlag: with: m monitorPostMsgsFlag]                        updateBlock: [:m :a :p | a == #value].</body><body package="DDEML">release</body></methods><methods><class-id>Tools.DdemlMonitorUI</class-id> <category>events</category><body package="DDEML">noticeOfWindowClose: aWindow         super noticeOfWindowClose: aWindow.        self release</body></methods><methods><class-id>Tools.DdemlMonitorUI class</class-id> <category>interface specs</category><body package="DDEML">windowSpec        "UIPainter new openOnClass: self andSelector: #windowSpec"        &lt;resource: #canvas&gt;        ^#(#FullSpec                 #window:                 #(#WindowSpec                         #label: 'DDEML Monitor'                         #bounds: #(#Rectangle 234 233 637 416 ) )                 #component:                 #(#SpecCollection                         #collection: #(                                #(#CheckBoxSpec                                         #layout: #(#LayoutOrigin 0 0.709677 0 0.0382514 )                                         #model: #callbacks                                         #label: 'Callbacks' )                                 #(#CheckBoxSpec                                         #layout: #(#LayoutOrigin 0 0.709677 0 0.174863 )                                         #model: #conservations                                         #label: 'Conservations' )                                 #(#CheckBoxSpec                                         #layout: #(#LayoutOrigin 0 0.709677 0 0.311475 )                                         #model: #errors                                         #label: 'Errors' )                                 #(#CheckBoxSpec                                         #layout: #(#LayoutOrigin 0 0.709677 0 0.448087 )                                         #model: #stringHandles                                         #label: 'StringHandles' )                                 #(#CheckBoxSpec                                         #layout: #(#LayoutOrigin 0 0.709677 0 0.584699 )                                         #model: #links                                         #label: 'Links' )                                 #(#CheckBoxSpec                                         #layout: #(#LayoutOrigin 0 0.709677 0 0.721311 )                                         #model: #postMsgs                                         #label: 'PostMsgs' )                                 #(#CheckBoxSpec                                         #layout: #(#LayoutOrigin 0 0.709677 0 0.857923 )                                         #model: #sendMsgs                                         #label: 'SendMsgs' )                                 #(#ArbitraryComponentSpec                                         #layout: #(#LayoutFrame 0 0.0 0 0.0163934 0 0.687345 0 0.983607 )                                         #name: #textCollector                                         #flags: 9                                         #component: #textCollector ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="DDEML">toolsDdemlMonitorUI	"Open the toolsDdemlMonitorUI."	&lt;menuItem: '&amp;DDEML Monitor'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.025&gt;	self openApplicationForClassNamed: #DdemlMonitorUI</body></methods><methods><class-id>OS.DdemlPort</class-id> <category>procedures</category><body package="DDEML">DdeAbandonTransaction: idInst with: hConv with: idTransaction	&lt;C: BOOL DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction)&gt;</body><body package="DDEML">DdeAccessData: hData with: pcbDataSize	&lt;C: LPBYTE DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize)&gt;</body><body package="DDEML">DdeAddData: hData with: pSrc with: cb with: cbOff	&lt;C: HDDEDATA DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff)&gt;</body><body package="DDEML">DdeClientTransaction: pData with: cbData with: hConv with: hszItem with: wFmt with: wType with: dwTimeout with: pdwResult	&lt;C: HDDEDATA DdeClientTransaction(LPBYTE pData, DWORD cbData, HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType, DWORD dwTimeout, LPDWORD pdwResult)&gt;</body><body package="DDEML">DdeCmpStringHandles: hsz1 with: hsz2	&lt;C: int DdeCmpStringHandles(HSZ hsz1, HSZ hsz2)&gt;</body><body package="DDEML">DdeConnect: idInst with: hszService with: hszTopic with: pCC	&lt;C: HCONV DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic, PCONVCONTEXT pCC)&gt;</body><body package="DDEML">DdeConnectList: idInst with: hszService with: hszTopic with: hConvList with: pCC	&lt;C: HCONVLIST DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic, HCONVLIST hConvList, PCONVCONTEXT pCC)&gt;</body><body package="DDEML">DdeCreateDataHandle: idInst with: pSrc with: cb with: cbOff with: hszItem with: wFmt with: afCmd	&lt;C: HDDEDATA DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb, DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd)&gt;</body><body package="DDEML">DdeCreateStringHandle: idInst with: psz with: iCodePage	&lt;C: HSZ DdeCreateStringHandleA(DWORD idInst, LPSTR psz, int iCodePage)&gt;</body><body package="DDEML">DdeDisconnect: hConv	&lt;C: BOOL DdeDisconnect(HCONV hConv)&gt;</body><body package="DDEML">DdeDisconnectList: hConvList	&lt;C: BOOL DdeDisconnectList(HCONVLIST hConvList)&gt;</body><body package="DDEML">DdeEnableCallback: idInst with: hConv with: wCmd	&lt;C: BOOL DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd)&gt;</body><body package="DDEML">DdeGetData: hData with: pDst with: cbMax with: cbOff	&lt;C: DWORD _wincall DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff)&gt;</body><body package="DDEML">DdeGetLastError: idInst	&lt;C: UINT DdeGetLastError(DWORD idInst)&gt;</body><body package="DDEML">DdeImpersonateClient: hConv	&lt;C: BOOL DdeImpersonateClient(HCONV hConv)&gt;</body><body package="DDEML">DdeInitialize: pidInst with: pfnCallback with: afCmd with: ulRes	&lt;C: UINT DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)&gt;</body><body package="DDEML">DdeKeepStringHandle: idInst with: hsz	&lt;C: BOOL DdeKeepStringHandle(DWORD idInst, HSZ hsz)&gt;</body><body package="DDEML">DdeNameService: idInst with: hsz1 with: hsz2 with: afCmd	&lt;C: HDDEDATA DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd)&gt;</body><body package="DDEML">DdePostAdvise: idInst with: hszTopic with: hszItem	&lt;C: BOOL DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem)&gt;</body><body package="DDEML">DdeQueryConvInfo: hConv with: idTransaction with: pConvInfo	&lt;C: UINT DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo)&gt;</body><body package="DDEML">DdeQueryNextServer: hConvList with: hConvPrev	&lt;C: HCONV DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev)&gt;</body><body package="DDEML">DdeQueryString: idInst with: hsz with: psz with: cchMax with: iCodePage	&lt;C: DWORD DdeQueryStringW(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage)&gt;</body><body package="DDEML">DdeQueryStringW: idInst with: hsz with: psz with: cchMax with: iCodePage	&lt;C: DWORD DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage)&gt;</body><body package="DDEML">DdeReconnect: hConv	&lt;C: HCONV DdeReconnect(HCONV hConv)&gt;</body><body package="DDEML">DdeSetQualityOfService: hwndClient with: pqosNew with: pqosPrev	&lt;C: BOOL DdeSetQualityOfService(HWND hwndClient, const SECURITY_QUALITY_OF_SERVICE * pqosNew, PSECURITY_QUALITY_OF_SERVICE pqosPrev)&gt;</body><body package="DDEML">DdeSetUserHandle: hConv with: id with: hUser	&lt;C: BOOL DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser)&gt;</body><body package="DDEML">DdeUnaccessData: hData	&lt;C: BOOL DdeUnaccessData(HDDEDATA hData)&gt;</body><body package="DDEML">DdeUninitialize: idInst	&lt;C: BOOL DdeUninitialize(DWORD idInst)&gt;</body></methods><methods><class-id>OS.DdemlPort class</class-id> <category>procedures</category><body package="DDEML">DdeFreeDataHandle: hData	&lt;C: BOOL DdeFreeDataHandle(HDDEDATA hData)&gt;</body><body package="DDEML">DdeFreeStringHandle: idInst with: hsz	&lt;C: BOOL DdeFreeStringHandle(DWORD idInst, HSZ hsz)&gt;</body></methods><initialize><class-id>OS.DdemlPort</class-id></initialize><initialize><class-id>OS.DdemlDataHandle</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>OSHandle</name><environment>OS</environment><super>OS.OSErrorHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class></st-source>