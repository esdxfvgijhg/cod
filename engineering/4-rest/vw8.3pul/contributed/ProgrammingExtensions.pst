<?xml version="1.0"?><st-source><!-- Name: ProgrammingExtensionsNotice: Copyright 2002-2014 Cincom Systems, Inc.  All rights reserved.BundleName: Programming ExtensionsComment: This parcel adds a number of useful or not so useful menu items to various tools.To the Launcher's tools menu adds a Differator item that opens a simple diff tool.  It also adds 'Trim Changes' to the Changes menu.  This cuts-back the changes file discarding any changes since the last snapshot.  This is *very* dangerous, and only to be used by the unhealthily neat.When a method is selected in the browser, the code tool has a utilities menu that allows one to:	Inspect a method	Copy the selector of the method to the paste buffer, on it's own or with the class name, with or without the namespace (rooted at Smalltalk.*)	Convert the method to a menu or submenu pragmaIn the list of methods since inspect already exists as a menu pick, only copy selector is added.When a class is selected in the browser, the query menu has a "Subclass Responsibilities" menu pick that spawns a method browser on those methods that still need subclassResponsibilities defined.It extends the old FileBrowser to spawn a Change List, the modern File Browser has these features already.Finally, it adds a inspect window and inspect widget menu pick to the blue button menu (the window menu).DbIdentifier: bear73DbTrace: 438519DbUsername: mlucas-smithDbVersion: 8.0 - 7DialectVersion: VisualWorks 7.9HideSource: falsePackageName: ProgrammingExtensionsParcel: #('ProgrammingExtensions')ParcelName: ProgrammingExtensionsPrintStringCache: (8.0 - 7,mlucas-smith)SaveSource: trueVersion: 8.0 - 7Date: 12:50:22 PM July 1, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jun14.4) of July 1, 2014 on July 1, 2014 at 12:50:22 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WindowStructureVisitor</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window widgetPosition directorMap widgets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ProgrammingExtensions</package></attributes></class><comment><class-id>UI.WindowStructureVisitor</class-id><body>(May 16, 2002 2:04:40 pm LT)	Jaroslaw Podgajny	5/20/2002 jpodgajn 1.1</body></comment><shared-variable><name>LastBlueButtonMenuOrigin</name><environment>UI.ApplicationStandardSystemController</environment><private>false</private><constant>false</constant><category>state</category><initializer>nil</initializer><attributes><package>ProgrammingExtensions</package></attributes></shared-variable><methods><class-id>UI.WindowStructureVisitor</class-id> <category>accessing</category><body package="ProgrammingExtensions">findComponentAt: aPoint	"&lt;VisualComponent&gt;"	"Return a component occupying the position aPoint in the &lt;window&gt;. aPoint represents global position on the screen."	widgetPosition := aPoint.	self visit: window.	^self searchResult.</body><body package="ProgrammingExtensions">searchResult	widgets isEmpty ifTrue: [^window].	widgets size = 1 ifTrue: [^widgets first].	^widgets.</body></methods><methods><class-id>UI.WindowStructureVisitor</class-id> <category>private</category><body package="ProgrammingExtensions">foundComponent: aVisualComponent	(widgets includes: aVisualComponent) ifFalse:		[widgets addFirst: aVisualComponent]</body></methods><methods><class-id>UI.WindowStructureVisitor</class-id> <category>initialize-release</category><body package="ProgrammingExtensions">initialize	widgets := OrderedCollection new.</body><body package="ProgrammingExtensions">window: aWindow	window := aWindow.</body></methods><methods><class-id>UI.WindowStructureVisitor</class-id> <category>visiting</category><body package="ProgrammingExtensions">visit: anObject	anObject visit: self.</body><body package="ProgrammingExtensions">visitBorderDecorator: aBorderDecorator	"Enumerate an instance of BorderDecorator. Enumerate its &lt;components&gt; to check borders or scroll wrappers and proceed with &lt;component&gt;"	self visitComposite: aBorderDecorator.	self visit: aBorderDecorator component.</body><body package="ProgrammingExtensions">visitComposite: aCompositePart	"Enumerate all elements of a given CompositePart."	aCompositePart components do: [:eachVisualComponent | self visit: eachVisualComponent].</body><body package="ProgrammingExtensions">visitTranslatingWrapper: aTranslatingWrapper	"Enumerate an instance of TranslatingWrapper. Translate the &lt;widgetPosition&gt; and go on with the subject's component. Restore the position afterthat processing."	| theWidgetPosition |	theWidgetPosition := widgetPosition.	widgetPosition := widgetPosition - aTranslatingWrapper translation.	self visit: aTranslatingWrapper component.	widgetPosition := theWidgetPosition.</body><body package="ProgrammingExtensions">visitVisualComponent: aVisualComponent	"Enumerate an instance of VisualComponent. Check whether the component is the one we look for."	(aVisualComponent bounds containsPoint: widgetPosition) ifTrue: [self foundComponent: aVisualComponent].</body><body package="ProgrammingExtensions">visitWindow: aWindow	"Enumerate an instance of Window. Go on with the subject's component &lt;CompositePart&gt;."	| theWidgetPosition |	theWidgetPosition := widgetPosition.	widgetPosition := widgetPosition - aWindow globalOrigin.	self visit: aWindow component.	widgetPosition := theWidgetPosition.</body><body package="ProgrammingExtensions">visitWrapper: aWrapper	"Enumerate an instance of Wrapper. Go on with the subject's component."	self visit: aWrapper component.</body></methods><methods><class-id>UI.WindowStructureVisitor class</class-id> <category>instance creation</category><body package="ProgrammingExtensions">forWindow: aWindow	^self new		window: aWindow;		yourself.</body><body package="ProgrammingExtensions">new	^super new		initialize;		yourself.</body></methods><methods><class-id>UI.ApplicationStandardSystemController</class-id> <category>private</category><body package="ProgrammingExtensions">trackMenu: menu event: event	"Open the menu and answer the value chosen."	LastBlueButtonMenuOrigin := event globalPoint.	^super trackMenu: menu event: event.</body></methods><methods><class-id>Graphics.TranslatingWrapper</class-id> <category>actions</category><body package="ProgrammingExtensions">visit: aVisitor	aVisitor visitTranslatingWrapper: self.</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>testing</category><body package="ProgrammingExtensions">isChangeFile	^fileName asFilename extension = Filename changeExtension</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>file name list</category><body package="ProgrammingExtensions">spawnChangeList	"Spawn a ChangeList on the selected file."	| cl |	cl := ChangeList new.	cl scanFilename: fileName asFilename.	cl open</body><body package="ProgrammingExtensions">spawnCodeConflicts	"Spawn a ChangeList on the conflicts selected file."	| cl onlyConflicts |	onlyConflicts := builder window sensor shiftDown.	cl := ChangeList new.	cl checkSystem: #code.	cl showConflicts: true.	cl scanFilename: fileName asFilename.	onlyConflicts		ifTrue: 			[cl				removeClassesNotInSystem;				removeMethodsNotInSystem;				forgetAll].	cl isEmpty ifTrue: [^Dialog warn: 'No conflicts.'].	cl open</body><body package="ProgrammingExtensions">spawnConflicts	"Spawn a ChangeList on the conflicts selected file."	| cl onlyConflicts |	onlyConflicts := builder window sensor shiftDown.	cl := ChangeList new.	cl checkSystem: #exact.	cl showConflicts: true.	cl scanFilename: fileName asFilename.	onlyConflicts		ifTrue: 			[cl				removeClassesNotInSystem;				removeMethodsNotInSystem;				forgetAll].	cl isEmpty ifTrue: [^Dialog warn: 'No conflicts.'].	cl open</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>menus-options</category><body package="ProgrammingExtensions">toolsMenu	"Answer the tools menu to use for operating on the selected file (if any)."	^self newMenuNamed: #toolsMenu</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>actions</category><body package="ProgrammingExtensions">visit: aVisitor 	aVisitor visitWindow: self.</body></methods><methods><class-id>Graphics.Wrapper</class-id> <category>actions</category><body package="ProgrammingExtensions">visit: aVisitor	aVisitor visitWrapper: self.</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="ProgrammingExtensions">&gt;&gt; aSelector	"Answer a MethopdDefinition for the compiled method at aSelector."	^MethodDefinition class: self selector: aSelector</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>actions</category><body package="ProgrammingExtensions">visit: aVisitor	aVisitor visitComposite: self.</body></methods><methods><class-id>UI.BorderDecorator</class-id> <category>actions</category><body package="ProgrammingExtensions">visit: aVisitor	aVisitor visitBorderDecorator: self.</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>private</category><body package="ProgrammingExtensions">menuItemTemplate: args	"Make a template in the method that allows it to be declared	as a menu item for one of the receiver's menus."	| source parse pos insert newSource targetClass |	self updateRequest ifFalse: [^self].	targetClass := self selectedClass.	source := self definition sourceCode.	parse := [targetClass compilerClass					parse: source					class: targetClass]				on: Object errorSignal				do: [:ex | ex return: nil].	parse == nil ifTrue:		[^Dialog warn: 'The source code for this method could not be parsed'				for: self interfaceWindow].	pos := parse block body sourcePosition first.	pos &lt;= source size		ifTrue:			[(source at: pos) = $|				ifTrue: [[(source at: (pos := pos-1)) = $|] whileFalse].			[(source at: (pos := pos-1)) isSeparator] whileTrue]		ifFalse: [pos := source size].	insert := '&lt;n&gt;&lt;t&gt;%&lt;&lt;1s&gt; &lt;2p&gt;',			'&lt;n&gt;&lt;t&gt;&lt;t&gt;nameKey: &lt;3p&gt;',			'&lt;n&gt;&lt;t&gt;&lt;t&gt;menu: &lt;4p&gt;',			'&lt;n&gt;&lt;t&gt;&lt;t&gt;position: &lt;5p&gt;%&gt;'.	newSource := source copyReplaceFrom: pos+1 to: pos				with: (insert expandMacrosWithArguments: args).	self textController		selectFrom: 1 to: self textController text size;		deselect;		replaceSelectionWith: newSource asText;		selectAt: 1</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>utilities</category><body package="ProgrammingExtensions">trimChanges	"Trim back the changes file to the last snapshot."		"SourceFileManager default trimChanges."	| file position |	file := self ensureOpen: currentTarget.	file flush.	position := self class findLastSnapshotIn: file.	position == nil "There is no SNAPSHOT marker; wipe the entire file"		ifTrue: [position := 0]		ifFalse:			["There is a snapshot marker; find the time stamp following it, if any."			 file position: position.			 [:exit|			  ChangeScanner new				scanFile: file				do: [:nextChange|					nextChange class == OtherChange ifTrue:						[position := file position].					exit value]] valueWithExit].	"The unwind due to valueWithExit may have caused the ChangeScanner	 to close the file; sending position: ensures it is open."	file position: position.	file ioConnection output truncateTo: position.	self close: currentTarget</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>actions</category><body package="ProgrammingExtensions">visit: aVisitor	aVisitor visitVisualComponent: self.</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>testing</category><body package="ProgrammingExtensions">isClassSelected	^self selectedClass notNil</body><body package="ProgrammingExtensions">isMethodSelected	^self selector notNil</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="ProgrammingExtensions">openDifferatorToolCommand	&lt;command: #openDifferator&gt;	^Command		label: (#Differator &lt;&lt; #menus &gt;&gt; 'Differator')		group: #launcher		bindings: #()</body><body package="ProgrammingExtensions">trimChangesFileCommand	&lt;command: #trimChangesFile&gt;	^Command		label: #TrimChangesFile &lt;&lt; #labels &gt;&gt; 'Trim Changes File'		group: #launcher		bindings: #()</body></methods><methods><class-id>UI.ApplicationStandardSystemController</class-id> <category>menu messages</category><body package="ProgrammingExtensions">inspectWidget	"Inspect the widget contained in the window at the position the menu has been open."	&lt;menuItem: 'Inspect Widget'		nameKey: nil		menu: #(scheduledBlueButtonMenu)		position: 25.02&gt;	((WindowStructureVisitor forWindow: self view) findComponentAt: LastBlueButtonMenuOrigin) inspect.</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>file name list</category><body package="ProgrammingExtensions">fileSpawnChangeListItem	&lt;itemInMenu: #(#fileMenu) position: 40.20&gt;	^(MenuItem labeled: #spawnChanges &lt;&lt; #menus &gt;&gt; 'Spawn Changes')		visible: [self doesFileExist and: [self isChangeFile]];		enablement: [self doesFileExist];		value: [self spawnChangeList];		yourself</body><body package="ProgrammingExtensions">fileSpawnCodeConflictsItem	&lt;itemInMenu: #(#fileMenu) position: 40.22&gt;	^(MenuItem		labeled: #spawnCodeConflicts &lt;&lt; #menus &gt;&gt; 'Spawn Code Conflicts')		visible: [self doesFileExist and: [self isChangeFile]];		enablement: [self doesFileExist];		value: [self spawnCodeConflicts];		yourself</body><body package="ProgrammingExtensions">fileSpawnConflictsItem	&lt;itemInMenu: #(#fileMenu) position: 40.21&gt;	^(MenuItem labeled: #spawnConflicts &lt;&lt; #menus &gt;&gt; 'Spawn Conflicts')		visible: [self doesFileExist and: [self isChangeFile]];		enablement: [self doesFileExist];		value: [self spawnConflicts];		yourself</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>menus-menu bar</category><body package="ProgrammingExtensions">menuBarTools	&lt;itemInMenu: #(#menuBar) position: 20.10&gt;	&lt;itemInMenu: #(#fileEditorMenuBar) position: 20.10&gt;	^(MenuItem labeled: #Tools &lt;&lt; #menus &gt;&gt; 'Tools')		submenu: [self toolsMenu];		yourself</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>menus-options</category><body package="ProgrammingExtensions">toolsBrowseItem	&lt;itemInMenu: #(#toolsMenu) position: 10.05&gt;	^(MenuItem labeled: #Browse &lt;&lt; #menus &gt;&gt; 'Browse')		nameKey: #browse;		value: [self browse];		yourself</body><body package="ProgrammingExtensions">toolsInspectItem	&lt;itemInMenu: #(#toolsMenu) position: 10.01&gt;	^(MenuItem labeled: #Inspect &lt;&lt; #menus &gt;&gt; 'Inspect')		nameKey: #inspect;		value: [self inspect];		yourself</body></methods><methods><class-id>UI.StandardSystemController</class-id> <category>menu messages</category><body package="ProgrammingExtensions">inspectView	"Inspect the view using either the window browse, if available, or, if the shift key is down, a standard inspector."	&lt;menuItem: 'Inspect Window'		nameKey: nil		menu: #(scheduledBlueButtonMenu)		position: 25.01&gt;	"TODO: ASB this is bad UI because how does the user know to hold down shift?"	self sensor shiftDown		ifTrue: [ view basicInspect ]		ifFalse: [ view inspect ]</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>actions</category><body package="ProgrammingExtensions">copyMethodDescriptor	&lt;	menuItem: 'Copy Method Descriptor'	nameKey: nil	menu: #(#mainMenu #utilities)	position: 10.03&gt;	TextEditorController copySelection: self methodClass name , '&gt;&gt;' , self selector</body><body package="ProgrammingExtensions">copyMethodDescriptorWithNamespace	&lt;	menuItem: 'Copy Method Descriptor with Namespace'	nameKey: nil	menu: #(#mainMenu #utilities)	position: 10.04&gt;	TextEditorController copySelection: self methodClass unambiguousName , '&gt;&gt;' , self selector</body><body package="ProgrammingExtensions">copySelector	&lt;	menuItem: 'Copy Selector'	nameKey: nil	menu: #(#mainMenu #utilities)	position: 10.02&gt;	TextEditorController copySelection: self selector</body><body package="ProgrammingExtensions">inspectMethod	"Inspect the current method."	&lt;menuItem: 'Inspect'		nameKey: nil		menu: #(#mainMenu #utilities)		position: 10.00 &gt;	self definition ifNotNil: [:def | def method inspect]</body><body package="ProgrammingExtensions">menuItemTemplate	"Make a template in the method that allows it to be declared	as a menu item for one of the receiver's menus."	&lt;menuItem: 'Make method a menu item'		nameKey: nil		menu: #(#mainMenu #utilities)		position: 20.1&gt;	self menuItemTemplate: #('menuItem:' 'my menu label' nil #(#menuName #submenuNameKey) 10.01)</body><body package="ProgrammingExtensions">selectorUtilities	&lt;submenu: 'Utilities'		nameKey: #utilities		menu: #(mainMenu)		position: 21.0&gt;</body><body package="ProgrammingExtensions">submenuTemplate	"Make a template in the method that allows it to be declared	as a menu item for one of the receiver's menus."	&lt;menuItem: 'Make method a submenu header'		nameKey: nil		menu: #(#mainMenu #utilities)		position: 20.2&gt;	self menuItemTemplate: #('submenu:' 'my menu' #submenuNameKey #(#menuName) 10.01)</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - changes</category><body package="ProgrammingExtensions">menuItemChangesFileTrim	&lt;menuItemForCommand: #trimChangesFile		nameKey: nil		menu: #(#menuBar #system #changes)		position: 30.1&gt;	(Dialog confirm: 'really trim the changes file?') ifTrue: [SourceFileManager default trimChanges]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools</category><body package="ProgrammingExtensions">menuItemOpenDifferator	&lt;menuItemForCommand: #openDifferator		nameKey: nil		menu: #(#menuBar #tools)		position: 40.1&gt;	self openApplicationForClassNamed: #Differator</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>actions</category><body package="ProgrammingExtensions">browseSubclassResponsibilities	"Open a list browser on all subclass responsibilities of this class.	 The list includes implementations that implement subclass responsibilities."	&lt;menuItem: 'Subclass Responsibilities'		nameKey: nil		enablement: #isClassSelected 		indication: nil		menu: #(#classMenu #Other)		position: 10.50 &gt;	| subclassResponsibilities thisClass srsym |	self updateRequest ifFalse: [^self].	subclassResponsibilities := OrderedCollection new.	srsym := 'subclassResponsibility' asSymbol. "Avoid including this method"	(((thisClass := self selectedClass) withAllSuperclasses collect: [:ea| ea class]),	thisClass withAllSuperclasses) reverseDo:		[:class |		(class whichSelectorsReferTo: srsym) do:			[:aSelector | | method def |			method := class compiledMethodAt: aSelector.			"If subclassResponsibility is in extended specialSelector set			 it won't be a literal so accept methods with no literals also."			method numLiterals &lt;= 1 ifTrue:				[subclassResponsibilities addLast: (def := MethodDefinition class: class selector: aSelector).				(Array with: thisClass with: thisClass class) do:					[:subclass| | implementingSuperclass |					((subclass inheritsFrom: class)					and: [(implementingSuperclass := subclass whichClassIncludesSelector: aSelector) ~= class]) ifTrue:						[subclassResponsibilities							addLast: (MethodDefinition											class: subclass											implementor: implementingSuperclass											selector: aSelector)]].				subclassResponsibilities last == def ifTrue:					[def extraText: ' (unimplemented)']]]].	MethodCollector new		openListBrowserOn: subclassResponsibilities		label: 'Subclass responsibilities of ' , thisClass fullName		initialSelection: nil</body><body package="ProgrammingExtensions">copyMethodDescriptor	&lt;	menuItem: 'Copy Method Descriptor'	nameKey: nil	enablement: #isMethodSelected	indication: nil	menu: #(#selectorMenu)	position: 90.7&gt;	TextEditorController copySelection: self methodClass name , '&gt;&gt;' , self selector</body><body package="ProgrammingExtensions">copyMethodDescriptorWithNamespace	&lt;	menuItem: 'Copy Method Descriptor with Namespace'	nameKey: nil	enablement: #isMethodSelected	indication: nil	menu: #(#selectorMenu)	position: 90.8&gt;	TextEditorController copySelection: self methodClass unambiguousName , '&gt;&gt;' , self selector</body><body package="ProgrammingExtensions">copySelector	&lt;	menuItem: 'Copy Selector'	nameKey: nil	enablement: #isMethodSelected	indication: nil	menu: #(#selectorMenu)	position: 90.6&gt;	TextEditorController copySelection: self selector</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FileBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName list myPattern selectionState autoRead lastModified currentFileEncoding defaultEncodings patternAspect menuBar showFullPath isDirty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>StandardSystemController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationStandardSystemController</name><environment>UI</environment><super>UI.StandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>CompositePart</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components preferredExtent layoutManager layoutIsInvalid minimumExtent maximumExtent alignmentRectInsets baseline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>BorderDecorator</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component policy hasBorder hasHorizontalScrollbar hasVerticalScrollbar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>TranslatingWrapper</name><environment>Graphics</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock transcriptView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>