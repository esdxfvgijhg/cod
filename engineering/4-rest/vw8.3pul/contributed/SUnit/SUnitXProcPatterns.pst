<?xml version="1.0"?><st-source><!-- Name: SUnitXProcPatternsComment: Pattern for making test results capture errors and failures raised	- in subprocesses spawned by the main test processor	- in actions created by the test but executed in pre-existing non-test processesor in a mixture of such cases.  This pattern requires method wrappers so can be ported to dialects that have them (e.g. VisualWorks, VisualAge, Squeak, etc.) but not to dialects that lack them.To use the pattern, either make your test class a subclass of CrossProcessTestCase or make it override TestCase>>run: with the implementation in CrossProcessTestCase>>run: (only use this latter way if you need to add the pattern to a subclass in an existing test hierarchy) and decide which strategy the test case requires.  TestCase>>crossProcessTestStrategy provides a default strategy.  Override this method for test cases that open windows or that send DeferrableActions to pre-existing processes (see CrossProcessTestStrategy class comment and 'strategy choosing' protocol method comments for more infomation).The basic pattern is to wrap	Process class>>forBlock:priority:so that all processes spawned (directly or recursively) by the test will have any errors or failures they raise trapped at the top of the spawned thread and added to the test result.  Subthread completion is tracked by a ProcrastinatingSemaphore which resumes when all spawned blocks signal completion or when a standard delay (set in the strategy, i.e. by overriding TestCase>>crossProcessTestStrategy) is exceeded.  Various subwrap* strategy methods help avoid trivial slowness to complete of UI tests by e.g. wrapping WindowManager>>unscheduleWindow: to check (after a short delay) whether the WindowManager>>newProcess should be terminated whenever a window is closed (see subwrap* method comments).Update:   in 7.7.1 and later, a window which closes itself also terminates its process (in #unscheduleWindow:).  The wrapping to check for termination is only required if tests' windows are externally terminated (as is the case in the SUnitXProcTests), where closeAndUnchedule is sent by the tests to the windows they create).An alternative or additional candidate for wrapping is	DeferrableAction>>block:(A trivial refactor of DeferrableAction>>message: in an override ensures that this captures all DeferrableActions.)  If events created by the test are for some reason to be run in a pre-existing processes (e.g. the WindowManager>>newProcess of a pre-existing window not spawned by the test) then, and only then, this may need to be wrapped instead;  override crossProcessTestStrategy as needed.  In this case probably only DeferrableActions that the tester expects to run will be created during the test, and so wrapped, as the process that runs them is not started or stopped by the test.  However note that DeferrableActions can be lost (i.e. never executed) when a WindowManager is closed (loss of a duplicate #sendTerminate-created event is routine) or when a TransientWindow is unmapped;  if a test includes such cases, completion strategies may need further resource wrappings to avoid waiting for the delay to timeout.  Any method whose first argument is a block (i.e. the block within which errors and failures are to be captured) can be wrapped.  All wrapped methods that share a strategy will share a ProcrastinatingSemaphore and so will (preferrably) all expect completion to be signalled in normal running (it is tedious to rely on the delay routinely, though essential to have it while coding and for some failure situations).Read the class comments for more details.Thanks to Reinout for pair-programming at CS10.DbIdentifier: bear73DbTrace: 368379DbUsername: nrossDbVersion: 7.9 - 1DevelopmentPrerequisites: #(#(#any 'SUnit' '') #(#any 'Method Wrapper Base' ''))PackageName: SUnitXProcPatternsParcel: #('SUnitXProcPatterns')ParcelName: SUnitXProcPatternsPrerequisiteParcels: #(#('SUnit' '') #('Method Wrapper Base' ''))PrintStringCache: (7.9 - 1,nross)Version: 7.9 - 1Date: 11:04:00 AM April 13, 2012 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.9 (apr12.1) of April 13, 2012 on April 13, 2012 at 11:04:00 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CrossProcessTestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitPatterns</category><attributes><package>SUnitXProcPatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.CrossProcessTestCase</class-id><body>CrossProcessTestCase wraps the blocks of any processes it forks in its test handler, suppressing debuggers and reporting the worst defect found in any process back to the overall result.  Thus running the test will not show spurious passes and debuggers when a problem is raised in a subthread.  Debugging the test behaves as normal.Just as an ordinary test run will not complete until it has executed all the test code, so a cross-process test case will not do so until it has executed all the code in the main process and every process spawned by it (see #waitTillSubThreadsComplete).</body></comment><class><name>CrossProcessTestStrategy</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase testResult subthreadCompletionSemaphore wrappers subThreadCompletionWaitTime </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Wrappers.*			</imports><category>SUnitPatterns</category><attributes><package>SUnitXProcPatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.CrossProcessTestStrategy</class-id><body>TestCase&gt;&gt;crossProcessTestStrategy, overridden by specific test cases as needed, returns an instance of me suitable to a given cross-process test case.  Strategies differ in their time-out delay (ideally, once the test is stable, it should be longer than any subthread will run) and in which wrappers they need:  tests that open and close windows need additional wrappers to detect subprocess completion;  tests that send actions to pre-existing processes need different wrappers from those that spawn subprocesses (and may also need additional wrappers to detect discarded, so non-completing, actions).Instance Variables:	subthreadCompletionSemaphore	&lt;ProcrastinatingSemaphore&gt;	I am unsignalled when a subthread is wrapped and signalled when it completes	subThreadCompletionWaitTime	&lt;SmallInteger&gt;	How long does the main thread wait for all subthreads to complete before resuming anyway	testCase	&lt;TestCase&gt;	the test whose subthreads are also to have their errors and failures captured to the testResult, just like the main thread	testResult	&lt;CrossProcessTestResult&gt;	capture thread- and subthread-raised defects;  provide the most serious to the outer test result	wrappers	&lt;(Collection of: MethodWrapper)&gt;	modify subthread spawning (and other methods as needed) during the test run</body></comment><class><name>CrossProcessTestResult</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitPatterns</category><attributes><package>SUnitXProcPatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.CrossProcessTestResult</class-id><body>I am created for a single test run, during which I capture defects raised by the main test process, by subprocesses it spawns and/or by actions it queues to pre-existing processes .  At the end of the run, I add the most serious defect raised to the overall test suites' test result.Adds to my collections are not synchronised as I need to know only whether one or more test cases were added to a given collection, not how many.</body></comment><class><name>CrossProcessTestWrapper</name><environment>XProgramming.SUnit</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>testStrategy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitPatterns</category><attributes><package>SUnitXProcPatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.CrossProcessTestWrapper</class-id><body>I can wrap Process class&gt;&gt;forBlock:priority:, DeferrableAction&gt;&gt;block: or any other method that has a no-arg-block as its first argument.  I replace the block argument with the modified block that my strategy returns to me.Instance Variables:	testStrategy	&lt;CrossProcessTestStrategy&gt;	convert no-arg block to no-arg block with additional behaviour</body></comment><class><name>ProcrastinatingSemaphore</name><environment>Core</environment><super>Core.Semaphore</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>deficitSignals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitPatterns</category><attributes><package>SUnitXProcPatterns</package></attributes></class><comment><class-id>Core.ProcrastinatingSemaphore</class-id><body>ProcrastinatingSemaphore is a Semaphore that can be told to wait for additional signals before unblocking.  It can be used instead of a shared queue of semaphores when, inversely to the standard semaphore usage pattern, a single process must wait on many.  It is simpler than sending multiple waits all of which but the last block trivial processes, and it is less order-dependent than that method.Sending #unsignal decrements the excessSignal count or increments the deficitSignal count (only one can be non-zero at a time).  The overall signal count (excessSignals - deficitSignals) can go negative and a waiting semaphore will not unblock until it returns to value 1.If the superclass in fact implemented an	excessSignals = 0check in its #wait primitive, it would be possible to have excessSignals become negative.  This was the case in VW7.8.1 and earlier, but in VW7.9 the primitives do in fact what their representative Smalltalk code implies by checking excessSignals &gt; 0, so that a negative excessSignals value is treated like a zero value.  In future, #signal and #unsignal in this class could be reimplemented as primitives by rewriting the super's primitive to allow negative excessSignals, thus eliminating the need for the deficitSignals instaVar.</body></comment><methods><class-id>XProgramming.SUnit.CrossProcessTestCase</class-id> <category>running</category><body package="SUnitXProcPatterns">run: aResult	"As this is the only method that a test case using the pattern must implement, you can add it to specific test cases instead of subclassing this specialized testcase class;  use whichever approach is more convenient.  (Remember to override #crossProcessTestStrategy if the default strategy is not the one you want.)"	| multithreadResult |	multithreadResult := CrossProcessTestResult new.	super run: multithreadResult.	multithreadResult hasErrors ifTrue: [^aResult errors add: self].	multithreadResult hasFailures ifTrue: [^aResult failures add: self].	^aResult passed add: self</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestCase class</class-id> <category>Testing</category><body package="SUnitXProcPatterns">isAbstract	^self sunitName = #CrossProcessTestCase</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestStrategy</class-id> <category>evaluating</category><body package="SUnitXProcPatterns">isUnderTest	"Any process spawned by the main test should be wrapped.  Any process spawned from within a wrapped context should be wrapped."	^(thisContext findParentContextWithHomeMethod:		(CrossProcessTestResult compiledMethodAt: #runCase:forBlock:))			notNil</body><body package="SUnitXProcPatterns">waitTillSubThreadsComplete	"Keep waiting till the last subprocess signals completion.  As a subprocess can spawn a subsubprocess after we reach here that then runs longer than its parent, we need to check we're the only test process, waiting some more if not.  (Could provide mechanism whereby specific test cases can override this with a simple delay if this 'procrastinate till last thread completes' pattern is seen as risky.)"	| timeoutProcess |	timeoutProcess :=		[(Delay forMilliseconds: subThreadCompletionWaitTime) wait.		[subthreadCompletionSemaphore isEmpty] whileFalse:			[subthreadCompletionSemaphore signal]] forkAt: Processor systemRockBottomPriority.	subthreadCompletionSemaphore wait.	timeoutProcess terminate.</body><body package="SUnitXProcPatterns">wrapBlock: anArrayWithFirstElementBlock	"The active process has invoked a method (e.g. #forBlock:priority: or DeferrableAction&gt;&gt;block:) that returns a process or action.  If the active process is under test, I replace the block argument with a modified block (so this becomes the block that the process or action will run) then unsignal the semaphore (so that it will wait for the upcoming subthread).  The modification ensures that when the process is resumed or the action is executed, the testResult runs the original block, trapping defects, and then signals the semaphore;  when all subthreads have signalled (or the test's subthreadCompletionWaitTime is exceeded), the main thread continues."	self isUnderTest ifTrue:		[| testSpawnedBlock | testSpawnedBlock := anArrayWithFirstElementBlock first.		anArrayWithFirstElementBlock at: 1 put:			[[testResult runCase: testCase forBlock: testSpawnedBlock.			subthreadCompletionSemaphore signal]				on: Process terminateSignal				do: [:ex | subthreadCompletionSemaphore signal.					ex pass]].		subthreadCompletionSemaphore unsignal].	^anArrayWithFirstElementBlock</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestStrategy</class-id> <category>strategy choosing</category><body package="SUnitXProcPatterns">subThreadCompletionWaitTime: anInteger	"Let tests, in #crossProcessTestStrategy, call this to override the default if they wish."	subThreadCompletionWaitTime := anInteger</body><body package="SUnitXProcPatterns">subwrapWindowUnscheduling	"If the test creates windows and closes them explicitly (i.e. they are sent #closeAndUnschedule from outside their own window manager's process) and WindowManager&gt;&gt;newProcess is wrapped, then test completion is speeded if we also wrap WindowManager&gt;&gt;unscheduleWindow: to check (at rockbottom priority, after a brief delay) whether the wrapped process should terminate.  Without this, the newProcess block of any manager created by the test may not terminate until the test UI, in updating, makes the WindowManager class check #terminateIfEmpty on all registered WindowManagers.  However this update may wait until the test completes and since the test is waiting until its spawned processes complete, the deadlock is only resolved when the test times-out waiting for them.  Hence in such a case, this wrapper makes completion signalling faster and more rational."	wrappers add:		((BlockMethodWrapper on: #unscheduleWindow: inClass: WindowManager)			afterBlock:				[:receiver :arguments | receiver hasWindows ifFalse:					[[receiver terminateIfEmpty] forkAt: Processor systemRockBottomPriority]];			yourself).</body><body package="SUnitXProcPatterns">wrapDeferrableActions	"This wraps all non-pathological ways of creating a DeferredAction (if that class' #message: method has been trivially refactored to use its #block: method).  It is only required when a test sends deferred actions to processes it did not create and so did not wrap, or when processes are not wrapped.  BE AWARE that deferrable actions may activate but silently not execute, e.g. closing a window can easily generate and then lose a second WindowManager&gt;&gt;sendTerminate action, requiring wrapping for to completion signalling when events are discarded from the eventQueue (e.g. in  WindowManager&gt;&gt;terminate and &gt;&gt;drainOutstandingEventsFor:)."	wrappers add:		((CrossProcessTestWrapper on: #block: inClass: DeferrableAction)			testStrategy: self;			yourself)</body><body package="SUnitXProcPatterns">wrapProcesses	"IMPORTANT: if the test creates windows, use #wrapProcessesForUI instead of me or add #subwrapWindowsUnscheduling to me (the effect is the same).  This wraps all non-pathological ways of creating processes."	wrappers add:		((CrossProcessTestWrapper on: #forBlock:priority: inClass: Process class)			testStrategy: self;			yourself)</body><body package="SUnitXProcPatterns">wrapProcessesForUI	"This wraps all non-pathological ways of creating processes.  It also wraps WindowManager&gt;&gt;unscheduleWindow: to check (after a brief delay) whether WindowManager&gt;&gt;newProcess should terminate, important if the test creates windows (see subwrapWindowUnscheduling comment)."	self wrapProcesses.	self subwrapWindowUnscheduling.</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestStrategy</class-id> <category>initialize-release</category><body package="SUnitXProcPatterns">initialize	wrappers := OrderedCollection new.	subThreadCompletionWaitTime := 5000.	subthreadCompletionSemaphore := ProcrastinatingSemaphore forMutualExclusion.</body><body package="SUnitXProcPatterns">install	wrappers do:		[:each |		testCase			deny: each isRivalWrapperInstalled			description: each printString, 'is already wrapped for cross-process testing'].	wrappers do: [:each | each install].</body><body package="SUnitXProcPatterns">setTestCase: aTestCase result: aTestResult	testResult := aTestResult.	testCase := aTestCase.</body><body package="SUnitXProcPatterns">uninstall	wrappers do: [:each | each uninstall].</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestStrategy class</class-id> <category>instance creation</category><body package="SUnitXProcPatterns">new	^super new initialize</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestResult</class-id> <category>running</category><body package="SUnitXProcPatterns">runCase: aTestCase	"The super call is refactored into runCase:forBlock: and the call of that here."	| testStrategy |	testStrategy := aTestCase crossProcessTestStrategy		setTestCase: aTestCase result: self.	[testStrategy install.	self runCase: aTestCase forBlock: [aTestCase runCase].	testStrategy waitTillSubThreadsComplete]		sunitEnsure: [testStrategy uninstall].</body><body package="SUnitXProcPatterns">runCase: aTestCase forBlock: aBlock	"This generalizes the superclass' #runCase: method to wrap the test handlers round a block, not a specific test method call, so enabling its use to capture defects raised in subthreads forked by the test.  The calls that add aTestCase to the result are not #critical:-protected for simplicity as we only care if one or more error or failure was found, not the exact number found in all threads, so the possibility of overwriting in writes from multiple subthreads is not a concern."	[aBlock value.				"the only change from super's #runCase:"	self addPass: aTestCase]		sunitOn: self class failure, self class error		do: [:signal |			signal sunitAnnounce: aTestCase toResult: self].</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestWrapper</class-id> <category>accessing</category><body package="SUnitXProcPatterns">testStrategy: aCrossProcessTestStrategy	testStrategy := aCrossProcessTestStrategy</body></methods><methods><class-id>XProgramming.SUnit.CrossProcessTestWrapper</class-id> <category>evaluating</category><body package="SUnitXProcPatterns">valueWithReceiver: aProcessClass arguments: anArrayWhoseFirstElementIsBlock	"If the parent process is a test process, wrap the forked block in a test handler that will capture any defects to the test result."	^clientMethod		valueWithReceiver: aProcessClass		arguments: (testStrategy wrapBlock: anArrayWhoseFirstElementIsBlock)</body></methods><methods><class-id>Core.ProcrastinatingSemaphore</class-id> <category>communication</category><body package="SUnitXProcPatterns">signal	"Do not resume a process waiting on me unless the deficitSignal count is zero, i.e. unless sufficient #signals have been sent to me to equal the #wait and all #unsignals."	[deficitSignals = 0		ifTrue: [super signal]		ifFalse: [deficitSignals := deficitSignals - 1]]			valueUnpreemptively.</body><body package="SUnitXProcPatterns">unsignal	"This method is a #wait that decrements the overall excessSignals - deficitSignals count but never causes me to suspend my process.  It is sent by processes that want my waiting process to go on waiting until they too signal the semaphore.  The actual #wait is sent in the process that is to wait.  This message can be sent to me before or after I receive #wait."	[excessSignals &gt; 0		ifTrue: [excessSignals := excessSignals - 1]		ifFalse: [deficitSignals := deficitSignals + 1]]			valueUnpreemptively.</body></methods><methods><class-id>Core.ProcrastinatingSemaphore</class-id> <category>initialize-release</category><body package="SUnitXProcPatterns">initSignals	deficitSignals := 0.	super initSignals.</body><body package="SUnitXProcPatterns">initSignalsTo: aNumber	"Deficit signals cannot be non-zero unless excessSignals is zero.  Because the supercall may send self signal, reset deficitSignals first."	aNumber = 0 ifFalse: [deficitSignals := 0].	super initSignalsTo: aNumber.</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>cross-process</category><body package="SUnitXProcPatterns">crossProcessTestStrategy	"IMPORTANT:  if the tests opens and closes windows, override this with .^.. wrapProcessesForUI (or ^super ... subwrapUnscheduleWindow)."	^CrossProcessTestStrategy new wrapProcesses"This default extends TestCase instead of CrossProcessTestCase to make it easier to add cross-process behaviour to TestCases that are deep in an otherwise-non-cross-process hierarchy."</body></methods><methods><class-id>UI.DeferrableAction</class-id> <category>accessing</category><body package="SUnitXProcPatterns">message: aMessage	"Refactored to allow the cross-process test utility to wrap the block with the test handler."	self block: [aMessage value].</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper</class-id> <category>querying</category><body package="SUnitXProcPatterns">isInstalled	^(mclass compiledMethodAt: selector ifAbsent: [nil]) == self</body><body package="SUnitXProcPatterns">isRivalWrapperInstalled	^(mclass compiledMethodAt: selector ifAbsent: [nil]) class == self class		and: [self isInstalled not]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>Semaphore</name><environment>Core</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>excessSignals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>TestResult</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failures errors passed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><class><name>DeferrableAction</name><environment>UI</environment><super>UI.Event</super><private>false</private><indexed-type>none</indexed-type><inst-vars>semaphore result action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class></st-source>