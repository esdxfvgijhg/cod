<?xml version="1.0"?><st-source><!-- Name: SUnitNotice: This software and documentation is provided as a service to the programming community. Distribute it free as you see fit. There is no warranty of any kind, express or implied.Comment: SUnit is the original test framework that now has so many *Unit imitators.  It powered test-driven development in the eXtreme Programming method, inspirer of all agile methods.  The current SUnit is little changed from the original but some features have been added:  additions to the assertion protocol, additional class TestResource and abstract superclass TestAsserter, and basic logging.Pluggable TestSuites and TestResults==============================Users of SUnit mainly subclass TestCase.  Recent versions make it easier to subclass TestSuite and/or TestResult in the more limited range of cases where that can be useful.  Use TestCase class>>suiteClass: to plug in a more specific TestSuite subclass if desired.  During a run, behaviour is principally on the TestSuite (and the tests), while data is captured on the TestResult, so the suggested specialisation strategy is to override #run (and/or other methods, but see the comment in TestSuite>>run) in a specific TestSuite subclass to effect the behaviour required - e.g. to capture the duration of the run, or the state of TestResources before all are reset at the end - and to add this data to a generic test result subclass intended to work with several such specific suite classes.  For an example of such a generic result class, see ClassifiedTestResult in SUnitResourcePatterns.  For an example of how TestResult subclasses may be plugged in and written by tests instead of, or as well as, the above, see TestSkip and references in that utility and in SUnitResourcePatternTests.Assertion description strings=====================Make your tests more informative by using #assert:description: and #deny:description: rather than just #assert and #deny.  These methods take a string as their second argument.  If the test case fails, this string will be shown in the notifier (and in the log, if logging is active) instead of the less informative default: 'Assertion failed'.  Writing description strings can also be an efficient way to document the intent of an assertion and to express what its failure would mean both in generic convenience protocol, e.g.	TestAsserter>>assert: anObject equals: anotherObject		self assert: anObject = anotherObject			description: anObject printString, ' is not equal to ', anotherObject printString.and in specific tests, e.g.		self deny: DbRegistry isOnline			description: ('I cannot meaningfully test connecting because we are already connected to <1p>'							expandMacrosWith: DbRegistry dbIdentifier).The description string can be constructed dynamically but remember, the string will be constructed whether or not the assertion fails;  e.g. in the example above, we write <1p> instead of <1s> to avoid DNUing when dbIdentifier returns nil.Resumable assertions================The default case is that a single failure halts a test, bypassing the remaining code and going immediately to #tearDown (or, if the failing assertion is in #tearDown, aborting the rest of that method):  the assumption is that later code in a test depends on earlier code having passed.  Sometimes this is not so and it is more useful to see when debugging (and/or to log when running) the results from several assertions in a test.  Example:	#(‘same’ ‘*’ ‘*.txt’ ‘a*c’) with: #(‘same’ ‘any’ ‘some.txt’ ‘abc’) do:		[:eachMeta :eachString |		self assert: (eachMeta match: eachString)			description: (‘<1s> does not match <2s>’ expandMacrosWith: eachMeta with: eachString)			resumable: true].Raising a ResumableTestFailure means that all the assertions will be run.  If the test case is logging, this will print out a message to the log for each one that fails.  When debugging, the user can hit 'proceed' to continue the test and see which other expressions do not match.Test resources===========A TestResource class holds a singleton instance that is set up when the first test that uses it is encountered and torn down at the end of the test suite's run.  TestResource understands #assert:description:, #deny:description:, etc., so that code written in the #setUp and #tearDown of a TestCase can easily be refactored into the #setUp and #tearDown of a TestResource if it starts to take too long.The order returned by TestCase class>>resources and TestResource class>>resources is respected:  resources are set up in that order and torn down in the reverse order.  For example, suppose a test requires both a resource that provides a database connection and another resource that adds some data temporarily to a database;  it can provide the resources in order and rely on their setUps and tearDowns being called in the correct order.  Where a resource is required by two other resources, it will not be torn down until both requirers have been torn down.TestResource class>>availableFor: defines what a resource does when a test or another resource requires it.  The standard behaviour is to assert that it is available, so raising a TestFailure if it is not, but a specialised resource subclass might override this.TestAsserter=========TestCase and TestResource share a common superclass TestAsserter, which understands the #assert:... and #deny:... protocol (its class-side understands #assert:description:).  If you find yourself refactoring common behaviour from test cases or test resources into a helper class, this may be a convenient superclass to use.Logging support=============The description strings described above may be logged to a Stream such as the Transcript, a file, stdout, etc. - Choose whether to log by overriding TestAsserter class>>isLogging - Choose where to log by overriding TestAsserter class>>failureLog or changing SUnitNameResolver defaultLogDevice (default is Transcript).  DbIdentifier: bear73DbTrace: 443174DbUsername: nrossDbVersion: 4.1 RC3DevelopmentPrerequisites: #(#(#any 'SUnitPreload' ''))PackageName: SUnitParcel: #('SUnit')ParcelName: SUnitPrerequisiteParcels: #(#('SUnitPreload' ''))PrintStringCache: (4.1 RC3,nross)Version: 4.1 RC3Date: 10:38:20 AM July 25, 2014 --><time-stamp>From VisualWorks®, Pre-Release 8.0 (jul14.3) of July 25, 2014 on July 25, 2014 at 10:38:20 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TestAsserter</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestAsserter</class-id><body>I understand methods beginning #assert:... and #deny:... (and my class-side understands #assert:description:).  I am the superclass of TestCase and TestResource and can also be the superclass of any test helper classes you create to factor out test behaviour.  I exist so that test code can be refactored between my subclasses without difficulty.Send #assert:description: when you want to check for an expected value. For example, you might say	self assert: socket isOpen description: 'We requested a socket but now it is not open'.to test whether or not a socket is open at a point in a test.  Use description strings both to give more information about where a test failed in debugger notifiers and logs, and to document the intent of a test.  Other methods include #assert:, #assert:description:resumable:, #deny:, #deny:description:, #deny:description:resumable:, #should:raise:, #should:raise:description:, #shouldnt:raise:, #shouldnt:raise:description:.  All these methods are defined on the superclass, TestAsserter.  (Any convenience assertion methods you create for general use should also be defined in my 'convenience' protocol.)Override my class-side #isLogging in subclasses to have failed assertion descriptions shown on the Transcript.  To have them appear elsewhere, also override my class-side #failureLog.</body></comment><class><name>TestResource</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestResource</class-id><body>Normally a test will set up all the objects it needs and tear them down again after it has run.  This self-containedness makes a test more robust.  Use TestResources only for objects that are needed by several tests and that are too 'expensive' (in time or otherwise) to recreate and destroy for each test.  A viable approach is to develop the code in MyTestCase's #setUp and #tearDown methods, then at some point refactor the code into the #setUp and #tearDown of a TestResource whose class is added to MyTestCase class&gt;&gt;resource method.TestResource uses the singleton pattern.  A TestResource class will set up a single instance of itself when first requested and tear it down again at the end of TestSuite&gt;&gt;run (or TestCase&gt;&gt;run, &gt;&gt;debug and &gt;&gt;debugAsFailure).  Normally, a TestResource, once setUp, remains active during the running of all remaining tests and is #reset after all tests have run.  For an exception, see subclass CompetingResource in SUnitResourcePatterns.  Users can choose to #reset a resource in the #tearDown of a test that alters it, sacrificing the performance gain of having a single #setUp of the resource for the certainty that other tests using it will not see the alterations.  Generally however, this should be the exception:  if you need to reset the resource for every test that uses it, its code should just be part of your test's #setUp and #tearDown code.To use, create a subclass of TestResource and override the following:	- TestCase class&gt;&gt;resources, to return a collection including the TestResource class, for all test case classes that need it		* a TestCase' resources are set up in the order returned and torn down in the reverse order	- TestResource class&gt;&gt;resources, if the resource itself always needs some other resource to be present before it can set up		* a TestResource's resource are set up before it and torn down after it, and are set up in the order returned and torn down in the reverse order	- TestResource&gt;&gt;setUp and tearDown, to define initial and final behaviour (just like a test)	- TestResource&gt;&gt;isAvailable, to return true if it is and false if it isn't (the framework calls this after setUp);  ideally, this call should not change the resource' state - that should be done in setUpTestResource implements the singleton pattern in its class-side #isAvailable and #reset methods.  Do not override these when creating specific resources;  unless you are developing a whole new pattern of use, it will always be correct to override instance-side #setUp, #tearDown and #isAvailable, and dangerous to override class&gt;&gt;isAvailable, class&gt;&gt;isAlreadyAvailable and class&gt;&gt;reset.Generally, users do not code interactions with a test's resources during the running of a test.  Code that reads a resource' values while leaving its state strictly alone is safe enough.  A test must leave a resource in a clean state:  always use #reset if a test must protect later-running tests from unsafe changes (and review whether in such a case a resource is the right thing to use in the first place).See my superclass' comment for assertion and logging information.</body></comment><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestCase</class-id><body>A TestCase is an implementation of the Command pattern to run a test.  TestCase instances are created with the class method #selector:, passing the symbol that names the method to be executed when the test case runs.  Various UIs exist to run these instances and they can also be created and run programmatically.When you discover a new fixture, subclass TestCase and create a #test... method for the first test.  As that method develops and more #test... methods are added, you will find yourself refactoring temps into instance variables for the objects in the fixture and overriding #setUp to initialize these variables.  As required, override #tearDown to nil references, release objects and deallocate.See my superclass' comment for assertion and logging information.Instance Variables	testSelector	&lt;Symbol&gt;	Running a test instance calls this method, after #setUp and before ensured #tearDownClass Instance Variables	suiteClass		&lt;nil | TestSuite class&gt;	When this is nil (the default value), the framework default (TestSuite) is used.											If the user sets its value to a TestSuite subclass, that will be used for all runs											in the image until the user supplies another, or flushes to revert to the default.</body></comment><class><name>TestResult</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failures errors passed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestResult</class-id><body>This implements the Collecting Parameter pattern for running a bunch of tests.  It holds tests that have run, sorted into the result categories of passed, failures and errors.TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. TestResult subclasses can  handle multi-threaded tests (see SUnitXProcPatterns) and might record coverage information or send emails when the run completes.</body></comment><class><name>TestSuite</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tests resources name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestSuite</class-id><body>This is a Composite of Tests, either TestCases or other TestSuites. The top-level protocol is #run.  This creates aTestResult and sends	self run: aTestResult.then ensures that any TestResources made available during the run are reset.  These, and the dependencies protocol, are common between this and TestCase.</body></comment><shared-variable><name>SuiteClass</name><environment>XProgramming.SUnit.TestCase</environment><private>false</private><constant>false</constant><category>New Share</category><attributes><package>SUnit</package></attributes></shared-variable><methods><class-id>XProgramming.SUnit.TestAsserter</class-id> <category>logging</category><body package="SUnit">logFailure: aString	self class logFailure: aString.</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter</class-id> <category>asserting</category><body package="SUnit">assert: aBoolean	aBoolean ifFalse:		[self logFailure: 'Assertion failed'.		TestResult failure sunitSignalWith: 'Assertion failed'].</body><body package="SUnit">assert: aBoolean description: aString	aBoolean ifFalse:		[self logFailure: aString.		TestResult failure sunitSignalWith: aString].</body><body package="SUnit">assert: aBoolean description: aString resumable: resumableBoolean	| exception |	aBoolean ifFalse:		[self logFailure: aString.		exception := resumableBoolean			ifTrue: [TestResult resumableFailure]			ifFalse: [TestResult failure].		exception sunitSignalWith: aString].</body><body package="SUnit">deny: aBoolean	self assert: aBoolean not.</body><body package="SUnit">deny: aBoolean description: aString	self assert: aBoolean not description: aString.</body><body package="SUnit">deny: aBoolean description: aString resumable: resumableBoolean	self assert: aBoolean not description: aString resumable: resumableBoolean.</body><body package="SUnit">should: aBlock raise: anExceptionalEvent 	self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent).</body><body package="SUnit">should: aBlock raise: anExceptionalEvent description: aString 	self		assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)		description: aString.</body><body package="SUnit">shouldnt: aBlock raise: anExceptionalEvent 	self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not.</body><body package="SUnit">shouldnt: aBlock raise: anExceptionalEvent description: aString 	self		assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString.</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter</class-id> <category>private</category><body package="SUnit">executeShould: aBlock inScopeOf: anExceptionalEvent	^[aBlock value. 	false]		sunitOn: anExceptionalEvent		do: [:ex | ex sunitExitWith: true]</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter</class-id> <category>convenience</category><body package="SUnit">assert: anObject equals: anotherObject	self assert: anObject = anotherObject		description: anObject printString, ' is not equal to ', anotherObject printString.</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter class</class-id> <category>logging</category><body package="SUnit">failureLog	^SUnitNameResolver defaultLogDevice</body><body package="SUnit">isLogging	"By default, we're not logging failures. Override in subclasses as desired."	^false</body><body package="SUnit">logFailure: aString	self isLogging ifTrue:		[self failureLog cr; nextPutAll: aString; flush].</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter class</class-id> <category>asserting</category><body package="SUnit">assert: aBoolean description: aString	"Minimal clone of the instance-side assert protocol so that class-side methods can use it."	aBoolean ifFalse:		[self logFailure: aString.		TestResult failure sunitSignalWith: aString].</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>accessing</category><body package="SUnit">description	description isNil		ifTrue: [^''].	^description</body><body package="SUnit">description: aString	description := aString</body><body package="SUnit">name	name isNil		ifTrue: [^self printString].	^name</body><body package="SUnit">name: aString	name := aString</body><body package="SUnit">resources	^self class resources</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>printing</category><body package="SUnit">printOn: aStream	aStream nextPutAll: self class printString</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>running</category><body package="SUnit">setUp	"Does nothing. Subclasses should override this to initialize their resource"</body><body package="SUnit">tearDown	"Does nothing. Subclasses should override this to tear down their resource"</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>testing</category><body package="SUnit">isAvailable	"Override to provide information on the readiness of the resource.  Put state-changing behaviour in setUp and keep this a state-preserving check as far as possible.  Where setUp is guaranteed to provide a valid resource if it completes, there is no need to override this."		^true</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>initialize-release</category><body package="SUnit">initialize	"This method used to call setUp but now does nothing;  setUp is called by the framework at the appropriate point.  Subclasses may override to set the object to its default state."</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>testing</category><body package="SUnit">isAlreadyAvailable	^current class == self</body><body package="SUnit">isAvailable	"This is (and must be) a lazy method.  If my current has a value, an attempt to make me available has already been made:  trust its result.  If not, try to make me available."	current isNil ifTrue: [self makeAvailable].	^self isAlreadyAvailable</body><body package="SUnit">isUninvoked	"This resource has not been invoked (or has been reset)."	^current isNil</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>accessing</category><body package="SUnit">current	"This is a lazy accessor:  the assert of self isAvailable does no work unless current isNil.  However this method should normally be sent only to a resource that should already have been made available, e.g. in a test whose test case class has the resource class in its #resources, so should never be able to fail the assert.	If the intent is indeed to access a possibly-unprepared or reset-in-earlier-test resource lazily, then preface the call of 'MyResource current' with 'MyResource availableFor: self'."	self assert: self isAvailable		description: 'Sent #current to unavailable resource ', self name, '.  Add the resource to the class-side #resources for the test case (recommended), or send #availableFor: beforehand'.	^current</body><body package="SUnit">resources	^#()</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>instance creation</category><body package="SUnit">new	"Use #current to get the valid current instance.  Use of #new to get an instance (that should never be the current one) could be done in bizarre circumstances, so is not blocked, but will usually be inappropriate."	^super new initialize</body><body package="SUnit">reset	[self isAlreadyAvailable ifTrue: [current tearDown]]		sunitEnsure: [current := nil].</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>private</category><body package="SUnit">makeAvailable	"This method must be the _only_ way to set a notNil value for the unique instance (current).  First, obtain a candidate instance and set current to a notNil placeholder (any notNil object not an instance of me would do;  this version uses false).  Next, check any subordinate resources needed by this resource.  Lastly, setUp the candidate and put it in current if it is available, ensuring that it is torn down otherwise."	| candidate |	current := false.	candidate := self new.	self resources do: [:each | each availableFor: candidate].	[candidate setUp.	candidate isAvailable ifTrue: [current := candidate]]		sunitEnsure: [current == candidate ifFalse: [candidate tearDown]].</body><body package="SUnit">resetOrAddResourcesTo: aCollection	"Add correctly set-up resources to the collection unless already there. Reset any imperfectly-set-up resources, so current isNil will return true if they are re-encountered via an indirectly self-prerequing resource;  circular references cannot be set up so will never reply true to isAlreadyAvailable, but may have correctly-set-up prereqs to add and/or imperfectly-set-up ones to reset, so do not abort the loop first time round."	current isNil ifTrue: [^self].	self isAlreadyAvailable		ifFalse:			[self reset.			self resources do: [:each | each resetOrAddResourcesTo: aCollection]]		ifTrue:			[(aCollection includes: self) ifFalse:				[self resources do: [:each | each resetOrAddResourcesTo: aCollection].				aCollection add: self]]."The cloned 'self resources do: ...' line in both blocks is, I think, the best way to write this method so that its logic is clear.  The first loop resets this resource immediately, before traversing its resources;  the second traverses before adding"</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>running</category><body package="SUnit">availableFor: aTestAsserter	aTestAsserter		assert: self isAvailable		description: 'Unavailable resource ' , self name , ' requested by ', aTestAsserter printString.</body><body package="SUnit">resetResources: topLevelResources	"Reset all imperfectly-set-up resources while gathering the rest for ordered resetting."	| availableResources |	availableResources := OrderedCollection new: topLevelResources size.	topLevelResources do: [:each | each resetOrAddResourcesTo: availableResources]. 	availableResources reverseDo: [:each | each reset].</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>accessing</category><body package="SUnit">resources	"We give TestCase this instance-side method so that methods polymorphic with TestSuite can be code-identical.  Having this instance-side method also helps when writing tests of resource behaviour. Except for such tests, it is rare to override this method and should not be done without thought.  If there were a good reason why a single test case needed to share tests requiring different resources, it might be legitimate."	^self class resources</body><body package="SUnit">selector	^testSelector</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>deprecated</category><body package="SUnit">debugAsFailure	| semaphore |	semaphore := Semaphore new.	[semaphore wait. TestResource resetResources: self resources] fork.	(self class selector: testSelector) runCaseAsFailure: semaphore.</body><body package="SUnit">openDebuggerOnFailingTestMethod	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 	 send into 'self perform: testSelector' to see the failure from the beginning"	self		halt;		performTest</body><body package="SUnit">runCaseAsFailure: aSemaphore	[self resources do: [:each | each availableFor: self].	[self setUp.	self openDebuggerOnFailingTestMethod]		sunitEnsure: [self tearDown]]			sunitEnsure: [aSemaphore signal].</body><body package="SUnit">should: aBlock	self assert: aBlock value</body><body package="SUnit">should: aBlock description: aString	self assert: aBlock value description: aString</body><body package="SUnit">shouldnt: aBlock	self deny: aBlock value</body><body package="SUnit">shouldnt: aBlock description: aString	self deny: aBlock value description: aString</body><body package="SUnit">signalFailure: aString	TestResult failure sunitSignalWith: aString.</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>dependencies</category><body package="SUnit">addDependentToHierachy: anObject 	"an empty method. for Composite compability with TestSuite"</body><body package="SUnit">removeDependentFromHierachy: anObject 	"an empty method. for Composite compability with TestSuite"</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>printing</category><body package="SUnit">printOn: aStream	aStream		nextPutAll: self class printString;		nextPutAll: '&gt;&gt;#';		nextPutAll: testSelector</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>private</category><body package="SUnit">performTest	self perform: testSelector sunitAsSymbol</body><body package="SUnit">run: aResult	"I am called within #run and am not a top-level API method.  I am polymorphic with TestSuite&gt;&gt;run:"	aResult runCase: self</body><body package="SUnit">setTestSelector: aSymbol	testSelector := aSymbol</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>running</category><body package="SUnit">debug	"I do what exactly run does except that I do not suppress raising of errors.  I am polymorphic with TestSuite&gt;&gt;debug.  (There is no TestCase&gt;&gt;debug: as there is no need for it to dispatch to the TestResult as the intent is _not_ to suppress errors.)"	[self asNew runCase]		sunitEnsure: [TestResource resetResources: self resources].</body><body package="SUnit">run	"This method is a polymorph of TestSuite&gt;&gt;run.  Its task is to run the test and then ensure any resources it used are torn down.  (Set up of resources is done in #runCase using a just-in-time pattern).  It is not normally overridden in a subclass (usually #setUp and #tearDown are the methods to override);  if it is, ensure tear down of resources is still done (via super call of it or otherwise)."	| result |	result := TestResult new.	[self run: result]		sunitEnsure: [TestResource resetResources: self resources].	^result</body><body package="SUnit">runCase	"This can be overridden to do before and after work but he super runCase call would be dangerous to omit."	self resources do: [:each | each availableFor: self].	[self setUp.	self performTest] sunitEnsure: [self tearDown]</body><body package="SUnit">setUp	"This and tearDown are the normal methods to override to give specific pre-test and post-test behaviour."</body><body package="SUnit">tearDown	"This and setUp are the normal methods to override to give specific post-test and pre-test behaviour."</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>comparing</category><body package="SUnit">= aTestCase	^self class = aTestCase class		and: [self selector = aTestCase selector]</body><body package="SUnit">hash	^self class hash bitXor: self selector hash</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>copying</category><body package="SUnit">asNew	"Return a new instance whose key instvars are the same as this one's (usually, this will be the same as: 'create a new instance which is equal to this one') and whose other instvars have their initialized values, e.g. nil.	For a typical test case, this means 'create a new instance with the same testSelector'.  Subclasses may override this method to copy additional instvars _only_ when these define the test case, i.e. are key instvars that need to be copied for a rerun to be valid.  Usually, there will be no such additional instvars."	^self class selector: self selector</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>accessing</category><body package="SUnit">allTestSelectors	| answer pivotClass lookupRoot |	answer := Set withAll: self testSelectors.	self shouldInheritSelectors ifTrue:		[pivotClass := self.		lookupRoot := self lookupHierarchyRoot.		[pivotClass == lookupRoot] whileFalse:			[pivotClass := pivotClass superclass.			answer addAll: pivotClass testSelectors]].	^answer asSortedCollection asOrderedCollection</body><body package="SUnit">lookupHierarchyRoot	^TestCase</body><body package="SUnit">resources	^#()</body><body package="SUnit">sunitVersion	^'4.0'</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>testing</category><body package="SUnit">isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self sunitName = #TestCase</body><body package="SUnit">shouldInheritSelectors	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."	^self ~~ self lookupHierarchyRoot		and: [self superclass isAbstract			or: [self testSelectors isEmpty]]</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>instance creation</category><body package="SUnit">run: aSymbol	^(self selector: aSymbol) run</body><body package="SUnit">selector: aSymbol	^self new setTestSelector: aSymbol</body><body package="SUnit">suite	^self buildSuite</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>private</category><body package="SUnit">testSelectors	"The API method is allTestSelectors which now includes #shouldInheritSelectors and so handles all cases.  Unlike that method, this does not guarantee to return a sorted ordered collection."	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>building suites</category><body package="SUnit">buildSuite	| suite |	^self isAbstract		ifTrue:			[suite := self suiteClass named: self name asString.			self allSubclasses do:				[:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].			suite]		ifFalse: [self buildSuiteFromSelectors]</body><body package="SUnit">buildSuiteFromMethods: testMethods	^testMethods		inject: (self suiteClass named: self name asString)		into:			[:suite :selector |			suite				addTest: (self selector: selector);				yourself]</body><body package="SUnit">buildSuiteFromSelectors	^self buildSuiteFromMethods: self allTestSelectors</body><body package="SUnit">flushSuiteClass	SuiteClass := nil.</body><body package="SUnit">suiteClass	^SuiteClass ifNil: [TestSuite]</body><body package="SUnit">suiteClass: aTestSuiteClass	SuiteClass := aTestSuiteClass.</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>deprecation</category><body package="SUnit">debug: aSymbol	"This method is deprecated.  It appears to be unused."	^(self selector: aSymbol) debug</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>testing</category><body package="SUnit">hasErrors	^self errors size &gt; 0</body><body package="SUnit">hasFailures	^self failures size &gt; 0</body><body package="SUnit">hasPassed	^self hasErrors not and: [self hasFailures not]</body><body package="SUnit">isError: aTestCase	^self errors includes: aTestCase</body><body package="SUnit">isFailure: aTestCase	^self failures includes: aTestCase</body><body package="SUnit">isPassed: aTestCase	^self passed includes: aTestCase</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>accessing</category><body package="SUnit">defects	^OrderedCollection new		addAll: self errors;		addAll: self failures; yourself</body><body package="SUnit">errorCount	^self errors size</body><body package="SUnit">errors	errors isNil ifTrue: [errors := OrderedCollection new].	^errors</body><body package="SUnit">failureCount	^self failures size</body><body package="SUnit">failures	"We use a Set, not an OrderedCollection as #errors and #passed do, because a resumable test failure in a loop can raise many failures against the same test.  In current Sunit UIs, this could result in bizarre test count reporting (-27 tests run, and suchlike).  This will be reviewed."	failures isNil ifTrue: [failures := Set new].	^failures</body><body package="SUnit">passed	passed isNil ifTrue: [passed := OrderedCollection new].	^passed</body><body package="SUnit">passedCount	^self passed size</body><body package="SUnit">runCount	^self passedCount + self failureCount + self errorCount</body><body package="SUnit">tests	^(OrderedCollection new: self runCount)		addAll: self passed;		addAll: self errors;		addAll: self failures;		yourself</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>initialize-release</category><body package="SUnit">initialize</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>deprecated</category><body package="SUnit">correctCount	"deprecated - use #passedCount"	^self passedCount</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>running</category><body package="SUnit">runCase: aTestCase	[aTestCase runCase.	self addPass: aTestCase]		sunitOn: self class failure , self class error		do: [:ex | ex sunitAnnounce: aTestCase toResult: self].</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>adding</category><body package="SUnit">addError: aTestCase	^self errors add: aTestCase</body><body package="SUnit">addFailure: aTestCase	^self failures add: aTestCase</body><body package="SUnit">addPass: aTestCase	"If a test raises a resumable test failure then it will be added to failures, but the test will then resume;  if it runs to the end, it will call this method.  Guard against this (returning nil instead of aTestCase when so, to let subclasses know in case they also wish to guard against it)."	^(self failures includes: aTestCase) ifFalse:		[self passed add: aTestCase]</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>printing</category><body package="SUnit">printOn: aStream	aStream		nextPutAll: self runCount printString;		nextPutAll: ' run, ';		nextPutAll: self passedCount printString;		nextPutAll: ' passed, ';		nextPutAll: self failureCount printString;		nextPutAll: ' failed, ';		nextPutAll: self errorCount printString;		nextPutAll: ' error'.	self errorCount ~= 1		ifTrue: [aStream nextPut: $s]</body></methods><methods><class-id>XProgramming.SUnit.TestResult class</class-id> <category>exceptions</category><body package="SUnit">error	^self exError</body><body package="SUnit">exError	^SUnitNameResolver errorObject</body><body package="SUnit">failure	^TestFailure</body><body package="SUnit">resumableFailure	^ResumableTestFailure</body><body package="SUnit">signalErrorWith: aString 	self error sunitSignalWith: aString</body><body package="SUnit">signalFailureWith: aString 	self failure sunitSignalWith: aString</body></methods><methods><class-id>XProgramming.SUnit.TestResult class</class-id> <category>instance creation</category><body package="SUnit">new	^super new initialize</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>accessing</category><body package="SUnit">addTest: aTest	self tests add: aTest</body><body package="SUnit">addTests: aCollection 	aCollection do: [:eachTest | self addTest: eachTest]</body><body package="SUnit">defaultResources	^self tests		inject: OrderedCollection new		into:			[:coll :testCase |			testCase resources do:				[:each |				(coll includes: each) ifFalse: [coll add: each]].			coll]</body><body package="SUnit">name	^name</body><body package="SUnit">name: aString	name := aString</body><body package="SUnit">resources	resources isNil ifTrue: [resources := self defaultResources].	^resources</body><body package="SUnit">resources: someOrderedTestResourceClasses	"The parameter should understand reverseDo: and should not contain duplicates."	resources := someOrderedTestResourceClasses</body><body package="SUnit">tests	tests isNil ifTrue: [tests := OrderedCollection new].	^tests</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>dependencies</category><body package="SUnit">addDependentToHierachy: anObject	self sunitAddDependent: anObject.	self tests do: [ :each | each addDependentToHierachy: anObject]</body><body package="SUnit">removeDependentFromHierachy: anObject	self sunitRemoveDependent: anObject.	self tests do: [ :each | each removeDependentFromHierachy: anObject]</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>initialize-release</category><body package="SUnit">newTestResult	^TestResult new</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>running</category><body package="SUnit">debug	"This method is a polymorph of TestCase&gt;&gt;debug.  Its task is to run the tests in debug mode and then ensure any resources they used are torn down.  (Set up of resources is done in #runCase using a just-in-time pattern).  If it is overridden in a subclass, ensure tear down of resources is still done (via super call of it or otherwise)."	| result |	result := self newTestResult.	[self debug: result]		sunitEnsure: [TestResource resetResources: self resources].	^result</body><body package="SUnit">run	"This method is a polymorph of TestCase&gt;&gt;run.  Its task is to run the tests and then ensure any resources they used are torn down.  (Set up of resources is done in #runCase using a just-in-time pattern).  If it is overridden in a subclass, ensure tear down of resources is still done (via super call of it or otherwise)."	| result |	result := self newTestResult.	[self run: result]		sunitEnsure: [TestResource resetResources: self resources].	^result</body><body package="SUnit">run: aResult	"This method is called within #run.  It is not a top-level API method.  It is polymorphic with TestSuite&gt;&gt;run:"	self tests do:		[:each |		self sunitChanged: each.		each run: aResult]</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>private</category><body package="SUnit">debug: aResult	"This method is called within #debug.  It is not a top-level API method.  (There is no TestCase&gt;&gt;debug: as there is no need for a test to dispatch to the TestResult because the intent is _not_ to suppress errors.)"	self tests do:		[:each |		self sunitChanged: each.		each runCase].</body></methods><methods><class-id>XProgramming.SUnit.TestSuite class</class-id> <category>instance creation</category><body package="SUnit">named: aString	^self new		name: aString;		yourself</body></methods><methods><class-id>XProgramming.SUnit.TestSuite class</class-id> <category>initialize-release</category><body package="SUnit">obsolete	"Good housekeeping:  if a subclass of me is being unloaded, ensure TestCase is not referencing it."	TestCase suiteClass == self ifTrue: [TestCase flushSuiteClass].	super obsolete.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>