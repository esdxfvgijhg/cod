<?xml version="1.0"?><st-source><!-- Name: SUnitResourcePatternsNotice: Copyright 2005 - 2015 Niall RossThis utility is free to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: Normal use of SUnit involves much subclassing of TestCase, leaving the other concrete classes of the framework alone.  This utility contains examples of subclassing TestSuite, TestResult, TestFailure and TestResource.  The following is a summary:  see each subclass' comments for details.If RBSUnitShowResult is loaded, you can use the Tools > Testing page of the VisualLauncher settings to set suite and result classes for the image.  If not (or instead), execute	XProgramming.SUnit.TestCase suiteClass: <TestSuite subclass>to use a TestSuite subclass and	XProgramming.SUnit.TestCase suiteClass:		(<PluggableSuite or subclass> resultClass: <TestResult subclass>)to use a TestResult subclass.  To revert, execute	XProgramming.SUnit.TestCase suiteClass: XProgramming.SUnit.TestSuite.TestSuite subclasses include:	MinimalResConflictSuite:  pessimistic handling of possible resource conflicts (only OK if shared in class)	PackageResConflictSuite:  less pessimistic handling of possible resource conflicts (OK if shared in package)	RandomSuite:  run the tests in a random order	FastSuite:  only raise #changed notifications when a given time has elapsedTestResults subclasses include:	ClassifiedTestResult:  classify results against any tag, not just pass/fail/error	KeepLatestResult:  (in RBSUnitShowResult) classify results against any tag, not just pass/fail/errorTestFailure subclass: TestSkip is used by skipUnless:{description:}, skipIf:{description:} or (variant form) #assert:orSkip:, #deny:orSkip: to replace TestCase or TestResource code of the form:	self platform isMac ifFalse: [^self].	"This test only makes sense on Mac OS"with	self skipUnless: self isOnMac		description: 'This test only makes sense on Mac OS'.When running a suite containing tests with this protocol, standard practice is to use the subclassing pattern above to ensure the test result is a ClassifiedResult (or subclass or compatible class).  However calling #addSkip: on a TestResult transforms it into a ClassifiedResult, to which further skips or other specialised results may be added (but this uses #become:, hence the preference for anticipating the need by plugging in the result subclass).  TestResource subclasses:	- InvariantResource:  when you want a run to leave the resource active if and only if it was active before the run started.	- CompetingResource:  when two (or more) resources cannot both be available at the same time but you wish to run tests using both in an optimistic suite.DbIdentifier: bear73DbTrace: 469232DbUsername: nrossDbVersion: 4.1 RC4DevelopmentPrerequisites: #(#(#any 'SUnit' ''))Namespace: XProgramming.SUnitPackageName: SUnitResourcePatternsParcel: #('SUnitResourcePatterns')ParcelName: SUnitResourcePatternsPrerequisiteParcels: #(#('SUnit' ''))PrintStringCache: (4.1 RC4,nross)Version: 4.1 RC4Date: 9:36:57 AM July 24, 2015 --><time-stamp>From VisualWorksÂ®, 8.1 of July 24, 2015 on July 24, 2015 at 9:36:57 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ClassifiedTestResult</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classifiedResults </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.ClassifiedTestResult</class-id><body>I classify tests as passed, failures and errors, as my superclass does, or as any classification I am handed in	addClassification: aString ofTestCase: aTestCaseFor example, when I am sent	addOutcome: aTestCase ofTestCase: aTestSkipthen I classify that test case against 'skip' (the value returned by aTestSkip class classificationTag) and report e.g.	0 run, 0 passed, 0 failures, 0 error, 1 skipNote that only passes, failures and errors count as run, so a test exception that classifies itself in my dictionary can also put itself in one of these categories, and so appear in the run list, or not, and so be omitted from the run count.While tearing down resources, I reclassify any tests that were failed by a resource against the failing resource's #classificationTag (which is the class' name unless the user has overridden that method for it).  Thus a run's result could read	8 run, 8 passed, 0 failures, 0 error, 7 DatabaseResourceif 15 tests were run but 7 needed a database resource that could not be set up.There are two ways I can be used in a test run.* Firstly I can be set as the default:  either set me as the 'Test Result Class' in the Tools &gt; Testing page of the VisualLauncher settings, or execute:	XProgramming.SUnit.TestCase suiteClass resultClass: self.(Note that the suiteClass must be PluggableTestSuite or a subclass before this can be done.)  To revert, reset the setting or re-execute the above.* Secondly, the test run's result can become an instance of me during the run by a test that raises an outcome that demands me;  see TestResult&gt;&gt;addOutcome:exception:.</body></comment><class><name>PluggableSuite</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestSuite</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>resultClass </class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.PluggableSuite</class-id><body>I enable pairing of teste suite and test result classes.  Plug the desired TestResult subclass into the 'resultClass' class instance variable of me or (if specialised test suite behaviour is also wanted) the desired subclass of me.</body></comment><class><name>FastSuite</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.PluggableSuite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastRunStatusUpdate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.FastSuite</class-id><body>I only raise #changed notifications when enough time has elapsed.  I am for running tests that take so little time that updating tools between each test would affect the perceived time unduly.To use, set me as the suite class in the Tools &gt; Testing page of the VisualLauncher settings, or execute:	XProgramming.SUnit.TestSuite suiteClass: self.To revert, reset the setting or re-execute the above.</body></comment><class><name>TestSkip</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestFailure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitResourcePatternsPreload</category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.TestSkip</class-id><body>I am raised by tests that send #skip, #skipUnless:{description:} or #skipIf:{description:} or (variant protocol) #assert:orSkip: or #deny:orSkip:.  Any such test is not run further, so is classified as skipped, neither passing nor failing.  Running a test that is skipped expects a ClassifiedTestResult or subclass (and will #become: the result to be so if not already, but arranging it so from the run start is better practice).</body></comment><class><name>LimitResConflictSuite</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.PluggableSuite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourceSetsToSuites </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.LimitResConflictSuite</class-id><body>I implement resource handling according to wholly or partially pessimistic principles.  The resources of the whole suite are split into groups according to some rule defined in a concrete subclass, each group keying a suite of tests needing resources in that group.  A suitable rule is one giving some expectation that the resources in the group can be expected to work together.  All tests keyed by a given group are run, then all resources in the group are torn down before the next group starts.The optimistic versus pessimistic trade-off is about speed of running versus not having explicitly to tag competing resources.  The larger the resource groups are, the less often we will set up and tear down a resource multiple times, but the greater the possibility that two resources might conflict and need to be explicitly tagged as belonging to a conflict set.  The fully-optimistic approach of base SUnit is at one end of this spectrum.  The fully pessimistic approach of my MinimalResConflictSuite subclass is at the other end (and is the same as SUnitToo's approach).My main function is to be an abstract class for subclasses with sensibly-chosen conflict group rules.  However I can also be used as a concrete class for the most extreme case of assuming that every test's resources can interfere with every other test's resources and/or that we wish to run in a non-resource-pattern manner.  By making each test be its own conflict resolution group we ensure that (the run may take a long time and) test resources are set up and torn down exactly as if they were part of the test's own setUp and tearDown.Instance Variables	resourceSetsToSuites	&lt;Dictionary&gt;	test suites keyed by some aspect shared by all tests in the suite</body></comment><class><name>MinimalResConflictSuite</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.LimitResConflictSuite</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.MinimalResConflictSuite</class-id><body>I implement resource handling according to the wholly pessimistic principle that no group of resources can be trusted to work together unless all are referenced by a test.  Tests are split up into collections within which all tests use the same set of resources.  Each collection is run, after which all its resources are torn down.  The run then moves on to the next collection.  (See my superclass' comment for more details.)To use, set me as the suite class in the Tools &gt; Testing page of the VisualLauncher settings, or execute:	XProgramming.SUnit.TestSuite suiteClass: self.To revert, reset the setting or re-execute the above. Using this class in SUnit gives the same resource-grouping behaviour as SUnitToo's hard-coded implementation of resource handling.</body></comment><class><name>ModerateResConflictSuite</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.LimitResConflictSuite</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.ModerateResConflictSuite</class-id><body>I implement resource handling according to the moderately pessimistic principle that resources may clash unless used by tests in the same parcel or package;  otherwise, I resemble MinimalResConflictSuite.  Tests are split up into collections within which all tests belong to the same component.  Each collection is run, after which all its resources are torn down.  The run then moves on to the next collection.  (See my superclass' comment for more details.)To use, set me as the suite class in the Tools &gt; Testing page of the VisualLauncher settings, or execute:	XProgramming.SUnit.TestSuite suiteClass: self.To revert, reset the setting or re-execute the above.</body></comment><class><name>InvariantResource</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wasAlreadyAvailable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.InvariantResource</class-id><body>I am a test resource that leaves the state of the resource it encapsulates the same after a test run as it was before the run started, unlike ordinary resources which will always be set up before a run and torn down after a run regardless of whether they were available beforehand or not.  When initializing itself, the resource only does #setUp if it is not already available.  When uninitializing itself, the resource does #tearDown only if it was not already available before the run started.  Subclasses override instance-side #isAvailable to provide the condition for avoiding or doing #setUp / #tearDown.This pattern can be useful during development when the user may be doing a mix of configuring resources by hand for half-developed tests and re-running existing tests.  It also makes it easy to run a test by default against a given database or suchlike item named in the resource, while also running it occasionally against any other database to which a developer may connect by hand.</body></comment><class><name>CompetingResource</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.CompetingResource</class-id><body>SCENARIO: we want to handle a collection of test cases, each of which individually have a compatible resource set, but which collectively cannot initialize all their resources at the same time.  In SUnit 3.2 and after, suites of tests whose resources cannot all be avaiable at the same time are much easier to handle:  this class implements one pattern for doing so;  the comments below and in its methods indicate other patterns.  Earlier versions of this class were much more complex, to handle the problem in SUnit 3.1 and earlier.MOTIVATION:  a resource will often represent something that must be a singleton in a given test case but which can be different for different test cases.  An example is a database resource for a system that can only be logged-in to one database at a time.  There may be several databases (e.g. for different lines of business, different phases, etc.).  It may be essential to make database login be a test resource (to make suites of tests that all use one database run quickly).  However when tests using different databases are combined in suites, the resource mechanism threatens to break down, yet combining all tests into an overall system test suite is the natural XP action.SOLUTION:  when #makeAvailable is sent to a CompetingResource, it sends #reset to its competitors before proceeding.  Either reparent (an abstract superclass of) the rival classes under this class, e.g.	CompetingResource		DatabaseResource (implements #competingResourceTypes)			UKDatabaseResource			USDatabaseResourceor extend (an abstract superclass of) the rival classes with methods from this class, e.g.	TestResource		DatabaseResource (implements #makeAvailable from this class and #competingResourceTypes)			UKDatabaseResource			USDatabaseResourceThe abstract superclass, e.g. DatabaseResource, will often already exist since a specific set of competing resources will usually share behaviour, differing only in some data values.The superclass defines the set of competingResourceTypes in either case, e.g.	DatabaseResource class&gt;&gt;competingResourceTypes		^DatabaseResource allSubclassesor	DatabaseResource class&gt;&gt;competingResourceTypes		^Set with: UKDatabaseResource with: USDatabaseResourceIf the competing classes live in separate packages, so some may not be loaded, a computed list is better.  The hardcoded example above exploits the fact that a Set will silently not add nil, so that it will work even if one of its classes was undeclared.  Except to handle that case, there is no special reason to return a Set rather than an Array or other collection.A suite that only has one class from a set of competing resource will behave exactly as before, setting it up when the first test that needs it is run and tearing iy down in TestSuite&gt;&gt;run.  A suite that has a second test wanting a rival resource will tear down the active one (by tearing down all in the set, only one of which will be active) and set up the rival when it runs the second test.STATUS:  see the associated test package for tests and for an example (the Ex-prefixed classes) of the pattern (the classes' method protocols distinguish example methods from methods that are only there to assist testing and are not part of the pattern).Currently, there is no support for sorting a multiple-competing-resource-using test suite into an efficient order for running.  It is assumed that the user knows which tests use competing resources and will assemble a suite that does not prompt excessive changing (or that the time cost of not bothering to do so is acceptable).  It would be possible to devise subclasses or extensions of TestSuite to handle ordering.Like other test resources, this does not handle simultaneous running in separate threads of two test suites using the same singleton resource classes, nor does it handle asynchronous tear down of external resources.</body></comment><class><name>RandomSuite</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.PluggableSuite</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>random inspectFailedOrder </class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><comment><class-id>XProgramming.SUnit.RandomSuite</class-id><body>I randomise the order in which I runs tests (using the same algorithm as SUnitToo).  My collection of tests is set to the random order, which can therefore be examined after the run.To use, set me as the suite class in the Tools &gt; Testing page of the VisualLauncher settings, or execute:	XProgramming.SUnit.TestSuite suiteClass: self.To revert, reset the setting or re-execute the above.Class Instance Variables	random			&lt;Random&gt;	reuse random in successive runs instead of restarting it for each run	inspectFailedOrder	&lt;Boolean&gt;	should we open an inspector on the order of a run that fails?</body></comment><methods><class-id>XProgramming.SUnit.ClassifiedTestResult</class-id> <category>printing</category><body package="SUnitResourcePatterns">displayString	"For use with RBSUnitExtensions and other tools.  Add our numbers and tags (appending s unless number is 1), comma-separated."	| stream |	stream := WriteStream on: (String new: 32).	stream nextPutAll: super displayString.	self classifiedResults keysAndValuesDo:		[:eachTag :eachResults |		stream			nextPut: $,; space;			nextPutAll: eachResults size printString;			space;			nextPutAll: eachTag.		eachResults size ~= 1 ifTrue: [stream nextPut: $s]].	^stream contents</body><body package="SUnitResourcePatterns">printOn: aStream	"To distingush skips from the rest, since skipped tests are not run, separate it with a semi-colon and two spaces, not a comma and one space."	super printOn: aStream.	self classifiedResults keysAndValuesDo:		[:eachTag :eachResults |		aStream			nextPut: $,; space;			nextPutAll: eachResults size printString;			space;			nextPutAll: eachTag.		eachResults size ~= 1 ifTrue: [aStream nextPut: $s]].</body></methods><methods><class-id>XProgramming.SUnit.ClassifiedTestResult</class-id> <category>accessing</category><body package="SUnitResourcePatterns">classified: aTestClassificationString	^classifiedResults at: aTestClassificationString ifAbsent: [#()]</body><body package="SUnitResourcePatterns">classifiedCount: aTestClassificationString	^(classifiedResults at: aTestClassificationString ifAbsent: [^0]) size</body><body package="SUnitResourcePatterns">classifiedResults	^classifiedResults</body></methods><methods><class-id>XProgramming.SUnit.ClassifiedTestResult</class-id> <category>initialize-release</category><body package="SUnitResourcePatterns">initialize	super initialize.	classifiedResults := Dictionary new.</body><body package="SUnitResourcePatterns">passed: somePasses failures: someFailures errors: someErrors	passed := somePasses.	failures := someFailures.	errors := someErrors.</body></methods><methods><class-id>XProgramming.SUnit.ClassifiedTestResult</class-id> <category>running</category><body package="SUnitResourcePatterns">reclassifyFailuresOf: aTestResourceClass	"Move all TestCases that were failed by aTestResourceClass from this result's 'failures' category to the resource's classificationTag category (the tag is the resource's class name by default but a resource may want to override, e.g. to a shorter string).	When calling this method, iterate over resources in dependency order, so that a resource-failed test is reclassified against the right first-cause-of-failure resource, not against a dependent resource that was failed by that first resource."	aTestResourceClass isAlreadyAvailable ifTrue: [^self].	aTestResourceClass isUninvoked ifTrue: [^self].	self failures copy do:		[:each |		(each class resources includes: aTestResourceClass) ifTrue: 			[self				addClassification: aTestResourceClass classificationTag				ofTestCase: (self failures remove: each ifAbsent: [nil])]]	"adding nil to a Set is a no-op""There are two ways to get which tests were failed by which resources.	- This implementation shows one way:  post-hoc, check if the supplied resource failed to be made available.  If so, iterate over the failed tests of the result, finding those whose resources include the supplied one.  Reclassify each such test case's failure against the test resource.	- The other way is both simpler and more robust:  in #makeAvailable, change the nonce value that denotes a failed resource from 'false' to 'OrderedCollection new'.  During the test suite run, add each resource-dependent test to this collection at the moment when the resource fails it.  At the end-run point where this method is called, just iterate over that collection.  This makes the coding here simpler, and handles the very rare and unlikely case where a test fails not because of a resource but later that resource is forced into failure by reset and unsuccessful reinvocation, so begins failing tests part-way through a run (pretty rare scenario, but you can do anything in Smalltalk).  An initial version of this, needing further work, is in SUnit(4.0 RC2 + AR 59450 3)."</body></methods><methods><class-id>XProgramming.SUnit.ClassifiedTestResult</class-id> <category>adding</category><body package="SUnitResourcePatterns">addClassification: aString ofTestCase: aTestCase	^(self		classifiedResults at: aString		ifAbsentPut: [Set new])			add: aTestCase</body><body package="SUnitResourcePatterns">addOutcome: aTestCase exception: anException	^self		addClassification: anException class classificationTag		ofTestCase: aTestCase</body></methods><methods><class-id>XProgramming.SUnit.PluggableSuite</class-id> <category>initialize-release</category><body package="SUnitResourcePatterns">newTestResult	^self class resultClass new</body></methods><methods><class-id>XProgramming.SUnit.PluggableSuite class</class-id> <category>accessing</category><body package="SUnitResourcePatterns">resultClass	^resultClass</body><body package="SUnitResourcePatterns">resultClass: aTestResultClass	resultClass := aTestResultClass.</body></methods><methods><class-id>XProgramming.SUnit.FastSuite</class-id> <category>Camp Smalltalk</category><body package="SUnitResourcePatterns">changeNotificationDelay	^500000 "microseconds, i.e. 50 milliseonds"</body><body package="SUnitResourcePatterns">lastRunStatusUpdate	lastRunStatusUpdate isNil ifTrue: [lastRunStatusUpdate := 0].	^lastRunStatusUpdate</body><body package="SUnitResourcePatterns">lastRunStatusUpdate: anInteger	lastRunStatusUpdate := anInteger.</body><body package="SUnitResourcePatterns">sunitChanged: aTestCase	| timeNow |	timeNow := Time microsecondClock.	timeNow - self lastRunStatusUpdate &gt; self changeNotificationDelay		ifTrue: 			[super sunitChanged: aTestCase.			self lastRunStatusUpdate: timeNow]</body></methods><methods><class-id>XProgramming.SUnit.TestSkip</class-id> <category>Camp Smalltalk</category><body package="SUnitResourcePatterns">sunitAnnounce: aTestCase toResult: aTestResult	aTestResult addOutcome: aTestCase exception: self.	self sunitExitWith: false.</body></methods><methods><class-id>XProgramming.SUnit.TestSkip class</class-id> <category>Camp Smalltalk</category><body package="SUnitResourcePatterns">classificationTag	^'skip'</body></methods><methods><class-id>XProgramming.SUnit.LimitResConflictSuite</class-id> <category>accessing</category><body package="SUnitResourcePatterns">addTest: aTest	super addTest: aTest.	^(self resourceSetsToSuites		at: (self limitedConflictGroupForTest: aTest)		ifAbsentPut: [TestSuite new])			addTest: aTest</body><body package="SUnitResourcePatterns">limitedConflictGroupForTest: aTest	"My main function is to be an abstract class for subclasses with sensibly-chosen conflict group rules.  However I can also be used as a concrete class for the most extreme case of assuming that every test's resources can interfere with every other test's resources and/or that we wish to run in a non-resource-pattern manner.  By making each test be its own conflict resolution group we ensure that (the run may take a long time and) test resources are set up and torn down exactly as if they were part of the test's own setUp and tearDown."	^aTest</body><body package="SUnitResourcePatterns">resourceSetsToSuites	^resourceSetsToSuites ifNil: [resourceSetsToSuites := Dictionary new]</body><body package="SUnitResourcePatterns">setTests: someTests	tests := someTests</body></methods><methods><class-id>XProgramming.SUnit.LimitResConflictSuite</class-id> <category>running</category><body package="SUnitResourcePatterns">run	| result allTests |	allTests := self tests.	result := self newTestResult.	resourceSetsToSuites do:		[:suite || suiteResources | suiteResources := suite resources.		[self setTests: suite tests.		self run: result.		suiteResources do: [:each | result reclassifyFailuresOf: each]]			sunitEnsure:				[TestResource resetResources: suiteResources.				self setTests: allTests]].	"iterate/exit with clean start state"	^result</body></methods><methods><class-id>XProgramming.SUnit.MinimalResConflictSuite</class-id> <category>accessing</category><body package="SUnitResourcePatterns">limitedConflictGroupForTest: aTest	"Tests hold resources in sequenceable collections.  We convert to Sets as keys, otherwise tests with the same resources listed in different orders would needlessly appear under different keys.  The set loses the order, which might be being relied on by all tests presenting the same order because not expressed in resource dependency.  When running a subsuite, we therefore let the resources be set up by the subsuite's first test, not from the subsuite's key."	^aTest resources asSet</body></methods><methods><class-id>XProgramming.SUnit.ModerateResConflictSuite</class-id> <category>accessing</category><body package="SUnitResourcePatterns">limitedConflictGroupForTest: aTest	"In VisualWorks, treat all resources used by tests in the same parcel as compatible.  If a test is not in a parcel, treat its resources as compatible with any used by other tests in its package."	^(Parcel		componentDefiningSelector: aTest selector		class: aTest class)	ifNil: [Store.Registry			componentDefiningSelector: aTest selector			class: aTest class]</body></methods><methods><class-id>XProgramming.SUnit.InvariantResource</class-id> <category>accessing</category><body package="SUnitResourcePatterns">wasAlreadyAvailable	^wasAlreadyAvailable</body></methods><methods><class-id>XProgramming.SUnit.InvariantResource</class-id> <category>testing</category><body package="SUnitResourcePatterns">isAvailable	"Invariant resource subclasses must override this to return whether the resource is available or not.  The test must work without #setUp having been sent to the instance (#initialize will have been sent).  The test must not _cause_ it to become available;  that must _only_ be done in setUp.  (Do _not_ override class-side isAvailable.)"		^self subclassResponsibility</body></methods><methods><class-id>XProgramming.SUnit.InvariantResource</class-id> <category>initialize-release</category><body package="SUnitResourcePatterns">initialize	"Are we now, before #setUp has been called, already available?  (The supercall of initialize will do nothing in SUnit but will do something when run under the SUnitToo bridge.)"	wasAlreadyAvailable := self isAvailable.	wasAlreadyAvailable ifFalse: [super initialize].</body></methods><methods><class-id>XProgramming.SUnit.InvariantResource class</class-id> <category>instance creation</category><body package="SUnitResourcePatterns">makeAvailable	"If I was already available, do not set me up or tear me down.  Just put a no-op instance in my current that I will treat as valid."	| candidate |	current := false.	candidate := self new.	candidate wasAlreadyAvailable		ifTrue: [current := candidate]		ifFalse: [super makeAvailable].</body><body package="SUnitResourcePatterns">reset	"If I was already available, do not tear me down."	[(self isAlreadyAvailable and: [current wasAlreadyAvailable])		ifFalse: [super reset]]			sunitEnsure: [current := nil].</body></methods><methods><class-id>XProgramming.SUnit.CompetingResource class</class-id> <category>private</category><body package="SUnitResourcePatterns">competingResourceTypes	"Return a collection of the resources that cannot be simultaneously available."	^self subclassResponsibility"The list may be computed, e.g.	DatabaseResource class&gt;&gt;competingResourceTypes		^DatabaseResource allSubclassesor hardcoded, e.g.	DatabaseResource class&gt;&gt;competingResourceTypes		^Set with: UKDatabaseResource with: USDatabaseResourceIf the competing classes live in separate packages, so some may not be loaded, a computed list is better.  The hardcoded example above exploits the fact that a Set will silently not add nil, so that it will work even if one of its classes was undeclared.  Except to handle that case, there is no special reason to return a Set rather than an Array or other collection."</body><body package="SUnitResourcePatterns">makeAvailable	"Ensure reset of an available competing resource by resetting all of them before making this one available.  Only one resource from a competingResourceTypes set can be available at a time so the action is a no-op on the others.  In particular, if this method is called, this resource is not already available, so we can send reset to it along with its competitors as a no-op."	self competingResourceTypes do: [:each | each reset].	super makeAvailable.</body></methods><methods><class-id>XProgramming.SUnit.RandomSuite</class-id> <category>utility</category><body package="SUnitResourcePatterns">randomiseTestCases	"Enumerate the TestCases in aCollection in a random order. We keep a class variable to use the same random in successive runs, rather than creating a new random each time, which is less random.  (This is the encouraged enumeration strategy.  It makes sure that coupling errors don't accrue from running the tests in the same order each time.)"	| randomTestCases a b random |	random := self class random.	randomTestCases := self tests asArray.	randomTestCases size * 3 timesRepeat:		[a := (random next * randomTestCases size) ceiling max: 1.		b := (random next * randomTestCases size) ceiling max: 1.		randomTestCases swap: a with: b].	tests := randomTestCases asOrderedCollection.</body></methods><methods><class-id>XProgramming.SUnit.RandomSuite</class-id> <category>running</category><body package="SUnitResourcePatterns">run: aResult	self randomiseTestCases.	super run: aResult.	(aResult hasPassed not and: [self class inspectFailedOrder]) ifTrue:		[(self class superclass			resultClass: self class resultClass;	"preserve my current resultClass in repeat runs"			named: 'Failed (Randomised) Order of Tests') addTests: tests; inspect].</body></methods><methods><class-id>XProgramming.SUnit.RandomSuite class</class-id> <category>private</category><body package="SUnitResourcePatterns">random	^random ifNil: [random := Random standard]</body></methods><methods><class-id>XProgramming.SUnit.RandomSuite class</class-id> <category>accessing</category><body package="SUnitResourcePatterns">inspectFailedOrder	"Handle nil (i.e. uninitialized) case."	^inspectFailedOrder == true</body><body package="SUnitResourcePatterns">inspectFailedOrder: aBoolean	inspectFailedOrder := aBoolean.</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>adding</category><body package="SUnitResourcePatterns">addOutcome: aTestCase exception: anException	"This not-ideal use of #become is just a backup;  normally, a ClassifiedTestResult is used from the first by an instance of PluggableTestSuite or a subclass.  The return is debatable:  arguably, we should become and then call super on the new object, but also arguably we need not return in this method or its polymorphs (the return is unused at the moment)."	self become:		(ClassifiedTestResult new			passed: self passed failures: self failures errors: self errors;			addOutcome: aTestCase exception: anException;			yourself).	^aTestCase</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>accessing</category><body package="SUnitResourcePatterns">classified: aTestClassificationString	^#()</body><body package="SUnitResourcePatterns">classifiedCount: aTestClassificationString	^0</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>running</category><body package="SUnitResourcePatterns">reclassifyFailuresOf: aTestResourceClass	"Our suite would like us to reclassify but we cannot reclassify anything.  For now, do nothing (i.e. just avoid a DNU);  it's the user's job to choose a test result class that positively supports the expectations of their chosen test suite.  If, at a later date, a test (i.e. not just a test suite) could ask us to reclassify, uncomment the code below.	self become:		(ClassifiedTestResult new			passed: self passed failures: self failures errors: self errors;			reclassifyFailuresOf: aTestResourceClass;			yourself)"</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>accessing</category><body package="SUnitResourcePatterns">classificationTag	"Specific classes may wish to override with a shorter meaningful string"	^self name</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>instance creation</category><body package="SUnitResourcePatterns">resetAll	"WARNING:  this is never sent by the framework and is only for (cautious) explicit programmatic use by developers.  When resetting a resource that uses other resources in a competing resource pattern, it can be tedious to send reset explicitly to each node of a tree of resource classes, especially if the tree is evolving during development.  If all nodes compete with other resources in other trees, or are at least unused by them, this method can be sent to the top-level resource in the tree instead.	HOWEVER if the tree is, or is part of, a graph, i.e. it contains a resource used by two or more other resources in the same test suite run, sending this to the top of the tree is unsafe.  ONLY use this method when the sets of competing resources are, and while they remain, pure trees."	self resetResources: (Array with: self).</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter class</class-id> <category>asserting</category><body package="SUnitResourcePatterns">assert: aBoolean orSkip: aString	"We offer a minimal clone of all instance-side assert:* protocol so that class-side methods can use them."	aBoolean ifFalse: [TestSkip sunitSignalWith: aString].</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter</class-id> <category>asserting</category><body package="SUnitResourcePatterns">assert: aBoolean orSkip: aString	"As #assert:description naturally shortens to #assert:, so #skipUnless:description: naturally shortens to #skipUnless:.  By contrast #assert:orSkip: does not naturally shorten, so we provide it as a convenience protocol but do not make it the main style."	self skipUnless: aBoolean description: aString.</body><body package="SUnitResourcePatterns">deny: aBoolean orSkip: aString	"As #deny:description naturally shortens to #deny:, so #skipIf:description: naturally shortens to #skipIf:.  By contrast #deny:orSkip: does not naturally shorten, so we provide it as a convenience protocol but do not make it the main style."	self skipIf: aBoolean description: aString.</body><body package="SUnitResourcePatterns">skip	"Unconditionally skip the test.  A convenience method for tests in long-term development or maintenance."	TestSkip sunitSignalWith: 'Test skipped'.</body><body package="SUnitResourcePatterns">skipIf: aBoolean	self skipUnless: aBoolean not.</body><body package="SUnitResourcePatterns">skipIf: aBoolean description: aString	self skipUnless: aBoolean not description: aString.</body><body package="SUnitResourcePatterns">skipUnless: aBoolean	self skipUnless: aBoolean description: 'Assertion skipped'.</body><body package="SUnitResourcePatterns">skipUnless: aBoolean description: aString	"If the boolean is not true, stop running the test (as for an assertion), but classify it as skipped, not as failed."	aBoolean ifFalse: [TestSkip sunitSignalWith: aString].</body></methods><methods><class-id>XProgramming.SUnit.TestSuite class</class-id> <category>accessing</category><body package="SUnitResourcePatterns">resultClass	^TestResult</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestAsserter</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestResource</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestSuite</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tests resources name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestResult</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failures errors passed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestFailure</name><environment>XProgramming.SUnit</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitPreload</category><attributes><package>SUnitPreload</package></attributes></class></st-source>