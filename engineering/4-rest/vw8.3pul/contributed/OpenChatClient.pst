<?xml version="1.0"?><st-source><!-- Name: OpenChatClientComment: Starting a Chat Client:This is a sample Opentalk chat client. Needs to connect to an OpenChatServer running somewhere.You can start a chat client from the Tools menu or evaluting something like:	(OpentalkChatClient		as: <yourChatID>					"e.g. 'martin'"		on: <aChatServerIPSocketAddress>	"e.g. IPSocketAddress hostName: 'bear' port: 4242"		) openStarting a Chat Session:The left pane shows all the parties currently connected to the server. You can start a chat session by selecting somebody and choosing 'Start Chat' from the context menu. The other party will get a confirmation dialog which has to be accepted in order to start a session.Messages:Once a chat session is started message text can be typed into the input field on the bottom. Hit Enter to send the message out. Messages are displayed in the top right text pane.Multiparty Sessions:If you want to get somebody else into the session just select his chat id and choose 'Invite to Join' from the context menu. Invitation to join has to be confirmed by the other party as well.Leaving a Session:To finish the session hit the Leave button. Simply closing the client has the same effect. Once all the parties leave a session, it is removed from the server.Multiple Sessions:A client can carry on only one session at a time. If you want multiple sessions, start more clients.DbIdentifier: bear73DbTrace: 54788DevelopmentPrerequisites: #(#(#any 'Opentalk-STST' ''))PackageName: OpenChatClientParcel: #('OpenChatClient')PrerequisiteParcels: #(#('Opentalk-STST' ''))PrintStringCache: (11,mkobetic)Version: 11Date: 11:13:59 AM October 21, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (oct09.4) of October 21, 2009 on October 21, 2009 at 11:13:59 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OpenChatClient</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id broker server serverParties session message textCollector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OpenChatClient</category><attributes><package>OpenChatClient</package></attributes></class><comment><class-id>OpenChatClient</class-id><body></body></comment><shared-variable><name>Log</name><environment>OpenChatClient</environment><private>false</private><constant>false</constant><category>private</category><attributes><package>OpenChatClient</package></attributes></shared-variable><methods><class-id>OpenChatClient</class-id> <category>actions</category><body package="OpenChatClient" selector="displayMessage:from:">displayMessage: aString from: anId	anId notNil ifTrue: [		textCollector show: '&lt;', anId, '&gt;: ' ].	textCollector		show: aString;		cr</body><body package="OpenChatClient" selector="doYouAcceptSession:from:on:">doYouAcceptSession: aChatSession from: initiatingPartyId on: aTopic	| question |	question := WriteStream on: (String new: 20).	question		nextPutAll: initiatingPartyId;		nextPutAll: ' wants to talk to you about ';		nextPutAll: aTopic;		nextPut: $.; cr;		nextPutAll: 'Do you accept ?'.	(Dialog confirm: question contents) ifFalse: [^false].	session := aChatSession.	self message onChangeSend: #sendMessage to: self.	^true</body><body package="OpenChatClient" selector="leaveSession">leaveSession	session notNil ifTrue: [		session leaving: id.		session := nil ]</body><body package="OpenChatClient" selector="sendMessage">sendMessage	session notNil ifTrue: [		session addMessage: self message value from: id.		self message			retractInterestsFor: self;			value: '';			onChangeSend: #sendMessage to: self ]</body></methods><methods><class-id>OpenChatClient</class-id> <category>accessing</category><body package="OpenChatClient" selector="id">id	^id</body></methods><methods><class-id>OpenChatClient</class-id> <category>aspects</category><body package="OpenChatClient" selector="labelFor:">labelFor: aKey	^aKey = #windowLabel		ifTrue: [self windowLabel]		ifFalse: [super labelFor: aKey]</body><body package="OpenChatClient" selector="message">message	message isNil ifTrue: [message := String new asValue].	^message</body><body package="OpenChatClient" selector="serverParties">serverParties	serverParties isNil ifTrue: [serverParties := SelectionInList with: List new].	^serverParties</body><body package="OpenChatClient" selector="textCollector">textCollector	textCollector isNil ifTrue: [textCollector := TextCollector new].	^textCollector</body><body package="OpenChatClient" selector="textView">textView	^TextCollectorView new model: self textCollector</body><body package="OpenChatClient" selector="windowLabel">windowLabel	| s |	s := WriteStream on: String new.	self printOn: s.	s nextPut: $@.	broker objectAdaptor printAccessInfoOn: s.	^s contents</body></methods><methods><class-id>OpenChatClient</class-id> <category>server  broadcasts</category><body package="OpenChatClient" selector="partyList:">partyList: partyIds	self serverParties list: partyIds asList</body><body package="OpenChatClient" selector="serverStopping">serverStopping	"We don't want the server to wait for this to finish, so we need to fork it off.	Some asynchronous messaging support would be handy here"	[ 	self partyList: #().		server := nil.		Transcript cr; show: 'ChatServer has stopped.'	] fork</body></methods><methods><class-id>OpenChatClient</class-id> <category>menus</category><body package="OpenChatClient" selector="partyMenu">partyMenu	^Menu new		augmentFrom: self class to: OpenChatClient menuName: #partyMenu;		yourself</body></methods><methods><class-id>OpenChatClient</class-id> <category>private</category><body package="OpenChatClient" selector="log">log"	Log := nil"	Log isNil ifTrue: [		Log := #{OpenChatServer}			ifDefinedDo: [ :class | class log ]			elseDo: [Opentalk.EventCollector new resetClock; yourself] ].	^Log</body><body package="OpenChatClient" selector="logMessages">logMessages	^#{OpenChatServer}		ifDefinedDo: [ :class | class logMessages ]		elseDo: [false]</body><body package="OpenChatClient" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	session notNil ifTrue: [session leaving: id].	server notNil ifTrue: [server removeParty: self].	broker stop.</body><body package="OpenChatClient" selector="printOn:">printOn: aStream	aStream		nextPutAll: 'ChatClient(';		nextPutAll: id;		nextPut: $)</body></methods><methods><class-id>OpenChatClient</class-id> <category>debugging</category><body package="OpenChatClient" selector="inspectLog">inspectLog	Log inspect</body><body package="OpenChatClient" selector="postBuildWith:">postBuildWith: aBuilder	self eventsHandled isEmpty ifFalse: [		(aBuilder menuAt: #partyMenu)			addLine;			addItem: (MenuItem labeled: 'Reset Log Clock') value: #resetLogClock;			addItem: (MenuItem labeled: 'Flush Log To Transcript') value: #flushLogToTranscript;			addItem: (MenuItem labeled: 'Inspect Log') value: #inspectLog ]</body></methods><methods><class-id>OpenChatClient</class-id> <category>initialize</category><body package="OpenChatClient" selector="initializeId:onServer:broker:">initializeId: anId onServer: anIPAddress broker: aBroker	id := anId.	broker := aBroker.	(InputState default shiftDown) ifTrue: [		broker sendAllEventsTo: self log ].	self logMessages ifTrue: [		#(sendingRequest:in: receivingRequest:in:) do: [ :ev |			broker objectAdaptor when: ev do: [ :rq :tr |				self log log: (					MessageSend						receiver: rq target						selector: rq message selector						arguments: rq message arguments) ] ] ].	broker start.	server := broker remoteObjectOn: anIPAddress oid: #ChatServer.	[ server addParty: self.	] ifCurtailed: [ broker stop ]</body><body package="OpenChatClient" selector="initializeTcpId:onServer:">initializeTcpId: anId onServer: anIPAddress	self		initializeId: anId		onServer: anIPAddress		broker: (Opentalk.RequestBroker newStstTcpAt: IPSocketAddress thisHostAnyPort)</body><body package="OpenChatClient" selector="initializeUdpId:onServer:">initializeUdpId: anId onServer: anIPAddress	self		initializeId: anId		onServer: anIPAddress		broker: (Opentalk.RequestBroker newStstUdpAt: IPSocketAddress thisHostAnyPort)</body></methods><methods><class-id>OpenChatClient class</class-id> <category>instance creation</category><body package="OpenChatClient" selector="standardAddress">standardAddress	^IPSocketAddress		hostName: 'localhost'		port: self standardPort</body><body package="OpenChatClient" selector="standardPort">standardPort	^4242</body><body package="OpenChatClient" selector="tcpAs:">tcpAs: myId	^self tcpAs: myId on: self standardAddress</body><body package="OpenChatClient" selector="tcpAs:on:">tcpAs: myId on: serverIPAddress	^self new		initializeTcpId: myId		onServer: serverIPAddress</body><body package="OpenChatClient" selector="udpAs:">udpAs: myId	^self udpAs: myId on: self standardAddress</body><body package="OpenChatClient" selector="udpAs:on:">udpAs: myId on: serverIPAddress	^self new		initializeUdpId: myId		onServer: serverIPAddress</body></methods><methods><class-id>OpenChatClient</class-id> <category>actions</category><body package="OpenChatClient" selector="chatWithParty">chatWithParty	&lt;menuItem: 'Start Chat'		nameKey: nil		menu: #(#partyMenu)		position: 2.3&gt;	| topic party |	session notNil ifTrue: [^Dialog warn: 'You have to leave the current session to start another one !'].	party := self serverParties selection.	party = id ifTrue: [^self].	topic := Dialog request: 'What is the topic ?' initialAnswer: 'General'.	topic isEmpty ifTrue: [^self].	session := server startSessionFor: self with: party on: topic.	session isNil ifTrue: [^self displayMessage: 'Failed to establish a session' from: party].	self message onChangeSend: #sendMessage to: self.</body><body package="OpenChatClient" selector="inviteParty">inviteParty	&lt;menuItem: 'Invite To Join'		nameKey: nil		menu: #(#partyMenu)		position: 2.5&gt;	| party |	session isNil ifTrue: [^Dialog warn: 'You have to be in a session to invite somebody to join it !'].	party := self serverParties selection.	party = id ifTrue: [^self].	(server invite: party toJoin: session from: self) ifFalse: [		self displayMessage: ' Did not join the session !' from: party]</body></methods><methods><class-id>OpenChatClient</class-id> <category>debugging</category><body package="OpenChatClient" selector="flushLogToTranscript">flushLogToTranscript	&lt;menuItem: 'Flush Log To Transcript'		nameKey: nil		menu: #(#partyMenu)		position: 9.5&gt;	Log flushToTranscript</body><body package="OpenChatClient" selector="resetLogClock">resetLogClock	&lt;menuItem: 'Reset Log Clock'		nameKey: nil		menu: #(#partyMenu)		position: 9.7&gt;	Log resetClock</body></methods><methods><class-id>OpenChatClient class</class-id> <category>interface specs</category><body package="OpenChatClient" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 399 275 726 669 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -28 1 -62 1 -2 1 ) 					#model: #message ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 98 0 -30 1 ) 					#model: #serverParties 					#tabable: false 					#menu: #partyMenu 					#selectionType: #highlight ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 2 0 -2 1 -30 1 ) 					#flags: 9 					#component: #textView ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -58 1 -26 1 -2 1 -2 1 ) 					#model: #leaveSession 					#tabable: false 					#label: 'Leave' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="OpenChatClient" selector="openChatClient">openChatClient	&lt;menuItem: 'Open Chat Client'		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 12.30&gt;	| id serverHost serverPort protocolMessage |	id := Dialog request: 'Your chat ID ?'.	id isEmpty ifTrue: [^self].	serverHost := Dialog request: 'What host is the chat server running on ?' initialAnswer: 'localhost'.	serverHost isEmpty ifTrue: [^self].	serverPort := Dialog request: 'What port is the chat server running on ?' initialAnswer: '4242'.	serverPort isEmpty ifTrue: [^self].	protocolMessage := Dialog choose: 'What type of protocol to use ?'				labels: #('TCP' 'UDP')				values: #(tcpAs:on: udpAs:on:)				default: #tcpAs:on:.	(OpenChatClient		perform: protocolMessage		with: id		with: (IPSocketAddress			hostName: serverHost			port: serverPort asNumber)) open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>