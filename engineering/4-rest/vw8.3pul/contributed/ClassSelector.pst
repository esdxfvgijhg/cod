<?xml version="1.0"?><st-source><!-- Name: Class SelectorComment: The goodie parcel ClassSelector.pcl replaces the VisualLauncher class entry dialog for menu operation Browse->Class Named... to a class selector dialog.  The class selector dialog includes a list of all classes in the image whose selection changes to best match a class entry as it is entered.  Classes may be selected from the list or their partial names entered or pasted into the entry field.  Classes oflike name that appear in separate namespaces will appear in the list in their full name.  The wild card character "*" may be used to reduce the list of classes to only those that best match the entry so far.  Double click to select and close the dialog on a class in the list or make a selection and press the Enter key. To see an example how the selection changes with an entry try typing in the following strings into the class selector dialog:     Byte*Str*     Doc*     Data*Co* To restore the original class entry dialog simply unload the class selector parcel ClassSelector.pcl. HideSource: falseParcel: #('ClassSelector')SaveSource: trueVersion: 7.1Date: 8:50:10 am February 13, 2003 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.1 - feb03.1 of January 27, 2003 on February 13, 2003 at 8:50:10 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ClassSelector</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString searchList selectedClass prompt formerLists ambiguous </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-ClassFinder</category></class><comment><class-id>Tools.ClassSelector</class-id><body>I provide a class selection dialog with a class list whose selection continuously updates to the class that best matches the name entered by the user in an entry field.  The user may select a class from the list, or enter or paste a partial class name in the entry field.  If the entry includes the wild card character '*' the list is refined to include only classes that best match the entry so far.Instance Variables:searchString	&lt;String&gt;	Search string entrysearchList	&lt;SelectionInList on: SortedCollection&gt;	List of all classes to select from the image.selectedClass	&lt;Behavior | nil&gt;	Class selected or nil if none.prompt	&lt;String&gt;	Prompt string of dialogformerLists	&lt;OrderedCollection&gt;	Backup copies of searchLists for each list refined by entry of '*' in searchString.ambiguous	&lt;Set&gt;	Set with any class that appears in different namespaces with the same name </body></comment><methods><class-id>Tools.ClassSelector</class-id> <category>actions</category><body>cancelAction	selectedClass := nil.	self closeCancel</body><body>ok	self classSelected.  	^self closeRequest.</body></methods><methods><class-id>Tools.ClassSelector</class-id> <category>interface opening</category><body>postBuildWith: aBuilder 	"Set the keyboard hook to select from and refine the list of 	classes upon the current entry"	| ctrl listWidget |	ctrl := (aBuilder componentAt: #searchStringID) widget controller.	ctrl		keyboardHook: 			[:x :cntlr | 			| char |			ctrl requestFocusOut.			char := x keyValue.			(char isKindOf: Character)				ifTrue: 					[| entry |					entry := self searchString value.					entry isEmpty						ifFalse: 							[char == Character backspace								ifTrue: [entry last == $* ifTrue: [entry := entry copyFrom: 1 to: entry size - 1]]								ifFalse: [entry := entry copyWith: char].							self selectMatch: entry trimBlanks refineList: formerLists size &lt; (entry occurrencesOf: $*)].					x]].	listWidget := (aBuilder componentAt: #searchListID) widget.	listWidget		visualBlock: 			[:v :i | 			| item name |			item := searchList list at: i.			name := (ambiguous includes: item)						ifTrue: [item unambiguousName]						ifFalse: [item name].			BoundedWrapper on: (Label with: name attributes: v textStyle)].	listWidget		selectedVisualBlock: 			[:v :i | 			| item name rw |			item := searchList list at: i.			name := (ambiguous includes: item)						ifTrue: [item unambiguousName]						ifFalse: [item name].			rw := ReversingWrapper on: (Label with: name attributes: v textStyle).			rw reverse setValue: true.			BoundedWrapper on: rw].	prompt notNil ifTrue: [(aBuilder componentAt: #promptLabel) widget labelString: prompt]</body></methods><methods><class-id>Tools.ClassSelector</class-id> <category>initialize-release</category><body>initialize	"Initialize the list with all classes in the image"	| list c1 c2 |	searchList := SelectionInList with: (SortedCollection withAll: Root allClasses sortBlock: SmalltalkWorkbench classNameSortBlock).	formerLists := OrderedCollection new.	searchString := String new asValue.	ambiguous := Set new.	list := searchList list.	c1 := list first.	2 to: list size do:[:i|		c1 name = (c2 := list at: i) name			ifTrue:[ambiguous add:c1; add:c2].		c1 := c2].	super initialize</body></methods><methods><class-id>Tools.ClassSelector</class-id> <category>aspects</category><body>prompt: aString	prompt := aString.</body><body>searchList	^searchList</body><body>searchString	^searchString</body><body>selectedClass	^selectedClass</body></methods><methods><class-id>Tools.ClassSelector</class-id> <category>private</category><body>classSelected	| selection |	selection := searchList selection.	 selectedClass := selection isNil		ifTrue:[ | currentEntry |				 currentEntry := self searchString value trimBlanks.				 self selectMatch: currentEntry refineList: (currentEntry includes:$*).				 searchList selection]		ifFalse: [self searchString value: selection name. 				  selection]</body><body>selectMatch: aString refineList: aBoolean 	| match class |	aBoolean		ifTrue: 			[formerLists addLast: searchList list copy.			searchList list: (searchList list select: [:z | z name						matchesPattern: aString						ignoreCase: true						do: nil])].	formerLists size &gt; (aString occurrencesOf: $*)		ifTrue: 			[searchList list: formerLists removeLast].	match := aString , '*'.	class := searchList list detect: [:z | z name					matchesPattern: match					ignoreCase: true					do: nil]				ifNone: [].	class isNil ifFalse: [searchList selection: class]</body></methods><methods><class-id>Tools.ClassSelector class</class-id> <category>opening</category><body>findAClass: prompt	| aFinder |	aFinder := self new prompt: prompt.	aFinder open.	^aFinder selectedClass.</body><body>open	| aFinder |	aFinder := self new.	aFinder open.	^aFinder.</body></methods><methods><class-id>Tools.SmalltalkWorkbench class</class-id> <category>private</category><body>findAClass: prompt 	^ClassSelector findAClass: prompt</body></methods><methods><class-id>Tools.SmalltalkWorkbench class</class-id> <category>browsing</category><body>chooseAndBrowseClassFrom: aWindowOrNil	| class |	class := self findAClass: 'Browse what class?'.	class isNil ifTrue: [^self].	self browseClass: class</body></methods><methods><class-id>Tools.ClassSelector class</class-id> <category>interface specs</category><body>windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Find Class' 			#min: #(#{Core.Point} 412 284 ) 			#max: #(#{Core.Point} 412 284 ) 			#bounds: #(#{Graphics.Rectangle} 163 546 575 830 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 27 33 386 60 ) 					#name: #searchStringID 					#model: #searchString 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #classSelected ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.Rectangle} 27 69 386 232 ) 					#name: #searchListID 					#flags: 15 					#model: #searchList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #classSelected 						#doubleClickSelector: #ok ) 					#tabable: false 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 27 13 ) 					#name: #promptLabel 					#label: 'Find Class:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 153 243 205 268 ) 					#model: #ok 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 242 269 268 ) 					#model: #cancelAction 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category></class></st-source>