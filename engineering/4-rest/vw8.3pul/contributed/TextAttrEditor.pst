<?xml version="1.0"?><st-source><!-- Name: Text Attr EditorNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: Framework to interactively modify and view the result of FontDescription, TextAttributes, and FontPolicy specifications upon a ComposedText instance.  See TextOptionsEditor class protocol 'examples' for example usage.DbIdentifier: bear73DbTrace: 169525HideSource: falsePackageName: Text Attr EditorParcel: #('Text Attr Editor')ParcelName: Text Attr EditorPrintStringCache: (7.7 - 4,kgreek)SaveSource: trueVersion: 7.7 - 4Date: 6:17:27 AM August 5, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 6:17:27 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TextOptionsInterface</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composedTextHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Text Attributes Editor</category><attributes><package>Text Attr Editor</package></attributes></class><comment><class-id>Tools.TextOptionsInterface</class-id><body>TextOptionsInterface is an abstract class that defines the methods in common to access and update the text attributes of a ComposedText instance.Instance Variables:	composedTextHolder	&lt;ValueHolder on: aComposedText&gt;	A ValueHolder on the ComposedText instance that determines the TextAttributes and FontPolicy instances under edit. </body></comment><class><name>TextAttributesInterface</name><environment>Tools</environment><super>Tools.TextOptionsInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textAttributesHolder alignmentChoices bottomLeading topLeading </inst-vars><class-inst-vars></class-inst-vars><imports>			TextConstants.*			</imports><category>Text Attributes Editor</category><attributes><package>Text Attr Editor</package></attributes></class><comment><class-id>Tools.TextAttributesInterface</class-id><body>The TextAttributesInterface allows a user to view and edit text attributes for scaled (VariableSizeTextAttributes) or non-scaled (TextAttributes) instances.Description of Fields:Baseline:		The vertical distance in pixels between the top of a line and the baseline of that line.  The baseline is the line from which a font's ascent and descent are measured.Line Grid:		The vertical distance  in pixels between the top of one line of text and the next.First Indent:	The left indent in pixels of the first line of text.Rest Indent:	The left indent in pixels of all but the first line of text.Right Indent:	The right indent in pixels of all text.Clear Indents:	This button will reset all indents to zero.Text Line Alignment:	LeftFlush	Left justify 	RightFlush	Right justify	Justified	Full justify 	Centered	Center justifyIf this is open on a VariableSizeTextAttributes instance the following fields appear:Scaling:			How large this font should be relative to the system's default font size.Bottom Leading:	 If a body of text has 'fontAttributeForLeading' as the attribute for all of its characters, this specifies how many pixels there should be between the bottom of one line of text and the bottom of the line which contains the text.Top Leading:		If a body of text has 'fontAttributeForLeading' as the attribute for all of its characters, this specifies how many pixels there should be between the top of one line of text and the top of the line which contains the text.</body></comment><class><name>FontDescriptionInterface</name><environment>Tools</environment><super>Tools.TextOptionsInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fontDescriptionHolder definition familyList fonts name pixelSize pointSize encoding includeAnyFamily includeAnyManufacturer manufacturerList boldnessChoices encodingChoices matchLabel noMatch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Text Attributes Editor</category><attributes><package>Text Attr Editor</package></attributes></class><comment><class-id>Tools.FontDescriptionInterface</class-id><body>The FontDescriptionInterface application allows a user to view and edit a font specification.  A FontPolicy applies a FontDescription to find and rank all ImplementationFonts (platform fonts) that meet its specification.  A FontDescription may be so tightly specified that one or no fonts may be found that match it, or so loosely specified that all installed fonts will match it.   A quality value of 0 indicates an exact match.  A high quality value indicates a poor match.  Of the fonts found, the font with the lowest quality value is used.  If a FontDescription is too tightly specified it is possible that no matching font will be found on the current platform.  In this case the exception 'There are no fonts matching this font description' will occur. Description of Fields:Name:		Specification for the ImplementationFont name.  Match any if blank.  The '*' matches any substring.  For example, 'Arial*' will match all arial font variations.  According to the default FontPolicy a name entry takes high precedence in matching.  Avoid specifying a font entirely by name.Size:		Read or enter the pixel or point size of the font.  The conversion assumes 96 pixels = 72 points.  This is generally true for MS Windows applications on an SVGA monitor but is not so in other configurations.  Any particular font size specified for different families and manufacturers may result in slightly different physical sizes.   The sizes in these fields may be expressed as a fraction if the result of the conversion is not a whole number.  Any pixel size specification which is not a whole number may lead to unpredictable font results.Encoding:		The font encoding specified.  Select from a list of font encodings available on the current platform.  A blank selection matches any encoding.  The default FontPolicy places high preference on matching closely any specified encoding.Family:		View or edit the list of families to match.  The top entry in the list takes precedence.  From the list pop up menu you can select from a font family present on the current platform.  The menu also allows you to delete selections.  Checking "Include '*'" allows wild card matching to font families.Manufacturer:	View or edit the list of font manufacturers to match.  The top entry in the list takes precedence.  From the list pop up menu you can select from a font manufacturer present on the current platform.  The menu also allows you to delete selections.  Checking "Include '*'" allows wild card matching to manufacturers.  Font manufacturer is ignored for font selection on PC platforms.Boldness:	Select a boldness from 0 to 1 in 0.1 steps.  Any value greater than 0.5 typically selects a bold font.Serif:	Select a serif font if checked.Fixed:	Select a fixed width font if checked (e.g. Courier).Italic:	Make italicized if checked.Strikeout:	Strikeout if checked.Underline:	Underline if checked.Matching font list:	This displays a list of all ImplementationFonts that match the font description ranked by lowest quality value (most exact) first.  The top entry is the font used.  Selections in this list are ignored.FontDescription as code:	The text box in the lower left shows the FontDescription selections as it would appear as Smalltalk code.  You may edit and accept the FontDescription in this field to assume different selections. </body></comment><class><name>TextPrintAccessory</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Text Attributes Editor</category><attributes><package>Text Attr Editor</package></attributes></class><comment><class-id>Tools.TextPrintAccessory</class-id><body>I am a helper class for TextOptionsEditor. My window will print a sample of the text under TextOptionsEditor.</body></comment><class><name>TextOptionsEditor</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composedTextHolder majorKeys sampleText pageSelections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Text Attributes Editor</category><attributes><package>Text Attr Editor</package></attributes></class><comment><class-id>Tools.TextOptionsEditor</class-id><body>The TextOptionsEditor application allows a user to examine and change the text attributes of a ComposedText instance.  Copies of the FontDescription, TextAttributes or VariableSizeTextAttributes, and FontPolicy instances are installed and edited so that  system parameters are not changed.Instance Variables	composedTextHolder	&lt;ValueHolder on: aComposedText&gt; A ValueHolder on the ComposedText instance for the attributes and text appearing in the TextView	majorKeys		&lt;ValueHolder on:SelectionInList&gt; Notebook list of tab-subapplication associations	sampleText 	&lt;ValueHolder on:aText&gt;	Text copy of composedTextHolder	pageSelections &lt;Dictionary&gt;		Collection of tab names and interfaces.</body></comment><class><name>FontPolicyInterface</name><environment>Tools</environment><super>Tools.TextOptionsInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fontPolicyHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Text Attributes Editor</category><attributes><package>Text Attr Editor</package></attributes></class><comment><class-id>Tools.FontPolicyInterface</class-id><body>The FontPolicyInterface application allows a user to view and edit the weights of a FontPolicy.  Weights are assigned to the various properties that a FontDescription can have.   The higher the weight for a property the more relevance placed on finding a platform font that matches its criteria closely.  It is seldom necessary to change FontPolicy weights and instead is more appropriate to modify FontDescription properties.  See the class comment of FontPolicy for more information.</body></comment><methods><class-id>Tools.TextOptionsInterface</class-id> <category>accessing</category><body package="Text Attr Editor" selector="characterAttributes">characterAttributes	^self textAttributes characterAttributes</body><body package="Text Attr Editor" selector="composedText">composedText	^self composedTextHolder value</body><body package="Text Attr Editor" selector="composedTextHolder">composedTextHolder	composedTextHolder isNil		ifTrue:			[composedTextHolder :=  'This is some sample text'  asComposedText asValue].	^composedTextHolder</body><body package="Text Attr Editor" selector="composedTextHolder:">composedTextHolder: aValueHolder 	composedTextHolder := aValueHolder.</body><body package="Text Attr Editor" selector="fontDescription">fontDescription	^self characterAttributes defaultQueryFor: self fontPolicy</body><body package="Text Attr Editor" selector="fontPolicy">fontPolicy	^self composedText fontPolicy</body><body package="Text Attr Editor" selector="textAttributes">textAttributes	^self composedText textStyle</body><body package="Text Attr Editor" selector="textAttributes:">textAttributes: aTextAttributes	 self composedText textStyle: aTextAttributes</body></methods><methods><class-id>Tools.TextOptionsInterface</class-id> <category>printing</category><body package="Text Attr Editor" selector="descriptionString">descriptionString	self subclassResponsibility</body></methods><methods><class-id>Tools.TextOptionsInterface</class-id> <category>help service</category><body package="Text Attr Editor" selector="help">help	(SimpleHelp helpString: self class comment) open</body></methods><methods><class-id>Tools.TextOptionsInterface</class-id> <category>intialize-release</category><body package="Text Attr Editor" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self release</body></methods><methods><class-id>Tools.TextOptionsInterface</class-id> <category>updating</category><body package="Text Attr Editor" selector="updateSampleText">updateSampleText	"Adopt the TextAttributes changes to the ComposedText"	self composedText textStyle: self textAttributes.  	"Update the dependents of the composedTextHolder"  	self composedTextHolder changed:#value.</body></methods><methods><class-id>Tools.TextAttributesInterface</class-id> <category>alignment choices</category><body package="Text Attr Editor" selector="alignmentChoices">alignmentChoices	^alignmentChoices isNil		ifTrue: [alignmentChoices := Dictionary						with: 'Centered' -&gt; Centered						with: 'Justified' -&gt; Justified						with: 'LeftFlush' -&gt; LeftFlush						with: 'RightFlush' -&gt; RightFlush]		ifFalse: [alignmentChoices]</body><body package="Text Attr Editor" selector="alignmentIndex:">alignmentIndex: aString	^self alignmentChoices at: aString</body><body package="Text Attr Editor" selector="alignmentIndicies">alignmentIndicies	^self alignmentChoices values asValue</body><body package="Text Attr Editor" selector="alignmentLabel:">alignmentLabel: anInteger	^self alignmentChoices keyAtValue: anInteger</body></methods><methods><class-id>Tools.TextAttributesInterface</class-id> <category>aspects</category><body package="Text Attr Editor" selector="bottomLeading">bottomLeading	^bottomLeading isNil		ifTrue:			[bottomLeading := (PluggableAdaptor on: self textAttributesHolder)						getBlock: [:txtattr | self hasAVariableSizeTextAttributes											ifTrue:[txtattr value bottomLeading]											ifFalse:[nil]]						putBlock: [:txtattr :bottom |self hasAVariableSizeTextAttributes											ifTrue:[txtattr value bottomLeading: bottom]											ifFalse:[nil]]						updateBlock: [:txtattr :aspect :other | true]]		ifFalse:			[bottomLeading]</body><body package="Text Attr Editor" selector="textAttributesHolder">textAttributesHolder	^textAttributesHolder isNil		ifTrue: [textAttributesHolder := self textAttributes asValue.				textAttributesHolder onChangeSend:#changeVisibility to:self]		ifFalse: [textAttributesHolder]</body><body package="Text Attr Editor" selector="topLeading">topLeading	^topLeading isNil		ifTrue:			[topLeading := (PluggableAdaptor on: self textAttributesHolder)						getBlock: [:txtattr | self hasAVariableSizeTextAttributes											ifTrue:[txtattr value topLeading]											ifFalse:[nil]]						putBlock: [:txtattr :bottom |self hasAVariableSizeTextAttributes											ifTrue:[txtattr value topLeading: bottom]											ifFalse:[nil]]						updateBlock: [:txtattr :aspect :other | true]]		ifFalse:			[topLeading]</body></methods><methods><class-id>Tools.TextAttributesInterface</class-id> <category>updating</category><body package="Text Attr Editor" selector="changeVisibility">changeVisibility	"Scale, top leading, and bottom leading apply to only VariableSizeTextAttributes. Hide these fields if the textAttributesHolder has a plain instance of TextAttributes"	self postBuildWith: self builder</body></methods><methods><class-id>Tools.TextAttributesInterface</class-id> <category>actions</category><body package="Text Attr Editor" selector="clearIndents">clearIndents"Clear entries to the first, rest, and right ident fields and update"	self textAttributesHolder value clearIndents.	self textAttributesHolder changed.	self updateSampleText.</body></methods><methods><class-id>Tools.TextAttributesInterface</class-id> <category>printing</category><body package="Text Attr Editor" selector="descriptionString">descriptionString	"Answer a string that includes a report of all text attributes"	| stream |	stream :=String new writeStream.	stream nextPutAll: self textAttributes printString,':';cr.	stream nextPutAll:'Alignment:';tab;nextPutAll:(self alignmentLabel: self textAttributes alignment);cr.	stream nextPutAll:'Line Grid:';tab;nextPutAll:self textAttributes lineGrid printString;cr.	stream nextPutAll:'First Indent:';tab;nextPutAll:self textAttributes firstIndent printString;cr.	stream nextPutAll:'Rest Indent:';tab;nextPutAll:self textAttributes restIndent printString;cr.	stream nextPutAll:'Right Indent:';tab;nextPutAll:self textAttributes rightIndent printString;cr.	(self textAttributes isKindOf: VariableSizeTextAttributes)		ifTrue:[stream nextPutAll:'Scaling:';tab;nextPutAll:self textAttributes scalingFactor printString;cr.			    stream nextPutAll:'Bottom Leading:';tab;nextPutAll:self textAttributes bottomLeading printString;cr.			    stream nextPutAll:'Top Leading:';tab;nextPutAll:self textAttributes topLeading printString;cr].	stream cr.	^stream contents</body></methods><methods><class-id>Tools.TextAttributesInterface</class-id> <category>testing</category><body package="Text Attr Editor" selector="hasAVariableSizeTextAttributes">hasAVariableSizeTextAttributes	^self textAttributesHolder value isKindOf:VariableSizeTextAttributes</body></methods><methods><class-id>Tools.TextAttributesInterface</class-id> <category>interface opening</category><body package="Text Attr Editor" selector="postBuildWith:">postBuildWith: aBuilder 	"If we open on a VariableSizeTextAttributes instance then make scale, top, and bottom leading fields visible.  If it is a TextAttributes instance then hide these fields"	| composite |	composite := aBuilder componentAt: #variableSizeComposite.	self hasAVariableSizeTextAttributes		ifTrue: [composite beVisible]		ifFalse: [composite beInvisible].</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>family selection</category><body package="Text Attr Editor" selector="addFamily">addFamily	"Request a selection for a font family from a list of 	available fonts and add it after the current family 	selection. If no family is selected add the choice to the 	beginning of the list"	| families availableFamilyList choice list |	families := Set new.	self fontPolicy availableFonts do: [:font | families add: font family].	availableFamilyList := families asSortedCollection.	choice := Dialog				choose: 'Choose an available font family'				fromList: availableFamilyList				values: availableFamilyList				lines: 8				cancel: [#noChoice].	choice = #noChoice ifTrue: [^self].	list := self familyList list.	(list includes: choice)		ifFalse: 			[list add: choice beforeIndex: self familyList selectionIndex + 1.			self updateFontFamily]</body><body package="Text Attr Editor" selector="clearFamilyList">clearFamilyList	self familyList list: List new.	self updateFontFamily</body><body package="Text Attr Editor" selector="deleteFamilySelection">deleteFamilySelection	"Remove the selected family from the family list"	| familySelectionInList selection |	familySelectionInList := self familyList.	(selection := familySelectionInList selection) isNil		ifFalse: 			[familySelectionInList list remove: selection.			self updateFontFamily]</body><body package="Text Attr Editor" selector="familyList">familyList	familyList isNil		ifTrue: 			[familyList := SelectionInList new.			self updateFamilyList].	^familyList</body><body package="Text Attr Editor" selector="includeAnyFamily">includeAnyFamily	^includeAnyFamily isNil		ifTrue: 			[| family |			family := self fontDescription family.			includeAnyFamily := ((family isKindOf: SequenceableCollection)						and: [(family isKindOf: String) not and: [family includes: '*']]) asValue]		ifFalse: [includeAnyFamily]</body><body package="Text Attr Editor" selector="updateFamilyList">updateFamilyList	"Update the family list and includeAny check boxes from 	the font description"	| list family |	family := self fontDescription family.	family isNil 		ifTrue: [list := List new]		ifFalse: 			[list := (family isKindOf: String) 						ifTrue: [List with: family]						ifFalse: [family asList].			(list includes: '*') 				ifTrue: 					[self includeAnyFamily value: true.					list remove: '*']				ifFalse: [self includeAnyFamily value: false]].	self familyList list: list</body><body package="Text Attr Editor" selector="updateFontFamily">updateFontFamily	"Update the font description from a change in the font 	family selections"	| list family |	list := self familyList list copy.	self includeAnyFamily value ifTrue: [list add: '*'].	list isEmpty 		ifTrue: [family := nil]		ifFalse: 			[family := list size &gt; 1 ifTrue: [list asArray] ifFalse: [list at: 1]].	self fontDescription family: family.	self updateSelection</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>manufacturer selection</category><body package="Text Attr Editor" selector="addManufacturer">addManufacturer	"Request a selection for a font manufacturer from a list of 	available fonts and add it after the current manufacturer 	selection. If no manufacturer is selected add the choice to the 	beginning of the list"	| availableManufacturerList choice list manufacturers |	manufacturers := Set new.	self fontPolicy availableFonts do: [:font | manufacturers add: font manufacturer].	availableManufacturerList := manufacturers asSortedCollection.	choice := Dialog				choose: 'Choose an available font manufacturer'				fromList: availableManufacturerList				values: availableManufacturerList				lines: 8				cancel: [#noChoice].	choice = #noChoice ifTrue: [^self].	list := self manufacturerList list.	(list includes: choice)		ifFalse: 			[list add: choice beforeIndex: self manufacturerList selectionIndex + 1.			self updateFontManufacturer]</body><body package="Text Attr Editor" selector="clearManufacturerList">clearManufacturerList	self manufacturerList list: List new.	self updateFontManufacturer</body><body package="Text Attr Editor" selector="deleteManufacturerSelection">deleteManufacturerSelection	"Remove the selected manufacturer from the manufacturer list"	| manufacturerSelectionInList selection |	manufacturerSelectionInList := self manufacturerList.	(selection := manufacturerSelectionInList selection) isNil		ifFalse: 			[manufacturerSelectionInList list remove: selection.			self updateFontManufacturer]</body><body package="Text Attr Editor" selector="includeAnyManufacturer">includeAnyManufacturer	^includeAnyManufacturer isNil		ifTrue: 			[| manufacturer |			manufacturer := self fontDescription manufacturer.			includeAnyManufacturer := ((manufacturer isKindOf: SequenceableCollection)						and: [(manufacturer isKindOf: String) not and: [manufacturer includes: '*']]) asValue]		ifFalse: [includeAnyManufacturer]</body><body package="Text Attr Editor" selector="manufacturerList">manufacturerList	manufacturerList isNil		ifTrue: 			[manufacturerList := SelectionInList new.			self updateManufacturerList].	^manufacturerList</body><body package="Text Attr Editor" selector="updateFontManufacturer">updateFontManufacturer	"Update the font description from a change in the font 	manufacturer selections"	| list manufacturer |	list := self manufacturerList list copy.	self includeAnyManufacturer value ifTrue: [list add: '*'].	list isEmpty 		ifTrue: [manufacturer := nil]		ifFalse: 			[manufacturer := list size &gt; 1 ifTrue: [list asArray] ifFalse: [list at: 1]].	self fontDescription manufacturer: manufacturer.	self updateSelection</body><body package="Text Attr Editor" selector="updateManufacturerList">updateManufacturerList	"Update the manufacturer list and includeAny check boxes from 	the font description"	| list manufacturer |	manufacturer := self fontDescription manufacturer.	manufacturer isNil 		ifTrue: [list := List new]		ifFalse: 			[list := (manufacturer isKindOf: String) 						ifTrue: [List with: manufacturer]						ifFalse: [manufacturer asList].			(list includes: '*') 				ifTrue: 					[self includeAnyManufacturer value: true.					list remove: '*']				ifFalse: [self includeAnyManufacturer value: false]].	self manufacturerList list: list</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>aspects</category><body package="Text Attr Editor" selector="boldnessChoices">boldnessChoices	^boldnessChoices isNil		ifTrue:			[boldnessChoices :=  (1 to: 0 by:-0.1) asValue]		ifFalse:			[boldnessChoices]</body><body package="Text Attr Editor" selector="definition">definition	^definition isNil		ifTrue: [definition := self fontDescriptionAsCode asValue]		ifFalse: [definition]</body><body package="Text Attr Editor" selector="encoding">encoding	^encoding isNil		ifTrue: [encoding := (PluggableAdaptor on: self fontDescriptionHolder)						getBlock: [:font | font  value encoding]						putBlock: [:font :enc | (enc isNil or:[enc isEmpty])												ifTrue:[font  value encoding: nil]												ifFalse:[font  value encoding: enc]]						updateBlock: [:font :aspect :other | true]]		ifFalse: [encoding]</body><body package="Text Attr Editor" selector="encodingChoices">encodingChoices	^encodingChoices isNil		ifTrue: 			[encodingChoices := Set new.			self fontPolicy availableFonts do: [:font | encodingChoices add: font encoding].			encodingChoices := encodingChoices asSortedCollection.			encodingChoices add: String new.			encodingChoices := encodingChoices asValue]		ifFalse: [encodingChoices]</body><body package="Text Attr Editor" selector="fontDescription">fontDescription	^self fontDescriptionHolder value</body><body package="Text Attr Editor" selector="fontDescriptionHolder">fontDescriptionHolder	^fontDescriptionHolder isNil		ifTrue: [fontDescriptionHolder := (PluggableAdaptor on: self characterAttributes)						getBlock: [:attrib | attrib defaultQueryFor: self fontPolicy ]						putBlock: [:attrib :font | attrib setDefaultQuery: font for: self fontPolicy]						updateBlock: [:font :aspect :other | true].			     fontDescriptionHolder onChangeSend:#updateSelection to: self]		ifFalse: [fontDescriptionHolder]</body><body package="Text Attr Editor" selector="fontListSample">fontListSample	^ 'XxMmAaBb' asValue</body><body package="Text Attr Editor" selector="fonts">fonts	^fonts isNil		ifTrue: [fonts := SelectionInList new]		ifFalse: [fonts]</body><body package="Text Attr Editor" selector="name">name	^name isNil		ifTrue: [name := (PluggableAdaptor on: self fontDescriptionHolder)						getBlock: [:font | font value name]						putBlock: [:font :entry | entry isEmpty												ifTrue:[font value name: nil]												ifFalse:[font value name: entry]]						updateBlock: [:font :aspect :other | true]]		ifFalse: [name]</body><body package="Text Attr Editor" selector="pixelSize">pixelSize	^pixelSize isNil		ifTrue: [pixelSize := (PluggableAdaptor on: self fontDescription)						getBlock: [:font | font pixelSize]						putBlock: 							[:font :pixels | 							pixels = 0								ifTrue: [font pixelSize: nil]								ifFalse: [font pixelSize: pixels].							self characterAttributes setDefaultQuery: font for: self fontPolicy]						updateBlock: [:font :aspect :other | true]]		ifFalse: [pixelSize]</body><body package="Text Attr Editor" selector="pointSize">pointSize	^pointSize isNil		ifTrue: [pointSize := (PluggableAdaptor on: self pixelSize)						getBlock: [:pixels | self class pixelsToPoints: pixels value]						putBlock: [:pixels :points | pixels value: (self class pointsToPixels: points)]						updateBlock: [:pixels :aspect :other | true]]		ifFalse: [pointSize]</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>font description editor</category><body package="Text Attr Editor" selector="editorAccept">editorAccept	"Compile and replace my FontDescription from the 	definition in the editor"	| editor result |	editor := (self builder componentAt: #descriptionEditor) widget.	result := Compiler				evaluate: self definition value				for: nil				notifying: editor controller				logged: false.	(result isKindOf: FontDescription)		ifTrue: [self fontDescriptionHolder value: result]		ifFalse: [editor flash].</body><body package="Text Attr Editor" selector="editorUpdateRequest:">editorUpdateRequest: aParagraphEditor 	"Verify that the user may leave the font decription editor 	with unsaved changes"	^aParagraphEditor view updateRequest</body><body package="Text Attr Editor" selector="fontDescriptionAsCode">fontDescriptionAsCode	"Answer the fontDescription coded in Smalltalk"	| plainFont stream attributes |	plainFont := FontDescription new.	stream := String new writeStream.	stream nextPutAll: 'FontDescription new'.	attributes := OrderedCollection new.	#(#name #family #manufacturer #pixelSize #encoding #encodings #boldness #serif #fixedWidth #italic #setWidth #shadow #strikeout #underline #color #outline) 		do: 			[:message | 			| attribute |			attribute := self fontDescription perform: message.			(plainFont perform: message) = attribute 				ifFalse: [attributes add: message -&gt; attribute]].	attributes do: 			[:assoc | 			stream nextPutAll: ('&lt;n&gt;&lt;t&gt;&lt;1s&gt;: &lt;2p&gt;' expandMacrosWith: assoc key asString						with: assoc value)]		separatedBy: [stream nextPut: $;].	stream nextPut: $..	^stream contents</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>updating</category><body package="Text Attr Editor" selector="pixelSizeChanged">pixelSizeChanged	"If the pixel size was changed for a scaled text instance warn the user to change the scale from the text style"	(self textAttributes isKindOf: VariableSizeTextAttributes)		ifTrue: [Dialog warn: 'Your pixel size change was applied to a \scaled text style (VariableSizeTextAttributes).\Change the TextAttributes scaling factor\to resize the font' withCRs].	^true</body><body package="Text Attr Editor" selector="sampleFontSelected">sampleFontSelected		| fontSample |	fontSample := self widgetAt: #fontListSample.	fontSample isVisible: self fonts selectionIndex &gt; 0.	self fonts		selectionDo:			[:label | 			| fontName |			fontName := (label readStream)				skipThrough: $:;				skipSeparators;				upToEnd.			[| textStyle |			textStyle := TextAttributes				characterAttributes:					(CharacterAttributes defaultQuery: (FontDescription new name: fontName)).			textStyle alignment: TextConstants.RightFlush.			fontSample				textStyle: textStyle;				updateDisplayContents]				on: NoMatchingFontError				do:					[:ex | 					fontSample						textStyle: TextAttributes default;						editText: 'No such font';						flash.					ex return]]</body><body package="Text Attr Editor" selector="updateDefinition">updateDefinition		| editor |	self definition value: self fontDescriptionAsCode.	editor := self wrapperAt: #descriptionEditor.	editor		lookPreferences:			(editor lookPreferences				foregroundColor:					(noMatch						ifTrue: [ColorValue red]						ifFalse: [nil]))</body><body package="Text Attr Editor" selector="updateFontList">updateFontList	"Update the list of matching fonts and its quantity label"		| matches names bestFont ranked fontPolicy noFontBlock |	fontPolicy := self fontPolicy.	[noFontBlock := fontPolicy noFontBlock.	fontPolicy noFontBlock: self noMatchBlock.	matches := fontPolicy searchForFont: self fontDescription.	"May include duplicates"	bestFont := fontPolicy findBestFont: self fontDescription]		ensure: [fontPolicy noFontBlock: noFontBlock].	ranked := noMatch		ifTrue: [#()]		ifFalse:			[matches 				sortBlock: [:x :y | x key &lt; y key or: [x value = bestFont]]].	names := ranked		collect:			[:assoc | 			'&lt;1p&gt;:&lt;t&gt;&lt;2s&gt;'				expandMacrosWith: assoc key				with: assoc value name].	self fonts list: names.	matchLabel label text: names size printString , ' matching fonts       '.	matchLabel invalidate</body><body package="Text Attr Editor" selector="updateName">updateName	"Update the font description name from the selection"	self fontDescription name: self name value.	self updateSelection</body><body package="Text Attr Editor" selector="updateSampleText">updateSampleText	"Adopt the font description to the sample text widget"	"Update the text attributes for a change in font description"	self textAttributes gridForFont: nil withLead: 1. 	super updateSampleText.</body><body package="Text Attr Editor" selector="updateSelection">updateSelection	"Update the font description selections in the window"		noMatch := false.	self characterAttributes invalidateQueryCache.	self updateFontList.	self updateDefinition.	self updateFamilyList.	self updateManufacturerList.	self updateSampleText</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>initialize-release</category><body package="Text Attr Editor" selector="initialize">initialize	super initialize.	noMatch := false.</body><body package="Text Attr Editor" selector="release">release	self fontDescriptionHolder release removeDependent: self.</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>private</category><body package="Text Attr Editor" selector="noMatchBlock">noMatchBlock		^[:fontRequest | 	noMatch := true.	self fontPolicy defaultFont fontDescription]</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>interface opening</category><body package="Text Attr Editor" selector="postBuildWith:">postBuildWith: aBuilder "Set tabs for the font list"	| ta tabWidth |	ta := TextAttributes styleNamed: #small.	tabWidth := (ComposedText withText: '0.00000: ' style: ta) width.	ta useTabs: (tabWidth to: 5 * tabWidth by: tabWidth).	(aBuilder componentAt: #fontList) widget 		textStyle: ta. "Disable selections in the list""Prepare the font match list and quantity label"	matchLabel := (aBuilder componentAt: #fontNumber) widget.	self updateSelection</body></methods><methods><class-id>Tools.FontDescriptionInterface</class-id> <category>printing</category><body package="Text Attr Editor" selector="descriptionString">descriptionString	"Answer a string that summaries the properties and fonts that match this description"	|sublist stream |	sublist := self fonts list copyFrom:1 to:(5 min: self fonts list size).	stream := String new writeStream.	stream nextPutAll: 'FontDescription:';cr.	stream nextPutAll: self definition value;cr; cr.	stream nextPutAll:'First five matching fonts and quality factors:';cr.	sublist do:[:line| stream nextPutAll: line;cr].	stream cr.	^stream contents</body></methods><methods><class-id>Tools.FontDescriptionInterface class</class-id> <category>menu access</category><body package="Text Attr Editor" selector="editorMenu">editorMenu	^Menu 		labelList: ParagraphEditor editGroupLabels , #(#('accept' 'cancel')) 		values: ParagraphEditor editGroupSelectors , #(#editorAccept #cancel)</body></methods><methods><class-id>Tools.FontDescriptionInterface class</class-id> <category>conversions</category><body package="Text Attr Editor" selector="pixelsToPoints:">pixelsToPoints: aNumberInPixelsOrNil		^aNumberInPixelsOrNil isNil		ifTrue:[nil]		ifFalse:[aNumberInPixelsOrNil * 72 / 96]</body><body package="Text Attr Editor" selector="pointsToPixels:">pointsToPixels: aNumberInPointsOrNil	^aNumberInPointsOrNil isNil		ifTrue:[nil]		ifFalse:[aNumberInPointsOrNil * 96 / 72]</body></methods><methods><class-id>Tools.TextPrintAccessory</class-id> <category>actions</category><body package="Text Attr Editor" selector="printSettingsSummary">printSettingsSummary	self builder window application printSettingsSummary</body></methods><methods><class-id>Tools.TextOptionsEditor</class-id> <category>aspects</category><body package="Text Attr Editor" selector="composedTextHolder">composedTextHolder	composedTextHolder isNil		ifTrue:			[self composedTextHolder: 'This is some sample text' asComposedText asValue].	^composedTextHolder</body><body package="Text Attr Editor" selector="composedTextHolder:">composedTextHolder: aValueHolder"Set the ValueHolder on an instance ComposedText.  Install copies of TextAttributes, CharacterAttributes, and FontDescription to this ComposedText instance to prevent changing any global references" 	| textStyle characterAttributes fontDescription composedText |	composedTextHolder := aValueHolder. 	composedText := composedTextHolder value.	textStyle := composedText textStyle copy.	characterAttributes := textStyle characterAttributes copy.	fontDescription := (characterAttributes defaultFontFor: composedText fontPolicy) copy.	characterAttributes setDefaultQuery: fontDescription for:composedText fontPolicy.	textStyle setCharacterAttributes: characterAttributes.	composedText  textStyle: textStyle.	"Finally set up dependency on composedTextHolder"	composedTextHolder onChangeSend:#updateTextView to: self</body><body package="Text Attr Editor" selector="majorKeys">majorKeys	^majorKeys isNil		ifTrue:			[majorKeys := SelectionInList with: #('Font Description' 'Text Attributes' 'Font Policy') ]		ifFalse:			[majorKeys]</body><body package="Text Attr Editor" selector="pageSelections">pageSelections	^pageSelections isNil 		ifTrue: 			[pageSelections := Dictionary 				with: 'Font Description' -&gt; (FontDescriptionInterface new 								composedTextHolder: self composedTextHolder)				with: 'Text Attributes' 						-&gt; (TextAttributesInterface new composedTextHolder: self composedTextHolder)				with: 'Font Policy' 						-&gt; (FontPolicyInterface new composedTextHolder: self composedTextHolder)]		ifFalse: [pageSelections]</body><body package="Text Attr Editor" selector="sampleText">sampleText	^sampleText isNil		ifTrue:			[sampleText := self composedTextHolder copy]		ifFalse:			[sampleText]</body></methods><methods><class-id>Tools.TextOptionsEditor</class-id> <category>initialize release</category><body package="Text Attr Editor" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self release</body><body package="Text Attr Editor" selector="release">release	"Release all the subcanvases"	self pageSelections do:[:page|page  release].	super release.</body></methods><methods><class-id>Tools.TextOptionsEditor</class-id> <category>printing</category><body package="Text Attr Editor" selector="openPrintAccessory">openPrintAccessory	self builder window beMaster application:self.  	(TextPrintAccessory open window)		application: self;		beSlave;		receiveWindowEvents:#(#close #collapse #expand).</body><body package="Text Attr Editor" selector="openSettingsSummary">openSettingsSummary	"Open a window describing the text attributes selections"	| description |	description := self majorKeys list inject:String new into:[:sofar :assoc|  sofar, assoc value descriptionString].	ComposedTextView open: description asValue.</body><body package="Text Attr Editor" selector="printSettingsSummary">printSettingsSummary	"Print a summary of the attributes of each page and the sample text in the attributes selected"	 | doc |	doc := Document new				doFooter: true				footerString:'Composed Text Attributes Summary'				doPageNumbers: false.	doc setTabs:#(1.5 2 2.5).	self pageSelections do:[:value| doc startParagraph addString: value descriptionString].	doc startParagraph addText: self sampleText value under: self composedTextHolder value textStyle. 	doc toPrinter close.</body></methods><methods><class-id>Tools.TextOptionsEditor</class-id> <category>interface opening</category><body package="Text Attr Editor" selector="postBuildWith:">postBuildWith: aBuilder	"Open with the text style displayed"	self updateTextView.</body></methods><methods><class-id>Tools.TextOptionsEditor</class-id> <category>updating</category><body package="Text Attr Editor" selector="changedTab">changedTab	"Update the notebook page according to a change in the tab"	(self builder componentAt:#notebook) widget		client: (self pageSelections at: self majorKeys selection)		spec: #windowSpec.</body><body package="Text Attr Editor" selector="updateTextHolder">updateTextHolder	"Update the text in the composedTextHolder from a user entry in the text field"	self composedTextHolder value text: self sampleText value.</body><body package="Text Attr Editor" selector="updateTextView">updateTextView	"Update the text according to a change of the composed text style"	| textView | 	textView:=(self builder componentAt:#textView) widget.	"Update the text view text style"	textView textStyle: self composedTextHolder value textStyle.	"Recompose and display"	textView displayContents composeAll.	textView invalidate.</body></methods><methods><class-id>Tools.TextOptionsEditor class</class-id> <category>instance creation</category><body package="Text Attr Editor" selector="openOnComposedTextValue:">openOnComposedTextValue: aValueHolder 	^(self new)		composedTextHolder: aValueHolder; 		open;		yourself</body></methods><methods><class-id>Tools.TextOptionsEditor class</class-id> <category>examples</category><body package="Text Attr Editor" selector="printerPixelSizeExample">printerPixelSizeExample	"TextOptionsEditor printerPixelSizeExample"	| ta text ps font ca |	font := FontDescription new 			family: #('times' '*');			pixelSize: 16;			boldness: 0.8.	ca := CharacterAttributes newWithDefaultAttributes setDefaultQuery: font.		ta := TextAttributes characterAttributes: ca.	text := 'This is some simple sample text' asComposedText textStyle: ta.	ps := Printer startPrintJobNamed: 'temp.ps'.	text newGraphicsDevice: ps graphicsDevice.	(self openOnComposedTextValue: text asValue)		openPrintAccessory.	ps close.</body><body package="Text Attr Editor" selector="printerScaleSizeExample">printerScaleSizeExample	"TextOptionsEditor printerScaleSizeExample"	| ta text ps font |	font := FontDescription new 			family: #('times' '*').	ta := VariableSizeTextAttributes defaultFontQuery: font.	ta scalingFactor: 1.2.	text := 'This is some simple sample text' asComposedText textStyle: ta.	ps := Printer startPrintJobNamed: 'temp.ps'.	text newGraphicsDevice: ps graphicsDevice.	(self openOnComposedTextValue: text asValue)		openPrintAccessory.	ps close.</body><body package="Text Attr Editor" selector="screenPixelSizeExample">screenPixelSizeExample	"TextOptionsEditor screenPixelSizeExample"	| ta text font ca |	font := FontDescription new family: 'arial'; 			boldness: 1.0;			color: ColorValue red.	ca := CharacterAttributes newWithDefaultAttributes setDefaultQuery: font.		ta := TextAttributes characterAttributes: ca.	text :=  'This is some sample text' asComposedText textStyle: ta.	self openOnComposedTextValue: text asValue.</body><body package="Text Attr Editor" selector="screenScaleSizeExample">screenScaleSizeExample	"TextOptionsEditor screenScaleSizeExample"	| ta text font |	font := FontDescription new family: 'arial'; 			boldness: 1.0;			color: ColorValue red.			ta := VariableSizeTextAttributes defaultFontQuery: font.	ta scalingFactor: 1.2.	text := 'This is some simple sample text' asComposedText textStyle: ta.	self openOnComposedTextValue: text asValue.</body></methods><methods><class-id>Tools.FontPolicyInterface</class-id> <category>printing</category><body package="Text Attr Editor" selector="descriptionString">descriptionString	"Answer a string that shows the FontPolicy settings"	| policy stream |	policy := self fontPolicyHolder value.	stream := String new writeStream.	stream nextPutAll: 'FontPolicy Weights:';cr.	stream nextPutAll:'Boldness:';tab;nextPutAll:policy boldnessWeight printString;cr.	stream nextPutAll:'Manufacturer:';tab;nextPutAll:policy manufacturerWeight printString;cr.	stream nextPutAll:'Encoding:';tab;nextPutAll:policy encodingWeight printString;cr.	stream nextPutAll:'Name:';tab;nextPutAll:policy nameWeight printString;cr.	stream nextPutAll:'Family:';tab;nextPutAll:policy familyWeight printString;cr.	stream nextPutAll:'Pixel Size:';tab;nextPutAll:policy pixelSizeWeight printString;cr.	stream nextPutAll:'Fixed Width:';tab;nextPutAll:policy fixedWidthWeight printString;cr.	stream nextPutAll:'Serif:';tab;nextPutAll:policy serifWeight printString;cr.	stream nextPutAll:'Italic:';tab;nextPutAll:policy italicWeight printString;cr.	stream cr.	^stream contents</body></methods><methods><class-id>Tools.FontPolicyInterface</class-id> <category>aspects</category><body package="Text Attr Editor" selector="fontPolicyHolder">fontPolicyHolder		^fontPolicyHolder isNil		ifTrue:			[fontPolicyHolder := self fontPolicy asValue]		ifFalse:			[fontPolicyHolder]</body></methods><methods><class-id>Tools.FontPolicyInterface</class-id> <category>actions</category><body package="Text Attr Editor" selector="flushCache">flushCache	self fontPolicy flushFonts</body></methods><methods><class-id>Tools.TextAttributesInterface class</class-id> <category>interface specs</category><body package="Text Attr Editor" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Text Attributes' 			#bounds: #(#Rectangle 694 100 1214 525 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ComboBoxSpec 					#layout: #(#Rectangle 327 37 444 63 ) 					#model: #'textAttributesHolder alignment' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #updateSampleText ) 					#type: #object 					#comboList: #alignmentIndicies 					#readSelector: 					#alignmentIndex: 					#printSelector: 					#alignmentLabel: ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 114 7 405 29 ) 					#flags: 0 					#model: #textAttributesHolder 					#alignment: #center 					#isReadOnly: true 					#type: #object ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 392 217 444 242 ) 					#model: #help 					#label: 'Help' 					#defaultable: true ) 				#(#CompositeSpecCollection 					#collection: #(						#(#LabelSpec 							#layout: #(#Point 0 0 ) 							#label: 'Scaling' ) 						#(#InputFieldSpec 							#layout: #(#Rectangle 135 1 191 27 ) 							#model: #'textAttributesHolder characterAttributes scalingFactor' 							#callbacksSpec: 							#(#UIEventCallbackSubSpec 								#valueChangeSelector: #updateSampleText ) 							#type: #number ) 						#(#InputFieldSpec 							#layout: #(#Rectangle 135 37 191 63 ) 							#model: #bottomLeading 							#callbacksSpec: 							#(#UIEventCallbackSubSpec 								#valueChangeSelector: #updateSampleText ) 							#type: #number ) 						#(#InputFieldSpec 							#layout: #(#Rectangle 135 74 191 100 ) 							#model: #topLeading 							#callbacksSpec: 							#(#UIEventCallbackSubSpec 								#valueChangeSelector: #updateSampleText ) 							#type: #number ) 						#(#LabelSpec 							#layout: #(#Point 0 37 ) 							#label: 'Bottom Leading' ) 						#(#LabelSpec 							#layout: #(#Point 0 74 ) 							#label: 'Top Leading' ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 253 77 444 177 ) 						#name: #variableSizeComposite ) ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 166 37 222 63 ) 					#model: #'textAttributesHolder baseline' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #updateSampleText ) 					#type: #number ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 167 73 223 99 ) 					#model: #'textAttributesHolder lineGrid' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #updateSampleText ) 					#type: #number ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 167 109 223 135 ) 					#model: #'textAttributesHolder firstIndent' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #updateSampleText ) 					#type: #number ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 166 145 222 171 ) 					#model: #'textAttributesHolder restIndent' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #updateSampleText ) 					#type: #number ) 				#(#LabelSpec 					#layout: #(#Point 60 39 ) 					#label: 'Baseline' ) 				#(#LabelSpec 					#layout: #(#Point 60 75 ) 					#label: 'Line Grid' ) 				#(#LabelSpec 					#layout: #(#Point 60 111 ) 					#label: 'First Indent' ) 				#(#LabelSpec 					#layout: #(#Point 60 183 ) 					#label: 'Right Indent' ) 				#(#LabelSpec 					#layout: #(#Point 60 147 ) 					#label: 'Rest Indent' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 166 181 222 205 ) 					#model: #'textAttributesHolder rightIndent' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #updateSampleText ) 					#type: #number ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 115 217 221 242 ) 					#model: #clearIndents 					#label: 'Clear Indents' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.FontDescriptionInterface class</class-id> <category>resources</category><body package="Text Attr Editor" selector="familyMenu">familyMenu	"UIMenuEditor new openOnClass: self andSelector: #familyMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 'add' 				#value: #addFamily ) 			#(#MenuItem 				#rawLabel: 'delete' 				#value: #deleteFamilySelection ) 			#(#MenuItem 				#rawLabel: 'clear' 				#value: #clearFamilyList ) ) #(2 1 ) nil ) decodeAsLiteralArray</body><body package="Text Attr Editor" selector="manufacturerMenu">manufacturerMenu	"UIMenuEditor new openOnClass: self andSelector: #manufacturerMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 'add' 				#value: #addManufacturer ) 			#(#MenuItem 				#rawLabel: 'delete' 				#value: #deleteManufacturerSelection ) 			#(#MenuItem 				#rawLabel: 'clear' 				#value: #clearManufacturerList ) ) #(2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FontDescriptionInterface class</class-id> <category>interface specs</category><body package="Text Attr Editor" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Font Description' 			#bounds: #(#{Graphics.Rectangle} 640 510 1160 990 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 162 0 -4 0.5 -35 1 ) 					#name: #descriptionEditor 					#model: #definition 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#editorUpdateRequest: ) 					#menu: #editorMenu 					#tabRequiresControl: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 62 0 8 0 -12 1 30 0 ) 					#model: #name 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #updateName ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 9 ) 					#label: 'Name' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 163 0 -9 1 -35 1 ) 					#name: #fontList 					#flags: 15 					#model: #fonts 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #sampleFontSelected ) 					#style: #small 					#selectionType: #checkMark ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -1 0.5 -5 1 0 1 ) 					#name: #fontNumber 					#label: '0 Matching Fonts' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 10 129 162 155 ) 					#model: #encoding 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSelection ) 					#type: #string 					#comboList: #encodingChoices ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 109 ) 					#label: 'Encoding' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 69 49 121 73 ) 					#model: #pixelSize 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #updateSelection 						#valueChangeSelector: #pixelSizeChanged ) 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 23 51 ) 					#label: 'Pixel' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 23 79 ) 					#label: 'Point' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 69 77 121 101 ) 					#model: #pointSize 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #updateSelection 						#valueChangeSelector: #pixelSizeChanged ) 					#type: #number ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 11 32 127 108 ) 					#label: 'Size' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #serif 							#model: #'fontDescriptionHolder serif' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #updateSelection ) 							#label: 'Serif' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 16 ) 							#name: #fixedWidth 							#model: #'fontDescriptionHolder fixedWidth' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #updateSelection ) 							#label: 'Fixed' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 33 ) 							#name: #italic 							#model: #'fontDescriptionHolder italic' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #updateSelection ) 							#label: 'Italic' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 49 ) 							#name: #strikeout 							#model: #'fontDescriptionHolder strikeout' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #updateSelection ) 							#label: 'Strikeout' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 66 ) 							#name: #underline 							#model: #'fontDescriptionHolder underline' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #updateSelection ) 							#label: 'Underline' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -87 1 73 0 -12 1 158 0 ) 						#name: #checkBoxComposite ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} -87 1 51 0 -11 1 74 0 ) 					#model: #'fontDescriptionHolder boldness' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSelection ) 					#type: #object 					#comboList: #boldnessChoices ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -87 1 31 0 ) 					#label: 'Boldness' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 -5 1 0 1 ) 					#model: #help 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -172 1 -28 1 -9 1 -5 1 ) 					#name: #fontListSample 					#flags: 0 					#isOpaque: true 					#model: #fontListSample 					#alignment: #right 					#isReadOnly: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 39 0.5 33 0 -96 1 156 0 ) 					#label: 'Manufacturer' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 47 0.5 56 0 -108 1 124 0 ) 					#model: #manufacturerList 					#menu: #manufacturerMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 45 0.5 130 0 ) 					#model: #includeAnyManufacturer 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateFontManufacturer ) 					#label: 'Include ''*''' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 166 0 33 0 34 0.5 156 0 ) 					#label: 'Family' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 174 0 56 0 24 0.5 124 0 ) 					#model: #familyList 					#menu: #familyMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 173 130 ) 					#model: #includeAnyFamily 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateFontFamily ) 					#label: 'Include ''*''' ) ) ) )</body></methods><methods><class-id>Tools.TextPrintAccessory class</class-id> <category>interface specs</category><body package="Text Attr Editor" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec."	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Print Sample' 			#bounds: #(#Rectangle 384 281 524 330 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Rectangle 27 14 110 37 ) 					#model: #printSettingsSummary 					#label: 'Print' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.TextOptionsEditor class</class-id> <category>interface specs</category><body package="Text Attr Editor" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Text Attributes Viewer' 			#bounds: #(#{Graphics.Rectangle} 78 442 718 913 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 350 0 -10 1 -10 1 ) 					#name: #textView 					#model: #sampleText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateTextHolder ) 					#tabRequiresControl: true ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 347 0 ) 					#name: #notebook 					#model: #majorKeys 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedTab ) 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.FontPolicyInterface class</class-id> <category>interface specs</category><body package="Text Attr Editor" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Font Policy Weights' 			#bounds: #(#{Graphics.Rectangle} 640 512 1160 937 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 388 36 444 62 ) 					#model: #'fontPolicyHolder manufacturerWeight' 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 388 72 444 98 ) 					#model: #'fontPolicyHolder nameWeight' 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 388 108 444 134 ) 					#model: #'fontPolicyHolder pixelSizeWeight' 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 388 144 444 170 ) 					#model: #'fontPolicyHolder serifWeight' 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 272 39 ) 					#label: 'Manufacturer' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 272 75 ) 					#label: 'Name' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 272 111 ) 					#label: 'Pixel Size' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 272 147 ) 					#label: 'Serif' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 392 215 444 242 ) 					#model: #help 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 103 0 159 26 ) 							#model: #'fontPolicyHolder boldnessWeight' 							#type: #number ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 103 36 159 62 ) 							#model: #'fontPolicyHolder encodingWeight' 							#type: #number ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 103 72 159 98 ) 							#model: #'fontPolicyHolder familyWeight' 							#type: #number ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 103 108 159 134 ) 							#model: #'fontPolicyHolder fixedWidthWeight' 							#type: #number ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 'Bold' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 39 ) 							#label: 'Encoding' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 75 ) 							#label: 'Family' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 147 ) 							#label: 'Italic' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 111 ) 							#label: 'Fixed Width' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 103 144 159 168 ) 							#model: #'fontPolicyHolder italicWeight' 							#type: #number ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 60 36 230 208 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 60 0 215 0 0 0 ) 					#name: #ActionButton1 					#model: #flushCache 					#label: 'Flush Cache' 					#defaultable: true ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>