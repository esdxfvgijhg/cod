<?xml version="1.0"?><st-source><!-- Name: RBDynamicRefactoringsNotice: Copyright 2003 - 2015 John Brant, Niall RossThis utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This package was created in the Custom Refactoring project from John Brant's code for dynamic refactorings.  The project extended the UI and the test suite;  the core is relatively unmodified from John's original concept.  It handles cases where polymorphism prevents a static analysis from deducing what changes would be a pure refactoring or not.  The provided dynamic refactoring is for a rename of a method with multiple implementors.  The approach extends easily to other static ChangeMethodNameRefactorings when blocked by multiple implementors, and could be developed to handle a range of other cases.The system wraps the call sites of the statically-unresolvable methods.  The user can run test suites and/or exercise code by hand to call these sites and so let the system resolve the refactoring.  They can also simply invoke operations on the list of call sites to tell the system the right answer - not provably a refactoring but sometimes fastest and safe enough in simple cases or to clear that last hard-to-reach but easy-to-diagnose call site.  Thus the system generates a list of refactoring changes.  The user can further inspect these and edit them, as for a static refactoring, before executing.Tests check correct behaviour in a variety of polymorphically and hierarchically challenging situations.The system fits naturally with the corresponding version of Tools-Refactoring Browser, replacing the static multiple implementors warning review option with the dynamic one (see the UI package's comment re adding a direct invoker if desired).  Becaue the system depends on method wrappers, it is expected always to be a separately loadable and unloadable add-on, never becoming part of the Tools-Refactoring Browser base, since not everyone wishes to have method wrappers in their base IDE by default.  Detailed instruction and cautioning scripts in the UI make users aware of the powers and perils of method wrappers.DbIdentifier: bear73DbTrace: 454544DbUsername: nrossDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'Method Wrapper Base' '') #(#any 'Browser-Refactorings' ''))PackageName: RBDynamicRefactoringsParcel: #('RBDynamicRefactorings')ParcelName: RBDynamicRefactoringsPrerequisiteParcels: #(#('Method Wrapper Base' '') #('Browser-Refactorings' ''))PrintStringCache: (8.1 - 1,nross)Version: 8.1 - 1Date: 7:20:47 AM January 9, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (jan15.1) of January 9, 2015 on January 9, 2015 at 7:20:47 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MethodCallAnalysis</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappers selector ignoring callSiteLookupTable callSites </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBDynamicRefactorings</category><attributes><package>RBDynamicRefactorings</package></attributes></class><comment><class-id>Refactory.Browser.MethodCallAnalysis</class-id><body>I hold call sites and their data.Instance Variables	callSiteLookupTable	&lt;IdentityDictionary of: CompiledCode -&gt; CallSite&gt;  holds data on which methods have been called and from where	callSites	&lt;List of: CallSite&gt;  holds data on which methods have nee called and from where	ignoring	&lt;Boolean&gt;	(usually false) allows the analysis to switch off collecting data while running its own methods	selector	&lt;Symbol&gt;	the selector whose calls are being analysed	wrappers	&lt;OrderedCollection of: MethodCallWrapper&gt;	all the wrapped sites (unwrappable sites will be warned of on install)</body></comment><class><name>MethodCallWrapper</name><environment>Refactory.Browser</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>analysis </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBDynamicRefactorings</category><attributes><package>RBDynamicRefactorings</package></attributes></class><comment><class-id>Refactory.Browser.MethodCallWrapper</class-id><body>Before executing the wrapped call, tell the MethodCallAnalysis about the calling context.Instance Variables	analysis	&lt;MethodCallAnalysis&gt;  holds data on which methods have been called and from where</body></comment><class><name>DynamicRenameMethod</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>analysis oldSelector newSelector model implementors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBDynamicRefactorings</category><attributes><package>RBDynamicRefactorings</package></attributes></class><comment><class-id>Refactory.Browser.DynamicRenameMethod</class-id><body>The dynamic equivalent of RenameMethodRefactoring.Instance Variables	analysis	&lt;MethodCallAnalysis&gt;  holds data on which methods have been called and from where	implementors	&lt;Collection of: RBAbstractClass&gt;	All of the classes that implement this method.	model	&lt;RBRootNamespace&gt;	The model in which to perform the refactoring.	newSelector	&lt;Symbol&gt;	The selector to be changed to.	oldSelector	&lt;Symbol&gt;	The original selector.</body></comment><class><name>CallSite</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc selector receivers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBDynamicRefactorings</category><attributes><package>RBDynamicRefactorings</package></attributes></class><comment><class-id>Refactory.Browser.CallSite</class-id><body>Instance Variables	method	&lt;CompiledCode&gt;  A method that calls the selector of interest.	pc	&lt;Integer&gt;		Location of the call in the method.	receivers	&lt;IdentitySet of: Class&gt;	Those implementors of the selector of interest that have been called from this site.	selector	&lt;Symbol&gt;	The selector of the calling method.</body></comment><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>private</category><body package="RBDynamicRefactorings">callSiteFrom: each in: meth 	^(callSiteLookupTable at: meth ifAbsentPut: [IdentityDictionary new]) 		at: each		ifAbsentPut: [callSites add: (CallSite from: each in: meth)]</body><body package="RBDynamicRefactorings">ignoreSendsWhile: aBlock 	"This doesn't handle multi-processes, but hopefully, it will work good enough. I just need something that ignores sends inside aBlock."	ignoring ifTrue: [^self].	ignoring := true.	aBlock ensure: [ignoring := false]</body><body package="RBDynamicRefactorings">refactoringWarning: aString 	RefactoringWarning raiseSignal: aString</body><body package="RBDynamicRefactorings">setup	callSites := List new.	callSiteLookupTable := IdentityDictionary new.	(BrowserEnvironment new referencesTo: selector) 		methodsDo: [:each | self setupCallSitesFor: each]</body><body package="RBDynamicRefactorings">setupCallSitesFor: aCompiledMethod 	aCompiledMethod callSitesOf: selector		do: [:meth :each | self callSiteFrom: each in: meth]</body><body package="RBDynamicRefactorings">warnOfPolymorphs: classes	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'I must also rename implementors of #';		nextPutAll: selector;		nextPutAll: ' in the following classes:'; cr.	classes do: [:each | stream tab; nextPutAll: each printString; cr].	stream		nextPutAll: 'since they share call sites with the one(s) you wish to rename.'.	self refactoringWarning: stream contents.</body><body package="RBDynamicRefactorings">warnOfUnwrappables: classes	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'It is forbidden to install a wrapper on method #';		nextPutAll: selector;		nextPutAll: ' in the following classes:';		cr.	classes do: [:each | stream tab; nextPutAll: each printString; cr].	stream		nextPutAll: 'If none of the above are called by code that also calls the #' , selector , ' implementor(s) that you intend'; cr;		nextPutAll: 'to rename, then it is safe to proceed.  Otherwise abort, or check the result of applying the refactorings.'.	self refactoringWarning: stream contents.</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>accessing</category><body package="RBDynamicRefactorings">allCallSites	^callSites</body><body package="RBDynamicRefactorings">allCallSitesOf: aClassCollection	^callSites select: [:each | each sendsMessageToAnyOf: aClassCollection]</body><body package="RBDynamicRefactorings">implementors	^(BrowserEnvironment new implementorsOf: selector) classes</body><body package="RBDynamicRefactorings">polymorphicMethodsTo: someBehaviors	| classes index |	classes := OrderedCollection withAll: someBehaviors.	index := 1.	[index &lt;= classes size] whileTrue: 		[callSites do: 			[:each | 			(each sendsMessageTo: (classes at: index)) ifTrue: 				[classes addAll: (each receivers reject: [:cls | classes includes: cls])]].			index := index + 1].	someBehaviors size = classes size ifFalse:		[self warnOfPolymorphs: (classes reject: [:each | someBehaviors includes: each])].	^classes asSet</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>initialize-release</category><body package="RBDynamicRefactorings">for: aSelector 	selector := aSelector.	ignoring := false.	self setup</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>wrappers</category><body package="RBDynamicRefactorings">addCallTo: aClass from: aCompiledCode at: anInteger	(self callSiteFrom: anInteger in: aCompiledCode) addSender: aClass</body><body package="RBDynamicRefactorings">install	| unwrappables |	wrappers := OrderedCollection new.	unwrappables := OrderedCollection new.	self implementors do:		[:each || wrapper |		wrapper := MethodCallWrapper on: selector inClass: each.		wrapper isNil			ifFalse: [wrappers add: wrapper]			ifTrue: [unwrappables add: each]].	unwrappables isEmpty ifFalse: [self warnOfUnwrappables: unwrappables].	wrappers do: [:each | each analysis: self].	wrappers do: [:each | each install].</body><body package="RBDynamicRefactorings">uninstall	wrappers isNil ifTrue: [^self].	wrappers do: [:each | each uninstall].	wrappers := nil</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis class</class-id> <category>instance creation</category><body package="RBDynamicRefactorings">for: aSelector 	^(self new)		for: aSelector;		yourself</body></methods><methods><class-id>Refactory.Browser.MethodCallWrapper</class-id> <category>initialize-release</category><body package="RBDynamicRefactorings">analysis: aMethodCallAnalysis	analysis := aMethodCallAnalysis</body></methods><methods><class-id>Refactory.Browser.MethodCallWrapper</class-id> <category>evaluating-before-after</category><body package="RBDynamicRefactorings">beforeMethod	analysis ignoreSendsWhile: 			[| context |			context := self sendingContext.			context isNil ifTrue: [^self].			analysis 				addCallTo: mclass				from: context method				at: context pc]</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethod</class-id> <category>transformations</category><body package="RBDynamicRefactorings">addNewImplementors	implementors do: 			[:each | 			| modelClass |			modelClass := model classFor: each.			(modelClass parseTreeFor: oldSelector) ifNotNil: 					[:tree | 					tree renameSelector: newSelector andArguments: tree arguments.					tree = (modelClass parseTreeFor: newSelector) 						ifFalse: 							[modelClass compile: tree newSource								withAttributesFrom: (modelClass methodFor: oldSelector)]]]</body><body package="RBDynamicRefactorings">computePolymorphicImplementors	"Find any polymorphs of the implementor(s) to be renamed that are called at any of the same call-sites, so must be renamed (or the relevant call site(s) rewritten by hand)."	implementors := analysis polymorphicMethodsTo: implementors.</body><body package="RBDynamicRefactorings">removeOldImplementors	"Niall Ross: first time round, the oldSelector is sure to be defined by every implementor (page 1 will have ensured this), but if the user iterates back and forth between the call site analysis and the generated refactorings list (pages 2 and 3) then we must check whether it has already been removed because the user applied a prior iteration.  (This is not an issue for the other refactoring parts of a dynamic rename but the remove needs an explicit check.)"	implementors do:		[:each || modelClass |		modelClass := model classFor: each.		(modelClass directlyDefinesMethod: oldSelector)			ifTrue: [modelClass removeMethod: oldSelector]]</body><body package="RBDynamicRefactorings">renameAround: aBlock 	self setupAnalysis.	aBlock ensure: [self tearDownAnalysis]</body><body package="RBDynamicRefactorings">renameMethods	self initializeModel.	self computePolymorphicImplementors.	self addNewImplementors.	self renameSends.	self updateNewImplementors.	self removeOldImplementors</body><body package="RBDynamicRefactorings">renameSends	| callSites |	callSites := (analysis allCallSitesOf: implementors) 				groupedBy: [:each | each homeMethod].	callSites 		keysAndValuesDo: [:key :value | self renameSendsAt: value in: key]</body><body package="RBDynamicRefactorings">renameSendsAt: callSiteCollection in: aCompiledMethod 	| selector class nodes modelClass tree |	class := callSiteCollection first methodClass.	selector := callSiteCollection first selector.	selector isNil ifTrue: [^self].	modelClass := model classFor: class.	tree := modelClass parseTreeFor: selector.	tree isNil ifTrue: [^self].	nodes := self allNodesIn: tree at: callSiteCollection.	nodes do: 			[:each | 			each replaceWith: (RBMessageNode 						receiver: each receiver						selector: newSelector						arguments: each arguments)].	modelClass compile: tree newSource		withAttributesFrom: (modelClass methodFor: selector)</body><body package="RBDynamicRefactorings">updateNewImplementors	"We may have replaced some message sends in the methods that we are renaming. If so, just copy the methods again."	self addNewImplementors</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethod</class-id> <category>accessing</category><body package="RBDynamicRefactorings">allCallSites	^analysis allCallSites</body><body package="RBDynamicRefactorings">allImplementors	^analysis implementors</body><body package="RBDynamicRefactorings">changes	^model changes</body><body package="RBDynamicRefactorings">implementors	^implementors</body><body package="RBDynamicRefactorings">implementors: aClassCollection 	implementors := Set withAll: aClassCollection</body><body package="RBDynamicRefactorings">model	^model</body><body package="RBDynamicRefactorings">newSelector	^newSelector</body><body package="RBDynamicRefactorings">newSelector: aSymbol	newSelector := aSymbol</body><body package="RBDynamicRefactorings">oldSelector	^oldSelector</body><body package="RBDynamicRefactorings">oldSelector: aSymbol 	oldSelector := aSymbol.	self updateAnalysis</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethod</class-id> <category>static transformations</category><body package="RBDynamicRefactorings">renameAtCallSite: aCallSite	analysis addCallTo: (implementors detect: [:each | true]) from: aCallSite method at: aCallSite pc.</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethod</class-id> <category>private</category><body package="RBDynamicRefactorings">allNodesIn: aRBMethodNode at: callSiteCollection 	| nodes |	nodes := IdentitySet new.	callSiteCollection do: 			[:each | 			(each messageSendNodeIn: aRBMethodNode) 				ifNotNil: [:node | node selector = oldSelector ifTrue: [nodes add: node]]].	^nodes</body><body package="RBDynamicRefactorings">initializeModel	model := RBRootNameSpace new.	model description: 'Dynamic rename ' , oldSelector , ' to ' , newSelector</body><body package="RBDynamicRefactorings">setupAnalysis	analysis := MethodCallAnalysis for: oldSelector.	analysis install</body><body package="RBDynamicRefactorings">tearDownAnalysis	analysis uninstall</body><body package="RBDynamicRefactorings">updateAnalysis	analysis		uninstall;		for: oldSelector</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethod</class-id> <category>initialize-release</category><body package="RBDynamicRefactorings">initialize	analysis := MethodCallAnalysis new</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethod class</class-id> <category>instance creation</category><body package="RBDynamicRefactorings">new	^(super new)		initialize;		yourself</body><body package="RBDynamicRefactorings">rename: oldSymbol to: newSymbol in: implementingClasses around: aBlock 	^(self new)		oldSelector: oldSymbol;		newSelector: newSymbol;		implementors: implementingClasses;		renameAround: aBlock;		renameMethods;		yourself</body></methods><methods><class-id>Refactory.Browser.CallSite</class-id> <category>accessing</category><body package="RBDynamicRefactorings">addSender: aClass 	receivers add: aClass</body><body package="RBDynamicRefactorings">homeMethod	^method homeMethod</body><body package="RBDynamicRefactorings">messageSendNodeIn: aRBMethodNode 	| node |	node := aRBMethodNode bestNodeFor: self sourceInterval.	^(node isNil or: [node isMessage not]) ifTrue: [nil] ifFalse: [node]</body><body package="RBDynamicRefactorings">method	^method</body><body package="RBDynamicRefactorings">methodClass	^self homeMethod mclass</body><body package="RBDynamicRefactorings">parseTree	^self homeMethod parseTreeFor: self selector</body><body package="RBDynamicRefactorings">pc	^pc</body><body package="RBDynamicRefactorings">receivers	^receivers</body><body package="RBDynamicRefactorings">selector	^selector</body><body package="RBDynamicRefactorings">source	^[self methodClass sourceCodeAt: self selector] on: Error		do: [:ex | ex return: 'No source']</body><body package="RBDynamicRefactorings">sourceInterval	^self selector = self unknownSelector 		ifTrue: [1 to: 0]		ifFalse: [method sourceIntervalFor: pc]</body></methods><methods><class-id>Refactory.Browser.CallSite</class-id> <category>initialize-release</category><body package="RBDynamicRefactorings">initialize	receivers := IdentitySet new</body><body package="RBDynamicRefactorings">method: aCompiledCode 	method := aCompiledCode.	selector := self methodClass selectorAtMethod: self homeMethod				ifAbsent: [self unknownSelector]</body><body package="RBDynamicRefactorings">pc: anInteger	pc := anInteger</body></methods><methods><class-id>Refactory.Browser.CallSite</class-id> <category>testing</category><body package="RBDynamicRefactorings">hasBeenExecuted	^receivers notEmpty</body><body package="RBDynamicRefactorings">sendsMessageTo: aClass 	^receivers includes: aClass</body><body package="RBDynamicRefactorings">sendsMessageToAnyOf: aClassCollection 	^aClassCollection anySatisfy: [:each | self sendsMessageTo: each]</body></methods><methods><class-id>Refactory.Browser.CallSite</class-id> <category>printing</category><body package="RBDynamicRefactorings">printOn: aStream 	aStream		nextPutAll: self methodClass fullName;		nextPutAll: '&gt;&gt;';		nextPutAll: self selector;		nextPutAll: ' [';		print: pc;		nextPut: $]</body></methods><methods><class-id>Refactory.Browser.CallSite</class-id> <category>private</category><body package="RBDynamicRefactorings">unknownSelector	^#' unknown '</body></methods><methods><class-id>Refactory.Browser.CallSite class</class-id> <category>instance creation</category><body package="RBDynamicRefactorings">from: pcInteger in: aCompiledMethod 	^(self new)		method: aCompiledMethod;		pc: pcInteger;		yourself</body><body package="RBDynamicRefactorings">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.Browser.CallSite class</class-id> <category>accessing</category><body package="RBDynamicRefactorings">sortBlock	^	[:a :b | 	a methodClass fullName &lt; b methodClass fullName or: 			[a methodClass = b methodClass and: 					[a selector &lt; b selector or: [a selector = b selector and: [a pc &lt; b pc]]]]]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>RefactoringBrowser</category><body package="RBDynamicRefactorings">callSitesOf: aSelector do: aBlock 	"Iterate over all call sites of aSelector in the method. For each call site evaluate the block with the method/block 	sending the message as well as the pc after the message send. This will be the pc that is displayed in the debugger."	self withAllBlockMethodsDo: 			[:meth | 			| scanner selector |			scanner := InstructionStream on: meth.			scanner scanFor: 					[:byte | 					selector := scanner peekForSelector.					selector == aSelector 						ifTrue: [aBlock value: meth value: (scanner nextPC: scanner pc)].					false]]</body><body package="RBDynamicRefactorings">sourceIntervalFor: anInteger 	| homeMethod methodHolder index intervals |	homeMethod := self homeMethod.	methodHolder := homeMethod sourceInfoIfCached.	methodHolder == nil 		ifTrue: 			[methodHolder := self compilerClass new 						parse: homeMethod getSource						in: homeMethod mclass						environment: self environment						allowReceiver: homeMethod usuallyAllowsReceiver						noPattern: homeMethod usuallyHasSelector not						notifying: nil.			homeMethod cacheSourceInfo: methodHolder].	index := homeMethod withAllBlockMethods identityIndexOf: self.	intervals := methodHolder sourceMap at: index.	^(intervals reverse detect: [:each | each key &lt; anInteger]		ifNone: [nil -&gt; nil]) value</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class></st-source>