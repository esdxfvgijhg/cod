<?xml version="1.0"?><st-source><!-- Name: FileOut30Notice: Copyright 2000-2014 Cincom Systems, Inc.  All rights reserved.Comment: This goodie provides the ability to load and save code in a variety of formats other than the standard VisualWorks XML and Chunk formats: VisualWorks 3.0 file-out format, Squeak format, VASmalltalk .st and .app format, Dolphin .pac format.	- File-in formats are automatically recognized;  look at implementors and senders of #canFormatStream: to see the rules. To set a namespace from which to resolve unqualified names, choose it in the Default File-in Namespace tab in the VisualWorks settings.	- To set a file-out format, choose it in the Source tab in the VisualWorks settings.The "VW3.0 non-Envy" setting will create file-outs compatible with VisualWorks 3.0. Note that if you save a parcel while this 3.0 File-Out option is set, that parcel will have its source also saved in VisualWorks 3.0 format.  The "VW 3.0 Envy generic" setting differs only in method deletion (possible when change sets or package differences are filed-out); Envy-synching requires a different protocol in that case if the image is not to be left inconsistent with the database.  File-in from either VW 3.0 ignores both protocols and uses standard chunk, resolving unqualified class names in the default file-in namespace.  (The non-default VW 3.0 Envy setting	System genericFormat: trueshould be used - but see remarks after "VASmalltalk" below).The remaining formats are provided for compatibility with other dialects, are not fully supported, lack documentation, and quite possibly have problems in edge cases. These formats allow you to read or write package formats from some other dialects with as much information as possible preserved between them. For all of these formats there are some conventions observed.  - A prerequisite of the form <Name><Dialect>Port will be transformed appropriately on file-in or file-out, where dialect is one of VW, VA, or Dolphin. So, for example, FooVWPort would become FooDolphinPort if filed out in Dolphin format.  - On file-in, at least some properties are preserved. The most notable example is ENVY prerequisites. On file-in of an ENVY application, any prerequisites whose names did not correspond to packages in the image are preserved in the envyPrerequisites variable and will be added back into the prerequisite list on file-out in ENVY format.  - Note that these formats do not ensure valid syntax in the target dialect. For example, an ENVY application cannot have whitespace in its name, and a hyphen in a Dolphin method category indicates a hierarchical category. The system will attempt to compensate for some of these known differences, but in general you are responsible for writing portable code.  - These have been tested primarily for reading/writing complete packages/applications. Use for code fragments (e.g. differences between packages) may or may not work properly.Squeak format is a format roughly compatible with Squeak file-out format. Note that it doesn't attempt to handle dialect differences such as the conversion between underscore/left arrow and :=. This was contributed by Roel Wuyts.VASmalltalk-compatible format is a format which can read and write VisualAge .app format files. This can file out a complete Store package into a VASmalltalk or VisualAge application. Namespace information will be removed, and as much package information as possible will be preserved. It is also possible to file out a complete bundle with this format and get a single file which can recreate all of the component packages as applications (note that this does not at the moment attempt to create configuration maps or version the resulting code). Smaller units - classes or methods - can also be filed-out. (This format has been tested against versions of VASmalltalk and VisualAge. It may also work with little or no modification for VisualWorks/ENVY code with the default	System genericFormat: falsesetting. However file-outs from a VW3.0 Envy image with this setting are not recognised by this format's #canFormatStream: method at this time.)Dolphin 4.0-compatible format is a format which is compatible with the .pac files of Dolphin Smalltalk. These files should be directly loadable into a Dolphin image as packages.Because this package contains several #canFormatStream: implementations, some of which scan the whole file looking for a diagnostic expression, it must avoid having such a #canFormatStream: method for another dialect accidentally match its own source code.  Having a safe order of presentation of SourceFileFormat subclasses in #formatForStream:, both in the overridden and the overriding implementations, is key to this.DbIdentifier: bear73DbTrace: 424139DbUsername: nrossDbVersion: 8.0 - 1DevelopmentPrerequisites: #(#(#any 'SUnit' '') #(#any 'Browser-ConfigurableFormatter' '') #(#any 'Visibility-Bindings' '') #(#any 'Tools-Settings-VW' ''))PackageName: FileOut30Parcel: #('FileOut30')ParcelName: FileOut30PrerequisiteDescriptions: #(#(#name 'SUnit') #(#name 'Browser-ConfigurableFormatter') #(#name 'Visibility-Bindings' #componentType #package) #(#name 'Tools-Settings-VW' #componentType #package))PrerequisiteParcels: #(#('SUnit' '') #('Browser-ConfigurableFormatter' '') #('Visibility-Bindings' '') #('Tools-Settings-VW' ''))PrintStringCache: (8.0 - 1,nross)Version: 8.0 - 1Post-Load Block: 	[ :pkg | UI.UISettings addPreferenceSection: #addFileOut30To:development:runtime:]Post-Unload Block: 	[UI.UISettings removePreferenceSection: #addFileOut30To:development:runtime:]Date: 10:12:56 AM March 7, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (mar14.1) of March 7, 2014 on March 7, 2014 at 10:12:56 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SqueakCompatibility</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>FileOut30</category><attributes><package>FileOut30</package></attributes></name-space><name-space><name>DolphinCompatibility</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>FileOut30</category><attributes><package>FileOut30</package></attributes></name-space><name-space><name>VisualAgeCompatibility</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>FileOut30</category><attributes><package>FileOut30</package></attributes></name-space><class><name>FilteringFileFormat</name><environment>Kernel</environment><super>Kernel.ChunkSourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filteredStatements filteredClasses filteredClassCategories filteredProtocols filteredMethods environment shouldBeVerbose </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><comment><class-id>Kernel.FilteringFileFormat</class-id><body>FilteringFileFormat allows statements, classes, classes in a category, methods, methods in a protocol to all be filtered as the fileIn is happening. It can also push code into a namespace as it's compiling and use the DefaultPackageNamespaces as it does so.  If no format matches a suppied file of source, FilteringFileFormat is tried;  this is the only way it, as opposed to a subclass or sibling, can be the chosen format.To use, do something like the following:filer := SourceFileFormat formatForStream: stream.filer environment: Seaside.filer filteredClassCategories add: #'Seaside-Platform'.filer filteredProtocols add: #'*seaside2-squeak'.filer fileInFrom: streamInstance Variables	environment	&lt;Object&gt;	description of environment	filteredClassCategories	&lt;Collection&gt;	description of filteredClassCategories	filteredClasses	&lt;Collection&gt;	description of filteredClasses	filteredMethods	&lt;Collection&gt;	description of filteredMethods	filteredProtocols	&lt;Collection&gt;	description of filteredProtocols	filteredStatements	&lt;Collection&gt;	description of filteredStatements</body></comment><class><name>ForeignPackageFileFormat</name><environment>Kernel</environment><super>Kernel.FilteringFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldPackage package storePackage currentCategory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><comment><class-id>Kernel.ForeignPackageFileFormat</class-id><body>Abstract superclass for sources that attempt to write or read source of other dialects allowing for those dialects' CM constructs.</body></comment><class><name>VisualAgeApplicationSourceFileFormat</name><environment>VisualAgeCompatibility</environment><super>Kernel.ForeignPackageFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><comment><class-id>VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat</class-id><body>This code was initially devised to read in entire applications.  If the first chunk is a VA app declaration, optionally preceeded by a comment chunk, e.g.	"Latest refactoring test add-ons"!	Application create: #RBCustomRefactoringTests with:		(#(MethodWrappers RBCustomRefactoringUI RefactoryTestingApp)			collect: [:each | Smalltalk at: each ifAbsent: [				Application errorPrerequisite: #RBCustomRefactoringTests missing: each]])!it will create a package from the expression and make it the current package during the file-in.  If you have just filed out classes or methods from VASmalltalk, not an entire app, in VA-specific format, e.g.	!RBCustomRefactoringTests publicMethods !and etc., the code will simply be filed in.  (An alternative approach to filing in specific class and method fileouts from VASmalltalk is to set	System genericFormat: truebefore filing them out.)</body></comment><class><name>FakeSmalltalkDictionaryForPrerequisites</name><environment>VisualAgeCompatibility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><comment><class-id>VisualAgeCompatibility.FakeSmalltalkDictionaryForPrerequisites</class-id><body>VisualAge package format includes Smalltalk at: expressions to determine whether applications exist in the image. We need to intercept these and translate the references to packages, so we use this class to replace the normal Smalltalk dictionary and do package lookups instead.</body></comment><class><name>ForeignPackage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name comment version classNames methodNames globalNames binaryGlobalNames prerequisites </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>Package</name><environment>DolphinCompatibility</environment><super>Kernel.ForeignPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourceNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>SqueakTests</name><environment>SqueakCompatibility</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SqeakOuter</category><attributes><package>FileOut30</package></attributes></class><class><name>DolphinPackageSourceFileFormat</name><environment>DolphinCompatibility</environment><super>Kernel.ForeignPackageFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>MissingClassCategoryReader</name><environment>Kernel</environment><super>Kernel.ClassCategoryReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasComplainedAboutMissingClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FileOut30</category><attributes><package>FileOut30</package></attributes></class><class><name>OldChunkSourceFileFormat</name><environment>Kernel</environment><super>Kernel.FilteringFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storeFileOutPreference </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><comment><class-id>Kernel.OldChunkSourceFileFormat</class-id><body>OldChunkSourceFileFormat handles code in Smalltalk-80 style source code format without namespaces for non-Envy VW3 or earlier.  VW3 non-Envy and VW3 Envy (genericFormat) are identical except when removing methods.  As this makes no difference when filing in from VW3 to VW7, we always use the more specific subclass for file-in.  Select the class appropriate to the intended target when filing out.</body></comment><class><name>VW3EnvySourceFileFormat</name><environment>Kernel</environment><super>Kernel.OldChunkSourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FileOut30</package></attributes></class><comment><class-id>Kernel.VW3EnvySourceFileFormat</class-id><body>VW3 non-Envy and VW3 Envy (genericFormat) are identical except when removing methods.  As this makes no difference when filing in from VW3 to VW7, we always use the more specific class for file-in.  Select the class appropriate to the intended target when filing out.As file-outs from VW7 will have that release as their first line, even if written in VW3 format, they will not be matched by this class' #canFormatStream: method if filed in again to VW7 (unless hand-edited to change 7 to 3 in the first line).  As there seems little reason to file out code from VW7 in VW3 format and then attempt to file it back into VW7, and making the first line say it had been filed out from VW3 when it was filed out from VW7 in VW3 format could be confusing, this edit is left for the user to do in the unlikely event that they need it.</body></comment><class><name>SqueakMethodFormatter</name><environment>SqueakCompatibility</environment><super>Refactory.Browser.RBConfigurableFormatter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SqueakOuter</category><attributes><package>FileOut30</package></attributes></class><comment><class-id>SqueakCompatibility.SqueakMethodFormatter</class-id><body>Format methods according to Squeak standards: remove namespace information from classes.Squeak used to use underscore for assignment, e.g.	coll _ OrderedCollection newbut by default Pharo has the ability to read that turned off (it can be turned on if needed) and all Squeak versions in use can accept the more usual assignment string	coll := OrderedCollection newso we no longer override acceptAssignmentNode: to substitute _ for :=.</body></comment><class><name>SqueakCommentScanner</name><environment>SqueakCompatibility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>EnvyPrerequisite</name><environment>VisualAgeCompatibility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>DolphinMethodCategorizationScanner</name><environment>DolphinCompatibility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class methodName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>Application</name><environment>VisualAgeCompatibility</environment><super>Kernel.ForeignPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>envyPrerequisites </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>DolphinCategoryScanner</name><environment>DolphinCompatibility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>FileOut30</package></attributes></class><class><name>SqueakChangeSetFileFormat</name><environment>SqueakCompatibility</environment><super>Kernel.OldChunkSourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>acronym timeStampString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FileOut30</category><attributes><package>FileOut30</package></attributes></class><class><name>TestClass</name><environment>SqueakCompatibility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>added for testing </inst-vars><class-inst-vars>Test ClassInstanceVariables </class-inst-vars><imports></imports><category>SqueakOuter</category><attributes><package>FileOut30</package></attributes></class><comment><class-id>SqueakCompatibility.TestClass</class-id><body>Class used for unit testing the Squeak file-out code.</body></comment><shared-variable><name>Smalltalk</name><environment>VisualAgeCompatibility</environment><private>false</private><constant>false</constant><category>(none)</category><initializer>FakeSmalltalkDictionaryForPrerequisites new</initializer><attributes><package>FileOut30</package></attributes></shared-variable><shared-variable><name>ForTests</name><environment>SqueakCompatibility.TestClass</environment><private>false</private><constant>false</constant><category>forTests</category><initializer>Array new: 5</initializer><attributes><package>FileOut30</package></attributes></shared-variable><shared-variable><name>Added</name><environment>SqueakCompatibility.TestClass</environment><private>false</private><constant>false</constant><category>forTests</category><initializer>Array new: 5</initializer><attributes><package>FileOut30</package></attributes></shared-variable><methods><class-id>Kernel.FilteringFileFormat</class-id> <category>accessing</category><body package="FileOut30">environment	^environment</body><body package="FileOut30">environment: anObject	environment := anObject</body><body package="FileOut30">filteredClassCategories	^filteredClassCategories</body><body package="FileOut30">filteredClassCategories: anObject	filteredClassCategories := anObject</body><body package="FileOut30">filteredClasses	^filteredClasses</body><body package="FileOut30">filteredClasses: anObject	filteredClasses := anObject</body><body package="FileOut30">filteredMethods	^filteredMethods</body><body package="FileOut30">filteredMethods: anObject	filteredMethods := anObject</body><body package="FileOut30">filteredProtocols	^filteredProtocols</body><body package="FileOut30">filteredProtocols: anObject	filteredProtocols := anObject</body><body package="FileOut30">filteredStatements	^filteredStatements</body><body package="FileOut30">filteredStatements: anObject	filteredStatements := anObject</body><body package="FileOut30">shouldBeVerbose	^shouldBeVerbose</body><body package="FileOut30">shouldBeVerbose: anObject	shouldBeVerbose := anObject</body></methods><methods><class-id>Kernel.FilteringFileFormat</class-id> <category>reading</category><body package="FileOut30">fileInContextChangeFrom: aStream 	| chunk scan |	chunk := self nextChunkFrom: aStream.	scan := self evaluate: chunk allowReceiver: false.	(self shouldFilterContext:  chunk) ifTrue: [scan := scan asMissingClassReader].	^scan scanFrom: aStream using: self</body><body package="FileOut30">fileInFrom: aStream 	^self readingDo: 			[			[[aStream atEnd] whileFalse: 					[aStream skipSeparators.					(aStream peekFor: $!) 						ifTrue: [self fileInContextChangeFrom: aStream]						ifFalse: [self executingDo: [self fileInStatementFrom: aStream]]]] 					ensure: [aStream close]]</body><body package="FileOut30">fileInStatementFrom: aStream	| value chunk |	chunk := self nextChunkFrom: aStream.	(self shouldFilterStatement: chunk) ifTrue: [^nil].	value := self evaluate: chunk allowReceiver: true.	((value isKindOf: Class) and: [self isClassDefinitionStatement: chunk forClassNamed: value name]) ifTrue: [value relocateTo: environment].	SourceFileManager default logChange: chunk.	^value</body></methods><methods><class-id>Kernel.FilteringFileFormat</class-id> <category>private</category><body package="FileOut30">compile: string class: aClass protocol: aProtocol	| compiler parseTree selector |	(self shouldFilterClass: aClass instanceBehavior name) ifTrue: [^self].	(self shouldFilterProtocol: aProtocol) ifTrue: [^self].	compiler := aClass compilerClass new				from: string				class: aClass				context: nil				notifying: nil.	parseTree := compiler				translate: string readStream				noPattern: false				ifFail: [nil].	parseTree ifNotNil: [selector := parseTree selector].	(self shouldFilterClass: aClass instanceBehavior name method: selector) ifTrue: [^self].	^aClass		compile: string		classified: aProtocol		notifying: nil		attributes: nil		environment: ((environment isVisibleIn: aClass environment) ifFalse: [environment])</body><body package="FileOut30">compressedStatement: aStatement	| compressedStatement previous |	previous := nil.	compressedStatement := String new writeStream.	aStatement do: [:each |		(each isSeparator and: [previous isSeparator]) ifFalse:			[previous := each.			each isSeparator ifTrue: [compressedStatement nextPut: $ ] ifFalse: [compressedStatement nextPut: each]]].	^compressedStatement contents</body><body package="FileOut30">evaluate: statement allowReceiver: allowReceiver	^Object evaluatorClass new 		evaluate: statement		in: nil		allowReceiver: allowReceiver		receiver: nil		environment: environment		notifying: nil		ifFail: [nil]</body><body package="FileOut30">executingDo: aBlock	| result |	Cursor execute showWhile: [result := aBlock value].	^result</body><body package="FileOut30">extractClassNameFromClassDefinition: aStatement	^(aStatement readStream upTo: $#; upToSeparator) trimBlanks</body><body package="FileOut30">readingDo: aBlock	| result |	Cursor read showWhile: [result := aBlock value].	^result</body></methods><methods><class-id>Kernel.FilteringFileFormat</class-id> <category>testing</category><body package="FileOut30">isClassDefinitionStatement: aStatement forClassNamed: className	| compressedStatement previous |	previous := nil.	compressedStatement := String new writeStream.	aStatement do: [:each |		(each isSeparator and: [previous isSeparator]) ifFalse:			[previous := each.			each isSeparator ifTrue: [compressedStatement nextPut: $ ] ifFalse: [compressedStatement nextPut: each]]].	compressedStatement := compressedStatement contents.	^self isCompressedClassDefinitionStatement: compressedStatement forClassNamed: className</body><body package="FileOut30">isCompressedClassDefinitionStatement: aStatement forClassCategoryNamed: categoryName	^'* subclass: #* instanceVariableNames: ''*'' classVariableNames: ''*'' poolDictionaries: ''*'' category: ''', categoryName, '''*' match: aStatement</body><body package="FileOut30">isCompressedClassDefinitionStatement: aStatement forClassNamed: className	^'* subclass: #', className, ' instanceVariableNames: ''*'' classVariableNames: ''*'' poolDictionaries:*' match: aStatement</body><body package="FileOut30">isCompressedClassReceiverStatement: aStatement forClassNamed: className	^className, ' *' match: aStatement</body><body package="FileOut30">isInitializeStatement: aStatement forClassNamed: className	^(className, ' initialize') = aStatement</body><body package="FileOut30">shouldComplainAboutMissingClasses	^false</body><body package="FileOut30">shouldFilterClass: className	^filteredClasses includes: className</body><body package="FileOut30">shouldFilterClass: className method: methodName	^filteredMethods includes: (className -&gt; methodName)</body><body package="FileOut30">shouldFilterContext:  aStatement	^filteredClasses anySatisfy: [:className | '*', className, '*' match: aStatement ]</body><body package="FileOut30">shouldFilterProtocol: protocolName	^filteredProtocols includes: protocolName</body><body package="FileOut30">shouldFilterStatement: aStatement	| compressedStatement |	(filteredStatements includes: aStatement) ifTrue: [^true].	compressedStatement := self compressedStatement: aStatement.	(filteredClasses anySatisfy: [:className | self isCompressedClassDefinitionStatement: compressedStatement forClassNamed: className]) ifTrue: [^true].	(filteredClassCategories anySatisfy: [:categoryName | self isCompressedClassDefinitionStatement: compressedStatement forClassCategoryNamed: categoryName])		ifTrue: [ | className |			className := self extractClassNameFromClassDefinition: aStatement.			filteredClasses add: className asSymbol.			^true].	(filteredClasses anySatisfy: [:className | self isCompressedClassReceiverStatement: compressedStatement forClassNamed: className]) ifTrue: [^true].	^filteredClasses anySatisfy: [:className | self isInitializeStatement: aStatement forClassNamed: className]</body></methods><methods><class-id>Kernel.FilteringFileFormat</class-id> <category>initialize</category><body package="FileOut30">initialize	super initialize.	shouldBeVerbose := true.	environment := self class fileInEnvironment.	filteredStatements := OrderedCollection new.	filteredClasses := OrderedCollection new.	filteredClassCategories := OrderedCollection new.	filteredProtocols := OrderedCollection new.	filteredMethods := OrderedCollection new</body></methods><methods><class-id>Kernel.ForeignPackageFileFormat</class-id> <category>actions</category><body package="FileOut30">bundleNamed: name structure: structure on: aStream	"We don't convert bundles into anything useful at the moment"</body><body package="FileOut30">bundleProperties: aDictionary for: aBundleModel on: aStream 	"We don't do anything useful with bundles at the moment"</body><body package="FileOut30">classAttributeNames	^self subclassResponsibility.</body><body package="FileOut30">classAttributesFor: aClass 	self subclassResponsibility.</body><body package="FileOut30">classNameFor: aClass	"Answer how the class should be represented in the source file."	^aClass name</body><body package="FileOut30">closeMethodGroup: aFileStream	aFileStream nextPutAll: ' !'; cr.</body><body package="FileOut30">initializeObject: anObject on: aStream	"Only initialize classes for non-vw systems"	anObject isBehavior ifTrue: [		aStream cr; cr; nextChunkPut: (anObject name , ' initialize')].</body><body package="FileOut30">methodSelector: aSymbol body: aString class: aClass attributes: attributes on: aFileStream for: aSourceFileManager 	aFileStream cr.	aFileStream nextChunkPut: aString.	aFileStream nextPutAll: ' !'.	self 		printCategory: currentCategory		for: aSymbol		in: aClass		on: aFileStream.	self 		printCategoryChunk: currentCategory		for: aClass		on: aFileStream.</body><body package="FileOut30">storeClassDefinition: object on: aStream withAttributes: attributes named: attributeNames	| str |	object isBehavior ifFalse: [^self].	str := WriteStream on: (String new: 300).	str nextPutAll: object superclass displayString.	attributeNames with: attributes		do: 			[:symbol :value | 			str nextPutAll: symbol.			str print: value.			str cr].	aStream cr; cr; nextChunkPut: str contents.</body><body package="FileOut30">storeDefinition: object on: aStream 	| |	object isBehavior ifFalse: [^self].	self 		storeClassDefinition: object		on: aStream		withAttributes: (self classAttributesFor: object)		named: self classAttributeNames.</body><body package="FileOut30">timeStamp: aStream	"Dolphin wants the first chunk to be the package definition, so write the timestamp as a comment, not as a separate chunk"	| tempStream |	tempStream := WriteStream on: (String new: 16).	SystemUtils timeStamp: tempStream.	aStream 		nextPut: $";		nextPutAll: tempStream contents;		nextPut: $";		cr.</body></methods><methods><class-id>Kernel.ForeignPackageFileFormat</class-id> <category>file-in</category><body package="FileOut30">evaluateAsDoit: aString 	| result |	result := self evaluateExpression: aString.	SourceFileManager default logChange: aString.	^result</body><body package="FileOut30">evaluateChunksOf: aStream 	[aStream atEnd] whileFalse: 			[| chunk usesScanner |			aStream skipSeparators.			usesScanner := aStream peekFor: $!.			chunk := self nextChunkFrom: aStream.			usesScanner 				ifTrue: [self evaluateWithScanner: chunk in: aStream]				ifFalse: [self evaluateAsDoit: chunk]]</body><body package="FileOut30">evaluateExpression: aString 	^Object evaluatorClass new 		evaluate: aString		in: nil		allowReceiver: false		receiver: nil		environment: self fileInEnvironment		notifying: nil		ifFail: [nil]</body><body package="FileOut30">evaluateWithScanner: aString in: aStream	| result |	result := self evaluateExpression: aString.	^result scanFrom: aStream using: self.</body><body package="FileOut30">fileInFrom: aStream 		"If this is from VW, then the first chunk will be a lead comment, which we should ignore."	(aStream peek = $") ifTrue: [aStream nextChunk].	"Check for the presence of Store"	Smalltalk at: 'Store' ifAbsent: [self error: 'Cannot file in a package-based source format without Store loaded'].	self readPackageFrom: aStream.	oldPackage := Store.Registry isCurrentNull ifTrue: [nil] ifFalse: [Store.Registry currentPackage].	Store.Registry currentPackage: self storePackage.	[		Cursor read 			showWhile: [[self evaluateChunksOf: aStream] ensure: [aStream close]].	] ensure: [		Store.Registry currentPackage: oldPackage].</body><body package="FileOut30">readPackageFrom: aStream	"For VA We expect something of the formApplication create: #GlorpCore with:    (#( GlorpUnitOfWork)        collect: [:each | Smalltalk at: each ifAbsent: [            Application errorPrerequisite: #GlorpCore missing: each]])!For Dolphin, something much longer, but starting with| package |package := Package name: 'Glorp-Core'.package paxVersion: 0;	basicComment: ''."	| chunk |	chunk := self nextChunkFrom: aStream.	package := self evaluateAsDoit: chunk.	(package isKindOf: ForeignPackage) ifFalse: [		package := nil].</body><body package="FileOut30">storePackage	storePackage isNil ifTrue: [		storePackage := package isNil ifTrue: [nil] ifFalse: [package createStorePackage]].	^storePackage</body></methods><methods><class-id>VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat</class-id> <category>accessing</category><body package="FileOut30">defaultExtension	^'.app'.</body><body package="FileOut30">environment: aNameSpace	"If the user resets the environment programmatically, recreate the evaluation namespace to import it and the other defaults."	self environment: aNameSpace.	self initializeEvaluationNamespace.</body><body package="FileOut30">fileInEnvironment	^namespace</body><body package="FileOut30">requiresIndividualPackages	^false.</body><body package="FileOut30">syntax	^#'VisualAge Application'.</body></methods><methods><class-id>VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat</class-id> <category>actions</category><body package="FileOut30">classAttributeNames	^#(' subclass: ' 	'	classInstanceVariableNames: ' 	'	instanceVariableNames: ' 	'	classVariableNames: '	 '	poolDictionaries: ').</body><body package="FileOut30">classAttributesFor: aClass 	| values |	values := (OrderedCollection new)				add: aClass name;				add: aClass class instanceVariablesString;				add: aClass instanceVariablesString;				add: aClass classVariablesString;				add: aClass sharedPoolsString;				yourself.	^values</body><body package="FileOut30">closeMethodGroup: aFileStream	aFileStream nextPutAll: ' !'; cr.</body><body package="FileOut30">comment: object value: comment on: aStream for: aSourceFileManager	"Prevent the super from writing out the fullName of the class in the comment-setting expression."	| filePosition |	object isBehavior ifFalse: [^self].	aStream cr; cr.	filePosition := aSourceFileManager getWritePosition: aStream.	aStream nextChunkPut: object name, ' comment:\' withCRs, comment asString storeString.	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="FileOut30">nameForPackage: anApplication	^anApplication name select: [:each | each isAlphaNumeric]</body><body package="FileOut30">packageProperties: aDictionary for: aPackageModel on: aFileManager 	"Include all the properties for the package on the stream"	| app prereqSymbols aStream |	aStream := aFileManager targetFile.	app := Application fromStore: aPackageModel.	aStream		nextPutAll: 'Application create: #';		nextPutAll: (self nameForPackage: app);		nextPutAll: ' with: (';		cr;		tab.	prereqSymbols := app prerequisitesForFileOut.	prereqSymbols isEmpty 		ifTrue: [prereqSymbols := prereqSymbols , #(#Kernel)].	aStream print: prereqSymbols.	aStream		cr;		tab;		tab;		nextPutAll: 'collect: [:each | Smalltalk at: each ifAbsent: [';		cr;		tab;		tab;		tab;		nextPutAll: 'Application errorPrerequisite: #';		nextPutAll: (self nameForPackage: app);		nextPutAll: ' missing: each]])!';		cr;		cr;		nextPutAll: (self nameForPackage: app);		nextPutAll: ' becomeDefault!';		cr</body><body package="FileOut30">printCategory: aCategory for: aSelector in: aClass on: aFileStream	| str |	str := WriteStream on: (String new: 100).	str 		nextPutAll: (self classNameFor: aClass);		nextPutAll: ' categoriesFor: ';		print: aSelector;		nextPutAll: ' are: ';		print: (Array with: aCategory). 	aFileStream cr.	aFileStream nextChunkPut: str contents.	aFileStream cr; cr.</body><body package="FileOut30">printCategoryChunk: aString for: aClass on: aFileStream	"Essetial to separate final ! of class comment or definition from initial ! of category chunk via crs:  VASmalltalk will not parse !! on a line."	currentCategory := aString.	aFileStream cr; cr; nextPut: $!.	aFileStream nextChunkPut: (self classNameFor: aClass), ' publicMethods '.</body><body package="FileOut30">removeSelector: sel from: class on: aStream	"VASmalltalk makes #removeSelector: call #removeSelector:ifAbsent: with an error raising block if the method is not found.  For compatibility with VW behaviour and for common sense, if what we're trying to remove is already absent in VA, do not raise an error when filing-in."	aStream cr; cr; nextChunkPut:		class name, ' removeSelector: ', sel storeString, ' ifAbsent: []'.</body></methods><methods><class-id>VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat</class-id> <category>initialize/release</category><body package="FileOut30">initialize	super initialize.	self initializeEvaluationNamespace.</body><body package="FileOut30">initializeEvaluationNamespace	"Superclass initializes environment to self class fileInEnvironment.  User can reset it programmatically."	namespace := NameSpace new.	namespace imports: 'private ', self environment name, '.* private VisualAgeCompatibility.* private XProgramming.SUnit.*'.	namespace at: #Smalltalk put: FakeSmalltalkDictionaryForPrerequisites new.</body></methods><methods><class-id>VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat</class-id> <category>file-in</category><body package="FileOut30">readPackageFrom: aStream	"This format will match anything that has ' publicMethods ! in it, which includes class and method file-outs from VASmalltalk as well as file-outs of entire apps.  If the first chunk, after an optional comment, is a doIt, evaluate it and see if it gives us a package.  If it is not a doIt, avoid consuming it as that would break subsequent reading (see #evaluateChunksOf:).  If it is and returns a package, assign it to our namespace so that we can compile file-in code that refers to it, e.g. MyPackage becomeDefault."	aStream skipSeparators.	(aStream peek = $!) ifFalse:		[super readPackageFrom: aStream.		package isNil ifFalse: [namespace at: package name asSymbol put: package]].</body></methods><methods><class-id>VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat class</class-id> <category>printing</category><body package="FileOut30">label	^'VASmalltalk-compatible (see Help)'</body></methods><methods><class-id>VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat class</class-id> <category>testing</category><body package="FileOut30">canFormatStream: aStream	"Detect VASmalltalk code by looking for 'publicMethods !'. N.B. this searches the entire source stream, not just the first line, so could mismatch a non-XML source file that just happened to contain the match string."	| atEnd |	aStream upToAll: ' publicMethods !'.	atEnd := aStream atEnd.	aStream reset.	^atEnd not.</body></methods><methods><class-id>VisualAgeCompatibility.FakeSmalltalkDictionaryForPrerequisites</class-id> <category>dictionary protocol</category><body package="FileOut30">at: aSymbol	^self at: aSymbol ifAbsent: [self error: 'Key not found'].</body><body package="FileOut30">at: aSymbol ifAbsent: aBlock	^(Store.Registry packageNamed: aSymbol asString) isNil		ifTrue: aBlock		ifFalse: [aSymbol asString].</body></methods><methods><class-id>Kernel.ForeignPackage</class-id> <category>accessing</category><body package="FileOut30">addMethodNames: aSet 	self methodNames addAll: aSet.</body><body package="FileOut30">basicComment: aString	comment := aString.</body><body package="FileOut30">basicPackageVersion: aString	version := aString.</body><body package="FileOut30">binaryGlobalNames	^binaryGlobalNames</body><body package="FileOut30">binaryGlobalNames: anObject	binaryGlobalNames := anObject</body><body package="FileOut30">classNames	classNames isNil ifTrue: [classNames := Set new].	^classNames</body><body package="FileOut30">classNames: anObject	classNames := anObject</body><body package="FileOut30">comment	^comment.</body><body package="FileOut30">convertPrerequisite: aString	"Convert the prerequisite name if it looks like a dialect portability application"	('*VAPort' match: aString) ifTrue: [^aString copyReplaceAll: 'VAPort' with: 'VWPort'].	('*DolphinPort' match: aString) ifTrue: [^aString copyReplaceAll: 'DolphinPort' with: 'VWPort'].	^aString.</body><body package="FileOut30">globalNames	globalNames isNil ifTrue: [globalNames := OrderedCollection new].	^globalNames</body><body package="FileOut30">globalNames: anObject	globalNames := anObject</body><body package="FileOut30">methodNames	methodNames isNil ifTrue: [methodNames := OrderedCollection new].	^methodNames</body><body package="FileOut30">methodNames: anObject	methodNames := anObject</body><body package="FileOut30">name	^name</body><body package="FileOut30">name: anObject	name := anObject</body><body package="FileOut30">paxVersion	^0.</body><body package="FileOut30">paxVersion: aNumber	"Ignore this"</body><body package="FileOut30">prerequisites	^prerequisites</body><body package="FileOut30">prerequisites: anIdentitySet 	prerequisites := anIdentitySet collect: [:each |		self convertPrerequisite: each].</body><body package="FileOut30">setPrerequisites: anIdentitySet	self prerequisites: anIdentitySet.</body><body package="FileOut30">version		^version.</body></methods><methods><class-id>Kernel.ForeignPackage</class-id> <category>converting</category><body package="FileOut30">createStorePackage	| storePackage |	storePackage := Store.Registry packageNamedOrCreate: name.	storePackage isEmpty 		ifFalse: 			[storePackage cleanse.			storePackage doUnloadExtensionsFromImage.			storePackage doUnloadDefinitionsFromImage.			storePackage doUnloadExtensionsFromImage].	storePackage comment: comment.	storePackage 		developmentPrerequisites: (prerequisites asArray collect: 					[:each | 					Array 						with: #any						with: each						with: '']).	^storePackage</body><body package="FileOut30">fromStorePackage: aStorePackageModel	| |	name := aStorePackageModel name.	comment := aStorePackageModel comment.	prerequisites := IdentitySet withAll: (aStorePackageModel developmentPrerequisites collect: [:each | each at: 2]).	version := aStorePackageModel version.	classNames := aStorePackageModel definedClassModels collect: [:each |		each fullClassSymbol asQualifiedReference value name].	aStorePackageModel extendedClassModels do: [:each | | className assocs |		className := each fullClassSymbol asQualifiedReference value name.		assocs := (each selectorsMeta: false) collect: [:eachSelector |			className -&gt; eachSelector].		self addMethodNames: assocs.		assocs := (each selectorsMeta: true) collect: [:eachSelector |			className asString -&gt; eachSelector].		self addMethodNames: assocs].			^self.				"paxVersion  basicPackageVersionclassNamesmethodNAmesglobalNamesresourceNames"</body></methods><methods><class-id>Kernel.ForeignPackage</class-id> <category>initialize</category><body package="FileOut30">initialize</body></methods><methods><class-id>Kernel.ForeignPackage</class-id> <category>dialect specific</category><body package="FileOut30">additionalPrerequisites	self subclassResponsibility.</body><body package="FileOut30">dialectPortAppName	self subclassResponsibility.</body></methods><methods><class-id>Kernel.ForeignPackage</class-id> <category>actions</category><body package="FileOut30">prerequisitesForFileOut	| fixedPrereqs |	fixedPrereqs := self prerequisites 				collect: [:each | each select: [:eachChar | eachChar isAlphaNumeric]].	fixedPrereqs addAll: self additionalPrerequisites.	fixedPrereqs := fixedPrereqs asSortedCollection asArray.	fixedPrereqs := fixedPrereqs collect: 					[:each | 					('*VWPort' match: each) 						ifTrue: [each copyReplaceAll: 'VWPort' with: self dialectPortAppName]						ifFalse: [each]].	^fixedPrereqs collect: [:each | each asSymbol]</body></methods><methods><class-id>Kernel.ForeignPackage class</class-id> <category>instance creation</category><body package="FileOut30">fromStore: aStorePackageModel 	^self new fromStorePackage: aStorePackageModel.</body><body package="FileOut30">new	^super new initialize.</body></methods><methods><class-id>DolphinCompatibility.Package</class-id> <category>dialect specific</category><body package="FileOut30">additionalPrerequisites	^#().</body><body package="FileOut30">dialectPortAppName	^'DolphinPort'.</body></methods><methods><class-id>DolphinCompatibility.Package</class-id> <category>accessing</category><body package="FileOut30">allResourceNames: aSet 	resourceNames := aSet</body><body package="FileOut30">globalAliases: aCollection	"I don't know what this is. Ignore it"</body><body package="FileOut30">resourceNames	resourceNames isNil ifTrue: [resourceNames := OrderedCollection new].	^resourceNames</body><body package="FileOut30">resourceNames: anObject	resourceNames := anObject</body></methods><methods><class-id>DolphinCompatibility.Package class</class-id> <category>instance creation</category><body package="FileOut30">name: aString	^self new name: aString.</body></methods><methods><class-id>SqueakCompatibility.SqueakTests</class-id> <category>auxiliary</category><body package="FileOut30">getFileOutResultsDoing: block	| fileManager actualStream |		fileManager := SourceCodeStream internalWithEncoding: #Source.		fileManager sourceFormatter: (SqueakCompatibility.SqueakChangeSetFileFormat acronym: 'rw').		actualStream := fileManager targetFile stream.		[ block value: fileManager]			ensure: [fileManager close].		^actualStream contents asString</body><body package="FileOut30">getFileOutResultsForSelector: aSelector	^self getFileOutResultsDoing: [:fileManager |		fileManager 			fileOutMessages: (Set with: aSelector)			for: TestClass			logging: false]</body></methods><methods><class-id>SqueakCompatibility.SqueakTests</class-id> <category>testing</category><body package="FileOut30">testClassDefinition	| result shouldMatch |	result := self getFileOutResultsDoing: [:fileManager |		TestClass fileOutDefinitionOn: fileManager].	shouldMatch := 'Object subclass: #TestClass	instanceVariableNames: ''added for testing ''	classVariableNames: ''Added ForTests ''	poolDictionaries: ''''	category: ''SqueakOuter''!TestClass class	instanceVariableNames: ''Test ClassInstanceVariables ''!'.	self assert: result = shouldMatch</body><body package="FileOut30">testMethodDoingPrimitive	|  shouldMatch result |	result := self getFileOutResultsForSelector: #methodDoingPrimitive: .	shouldMatch := '!TestClass methodsFor: ''forTests'' stamp: ''rw *''!methodDoingPrimitive: index	"Copied the implementation of Object&gt;&gt;#at: as an example for a method doing a message send."		&lt;primitive: 60&gt;	^super methodDoingPrimitive: index! !'.	self assert: (shouldMatch match: result)</body><body package="FileOut30">testMethodWithNamespacedClass	"self debug: #testMethodWithNamespacedClass"		|  shouldMatch result |	result := self getFileOutResultsForSelector: #methodWithNamespacedClass .	shouldMatch := '!TestClass methodsFor: * stamp: ''rw *''!methodWithNamespacedClass		^TestCase new! !'.	self assert: (shouldMatch match: result)</body><body package="FileOut30">testMethodWithSimpleClass	|  shouldMatch result |	result := self getFileOutResultsForSelector: #methodWithSimpleClass.	shouldMatch := '!TestClass methodsFor: * stamp: ''rw *''!methodWithSimpleClass		^Array new: 4! !'.	self assert: (shouldMatch match: result)</body><body package="FileOut30">testNamespace	|  shouldMatch result |	result := self getFileOutResultsDoing: [:fileManager | Smalltalk.SqueakCompatibility fileOutDefinitionOn: fileManager].	shouldMatch := ''.	self assert: (shouldMatch match: result)</body><body package="FileOut30">testUnderscoreSelector	| haltCaptured |	haltCaptured := false.	[self getFileOutResultsForSelector: #methodWith_Underscore] on: UserNotification do: [:exc | haltCaptured := true].	self assert: haltCaptured.</body></methods><methods><class-id>DolphinCompatibility.DolphinPackageSourceFileFormat</class-id> <category>actions</category><body package="FileOut30">addComment: aComment on: aStream	"Dolphin wants the first chunk to be the package definition, so write the comment directly, not as a separate chunk"	| comment |	comment := aComment.	(comment first = $" and: [comment last = $"])		ifFalse: [comment := '"', (comment copyReplaceAll: '"' with: ''''''), '"'].	aStream nextPutAll: comment; cr.</body><body package="FileOut30">classAttributeNames	^#(' subclass: ' 	'	instanceVariableNames: ' 	'	classVariableNames: '	 '	poolDictionaries: '	'	classInstanceVariableNames: ' ).</body><body package="FileOut30">classAttributesFor: aClass 	| values |	values := (OrderedCollection new)				add: aClass name;				add: aClass class instanceVariablesString;				add: aClass instanceVariablesString;				add: aClass classVariablesString;				add: aClass sharedPoolsString;				yourself.	^values</body><body package="FileOut30">comment: object value: comment on: aStream for: aSourceFileManager	"Prevent the super from writing out the fullName of the class in the comment-setting expression."	| filePosition |	object isBehavior ifFalse: [^self].	aStream cr; cr.	filePosition := aSourceFileManager getWritePosition: aStream.	aStream nextChunkPut: object name, ' comment:\' withCRs, comment asString storeString.	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="FileOut30">nameForPackage: aPackage	^aPackage name</body><body package="FileOut30">packageProperties: aDictionary for: aPackageModel on: aFileManager 	"Include all the properties for the package on the stream"	| aStream |	aStream := aFileManager targetFile.	package := Package fromStore: aPackageModel.	self writePackageDeclarationOn: aStream.	self writePackageCommentOn: aStream.	self writePackageVersionOn: aStream.	self writePackageScriptsOn: aStream.	aStream 		nextPutAll: '"Add the class names, loose method names, global names, resource names"'.	self printPackageProperty: 'classNames' on: aStream.	self printPackageProperty: 'methodNames' on: aStream.	self printPackageProperty: 'globalNames' on: aStream.	self printPackageProperty: 'resourceNames' on: aStream.	self writePackageBinaryGlobalNamesOn: aStream.	self writePackageResourceNamesOn: aStream.	self writePackagePrerequisitesOn: aStream.	aStream		cr;		nextPutAll: 'package!'</body><body package="FileOut30">printCategory: aCategory for: aSelector in: aClass on: aFileStream	| str |	str := WriteStream on: (String new: 100).	str 		nextPutAll: (self classNameFor: aClass);		nextPutAll: ' categoriesFor: ';		print: aSelector;		nextPutAll: '!';		nextPutAll: aCategory;		nextPutAll: '!'.	aFileStream cr.	aFileStream nextPut: $!.	aFileStream nextPutAll: str contents.	aFileStream nextPutAll: ' !'.	aFileStream cr; cr.</body><body package="FileOut30">printCategoryChunk: aString for: aClass on: aFileStream	currentCategory := aString.	aFileStream cr; cr; nextPut: $!.	aFileStream nextChunkPut: (self classNameFor: aClass), ' methodsFor'.</body><body package="FileOut30">printPackageProperty: aString on: aStream 	aStream		nextPutAll: 'package ';		nextPutAll: aString;		cr.	(package perform: aString asSymbol) do: 			[:each | 			aStream				nextPutAll: '	add: '.			each class == Association 				ifTrue: [aStream print: each key; nextPutAll: ' -&gt; '; print: each value]				ifFalse: [aStream print: each].			aStream				nextPut: $;;				cr].	aStream		nextPutAll: '	yourself.';		cr</body><body package="FileOut30">removeSelector: sel from: class on: aStream	aStream cr; cr; nextChunkPut:		class name, ' removeSelector: ', sel storeString.</body><body package="FileOut30">storeDefinition: object on: aStream	| names str values |	object isBehavior ifFalse: [^self].	names := #(' subclass: '  '	instanceVariableNames: ' '	classVariableNames: ' '	poolDictionaries: ' '	classInstanceVariableNames: ').	values := OrderedCollection new		add: object name;		add: object instanceVariablesString;		add: object classVariablesString;		add: object sharedPoolsString;		add: object class instanceVariablesString;		yourself.	str := WriteStream on: (String new: 300).	str nextPutAll: object superclass displayString.	names with: values		do: 			[:symbol :value | 			str nextPutAll: symbol.			str print: value.			str cr].	aStream cr; cr; nextChunkPut: str contents.</body><body package="FileOut30">writePackageBinaryGlobalNamesOn: aStream 	aStream 		nextPutAll: '"Binary Global Names"package binaryGlobalNames: (Set new	yourself).'</body><body package="FileOut30">writePackageCommentOn: aStream 	aStream		tab;		nextPutAll: 'basicComment: ';		nextPutAll: package comment printString;		nextPutAll: '.';		cr;		cr</body><body package="FileOut30">writePackageDeclarationOn: aStream 	aStream		nextPutAll: '| package |';		cr;		nextPutAll: 'package := Package name: ''';		nextPutAll: (self nameForPackage: package);		nextPutAll: '''.';		cr.	aStream		nextPutAll: 'package paxVersion: ';		print: package paxVersion;		nextPutAll: ';';		cr.</body><body package="FileOut30">writePackagePrerequisitesOn: aStream 	aStream		nextPutAll: '"Add the prerequisite names"';		nextPutAll: 'package setPrerequisites: (IdentitySet new';		cr.	package prerequisitesForFileOut do: 			[:each | 			aStream				nextPutAll: '	add: ';				print: each asString;				nextPut: $;;				cr].	aStream		nextPutAll: '	yourself).';		cr</body><body package="FileOut30">writePackageResourceNamesOn: aStream 	aStream 		nextPutAll: '"Resource Names"package allResourceNames: (Set new	yourself).'</body><body package="FileOut30">writePackageScriptsOn: aStream	aStream cr; nextPutAll: '"Add the package scripts"'; cr.</body><body package="FileOut30">writePackageVersionOn: aStream 	aStream		nextPutAll: 'package basicPackageVersion: ';		print: package version;		nextPut: $.;		cr;		cr</body></methods><methods><class-id>DolphinCompatibility.DolphinPackageSourceFileFormat</class-id> <category>recompiling</category><body package="FileOut30">nextChunkFrom: sourceStream	"Answer the contents of the receiver, up to the next terminator character, with	double terminators ignored. Ignore Dolphin statements that we just don't want to deal with"		| chunk |	chunk := super nextChunkFrom: sourceStream.	('*guid: (GUID fromString: *' match: chunk)		ifTrue: [^'']		ifFalse: [^chunk].</body></methods><methods><class-id>DolphinCompatibility.DolphinPackageSourceFileFormat</class-id> <category>accessing</category><body package="FileOut30">defaultExtension	^'.pac'.</body><body package="FileOut30">fileInEnvironment	^DolphinCompatibility</body><body package="FileOut30">requiresIndividualPackages	^true.</body><body package="FileOut30">syntax	^#'Dolphin Package'</body></methods><methods><class-id>DolphinCompatibility.DolphinPackageSourceFileFormat class</class-id> <category>testing</category><body package="FileOut30">canFormatStream: aStream	| result |	result := (aStream next: 9) asString = '| package'.	aStream reset.	^result.</body></methods><methods><class-id>DolphinCompatibility.DolphinPackageSourceFileFormat class</class-id> <category>printing</category><body package="FileOut30">label	^'Dolphin 4.0-compatible (see Help)'</body></methods><methods><class-id>Kernel.MissingClassCategoryReader</class-id> <category>private</category><body package="FileOut30">setClass: aClass category: aCategory 	super setClass: aClass category: aCategory.	hasComplainedAboutMissingClass := false</body></methods><methods><class-id>Kernel.MissingClassCategoryReader</class-id> <category>fileIn/Out</category><body package="FileOut30">asMissingClassReader</body><body package="FileOut30">scanFrom: aStream using: aFormatter	"We exist to catch those cases where a fileIn says		Foo class methodsFor: 'xyz'	but the class Foo doesn't exist.  See (UndefinedObject class)&gt;&gt;methodsForUndefined:"	| string |	(hasComplainedAboutMissingClass not and: [aFormatter shouldComplainAboutMissingClasses]) ifTrue: [		self notify: (#ClassAbsentFromSystem &lt;&lt; #dialogs &gt;&gt; 'The requested class seems to be absent from the system.').		hasComplainedAboutMissingClass := true].	[string := aFormatter methodBodyFrom: aStream.	string size &gt; 0] whileTrue "done when double terminators"</body></methods><methods><class-id>Kernel.OldChunkSourceFileFormat</class-id> <category>private</category><body package="FileOut30">classNameFor: aClass	"Answer how the class should be represented in the source file."	^aClass name</body><body package="FileOut30">fixClassSpecSource: aSourceText forClass: aClass	"If source text is a canvas or menu resource specification for aClass replace any bindings and remove new 5i spec attributes"	| source isCanvas |	aClass isMeta ifFalse:[^aSourceText].	source := aSourceText string.	isCanvas := (source indexOfSubCollection: '&lt;resource: #canvas&gt;' startingAt: 1) &gt; 0. 	(isCanvas not and:[	(source indexOfSubCollection: '&lt;resource: #menu&gt;' startingAt: 1) = 0])		ifTrue: [^aSourceText].	source := self replaceBindingsIn: source.	isCanvas ifTrue:[source := self removeNewAttributesIn: source].	^source</body><body package="FileOut30">newAttributeNames	 ^#('#tabRequiresControl:' '#isWrapped:')</body><body package="FileOut30">removeNewAttributesIn: source 	"If source text is a canvas remove any new 5i attributes and arguments"	| convertStream last ranges attributes |	convertStream := String new writeStream.	last := 1.	attributes := self newAttributeNames asOrderedCollection.	[ranges := SortedCollection sortBlock: [:a :b | a first &lt; b first].	attributes copy		do: 			[:name | 			| rangeFind |			rangeFind := source						rangeOfPattern: name						startingAt: last						ignoreCase: false.			rangeFind = (0 to: 0)				ifTrue: [attributes remove: name]				ifFalse: [ranges add: rangeFind]].	ranges isEmpty]		whileFalse: 			[| range |			range := ranges first.			convertStream nextPutAll: (source copyFrom: last to: range first - 1).			last := (range last + 1 to: source size)						detect: [:index | '#)' includes: (source at: index)]						ifNone: [source size]].	convertStream nextPutAll: (source copyFrom: last to: source size).	^convertStream contents</body><body package="FileOut30">replaceBindingsIn: source	"If source text is a canvas or menu resource specification for aClass replace any bindings with the class symbol (e.g. replace #{UI.FullSpec} with #FullSpec)"	|  convertStream last range |	convertStream := String new writeStream.	last := 1.	[(range := source rangeOfPattern:  '#{*}' startingAt: last ignoreCase: false) = (0 to: 0)]		whileFalse: 			[| bindingString classString |			convertStream nextPutAll: (source copyFrom: last to: range first - 1).			bindingString := source copyFrom: range first + 2 to: range last - 1.			classString := bindingString copyFrom: ((bindingString indexOfSubCollection: '.' startingAt: 1) + 1							max: 1) 						to: bindingString size.			convertStream nextPutAll: '#' , classString.		     last := range last + 1].	convertStream nextPutAll: (source copyFrom: last to: source size).	^convertStream contents</body></methods><methods><class-id>Kernel.OldChunkSourceFileFormat</class-id> <category>actions</category><body package="FileOut30">comment: object value: comment on: aStream for: aSourceFileManager	"Prevent the super from writing out the fullName of the class in the comment-setting expression."	| filePosition |	object isBehavior ifFalse: [^self].	aStream cr; cr.	filePosition := aSourceFileManager getWritePosition: aStream.	aStream nextChunkPut: object name, ' comment:\' withCRs, comment asString storeString.	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="FileOut30">initializeObject: anObject on: aStream	| obj |  	obj := anObject.	obj isBindingReference 		ifTrue: [obj binding isForClass			ifTrue: [obj := obj value]			ifFalse: [^self]]		ifFalse: [obj isBehavior			ifFalse: [^self]].	aStream cr; cr; nextChunkPut: (obj name asString, ' initialize')</body><body package="FileOut30">methodBody: src class: class attributes: attributes on: aFileStream for: aSourceFileManager	| filePosition |	aFileStream cr; cr.	filePosition := aSourceFileManager getWritePosition: aFileStream.  	aFileStream nextChunkPut: (self fixClassSpecSource: src forClass: class).	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="FileOut30">remove: objName type: type on: aStream	type == #class ifFalse: [^self].	aStream cr; cr; nextChunkPut: objName, ' removeFromSystem'</body><body package="FileOut30">rename: newName from: oldName type: type on: aStream	| n1 n2 |	n1 := self homeAndNameOf: oldName.	n2 := self homeAndNameOf: newName.	n1 last = n2 last		ifFalse:			[aStream cr; cr; nextChunkPut:					n1 last, ' renameTo: ', n2 last asSymbol storeString]</body><body package="FileOut30">reorganize: object on: aStream	aStream cr; cr; nextChunkPut:				object name ,				' reorganizeFromString: ' ,				object organization printString storeString</body><body package="FileOut30">reorganizeNameSpace: object on: aStream	object isBehavior ifTrue: [^self].	aStream cr; cr; nextChunkPut:				object name ,				' reorganizeFromString: ' ,				object asNameSpace organization printString storeString</body><body package="FileOut30">storeDefinition: object on: aStream	| msg tempStr |	object isBehavior ifFalse: [^self].	msg := object oldDefinitionMessage.	tempStr := WriteStream on: (String new: 300).	tempStr nextPutAll: (msg receiver == nil ifTrue: ['nil'] ifFalse: [msg receiver name]).	msg selector keywords with: msg arguments do:		[:word :arg |		arg == object name			ifTrue: [tempStr space]			ifFalse: [tempStr cr; tab].		tempStr nextPutAll: word; space.		arg class == Array			ifTrue:				[tempStr nextPutAll: '#('.				arg do: [:argN | tempStr crtab: 3; store: argN].				tempStr nextPutAll: ')']			ifFalse: [tempStr store: arg]].	aStream cr; cr; nextChunkPut: tempStr contents.	object isMeta ifFalse: [self storeDefinition: object class on: aStream].</body></methods><methods><class-id>Kernel.OldChunkSourceFileFormat</class-id> <category>accessing</category><body package="FileOut30">close: output	super close: output.		"Restore the storeFileOutPreference if it was set."	storeFileOutPreference ~~ nil ifTrue:		[#{Store.StoreSettings} ifDefinedDo: 			[:uiSettings |			(uiSettings preferenceModelFor: #fileoutOption) value: storeFileOutPreference]]</body><body package="FileOut30">supportsPackages	^false.</body><body package="FileOut30">syntax	^#'VW3 chunk'</body></methods><methods><class-id>Kernel.OldChunkSourceFileFormat</class-id> <category>initialize-release</category><body package="FileOut30">initialize	super initialize.	"If Store is in the image, then turn off the preference for including package	 information in file-outs since it is not 3.0 compatible."	#{Store.StoreSettings} ifDefinedDo: 		[:uiSettings |		storeFileOutPreference := (uiSettings preferenceFor: #fileoutOption) value.		(uiSettings preferenceModelFor: #fileoutOption) value: #never]</body></methods><methods><class-id>Kernel.OldChunkSourceFileFormat class</class-id> <category>printing</category><body package="FileOut30">label	^'VW 3.0 non-Envy (see Help)'</body></methods><methods><class-id>Kernel.VW3EnvySourceFileFormat</class-id> <category>actions</category><body package="FileOut30">removeSelector: sel from: class on: aStream	"If filed-out code is filed-in to VW3/Envy, removeSelector:ifAbsent: synchs with Envy which removeSelector: does not (this is a side-effect of Envy in VW trying to preserve Envy and non-Envy protocol in this area;  Envy in VA has no such concern so simply makes #removeSelector: call #removeSelector:ifAbsent:)."	aStream cr; cr; nextChunkPut:		class name, ' removeSelector: ', sel storeString, ' ifAbsent: []'.</body></methods><methods><class-id>Kernel.VW3EnvySourceFileFormat class</class-id> <category>printing</category><body package="FileOut30">label	^'VW 3.0 Envy generic (see Help)'</body></methods><methods><class-id>Kernel.VW3EnvySourceFileFormat class</class-id> <category>testing</category><body package="FileOut30">canFormatStream: aStream	"We skip to avoid possible platform matching issues with the Â® character.  We code a fussy match to avoid ever mistaking VW7 chunk for VW3 chunk."	| result |	result := (aStream next: 17) asString = '''From VisualWorks'		and: [ | releaseName |			releaseName := aStream skip: 1; next: 11.			releaseName = ', Release 3' or: [releaseName = ', Release 2']].	aStream reset.	^result</body></methods><methods><class-id>SqueakCompatibility.SqueakMethodFormatter</class-id> <category>visitor-double dispatching</category><body package="FileOut30">acceptLiteralNode: aLiteralNode 	(aLiteralNode value isKindOf: BindingReference) ifTrue: [		self writeString: aLiteralNode value name asString.	] ifFalse: [		super acceptLiteralNode: aLiteralNode.	]</body><body package="FileOut30">acceptVariableNode: aVariableNode 	"Strip namespace information. Do it purely syntactical since I have just the string to work with. The regular parse tree has BindingReference's to work with instead, which is cleaner."	| n lastDot shortName |	n := aVariableNode name.	lastDot := n lastIndexOf: $. ifAbsent: [super acceptVariableNode: aVariableNode. ^self].	shortName := n copyFrom: lastDot + 1 to: n size.	codeStream nextPutAll: shortName</body></methods><methods><class-id>SqueakCompatibility.SqueakCommentScanner</class-id> <category>As yet unclassified</category><body package="FileOut30">setClass: aClass	class := aClass.</body></methods><methods><class-id>SqueakCompatibility.SqueakCommentScanner</class-id> <category>fileIn/Out</category><body package="FileOut30">asMissingClassReader</body><body package="FileOut30">scanFrom: aStream using: aFormatter	| comment |	comment := aFormatter nextChunkFrom: aStream.	comment isEmpty ifTrue: [^self].	class ifNil: [^self].	class comment: comment."	aStream skipSeparators.	aStream peek = $!."</body></methods><methods><class-id>VisualAgeCompatibility.EnvyPrerequisite</class-id> <category>accessing</category><body package="FileOut30">name	^name</body><body package="FileOut30">name: aString	name := aString.</body></methods><methods><class-id>DolphinCompatibility.DolphinMethodCategorizationScanner</class-id> <category>stuff</category><body package="FileOut30">asMissingClassReader</body><body package="FileOut30">readSubChunksFrom: aStream using: aFormatter	|  names body |	names := OrderedCollection new.	[body := aFormatter nextChunkFrom: aStream.	body isEmpty] whileFalse: [		names add: body].	^names.</body><body package="FileOut30">scanFrom: aStream using: aFormatter 	| names category |	names := self readSubChunksFrom: aStream using: aFormatter.	category := names 				detect: [:each | each first ~= $* and: [(#('public' 'private') includes: each) not]]				ifNone: [^self].	class ifNil: [^self].	class organization classify: methodName under: category</body></methods><methods><class-id>DolphinCompatibility.DolphinMethodCategorizationScanner</class-id> <category>accessing</category><body package="FileOut30">methodName: aSymbol 	methodName := aSymbol</body><body package="FileOut30">setClass: aClass	class := aClass.</body></methods><methods><class-id>VisualAgeCompatibility.Application</class-id> <category>accessing</category><body package="FileOut30">envyPrerequisites	^envyPrerequisites</body><body package="FileOut30">envyPrerequisites: aCollection	"Set the prerequisites which are required in ENVY, but not meaningful in VW"	envyPrerequisites := aCollection.</body></methods><methods><class-id>VisualAgeCompatibility.Application</class-id> <category>initialize</category><body package="FileOut30">initialize	super initialize.	envyPrerequisites := OrderedCollection new.</body></methods><methods><class-id>VisualAgeCompatibility.Application</class-id> <category>dialect specific</category><body package="FileOut30">additionalPrerequisites	^envyPrerequisites collect: [:each | each name].</body><body package="FileOut30">dialectPortAppName	^'VAPort'.</body></methods><methods><class-id>VisualAgeCompatibility.Application</class-id> <category>application protocol</category><body package="FileOut30">becomeDefault	^self.</body><body package="FileOut30">initializeAfterLoad	^self.</body><body package="FileOut30">loaded	^self.</body></methods><methods><class-id>VisualAgeCompatibility.Application</class-id> <category>converting</category><body package="FileOut30">createStorePackage		| pkg |	pkg := super createStorePackage.	envyPrerequisites isEmpty ifFalse: [		pkg propertyAt: 'envyPrerequisites' put: (envyPrerequisites collect: [:each | each name])].	^pkg.</body></methods><methods><class-id>VisualAgeCompatibility.Application class</class-id> <category>instance creation</category><body package="FileOut30">create: aSymbol with: prerequisites	| app |	app := self new.	app name: aSymbol asString.	app prerequisites: (prerequisites select: [:each | each isString]).	app envyPrerequisites: (prerequisites select: [:each | each isString not]).	^app.</body></methods><methods><class-id>VisualAgeCompatibility.Application class</class-id> <category>errors</category><body package="FileOut30">errorPrerequisite: mainPackageName missing: aString	^EnvyPrerequisite new name: aString.</body></methods><methods><class-id>DolphinCompatibility.DolphinCategoryScanner</class-id> <category>As yet unclassified</category><body package="FileOut30">setClass: aClass	class := aClass.</body></methods><methods><class-id>DolphinCompatibility.DolphinCategoryScanner</class-id> <category>fileIn/Out</category><body package="FileOut30">asMissingClassReader</body><body package="FileOut30">scanFrom: aStream using: aFormatter	[| body |	body := aFormatter methodBodyFrom: aStream.	body isEmpty ifTrue: [^self].	class ifNil: [^self].	class organization addCategory: body.	aStream skipSeparators.	aStream peek = $!] whileTrue.</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat</class-id> <category>accessing</category><body package="FileOut30">acronym	^acronym isNil ifTrue: [acronym := self defaultAcronym] ifFalse: [acronym]</body><body package="FileOut30">acronym: anObject	acronym := anObject</body><body package="FileOut30">syntax	^#'Squeak'</body><body package="FileOut30">timeStampString	^timeStampString</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat</class-id> <category>actions</category><body package="FileOut30">methodBody: src class: class attributes: attributes on: aFileStream for: aSourceFileManager 	| filePosition selector |	selector := class parserClass new parseSelector: src.	(selector includes: $_ ) ifTrue: [self notifyOfUnderscoreIn: selector class: class].	aFileStream cr; cr.	filePosition := aSourceFileManager getWritePosition: aFileStream.	aFileStream nextChunkPut: (self formatMethod: src inClass: class).	^aSourceFileManager keyForFile: aSourceFileManager target		position: filePosition</body><body package="FileOut30">methodSources: methodSources class: class selector: sel attributes: attributes on: aFileStream for: aSourceFileManager 	^self 		methodBody: methodSources source		class: class		attributes: attributes		on: aFileStream		for: aSourceFileManager</body><body package="FileOut30">notifyOfUnderscoreIn: aSelector class: aClass	Transcript		cr;		nextPutAll: 'Pharo / Squeak fileout has underscore in selector:';		crtab;		nextPutAll: aClass fullName;		nextPutAll: '&gt;&gt;';		print: aSelector;		cr;		nextPutAll: 'Fileout continues (since Pharo and recent Squeak can handle underscore in selectors).'.</body><body package="FileOut30">printCategoryChunk: aString for: aClass on: aFileStream	| chunk |	chunk := self tempStreamFor: aFileStream.	chunk		nextPutAll: (self classNameFor: aClass);		nextPutAll: ' methodsFor: ';		store: aString asString;		nextPutAll: ' stamp: ''';		nextPutAll: self acronym;		space;		nextPutAll: self timeStampString;		nextPut: $'.	aFileStream		cr; cr; nextPut: $!;		nextChunkPut: chunk contents</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat</class-id> <category>private</category><body package="FileOut30">classNameFor: aClass	^aClass name asString</body><body package="FileOut30">constructTimeStampString	"self new constructTimeStampString"	| str |	str := WriteStream on: String new.	str		nextPutAll: (TimestampPrintPolicy print: Date today using: 'd/m/yy ') asString;		nextPutAll: (TimestampPrintPolicy print: Time now using: 'hh:mm') asString.	^str contents</body><body package="FileOut30">defaultAcronym	^''</body><body package="FileOut30">formatMethod: src inClass: class	"Provide a Squeak formatting of the given method body"	^ class compilerClass new formatForSqueak: src inClass: class</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat</class-id> <category>initialize-release</category><body package="FileOut30">initialize	super initialize.	timeStampString := self constructTimeStampString</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat</class-id> <category>reading</category><body package="FileOut30">fileInFrom: aStream	Smalltalk at: #SystemOrganization put: SystemOrganizer new.	^[super fileInFrom: aStream] ensure: [Smalltalk removeKey: #SystemOrganization ifAbsent: []].</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat class</class-id> <category>instance creation</category><body package="FileOut30">acronym: anAcronymString	^self new acronym: anAcronymString</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat class</class-id> <category>testing</category><body package="FileOut30">canFormatStream: aStream		| atEnd result |	result := (aStream next: 18) asString = 'SystemOrganization'.	aStream reset.	result ifTrue: [^true].	aStream skipThroughAll: '''From Squeak'.	atEnd := aStream atEnd.	aStream reset.	^atEnd not.</body></methods><methods><class-id>SqueakCompatibility.SqueakChangeSetFileFormat class</class-id> <category>printing</category><body package="FileOut30">label	^'Squeak / Pharo (see Help)'</body></methods><methods><class-id>SqueakCompatibility.TestClass</class-id> <category>forTests</category><body package="FileOut30">methodDoingPrimitive: index	"Copied the implementation of Object&gt;&gt;#at: as an example for a method doing a message send."	&lt;primitive: 60&gt;	^super methodDoingPrimitive: index</body><body package="FileOut30">methodWithNamespacedClass	^XProgramming.SUnit.TestCase new</body><body package="FileOut30">methodWithSimpleClass	^Array new: 4</body><body package="FileOut30">methodWith_Underscore	"This method selector has an underscore.... just in case you did not notice already ... "</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="FileOut30">oldDefinitionMessage	" Answer a MessageSend that defines the receiver. "	| names |	names := (String new: 50) writeStream.	self instVarNames do: [:n | names nextPutAll: n; space].	^MessageSend		receiver: self		selector: #instanceVariableNames:		argument: names contents</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat class</class-id> <category>printing</category><body package="FileOut30">label	^#ChunkFormat &lt;&lt; #dialogs &gt;&gt; 'Chunk Format'</body></methods><methods><class-id>Kernel.SourceFileFormat class</class-id> <category>instance creation</category><body package="FileOut30">formatForStream: aStream	"This parcel contains several #canFormatStream: implementations, so must test its own source format, which is XMLSourceFileFormat, first, or at least earlier than any 'scan whole file for ...' matcher, otherwise it will match the first of their implementation in the Squeak or VA #canFormatStream: implementations.  Fortunately, the XML matcher is xor with the others and last in the subclass list."	self allSubclasses reverseDo:		[:subclass |		(subclass canFormatStream: aStream)			ifTrue: [^subclass new]].	^FilteringFileFormat new</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>code component support</category><body package="FileOut30">bundleProperties: aDictionary for: aBundleModel on: aFileManager	"Include all the properties for the package on the stream"	aDictionary isEmpty ifTrue: [ ^self ].	aBundleModel fileOutProperties: aDictionary on: aFileManager.</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>private</category><body package="FileOut30">compile: string class: aClass protocol: aProtocol	^aClass compile: string classified: aProtocol</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>accessing</category><body package="FileOut30">defaultExtension	^'.st'.</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>actions</category><body package="FileOut30">methodSelector: aSymbol body: src class: class attributes: attributes on: aFileStream for: aSourceFileManager	self methodBody: src class: class attributes: attributes on: aFileStream for: aSourceFileManager.</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>code component support</category><body package="FileOut30">packageProperties: aDictionary for: aPackageModel on: aFileManager	"Include all the properties for the package on the stream"	aDictionary isEmpty ifTrue: [ ^self ].	aPackageModel fileOutProperties: aDictionary on: aFileManager.</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>accessing</category><body package="FileOut30">requiresIndividualPackages	^false.</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>testing</category><body package="FileOut30">shouldBeVerbose	^true</body><body package="FileOut30">shouldComplainAboutMissingClasses	^true</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>accessing</category><body package="FileOut30">supportsPackages	^true.</body></methods><methods><class-id>Core.Class</class-id> <category>fileIn/Out</category><body package="FileOut30">categoriesForClass	^DolphinCompatibility.DolphinCategoryScanner new setClass: self.</body></methods><methods><class-id>Core.Class</class-id> <category>subclass creation</category><body package="FileOut30">fileInEnvironment	"Return the default namespace to use when filing in code which doesn't use qualified names. Get this from user preferences if available."	#{UISettings} ifDefinedDo:		[:uiSettings |		(uiSettings preferenceFor: #fileInDefaultNamespace) ifNotNil:			[:namespaceFullName | ^namespaceFullName asQualifiedReference value]].	^Smalltalk</body><body package="FileOut30">subclass: t classInstanceVariableNames: classInstVars instanceVariableNames: f classVariableNames: d poolDictionaries: s	"For VisualAge fileout compatibility.	This is the standard initialization message for creating a new class as a subclass	of an existing class (the receiver)."	^self subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		classInstanceVariableNames: classInstVars.</body><body package="FileOut30">subclass: className instanceVariableNames: iVars classVariableNames: d poolDictionaries: pools classInstanceVariableNames: clsInstVars 	"For compatibility filing in of other dialect code. Makes some assumptions"	| approved cbr mbr class |	approved := SystemUtils		validateClassName: className		for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self fileInEnvironment)			superclass: self;			instVarString: iVars;			category: Store.Registry currentPackage name asSymbol;			attributes: OrderedCollection new;			behaviorType: #none;			importString: pools;			private: false.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: clsInstVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>fileIn/Out</category><body package="FileOut30">categoriesFor: aSymbol 	^(DolphinCompatibility.DolphinMethodCategorizationScanner new) 		setClass: self;		methodName: aSymbol.</body><body package="FileOut30">categoriesFor: aSelector are: aCollection	self organization classify: aSelector under: aCollection first.</body><body package="FileOut30">commentStamp: aString prior: anInteger	^(SqueakCompatibility.SqueakCommentScanner new) 		setClass: self.</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>initialize-release</category><body package="FileOut30">initializeAfterLoad	"For compatibility with VisualAge and ENVY code."</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>fileIn/Out</category><body package="FileOut30">methodsFor	^self methodsFor: 'as yet unclassified'.</body><body package="FileOut30">methodsFor: aString stamp: aTimestamp	"For Squeak compatibility"	^self methodsFor: aString.</body><body package="FileOut30">privateMethods	^self methods.</body><body package="FileOut30">privateMethodsFor: aString	"VW3/Envy non-genericFormat file-in"	^self methodsFor: aString</body><body package="FileOut30">publicMethods	^self methods.</body><body package="FileOut30">publicMethodsFor: aString	"VW3/Envy non-genericFormat file-in"	^self methodsFor: aString</body></methods><methods><class-id>Kernel.ClassCategoryReader</class-id> <category>fileIn/Out</category><body package="FileOut30">asMissingClassReader	^MissingClassCategoryReader class: nil category: category</body><body package="FileOut30">scanFrom: aStream using: aFormatter	"Files in methods from the stream, aStream.  Prints the name and	category of the methods in the transcript view."	| string |	aFormatter shouldBeVerbose ifTrue: [Transcript cr; nextPutAll: class printString; nextPut: $&lt;; nextPutAll: category; endEntry].	[string := aFormatter methodBodyFrom: aStream.	string size &gt; 0] whileTrue:		"done when double terminators"		[aFormatter compile: string class: class protocol: category]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>creating subclasses</category><body package="FileOut30">oldDefinitionMessage	"Answer a MessageSend that defines the receiver."	includeFiles isNil ifTrue: [^super oldDefinitionMessage].	^MessageSend		receiver: superclass		selector: #subclass:includeFiles:includeDirectories:libraryFiles:libraryDirectories:generateMethods:beVirtual:optimizationLevel:instanceVariableNames:classVariableNames:poolDictionaries:category:		arguments: self oldDefinitionMessageArguments</body><body package="FileOut30">oldDefinitionMessageArguments	"Answer an Array of values that should be used as the arguments to the receiver's instance creation message."	| arguments |	arguments := Array new: 12.	arguments		at: 1 put: self name;		at: 2 put: (includeFiles fold: [:a :b | a, ' ', b]);		at: 3 put: (self includeDirectoriesArray fold: [:a :b | a, ' ', b]);		at: 4 put: (self libraryFilesArray fold: [:a :b | a, ' ', b]);		at: 5 put: (self libraryDirectoriesArray fold: [:a :b | a, ' ', b]);		at: 6 put: '';		at: 7 put: self isVirtual;		at: 8 put: self optimizationLevel;		at: 9 put: self instanceVariablesString;		at: 10 put: self classVariablesString;		at: 11 put: self sharedPoolsString;		at: 12 put: self category asString.	^arguments</body></methods><methods><class-id>Core.UndefinedObject class</class-id> <category>fileIn/Out</category><body package="FileOut30">methodsFor: aString 	"Answer a ClassCategoryReader for accessing the messages in the method	dictionary category, aString, of the receiver."	^ClassCategoryReader class: self category: aString asSymbol	"False methodsFor: 'logical operations' inspect"</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>fileIn/Out</category><body package="FileOut30">categoriesFor: aSymbol 	^(DolphinCompatibility.DolphinMethodCategorizationScanner new) 		setClass: self;		methodName: aSymbol.</body><body package="FileOut30">categoriesForClass	^DolphinCompatibility.DolphinCategoryScanner new setClass: self.</body><body package="FileOut30">commentStamp: aString prior: anInteger	^(SqueakCompatibility.SqueakCommentScanner new) 		setClass: self</body><body package="FileOut30">methodsFor: aString 	"Answer a ClassCategoryReader for accessing the messages in the method	dictionary category, aString, of the receiver."	^MissingClassCategoryReader class: nil category: aString asSymbol</body><body package="FileOut30">methodsFor: aString stamp: aTimestamp	^self methodsFor: aString</body></methods><methods><class-id>Kernel.SourceCodeStream</class-id> <category>private</category><body package="FileOut30">fileOutTTMessages: aDictionary for: aClassName logging: aBoolean	"File out a description of the messages of aClassName. Messages are in sets as values of aDictionary whose keys are protocols."	aDictionary keysAndValuesDo:		[:protocol :methods || className meta class |		aBoolean ifTrue:			[Transcript cr; show: aClassName , '&gt;' , protocol].		className := aClassName.		(meta := className namesMetaClass) ifTrue:			[className := className classNameOnly].		class := className asQualifiedReference valueOrDo:			[(ChangeSupportClassProxy pathString: className) meta: meta].		(meta and: [class isMeta not]) ifTrue: [class := class class].		self printCategoryChunk: protocol for: class.		methods do:			[:method |			self				printMethodBody: method sourceCode				withSelector: method selector				for: class].		self closeMethodGroup].</body></methods><methods><class-id>Kernel.SmalltalkCompiler</class-id> <category>public access</category><body package="FileOut30">formatForSqueak: src inClass: cls	^ SqueakCompatibility.SqueakMethodFormatter format: (Refactory.Browser.RBParser parseMethod: src)</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>load/unload</category><body package="FileOut30">parcelOutTo: parcelFileName sourceFileName: sourceFileName parcelOptions: parcelOptions	"Generic publish the parcel with sources. Don't republish."	| codeWriter existing sfn |	codeWriter := CodeWriter new.	codeWriter codeComponent: self.	"fetch the parcel in the image if it exists."	( existing := self relatedParcel ) == nil 		ifTrue: [ existing := self ].	self propertyAt: #padded put: ( parcelOptions at: #padded ifAbsent: nil ).	sfn := ( parcelOptions at: #parcelSaveSource ifAbsent: true )		ifTrue: [ sourceFileName asLogicalFileSpecification ]		ifFalse: [ nil ].	Cursor wait showWhile: [ self prepareCodeWriter: codeWriter withAdditionalProperties: (parcelOptions at: #additionalProperties ifAbsent: [Dictionary new]) ].	[ codeWriter 		writeToParcelFileNamed: parcelFileName asLogicalFileSpecification		sourceFileNamed: sfn		oldSourceIndex: ( existing propertyAt: #sourceIndex ifAbsent: nil )		hideSource: ( parcelOptions at: #parcelHideSource ifAbsent: false )		republish: ( parcelOptions at: #parcelRepublish ifAbsent: false )		backup: ( parcelOptions at: #parcelBackup ifAbsent: false ).	] on: CodeWriter invalidTraceSignal		do: [ :ex | Parcel invalidNamedObjectSignal raiseWith: ex parameter ]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>private-load/unload</category><body package="FileOut30">prepareCodeWriter: aCodeWriter withAdditionalProperties: aDictionary	"Load aCodeWriter with the objects necessary to write-out the contents of the receiver."	self cleanse.	self runPreSave.	self storePropertiesOn: aCodeWriter withAdditionalProperties: aDictionary.	"Store the definitions."	aCodeWriter storeDefinedObjects: self definedObjects.	aCodeWriter		storeClasses: self definedClasses		extensions: self extensionMethods		excluding: self definedClassesExcludedSelectors.	aCodeWriter storeDefinedBindings: self definedBindings.	self namedObjects keysAndValuesDo: [:key :value | aCodeWriter addObject: value named: key].	^aCodeWriter</body><body package="FileOut30">storePropertiesOn: aCodeWriter 	^self storePropertiesOn: aCodeWriter withAdditionalProperties: Dictionary new.</body><body package="FileOut30">storePropertiesOn: aCodeWriter withAdditionalProperties: aDictionary	"Store the CodeComponents's properties. But ensure the #parcel 	property is just the 	base name, and that the stored properties exclude any volatile 	properties."	| storedProperties loadOrderedClasses parcelProperty |	loadOrderedClasses := SystemUtils sortForLoading: self definedClasses.	loadOrderedClasses do: [:cl | cl preSave: self].	parcelProperty := properties at: #parcel ifAbsent: [].	parcelProperty := Array with: (parcelProperty notNil											ifTrue: [parcelProperty last]											ifFalse: [self name]).	storedProperties := (self propertiesForSave) 							at: #parcel put: parcelProperty; 							at: #loadOrderedClasses put: loadOrderedClasses; 							yourself.	aDictionary keysAndValuesDo: [:eachKey :eachValue |		"Don't overwrite"		(storedProperties includesKey: eachKey) ifFalse: [			storedProperties at: eachKey put: eachValue]].	storedProperties at: #version ifAbsent: [self traceVersion notEmpty ifTrue: [storedProperties at: #version put: self traceVersion]].	"Store any subclass-specific properties."	self putStoredPropertiesIn: storedProperties.	aCodeWriter storeProperties: storedProperties</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="FileOut30">addFileOut30To: aDictionary development: devSpecs runtime: runtimeSpecs	"This method is added to and removed from PreferenceInitializers in FileOut30's postLoad and postUnload actions, in commands that then run UISettings updateAllPreferences."	aDictionary		at: #fileInDefaultNamespace		put: (self preferenceModelFor: #fileInDefaultNamespace default: #Smalltalk).</body></methods><methods><class-id>Kernel.XMLSourceFileFormat class</class-id> <category>printing</category><body package="FileOut30">label	^#XMLFormat &lt;&lt; #dialogs &gt;&gt; 'XML Format'</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="FileOut30">bundleProperties: aDictionary for: aPackageModel	self targetFile == nil		ifFalse:			[ self targetFormatter				bundleProperties: aDictionary				for: aPackageModel				on: self].</body><body package="FileOut30">packageProperties: aDictionary for: aPackageModel	self targetFile == nil		ifFalse:			[ self targetFormatter				packageProperties: aDictionary				for: aPackageModel				on: self].</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="FileOut30">printMethodBody: code withSelector: aSymbol for: aClass 	"Print the source code for the method."	self targetFormatter		methodSelector: aSymbol		body: code		class: aClass		attributes: nil		on: self targetFile		for: self</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="FileOut30">fileOutOn: aFileManager 	"File out the bundle on aFileManager."	aFileManager addComment: 'Bundle ' , self itemString.	( ( StoreSettings preferenceFor: #fileoutOption ) == #never )		ifFalse: [ self fileOutPropertiesOn: aFileManager ].	self containedItems do: [ :comp | 		aFileManager deferInitializations.		comp fileOutOn: aFileManager.		aFileManager finishInitializations].</body><body package="FileOut30">fileOutPropertiesOn: aFileManager		| props |	props := self propertiesForFileOut.	aFileManager bundleProperties: props for: self.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="FileOut30">fileOutPropertiesOn: aFileManager		| props |	props := self propertiesForFileOut.	aFileManager packageProperties: props for: self.</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-files</category><body package="FileOut30">files10fileOutType	"Not all SourceFileFormat subclasses are resolvable in Smalltalk from their simpleNames so we must use fullNames."	&lt;setting: #(files fileOutType)&gt;	| concreteFormats |	concreteFormats := SourceFileFormat allSubclasses select: [:each | each class selectors includes: #label].	^((EnumerationSetting				choices: (concreteFormats collect: [:each | ((each isVisibleIn: Smalltalk) ifTrue: [each name] ifFalse: [each fullName]) asSymbol])				labels: (concreteFormats collect: [:each | each label]))			onUISetting: #fileOutType)		default: #XMLSourceFileFormat;		label: #DefaultFileOutType &lt;&lt; #labels &gt;&gt; 'Default file-out type';		helpText: #DefaultFileOutTypeWithFileOut30HelpText &lt;&lt; #dialogs &gt;&gt; 'There are several formats to use for file-outs: the two native VisualWorks formats and the formats for prior versions and other dialects. The setting on this page controls which of these formats is used by programming tools that do not control this feature themselves, principally file-out (file-in uses #canFormatStream: to decide the appropriate setting for a given file''s code).Smalltalk chunk format saves Smalltalk programs in a form similar to that used in previous versions of VisualWorks, with Smalltalk expressions separated by exclamation marks. (NameSpace-influenced features, e.g. class definitions, are not file-out-compatible with old pre-NameSpace VisualWorks releases.)XML format saves Smalltalk programs using an XML markup set designed to capture more detailed meta-information about the program than Smalltalk chunk format, so it supports more powerful tools for manipulating source files. (Performance differences between it and chunk are completely invisible for all ordinary purposes; if you had to search all source in files containing 30,000 classes and their methods, chunk would be faster than XML.)WARNING: The remaining formats are provided for compatibility with other dialects, are not fully supported, lack documentation, and almost certainly have problems in some edge cases. These formats allow you to read or write package formats from some other dialects with as much information as possible preserved between them. For all of these formats there are some conventions observed.  - A prerequisite of the form &lt;Name&gt;&lt;Dialect&gt;Port will be transformed appropriately on file-in or file-out, where dialect is one of VW, VA, or Dolphin. So, for example, a FooVWPort package would become a FooDolphinPort package if filed out in Dolphin format.  - On file-in, some properties are preserved. The most notable example is ENVY prerequisites. On file-in of an ENVY application, any prerequisites whose names did not correspond to packages in the image are preserved in the envyPrerequisites variable and will be added back into the prerequisite list on file-out in ENVY format.  - These formats do not enforce valid syntax in the target dialect. For example, an ENVY application cannot have whitespace in its name, and a hyphen in a Dolphin method category indicates a hierarchical category. The system will attempt to compensate for some of these known differences, but in general you are responsible for writing portable code.  - These formats were initially developed and tested on file-in/out of complete packages/applications. They have also been exercised, but less rigorously, on file-in/out of differences between packages, and of individual classes and methods.VW 3.0 formats: these supports file-out only (file-in uses current chunk format) to pre-namespace versions of VW (tested with the latest, VW3.0). The non-Envy and Envy formats are almost identical; the latter synchs with Envy when a file-out of differences or changes deletes a method; the former bypasses Envy in that case, leaving the image inconsistent (for file-in to Envy images set System genericFormat: true.Squeak format (contributed by Roel Wuyts) should be compatible with standard Pharo and Squeak file-ins.  This version uses := for assignment, not underscore.VASmalltalk-compatible format can read and write VASmalltalk .app format files. A complete Store package can be filed out to a VisualAge application and vice versa. Namespace information will be removed, and as much package information as possible will be preserved. This format is tested against current versions of VASmalltalk, but should also work with little or no modification for older versions. It is also possible to file out a complete bundle with this format and get a single file which can recreate all of the component packages as applications (note that this does not at the moment attempt to create configuration maps or version the resulting code). Classes and methods filed out from VASmalltalk with the default System genericFormat: false setting can also be filed in using this format and vice versa. File-in to a VW 3.0 Envy images with the same setting may work (not fully tested); file-outs from such images will not be recognised by this format.Dolphin 4.0-compatible format writes and reads the .pac files of Dolphin Smalltalk. These files should be directly loadable into a Dolphin image as packages.'</body><body package="FileOut30">files11DefaultNamespace	&lt;setting: #(files defaultNameSpace)&gt;	^(StringSetting onUISetting: #fileInDefaultNamespace)		default: 'Smalltalk';		label: 'Default File-in Namespace';		helpText: 'If filed-in code is unqualified, file-in declares new bindings in this namespace and starts the search for existing bindings from this namespace.  (File-ins from VASmalltalk automatically add XProgramming.SUnit to the search path.)'.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>SourceFileFormat</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectProperties methodProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>ClassCategoryReader</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class category </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>RBConfigurableFormatter</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeStream indent lookaheadCode originalSource lineStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-ConfigurableFormatter</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ChunkSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SourceCodeStream</name><environment>Kernel</environment><super>Kernel.SourceFileManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classesToInitialize methodChunkClass methodProtocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SmalltalkCompiler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceStream requestor class targetClass environment context methodClass allowSelfReferences allowClassVariableReferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class></st-source>