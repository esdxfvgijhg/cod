<?xml version="1.0"?><st-source><!-- Name: RBDynamicRefactoringUINotice: Copyright 2003 - 2015 John Brant, Niall Ross, Adriaan van OsThis utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This goodie uses method wrappers to analyse method call sites to support method renaming.  It offers dynamic renaming as a middle alternative (Rename some...) when a static rename raises a 'multiple implementors' warning dialog, showing e.g.	This will refactor all of the 3 implementors and 5 senders of		#initializeFor:	Do you want to proceed?		Yes	Rename Some...	NoSelecting the middle option opens a multi-page step-by-step UI with detailed instructions (which also advise users about the powers and perils of method wrappers).  Users then run tests or exercise code by hand and the system records which implementors were used in which locations.  The user can also supply that information directly via a pop-up menu on the call site page.  The system warns if there are true polymorphic cases requiring hand rewrite.  At any point, the user can inspect the refactoring code generated so far and execute it.Remarks=======Do not load if you do not want Method Wrappers Base in your image.  Read that parcel's comment if unfamiliar with method wrappers.Using this goodie to rename a selector makes sense if you have a good test set for that selector or can exercise it adequately by hand or are confident you can provide the information for any unresolved call sites.See RBDynamicRefactorings comment for more information.If you wish to be able to invoke dynamic renaming directly from the menu, implement the following extension to add a 'Dynamic Rename' option to the RB's 'Method' menu.BrowserNavigator>>dynamicRename	"In the custom refactoring project, dynamic renaming is offered as a third alternative when a static rename receives a 'multiple implementors' warning.  This pragma lets you invoke dynamic renaming directly from the menu."	<menuItem: 'Dynamic Rename'		icon: nil		nameKey: #dynamicRename		enablement: #isSelectorSelected		indication: nil		menu: #(#selectorMenu)		position: 40.031>	(DynamicRenameMethodUI new		open;		selectorHolder) value: self selectorDbIdentifier: bear73DbTrace: 491490DbUsername: nrossDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'Browser-BrowserUI' '') #(#any 'RBDynamicRefactorings' ''))PackageName: RBDynamicRefactoringUIParcel: #('RBDynamicRefactoringUI')ParcelName: RBDynamicRefactoringUIPrerequisiteParcels: #(#('Browser-BrowserUI' '') #('RBDynamicRefactorings' ''))PrintStringCache: (8.2 - 1,nross)Version: 8.2 - 1Date: 1:31:06 PM June 3, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.1) of June 3, 2016 on June 3, 2016 at 1:31:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DynamicRenameMethodUI</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>implementorsList selectorHolder renameMethodTransformation callSiteList receiversList sourceHolder newSelectorHolder page textController </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBDynamicRefactoringUI</category><attributes><package>RBDynamicRefactoringUI</package></attributes></class><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>aspects</category><body package="RBDynamicRefactoringUI">callSiteList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^callSiteList isNil		ifTrue:			[callSiteList := SelectionInList new]		ifFalse:			[callSiteList]</body><body package="RBDynamicRefactoringUI">implementorsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^implementorsList isNil		ifTrue:			[implementorsList := MultiSelectionInList new]		ifFalse:			[implementorsList]</body><body package="RBDynamicRefactoringUI">newSelectorHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^newSelectorHolder isNil		ifTrue:			[newSelectorHolder := nil asValue]		ifFalse:			[newSelectorHolder]</body><body package="RBDynamicRefactoringUI">receiversList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^receiversList isNil		ifTrue:			[receiversList := SelectionInList new]		ifFalse:			[receiversList]</body><body package="RBDynamicRefactoringUI">selectorHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectorHolder isNil		ifTrue:			[selectorHolder := nil asValue]		ifFalse:			[selectorHolder]</body><body package="RBDynamicRefactoringUI">sourceHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sourceHolder isNil		ifTrue:			[sourceHolder := String new asValue]		ifFalse:			[sourceHolder]</body><body package="RBDynamicRefactoringUI">subcanvas	^self</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>interface opening</category><body package="RBDynamicRefactoringUI">postBuildCallSiteList: aBuilder 	| block specWidget |	specWidget := aBuilder componentAt: #callSiteList.	specWidget isNil ifTrue: [^self].	block := 			[:view :index | 			| item callSite |			callSite := view sequence at: index.			item := callSite displayString asText.			callSite hasBeenExecuted 				ifFalse: [item emphasizeAllWith: (Array with: #color -&gt; ColorValue red)].			Label with: item attributes: view textStyle].	(specWidget widget)		visualBlock: (self createVisualBlockFrom: block);		selectedVisualBlock: (self createSelectedVisualBlockFrom: block)</body><body package="RBDynamicRefactoringUI">postBuildImplementorsList: aBuilder 	| block specWidget |	specWidget := aBuilder componentAt: #implementorsList.	specWidget isNil ifTrue: [^self].	block := 			[:view :index | 			Label with: (view sequence at: index) fullName attributes: view textStyle].	(specWidget widget)		visualBlock: (self createVisualBlockFrom: block);		selectedVisualBlock: (self createSelectedVisualBlockFrom: block)</body><body package="RBDynamicRefactoringUI">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	(aBuilder componentAt: #sourceHolder) 		ifNotNil: [:each | textController := each widget controller].	self postBuildImplementorsList: aBuilder.	self postBuildCallSiteList: aBuilder</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>initialize-release</category><body package="RBDynamicRefactoringUI">initialize	super initialize.	page := 1.	renameMethodTransformation := DynamicRenameMethod new.	self selectorHolder value: #''.	self newSelectorHolder value: #''.	self selectorHolder onChangeSend: #changedSelector to: self.	self newSelectorHolder onChangeSend: #changedNewSelector to: self.	self implementorsList selectionIndexHolder 		onChangeSend: #changedImplementorsSelection		to: self.	self callSiteList selectionIndexHolder 		onChangeSend: #changedCallSiteSelection		to: self</body><body package="RBDynamicRefactoringUI">rename: oldMethodSelector to: newMethodSelector in: targetClass	self selectorHolder value: oldMethodSelector.	self newSelectorHolder value: newMethodSelector.	self implementorsList selections: (Array with: targetClass).	self next</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>changing</category><body package="RBDynamicRefactoringUI">changedCallSiteSelection	| callSite |	callSite := self callSiteList selection.	callSite isNil 		ifTrue: 			[self receiversList list: List new.			self sourceHolder value: ''.			^self].	self receiversList list: callSite receivers asList.	self sourceHolder value: callSite source.	textController notNil 		ifTrue: 			[textController selectFrom: callSite sourceInterval first				to: callSite sourceInterval last.			textController view displaySelection: true.			textController view selectAndScroll]</body><body package="RBDynamicRefactoringUI">changedImplementorsSelection	self updateSelectorPageNextButton</body><body package="RBDynamicRefactoringUI">changedNewSelector	self updateSelectorPageNextButton</body><body package="RBDynamicRefactoringUI">changedSelector	"Warn user?"	self showWaitCursorWhile: 			[renameMethodTransformation oldSelector: self selectorHolder value.			self implementorsList 				list: (renameMethodTransformation allImplementors 						asSortedCollection: [:a :b | a fullName &lt; b fullName]) asList.			self updateSelectorPageNextButton]</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>interface closing</category><body package="RBDynamicRefactoringUI">noticeOfWindowClose: aWindow 	renameMethodTransformation tearDownAnalysis.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>private</category><body package="RBDynamicRefactoringUI">canSwitchToPage: pageIndex 	^pageIndex between: 1 and: self pages size</body><body package="RBDynamicRefactoringUI">helpText	^'Dynamic renaming uses method wrappers, a powerful mechanism but one that can corrupt your image if used rashly.  Closing this UI at any time uninstalls the method wrappers from your system.  Unless you are familiar with method wrappers, I advise:&lt;n&gt;&lt;t&gt;- save any work you must not lose (first closing this UI to uninstall the wrappers !!) before proceeding&lt;n&gt;&lt;t&gt;- do not leave this UI open for a long time while doing unrelated work;  run operations that call the method you want to rename, then proceed to completion.&lt;n&gt;&lt;n&gt;The list above shows all call sites for the polymorphic method being renamed.  When the method is called at any of these sites, the wrappers capture this.  You should now run tests, scripts or utilities to exercise the method(s) you want to rename.  Then use the ''Refresh List Display'' menu item (or just refresh the window) to see all captured call sites turn from red to black in the list above.&lt;n&gt;&lt;n&gt;Selecting a captured site shows its receivers list.  To supplement your tests (or as an alternative to them), you can use the ''Rename *'' menu items to force adding the implementor you want to rename to the receivers list of the selected call site, or of all call sites sharing its scope.&lt;n&gt;&lt;n&gt;This tool can be a useful coding accelerator even when your tests and actions do not turn all call sites black.  Even if all do turn black, the change is only a refactoring if the computed receivers'' list is complete enough;  how confident are you that running more tests would not call a clashing method at some call site?  When you judge that you have captured enough data at all relevant sites, or as much as you can hope for, go to the next page, inspect the generated refactorings if you wish, and apply them.&lt;n&gt;&lt;n&gt;The previous page shows all implementors of the method;  the implementor(s) selected will be renamed.  Visiting it will clear and reset the above call site analysis (so don''t unless that is what you want).  Power users can use it to change the selection(s) and/or the method to be renamed.' expandMacros</body><body package="RBDynamicRefactoringUI">installInspectorPage	| inspector |	renameMethodTransformation		tearDownAnalysis;		renameMethods.	inspector := CompositeRefactoryChangeInspector new initializeDialogMenu.	inspector initializeFor: renameMethodTransformation changes.	self 		installSubcanvasIn: #subcanvas		using: inspector		spec: #windowSpec.	inspector setPseudoDialog: self.</body><body package="RBDynamicRefactoringUI">installInstrumentationPage	renameMethodTransformation		implementors: self implementorsList selections;		newSelector: self newSelectorHolder value;		setupAnalysis.	self callSiteList list:		(renameMethodTransformation allCallSites			asSortedCollection: CallSite sortBlock) asList.	self		installSubcanvasIn: #subcanvas		usingselfspec: #instrumentationSpec.	self sourceHolder value: self helpText.</body><body package="RBDynamicRefactoringUI">installSelectorPage	renameMethodTransformation tearDownAnalysis.	self		installSubcanvasIn: #subcanvas		usingselfspec: #selectorPageSpec.</body><body package="RBDynamicRefactoringUI">pages	^#(#installSelectorPage #installInstrumentationPage #installInspectorPage)</body><body package="RBDynamicRefactoringUI">postApply	self previous.	self sourceHolder value: self postApplyText.</body><body package="RBDynamicRefactoringUI">postApplyText	^'You have chosen to keep the UI open, either&lt;n&gt;&lt;t&gt;1) to do some final work on call sites&lt;n&gt;or&lt;n&gt;&lt;t&gt;2) to drive it as a power user.&lt;n&gt;&lt;n&gt;1) The identified call sites have been rewritten and the selected methods have been renamed, so you can no longer run them under their original names to identify further call sites in the above list.  You can however use the menu to identify any more call sites you want rewritten.  You can also rerun tests, or run more tests, to see which unrenamed implementors appear as receivers at the above call sites.  If (and only if) one or more call sites are identified for rewriting, you can go to the next page to apply the refactorings.&lt;n&gt;&lt;n&gt;2) If you want to drive the UI as a power user, go to the previous page and type in a selector name and proposed rename to get a new implementors list, thus clearing the no-longer-accurate current list.  Then select the implementor(s) you want to rename and go to the next page.' expandMacros</body><body package="RBDynamicRefactoringUI">switchToPage: pageIndex 	(self canSwitchToPage: pageIndex) ifFalse: [^self].	self handleError:			[self perform: (self pages at: pageIndex).			page := pageIndex.			page = 1 				ifTrue: [self disable: #previousButton]				ifFalse: [self enable: #previousButton].			page = self pages size 				ifTrue: 					[self						disable: #nextButton;						enable: #executeAllButton]				ifFalse: 					[self						enable: #nextButton;						disable: #executeAllButton]]</body><body package="RBDynamicRefactoringUI">updateSelectorPageNextButton	(self selectorHolder value notEmpty and: 			[self newSelectorHolder value notEmpty and: 					[self selectorHolder value numArgs = self newSelectorHolder value numArgs 						and: [self implementorsList selections notEmpty]]]) 		ifTrue: [self enable: #nextButton]		ifFalse: [self disable: #nextButton]</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>actions</category><body package="RBDynamicRefactoringUI">apply	"After applying, ask the user if they're done.  If so, close the display.  If not, update it.  Power users may want to use the UI iteratively, eliciting some call sites and applying the resulting refactorings, then returning to the analysis page to see what more may be done."	self performChange: renameMethodTransformation changes.	(self confirm: 'All refactorings in list applied.&lt;n&gt;Close this dynamic rename UI (i.e. we''re done)?' expandMacros)		ifTrue: [self closeRequest]		ifFalse: [self postApply].</body><body package="RBDynamicRefactoringUI">next	self switchToPage: page + 1</body><body package="RBDynamicRefactoringUI">previous	self switchToPage: page - 1</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>static transformations</category><body package="RBDynamicRefactoringUI">renameAtAllCallSitesInSelectedClass	| selectedCallSite |	selectedCallSite := self callSiteList selection.	(self callSiteList list 		select: [:each | each method mclass == selectedCallSite method mclass]) 			do: [:each | renameMethodTransformation renameAtCallSite: each].	self changedCallSiteSelection.	self redisplayCallSiteList.</body><body package="RBDynamicRefactoringUI">renameAtAllCallSitesInSelectedMethod	| selectedCallSite |	selectedCallSite := self callSiteList selection.	(self callSiteList list select: [:each | each method homeMethod == selectedCallSite method homeMethod])		do: [:each | renameMethodTransformation renameAtCallSite: each].	self changedCallSiteSelection.	self redisplayCallSiteList.</body><body package="RBDynamicRefactoringUI">renameAtSelectedCallSite	renameMethodTransformation renameAtCallSite: self callSiteList selection.	self changedCallSiteSelection.	self redisplayCallSiteList.</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI</class-id> <category>subcanvases</category><body package="RBDynamicRefactoringUI">installSubcanvasIn: aSymbol usingselfspec: aSpec	"Callers of this method used to call installSubcanvas:using:spec: with second parameter == self, wrapping the super call with code to save and reset the builder, i./e. protecting from the call of resetBuilder on the second parameter.  Changes to the super implementation meant that the receiver needed its builder within the supercall after resetBuilder sent to the second parameter meant that it had temporarily lost it.  Thus we inlined to this method for that case.  The ugly method name is meant to suggest this history.	Push this up to BrowserApplicationModel for more general use as and when needed (but no further, unless the dropped respondsTo:/isKindOf: guards are first restored.)"		| oldBuilder component |	builder isNil ifTrue: [^self].	oldBuilder := builder.	component := builder componentAt: aSymbol.	self resetBuilder.	component notNil ifTrue:		[component widget client: self spec: aSpec builder: oldBuilder newSubBuilder].	self updateDisplay.	builder := oldBuilder.</body><body package="RBDynamicRefactoringUI">redisplayCallSiteList	"We refrain from having the wrapper call this each time it is invoked, as that would embed a UI change call into code that could be wrapping almost any method.  Instead, a menu item reminds the user that the wrappers may have updated the call site display.  There should be (and maybe is) a neater way of accessing the widget and/or doing the redisplay."	self callSiteList list myDependents invalidate.</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI class</class-id> <category>instance creation</category><body package="RBDynamicRefactoringUI">rename: oldMethodSelector to: newMethodSelector in: targetClass	self new		open;		rename: oldMethodSelector to: newMethodSelector in: targetClass;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring</class-id> <category>preconditions</category><body package="RBDynamicRefactoringUI">dynamicRenameMethodUIBlock	"Parameter block for warnings and errors;  if static renaming has problems, provide a block the user can evaluate to pursue dynamic renaming.  We must get the current refactoring's values directly, not via accessors, since self class does not mean what we want."	^	[DynamicRenameMethodUI		rename: oldSelector		to: newSelector		in: class realClass]</body><body package="RBDynamicRefactoringUI">offerReviewChangesOption	"Change the third option from the superclass' implementation (inspecting the proposed changes) to renaming selected implementors by running code and/or selecting send sites.  Do this by launching the dynamic rename UI with the current refactoring's values."	^#RenameSomeDots &lt;&lt; #browser &gt;&gt; 'Rename Some...'		-&gt; self dynamicRenameMethodUIBlock</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChangeInspector</class-id> <category>accessing</category><body package="RBDynamicRefactoringUI">setPseudoDialog: anExecuteButtonHoldingApplicationModel	"Enable and disable the parameter's 'Execute All' button, just as if it was an enclosing SimpleDialog."	dialog := anExecuteButtonHoldingApplicationModel."The parameter will also get a close request when we close (which may be as a result of the parameter's being closed and so sending close to us as a subcomponent of it), so it had better be OK with that.  These are the only two messages it will be sent, currently:  obviously, any developments of this class that add to the methods sent to dialog may cause this optimistic polymorphism to develop problems."</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI class</class-id> <category>interface specs</category><body package="RBDynamicRefactoringUI">instrumentationSpec	"Tools.UIPainter new openOnClass: self andSelector: #instrumentationSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 700 525 1377 1030 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 10 ) 					#name: #Label1 					#label: 'Call Sites:' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.666666 0 0 2 0.666666 2 0.5 ) 					#name: #splitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'callSiteList' 					#belowWidgets: 'Label2 receiversList' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 2 0.666666 10 0 ) 					#name: #Label2 					#label: 'Receivers:' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.666666 31 0 -10 1 -2 0.5 ) 					#name: #receiversList 					#model: #receiversList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.5 0 1 2 0.5 ) 					#name: #splitter2 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'callSiteList splitter1 receiversList' 					#belowWidgets: 'Label3 sourceHolder' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 7 0.5 ) 					#name: #Label3 					#label: 'Source:' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 33 0.5 -10 1 -10 1 ) 					#name: #sourceHolder 					#model: #sourceHolder 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 31 0 -2 0.666666 -2 0.5 ) 					#name: #callSiteList 					#flags: 15 					#model: #callSiteList 					#menu: #callSiteMenu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body><body package="RBDynamicRefactoringUI">selectorPageSpec	"UIPainter new openOnClass: self andSelector: #selectorPageSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1477 1105 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 120 0 55 0 1 0 ) 					#name: #Label1 					#label: 'Old Selector:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 55 0 -20 1 78 0 ) 					#name: #selectorHolder 					#model: #selectorHolder 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 120 0 84 0 1 0 ) 					#name: #Label3 					#label: 'New Selector:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 84 0 -20 1 107 0 ) 					#name: #newSelectorHolder 					#model: #newSelectorHolder 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 120 0 120 0 1 0 ) 					#name: #Label2 					#label: 'Implementors:' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 120 0 -20 1 -20 1 ) 					#name: #implementorsList 					#model: #implementorsList 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body><body package="RBDynamicRefactoringUI">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dynamic Rename Method' 			#bounds: #(#{Graphics.Rectangle} 800 600 1477 1105 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -35 1 ) 					#name: #subcanvas 					#flags: 0 					#minorKey: #selectorPageSpec 					#clientKey: #subcanvas ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -33 1 -2 1 -31 1 ) 					#name: #Divider1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -336 1 -25 1 -255 1 -2 1 ) 					#name: #previousButton 					#flags: 40 					#model: #previous 					#label: 'Previous' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -253 1 -25 1 -172 1 -2 1 ) 					#name: #nextButton 					#flags: 40 					#model: #next 					#label: 'Next' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -168 1 -25 1 -87 1 -2 1 ) 					#name: #executeAllButton 					#flags: 40 					#model: #apply 					#label: 'Execute All' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -25 1 -4 1 -2 1 ) 					#name: #cancelButton 					#model: #closeRequest 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Refactory.Browser.DynamicRenameMethodUI class</class-id> <category>resources</category><body package="RBDynamicRefactoringUI">callSiteMenu	"Tools.MenuEditor new openOnClass: self andSelector: #callSiteMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #( 			#(#{UI.MenuItem} 				#rawLabel: 'Refresh List Display' 				#nameKey: #redisplayAllCallSitesStatus 				#value: #redisplayCallSiteList )			#(#{UI.MenuItem} 				#rawLabel: 'Rename Selected' 				#nameKey: #renameAtSelectedCallSite 				#value: #renameAtSelectedCallSite ) 			#(#{UI.MenuItem} 				#rawLabel: 'Rename All In Method' 				#nameKey: #renameAtAllCallSitesInSelectedMethod 				#value: #renameAtAllCallSitesInSelectedMethod ) 			#(#{UI.MenuItem} 				#rawLabel: 'Rename All In Class' 				#nameKey: #renameAtAllCallSitesInSelectedClass 				#value: #renameAtAllCallSitesInSelectedClass ) ) #(1 3 ) nil ) decodeAsLiteralArray</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>RenameMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ChangeMethodNameRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasPermutedArguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><class><name>BrowserApplicationModel</name><environment>Refactory.Browser</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-RB UI</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>CompositeRefactoryChangeInspector</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeDescription changeTree originalCode change dialog changesMenu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings UI</category><attributes><package>Browser-RefactoringUI</package></attributes></class></st-source>