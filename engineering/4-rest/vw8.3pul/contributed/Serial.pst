<?xml version="1.0"?><st-source><!-- Name: SerialHideSource: falseParcel: SerialSaveSource: trueDate: 4:13:10 pm January 9, 2001 --><time-stamp>From VisualWorksÂ®, Release 5i.2 apr00.2 of May 23, 2000 on January 9, 2001 at 4:13:10 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MacTtyOptions</name><environment>OS</environment><super>Core.UninterpretedBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Mac</category></class><comment><class-id>OS.MacTtyOptions</class-id><body>I represent a Mac tty options structure--what the Macintosh refers to as a SerShk; I communicate tty options (through a MacTtyAccessor) to the tty driver. byte 1 -- output flow control (0:none, 1:XON/XOFF)byte 2 -- CTS handshaking flag (0:none, 1:XON/XOFF)byte 3 -- XON characterbyte 4 -- XOFF characterbyte 5 -- errorsbyte 6 -- status changesbyte 7 -- input flow control (0:none, 1:XON/XOFF)byte 8 -- DTR input controlbytes 9-10 -- unsigned short		bits: 0-9		-- baud rate		bits: 10-11		-- bits per character		bits: 12-13		-- parity		bits: 14-15		-- stop bitsClass variables:	PortSizes	&lt;IdentityDictionary&gt; Maps port width codes to the number of bits per character	Speeds		&lt;IdentityDictionary&gt; Maps speed codes to baud rates	StopBits	&lt;IdentityDictionary&gt; Maps stop bits codes to the number of stop bits</body></comment><class><name>UnixTtyOptions</name><environment>OS</environment><super>Core.UninterpretedBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category></class><comment><class-id>OS.UnixTtyOptions</class-id><body>Class UnixTtyOptions is an abstract class.  Instances of subclasses are used to communicate tty options (through a UnixTtyAccessor) to the Unix tty driver.  Example subclasses are BsdTtyOptions and Sys5TtyOptions.Subclasses must implement:	accessing		echo:		parity:	utilities		setBinary		setGlassCooked	private-accessing		disciplineCode		disciplineCode:		speedCode		speedCode:Class Variables:	Disciplines	&lt;IdentityDictionary&gt; Maps discipline codes to symbols (e.g. old vs. new tty)	Speeds		&lt;IdentityDictionary&gt; Maps speed codes to baud rates (e.g. 9 is 1200 baud)</body></comment><class><name>BsdTtyOptions</name><environment>OS</environment><super>OS.UnixTtyOptions</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category></class><comment><class-id>OS.BsdTtyOptions</class-id><body>Class BsdTtyOptions represents a bsd tty options structure -- but unfortunately, bsd doesn't really have just one.  So we jammed all of them together to make something like the sys5 termio struct:struct bogus_termio {	long b_discipline;			/* line discipline */	struct /* sgttyb */ {		char sg_ispeed;			/* input speed */		char sg_ospeed;		/* output speed */		char sg_erase;			/* erase character */		char sg_kill;			/* kill character */		short sg_flags;			/* flags */	} b_sgttyb;	u_char b_tchars[6];		/* more control chars */	long b_localMode;			/* local modes */	u_char b_ltchars[6];		/* yet more control chars */};To know what all these fields really signify, see the man pages for TTY(4).Class Variables:	LocalModes		&lt;IdentityDictionary&gt;	SgFlags			&lt;IdentityDictionary&gt;</body></comment><class><name>UnixTtyAccessor</name><environment>OS</environment><super>OS.UnixIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category></class><comment><class-id>OS.UnixTtyAccessor</class-id><body>Deals with the behavior common to both pty's and real serial ttys, that is -- driver control.Class Variables:	OptionClass		&lt;UnixTtyOptions class | nil&gt; depending on which platform is being used</body></comment><class><name>UnixPseudoTtyAccessor</name><environment>OS</environment><super>OS.UnixTtyAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category></class><comment><class-id>OS.UnixPseudoTtyAccessor</class-id><body>A pseudo-tty exists almost exclusively for interprocess communications with subfors which want to talk to terminals.  Instances are like other IOAccessors except they can't be positioned and don't signal semaphores predictably.</body></comment><class><name>MacTtyAccessor</name><environment>OS</environment><super>OS.MacIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Mac</category></class><comment><class-id>OS.MacTtyAccessor</class-id><body>Class MacTtyAccessor represents the interface to the Macintosh Serial Driver.  It provides access to the "modem" and "printer" ports of the Macintosh.  In one form or another, it provides functionality equivalent to the specifications for the Serial Drivers described in "Inside Macintosh", Volume II, pages 245-260.</body></comment><class><name>UnixRealTtyAccessor</name><environment>OS</environment><super>OS.UnixTtyAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category></class><comment><class-id>OS.UnixRealTtyAccessor</class-id><body>Accessors for real "serial line" devices.  Specialized behavior includes modem control.Class Variables:	DefaultPort		&lt;ByteString&gt; the initial pathway information</body></comment><class><name>Sys5TtyOptions</name><environment>OS</environment><super>OS.UnixTtyOptions</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category></class><comment><class-id>OS.Sys5TtyOptions</class-id><body>ClassSys5TtyOptions represents a sys5 tty options structure:struct termio {	unsigned short c_iflag;		/* input modes */	unsigned short c_oflag;		/* output modes */	unsigned short c_cflag;		/* control modes */	unsigned short c_lflag;		/* local modes */	char c_line;					/* line discipline */	unsigned char c_cc[NCC];	/* control chars */};To know what all these fields really signify, see the man pages for TERMIO.Instance Variables:  *byte indexed*	Class Variables:	ControlModes	&lt;IdentityDictionary&gt;	InputModes		&lt;IdentityDictionary&gt;	LocalModes		&lt;IdentityDictionary&gt;	OutputModes 	&lt;IdentityDictionary&gt;</body></comment><class><name>PCTtyAccessor</name><environment>OS</environment><super>OS.PCIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category></class><class><name>OS2TtyAccessor</name><environment>OS</environment><super>OS.PCTtyAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-OS/2</category></class><comment><class-id>OS.OS2TtyAccessor</class-id><body>Instances of class OS2TtyAccessor are io-accessors for OS/2 "serial line" devices.  Specialized behavior includes modem control.</body></comment><class><name>OS2TtyOptions</name><environment>OS</environment><super>Core.UninterpretedBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-OS/2</category></class><comment><class-id>OS.OS2TtyOptions</class-id><body>Class OS2TtyOptions represents a OS/2 tty options structure.  Instances of the class communicate tty options (through a OS2TtyAccessor) to the tty driver.byte 1-4 -- baud ratebyte 5 -- baud rate fraction (normally 0)byte 6 -- dataBits (5,6,7,8)byte 7 -- parity (0:none, 1 : odd, 2:even, 3: mark (always 1) 4: space (always 0))byte 8 -- stopBits (0:1, 1:1.5 (only for 5 bit word) 2: 2 (not with 5 bit word))byte  9-10 write timeoutbyte 11-12 read timeoutbyte 13 Flags1 (Handshake)byte 14 Flags2 (Flow)byte 15 Flags3 (Buffer)byte 16 Error replacement charbyte 17 Break replacement charbyte 18 XON charbyte 19 XOFF charThe "Note X" referred to are in the OS/2 online CP Reference.Flags: Flags1        Has the following bits:     0-1           DTR Control Mode.  See Note 1.                                        Bit 1    Bit 0    Description                     0        0       Disable                     0        1       Enable                     1        0       Input handshaking                     1        1       Invalid input, resulting in a general failure error                                          Bit 2         Reserved.  Set to 0.     Bit 3         Enable output handshaking, using CTS. See Note 3.     Bit 4         Enable output handshaking, using DSR. See Note 3.     Bit 5         Enable output handshaking, using DCD. See Note 3.     Bit 6         Enable input sensitivity, using DSR. See Note 4.     Bit 7         Reserved.  Set to zero.    Flags2        Has the following bits:     Bit 0         Enable Automatic Transmit Flow Control (XON/XOFF). See Note 2.     Bit 1         Enable Automatic Receive Flow Control (XON/XOFF). See Note 2.     Bit 3         Enable error replacement character. See Note 5.     Bit 4         Enable break replacement character. See Note 7.     Bit 5         Automatic Receive Flow Control:                    1     1       Automatic Protocol Override.    Bits 6-7      RTS Control Mode. See Note 1.                     Bit 7    Bit 6    Description                     0        0       Disable                     0        1       Enable                     1        0       Input handshaking                     1        1       Toggling on transmit"                                         Flags3        Has the following bits:     Bit 0         Enable Write Timeout processing. Note 8.     Bits 1-2      Enable Read Timeout processing. Note 9.                     Bit 2    Bit 1    Description                     0        0       Invalid input.  Results in a general failure error.                     0        1       Normal Read Timeout processing                     1        0       Wait-For-Something Read Timeout processing                     1        1       No-Wait Read Timeout processing                                          Bits 3-4      Extended Hardware Buffering.  See Note 10.                     Bit 4    Bit 3    Description                     0        0       Not supported; ignored.  No change to FIFO state.                     0        1       Disabled                     1        0       Enabled                     1        1       Automatic Protocol Override                       Bits 5-6      Received trigger level.  See Note 11.                     Bit 6    Bit 5    Description                     0        0       1 character                     0        1       4 characters                     1        0       8 characters                     1        1       14 characters                                      Note:  The trigger level must be set to 1 character when the enhanced mode is on.     Bit 7         Transmit Buffer Load Count.  See Note 12.                                       0 = 1 character                    1 = 16 characters                    Note:  When Extended Hardware Buffering is disabled, this bit is set by the device driver. </body></comment><static><name>InputModes</name><environment>OS.Sys5TtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>ControlModes</name><environment>OS.Sys5TtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>OutputModes</name><environment>OS.Sys5TtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>LocalModes</name><environment>OS.Sys5TtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>DefaultPort</name><environment>OS.UnixRealTtyAccessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>OptionClass</name><environment>OS.UnixTtyAccessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>Disciplines</name><environment>OS.UnixTtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>Speeds</name><environment>OS.UnixTtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>PortSizes</name><environment>OS.MacTtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>Speeds</name><environment>OS.MacTtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>StopBits</name><environment>OS.MacTtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>SgFlags</name><environment>OS.BsdTtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><static><name>LocalModes</name><environment>OS.BsdTtyOptions</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></static><methods><class-id>OS.MacTtyOptions</class-id> <category>accessing</category><body>bits	"Answer the data size of the port--between 5 and 8 bits"	^PortSizes at: (self statusWord bitAnd: 16rC00)</body><body>bits: aValue	"Set the data size of the port"	| codedValue |	(aValue between: 5 and: 8)		ifFalse:	[MacTtyAccessor errorReporter unsupportedOperationSignal raise].	codedValue := PortSizes keyAtValue: aValue.	^self statusWord: (self set: codedValue in: self statusWord mask: 16rC00)</body><body>echo	"Answer echo mode."	^MacTtyAccessor unsupportedOperationSignal raiseRequest</body><body>echo: bool	"Set into/outof echo mode according to boolean arg."	^MacTtyAccessor unsupportedOperationSignal raiseRequest</body><body>inputFlowControl: bool	"Set input flow control for according to boolean arg."	self byteAt: 7 put: (bool ifTrue: [1] ifFalse: [0])</body><body>isFlowControlledInput	"Answer input flow control."	^(self byteAt: 7) = 1</body><body>isFlowControlledOutput	"Answer output flow control."	^(self byteAt: 1) = 1</body><body>isLineBuffered	"Answer if in line-buffered mode."	^false</body><body>isRaw	"Answer if in line-buffered mode."	^true</body><body>outputFlowControl: bool	"Set output flow control for according to boolean arg."	self byteAt: 1 put: (bool ifTrue: [1] ifFalse: [0])</body><body>parity	"Return the option value for tty parity. 	p = 1, odd parity. 	p = 0, even parity. 	p = nil, no parity."	| parity |	"For Mac OS:		 0 = none		1 = odd		2 = none		3 = even"	parity := (self statusWord bitAnd: 16r3000) bitShift: -12.	parity even		ifTrue:	[^nil].	parity = 1		ifTrue:	[^1]		ifFalse:	[^0]</body><body>parity: p 	"Set the option value for tty parity. 	p = 1, odd parity. 	p = 0, even parity. 	p = nil, no parity. 	Affects generation on output, and checking on input. 	returns self."	| parity |	"For Mac OS:		0 = none		1 = odd		2 = none		3 = even"	parity := 0.	p = 0		ifTrue:	[parity := 3].	p = 1		ifTrue:	[parity := 1].	self statusWord: (self set: (parity bitShift: 12) in: self statusWord mask: 16r3000)</body><body>raw: bool	"Set into/outof raw buffer mode according to boolean arg."	bool		ifTrue:	[self inputFlowControl: false; outputFlowControl: false; bits: 8; parity: nil]		ifFalse:	[self inputFlowControl: true; outputFlowControl: true; bits: 7]</body><body>speed	"Answer the line speed in baud."	^Speeds at: (self speedCode)</body><body>speed: s	"Set the line speed (baud)."	self speedCode: (Speeds keyAtValue: s)</body><body>stopBits	"Answer the stop bits of the port--1 or 2"	^StopBits at: (self statusWord bitAnd: 16rC000)</body><body>stopBits: aValue	"Set the stop bits of the port"	| codedValue |	(#(1 1.5 2) includes: aValue)		ifFalse:	[MacTtyAccessor errorReporter unsupportedOperationSignal raise].	codedValue := StopBits keyAtValue: aValue.	^self statusWord: (self set: codedValue in: self statusWord mask: 16rC000)</body></methods><methods><class-id>OS.MacTtyOptions</class-id> <category>utilities</category><body>isBinary	"See if the tty seems to be in binary mode"	^self bits = 8</body><body>setBinary	"Set modes suitable for binary data xfer."	self bits: 8;		stopBits: 1;		parity: nil;		raw: true;		inputFlowControl: false;		outputFlowControl: false</body><body>setDumbTerminal	"Set modes suitable for dumb terminal emulation	Turns on XON/XOFF flow control, and turns off all	other IO processing"	self bits: 8;		stopBits: 1;		parity: nil;		raw: true;		inputFlowControl: true;		outputFlowControl: true</body><body>setGlassCooked	"Set modes suitable for line-oriented crt emulation."	self bits: 7;		stopBits: 1;		raw: false</body></methods><methods><class-id>OS.MacTtyOptions</class-id> <category>printing</category><body>printOn: aStream	"Append to the argument aStream a sequence of characters that identifies the receiver."	super printOn: aStream.	aStream nextPut: $(.	self speed printOn: aStream.	aStream nextPutAll: ' baud, '.	self bits printOn: aStream.	aStream nextPutAll: ' bits, '.	self stopBits printOn: aStream.	aStream nextPutAll: ' stop bits, '.	self printParityOn: aStream.	aStream nextPutAll: ', '.	aStream nextPutAll: (self isRaw ifTrue: ['raw'] ifFalse: ['line-buffered']).	aStream nextPutAll: ', '.	aStream nextPutAll: (self isFlowControlledInput ifTrue: [''] ifFalse: ['no ']). 	aStream nextPutAll: 'input flow control, '.	aStream nextPutAll: (self isFlowControlledOutput ifTrue: [''] ifFalse: ['no ']). 	aStream nextPutAll: 'output flow control'.	aStream nextPut: $)</body><body>printParityOn: aStream	"Append to the argument aStream a sequence of characters that identifies the receiver's parity."	| p |	(p := self parity) == nil		ifTrue:	[aStream nextPutAll: 'no']		ifFalse:	[p = 1					ifTrue:	[aStream nextPutAll: 'odd']					ifFalse:	[aStream nextPutAll: 'even']].	aStream nextPutAll: ' parity'</body></methods><methods><class-id>OS.MacTtyOptions</class-id> <category>private</category><body>set: aValue in: aNumber mask: mask	^(aNumber maskClear: mask) bitOr: (aValue bitAnd: mask)</body><body>speedCode	^self statusWord bitAnd: 16r3FF</body><body>speedCode: aSpeedCode	self statusWord: (self set: aSpeedCode in: self statusWord mask: 16r3FF)</body><body>statusWord	^self unsignedShortAt: 9</body><body>statusWord: aWord	^self unsignedShortAt: 9 put: aWord</body></methods><methods><class-id>OS.MacTtyOptions class</class-id> <category>class initialization</category><body>initialize	"MacTtyOptions initialize"	PortSizes := IdentityDictionary new.	PortSizes at: 0 put: 5.	PortSizes at: 16r800 put: 6.	PortSizes at: 16r400 put: 7.	PortSizes at: 16rC00 put: 8.	StopBits := IdentityDictionary new.	StopBits at: 16r4000 put: 1.	StopBits at: 16r8000 put: 1.5.	StopBits at: 16rC000 put: 2.	self initSpeeds</body><body>initSpeeds	"Baud rates--Mac supports rates between 300 and	57600.  A baud rate of -1 says that the data rate	should be controlled by an external clock"	Speeds := IdentityDictionary new: 8.	Speeds at: 380 put: 300.	Speeds at: 189 put: 600.	Speeds at: 94 put: 1200.	Speeds at: 62 put: 1800.	Speeds at: 46 put: 2400.	Speeds at: 30 put: 3600.	Speeds at: 22 put: 4800.	Speeds at: 14 put: 7200.	Speeds at: 10 put: 9600.	Speeds at: 4 put: 19200.	Speeds at: 0 put: 57600.	Speeds at: 16r3FF put: -1</body></methods><methods><class-id>OS.MacTtyOptions class</class-id> <category>instance creation</category><body>new	^super new: 10</body></methods><methods><class-id>OS.UnixTtyOptions</class-id> <category>accessing</category><body>discipline	"Answer the line discipline (a Symbol)."	^Disciplines at: self disciplineCode ifAbsent: [#unknown]</body><body>discipline: aSymbol	"Assign the line discipline."	self disciplineCode: (Disciplines keyAtValue: aSymbol)</body><body>echo: bool	"Set into/outof echo mode according to boolean arg."	self subclassResponsibility</body><body>parity: p 	"Set the option value for tty parity. 	p = 1, odd parity. 	p = 0, even parity. 	p = nil, no parity. 	Affects generation on output, and checking on input. 	returns self."	self subclassResponsibility</body><body>speed	"Answer the line speed in baud."	^Speeds at: (self speedCode)</body><body>speed: s	"Set the line speed (baud)."	self speedCode: (Speeds keyAtValue: s)</body></methods><methods><class-id>OS.UnixTtyOptions</class-id> <category>utilities</category><body>setBinary	"Set modes suitable for binary data xfer."	self subclassResponsibility</body><body>setGlassCooked	"Set modes suitable for line-oriented crt emulation."	self subclassResponsibility</body></methods><methods><class-id>OS.UnixTtyOptions</class-id> <category>private-printing</category><body>printDisciplineOn: aStream	"Print the line discipline on the stream."	| disc |	disc := self discipline.	aStream nextPutAll: 'discipline: '; print: disc</body></methods><methods><class-id>OS.UnixTtyOptions</class-id> <category>private-accessing</category><body>disciplineCode	^self subclassResponsibility</body><body>disciplineCode: anInteger	^self subclassResponsibility</body><body>speedCode	^self subclassResponsibility</body><body>speedCode: anInteger	^self subclassResponsibility</body></methods><methods><class-id>OS.UnixTtyOptions class</class-id> <category>class initialization</category><body>initDisciplines	Disciplines := IdentityDictionary new: 3.	Disciplines at: 0 put: #old.	Disciplines at: 2 put: #new.	Disciplines at: 1 put: #net</body><body>initialize	"UnixTtyOptions initialize"	self initDisciplines.	self initSpeeds</body><body>initSpeeds	Speeds := IdentityDictionary new: 15.	Speeds at: 0 put: 0.	Speeds at: 1 put: 50.	Speeds at: 2 put: 75.	Speeds at: 3 put: 110.	Speeds at: 4 put: 134.	Speeds at: 5 put: 150.	Speeds at: 6 put: 200.	Speeds at: 7 put: 300.	Speeds at: 8 put: 600.	Speeds at: 9 put: 1200.	Speeds at: 10 put: 1800.	Speeds at: 11 put: 2400.	Speeds at: 12 put: 4800.	Speeds at: 13 put: 9600.	Speeds at: 14 put: 19200.	Speeds at: 15 put: -1</body></methods><methods><class-id>OS.UnixTtyOptions class</class-id> <category>private</category><body>controlCharAsString: c	"Given a character value, answer a string with the printable	represention (e.g. `^C' for 8r003)"	| str cv |	c = 255 ifTrue: [^'none'].	cv := c bitAnd: 127.	cv = 127 ifTrue: [^'del'].	cv = 32 ifTrue: [^'space'].	^cv &lt; 32		ifTrue: 			[String with: $^ with: (Character value: cv + 64)]		ifFalse: 			[String with: (Character value: cv)]</body></methods><methods><class-id>OS.BsdTtyOptions</class-id> <category>accessing</category><body>echo: bool 	"Set into/outof echo mode according to boolean arg."	| f |	f := self flags.	bool		ifTrue: [self flags: (f maskSet: (SgFlags at: #ECHO))]		ifFalse: [self flags: (f maskClear: (SgFlags at: #ECHO))]</body><body>parity: p 	"Set the option value for tty parity. 	p = 1, odd parity. 	p = 0, even parity. 	p = nil, no parity. 	Affects generation on output, and checking on input. 	returns self."	| m f |	m := ((SgFlags at: #ODDP)				bitOr: (SgFlags at: #EVENP)) bitInvert.	f := self flags.	p isNil		ifTrue: [self flags: (f bitAnd: m)]		ifFalse: [self flags: ((f bitAnd: m)					bitOr: (SgFlags at: (p even								ifTrue: [#EVENP]								ifFalse: [#ODDP])))]</body><body>speed: s	"Set the line speed (baud)."	self speedCode: (Speeds keyAtValue: s).	self oSpeedCode: (Speeds keyAtValue: s)</body></methods><methods><class-id>OS.BsdTtyOptions</class-id> <category>byte order reversal</category><body>reverseByteOrder	"Reverse the byte order for dealing with platform switch on snapshot return."	self swapLongAt: 1.	self swapShortAt: 9.	self swapLongAt: 17</body></methods><methods><class-id>OS.BsdTtyOptions</class-id> <category>utilities</category><body>isBinary	"See if the tty seems to be in binary mode"	^(self flags bitAnd: (SgFlags at: #RAW)) ~= 0</body><body>setBinary	"Set modes suitable for binary data xfer.  No flow control provided for!"	| f lm |	f := self flags.	lm := self localMode.	f := f maskClear: (SgFlags at: #ALLDELAY).	f := f maskClear: (SgFlags at: #CRMOD).	f := f maskSet: (SgFlags at: #RAW).	f := f maskClear: (SgFlags at: #ECHO).	f := f maskClear: (SgFlags at: #LCASE).	f := f maskClear: (SgFlags at: #CBREAK).	f := f maskClear: (SgFlags at: #TANDEM).	self flags: f.	lm := lm maskClear: (LocalModes at: #CRTBS).	lm := lm maskClear: (LocalModes at: #PRTERA).	lm := lm maskClear: (LocalModes at: #CRTERA).	lm := lm maskClear: (LocalModes at: #TILDE).	lm := lm maskClear: (LocalModes at: #MDMBUF).	lm := lm maskSet: (LocalModes at: #LITOUT).	lm := lm maskClear: (LocalModes at: #TOSTOP).	lm := lm maskSet: (LocalModes at: #CRTKIL).	lm := lm maskSet: (LocalModes at: #PASS8).	lm := lm maskClear: (LocalModes at: #CTLECH).	lm := lm maskClear: (LocalModes at: #PENDIN).	lm := lm maskSet: (LocalModes at: #DECCTQ).	lm := lm maskClear: (LocalModes at: #NOFLSH).	self localMode: lm</body><body>setDumbTerminal	"Set modes suitable for dumb terminal emulation.	Turns on XON/XOFF flow control, and turns off most	of the other IO processing"	| f lm |	f := self flags.	lm := self localMode.	f := f maskClear: (SgFlags at: #ALLDELAY).	f := f maskClear: (SgFlags at: #CRMOD).	f := f maskClear: (SgFlags at: #RAW).	f := f maskClear: (SgFlags at: #ECHO).	f := f maskClear: (SgFlags at: #LCASE).	f := f maskSet: (SgFlags at: #CBREAK).	f := f maskSet: (SgFlags at: #TANDEM).	self flags: f.	lm := lm maskClear: (LocalModes at: #CRTBS).	lm := lm maskClear: (LocalModes at: #PRTERA).	lm := lm maskClear: (LocalModes at: #CRTERA).	lm := lm maskClear: (LocalModes at: #TILDE).	lm := lm maskClear: (LocalModes at: #MDMBUF).	lm := lm maskSet: (LocalModes at: #LITOUT).	lm := lm maskClear: (LocalModes at: #TOSTOP).	lm := lm maskSet: (LocalModes at: #CRTKIL).	lm := lm maskSet: (LocalModes at: #PASS8).	lm := lm maskClear: (LocalModes at: #CTLECH).	lm := lm maskClear: (LocalModes at: #PENDIN).	lm := lm maskSet: (LocalModes at: #DECCTQ).	lm := lm maskClear: (LocalModes at: #NOFLSH).	self localMode: lm</body><body>setGlassCooked	"Set modes suitable for crt emulation."	| f lm |	f := self flags.	lm := self localMode.	f := f maskClear: (SgFlags at: #ALLDELAY).	f := f maskSet: (SgFlags at: #CRMOD).	f := f maskClear: (SgFlags at: #XTABS). "Set"	f := f maskClear: (SgFlags at: #RAW).	f := f maskSet: (SgFlags at: #ECHO). "Set"	f := f maskClear: (SgFlags at: #LCASE).	f := f maskClear: (SgFlags at: #CBREAK).	f := f maskClear: (SgFlags at: #TANDEM).	f := f maskSet: (SgFlags at: #ODDP). "GHU"	f := f maskSet: (SgFlags at: #EVENP). "GHU"	self flags: f.	lm := lm maskSet: (LocalModes at: #CRTBS).	lm := lm maskClear: (LocalModes at: #PRTERA).	lm := lm maskSet: (LocalModes at: #CRTERA).	lm := lm maskClear: (LocalModes at: #TILDE).	lm := lm maskClear: (LocalModes at: #MDMBUF).	lm := lm maskClear: (LocalModes at: #LITOUT).	lm := lm maskClear: (LocalModes at: #TOSTOP).	lm := lm maskSet: (LocalModes at: #CRTKIL).	lm := lm maskClear: (LocalModes at: #PASS8).	lm := lm maskSet: (LocalModes at: #CTLECH).	lm := lm maskClear: (LocalModes at: #PENDIN).	lm := lm maskSet: (LocalModes at: #DECCTQ).	lm := lm maskClear: (LocalModes at: #NOFLSH).	self localMode: lm</body></methods><methods><class-id>OS.BsdTtyOptions</class-id> <category>printing</category><body>printOn: aStream	"Append to the argument aStream a sequence of characters that identifies the receiver."	super printOn: aStream.	aStream nextPut: $(.	self printDisciplineOn: aStream.	aStream nextPutAll: ', '.	self printLocalModeOn: aStream.	aStream nextPutAll: ', '.	self printSgttybOn: aStream.	aStream space.	self printTcharsOn: aStream.	aStream space.	self printLtCharsOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>OS.BsdTtyOptions</class-id> <category>private-printing</category><body>printFlagsOn: aStream 	| sf |	sf := self flags.	aStream nextPutAll: 'flags:'.	SgFlags		associationsDo: 			[:a | 			(a value bitAnd: sf) = 0				ifTrue: [aStream nextPutAll: ' no-']				ifFalse: [aStream space].			aStream print: a key]</body><body>printLocalModeOn: aStream 	| lm |	lm := self localMode.	aStream nextPutAll: 'localModes:'.	LocalModes		associationsDo: 			[:a | 			(a value bitAnd: lm)				= 0				ifTrue: [aStream nextPutAll: ' no-']				ifFalse: [aStream space].			aStream print: a key]</body><body>printLtCharsOn: aStream	aStream nextPutAll: 'susp:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 21)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'dsusp:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 22)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'rprnt:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 23)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'flush:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 24)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'weras:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 25)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'lnext:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 26)).	aStream nextPutAll: '"'</body><body>printSgttybOn: aStream	| is os |	self printFlagsOn: aStream.	is := self speed.	os := self ospeed.	aStream nextPutAll: ', speed '.	aStream nextPutAll: (is &lt;= 0 ifTrue: ['unknown'] ifFalse: [is printString, ' baud']).	((os &gt; 0) and: [os ~= is])		ifTrue: [aStream nextPutAll: ' / output '.				aStream nextPutAll: (is &lt;= 0						ifTrue: ['unknown']						ifFalse: [os printString]).				aStream nextPutAll: ' baud'].	aStream nextPutAll: ', erase:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 7)).	aStream nextPutAll: '" kill:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 8)).	aStream nextPutAll: '" '.</body><body>printTcharsOn: aStream	aStream nextPutAll: 'intr:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 11)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'quit:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 12)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'start:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 13)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'stop:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 14)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'eof:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 15)).	aStream nextPutAll: '" '.	aStream nextPutAll: 'brk:"'.	aStream nextPutAll: (self class controlCharAsString: (self byteAt: 16)).	aStream nextPutAll: '" '.</body></methods><methods><class-id>OS.BsdTtyOptions</class-id> <category>private-accessing</category><body>disciplineCode	^self longAt: 1</body><body>disciplineCode: d	self longAt: 1 put: d</body><body>flags	^self unsignedShortAt: 9</body><body>flags: f	self unsignedShortAt: 9 put: f</body><body>localMode	^self unsignedLongAt: 17</body><body>localMode: v	self unsignedLongAt: 17 put: v</body><body>ospeed	^Speeds at: (self oSpeedCode)</body><body>oSpeedCode	^self byteAt: 6</body><body>oSpeedCode: br	^self byteAt: 6 put: br</body><body>speedCode	^self byteAt: 5</body><body>speedCode: br	^self byteAt: 5 put: br</body></methods><methods><class-id>OS.BsdTtyOptions class</class-id> <category>class initialization</category><body>initialize	"Set up bit field name dictionaries."	"BsdTtyOptions initialize"	self initLocalModes.	self initSgFlags</body><body>initLocalModes	"Set up the dictionary giving symbolic names for local-mode bit fields."	LocalModes := IdentityDictionary new: 15.	LocalModes at: #CRTBS put: 1.	LocalModes at: #PRTERA put: 2.	LocalModes at: #CRTERA put: 4.	LocalModes at: #TILDE put: 8r10.	LocalModes at: #MDMBUF put: 8r20.	LocalModes at: #LITOUT put: 8r40.	LocalModes at: #TOSTOP put: 8r100.	LocalModes at: #FLUSHO put: 8r200.	LocalModes at: #NOHANG put: 8r400.	LocalModes at: #CRTKIL put: 8r2000.	LocalModes at: #PASS8 put: 8r4000.	LocalModes at: #CTLECH put: 8r10000.	LocalModes at: #PENDIN put: 8r20000.	LocalModes at: #DECCTQ put: 8r40000.	LocalModes at: #NOFLSH put: 8r100000</body><body>initSgFlags	"Set up the dictionary giving symbolic names for sgflags bit fields."	SgFlags := IdentityDictionary new: 10.	SgFlags at: #ALLDELAY put: 8r177400.	SgFlags at: #XTABS put: 8r6000.	SgFlags at: #ODDP put: 8r100.	SgFlags at: #EVENP put: 8r200.	SgFlags at: #RAW put: 8r40.	SgFlags at: #CRMOD put: 8r20.	SgFlags at: #ECHO put: 8r10.	SgFlags at: #LCASE put: 4.	SgFlags at: #CBREAK put: 2.	SgFlags at: #TANDEM put: 1</body></methods><methods><class-id>OS.UnixTtyAccessor</class-id> <category>accessing</category><body>bufferSize	"Answer the recommended buffer size for this accessor."	"tty's are special, the driver has a 256-element clist (usually)."	^256</body><body>getOptions	"Answer tty settings as UnixTtyOptions instance."	| ttyo |	ttyo := self primGetOptions.	^self class defaultOptionClass with: ttyo from: 1 to: ttyo size</body><body>setOptions: opts	"Applies termio struct as tty settings."	"This is totally unreasonable, of course."	&lt;primitive: 638&gt;	self reportError</body></methods><methods><class-id>OS.UnixTtyAccessor</class-id> <category>utilities</category><body>setForCsh	"Set up a tty suitable for using the c-shell	as a terminal emulator."	| opts |	opts := self getOptions.	opts discipline: #new.	opts setGlassCooked.	self setOptions: opts</body><body>setForTty	"Set up a tty suitable for using the c-shell	as a terminal emulator."	| opts |	opts := self getOptions.	opts discipline: #new.	opts setDumbTerminal.	self setOptions: opts</body></methods><methods><class-id>OS.UnixTtyAccessor</class-id> <category>private</category><body>primGetOptions	"Returns tty settings termio struct as ByteArray."	"This is totally unreasonable, of course."	&lt;primitive: 637&gt;	self reportError</body></methods><methods><class-id>OS.UnixTtyAccessor class</class-id> <category>class initialization</category><body>hookupTo: platname	"Set-up to deal with a particular platform."	"Probably should use an ordered collection of patterns (from most to least specific)	with corresponding selectors to perform.  This will have to do for now."	"The difference between the two unixes we have to deal with here	is the tty options format."	('* bsd *' match: platname)		ifTrue: [OptionClass := BsdTtyOptions]		ifFalse: [('* sys# *' match: platname)				ifTrue: [OptionClass := Sys5TtyOptions]				ifFalse: [OptionClass := UnixTtyOptions]]</body></methods><methods><class-id>OS.UnixTtyAccessor class</class-id> <category>defaulting</category><body>defaultOptionClass	"Return the appropriate concrete class for interpreting options."	^OptionClass</body></methods><methods><class-id>OS.UnixPseudoTtyAccessor</class-id> <category>private</category><body>readWait	"Wait until the accessor has data available for reading."	"Override superclass method because ptys don't signal reliably."	[self readWaitWithTimeoutMs: self readPauseInterval] whileTrue</body><body>writeWait	"Wait until the accessor has data available for writing."	"Override superclass method because ptys don't signal reliably."	[self writeWaitWithTimeoutMs: self writePauseInterval] whileTrue</body></methods><methods><class-id>OS.UnixPseudoTtyAccessor class</class-id> <category>instance creation</category><body>openMaster: ptyName 	"Creates a master pty ( in /dev/pty*) and returns it."	^self handleValue:		[('/dev/pty' , ptyName) asFilename			openHandleForDirection: self readWrite			creation: self noCreate]</body><body>openPair	"Creates a connected pty pair.	Returns an (Array with: master with: slave)."	^self registerAllValuesOf:		[| fd2 e |		fd2 := self primPtyErrorInto: (e := self errorReporter new).		e failed ifTrue: [^e reportFor: self].		Array			with: (self handleNoRegister: (fd2 at: 1))			with: (self handleNoRegister: (fd2 at: 2))]</body></methods><methods><class-id>OS.UnixPseudoTtyAccessor class</class-id> <category>private</category><body>primPtyErrorInto: errorHolder	"Create a pty pair.	Returns an (Array with: masterFD with: slaveFD)."	&lt;primitive: 653&gt;	^errorHolder reportFor: self</body></methods><methods><class-id>OS.MacTtyAccessor</class-id> <category>accessing</category><body>bufferSize	"Answer the recommended buffer size for this accessor."	^self primGetSize</body><body>fileSize	"Answer the size of the file (which is being accessed) in bytes.	Not reasonable for serial ports."	self errorReporter inappropriateReferentSignal raiseWith: self</body><body>getOptions	"Answer tty settings as MacTtyOptions instance."	| ttyo |	ttyo := self primGetOptions.	^MacTtyOptions with: ttyo from: 1 to: ttyo size</body><body>setOptions: aSerShk	"Set serial port hand shake parameters; aSerShk is a MacTtyOptions."	&lt;primitive: 787&gt;	self reportError</body><body>truncateTo: position 	"Shortens the file to the given length (in bytes).	Not reasonable for serial ports."	self errorReporter inappropriateReferentSignal raiseWith: self</body></methods><methods><class-id>OS.MacTtyAccessor</class-id> <category>utilities</category><body>setForTty	"Set up a tty suitable for using the c-shell	as a terminal emulator."	| opts |	opts := self getOptions.	opts speed: 2400.	opts setDumbTerminal.	self setOptions: opts</body></methods><methods><class-id>OS.MacTtyAccessor</class-id> <category>private</category><body>primAssertDTR: aBoolean	"Assert (if true) or negate (if false) the port's DTR status"	&lt;primitive: 793&gt;	self reportErrorProceeding</body><body>primBreak: aBoolean	"send break."	&lt;primitive: 788&gt;	self reportErrorProceeding</body><body>primBufferSize	"Returns suggested buffer size in bytes (SmallInteger).	Not appropriate for serial ports."	self errorReporter illegalOperationSignal raise</body><body>primClose	"Close the accessor."	&lt;primitive: 781&gt;	self reportErrorProceeding</body><body>primGetOptions	"Returns serial port settings as ByteArray."	&lt;primitive: 786&gt;	self reportError</body><body>primGetSize	"Returns serial bufferSize in bytes (SmallInteger)."	&lt;primitive: 794&gt;	self reportError</body><body>primGetStatus	"Returns serial port settings as ByteArray."	&lt;primitive: 790&gt;	self reportError</body><body>primReadInto: buffer startingAt: index for: count	"buffer is a byte-object, the place where IO is performed.	index is a SmallInteger, the starting-point in the buffer.	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	&lt;primitive: 782&gt;	(self class restartableError: errorCode)		ifTrue:			[self readWait.			^self primReadInto: buffer startingAt: index for: count].	^self reportErrorProceeding</body><body>primSeekTo: position 	"Set to specified position (a positive integer). 	Not appropriate for serial ports."	self errorReporter illegalOperationSignal raise</body><body>primWriteFrom: buffer startingAt: index for: count	"buffer is a byte-object, the place where IO is performed.	index is a SmallInteger, the starting-point in the buffer.	count is a SmallInteger, the number of bytes to be written."	"Returns a SmallInteger, which is the count of the bytes written."	&lt;primitive: 783&gt;	(self class restartableError: errorCode)		ifTrue:			[self writeWait.			^self primWriteFrom: buffer startingAt: index for: count].	^self reportErrorProceeding</body><body>seekTo: position	"Set the `file pointer' to specified position.	Not reasonable for serial ports."	self errorReporter inappropriateReferentSignal raiseWith: self</body><body>setSem: sem forWrite: bool	"Signal this semaphore when the port is ready for an IO operation.	bool is true if the operation is for writing, false if for reading."	&lt;primitive: 792&gt;	^self reportError</body></methods><methods><class-id>OS.MacTtyAccessor class</class-id> <category>instance creation</category><body>open: aString	"Answer an accessor on an named serial port (either 'modem' or 'printer')"	| ioa index |	index := #('modem' 'printer') indexOf: aString asLowercase.	index &gt; 0		ifFalse: [self errorReporter inaccessibleSignal raise].	ioa := self handleValue: [self primOpen: index errInto: self errorReporter new].	ioa setForTty.	^ioa</body><body>primOpenFileNamed: nm direction: rwMode creation: creationRule errorInto: errorHolder	"Can't open serial ports this way"	self errorReporter illegalOperationSignal raise</body></methods><methods><class-id>OS.MacTtyAccessor class</class-id> <category>constants</category><body>defaultPortName	"Return the default port name"	^'modem'</body></methods><methods><class-id>OS.MacTtyAccessor class</class-id> <category>private</category><body>primOpen: aSmallInteger errInto: anErrorHolder	"Opens numbered serial port, returns handle (SmallInteger)."	&lt;primitive: 780&gt;	^anErrorHolder reportFor: self</body></methods><methods><class-id>OS.UnixRealTtyAccessor</class-id> <category>primitives</category><body>modemBits: bits mask: mask sendBreak: bool	"Sets platform-specific modem-control bits of first arg (SmallInteger)	corresponding to mask of second arg (SmallInteger)	(e.g. only bits set in mask are effected,	0 mask means don't change any).	Sends break if third arg (Boolean) is true.	Returns incoming modem line state (SmallInteger)."	&lt;primitive: 639&gt;	self reportError</body></methods><methods><class-id>OS.UnixRealTtyAccessor class</class-id> <category>class initialization</category><body>initialize	"UnixRealTtyAccessor initialize"	DefaultPort := '/dev/ttya'</body></methods><methods><class-id>OS.UnixRealTtyAccessor class</class-id> <category>instance creation</category><body>open: aString 	"Answer an accessor on an opened named tty. The name should be 	of the form '/dev/*', where * specifies the tty device."	| ioa |	ioa := self handleValue: [self primOpen: aString errInto: self errorReporter new].	ioa setForTty.	^ioa</body></methods><methods><class-id>OS.UnixRealTtyAccessor class</class-id> <category>constants</category><body>defaultPortName	^DefaultPort</body></methods><methods><class-id>OS.UnixRealTtyAccessor class</class-id> <category>private</category><body>primOpen: aString errInto: anErrorHolder	"Answer an accessor on an opened named tty. The name should be 	of the form '/dev/*', where * specifies the tty device.  Answers a	SmallInteger"	&lt;primitive: 655&gt;	^anErrorHolder reportFor: self</body></methods><methods><class-id>OS.Sys5TtyOptions</class-id> <category>accessing</category><body><B>clocal: bool 	</B>| lm |	lm := self controlMode.	bool		ifTrue: [self controlMode: (lm maskSet: (ControlModes at: #LOCAL))]		ifFalse: [self controlMode: (lm maskClear: (ControlModes at: #LOCAL))]</body><body><B>cread: bool 	</B>| lm |	lm := self controlMode.	bool		ifTrue: [self controlMode: (lm maskSet: (ControlModes at: #CREAD))]		ifFalse: [self controlMode: (lm maskClear: (ControlModes at: #CREAD))]</body><body><B>cs7: bool		</B>bool		ifTrue:[self controlMode: (self controlMode maskSet: (ControlModes at: #CS7))]		ifFalse:[self controlMode: (self controlMode maskClear: (ControlModes at: #CS7))]</body><body><B>cs8: bool		</B>bool		ifTrue:[self controlMode: (self controlMode maskSet: (ControlModes at: #CS8))]		ifFalse:[self controlMode: (self controlMode maskClear: (ControlModes at: #CS8))]</body><body>dataBits8		self controlMode: (self controlMode maskSet: (ControlModes at: #CS8))</body><body>discipline: aSymbol	"Assign the line discipline."	"Ignore because System V does not support switchable line disciplines."</body><body>echo: bool 	"Set into/outof echo mode according to boolean arg."	| lm |	lm := self localMode.	bool		ifTrue: [self localMode: (lm maskSet: (LocalModes at: #ECHO))]		ifFalse: [self localMode: (lm maskClear: (LocalModes at: #ECHO))]</body><body><B>ignbrk: bool 	</B>| lm |	lm := self inputMode.	bool		ifTrue: [self inputMode: (lm maskSet: (InputModes at: #IGNBRK))]		ifFalse: [self inputMode: (lm maskClear: (InputModes at: #IGNBRK))]</body><body><B>ignpar: bool 	</B>| lm |	lm := self inputMode.	bool		ifTrue: [self inputMode: (lm maskSet: (InputModes at: #IGNPAR))]		ifFalse: [self inputMode: (lm maskClear: (InputModes at: #IGNPAR))]</body><body>parity: p 	"Set the option value for tty parity. 	p = 1, odd parity. 	p = 0, even parity. 	p = nil, no parity. 	Affects generation on output, and checking on input. 	returns self."	| im cm |	im := self inputMode.	cm := self controlMode.	p isNil		ifTrue: 			[im := im maskSet: (InputModes at: #IGNPAR).			im := im maskClear: (InputModes at: #INPCK).			self inputMode: im.			self controlMode: (cm maskClear: (ControlModes at: #PARENB))]		ifFalse: 			[im := im maskClear: (InputModes at: #IGNPAR).			im := im maskSet: (InputModes at: #INPCK).			self inputMode: im.			self controlMode: (cm := cm maskSet: (ControlModes at: #PARENB)).			self controlMode: (p even					ifTrue: [cm maskClear: (ControlModes at: #PARODD)]					ifFalse: [cm maskSet: (ControlModes at: #PARODD)])]</body><body><B>stopBits: anInteger	</B>"0--1 stop bit per char	 1--2 stop bits per char"<B>	</B>(anInteger == 1 or:[anInteger == 2]) ifFalse:[self error: 'invalid number of bits'].<B>	</B>self controlMode: (anInteger == 1		ifTrue:[self controlMode maskClear: (ControlModes at: #STOPB)]		ifFalse:[self controlMode maskSet: (ControlModes at: #STOPB)])</body></methods><methods><class-id>OS.Sys5TtyOptions</class-id> <category>byte order reversal</category><body>reverseByteOrder	"Reverse the byte order for dealing with platform switch on snapshot return."	self swapShortAt: 1.	self swapShortAt: 3.	self swapShortAt: 5.	self swapShortAt: 7</body></methods><methods><class-id>OS.Sys5TtyOptions</class-id> <category>utilities</category><body>isBinary	"See if the tty seems to be in binary mode"	^(self localMode bitAnd: (LocalModes at: #ISIG)) = 0</body><body><B>setBinary	</B>"Set modes suitable for binary data xfer.  No flow control provided for!"	| im om lm |	im := self inputMode.	om := self outputMode.	lm := self localMode.	im := im maskClear: (InputModes at: #ISTRIP).	im := im maskClear: (InputModes at: #ICRNL).	im := im maskClear: (InputModes at: #IUCLC).	im := im maskClear: (InputModes at: #IXON).	im := im maskClear: (InputModes at: #IXOFF).	self inputMode: im.	lm := lm maskClear: (LocalModes at: #ISIG).	lm := lm maskClear: (LocalModes at: #ICANON).	lm := lm maskClear: (LocalModes at: #ECHO).	lm := lm maskClear: (LocalModes at: #ECHOE).	lm := lm maskClear: (LocalModes at: #NOFLSH).	self localMode: lm.	om := om maskClear: (OutputModes at: #ALLDELAY).	om := om maskClear: (OutputModes at: #POST).	om := om maskClear: (OutputModes at: #LCUC).	om := om maskClear: (OutputModes at: #NLCR).	om := om maskClear: (OutputModes at: #NLRET).	self outputMode: om</body><body><B>setDumbTerminal	</B>"Set modes suitable for dumb terminal emulation.	Turns on XON/XOFF flow control, and turns off all	other IO processing"	| im om lm |	im := self inputMode.	om := self outputMode.	lm := self localMode.	im := im maskClear: (InputModes at: #ISTRIP).	im := im maskClear: (InputModes at: #ICRNL).	im := im maskClear: (InputModes at: #IUCLC).	im := im maskSet: (InputModes at: #IXON).	im := im maskSet: (InputModes at: #IXOFF).	self inputMode: im.	lm := lm maskClear: (LocalModes at: #ISIG).	lm := lm maskClear: (LocalModes at: #ICANON).	lm := lm maskClear: (LocalModes at: #ECHO).	lm := lm maskClear: (LocalModes at: #ECHOE).	lm := lm maskClear: (LocalModes at: #NOFLSH).	self localMode: lm.	om := om maskClear: (OutputModes at: #ALLDELAY).	om := om maskClear: (OutputModes at: #POST).	om := om maskClear: (OutputModes at: #LCUC).	om := om maskClear: (OutputModes at: #NLCR).	om := om maskClear: (OutputModes at: #NLRET).	self outputMode: om</body><body><B>setGlassCooked	</B>"Set modes suitable for crt emulation."	| im om lm |	im := self inputMode.	om := self outputMode.	lm := self localMode.	im := im maskSet: (InputModes at: #ISTRIP).	im := im maskSet: (InputModes at: #ICRNL).	im := im maskClear: (InputModes at: #IUCLC).	im := im maskSet: (InputModes at: #IXANY).	im := im maskSet: (InputModes at: #IXON).	im := im maskSet: (InputModes at: #IXOFF).	self inputMode: im.	lm := lm maskSet: (LocalModes at: #ISIG).	lm := lm maskSet: (LocalModes at: #ICANON).	lm := lm maskSet: (LocalModes at: #ECHO).	lm := lm maskSet: (LocalModes at: #ECHOE).	lm := lm maskClear: (LocalModes at: #NOFLSH).	self localMode: lm.	om := om maskClear: (OutputModes at: #ALLDELAY).	om := om maskClear: (OutputModes at: #XTABS).	om := om maskSet: (OutputModes at: #POST).	om := om maskClear: (OutputModes at: #LCUC).	om := om maskSet: (OutputModes at: #NLCR).	om := om maskClear: (OutputModes at: #NLRET).	self outputMode: om</body></methods><methods><class-id>OS.Sys5TtyOptions</class-id> <category>printing</category><body><B>printOn: aStream	</B>"Append to the argument aStream a sequence of characters that identifies the receiver."	super printOn: aStream.	aStream nextPut: $(.	self printDisciplineOn: aStream.	aStream nextPutAll: ', '.	self printInputModeOn: aStream.	aStream nextPutAll: ', '.	self printOutputModeOn: aStream.	aStream nextPutAll: ', '.	self printControlModeOn: aStream.	aStream nextPutAll: ', '.	self printLocalModeOn: aStream.	aStream nextPutAll: ', '.	self printCcharsOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>OS.Sys5TtyOptions</class-id> <category>private-accessing</category><body>controlMode	^self unsignedShortAt: 5</body><body>controlMode: l	self unsignedShortAt: 5 put: l</body><body>disciplineCode	^self byteAt: 9</body><body>disciplineCode: d	self byteAt: 9 put: d</body><body>inputMode	^self unsignedShortAt: 1</body><body>inputMode: l	self unsignedShortAt: 1 put: l</body><body>localMode	^self unsignedShortAt: 7</body><body>localMode: l	self unsignedShortAt: 7 put: l</body><body>outputMode	^self unsignedShortAt: 3</body><body>outputMode: l	self unsignedShortAt: 3 put: l</body><body>speedCode	^self controlMode bitAnd: 8r17</body><body>speedCode: anInt	self controlMode: (self controlMode maskClear: 8r17) + (anInt bitAnd: 8r17)</body></methods><methods><class-id>OS.Sys5TtyOptions</class-id> <category>private-printing</category><body><B>printCcharsOn: aStream</B>	| charString |	charString := [:byte |					byte == 0						ifTrue:['&lt;undef&gt;']						ifFalse:[self class controlCharAsString: byte]].	aStream nextPutAll: 'intr = '.	aStream nextPutAll: (charString value: (self byteAt: 10)).	aStream nextPutAll: '; '.	aStream nextPutAll: 'quit = '.	aStream nextPutAll: (charString value: (self byteAt: 11)).	aStream nextPutAll: '; '.	aStream nextPutAll: 'erase = '.	aStream nextPutAll: (charString value: (self byteAt: 12)).	aStream nextPutAll: '; '.	aStream nextPutAll: 'kill = '.	aStream nextPutAll: (charString value: (self byteAt: 13)).	aStream nextPutAll: '; '.	aStream nextPutAll: 'eof = '.	aStream nextPutAll: (charString value: (self byteAt: 14)).	aStream nextPutAll: ';'</body><body><B>printControlModeOn: aStream	</B>| cm |	cm := self controlMode.	aStream nextPutAll: 'controlModes:'.	ControlModes		associationsDo: 			[:a | 			aStream space.			(a value bitAnd: cm) == 0				ifTrue: [aStream nextPut: $-].			aStream nextPutAll: a key asLowercase]</body><body><B>printInputModeOn: aStream	</B>| im |	im := self inputMode.	aStream nextPutAll: 'inputModes:'.	InputModes		associationsDo: 			[:a | 			aStream space.			(a value bitAnd: im) == 0				ifTrue: [aStream nextPut: $-].			aStream nextPutAll: a key asLowercase]</body><body><B>printLocalModeOn: aStream	</B>| lm |	lm := self localMode.	aStream nextPutAll: 'localModes:'.	LocalModes		associationsDo: 			[:a | 			aStream space.			(a value bitAnd: lm) == 0				ifTrue: [aStream nextPut: $-].			aStream nextPutAll: a key asLowercase]</body><body><B>printOutputModeOn: aStream	</B>| om |	om := self outputMode.	aStream nextPutAll: 'outputModes:'.	OutputModes		associationsDo: 			[:a | 			aStream space.			(a value bitAnd: om) == 0				ifTrue: [aStream nextPut: $-].			aStream nextPutAll: a key asLowercase]</body></methods><methods><class-id>OS.Sys5TtyOptions class</class-id> <category>class initialization</category><body><B>initControlModes	</B>"Set up the dictionary giving symbolic names for control-mode bit fields."	ControlModes := IdentityDictionary new: 7.	ControlModes at: #CS7 put: 8r40.	ControlModes at: #CS8 put: 8r60.	ControlModes at: #STOPB put: 8r100.	ControlModes at: #PARENB put: 8r400.	ControlModes at: #PARODD put: 8r1000.	ControlModes at: #HUPCL put: 8r2000.	ControlModes at: #CREAD put: 8r0200.	ControlModes at: #LOCAL put: 8r4000</body><body>initialize	"Set up bit field name dictionaries."	"Sys5TtyOptions initialize"	self initControlModes.	self initInputModes.	self initLocalModes.	self initOutputModes</body><body><B>initInputModes	</B>"Set up the dictionary giving symbolic names for input-mode bit fields."	InputModes := IdentityDictionary new: 14.	InputModes 		at: #IGNBRK 	put: 8r000001;		at: #BRKINT 		put: 8r000002;		at: #IGNPAR 	put: 8r000004;		at: #PARMRK 	put: 8r000010;		at: #INPCK	 	put: 8r000020;		at: #ISTRIP 		put: 8r000040;		at: #INLCR		put: 8r000100;		at: #IGNCR		put: 8r000200;		at: #ICRNL 		put: 8r000400;		at: #IUCLC 		put: 8r001000;		at: #IXON 		put: 8r002000;		at: #IXANY 		put: 8r004000;		at: #IXOFF 		put: 8r010000;		at: #IMAXBEL	put: 8r020000</body><body><B>initLocalModes	</B>"Set up the dictionary giving symbolic names for local-mode bit fields."	LocalModes := IdentityDictionary new: 15.	LocalModes 		at: #ISIG 		put: 8r000001;		at: #ICANON 	put: 8r000002;		"at: #XCASE 		put: 8r000004;"		at: #ECHO 		put: 8r000010;		at: #ECHOE 	put: 8r000020;		at: #ECHOK		put: 8r000040;		at: #ECHONL	put: 8r000100;		at: #NOFLSH 	put: 8r000200;		at: #TOSTOP	put: 8r000400;		"at: #ECHOCTL	put: 8r001000;		at: #ECHOPRT	put: 8r002000;		at: #ECHOKE	put: 8r004000;		at: #FLUSHO	put: 8r010000;"		at: #PENDIN		put: 8r040000;		at: #IEXTEN		put: 8r100000</body><body><B>initOutputModes	</B>"Set up the dictionary giving symbolic names for output-mode bit fields."	OutputModes := IdentityDictionary new: 5.	OutputModes 		at: #POST 		put: 8r000001;		at: #LCUC 		put: 8r000002;		at: #NLCR 		put: 8r000004;		at: #NLRET 		put: 8r000040;		at: #XTABS 		put: 8r014000;		at: #ALLDELAY 	put: 8r177700</body></methods><methods><class-id>OS.PCTtyAccessor</class-id> <category>accessing</category><body>bufferSize	"Answer the recommended buffer size for this accessor."	"tty's are special, the driver has a 256-element clist (usually)."	^256</body><body>fileSize	"Answer the size of the file (which is being accessed) in bytes.	Not reasonable for serial ports."	self errorReporter inappropriateReferentSignal raiseWith: self</body><body>getOptions	"Answer tty settings."	self subclassResponsibility</body><body>setOptions: aTtyOptions	"Set the port parameters.  Returns self."	^self subclassResponsibility</body><body>truncateTo: position 	"Shortens the file to the given length (in bytes).	Not reasonable for serial ports."	self errorReporter inappropriateReferentSignal raiseWith: self</body></methods><methods><class-id>OS.PCTtyAccessor</class-id> <category>utilities</category><body>setForTty	"Set up a tty suitable for using the c-shell	as a terminal emulator."	| opts |	opts := self getOptions.	opts speed: 9600.	opts setDumbTerminal.	self setOptions: opts</body></methods><methods><class-id>OS.PCTtyAccessor</class-id> <category>private</category><body>primGetSize	"Returns fileSize in bytes (SmallInteger).	Not appropriate for serial ports."	self errorReporter illegalOperationSignal raise</body><body>primSeekTo: position 	"Set to specified position (a positive integer). 	Not appropriate for serial ports."	self errorReporter illegalOperationSignal raise</body><body>seekTo: position	"Set the `file pointer' to specified position.	Not reasonable for serial ports."	self errorReporter inappropriateReferentSignal raiseWith: self</body><body>setSem: sem forWrite: bool	"Signal this semaphore when the port is ready for an IO operation.	bool is true if the operation is for writing, false if for reading."	&lt;primitive: 668&gt;	^self reportError</body></methods><methods><class-id>OS.PCTtyAccessor class</class-id> <category>instance creation</category><body>open: aString	"Answer an accessor on a named serial port (of the form 'COMn:')"	| ioa  |	(('COM#:' match: aString ignoreCase: false) and: [(aString at: 4) isDigit])		ifFalse: [self errorReporter inaccessibleSignal raise].	ioa := self handleValue:			[PCFilename new				named: aString;				openHandleForDirection: self readWrite				creation: self noCreate].	ioa setForTty.	^ioa</body><body>openFileNamed: nm direction: rwMode creation: creationRule 	"Return an accessor on the file named (a String or Filename) with	the appropriate read/write mode."	^self errorReporter illegalOperationSignal raise</body></methods><methods><class-id>OS.PCTtyAccessor class</class-id> <category>constants</category><body>defaultPortName	"Return the default port name"	^'COM1:'</body></methods><methods><class-id>OS.OS2TtyAccessor</class-id> <category>accessing</category><body>getOptions	"Answer tty settings as OS2TtyOptions instance."	| ttyo |	ttyo := self primGetOptions.	^OS2TtyOptions with: ttyo from: 1 to: ttyo size</body><body>modemBits: bits mask: mask sendBreak: bool	"Sets platform-specific modem-control bits of first arg (SmallInteger)	corresponding to mask of second arg (SmallInteger):Mask ON	Mask OFF	Meaning01			FF			Set DTR00			FE			Clear DTR02			FF			Set RTS00			FD			Clear RTS03			FF			Set DTR and RTS00			FC			Clear DTR and RTS.(From the Control Program Reference)	Sends break if third arg (Boolean) is true.	Returns incoming modem line state (SmallInteger)."	&lt;primitive: 743&gt;	self reportError</body><body>setOptions: anOS2TtyOptions	"Set the port parameters.  Returns self."	&lt;primitive: 742&gt;	self reportError</body></methods><methods><class-id>OS.OS2TtyAccessor</class-id> <category>private</category><body>primGetOptions	"Returns serial port settings as ByteArray."	&lt;primitive: 741&gt;	self reportError</body></methods><methods><class-id>OS.OS2TtyAccessor</class-id> <category>private-primitives</category><body>primWriteFrom: buffer startingAt: index for: count	"buffer is a byte-object, the place where IO is performed.	index is a SmallInteger, the starting-point in the buffer.	count is a SmallInteger, the number of bytes to be written."	"Returns a SmallInteger, which is the count of the bytes written."	"Fails if the result is not equal to the number of bytes to be written"	| result |	result := super primWriteFrom: buffer startingAt: index for: count.	^(result = count) 		ifTrue: [result]		ifFalse: [self reportErrorProceeding].</body></methods><methods><class-id>OS.OS2TtyOptions</class-id> <category>accessing</category><body>bits	"Answer the data size of the port--5, 6, 7 or 8"	^(self byteAt: 6)</body><body>bits: aValue	"Set the data size of the port"	(aValue &lt; 5 or: [ aValue &gt; 8 ])		ifTrue:	[OS2TtyAccessor errorReporter unsupportedOperationSignal raise].	^self byteAt: 6 put: aValue</body><body>breakReplacementChar	"Answer the break replacement char"		^(self byteAt: 17)</body><body>breakReplacementChar: aChar	"Set the break replacement char"		^self byteAt: 17 put: aChar</body><body>bufferFlag	^self byteAt: 15</body><body>bufferFlagWriteTimeout: write readTimeout: read buffering: buffer triggerLevel: trigger loadCount: count	"Bit 0         Enable Write Timeout processing. Note 8.     Bits 1-2      Enable Read Timeout processing. Note 9.                     Bit 2    Bit 1    Description                     0        0       Invalid input.  Results in a general failure error.                     0        1       Normal Read Timeout processing                     1        0       Wait-For-Something Read Timeout processing                     1        1       No-Wait Read Timeout processing                                          Bits 3-4      Extended Hardware Buffering.  See Note 10.                     Bit 4    Bit 3    Description                     0        0       Not supported; ignored.  No change to FIFO state.                     0        1       Disabled                     1        0       Enabled                     1        1       Automatic Protocol Override                       Bits 5-6      Received trigger level.  See Note 11.                     Bit 6    Bit 5    Description                     0        0       1 character                     0        1       4 characters                     1        0       8 characters                     1        1       14 characters                                      Note:  The trigger level must be set to 1 character when the enhanced mode is on.     Bit 7         Transmit Buffer Load Count.  See Note 12.                                       0 = 1 character                    1 = 16 characters                    Note:  When Extended Hardware Buffering is disabled, this bit is set by the device driver."	| flag |	flag := 0.	write ifTrue: [flag := flag + 1].	((read &gt; 0) and: [read &lt; 4]) ifTrue: [flag := flag + (read * 2)] ifFalse: [flag := flag + 2].	(buffer &lt; 4) ifTrue: [flag := flag + (buffer * 8)].	(trigger &lt; 4) 		ifFalse: [(trigger &lt; 8) ifTrue: [flag := flag + 32]		ifFalse: [(trigger &lt; 14) ifTrue: [flag := flag + 64]		ifFalse: [flag := flag + 96]]]. 	count = 1 ifFalse: [flag := flag + 128].	self byteAt: 15 put: flag.</body><body>errorReplacementChar	"Answer the error replacement char"		^(self byteAt: 16)</body><body>errorReplacementChar: aChar	"Set the error replacement char"		^self byteAt: 16 put: aChar</body><body>flowFlag	^self byteAt: 14</body><body>flowFlagTransmit: transmit receive: receive errorCharOn: errorOn breakCharOn: breakOn Override: override RTS: rts	"Bit 0         Enable Automatic Transmit Flow Control (XON/XOFF). See Note 2.    	 Bit 1         Enable Automatic Receive Flow Control (XON/XOFF). See Note 2. 	 Bit 3         Enable error replacement character. See Note 5. 	 Bit 4         Enable break replacement character. See Note 7. 	 Bit 5         Automatic Receive Flow Control:      		              1     1       Automatic Protocol Override.	 Bits 6-7   RTS Control Mode. See Note 1.                     Bit 7    Bit 6    Description                     0        0       Disable                     0        1       Enable                     1        0       Input handshaking                     1        1       Toggling on transmit"	| flag |	flag := 0.	(rts &lt; 4) ifTrue: [flag := rts * 64].	transmit ifTrue: [flag := flag + 1].	receive ifTrue: [flag := flag + 2].	errorOn ifTrue: [flag := flag + 8].	breakOn ifTrue: [flag := flag + 16].	override ifTrue: [flag := flag + 32].	self byteAt: 14 put: flag.</body><body>handshakingFlag	^self byteAt: 13</body><body>handshakingFlagDTR: dtr CTS: cts DSR: dsrOutput DCD: dcd inputDSR: dsrInput	"Bits 0-1           DTR Control Mode.  See Note 1.                                        Bit 1    Bit 0    Description                     0        0       Disable                     0        1       Enable                     1        0       Input handshaking                     1        1       Invalid input, resulting in a general failure error                       Bit 2         Reserved.  Set to 0.     Bit 3         Enable output handshaking, using CTS. See Note 3.     Bit 4         Enable output handshaking, using DSR. See Note 3.     Bit 5         Enable output handshaking, using DCD. See Note 3.     Bit 6         Enable input sensitivity, using DSR. See Note 4.     Bit 7         Reserved.  Set to zero. "	| flag |	flag := 0.	(dtr &lt; 3) ifTrue: [flag := dtr].	cts ifTrue: [flag := flag + 8].	dsrOutput ifTrue: [flag := flag + 16].	dcd ifTrue: [flag := flag + 32].	dsrInput ifTrue: [flag := flag + 64].	self byteAt: 13 put: flag.</body><body>parity	"Return the option value for tty parity. 	p = 1, odd parity. 	p = 0, even parity. 	p = nil, no parity.	p = 3, mark parity.	p = 4, space parity"	| parity |	"For OS/2,		0 = none		1 = odd		2 = even		3 = mark (always 1)		4 = space (always 0)"	parity := self byteAt: 7.	parity = 0		ifTrue:	[^nil].	parity = 2		ifTrue:	[^0].	^parity</body><body>parity: p 	"Set the option value for tty parity. 	p = 1, odd parity. 	p = 0, even parity. 	p = nil, no parity.	p = 3, mark parity.	p = 4, space parity	Affects generation on output, and checking on input. 	returns self."	| parity |	"For OS/2,		0 = none		1 = odd		2 = even		3 = mark (always 1)		4 = space (always 0)"	parity := 0.	p = 0		ifTrue:	[parity := 2]		ifFalse:	[(p notNil) ifTrue: [parity := p].].	self byteAt: 7 put: parity</body><body>raw: boolean 	"Set the system parameters based on whether the serial driver 	should do processing on data as it's sent or received"	boolean		ifTrue: [self inputFlowControl: false; outputFlowControl: false; bits: 8; parity: nil]		ifFalse: [self inputFlowControl: true; outputFlowControl: true; bits: 7]</body><body>readTimeout	"Answer the read timeout in units of 0.01 seconds, based on 0 where 0 = 0.01 seconds"		^self shortAt: 11</body><body>readTimeout: s	"Set the read timeout in units of 0.01 seconds, based on 0 where 0 = 0.01 seconds"	self shortAt: 11 put: s</body><body>setFlagsToDefaults	self handshakingFlagDTR: 1 CTS: false DSR: false DCD: false inputDSR: false.	self flowFlagTransmit: false receive: false errorCharOn: false breakCharOn: false Override: false RTS: 1.	self bufferFlagWriteTimeout: false readTimeout: 2 buffering: 0 triggerLevel: 0 loadCount: 0</body><body>speed	"Answer the line speed in baud."		^self longAt: 1</body><body>speed: s	"Set the line speed (baud)."	self longAt: 1 put: s.	self byteAt: 5 put: 0</body><body>stopBits	"Answer the stop bits of the port--1, 1.5 or 2"	| bits |	bits := self byteAt: 8.	bits = 0 ifTrue: [^1].	bits = 1 ifTrue: [^1.5].	^2.</body><body>stopBits: aValue	"Set the stop bits of the port"	| bits |	(aValue = 1 or: [ aValue = 2 or: [aValue = 1.5]])		ifFalse:	[OS2TtyAccessor errorReporter unsupportedOperationSignal raise].	aValue = 1 		ifTrue: [bits := 0]		ifFalse: [aValue = 1.5 			ifTrue: [bits := 1]			ifFalse: [bits := 2]].	^self byteAt: 8 put: bits</body><body>writeTimeout	"Answer the write timeout in units of 0.01 seconds, based on 0 where 0 = 0.01 seconds"		^self shortAt: 9</body><body>writeTimeout: s	"Set the write timeout in units of 0.01 seconds, based on 0 where 0 = 0.01 seconds"		self shortAt: 9 put: s</body><body>XOFFChar	"Answer the XOFF char"			^(self byteAt: 19)</body><body>XOFFChar: aChar	"Set the XOFF char"		^self byteAt: 19 put: aChar</body><body>XONChar	"Answer the XON char"			^(self byteAt: 18)</body><body>XONChar: aChar	"Set the XON char"		^self byteAt: 18 put: aChar</body></methods><methods><class-id>OS.OS2TtyOptions</class-id> <category>utilities</category><body>isBinary	"See if the tty seems to be in binary mode"	^self bits = 8</body><body>setBinary	"Set modes suitable for binary data xfer."	self bits: 8;		stopBits: 1;		parity: nil;		raw: true;		inputFlowControl: false;		outputFlowControl: false</body><body>setDumbTerminal	"Set modes suitable for dumb terminal emulation	Turns on XON/XOFF flow control, and turns off all	other IO processing"	self readTimeout: 0.	self writeTimeout: 0.	self bits: 8;		stopBits: 1;		parity: nil;		raw: true;		inputFlowControl: true;		outputFlowControl: true</body><body>setGlassCooked	"Set modes suitable for line-oriented crt emulation."	self bits: 7;		stopBits: 1;		raw: false</body></methods><methods><class-id>OS.OS2TtyOptions</class-id> <category>printing</category><body>printOn: aStream	"Append to the argument aStream a sequence of characters that identifies the receiver."	super printOn: aStream.	aStream nextPut: $(.	self speed printOn: aStream.	aStream nextPutAll: ' baud, '.	self bits printOn: aStream.	aStream nextPutAll: ' bits, '.	self stopBits printOn: aStream.	aStream nextPutAll: ' stop bits, '.	self printParityOn: aStream.	aStream nextPutAll: ', '.	self writeTimeout printOn: aStream.	aStream nextPutAll: ' write timeout, '.	self readTimeout printOn: aStream.	aStream nextPutAll: ' read timeout, '.	self handshakingFlag printOn: aStream.	aStream nextPutAll: ' handshake flags, '.	self flowFlag printOn: aStream.	aStream nextPutAll: ' flow flags, '.	self bufferFlag printOn: aStream.	aStream nextPutAll: ' buffer flags, '.	self errorReplacementChar printOn: aStream.	aStream nextPutAll: ' error char, '.	self breakReplacementChar printOn: aStream.	aStream nextPutAll: ' break char, '.	self XONChar printOn: aStream.	aStream nextPutAll: ' XON char, '.	self XOFFChar printOn: aStream.	aStream nextPutAll: ' XOFF char'.	aStream nextPut: $)</body><body>printParityOn: aStream	"Append to the argument aStream a sequence of characters that identifies the receiver's parity."	| p |	(p := self parity) == nil		ifTrue:	[aStream nextPutAll: 'no']		ifFalse:	[p = 1 ifTrue:	[aStream nextPutAll: 'odd'].				p = 0 ifTrue:[aStream nextPutAll: 'even'].				p = 3 ifTrue:[aStream nextPutAll: 'mark'].				p = 4 ifTrue:[aStream nextPutAll: 'space']].	aStream nextPutAll: ' parity'</body></methods><methods><class-id>OS.OS2TtyOptions</class-id> <category>private</category><body>inputFlowControl: bool	"Set input flow control for according to boolean arg."	| flag |	flag := self byteAt: 18.	bool		ifTrue:	[flag := flag maskSet: 2]		ifFalse:	[flag := flag maskClear: 2].	self byteAt: 18 put: flag</body><body>outputFlowControl: bool	"Set output flow control for according to boolean arg."	| flag |	flag := self byteAt: 18.	bool		ifTrue:	[flag := flag maskSet: 1]		ifFalse:	[flag := flag maskClear: 1].	self byteAt: 18 put: flag</body></methods><methods><class-id>OS.OS2TtyOptions class</class-id> <category>instance creation</category><body>new	| options |	options := super new: 19.	options setFlagsToDefaults.	options readTimeout: 0. "0.01 second"	options writeTimeout: 0. "0.01 second"</body></methods><methods><class-id>OS.UnixIOAccessor class</class-id> <category>class initialization</category><body>hookupTo: platname 	UnixTtyAccessor hookupTo: platname</body></methods><methods><class-id>OS.PCIOAccessor class</class-id> <category>defaulting</category><body>defaultForSerial	"Answer the appropriate class for serial (rs-232) communications. If the current operating system is not supported the unsupportedOperationSignal is raised."	self currentOS == #os2		ifTrue: [^Smalltalk at: #OS2TtyAccessor ifAbsent: [self unsupportedOperationSignal raise]].	^self unsupportedOperationSignal raise</body></methods><methods><class-id>OS.MacIOAccessor class</class-id> <category>defaulting</category><body>defaultForSerial	"Return the appropriate class for serial (rs-232) communications."	^MacTtyAccessor</body></methods><methods><class-id>OS.IOAccessor class</class-id> <category>defaults</category><body>defaultForSerial	"Return the appropriate class for serial (rs-232) communications."	| dc |	dc := self defaultClass.	dc == IOAccessor ifTrue: [^self]		ifFalse: [^dc defaultForSerial]</body></methods><methods><class-id>OS.UnixIOAccessor class</class-id> <category>defaulting</category><body>defaultForSerial	"Return the appropriate class for serial (rs-232) communications."	^UnixRealTtyAccessor</body></methods><initialize><class-id>OS.MacTtyOptions</class-id></initialize><initialize><class-id>OS.UnixTtyOptions</class-id></initialize><initialize><class-id>OS.BsdTtyOptions</class-id></initialize><initialize><class-id>OS.UnixRealTtyAccessor</class-id></initialize><initialize><class-id>OS.Sys5TtyOptions</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category></class><class><name>MacIOAccessor</name><environment>OS</environment><super>OS.IOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Mac</category></class><class><name>PCIOAccessor</name><environment>OS</environment><super>OS.IOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-PC</category></class><class><name>UnixIOAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Unix</category></class></st-source>