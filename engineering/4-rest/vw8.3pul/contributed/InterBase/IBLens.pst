<?xml version="1.0"?><st-source><!-- Name: IBLensComment: The InterBase/Firebird Connect, originally written by Anthony Boris <anthonyvb@yandex.ru>.The Lens provides high-level facilities that simplify the task of database access from VisualWorks.  Used in concert with the Lens-Runtime and IBEXDI parcels, this parcel (IBLens) provides the facilities to use the Lens on InterBase(6.x) and Firebird(0.9.x and higher) Database servers.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Copyright: The contents of this file are subject to the ParcPlace Public License Version 1.0 (the "License"); you may not use this file except incompliance with the License. You may obtain a copy of the License at http://www.parcplace.com/support/opensource/PPL-1.0.htmlSoftware distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. Seethe License for the specific language governing rights and limitations under the License.The Original Code is the InterBase/Firebird Connect.The Initial Developer of the Original Code is Anthony Boris.Portions created by Anthony Boris are Copyright (C) 2002-2003. All Rights Reserved.Contributor(s): Anthony BorisDbIdentifier: avbstoreDbTrace: 7781DevelopmentPrerequisites: #(#(#any 'IBEXDI' '') #(#any 'Lens-Runtime' ''))PackageName: IBLensParcel: #('IBLens')ParcelName: IBLensPrerequisiteParcels: #(#('IBEXDI' '') #('Lens-Runtime' ''))PrintStringCache: (7.3.1,avb)Version: 7.2Date: 10:10:40 am October 20, 2004 --><time-stamp>From VisualWorks®, 7.2.1 of 22.06.2004г. on 20.10.2004г. at 10:10:40.000</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>InterBaseTransporter</name><environment>Lens</environment><super>Lens.LensSQLTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generatorSession </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseContext</name><environment>Lens</environment><super>Lens.LensDatabaseContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-InterBase</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseField</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldName fieldLength scale fieldType fieldSubType nullable characterLength precision dataType </inst-vars><class-inst-vars>typeMap </class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseIndex</name><environment>Lens</environment><super>Lens.LensDatabaseIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table uniqueness isIndexInactive foreignKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseTable</name><environment>Lens</environment><super>Lens.LensDatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>systemFlag fieldId name tableType columns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseTableColumn</name><environment>Lens</environment><super>Lens.LensDatabaseTableColumn</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSource nullable table name columnPos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseConstraint</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraintName constNameUq </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseIndexSegment</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indexName columnName columnPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><class><name>InterBaseTableConstraint</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraintName constraintType index table </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IBLens</category><attributes><package>IBLens</package></attributes></class><methods><class-id>Lens.InterBaseTransporter</class-id> <category>registration</category><body package="IBLens">nextVariableName	"Answer a name to be used for the next variable being created."	^ ':' , (variableIndex := variableIndex + 1) printString</body></methods><methods><class-id>Lens.InterBaseTransporter</class-id> <category>initialize-release</category><body package="IBLens">disconnect	generatorSession == nil 		ifFalse: 			[generatorSession disconnect.			generatorSession := nil].	super disconnect</body><body package="IBLens">giveNextSerialNumberTo: variable of: object 	"Put the next generated serial number into variable of object.  Answer the value used."	^object instVarAt: variable instVarIndex		put: (self generatorSession				nextSequenceNumberFor: (variable objectType dataModel databaseContext 						generatorNameFor: variable))</body></methods><methods><class-id>Lens.InterBaseTransporter</class-id> <category>accessing</category><body package="IBLens">generatorSession	generatorSession == nil 		ifTrue: [generatorSession := session connection getSession].	^generatorSession</body></methods><methods><class-id>Lens.InterBaseContext</class-id> <category>printing</category><body package="IBLens">displayString	| strm |	strm := (String new: 128) writeStream.	strm 		nextPutAll: self class kind;		nextPutAll: ': '.	username isEmpty ifFalse:		[ strm nextPutAll: username ].	environment isEmpty ifFalse:		[ strm			nextPut: Character space;			nextPutAll: environment ].	^strm contents</body><body package="IBLens">printOn: stream	"Append to stream a sequence of characters that identifies the receiver."	| elaborated |	elaborated := false.	super printOn: stream.	(username isNil or: [username isEmpty])		ifFalse:			[elaborated := true.			stream				nextPut: $(;				nextPutAll: 'user=';				nextPutAll: username;				nextPut: Character space].	(environment isNil or: [environment isEmpty])		ifFalse:			[elaborated				ifFalse: [stream nextPut: $(].			stream				nextPutAll: 'env=';				nextPutAll: environment;				nextPut: Character space].	elaborated		ifTrue:			[stream skip: -1.			stream nextPutAll: ')']</body></methods><methods><class-id>Lens.InterBaseContext</class-id> <category>private</category><body package="IBLens">isColumn: c1 theSameAs: c2	^c1 name trimBlanks sameAs: c2 name trimBlanks</body></methods><methods><class-id>Lens.InterBaseContext</class-id> <category>data dictionary manipulation</category><body package="IBLens">checkDataModelColumn: dataModelCol withDatabaseColumn: dbCol of: type in: session	"Check consistency of existing data model column with database column. 	Engage user in dialog to fix any discrepancies."	| dataModelColType dbColType choice dataModel connection colName dataModelColWidth dbColWidth table variable message |	dataModel := session dataModel.	connection := session connection.	table := type table.	colName := table name , '.' , dataModelCol name.	"check for datatype agreement"	dataModelColType := dataModelCol dataType.	dbColType := dbCol dataType.	(self isColumnType: dataModelColType compatibleWith: dbColType) ifFalse:		[message := ((#columnDatatypes &lt;&lt; #lens &gt;&gt; 'Column &lt;1s&gt; has datatype &lt;2p&gt; in the data model, and datatype &lt;3p&gt; in the database.')					expandMacrosWith: colName					with: dataModelColType					with: dbColType).		choice := self getChoiceFor: message.		choice == #alterDataModel ifTrue: [			type dataModel saved: false.			dataModelCol dataType: dbColType].		choice == #alterDb ifTrue: [			connection doCommandString: (				table alterColumnCommand: dataModelCol operation: #alterType)]].	"check for width agreement"	dataModelColWidth := dataModelCol maxColumnConstraint.	dbColWidth := dbCol maxColumnConstraint.	variable := type variableMappedTo: dataModelCol.	"Do the checking only if the column is mapped to a variable"	variable notNil		ifTrue: [			(variable hasLongType or: [dataModelColWidth = dbColWidth]) ifFalse: [				message := ((#columnWidth &lt;&lt; #lens &gt;&gt; 'Column &lt;1s&gt; has width &lt;2p&gt; in the data model, and width &lt;3p&gt; in the database.')							expandMacrosWith: colName							with: dataModelColWidth							with: dbColWidth).				choice := self getChoiceFor: message.				dataModelColWidth &lt; dbColWidth ifTrue: [choice := #alterDataModel. Dialog warn: 'Column width can not be changed in database !'].				choice == #alterDataModel ifTrue: [					type dataModel saved: false.					dataModelCol maxColumnConstraint: dbColWidth.					variable valueType: (dataModel fieldTypeForColumn: dataModelCol)].				choice == #alterDb ifTrue: [					connection doCommandString: (						table alterColumnCommand: dataModelCol operation: #alterType)]]].	"check for nullability agreement"	dataModelCol isNotNil = dbCol isNotNil ifFalse: [		message := ((#columnIsNullable &lt;&lt; #lens &gt;&gt; 'Column &lt;1s&gt; is &lt;2?not :&gt;nullable in the data model and &lt;2?:not &gt;nullable in the database.')					expandMacrosWith: colName					with: dataModelCol isNotNil).		choice := self getChoiceFor: message.		"choice = #alterDb ifTrue: [choice := #alterDataModel. Dialog warn: 'Nullness changing not yet supported !']."		choice == #alterDataModel ifTrue: [			type dataModel saved: false.			dataModelCol isNotNil: dbCol isNotNil].		choice == #alterDb ifTrue: [			connection doCommandString: (				table alterColumnCommand: dataModelCol operation: (dataModelCol isNotNil ifTrue: [#setNotNull] ifFalse: [#setNull]))]].</body><body package="IBLens">createGeneratorFor: variable in: session 	"Add generator to the data dictionary if not already present."	| genName |	genName := self generatorNameFor: variable.	[session connection doCommandString: 'create generator ' , genName] 		on: self class connectionClass unableToExecuteSQLSignal		do: 			[:ex | 			| p |			p := ex parameter.			(p isNil or: [p isEmpty or: [(p at: 1) dbmsErrorCode abs ~= 607]]) 				ifTrue: [ex reject	"Some other problem."]				ifFalse: [ex return	"OK, do nothing."]]</body><body package="IBLens">dropGeneratorFor: variable in: session 	"Remove generator in session."	| genName |	genName := self generatorNameFor: variable.		[session connection 		doCommandString: 'DELETE FROM RDB$GENERATORS WHERE RDB$GENERATOR_NAME = ' 				, genName printString] 			on: self class connectionClass unableToExecuteSQLSignal			do: 				[:ex | 				| p |				p := ex parameter.				(p isNil or: [p isEmpty or: [(p at: 1) dbmsErrorCode abs ~= 955]]) 					ifTrue: [ex reject	"Some other problem."]					ifFalse: [ex return	"OK, do nothing."]]</body><body package="IBLens">generatorNameFor: variable	"Answer an array describing the name of the 	generator for variable."	| table seqName |	table := variable objectType table.	seqName := table name trimBlanks asUppercase, '_GEN'.	[seqName size &gt; self class maxNameSize] whileTrue:		[seqName := seqName dropVowels: 1].	^seqName</body><body package="IBLens">getTableNamed: tableName in: aLens 	"Answer the table named tableName from the data dictionary."	| query table |	query := aLens containerOf: self class tableClass.	table := query detect: [:tbl | tbl name = tableName asUppercase]				ifNone: [nil].	^table</body><body package="IBLens">listTablesLike: aPattern in: aLens 	"Answer a collection of tables which are accessible using aLens.	If aPattern is not nil, limit the search to only those tables with names matching."	| query where tables isSystem |	isSystem := ((aPattern notNil and: [aPattern size &gt; 0]) 				and: [aPattern first = $+]) ifTrue: [1] ifFalse: [0].	query := (aLens containerOf: self class tableClass) orderBy: [:t | t name].	where := ComposedBlock new add: [:t | t systemFlag = isSystem].	aPattern == nil 		ifFalse: 			[| criteria |			criteria := (isSystem = 1 						ifTrue: [aPattern copyFrom: 2 to: aPattern size]						ifFalse: [aPattern]) asUppercase.			criteria isEmpty ifFalse: [where add: [:t | t name isLike: criteria]]].	query selectWhere: where.	(tables := query values) do:		[ :tbl | tbl name: tbl name trimBlanks].	^tables</body><body package="IBLens">synchronizeDataDictionaryForType: type in: session	"Synchronize the data dictionary for type, by adding new or modifying 	existing database resources."	"Make sure there is a generator if it is needed."	type serialNumberVariable notNil ifTrue:		[ self createGeneratorFor: type serialNumberVariable in: session].	super synchronizeDataDictionaryForType: type in: session</body></methods><methods><class-id>Lens.InterBaseContext class</class-id> <category>accessing</category><body package="IBLens">connectionClass	"Answer the class of connections opened by instances of self."	^(self environment at: #InterBaseConnection ifAbsent: [nil])</body><body package="IBLens">kind	"Answer user-friendly label for receiver."	^#InterBase</body><body package="IBLens">tableClass	"Answer the class of tables for the receiver."	^InterBaseTable</body><body package="IBLens">tableColumnClass	"Answer the class of table columns in receiver's data dictionary."	^InterBaseTableColumn</body><body package="IBLens">transporterClass	"Answer the class of transporters via which to dynamically access the 	receiver's associated database."	^InterBaseTransporter</body></methods><methods><class-id>Lens.InterBaseContext class</class-id> <category>class initialization</category><body package="IBLens">initialize	"self initialize"	self initializeBasicTypes.	self initializeDataTypeMappings.	maxNameSize := 31.	maxColumnSize := 2 ** 20 - 1.	reservedWords := #().	shortSize := 32765.	"varchar limit"	(transactionPolicies := IdentitySet new) add: #PessimisticRR.	LensCompiler isNil ifFalse: [self initializeCatalogDataModel]</body><body package="IBLens">initializeBasicTypes	"Initialize basicTypes"	basicTypes := IdentityDictionary new.	#(Object Integer  Float Double ByteArray String Timestamp Date Time FixedPoint) do:		[ :className | 		self addBasicType: ((LensDataType new)							name: className;							memberClass: (className asQualifiedReference valueOrDo: [nil])) ].	self		addBasicType: (LensDataType new memberClass: Integer; name: #RowVersion);		addBasicType: (LensDataType new memberClass: Integer; name: #SerialNumber);		addBasicType: (LensEncodedType new 			memberClass: String;			name: #TrimString;			fieldType: (self typeNamed: #String); 			encodeSelector: #asString;			decodeSelector: #trimBlanks);		addBasicType: (LensEncodedType new			name: #Boolean;			memberClass: Boolean;			fieldType: ((self typeNamed: #String) copy maxColumnConstraint: 1); 			encodeSelector: #printStringForInterBase;			decodeSelector: #asBooleanForInterBase);		addBasicType: (LensEncodedType new			memberClass: Symbol;			fieldType: (self typeNamed: #String);			encodeSelector: nil;			decodeSelector: #asSymbol).	^self</body><body package="IBLens">initializeDataTypeMappings	"self initializeDataTypeMappings"	dataTypeMappings := OrderedCollection new.	(self mapFieldOf: #String to: #varchar) maxSize: shortSize.	(self mapFieldOf: #String to: #character) maxSize: shortSize.	(self mapFieldOf: #Boolean to: #character) maxSize: 1.	(self mapFieldOf: #TrimString to: #varchar) maxSize: shortSize.	(self mapFieldOf: #TrimString to: #character) maxSize: shortSize.	(self mapFieldOf: #String to: #clob) maxSize: maxColumnSize; makeLong.	(self mapFieldOf: #ByteArray to: #varchar) maxSize: shortSize.	(self mapFieldOf: #ByteArray to: #character) maxSize: shortSize.	(self mapFieldOf: #ByteArray to: #blob) maxSize: maxColumnSize; makeLong.	self mapFieldOf: #Integer to: #'smallint'.	self mapFieldOf: #Integer to: #'integer'.	self mapFieldOf: #Float to: #'float'.	self mapFieldOf: #Double to: #'double'.	self mapFieldOf: #SerialNumber to: #'integer'.	self mapFieldOf: #Timestamp to: #'timestamp'.	self mapFieldOf: #Date to: #'date'.	self mapFieldOf: #Time to: #'time'.	self mapFieldOf: #FixedPoint to: #'decimal'.</body></methods><methods><class-id>Lens.InterBaseContext class</class-id> <category>private</category><body package="IBLens">encodedAspects	^#()</body></methods><methods><class-id>Lens.InterBaseField</class-id> <category>accessing</category><body package="IBLens">characterLength	"Answer the receiver's characterLength."	^characterLength</body><body package="IBLens">characterLength: anObject	characterLength := anObject</body><body package="IBLens">dataType	^dataType</body><body package="IBLens">dataType: anObject	dataType := anObject</body><body package="IBLens">fieldLength	"Answer the receiver's fieldLength."	^fieldLength</body><body package="IBLens">fieldLength: anObject	fieldLength := anObject</body><body package="IBLens">fieldName	"Answer the receiver's fieldName."	^fieldName</body><body package="IBLens">fieldName: anObject	fieldName := anObject</body><body package="IBLens">fieldSubType	"Answer the receiver's fieldSubType."	^fieldSubType</body><body package="IBLens">fieldSubType: anObject	fieldSubType := anObject</body><body package="IBLens">fieldType	"Answer the receiver's fieldType."	^fieldType</body><body package="IBLens">fieldType: anObject	fieldType := anObject</body><body package="IBLens">maxColumnConstraint	^fieldLength</body><body package="IBLens">maxColumnConstraint: aSize	fieldLength := aSize</body><body package="IBLens">nullable	"Answer the receiver's nullable."	^nullable</body><body package="IBLens">nullable: anObject	nullable := anObject</body><body package="IBLens">precision	"Answer the receiver's precision."	^precision</body><body package="IBLens">precision: anObject	precision := anObject</body><body package="IBLens">scale	"Answer the receiver's scale."	^scale</body><body package="IBLens">scale: anObject	scale := anObject</body></methods><methods><class-id>Lens.InterBaseField</class-id> <category>initialize-release</category><body package="IBLens">postFetchInitialize: ignored 	"Decode dataType and zero out width if dataType is long."	self dataType: self deriveBaseDataType.	(#(#blob #clob) includes: self dataType) 		ifTrue: [self maxColumnConstraint: self defaultBLOBSize]</body></methods><methods><class-id>Lens.InterBaseField</class-id> <category>private</category><body package="IBLens">defaultBLOBSize	^ 1048575</body><body package="IBLens">deriveBaseDataType	"Attempt to translate just by looking up the type code."	| typeToUse |	typeToUse := self class typeMap at: fieldType ifAbsent: [^nil].	typeToUse = #blob ifTrue: [fieldSubType = 1 ifTrue: [^#clob]].	typeToUse = #character ifTrue: [fieldSubType = 1 ifTrue: [^#binary]].	(#(#smallint #integer #int64) includes: typeToUse) 		ifTrue: [(fieldSubType = 1 or: [fieldSubType = 2]) ifTrue: [^#decimal]].	^typeToUse</body></methods><methods><class-id>Lens.InterBaseField class</class-id> <category>accessing</category><body package="IBLens">typeMap	^typeMap</body></methods><methods><class-id>Lens.InterBaseField class</class-id> <category>class initialization</category><body package="IBLens">initialize	"Initialize the class"	"InterBaseField initialize"	self initializeTypeMap</body><body package="IBLens">initializeTypeMap	"Initialize the map from BLR type code to type name."	typeMap := IdentityDictionary new.	typeMap		at: 261 put: #blob;		at: 14 put: #character;		at: 40 put: #cstring;		at: 11 put: #d_float;		at: 27 put: #double;		at: 10 put: #float;		at: 16 put: #int64;		at: 8 put: #integer;		at: 9 put: #quad;		at: 7 put: #smallint;		at: 12 put: #date;		at: 13 put: #time;		at: 35 put: #timestamp;		at: 37 put: #varchar</body></methods><methods><class-id>Lens.InterBaseIndex</class-id> <category>accessing</category><body package="IBLens">foreignKey	"Answer the receiver's foreignKey."	^foreignKey</body><body package="IBLens">foreignKey: anObject	foreignKey := anObject</body><body package="IBLens">isIndexInactive	"Answer the receiver's isIndexInactive."	^isIndexInactive</body><body package="IBLens">isIndexInactive: anObject	isIndexInactive := anObject</body><body package="IBLens">table	"Answer the receiver's table."	^table</body><body package="IBLens">table: anObject	table := anObject</body><body package="IBLens">uniqueness	"Answer the receiver's uniqueness."	^uniqueness</body><body package="IBLens">uniqueness: anObject	uniqueness := anObject</body></methods><methods><class-id>Lens.InterBaseTable</class-id> <category>accessing</category><body package="IBLens">columns	"Answer the receiver's columns."	self privateColumns == nil ifTrue:		[ | cont lens ldm cols qry |		(lens := self lensSession) notNil ifTrue:			[ cont := lens containerOf: (ldm := lens dataModel) databaseContext class tableColumnClass.			qry :=cont selectWhere: [:col | col table = self].			qry orderBy: [:col | col columnPos].			cols := qry values.			self columns: cols.			"nil out widths of all fixed-size columns.			trim blanks from column names."			self privateColumns do:				[ :column |				(ldm fieldTypeForColumn: column) isVariableSize ifFalse:					[ column maxColumnConstraint: nil ].				column name: column name trimBlanks]]].	^self privateColumns</body><body package="IBLens">columns: newColumns	"Set the receiver's columns to newColumns."	columns := newColumns</body><body package="IBLens">fieldId	"Answer the receiver's fieldId."	^fieldId</body><body package="IBLens">fieldId: newFieldId 	fieldId := newFieldId</body><body package="IBLens">name	"Answer the receiver's name."	^name</body><body package="IBLens">name: newName	"Set the receiver's name to newName."	name :=  newName trimBlanks</body><body package="IBLens">owner	^nil</body><body package="IBLens">owner: ignored</body><body package="IBLens">systemFlag	"Answer the receiver's systemFlag."	^systemFlag</body><body package="IBLens">systemFlag: newSystemFlag	"Set the receiver's systemFlag to newSystemFlag."	systemFlag := newSystemFlag</body><body package="IBLens">tableType	"Answer the receiver's tableType."	^tableType</body><body package="IBLens">tableType: newTableType 	tableType := newTableType</body></methods><methods><class-id>Lens.InterBaseTable</class-id> <category>qualifications</category><body package="IBLens">qualify: ldm</body><body package="IBLens">unqualify</body></methods><methods><class-id>Lens.InterBaseTable</class-id> <category>private-accessing</category><body package="IBLens">privateColumns	"Answer the contents of the  instance variable which holds the receiver's columns."	^columns</body></methods><methods><class-id>Lens.InterBaseTable</class-id> <category>printing</category><body package="IBLens">displayString	^self qualifiedName trimBlanks</body><body package="IBLens">printNameOn: aStream 	| nm |	aStream nextPutAll: (((nm := self name) == nil or: [nm isEmpty]) 				ifFalse: [nm trimBlanks]				ifTrue: ['unnamed'])</body></methods><methods><class-id>Lens.InterBaseTable</class-id> <category>key detection</category><body package="IBLens">getPrimaryKeyIn: aLensSession 	"Answer the primary key for this table by looking it up in the database catalogs.  Answer an instance of LensTableKey or nil."	| constraints pkey |	constraints := aLensSession containerOf: InterBaseTableConstraint.	pkey := constraints 				select: [:cons | cons table = self &amp; (cons constraintType = 'PRIMARY KEY')].	pkey isEmpty 		ifFalse: 			["We found a valid primary key, make a LensTableKey to hold it."			| indexCont qry segmCols tabCols |			indexCont := aLensSession containerOf: InterBaseIndexSegment.			qry := indexCont selectWhere: [:seg | seg indexName = pkey first index].			qry orderBy: [:cols | cols columnPosition].			segmCols := qry values.			tabCols := segmCols 						collect: [:cons | self columns detect: [:each | each name trimBlanks = cons columnName trimBlanks]].			^LensTableKey 				table: self				columns: tabCols				keyType: #primary].	^nil</body><body package="IBLens">inferReferencesIn: aLensSession 	"We use tables also as non-persistent objects, therefore, aLensSession is passed 	to this method and the table's own lens is not used (if it even had one). This method	returns a collection with arrays representing references from the table to other tables"	| constraintCont cons res segmentsCont qry segmCols |	constraintCont := aLensSession containerOf: InterBaseConstraint.	segmentsCont := aLensSession containerOf: InterBaseIndexSegment.	cons := constraintCont select: [:cnst | cnst constraintName table name = self  name  &amp; (cnst constraintName constraintType = 'FOREIGN KEY')].	res := OrderedCollection new.	[cons size &gt; 0]		whileTrue: 			[| others con |			con := cons first.			qry := segmentsCont selectWhere: [:seg | seg indexName = con constraintName index].			qry orderBy: [:cols | cols columnPosition].			segmCols := qry values.			others := segmCols 						collect: [:cnst | self columns detect: [:each | each name trimBlanks = cnst columnName trimBlanks] ].			res add: (Array					with: self					with: (others collect: [ :c | c name trimBlanks])					with: (Array with: con  constNameUq  table name trimBlanks)).			cons remove: con].	^res</body></methods><methods><class-id>Lens.InterBaseTable</class-id> <category>DDL generation</category><body package="IBLens">alterColumnCommand: column operation: operation 	"Answer a command to add or modify a column in a table. If the modification is to the type then do not emit the nullness part"	| stream |	stream := WriteStream on: String new.	(#(#setNotNull #setNull) includes: operation) 		ifTrue: 			[stream 				nextPutAll: ('update RDB$RELATION_FIELDS set RDB$NULL_FLAG = &lt;1?1:NULL&gt; where (RDB$RELATION_NAME = &lt;2p&gt;)  and (RDB$FIELD_NAME = &lt;3p&gt;)' 						expandMacrosWith: operation == #setNotNull						with: self qualifiedName						with: column name)]		ifFalse: 			[stream nextPutAll: 'alter table ' , self qualifiedName.			operation == #add 				ifTrue: 					[stream nextPutAll: ' add '.					column putDefinitionOn: stream]				ifFalse: 					[stream nextPutAll: ' alter column '.					operation == #alterType 						ifTrue: 							[stream								nextPutAll: column name;								nextPutAll: ' type '.							column putTypeDefinitionOn: stream]]].	^stream contents</body></methods><methods><class-id>Lens.InterBaseTable class</class-id> <category>accessing</category><body package="IBLens">contextClass	"Answer the name of the class which provides database context."	^InterBaseContext</body><body package="IBLens">encodedAspects	^#()</body></methods><methods><class-id>Lens.InterBaseTableColumn</class-id> <category>accessing</category><body package="IBLens">columnPos	"Answer the receiver's columnPos."	^columnPos</body><body package="IBLens">columnPos: newColumnPos	"Set the receiver's columnPos to newColumnPos."	columnPos := newColumnPos</body><body package="IBLens">dataType	^self fieldSource dataType</body><body package="IBLens">dataType: newDataType	^self fieldSource dataType: newDataType</body><body package="IBLens">fieldSource	"Answer the receiver's fieldSource."	fieldSource isNil ifTrue: [fieldSource:=InterBaseField new].	^fieldSource</body><body package="IBLens">fieldSource: anObject	fieldSource := anObject</body><body package="IBLens">isNotNil	"Answer whether the column described by the receiver cannot store nulls."	^(nullable = 1)</body><body package="IBLens">isNotNil: aBoolean	"Set the receiver's isNotNil"	nullable := aBoolean ifTrue: [1] ifFalse: [0].</body><body package="IBLens">maxColumnConstraint	"Answer the receiver's maxColumnConstraint."	^self fieldSource maxColumnConstraint</body><body package="IBLens">maxColumnConstraint: aNumber	self fieldSource maxColumnConstraint: aNumber</body><body package="IBLens">name	"Answer the receiver's name."	^name</body><body package="IBLens">name: aString	name := aString trimBlanks</body><body package="IBLens">nullable	"Answer the receiver's nullable."	^nullable</body><body package="IBLens">nullable: anObject	nullable := anObject</body><body package="IBLens">precision	"Answer the receiver's precision."	^self fieldSource precision</body><body package="IBLens">precision: newPrecision 	"Set the receiver's precision to newPrecision."	self fieldSource precision: newPrecision</body><body package="IBLens">scale	"Answer the receiver's scale."	^self fieldSource scale</body><body package="IBLens">scale: newScale	"Set the receiver's scale to newScale"	self fieldSource scale: newScale</body><body package="IBLens">table	"Answer the receiver's table."	^table</body><body package="IBLens">table: anObject	table := anObject</body></methods><methods><class-id>Lens.InterBaseTableColumn</class-id> <category>relationships</category><body package="IBLens">stringKey: hints 	"The string to be used when I'm presented in a Falcon graph"	^'&lt;', self name trimBlanks, '&gt;'</body></methods><methods><class-id>Lens.InterBaseTableColumn</class-id> <category>printing</category><body package="IBLens">displayString	^self name trimBlanks</body><body package="IBLens">printNameOn: stream	| nm |	stream nextPutAll:		(((nm := self name) == nil or: [nm isEmpty])			ifFalse: [nm trimBlanks]			ifTrue: ['unnamed'])</body></methods><methods><class-id>Lens.InterBaseTableColumn</class-id> <category>DDL generation</category><body package="IBLens">putNullnessDefinitionOn: stream	"Put nullness definition on stream."	stream nextPutAll: (self isNotNil ifTrue: [' not null'] ifFalse: [' '])</body><body package="IBLens">putTypeDefinitionOn: stream 	"Emit a column type definition expression for receiver on stream"	stream nextPutAll: self dataType.	(self maxColumnConstraint == nil or: [self maxColumnConstraint isZero]) ifFalse:		[| mapping |		mapping := self class contextClass dataTypeMappings						detect: [:m | self dataType = m columnType]						ifNone: nil.		(mapping isNil or: [mapping isLongType not]) ifTrue:			[stream nextPut: $(; nextPutAll: self printedWidth; nextPut: $)]].</body></methods><methods><class-id>Lens.InterBaseTableColumn class</class-id> <category>accessing</category><body package="IBLens">contextClass	"Answer the name of the class which provides database context."	^InterBaseContext</body></methods><methods><class-id>Lens.InterBaseTableColumn class</class-id> <category>private</category><body package="IBLens">encodedAspects	^#(#name #dataType #maxColumnConstraint #scale  #precision		#(#pickledIsNotNil #isNotNil:) )</body></methods><methods><class-id>Lens.InterBaseConstraint</class-id> <category>accessing</category><body package="IBLens">constNameUq	"Answer the receiver's constNameUq."	^constNameUq</body><body package="IBLens">constNameUq: anObject	constNameUq := anObject</body><body package="IBLens">constraintName	"Answer the receiver's constraintName."	^constraintName</body><body package="IBLens">constraintName: anObject	constraintName := anObject</body></methods><methods><class-id>Lens.InterBaseIndexSegment</class-id> <category>accessing</category><body package="IBLens">columnName	"Answer the receiver's columnName."	^columnName</body><body package="IBLens">columnName: anObject	columnName := anObject</body><body package="IBLens">columnPosition	"Answer the receiver's columnPosition."	^columnPosition</body><body package="IBLens">columnPosition: anObject	columnPosition := anObject</body><body package="IBLens">indexName	"Answer the receiver's indexName."	^indexName</body><body package="IBLens">indexName: anObject	indexName := anObject</body></methods><methods><class-id>Lens.InterBaseTableConstraint</class-id> <category>accessing</category><body package="IBLens">constraintName	"Answer the receiver's constraintName."	^constraintName</body><body package="IBLens">constraintName: anObject	constraintName := anObject</body><body package="IBLens">constraintType	"Answer the receiver's constraintType."	^constraintType</body><body package="IBLens">constraintType: anObject	constraintType := anObject</body><body package="IBLens">index	"Answer the receiver's index."	^index</body><body package="IBLens">index: anObject	index := anObject</body><body package="IBLens">table	"Answer the receiver's table."	^table</body><body package="IBLens">table: anObject	table := anObject</body></methods><methods><class-id>Database.InterBaseSession</class-id> <category>private-ObjectLens</category><body package="IBLens">bindInput: object template: template to: bindStream 	"Recursively flatten a template onto a bindStream"	| class |	object == nil ifTrue: [^self bindNil: template to: bindStream].	template isInteger ifTrue: [^bindStream nextPut: object].	class := template class.	class == Object ifTrue: [^self].	(class == Float or: 	[class == Double or: 	[class == FixedPoint 	or: [class == Timestamp or: [class == Date or: [class == Time]]]]]) 		ifTrue: [^bindStream nextPut: object].	"Blob handling"	(class == ByteFieldDescriptor and: [template MaxColumnConstraint = 1048575]) 		ifTrue: [^bindStream nextPut: object readStream].	((object isKindOf: CharacterArray) or: [object isKindOf: ByteArray]) 		ifTrue: [^bindStream nextPut: object].	((template isKindOf: Array) or: [template isKindOf: OrderedCollection]) 		ifTrue: 			[1 to: object size				do: 					[:index | 					self 						bindInput: (object at: index)						template: (template at: index)						to: bindStream]]		ifFalse: 			["All others are treated as instances"			1 to: object class instSize				do: 					[:index | 					self 						bindInput: (object instVarAt: index)						template: (template instVarAt: index)						to: bindStream]]</body><body package="IBLens">bindNil: template to: bindStream	"Recursively bind nil against a template"	| class  |	( template == nil ) ifTrue:		[ ^bindStream nextPut: nil ].	( template isInteger ) ifTrue:		[ ^bindStream nextPut: nil ].	class := template class.	( class == Object ) ifTrue:		[ ^self ].	( class == Float	or: [ class == Double	or: [ class == FixedPoint	or: [ class == Timestamp	or: [class == Date	or: [class == Time	or: [ class == ByteFieldDescriptor	or: [ (template isKindOf: CharacterArray)	or: [ template isKindOf: ByteArray ] ] ] ] ] ] ] ] )		ifTrue: [ ^bindStream nextPut: nil ].	"Recusively bind nil for Arrays, OrderedCollections, and other instances"	( ( template isKindOf: Array) or: [ template isKindOf: OrderedCollection ] )		ifTrue:	[ 1 to: (template size) do:					[ :index |					self bindNil: (template at: index) to: bindStream ] ]		ifFalse:	[ "All other cases are treated as instances"				1 to: (template class instSize) do:					[ :index |					self bindNil: (template instVarAt: index) to: bindStream ] ]</body><body package="IBLens">flattenResultTemplate: template onto: descStream	"Recursively flatten an ObjectLens result template."	^self</body><body package="IBLens">nextSequenceNumberFor: generatorName        "Answer the next sequence number for the indicated generator."        | command number |        command := Lens.DatabaseCommand new.        command queryString:                'select gen_id(' , generatorName , ' ,1) from rdb$database'.        command resultTemplate: 0.        self doCommand: command.        number := self answerAfterCommand next.        self cancel.        ^number</body><body package="IBLens">nextViaTemplate: template	"Answer the object formed by reifying the template using a fetched row"	| class object |	( template isInteger ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asInteger ] ].	class := template class.	( class == Float ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asFloat ] ].	( class == Double ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asDouble] ].		( class == FixedPoint ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil			ifTrue: [ nil ]			ifFalse: [ object isInteger						ifTrue: [ object asFixedPoint: 2 ]						ifFalse: [ object ] ] ].	(  class == Timestamp or: [class == Date or: [class == Time or: [ template == true or: [ template == false ] ] ] ]) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object ].	( class == ByteFieldDescriptor or: [template isString and: [template isSymbol not]] ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object ].	( class == ByteArray ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asByteArray] ].	( template isKindOf: Collection ) ifTrue:		[ ( template isKindOf: Array )			ifTrue: [ ^self nextViaArrayTemplate: template ]			ifFalse: [ ^self nextViaCollectionTemplate: template ] ].	( class == Object ) ifTrue: [ ^nil ].	^self nextViaEntityTemplate: template</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="IBLens">recordTemplate	^self newDay: 1 year: 1</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="IBLens">recordTemplate	^self fromSeconds: 0</body></methods><methods><class-id>Core.Boolean</class-id> <category>private-interbase</category><body package="IBLens">printStringForInterBase	"Encode receiver in one character ."	^self ifTrue: [ 'Y' ] ifFalse: [ 'N' ]</body></methods><methods><class-id>Core.String</class-id> <category>private-interbase</category><body package="IBLens">asBooleanForInterBase	"Try to interpret the string as a Boolean using a common Cobol paradigm.  Treat the value as null if it doesn't match the encoded value for true or false."	self size == 1 ifTrue:		[ self = 'Y' ifTrue: [ ^true ].		self = 'N' ifTrue: [ ^false ] ].	^nil</body></methods><methods><class-id>Lens.InterBaseContext class</class-id> <category>lens data model specs</category><body package="IBLens">catalogDataModelSpec	"LensEditor new openOnClass: self andSelector: #catalogDataModelSpec"	&lt;resource: #dataModel&gt;	^#(#{Lens.LensDataModel} 		#setDatabaseContext: 		#(#{Lens.InterBaseContext} 			#username: '' 			#environment: '' ) 		#structureTypes: #(			#(#{Lens.LensStructureType} 				#memberClass: #{Lens.InterBaseTable} 				#setVariables: #(					#(#{Lens.LensStructureVariable} 						#name: 'systemFlag' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$SYSTEM_FLAG' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'fieldId' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_ID' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'name' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$RELATION_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'tableType' 						#setValueType: #ByteArray 						#fieldType: #ByteArray 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$VIEW_BLR' 							#dataType: #blob 							#maxColumnConstraint: 32700 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'columns' 						#setValueType: #Object 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: false ) ) 				#table: 				#(#{Lens.InterBaseTable} 					#name: 'RDB$RELATIONS' ) 				#defersPostingUpdates: true 				#idVariable: #('name' ) 				#idGeneratorType: #userDefinedId 				#indexes: #() ) 			#(#{Lens.LensStructureType} 				#memberClass: #{Lens.InterBaseTableColumn} 				#setVariables: #(					#(#{Lens.LensStructureVariable} 						#name: 'fieldSource' 						#setValueType: #InterBaseField 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_SOURCE' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'nullable' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$NULL_FLAG' 							#dataType: #smallint )						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true )					#(#{Lens.LensStructureVariable} 						#name: 'table' 						#setValueType: #InterBaseTable 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$RELATION_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'name' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'columnPos' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_POSITION' 							#dataType: #smallint 							#isNotNil: true ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true 						#isNotNil: true ) ) 				#table: 				#(#{Lens.InterBaseTable} 					#name: 'RDB$RELATION_FIELDS' ) 				#defersPostingUpdates: true 				#idVariable: #('table' 'name' ) 				#idGeneratorType: #userDefinedId 				#indexes: #() ) 			#(#{Lens.LensStructureType} 				#memberClass: #{Lens.InterBaseField} 				#setVariables: #(					#(#{Lens.LensStructureVariable} 						#name: 'fieldName' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'fieldLength' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_LENGTH' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'scale' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_SCALE' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'fieldType' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_TYPE' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'fieldSubType' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_SUB_TYPE' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'nullable' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$NULL_FLAG' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'characterLength' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$CHARACTER_LENGTH' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'precision' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_PRECISION' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'dataType' 						#setValueType: #Object 						#generatesAccessor: true 						#generatesMutator: true 						#privateIsMapped: false ) ) 				#table: 				#(#{Lens.InterBaseTable} 					#name: 'RDB$FIELDS' ) 				#defersPostingUpdates: true 				#idVariable: #('fieldName' ) 				#idGeneratorType: #userDefinedId 				#indexes: #() ) 			#(#{Lens.LensStructureType} 				#memberClass: #{Lens.InterBaseTableConstraint} 				#setVariables: #(					#(#{Lens.LensStructureVariable} 						#name: 'constraintName' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$CONSTRAINT_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'constraintType' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$CONSTRAINT_TYPE' 							#dataType: #character 							#maxColumnConstraint: 11 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'index' 						#setValueType: #InterBaseIndex 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$INDEX_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'table' 						#setValueType: #InterBaseTable 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$RELATION_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) ) 				#table: 				#(#{Lens.InterBaseTable} 					#name: 'RDB$RELATION_CONSTRAINTS' ) 				#defersPostingUpdates: true 				#idVariable: #('constraintName' ) 				#idGeneratorType: #userDefinedId 				#indexes: #() ) 			#(#{Lens.LensStructureType} 				#memberClass: #{Lens.InterBaseConstraint} 				#setVariables: #(					#(#{Lens.LensStructureVariable} 						#name: 'constraintName' 						#setValueType: #InterBaseTableConstraint 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$CONSTRAINT_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'constNameUq' 						#setValueType: #InterBaseTableConstraint 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$CONST_NAME_UQ' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) ) 				#table: 				#(#{Lens.InterBaseTable} 					#name: 'RDB$REF_CONSTRAINTS' ) 				#defersPostingUpdates: true 				#idVariable: #('constraintName' ) 				#idGeneratorType: #userDefinedId 				#indexes: #() ) 			#(#{Lens.LensStructureType} 				#memberClass: #{Lens.InterBaseIndex} 				#setVariables: #(					#(#{Lens.LensStructureVariable} 						#name: 'name' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$INDEX_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'indexedVariables' 						#setValueType: #Object 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: false ) 					#(#{Lens.LensStructureVariable} 						#name: 'table' 						#setValueType: #InterBaseTable 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$RELATION_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'uniqueness' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$UNIQUE_FLAG' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'isIndexInactive' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$INDEX_INACTIVE' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'foreignKey' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FOREIGN_KEY' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) ) 				#table: 				#(#{Lens.InterBaseTable} 					#name: 'RDB$INDICES' ) 				#defersPostingUpdates: true 				#idVariable: #('name' ) 				#idGeneratorType: #userDefinedId 				#indexes: #() ) 			#(#{Lens.LensStructureType} 				#memberClass: #{Lens.InterBaseIndexSegment} 				#setVariables: #(					#(#{Lens.LensStructureVariable} 						#name: 'indexName' 						#setValueType: #InterBaseIndex 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$INDEX_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'columnName' 						#setValueType: #String 						#fieldType: #String 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_NAME' 							#dataType: #character 							#maxColumnConstraint: 31 ) 						#generatesAccessor: false 						#generatesMutator: false 						#isId: true 						#privateIsMapped: true ) 					#(#{Lens.LensStructureVariable} 						#name: 'columnPosition' 						#setValueType: #Integer 						#fieldType: #Integer 						#column: 						#(#{Lens.InterBaseTableColumn} 							#name: 'RDB$FIELD_POSITION' 							#dataType: #smallint ) 						#generatesAccessor: false 						#generatesMutator: false 						#privateIsMapped: true ) ) 				#table: 				#(#{Lens.InterBaseTable} 					#name: 'RDB$INDEX_SEGMENTS' ) 				#defersPostingUpdates: true 				#idVariable: #('indexName' 'columnName' ) 				#idGeneratorType: #userDefinedId 				#indexes: #() ) ) 		#lensPolicyName: #Mixed 		#lensTransactionPolicyName: #PessimisticRR 		#validity: #installed )</body></methods><initialize><class-id>Lens.InterBaseContext</class-id></initialize><initialize><class-id>Lens.InterBaseField</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LensDatabaseIndex</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name indexedVariables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensDatabaseContext</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username environment </inst-vars><class-inst-vars>catalogDataModel dataTypeMappings maxColumnSize maxNameSize reservedWords basicTypes shortSize transactionPolicies </class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>InterBaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmtHolder statusBufferHolder bindValuePointersHolder paramDescriptions mustResendQueryHolder sqldaHolder outSqldaHolder minSqlvarSize resultsCache stmtType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-InterBase</category><attributes><package>IBEXDI</package></attributes></class><class><name>LensDatabaseTable</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>LensDatabaseTableColumn</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensSQLTransporter</name><environment>Lens</environment><super>Lens.LensBasicTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectFieldList whereCondition commandStream command objectSurrogateIndices joinLinks variableIndex numberOfIdVariables itemSurrogate variableBindings </inst-vars><class-inst-vars>functions </class-inst-vars><imports></imports><category>Lens-Private-Transporter</category><attributes><package>Lens-Runtime</package></attributes></class></st-source>