<?xml version="1.0"?><st-source><!-- Name: IBEXDITestComment: The InterBase/Firebird Connect, originally written by Anthony Boris <anthonyvb@yandex.ru>.Internal tests.Copyright: The contents of this file are subject to the ParcPlace Public License Version 1.0 (the "License"); you may not use this file except incompliance with the License. You may obtain a copy of the License at http://www.parcplace.com/support/opensource/PPL-1.0.htmlSoftware distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. Seethe License for the specific language governing rights and limitations under the License.The Original Code is the InterBase/Firebird Connect.The Initial Developer of the Original Code is Anthony Boris.Portions created by Anthony Boris are Copyright (C) 2001-2003. All Rights Reserved.Contributor(s): Anthony BorisDbIdentifier: VHSSTORE2DbTrace: 14642DevelopmentPrerequisites: #(#(#any 'IBEXDI' ''))PackageName: IBEXDITestParcel: #('IBEXDITest')ParcelName: IBEXDITestPrerequisiteParcels: #(#('IBEXDI' ''))PrintStringCache: (7.1.5,avb)Version: 7.2Date: 2:08:53 pm October 13, 2003 --><time-stamp>From VisualWorks®, Pre-Release 7.2 (oct03.1) of 06.10.2003г. on 13.10.2003г. at 14:08:53.000</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IBEXDITest</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-InterBase</category><attributes><package>IBEXDITest</package></attributes></class><methods><class-id>Database.IBEXDITest class</class-id> <category>services</category><body package="IBEXDITest">createTestDatabase	"self createTestDatabase"	| connection |	connection := #{InterBaseConnection} value new.	connection createDatabase: ('create database &lt;1p&gt; user &lt;2p&gt; password &lt;3p&gt;' expandMacrosWith: self testEnvironmentString 	with: self testUsernameString with: self testPasswordString ).	^self</body><body package="IBEXDITest">dropTestDatabase	"self dropTestDatabase"	| connection |	connection :=self testConnection.	connection dropDatabase.	^self</body><body package="IBEXDITest">initializeTestDatabase	"self initializeTestDatabase"	| connection |	connection := self testConnection.	self initializeTestSchemaUsing: connection.	self initializeTestDataUsing: connection.	connection disconnect.	^self</body><body package="IBEXDITest">initializeTestDataUsing: aConnection 	"^self 	I populate the test database via aConnection."	| session |	session := aConnection getSession.	session prepare: 'INSERT INTO table1 (name) VALUES (?)'.	#('First' 'Second' 'Third'	'Fourth' 'Fifth' 'Sixth'	'Seventh' 'Eighth'  'Ninth'	'Tenth' 'Eleventh'  'Twelfth' ) do: [:str |	session bindInput: (Array with: str); execute; answer].	session prepare: 'INSERT INTO table2 (id, name) VALUES (?, ?)'.	#( (1 'One') (2 'Two') (3 'Three')		(4 'Four') (5 'Five') (6 'Six')		(7 'Seven') (8 'Eight') (9 'Nine')		(10 'Ten')  (11 'Eleven') (12 'Twelve')) do: [:arr |	session bindInput: arr; execute; answer].	session prepare: 'insert into tableAll(		varcharField, charField,		integerField, smallintField,		decimalField, decimalField2,		floatField, doubleField,		dateField		, timeField , 	timestampField )values (	''Text'', ''Char'',	17000000, 123,	1234.56, 1234564567890.1234,	123.4E-1, 123456.789E+1,	''2000-09-27'',  ''14:53:42'', ''2000-09-25 14:54:55'')'; execute; answer.</body><body package="IBEXDITest">initializeTestSchemaUsing: aConnection 	"Initialize the test schema using aConnection."	|  session |	session := aConnection getSession.	[session prepare: 'drop table table1'; execute; answer] on: aConnection class externalDatabaseErrorSignal do: [:e|].	[session prepare: 'drop table table2'; execute; answer] on: aConnection class externalDatabaseErrorSignal do: [:e|].	[session prepare: 'drop table tableAll'; execute; answer] on: aConnection class externalDatabaseErrorSignal do: [:e|].	session prepare: 'create table table1 (name varchar(30))'; execute; answer.	session prepare: 'create table table2 (id integer, name varchar(30))'; execute; answer.	"all supported data types"	session prepare: 'create table tableAll (		varcharField		varchar(4),		charField		char(4),		integerField		integer,		smallintField	smallint,		decimalField	decimal(6,2),		decimalField2	decimal(18,4),		floatField		float,		doubleField		double precision,		dateField		date,		timeField		time,		timestampField	timestamp,		blobField		blob segment size 64,		blobField2		blob sub_type 1 segment size 32)'; execute; answer.	^self</body><body package="IBEXDITest">testConnection	| connection |	connection := #{InterBaseConnection} value new.	connection 		username: self testUsernameString; 		password: self testPasswordString; 		environment: self testEnvironmentString.	connection connect.	^connection</body><body package="IBEXDITest">testConnection1	| connection |	connection := #{InterBaseConnection} value new.	connection 		username: self testUsernameString; 		password: self testPasswordString; 		environment: self testEnvironmentString.	^connection</body><body package="IBEXDITest">testConnection2	| connection |	connection := #{InterBaseConnection} value new.	connection 		username: self testUsernameString; 		password: self testPasswordString; 		environment: self testEnvironmentString2.	"connection connect."	^connection</body><body package="IBEXDITest">testEnvironmentString	"Specify database name"	^'d:\sample.gdb'</body><body package="IBEXDITest">testEnvironmentString2	"Specify database name"	^'d:\Program files\Firebird\examples\Employee.gdb'</body><body package="IBEXDITest">testPasswordString	"Specify password "	^'anton'</body><body package="IBEXDITest">testStringLiteral	^'0123456789abcdefghijklmnopqrstubwxyzABCDEFGHIJKLMNOPQRSTUBWXYZabcdefghijklmnopqrstubwxyzABCDEFGHIJKL'</body><body package="IBEXDITest">testUsernameString	"Specify username "	^'avb'</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>test-distributed</category><body package="IBEXDITest">dtest1"self dtest1"| c1 c2 |c1:=self testConnection1.c2:=self testConnection2. c1 transactionCoordinatorFor: c2.c1 connect.c2 connect.c1 begin.c1 commit.c1 begin.c1 rollback.c2 disconnect.c1 disconnect.</body><body package="IBEXDITest">dtest2"self dtest2"| c1 c2 s1 s2 |c1:=self testConnection1.c2:=self testConnection2. c1 transactionCoordinatorFor: c2.c1 connect.c2 connect.c1 begin.s1:=c1 getSession prepare: 'select * from table1'.s2:=c2 getSession prepare: 'select * from country'.(s1 execute ; answer) upToEnd.(s2 execute ; answer) upToEnd.c1 commit.c1 disconnect.c2 disconnect.</body><body package="IBEXDITest">dtest3"self dtest3"| c1 c2 s1 s2 |c1:=self testConnection1.c2:=self testConnection2. c1 transactionCoordinatorFor: c2.c1 connect.c2 connect.c1 begin.s1:=c1 getSession prepare: 'select * from table1'.s2:=c2 getSession prepare: 'select * from country'.(s1 execute ; answer) upToEnd.(s2 execute ; answer) upToEnd.c1 rollback.c1 disconnect.c2 disconnect.</body><body package="IBEXDITest">testDistributed	self dtest1; 		dtest2;		dtest3</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>util</category><body package="IBEXDITest">getDpbString"self getDpbString"| str sel rs |str:=String new writeStream.rs := ReadStream on: (InterBaseInterface selectors select: [:s |  'isc_info_*' match: s]) asSortedCollection .[rs atEnd] whileFalse: [sel:=rs next.	str tab; tab;		nextPutAll: 'add: #';		nextPutAll: ((sel copyFrom: 10 to: sel size) convertUndescore);		nextPutAll: ' -&gt; xif ';		nextPutAll: sel;		nextPut: $; ;		cr].^str contents</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>test-procedures</category><body package="IBEXDITest">sptest1"self sptest1"| connection session |connection := self testConnection2.connection connect.session := connection  getSession.connection begin.session prepare: 'SELECT PROJ_ID FROM GET_EMP_PROJ (?) ORDER BY PROJ_ID'.session bindInput: #(4).(session execute ; answer) upToEnd inspect.connection disconnect</body><body package="IBEXDITest">sptest2"self sptest2"| connection session |connection := self testConnection2.connection connect.session := connection  getSession.connection begin.session prepare: 'select * from  DEPT_BUDGET(?) '.session bindInput: #(100).(session execute ; answer) upToEnd inspect.connection disconnect</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>test-simple</category><body package="IBEXDITest">test01	"Connect to an Interbase database and then disconnect."	"self test01"	| connection |	connection := InterBaseConnection new.	connection username: self testUsernameString; password: self testPasswordString; environment: self testEnvironmentString.	connection connect.	connection disconnect.	^self</body><body package="IBEXDITest">test02	"Use the default test connection and run simple query."	"self test02"	| connection session |	connection := self testConnection.	session := connection getSession.	session prepare: 'select (1 + 3) from table1'.	session execute.	session answer ; answer.	connection disconnect.	^self</body><body package="IBEXDITest">test03	"Repeatedly run query"	"self test03"	| connection session |	connection := self testConnection.	session := connection getSession.	session prepare: 'select (1 + 3) from table1'.	session execute.	session answer upToEnd.	"one more"	session execute.	session answer.	connection disconnect.	^self</body><body package="IBEXDITest">test04	"Repeatedly run query"	"self test04"	| connection session |	connection := self testConnection.	session := connection getSession.	session prepare: 'select (1 + 3) from table1'.	session execute.	session answer upToEnd.	"one more"	session prepare: 'select (4 + 5) from table1'.	session execute.	session answer.	connection disconnect.	^self</body><body package="IBEXDITest">test05	"Test variables in queries."	"self test05"	| connection session |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table test06'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table test06 (id integer, name varchar(6))'.	session execute ; answer.	session prepare: 'INSERT INTO test06 (id, name) VALUES(?, ?)'.	#(#(1 'Apple') #(2 'Orange') #(3 'Cherry')) do: [:entry | session bindInput: entry; execute; answer].	session rowCount.	session prepare: 'drop table test06'; 	execute; answer.	connection disconnect.	^self</body><body package="IBEXDITest">test06	"Test transaction retain mode "	"self test06"	| connection session |	connection := self testConnection.	connection transaction retainModeOn.	session := connection getSession.	session prepare: 'select * from table1'.	session execute; answer.	session execute; answer.	connection begin.	session execute; answer.	session execute; answer.	connection commit.	connection disconnect.	^self</body><body package="IBEXDITest">test08	"Test pause /resume"	"self test08"	| connection session |	connection := self testConnection.	session := connection getSession.	session prepare: 'select * from table1'.	session execute; answer.	connection database quiesce.	InterBaseDatabase  resume.	^self</body><body package="IBEXDITest">test09	"Test variables in queries."	"self test09"	| connection session |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table test09'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table test09 (id1 int, id2 int, id3 int, id4 int, id5 int, id6 int, id7 int, id8 int, id9 int, id10 int, id11 int, id12 int, id13 int, id14 int, id15 int, id16 int, id17 int, id18 int, id19 int, id20 int, id21 int, id22 int, id23 int, id24 int )'.	session execute ; answer.	session prepare: 'INSERT INTO test09  VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,  ?)'.	session bindInput: (1 to: 24) asArray; execute; answer.	session prepare: 'select * from test09'.	(session execute ; answer) upToEnd inspect.	connection disconnect.	^self</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>test-datatypes</category><body package="IBEXDITest">testAll"100 timesRepeat: [self testAll]"	self testChar.	self testChar2.	self testChar3.	"self testChar4."	self testDate.	self testTime.	self testTimestamp.	self testDecimal.	self testDecimal2.	self testInteger.	self testIntegerCursor.	self testByteArray.      self testBLOB.</body><body package="IBEXDITest">testBLOB	"self testBLOB"	|  field values  |	field := 'blob'.	values := (1 to: 100 ) collect: [:x | (ByteArray new: x*2 withAll: x) readStream ] . "includes 0 character!"	values	 at: 100 put: (ByteArray new: 254 withAll: 255) readStream; "largest"			at: 97 put: nil;			 at: 99 put: (ByteArray new) readStream.  "smallest" 	self testDatabaseFieldBLOB: field values: values answerValues: (values collect: [:x | x notNil ifTrue:[x contents ]])</body><body package="IBEXDITest">testByteArray	"self testByteArray"	|  field values  |	field := 'varchar(254) character set NONE'.	values := (1 to: 100 ) collect: [:x | ByteArray new: x*2 withAll: x ] . "includes 0 character!"	values	 at: 100 put: (ByteArray new: 254 withAll: 255); "largest"			at: 97 put: nil;			 at: 99 put: (ByteArray new).  "smallest" 	self testDatabaseField: field values: values answerValues: (values collect: [:t | t notNil ifTrue: [t asStringEncoding: #default]])</body><body package="IBEXDITest">testChar	"self testChar"	|  field values  string |	field := 'varchar(254) character set NONE'.	string := self testStringLiteral.	values := (1 to: 100) 				collect: [:x | String new: x * 2 withAll: (string at: x)].	values	 at: 100 put: (String new: 254 withAll: (Character value: 126)); "largest"			at: 97 put: nil;			 at: 99 put: (String new).  "smallest" 	self testDatabaseFieldChar: field values: values</body><body package="IBEXDITest">testChar2	"self testChar2"	"need more work for rebind support"	| field values string |	field := 'varchar(3996) character set NONE'.	" integer field size 4 + varchar size 3996+4+1 = 4005 max row size for tablespace with 4K pages"	string := self testStringLiteral.	values := (1 to: 100) 				collect: [:x | String new: x * 39 withAll: (string at: x)].	values		at: 100 put: (String new: 3996 withAll: (Character value: 126)); "largest"		at: 99 put: String new; 	"smallest"		at: 97 put: nil;		at: 2 put: (String new: 400 withAll: (Character value: 34)).	"test rebind: "	self testDatabaseFieldChar: field values: values</body><body package="IBEXDITest">testChar3	"self testChar3"	"Strange behavior: manual say - limit 32765, 	but I get 'invalid request BLR at offset 46			Implementation limit exceeded			block size exceeds implementation restriction'	on prepare: 'select testField from  where testField between ? and ? '"	|  field values  string |	field := 'varchar(32763) character set NONE'. 	string := self testStringLiteral.	values := (1 to: 100 ) collect: [:x | (String new: x*327 withAll: (string at: x)) ] .	values	 at: 100 put: (String new: 32763 withAll: (Character value: 126)); "largest"			 at: 99 put: (String new);  "smallest" 			at: 97 put: nil;			at: 2 put: (String new: 400 withAll: (Character value: 34)). "test rebind: "	self testDatabaseFieldChar: field values: values</body><body package="IBEXDITest">testChar4	"self testChar4"	|  field values  string |	field := 'varchar(254) character set win1251'.	string := self testStringLiteral.	values := (1 to: 100 ) collect: [:x | (String new: x*2 withAll: (string at: x)) ] .	values	 at: 100 put: (String new: 254 withAll: (Character value: 126)); "largest"			at: 97 put: nil;			 at: 99 put: (String new).  "smallest" 	self testDatabaseFieldChar: field values: values</body><body package="IBEXDITest">testDatabaseField: field values: values	self testDatabaseField: field values: values answerValues: values</body><body package="IBEXDITest">testDatabaseField: field values: values answerValues: answerValues	"Test database type"	|  s c   entry a result s2 |	c:=self testConnection.	[s := c getSession.	[s prepare: 'drop table tableTestField'; execute; answer] on: c class externalDatabaseErrorSignal do: [:e|].	s prepare: ('create table tableTestField (id integer not null, testField &lt;1s&gt;)' expandMacrosWith: field) ; execute; answer.	"now insert values"	c begin.	s prepare: 'insert into tableTestField(id, testField) values (?, ?)'.	"(1) basic insert"	entry:= Array new: 2.	values keysAndValuesDo: [:ind :val | entry at: 1 put: ind; 		 at: 2 put: val. 		s bindInput: entry; execute; answer].	c commit.	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; 		execute; answer.	result := a upToEnd collect: [:row | row first].	answerValues = result ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	c begin.	entry:=Array with: (values at: 5).	s2:=c getSession prepare: 'update tableTestField set testField=? where id=3'.	s2 bindInput: entry.	s2 execute ; answer.  "update third row"	c commit.	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; execute; answer.	(a next; next; next) first  = (answerValues at: 5) ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	"Parametrized select query"	entry := Array with: (values at: 10) with: (values at: 20). 	s prepare: 'select testField from tableTestField where testField between ? and ? '.	s bindInput: entry ; execute.	result:=OrderedCollection new.	[(a := s answer) == #noMoreAnswers] whileFalse: [		a == #noAnswerStream ifFalse: [result addAll:a upToEnd]].	result size = 11 ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	] ensure: [c disconnect]. 	Transcript cr; show: ('Test for &lt;1s&gt; passed' expandMacrosWith: field).	^self</body><body package="IBEXDITest">testDatabaseFieldBLOB: field values: values answerValues: answerValues	"Test database type"	|  s c   entry a result s2 |	c:=self testConnection.	[s := c getSession.	[s prepare: 'drop table tableTestField'; execute; answer] on: c class externalDatabaseErrorSignal do: [:e|].	s prepare: ('create table tableTestField (id integer not null, testField &lt;1s&gt;)' expandMacrosWith: field) ; execute; answer.	c begin.	"now insert values"	s prepare: 'insert into tableTestField(id, testField) values (?, ?)'.	"(1) basic insert"	entry:= Array new: 2.	values keysAndValuesDo: [:ind :val | entry at: 1 put: ind; 		 at: 2 put: val. 		s bindInput: entry; execute; answer].	c commit.	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; 		execute; answer.	result := a upToEnd collect: [:row | row first].	answerValues = result ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	c begin.	entry:=Array with: (values at: 5).	s2:=c getSession prepare: 'update tableTestField set testField=? where id=3'.	s2 bindInput: entry.	s2 execute ; answer.  "update third row"	c commit.	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; execute; answer.	(a next; next; next) first  = (answerValues at: 5) ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	] ensure: [c disconnect]. 	Transcript cr; show: ('Test for &lt;1s&gt; passed' expandMacrosWith: field).	^self</body><body package="IBEXDITest">testDatabaseFieldChar: field values: values 	"Test database type"	|  s c   entry a result s2 answerValues |	answerValues := values.	c:=self testConnection.	[s := c getSession.	[s prepare: 'drop table tableTestField'; execute; answer] on: c class externalDatabaseErrorSignal do: [:e|].	s prepare: ('create table tableTestField (id integer not null, testField &lt;1s&gt;)' expandMacrosWith: field) ; execute; answer.	"now insert values"	c begin.	s prepare: 'insert into tableTestField(id, testField) values (?, ?)'.	"(1) basic insert"	entry:= Array new: 2.	values keysAndValuesDo: [:ind :val | entry at: 1 put: ind; 		 at: 2 put: val. 		s bindInput: entry; execute; answer].	c commit.	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; 		execute; answer.	result := a upToEnd collect: [:row | row first].	answerValues = result ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	c begin.	entry:=Array with: (values at: 5).	s2:=c getSession prepare: 'update tableTestField set testField=? where id=3'.	s2 bindInput: entry.	s2 execute ; answer.  "update third row"	c commit.	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; execute; answer.	(a next; next; next) first  = (answerValues at: 5) ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	"Parametrized select query"	entry := Array with: 10 with: 20. 	s prepare: 'select testField from tableTestField where id between ? and ? '.	s bindInput: entry ; execute.	result:=OrderedCollection new.	[(a := s answer) == #noMoreAnswers] whileFalse: [		a == #noAnswerStream ifFalse: [result addAll:a upToEnd]].	result size = 11 ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	] ensure: [c disconnect]. 	Transcript cr; show: ('Test for &lt;1s&gt; passed' expandMacrosWith: field).	^self</body><body package="IBEXDITest">testDatabaseFieldCursorBug: field values: values	"Unstable cursor manipulation"	"Test database type"	|  s c   entry a result s2 |	c:=self testConnection.	[s := c getSession.	[s prepare: 'drop table tableTestField'; execute; answer] on: c class externalDatabaseErrorSignal do: [:e|].	s prepare: ('create table tableTestField (id integer not null, testField &lt;1s&gt;)' expandMacrosWith: field) ; execute; answer.	"now insert values"	s prepare: 'insert into tableTestField(id, testField) values (?, ?)'.	"(1) basic insert"	entry:= Array new: 2.	values keysAndValuesDo: [:ind :val | entry at: 1 put: ind; 		 at: 2 put: val. 		s bindInput: entry; execute; answer].	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; 		execute; answer.	result := a upToEnd collect: [:row | row first].	values = result ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	"Ok, now try positioned update "	"Assume: rows order persist for following two SELECT queries (generally it not so)"	c begin.	s prepare: 'select * from tableTestField for update' ; 		cursorName: 'S';		execute.	a:=s answer.	entry:=Array with: (values at: 5).	s2:=c getSession prepare: 'update tableTestField set testField=? where current of S'.	s2 bindInput: entry.	a next; next; next. 	s2 execute ; answer.  "update third row"	c commit.	"Check values"	a:=s prepare: 'select testField from tableTestField order by id' ; execute; answer.	(a next; next; next) first = entry first ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	"Parametrized select query"	entry := Array with: (values at: 10) with: (values at: 20). "first row of parameters"	s prepare: 'select * from tableTestField where testField between ? and ? '.	s bindInput: entry ; execute.	result:=OrderedCollection new.	[(a := s answer) == #noMoreAnswers] whileFalse: [		a == #noAnswerStream ifFalse: [result addAll:a upToEnd]].	result size = 11 ifFalse: [^self error: ('Test for &lt;1s&gt; failed' expandMacrosWith: field)].	] ensure: [c disconnect]. 	Transcript cr; show: ('Test for &lt;1s&gt; passed' expandMacrosWith: field).	^self</body><body package="IBEXDITest">testDate	"self testDate"	|  field values  |	field := 'date'.	values := (1 to: 100 ) collect: [:x | Date newDay: x year: 2000 ].	values	at: 100 put: (Date newDay: 365 year: 9999) ; "largest"			at: 97 put: nil;			at: 99 put: (Date newDay: 1 year: 100).  "smallest - DB2 manual say 1-01-0001, 	but VW dates before 1 January 100 translate to dd-mm-20yy " 	self testDatabaseField: field values: values</body><body package="IBEXDITest">testDecimal	"self testDecimal"	"Need more work"	|  field values  |	field := 'decimal(18,4)'.	values := (1 to: 100 ) collect: [:x | x asFixedPoint: 4].	values	 at: 100 put: 12345678901234.8901s; "largest" 	 		at: 97 put: nil;			 at: 99 put: -12345678901234.8901s.  "smallest" 	self testDatabaseField: field values: values</body><body package="IBEXDITest">testDecimal2	"self testDecimal"	"Need more work"	|  field values  |	field := 'decimal(5,2)'.	values := (1 to: 100 ) collect: [:x | x asFixedPoint: 2].	values	 at: 100 put: 123.89s; "largest" 	 		at: 97 put: nil;			 at: 99 put: -123.89s.  "smallest" 	self testDatabaseField: field values: values</body><body package="IBEXDITest">testDouble	"self testDouble"	|  field values  |	field := 'double precision'.	values := (1 to: 100 ) collect: [:x | x asDouble].	values	at: 100 put: 1.79769d308 ; "largest"			at: 99 put: -1.79769d308 ;  "smallest" 			at: 98 put: -2.225d-307 ; "largest negative"			at: 97 put: 2.225d-307;  "smallest positive" 			at: 96 put: nil.				self testDatabaseField: field values: values</body><body package="IBEXDITest">testFloat	"self testFloat" 	"Check max/min values !"	|  field values  |	field := 'float'.	values := (1 to: 100 ) collect: [:x | x asFloat].	values	at: 100 put: 3.402e37 ; "largest"			at: 99 put: -3.402e37  ;  "smallest" 			at: 98 put: -1.175e-36 ; "largest negative"			at: 97 put: 1.175e-36;  "smallest positive" 			at: 96 put: nil.	self testDatabaseField: field values: values</body><body package="IBEXDITest">testInteger	"self testInteger"	|  field values  |	field := 'integer'.	values := (1 to: 100 ) asArray.	values	 at: 100 put: 2147483647; "largest"			 at: 99 put: -2147483648;  "smallest" 			 at: 97 put: nil.	self testDatabaseField: field values: values</body><body package="IBEXDITest">testIntegerCursor	"10 timesRepeat: [self testIntegerCursor]"	|  field values  |	field := 'integer'.	values := (1 to: 100 ) asArray.	values	 at: 100 put: 2147483647; "largest"			 at: 99 put: -2147483648;  "smallest" 			 at: 97 put: nil.	self testDatabaseFieldCursorBug: field values: values</body><body package="IBEXDITest">testTime	"self testTime"	|  field values  |	field := 'time'.	values := (1 to: 100 ) collect: [:x | Time fromSeconds: x  ].	values	at: 100 put: (Time readFrom:  '23:59:59' readStream) ; "largest - in DB2 24:00:00"			at: 97 put: nil;			at: 99 put: (Time readFrom:  '00:00:00' readStream) .  "smallest " 	self testDatabaseField: field values: values</body><body package="IBEXDITest">testTimestamp	"self testTimestamp"	|  field values  |	field := 'timestamp'.	values := (1 to: 100 ) collect: [:x | Timestamp fromSeconds: x  ].	values	at: 100 put: (Timestamp readFrom: '12/31/9999 23:59:59' readStream) ; "largest - in DB2 9999-12-31 24:00:00.000000"			at: 97 put: nil;			at: 99 put: (Timestamp readFrom:  '1/1/100 00:00:00' readStream ).  "smallest " 	self testDatabaseField: field values: values</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>test-array</category><body package="IBEXDITest">testArr01	"Test variables in queries."	"self testArr01"	| connection session entry |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArr'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table testArr (id integer, myField int [4] )'.	session execute ; answer.	session prepare: 'INSERT INTO testArr (id, myField) VALUES(?, ?)'.	entry:=Array with: 1 with: (InterBaseArray forArray: #(2 3 4 5) column: 'MYFIELD' table: 'TESTARR').	session bindInput: entry; execute; answer.	"session prepare: 'drop table test07'; 	execute; answer."	connection disconnect.	^self</body><body package="IBEXDITest">testArr02	"Test variables in queries."	"self testArr02"	| connection session entry |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArr'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table testArr (id integer, myField varchar(15) [4] )'.	session execute ; answer.	session prepare: 'INSERT INTO testArr (id, myField) VALUES(?, ?)'.	entry:=Array with: 1 with: (InterBaseArray forArray: #('a' 'bc' '0123456789ABCD' 'fghij' ) column: 'MYFIELD' table: 'TESTARR').	session bindInput: entry; execute; answer.	"session prepare: 'drop table test08'; 	execute; answer."	connection disconnect.	^self</body><body package="IBEXDITest">testArr03	"Test variables in queries."	"self testArr03"	| connection session entry |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArr'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | e halt].	session prepare: 'create table testArr (id integer, myField char(15) [4] )'.	session execute ; answer.	session prepare: 'INSERT INTO testArr (id, myField) VALUES(?, ?)'.	entry:=Array with: 1 with: (InterBaseArray forArray: #('a' 'bc' '0123456789ABCDE' 'fghij' ) column: 'MYFIELD' table: 'TESTARR').	session bindInput: entry; execute; answer.	"session prepare: 'drop table test08'; 	execute; answer."	connection disconnect.	^self</body><body package="IBEXDITest">testArr04	"Test variables in queries."	"self testArr04"	| connection session entry |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArr'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | e halt ].	session prepare: 'create table testArr (id integer, myField varchar(15) [4] )'.	session execute ; answer.	session prepare: 'INSERT INTO testArr (id, myField) VALUES(?, ?)'.	entry:=Array with: 1 with: (InterBaseArray forArray: #('a' 'bc' #[1 2 3 4 5 6 7 8 9 255 1 2 3 4 5] 'fghij' ) column: 'MYFIELD' table: 'TESTARR').	session bindInput: entry; execute; answer.	"session prepare: 'drop table test08'; 	execute; answer."	connection disconnect.	^self</body><body package="IBEXDITest">testArray	self testArr01.	self testArr02.	self testArr03.      self testLargeArray.	self testSlices.	self testSlices2</body><body package="IBEXDITest">testLargeArray	"self testLargeArray"	| connection session entry myArray |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArr'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | e ].	session prepare: 'create table testArr (id integer, myField integer [16380] )'.	session execute ; answer.	session prepare: 'INSERT INTO testArr (id, myField) VALUES(?, ?)'.	myArray := (1 to: 16380 ) asArray.	entry:=Array with: 1 with: (InterBaseArray forArray: myArray column: 'MYFIELD' table: 'TESTARR').	session bindInput: entry; execute; answer.	"Warning: need always rebind Array !"	entry:=Array with: 1 with: (InterBaseArray forArray: myArray reverse column: 'MYFIELD' table: 'TESTARR'). 	session bindInput: entry; execute; answer.	(session prepare: 'select * from testArr' ; execute; answer) upToEnd inspect.	connection disconnect.	^self</body><body package="IBEXDITest">testSlices	"self testSlices"	| connection session entry myArray |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArr'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | e ].	session prepare: 'create table testArr (id integer, myField integer [100] )'.	session execute ; answer.	connection begin.	session prepare: 'INSERT INTO testArr (id, myField) VALUES(?, ?)'.	1 to: 100 do: [:i | myArray := (1 to: i) asArray.		entry:=Array with: 1 with: (InterBaseArray forArray: myArray column: 'MYFIELD' table: 'TESTARR').		session bindInput: entry; execute; answer].	100 to: 1 by: -1 do: [:i | myArray := (1 to: i) asArray.		entry:=Array with: 1 with: (InterBaseArray forArray: myArray column: 'MYFIELD' table: 'TESTARR').		session bindInput: entry; execute; answer].	connection commit.	(session prepare: 'select * from testArr' ; execute; answer) upToEnd.	connection disconnect.	^self</body><body package="IBEXDITest">testSlices2	"self testSlices2"	| connection session entry myArray dims |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArr'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | e ].	session prepare: 'create table testArr (id integer, myField integer [100] )'.	session execute ; answer.	connection begin.	session prepare: 'INSERT INTO testArr (id, myField) VALUES(?, ?)'.	1 to: 100 do: [:i | myArray := (i to: i) asArray. dims := Array with: (Array with: i with: i).		entry:=Array with: 1 			with: (InterBaseArray forArray: myArray 				column: 'MYFIELD' 				table: 'TESTARR'				dimensions: dims).		session bindInput: entry; execute; answer].	connection commit.	(session prepare: 'select * from testArr' ; execute; answer) upToEnd inspect.	connection disconnect.	^self</body><body package="IBEXDITest">testSlices3	"100 timesRepeat: [self testSlices3]"	| connection session entry myArray dims answer session2 |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArray'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | e].	session prepare: 'create table testArray (id integer, myField integer [100] )'. "Or ...int [1:100], int [1 : 100], but not int [1 :100] "	session execute; answer.	connection begin.	session prepare: 'INSERT INTO testArray (id, myField) VALUES(?, ?)'.	1 to: 100		do: 			[:i | 			myArray := (1 to: i) asArray.			dims := Array with: (Array with: 1 with: i).			entry := Array with: i with: (InterBaseArray							forArray: myArray							column: 'MYFIELD'							table: 'testArray'							dimensions: dims).			session bindInput: entry; execute; answer].	connection commit.	connection begin.	session prepare: 'select * from testArray for update'; 		cursorName: 'S'; 		execute.	answer := session answer.	session2 := connection getSession prepare: 'update testArray set myField=? where current of S'.	[answer atEnd]		whileFalse: 			[entry := answer next last. "get InterBaseArray an instance"			entry array: #(555 999) ; dimensions: #(#(11 12)). "replace array slice from 11 to 12 with 555 &amp; 999 "			session2 bindInput: (Array with: entry).			session2 execute; answer].	connection commit.	(session prepare: 'select * from testArray'; execute; answer) upToEnd inspect. "check result"	connection disconnect.	^self</body><body package="IBEXDITest">testSlices4	"100 timesRepeat: [self testSlices4]"	| connection session entry myArray dims answer session2 |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table testArray'; execute; answer]		on: connection class externalDatabaseErrorSignal do: [:e | e].	session prepare: 'create table testArray (id integer, myField varchar(250) [100] )'. 	session execute; answer.	connection begin.	session prepare: 'INSERT INTO testArray (id, myField) VALUES(?, ?)'.	1 to: 100		do: 			[:i | 			myArray := (1 to: i) collect: [:x | x printString].			dims := Array with: (Array with: 1 with: i).			entry := Array with: i with: (InterBaseArray							forArray: myArray							column: 'MYFIELD'							table: 'TESTARRAY'							dimensions: dims).			session bindInput: entry; execute; answer].	connection commit.	connection begin.	session prepare: 'select * from testArray for update'; 		cursorName: 'S'; 		execute.	answer := session answer.	session2 := connection getSession prepare: 'update testArray set myField=? where current of S'.	[answer atEnd]		whileFalse: 			[entry := answer next last. "get InterBaseArray an instance"			entry array: #('555' '999') ; dimensions: #(#(11 12)). "replace array slice from 11 to 12 with 555 &amp; 999 "			session2 bindInput: (Array with: entry).			session2 execute; answer].	connection commit.	(session prepare: 'select * from testArray'; execute; answer) upToEnd "inspect". "check result"	connection disconnect.	^self</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>test-parameters</category><body package="IBEXDITest">testRebind1	"self testRebind1"	| c s |	c:=self testConnection.	[s:=c getSession.	[s prepare: 'drop table testRebind'; execute; answer] 		on: c class externalDatabaseErrorSignal do: [:e|].	s prepare: 'create table testRebind (testField varchar(50))' ; execute; answer.	c begin.	s prepare: 'insert into testRebind values(?)'.	s 	bindInput: #('String') ; 		execute; answer;		bindInput: #(123) ;  "Integer"		execute; answer;		bindInput: #(1234567890); "LargeInteger" 		execute; answer;		bindInput: (Array with: Date today);		execute; answer;		bindInput: #( 1.234d23) ;  "Double"		execute; answer;		bindInput:(Array with: Time now);		execute; answer;		bindInput:#(nil);		execute; answer; 		bindInput:(Array with: Timestamp now);		execute; answer;		bindInput: #('Very Long String  :-)') ; 		execute; answer.		c commit.] ensure: [c disconnect].Transcript cr; show: ('testRebind1 passed' ).</body></methods><methods><class-id>Database.IBEXDITest class</class-id> <category>test-transactions</category><body package="IBEXDITest">testTransactions	self ttest1;		ttest2;		ttest3;		ttest4;		ttest5;		ttest6;		ttest7;		ttest8;		ttest10;		ttest11;		ttest12;		ttest13;		ttest20;		ttest30;		ttest31</body><body package="IBEXDITest">ttest1	"self ttest1"	| c |	c := self testConnection.	c disconnect</body><body package="IBEXDITest">ttest10	"self ttest10"	| c s |	c := self testConnection.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.	(s execute ; answer) next; next.	c disconnect</body><body package="IBEXDITest">ttest11	"self ttest11"	| c s |	c := self testConnection.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.	(s prepare: 'select * from table2 ';execute ; answer) next; next.	c disconnect</body><body package="IBEXDITest">ttest12	"self ttest12"	| c s |	c := self testConnection.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.	((c prepare: 'select * from table2 ') execute ; answer) next; next.	c disconnect</body><body package="IBEXDITest">ttest13	"self ttest13"	| c s s2|	c := self testConnection.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.	"get new session"	((s2:=c prepare: 'select * from table2 ') execute ; answer) next; next.	(s execute ; answer) next; next.	(s2 execute ; answer) next; next.	c disconnect</body><body package="IBEXDITest">ttest2	"self ttest2"	| c |	c := self testConnection.	ObjectMemory garbageCollect</body><body package="IBEXDITest">ttest20"self ttest20"| c s |c := self testConnection.c transactionParameters: 	#(write concurrency noWait 	   protected lockRead 'TABLE1'	   protected lockWrite 'TABLE2').c begin.s:=(c getSession prepare: 'select * from table1').(s execute;answer) upToEnd.c commitRetain.c disconnect</body><body package="IBEXDITest">ttest3	"self ttest3"	| c |	c := self testConnection.	c begin.	c disconnect</body><body package="IBEXDITest">ttest30	"self ttest30"	| c s c2 s2 |	c := self testConnection.      c2 := c cloneConnection.	c begin.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.     c2 begin.	s2 := c2 prepare: 'select * from table1'.	(s2 execute ; answer) upToEnd.      c commit.      c2 commit.	c disconnect.      c2 disconnect</body><body package="IBEXDITest">ttest31	"self ttest31"	| c s c2 s2 |	c := self testConnection.      c2 := c cloneConnection.	c begin.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.     c2 begin.	c disconnect.	s2 := c2 prepare: 'select * from table1'.	(s2 execute ; answer) upToEnd.      c2 commit.      c2 disconnect</body><body package="IBEXDITest">ttest4	"self ttest4"	| c |	c := self testConnection.	c begin.	c commit.	c disconnect</body><body package="IBEXDITest">ttest5	"self ttest5"	| c |	c := self testConnection.	c begin.	c rollback.	c disconnect</body><body package="IBEXDITest">ttest6	"self ttest6"	| c s |	c := self testConnection.	c begin.	s := c prepare: 'select * from table1'.	(s execute ; answer) upToEnd.	c commit.	c disconnect</body><body package="IBEXDITest">ttest7	"self ttest7"	| c s |	c := self testConnection.	s := c prepare: 'select * from table1'.	(s execute ; answer) upToEnd.	c disconnect</body><body package="IBEXDITest">ttest8	"self ttest8"	| c s |	c := self testConnection.	c begin.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.	c commit.	c disconnect</body><body package="IBEXDITest">ttest9	"self ttest9"	| c s |	c := self testConnection.	s := c prepare: 'select * from table1'.	(s execute ; answer) next; next.	c disconnect</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="IBEXDITest">convertUndescore" 'rec_lock' convertUndescore 'recLock' "	| short spos rs c |	spos := self size.	short := (self species new: spos) writeStream.	rs := self readStream.	[rs atEnd] whileFalse: [c := rs next.		c = $_  ifTrue: [ c := rs next. short nextPut: c asUppercase] ifFalse: [short nextPut: c]	].		^short contents</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>