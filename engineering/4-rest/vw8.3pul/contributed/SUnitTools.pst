<?xml version="1.0"?><st-source><!-- Name: SUnitToo(ls)Notice: Copyright 2004 - 2013 Travis GriggsThis utility is free to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: I am the tools/UI companion for the SUnitToo package. I add a set of status widgets to the browsers status panel. There are 3 ways of running tests:1) Normal running (the run icon)2) Debug (the bug icon)3) Step into (the run with pause icon)A screen cast showing some of the newer features of the tool set is here:<http://www.cincomsmalltalk.com/userblogs/travis/blogView?showComments=true&printTitle=SUnitToo(ls)_ala_4xx&entry=3364224821>I offer the following features.* When debugging, assertion failures and other errors open the debugger immediately, right in the spot the failure occured.* " Step Into" is an SUnitToo(ls) specific feature, it's handy for debugging tests from the front to the back, not just figuring out what went wrong, but why it went wrong.* Number of tests to run is shown, color feedback to show the last run.* Method and class level icons to show the last tested status of either* Automatic Buffer swapping between classes and their associated test classes* Ability to convert to/from XProgramming.SUnit.TestCase classes (quite common to load up some classic SUnit test cases, convert them, do development, then convert back)* Menu option for creating a test case for a given non-test case class* Comprehensive feedback widget for long running tests (see the screencast)* Ability to halt/cancel long running testsDbIdentifier: bear73DbTrace: 498773DbUsername: smichaelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'SUnitToolsIcons' '') #(#any 'SUnitToo' '') #(#any 'ExtraActivity' '') #(#any 'Base VisualWorks' '') #(#any 'Browser-BaseUI' '') #(#any 'Browser-BrowserUI' '') #(#any 'Browser-ChangeObjects' '') #(#any 'Browser-Environments' '') #(#any 'Browser-Namespace' '') #(#any 'Debugger-Probes' '') #(#any 'Debugger-Support' '') #(#any 'Debugger-UI' ''))PackageName: SUnitToo(ls)Parcel: #('SUnitToo(ls)')ParcelName: SUnitToo(ls)PrerequisiteDescriptions: #(#(#name 'SUnitToolsIcons' #componentType #package) #(#name 'SUnitToo') #(#name 'ExtraActivity') #(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Browser-BaseUI' #componentType #package) #(#name 'Browser-BrowserUI' #componentType #package) #(#name 'Browser-ChangeObjects' #componentType #package) #(#name 'Browser-Environments' #componentType #package) #(#name 'Browser-Namespace' #componentType #package) #(#name 'Debugger-Probes' #componentType #package) #(#name 'Debugger-Support' #componentType #package) #(#name 'Debugger-UI' #componentType #package))PrerequisiteParcels: #(#('SUnitToolsIcons' '') #('SUnitToo' '') #('ExtraActivity' '') #('Base VisualWorks' '') #('Browser-BaseUI' '') #('Browser-BrowserUI' '') #('Browser-ChangeObjects' '') #('Browser-Environments' '') #('Browser-Namespace' '') #('Debugger-Probes' '') #('Debugger-Support' '') #('Debugger-UI' ''))PrintStringCache: (8.3 - 1,smichael)Version: 8.3 - 1Post-Load Block: 	[:package | Refactory.Browser.AllTestsStatus initialize. Class regenerateTestClassQuery.SUnit.TestCase regenerateTestedClassQuery.Transcript show: 'Newly opened browsers will have the SUnitToo(ls) in them'; cr.]Date: 1:31:34 PM March 3, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (mar17.1) of March 3, 2017 on March 3, 2017 at 1:31:34 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SUnitTooProgressOverlay</name><environment>Refactory.Browser</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label progress drawing mask startTime runProcess suite results subscriptionRegistry testPrintSelector lastContext movementAngle state haltRequested maxTextWidth originalWindowEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Assets-IDE</category><attributes><package>SUnitToo(ls)</package></attributes></class><comment><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id><body>This is a very involved "widget" that handles the running of a TestSuite, and providing feedback integrated into the browser. It's an interesting widget, because it actually draws a couple of different things, acts as its in controllers, and takes responsibility for running the tests in an alternate process.And it acts in a modal way. It shows up full screen and covers the whole window. Most of that is left transparent, but no control can pass through to the browser below. And when the test is done, it removes itself from the window. Many tests are short lived, so it doesn't actually begin drawing anything until after a pause it's still running the test. An announcement SUnitTooRunDone is used to communicate back to interested parties that it's done. We can't just tie up the process, because we need to be able to service user interaction to provide the halt ability.Instance Variables	drawing	&lt;GraphicsMedium&gt;	To keep the feedback smooth, which updates at 12 Hz, we draw all of the feedback to an intermediate pixmap buffer	haltRequested	&lt;Integer | nil&gt;	When no halt has been requested this is nil. But when one is, we latch the Time microsecondClock. The way the halt proceeds, is that if we can shut down gracefully between tests, we will. But if the 12Hz clock notices that tests are still running, and it's been pending for a while, we'll go ahead and stop the runProcess.	label	&lt;Label&gt;	the text we're currently showing, usually what test we've been running lately.	lastContext	&lt;Context&gt;	every tick in the 12Hz loop, we check context of the runProcess against the last time we checked, to see if it's changed, and thus if we're making progress, or if it appears to be hung. This is used to decide whether or not to advance the movementAngle	mask	&lt;Mask&gt;	our "drawing" is non-rectangular, so we use this to clip it's rounded end borders	movementAngle	&lt;Integer&gt;	the "movement" feedback is the little arc that rotates around the progress pie. As long as the context of the runProcess keeps changing at every check, we'll keep moving it. Otherwise it freezes.	originalWindowEvents &lt;nil | Array&gt; at installOn: time, we remember the sendWindowEvents status of the window, and then set it to nil, this means we won't get certain messages that tend to not play nicely with the temporal state of the overlay, when I run cleanup, these are restored to the window from this cache	progress	&lt;Float&gt;	value between 0 and 1 that indicates what fraction of tests we have run so far	results	&lt;Results&gt;	I actually instantiate and keep track of the results for a test run. I pass it back to the originator (the test mini bar) via the SUnitTooRunDone announcement	runProcess	&lt;Process&gt;	the process used to run the tests, currently run at 45	startTime	&lt;Time&gt;	we note the time that we get our first display request and start the 12Hz clock. We want to wait some time (quiescentThreshold) before we actualy really start displaying, otherwise it's just distracting to have the progress view display and then go back away	state	&lt;Symbol&gt;	one of #(#inactive #visible #overHalt #haltPending). This is used by the handleEvent: driven state machine for determining how to respond to incoming events	subscriptionRegistry	&lt;Object&gt;	have to have a subscription registry so we can announce when we're done	suite	&lt;TestSuite&gt;	the suite we're running	testPrintSelector	&lt;ByteSymbol&gt; what method to use to print tests for the label. If the suite has multiple fixture classes, we show test selectors AND classes, otherwise we just show test selectors</body></comment><class><name>SUnitTooMiniBar</name><environment>Refactory.Browser</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel results testCount testCountLabel updateProcess label isVisible </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SUnitToo(ls)</package></attributes></class><comment><class-id>Refactory.Browser.SUnitTooMiniBar</class-id><body>SUnitTooMiniBar is a custom CompositePart which displays and manages the buttons and other widgets used for running tests. It does not actually run the tests, but defers that job to an SUnitTooProgressOverlay.Implementation	To add new buttons to the menu bar, one adds a method an &lt;subpart: n&gt; tagged method, where n represents it's position in the list of buttons. The method should return a button. See methods in the 'action buttons' protocol for examples.Instance Variables	codeModel	&lt;CodeModel&gt;	the code model i was hooked too	results	&lt;nil | Results&gt;	results of last run	testCount	&lt;Integer&gt;	lazily computed/cached count of tests to run	updateProcess &lt;Process | nil&gt; background process which updates me, so that browser navigation doesn't get slowed down</body></comment><class><name>SUnitTooRunDone</name><environment>Refactory.Browser</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SUnitToo(ls)</package></attributes></class><comment><class-id>Refactory.Browser.SUnitTooRunDone</class-id><body>This is used to announce the completion of an SUnitRun from the ProgressOverlay widget. The mini bar listens for this to know when to update.Instance Variables:	results &lt;Results&gt; The results from the run</body></comment><class><name>AllTestsStatus</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>results </class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo(ls)</package></attributes></class><comment><class-id>Refactory.Browser.AllTestsStatus</class-id><body>I am class side singleton which listens to TestCase result Announcements, and keeps track of which tests pass for which classes. This is used by the UI to put the appropriate (dynamic) icons on test methods and test classes.</body></comment><shared-variable><name>TestClassQuery</name><environment>Core.Class</environment><private>false</private><constant>false</constant><category>SUnitToo</category><initializer>[:class | nil]</initializer><attributes><package>SUnitToo(ls)</package></attributes></shared-variable><shared-variable><name>SUnitTestResults</name><environment>Refactory.Browser.ProtocolItemNavigatorPart</environment><private>false</private><constant>false</constant><category>variables</category><initializer>EphemeronDictionary new</initializer><attributes><package>SUnitToo(ls)</package></attributes></shared-variable><shared-variable><name>TestedClassQuery</name><environment>SUnit.TestCase</environment><private>false</private><constant>false</constant><category>Tools</category><initializer>[:class | nil]</initializer><attributes><package>SUnitToo(ls)</package></attributes></shared-variable><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>event driven</category><body package="SUnitToo(ls)">getEventHandler	^self</body><body package="SUnitToo(ls)">haltPendingRedButtonReleasedEvent: anEvent	(self isInBreakArea: anEvent point) ifTrue: [self initiateHalt].	state := #visible.	self redisplay</body><body package="SUnitToo(ls)">handleEvent: anEvent	| selector |	selector := (state , anEvent class name , ':') asSymbol.	^(self respondsTo: selector)		ifTrue: [self perform: selector with: anEvent]		ifFalse: [nil]</body><body package="SUnitToo(ls)">handlerForMouseEvent: anEvent	^self getEventHandler</body><body package="SUnitToo(ls)">overHaltMouseMovedEvent: anEvent	(self isInBreakArea: anEvent point)		ifFalse:			[state := #visible.			self redisplay]</body><body package="SUnitToo(ls)">overHaltRedButtonPressedEvent: anEvent	(self isInBreakArea: anEvent point)		ifTrue: [state := #haltPending]		ifFalse:			[state := #visible.			self redisplay]</body><body package="SUnitToo(ls)">visibleMouseMovedEvent: anEvent	(self isInBreakArea: anEvent point)		ifTrue:			[state := #overHalt.			self redisplay]</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>announcements</category><body package="SUnitToo(ls)">subscriptionRegistry: aSubscriptionRegistry	subscriptionRegistry := aSubscriptionRegistry</body><body package="SUnitToo(ls)">subscriptionRegistryOrNil	^subscriptionRegistry</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>bounds accessing</category><body package="SUnitToo(ls)">circleControlInset	^5</body><body package="SUnitToo(ls)">circleControlRadius	^self endRadius - self circleControlInset</body><body package="SUnitToo(ls)">endRadius	^30</body><body package="SUnitToo(ls)">halfChordWidth	"Return half of the length of the oval. There are 4 conditions to meet for this:	1. Start with a nominally proportioned size	2. Make sure we've got room for the text	3. Make sure we haven't exceeded the window	4. Make sure it's wide enough for the circles at least."	^(((self bounds width / 3 max: maxTextWidth half + (self endRadius * 2) + 5)		min: self bounds width half - 5)		max: self endRadius) rounded</body><body package="SUnitToo(ls)">preferredExtent	^Screen default bounds extent</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>testing</category><body package="SUnitToo(ls)">isInBreakArea: aPoint	^(self bounds center + ((self halfChordWidth - self endRadius) @ 0) dist:			aPoint) &lt;= self circleControlRadius</body><body package="SUnitToo(ls)">okToStartDisplaying	startTime ifNil: [startTime := Time millisecondClockValue].	^Time millisecondClockValue - startTime &gt; self quiescentThreshold</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>displaying</category><body package="SUnitToo(ls)">displayHaltControl: aGC	| rect |	rect := (drawing bounds corner - self endRadius - self endRadius		corner: drawing bounds corner) insetBy: self circleControlInset.	aGC		paint: self haltControlColor;		displayWedgeBoundedBy: rect startAngle: 0 sweepAngle: 360.	aGC		lineWidth: 5;		paint: (ColorValue brightness: 0.95);		displayRectangle:				(rect leftCenter + (7 @ -5) corner: rect rightCenter - (7 @ -5))</body><body package="SUnitToo(ls)">displayMovement: aGC	| rect paint |	paint := results allPassed		ifTrue: [ColorValue hue: 0.16667 saturation: 1 brightness: 0.8]		ifFalse:			[ColorValue				hue: (0.5 - (Time millisecondClockValue \\ 950 / 950.0 )) abs * 0.4				saturation: 0.9				brightness: 1].	aGC paint: paint.	aGC		lineWidth: 4;		capStyle: GraphicsContext capRound.	rect := Point zero extent: (self endRadius * 2) asPoint.	aGC		displayArcBoundedBy: (rect insetBy: self circleControlInset)		startAngle: movementAngle		sweepAngle: 45</body><body package="SUnitToo(ls)">displayOn: aGC	self isActivityTicking ifFalse: [self startActivityRate: 12].	startTime ifNil: [startTime := Time millisecondClockValue].	Time millisecondClockValue - startTime &gt; self quiescentThreshold		ifFalse: [^self].	state = #inactive ifTrue: [state := #visible].	self updateDrawing.	aGC		copyMaskedArea: self mask		fromPixelArray: self drawing		sourceOffset: Point zero		destinationOffset: (self bounds extent - self drawing extent) // 2</body><body package="SUnitToo(ls)">displayProgress: gc	| angle |	gc paint: (ColorValue hue: 0.7 saturation: 0.9 brightness: 0.9).	angle := progress * 360.	gc		displayWedgeBoundedBy:			((Point zero corner: self endRadius asPoint * 2) insetBy: self circleControlInset)		startAngle: 270 - angle		sweepAngle: angle</body><body package="SUnitToo(ls)">displayText: aGC	label ifNil: [^self].	aGC		intersectClip: (drawing bounds insetBy: (self endRadius * 2) @ 0);		paint: (ColorValue brightness: 0.9);		display: label			at:				(self endRadius * 2 + 5) @ ((self drawing height - label height) // 2)</body><body package="SUnitToo(ls)">drawing	(drawing notNil		and: [drawing isOpen and: [drawing extent = self mask extent]])		ifTrue: [^drawing].	drawing := Pixmap extent: self graphicExtent.	self updateDrawing.	^drawing</body><body package="SUnitToo(ls)">graphicExtent	^self halfChordWidth @ self endRadius * 2</body><body package="SUnitToo(ls)">haltControlColor	^ColorValue		hue: 0		saturation:			(state = #visible				ifTrue: [0.4]				ifFalse: [1])		brightness:			(state = #visible				ifTrue: [0.9]				ifFalse: [1])</body><body package="SUnitToo(ls)">mask	| gc |	(mask notNil and: [mask isOpen and: [mask extent = self graphicExtent]])		ifTrue: [^mask].	mask := Mask extent: self graphicExtent.	mask background: CoverageValue transparent.	gc := mask graphicsContext.	gc paint: CoverageValue opaque.	gc		displayWedgeBoundedBy: (Point zero corner: self endRadius * 2)			startAngle: 0			sweepAngle: 360;		displayRectangle: (mask bounds insetBy: self endRadius @ 0);		displayWedgeBoundedBy:				((mask bounds width - (self endRadius * 2)) @ 0 corner: mask bounds corner)			startAngle: 0			sweepAngle: 360.	^mask</body><body package="SUnitToo(ls)">redisplay	self isOpen ifFalse: [^self].	self displayOn: self graphicsContext</body><body package="SUnitToo(ls)">updateDrawing	| gc |	gc := self drawing graphicsContext.	gc		paint: (ColorValue brightness: 0.1);		displayRectangle: self drawing bounds.	self displayProgress: gc.	self displayMovement: gc.	self displayHaltControl: gc.	self displayText: gc</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>initialize-release</category><body package="SUnitToo(ls)">initialize	super initialize.	progress := 0.	testPrintSelector := #simpleTestName:.	movementAngle := 0.	state := #inactive.	maxTextWidth := 0</body><body package="SUnitToo(ls)">installOn: aWindow	"Place a new instance of me for temporary use as the last element in the windows component (assumed to be a CompositePart of some sort)."	| topComposite |	topComposite := aWindow component.	originalWindowEvents := aWindow sendWindowEvents.	aWindow sendWindowEvents: nil.	aWindow sensor		invalidationSuppressWhile: [topComposite add: self in: (0 @ 0 corner: 1 @ 1)]</body><body package="SUnitToo(ls)">release	subscriptionRegistry release.	runProcess ifNotNil: [runProcess terminate].	^super release</body><body package="SUnitToo(ls)">setTestPrintSelector	testPrintSelector := suite hasMixedReceiverTests		ifTrue: [#mixedTestName:]		ifFalse: [#simpleTestName:]</body><body package="SUnitToo(ls)">suite: aSuite	suite := aSuite.	self setTestPrintSelector</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>private</category><body package="SUnitToo(ls)">initiateHalt	haltRequested ifNotNil: [^self].	self setLabelText: 'Halting Tests'.	haltRequested := Time microsecondClock</body><body package="SUnitToo(ls)">mixedTestName: aTest	| definition ws |	definition := aTest asDefinition.	ws := (String new: 30) writeStream.	ws nextPutAll: definition inheritingClass name.	ws space.	ws nextPutAll: definition selector.	definition implementingClass == definition inheritingClass		ifFalse:			[ws				space;				nextPut: $(;				nextPutAll: definition implementingClass name;				nextPut: $)].	^ws contents</body><body package="SUnitToo(ls)">quiescentThreshold	^650</body><body package="SUnitToo(ls)">setLabelText: aString	label := Label with: aString.	maxTextWidth := maxTextWidth max: label width</body><body package="SUnitToo(ls)">simpleTestName: aTest	| definition ws |	definition := aTest asDefinition.	ws := (String new: 30) writeStream.	ws nextPutAll: definition selector.	definition implementingClass == definition inheritingClass		ifFalse:			[ws				space;				nextPut: $(;				nextPutAll: definition implementingClass name;				nextPut: $)].	^ws contents</body><body package="SUnitToo(ls)">timeToWaitForHalt	^1000000</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>extra activity</category><body package="SUnitToo(ls)">activityTickEvent: anEvent	self checkForCompletion.	self checkForProgress.	self redisplay</body><body package="SUnitToo(ls)">checkForCompletion	self checkForHalt.	self isDone ifFalse: [^self].	state := #inactive.	self stopActivity.	self okToStartDisplaying		ifTrue: [self cleanUp]		ifFalse:			[self topComponent sensor invalidationSuppressWhile: [self cleanUp]].	self		announce:			(SUnitTooRunDone				with:					(haltRequested						ifNotNil: [nil]						ifNil: [results]))</body><body package="SUnitToo(ls)">checkForHalt	(haltRequested isNil		or: [Time microsecondClock - haltRequested &lt; self timeToWaitForHalt])		ifTrue: [^self].	self setLabelText: 'Forcing Halt'.	self redisplay.	runProcess terminate.	(Delay forSeconds: 1) wait</body><body package="SUnitToo(ls)">checkForProgress	| currentContext |	currentContext := runProcess suspendedContext.	lastContext ~= currentContext		ifTrue:			[self incrementMovement.			lastContext := currentContext]</body><body package="SUnitToo(ls)">incrementMovement	movementAngle := (movementAngle - 30) \\ 360</body><body package="SUnitToo(ls)">isDone	^runProcess notNil and: [runProcess isTerminated]</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>running</category><body package="SUnitToo(ls)">noteProgress	progress := progress + suite testCount reciprocal</body><body package="SUnitToo(ls)">noteResourceStarvation: aResourceSet	| output skippedTests |	skippedTests := suite definitionsForResources: aResourceSet.	AllTestsStatus clearDefinitions: skippedTests.	output := String new writeStream.	output nextPutAll: 'Resource Unavailable: '.	(aResourceSet collect: #name) sorted do: [:each | output nextPutAll: each]		separatedBy: [output nextPutAll: ', '].	output		nextPutAll: ' (skipping ';		print: skippedTests size;		nextPutAll: ' tests)'.	self setLabelText: output contents.	Transcript		show: output contents;		cr.	1.5 seconds wait</body><body package="SUnitToo(ls)">noteTest: aTestCase	self setLabelText: (self perform: testPrintSelector with: aTestCase)</body><body package="SUnitToo(ls)">runSuiteUsing: aBlock	results := SUnit.Results new.	runProcess := 			[results collectWhile: 					[					[suite runUsing: 							[:each |							haltRequested								ifNil: 									[self noteTest: each.									aBlock value: each.									self noteProgress]]]							on: SUnit.TestResourceUnavailable							do: 								[:ex |								self noteResourceStarvation: ex parameter.								ex resume]]]					forkAt: 45.	runProcess name: 'Running Tests'</body></methods><methods><class-id>Refactory.Browser.SUnitTooProgressOverlay</class-id> <category>accessing</category><body package="SUnitToo(ls)">cleanUp	"Remove myself from my container. I'm assumed to be the last component of my topComponent."	self topComponent		ifNotNil: 			[:window |			window component remove: window component components last.			window sendWindowEvents: originalWindowEvents]</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>private</category><body package="SUnitToo(ls)">addProgressView: aTestSuite	^(SUnitTooProgressOverlay new)		suite: aTestSuite;		installOn: self topComponent;		yourself</body><body package="SUnitToo(ls)">computeTestCount	| count |	count := 0.	self navigator currentTestClassAndSelectorsDo: [ :mclass :selector | count := count + 1 ].	^count</body><body package="SUnitToo(ls)">defects	^results		ifNil: [^Array new]		ifNotNil: [results defects]</body><body package="SUnitToo(ls)">makeSuite	| suite |	suite := SUnit.TestSuite new.	self navigator		currentTestClassAndSelectorsDo: [:mclass :selector | suite addTest: (mclass selector: selector)].	^suite</body><body package="SUnitToo(ls)">navigator	^codeModel navigator</body><body package="SUnitToo(ls)">refreshLists	self navigator setState: self navigator getState</body><body package="SUnitToo(ls)">runTestsUsing: aTestRunningBlock whenDone: aCompletionBlock	| progressView suite |	suite := self makeSuite.	suite isEmpty ifTrue: [^self].	self clearResults.	progressView := self addProgressView: suite.	progressView		when: SUnitTooRunDone		do:			[:note | 			[progressView unsubscribe: self.			results := note results.			self				updateBackColor;				refreshLists.			aCompletionBlock value] uiEventNowFor: self topComponent]		for: self.	progressView runSuiteUsing: aTestRunningBlock</body><body package="SUnitToo(ls)">stepInto: aTestCase 	| modified |	modified := aTestCase method addUnitTestInitialBreakpoint.	[aTestCase run] ensure: [modified ifTrue: [aTestCase method revert]]</body><body package="SUnitToo(ls)">updateTestCount: aCount	aCount = testCount ifFalse: [		| oldWasVisible |		testCount := aCount.		testCountLabel := Label with: testCount printString asText.		codeModel ifNotNil: [ testCountLabel textStyle: codeModel builder policy class systemWidgetTextStyle ].		oldWasVisible := isVisible.		isVisible := testCount ~= 0.		"TODO: ASB - won't need this once we are no longer a Panel and can use standard CompositePart geometry methods"		oldWasVisible ~= isVisible ifTrue: [ self changedPreferredGeometry ].		self invalidate.	]</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>private-debugging</category><body package="SUnitToo(ls)">debug: aTestCase 	SUnit.TestCase 		when: SUnit.Failure		do: [:failure | self debugFailure: failure exception]		for: self.	SUnit.TestCase 		when: SUnit.SomeError		do: [:error | self debugError: error exception]		for: self.	[aTestCase debug] ensure: [SUnit.TestCase unsubscribe: self]</body><body package="SUnitToo(ls)">debugError: anException 	(anException respondsTo: #pretendDefaultAction) 		ifTrue: [anException pretendDefaultAction].	^Notifier developmentNotifier openOnException: anException</body><body package="SUnitToo(ls)">debugFailure: anException 	| tmpDebugger testContext machineryContext message |	machineryContext := self searchForFirstTestMachineryContext: anException.	testContext := machineryContext sender.	anException unwindTo: testContext.	message := Message new setSelector: machineryContext selector				arguments: ((1 to: machineryContext selector numArgs) 						collect: [:n | machineryContext localAt: n]).	testContext restackMessage: message to: testContext receiver.	tmpDebugger := DebuggerService basicNew.	testContext jump: (tmpDebugger presendPCFor: testContext) - testContext pc.	DebuggerService 		openOn: testContext		exception: anException		interrupted: true</body><body package="SUnitToo(ls)">searchForFirstTestMachineryContext: anException 	| n candidateContext |	n := 10.	candidateContext := anException topOfContextStack.	[n &gt; 0 and: [candidateContext notNil]] whileTrue: 			[candidateContext sender ifNotNil: [:sender | (sender mclass inheritsFrom: SUnit.TestCase) 				ifTrue: [^candidateContext]].			candidateContext := candidateContext sender.			n := n - 1].	^anException topOfContextStack</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>testing</category><body package="SUnitToo(ls)">hasBrokenTests	^results notNil and: [results allPassed not]</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>actions</category><body package="SUnitToo(ls)">browseBrokenTests	| definitions |	self hasBrokenTests ifFalse: [ ^self ].	definitions := (self defects collect: [ :each | each definition ]) sort.	RefactoringBrowser		openListBrowserOn: definitions		label:			('&lt;1s&gt; &lt;2s&gt; / &lt;3s&gt;'				expandMacrosWith: Date today shortPrintString				with: Time now shortPrintString				with: results printString)		initialSelection: nil</body><body package="SUnitToo(ls)">debugTests	self		runTestsUsing: [:each | self debug: each]		whenDone: nil</body><body package="SUnitToo(ls)">runTests	self		runTestsUsing: [:each | each run]		whenDone:			[(self hasBrokenTests and: [results ranCount &gt; 1])				ifTrue: [self browseBrokenTests]]</body><body package="SUnitToo(ls)">stepIntoTest	self		runTestsUsing: [:each | self stepInto: each]		whenDone: nil</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>displaying</category><body package="SUnitToo(ls)">displayColoring: aGC	results ifNil: [^self].	results codeToolLabelColor		ifNotNil:			[:paint | 			aGC paint: paint.			aGC displayRectangle: self bounds]</body><body package="SUnitToo(ls)">displayOn: aGC	isVisible ifTrue: [		self displayColoring: aGC.		aGC paint: ColorValue black.		label displayOn: aGC at: (self bounds left + 8) @ (self bounds center y - (label height / 2)).		self displayTestCount: aGC.		^super displayOn: aGC	]</body><body package="SUnitToo(ls)">displayTestCount: aGC	aGC paint: SymbolicPaint foreground.	testCountLabel displayOn: aGC		at: (self children last propertyAt: #frame) rightCenter				- (-4 @ testCountLabel height half)</body><body package="SUnitToo(ls)">updateBackColor	self invalidate</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>initialize-release</category><body package="SUnitToo(ls)">codeModel: aCodeModel	codeModel := aCodeModel.	label textStyle: codeModel builder policy class systemWidgetTextStyle.</body><body package="SUnitToo(ls)">initialize	super initialize.	isVisible := false.	label := Label with: 'Test:' asText allBold.	self addButtons.</body><body package="SUnitToo(ls)">initializeLayoutAlgorithm	self childFramingBlock: [ :rectangle :child :index | 		| left top |		left := rectangle left + 4 + label preferredWidth - child alignmentRectInsets left +  8 + ((index - 1) * (child alignmentPreferredWidth + 5)).		top := rectangle center y - child preferredHeight half.		left @ top extent: child preferredExtent	]</body><body package="SUnitToo(ls)">killUpdateProcess	updateProcess ifNotNil: #terminate.	updateProcess := nil</body><body package="SUnitToo(ls)">newGraphicsDevice: aGraphicsDevice	"Forward the newGraphicsDevice: aGraphicsDevice messages	to the receiver's components."	super newGraphicsDevice: aGraphicsDevice.	self initializeLayoutAlgorithm.</body><body package="SUnitToo(ls)">release	self killUpdateProcess.	super release</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>building widgets</category><body package="SUnitToo(ls)">addButtons	(Pragma allNamed: #subpart: in: self class sortedByArgument: 1) do: [:each |		self add: (self perform: each selector)	]</body><body package="SUnitToo(ls)">newButton	| button |	button := ActionButtonView new.	button controller deactivate.	button hasBorder: false.	^button</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>bounds accessing</category><body package="SUnitToo(ls)">intrinsicHeight	^16</body><body package="SUnitToo(ls)">intrinsicWidth	^145</body><body package="SUnitToo(ls)">maximumExtent	^self preferredExtent</body><body package="SUnitToo(ls)">minimumExtent	^self preferredExtent</body><body package="SUnitToo(ls)">preferredExtent	^145 @ 16</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>visual properties</category><body package="SUnitToo(ls)">isVisible	^isVisible</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>accessing</category><body package="SUnitToo(ls)">clearResults		results ifNotNil: [		results := nil.		self invalidate	]</body><body package="SUnitToo(ls)">touch	self killUpdateProcess.	updateProcess := [		| newTestCount |		self topComponent ifNotNil: [ :window |			window isOpen ifTrue: [				[ self updateTestCount: 0 ] uiEventFor: window			]		].		newTestCount := self computeTestCount.		self clearResults.		self topComponent ifNotNil: [ :window |			window isOpen ifTrue: [				[ self updateTestCount: newTestCount ] uiEventFor: window			]		].		updateProcess := nil	] forkAt: Processor userBackgroundPriority - 1</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar class</class-id> <category>example</category><body package="SUnitToo(ls)">example	"self example"	| window |	window := ApplicationWindow new.	window component: self new.	window openWithExtent: 600 @ 100.	^window</body></methods><methods><class-id>Refactory.Browser.SUnitTooRunDone</class-id> <category>accessing</category><body package="SUnitToo(ls)">results	^results</body><body package="SUnitToo(ls)">results: anObject	results := anObject</body></methods><methods><class-id>Refactory.Browser.SUnitTooRunDone class</class-id> <category>instance creation</category><body package="SUnitToo(ls)">with: aResults	^self new results: aResults</body></methods><methods><class-id>Refactory.Browser.AllTestsStatus class</class-id> <category>accessing</category><body package="SUnitToo(ls)">classTestStatus: aClass	| stats definition |	stats := Set new.	aClass testSelectorsDo: 			[:selector :method |			definition := MethodDefinition						class: aClass						implementor: method mclass						selector: selector.			stats add: (self definitionTestStatus: definition)]		skipping: IdentitySet new.	^stats</body><body package="SUnitToo(ls)">definitionTestStatus: aMethodDefinition 	^self method: aMethodDefinition method		definitionTestStatus: aMethodDefinition</body><body package="SUnitToo(ls)">method: aMethod definitionTestStatus: aMethodDefinition 	^(results at: aMethod ifAbsent: [^UndefinedObject]) at: aMethodDefinition		ifAbsent: [UndefinedObject]</body><body package="SUnitToo(ls)">packageTestStatus: aPackageModel 	| stats |	stats := Set new.	aPackageModel definedClassesDo: 			[:class | 			((class inheritsFrom: SUnit.TestCase) and: [class isAbstract not]) 				ifTrue: [stats addAll: (self classTestStatus: class)]].	^stats</body></methods><methods><class-id>Refactory.Browser.AllTestsStatus class</class-id> <category>class initialization</category><body package="SUnitToo(ls)">initialize	"self initialize"	results := EphemeronDictionary new.	self collect</body></methods><methods><class-id>Refactory.Browser.AllTestsStatus class</class-id> <category>private</category><body package="SUnitToo(ls)">addResult: aResult 	(results at: aResult method ifAbsentPut: [CompactDictionary new]) 		at: aResult definition		put: aResult class</body><body package="SUnitToo(ls)">cease	SUnit.TestCase unsubscribe: self</body><body package="SUnitToo(ls)">clearDefinitions: aMethodDefinitions		aMethodDefinitions		do:			[:each | 			results				at: each method				ifPresent:					[:map | 					map						removeKey: each						ifAbsent: []]]</body><body package="SUnitToo(ls)">collect	self cease.	SUnit.TestCase 		when: SUnit.Result		send: #addResult:		to: self</body></methods><methods><class-id>Refactory.Browser.AllTestsStatus class</class-id> <category>initialize-release</category><body package="SUnitToo(ls)">obsolete	self cease.	^super obsolete</body></methods><methods><class-id>SUnit.Failure class</class-id> <category>utility</category><body package="SUnitToo(ls)">testCaseIcon	^TestIcons testFailure</body><body package="SUnitToo(ls)">testMethodIcon	^TestIcons testFailure</body><body package="SUnitToo(ls)">testWorseThan: aResultType	^aResultType ~~ SomeError</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>testing</category><body package="SUnitToo(ls)">hasMixedReceiverTests	"Return whether or not I represent a mixed batch of tests, as in the fixture isn't the same for all tests."		| probe |	probe := resourceAndDefinitions any any inheritingClass.	^resourceAndDefinitions		allSatisfy:			[:byResources | byResources anySatisfy: [:each | each inheritingClass ~~ probe]]</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>private-selectors</category><body package="SUnitToo(ls)">allMethodDefinitionsFor: aProtocol in: class 	| selectors |	selectors := Set new.	"this section added to do VERY SPECIAL things for TestCases when they involve inheritance"	(class superclass notNil and: [class superclass inheritsFrom: SUnit.TestCase]) 		ifTrue: 			[class testSelectorsDo: 					[:eachSelector | 					| definition |					definition := (RBMethodDefinition class: class selector: eachSelector) 								resolve.					definition implementingClass ~= class 						ifTrue: 							[((navigator environment selectorsFor: aProtocol								in: definition implementingClass) includes: eachSelector) 								ifTrue: [selectors add: definition]]]].	"end addition"	self inheritedClassesOf: class		do: 			[:each | 			selectors 				addAll: ((navigator environment selectorsFor: aProtocol in: each) collect: 							[:sel | 							RBMethodDefinition 								class: class								implementor: each								selector: sel])].	^selectors</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>private</category><body package="SUnitToo(ls)">allProtocolsIn: aNavigatorState 	| protocols class |	class := aNavigatorState selectedClass.	(class notNil and: 			[aNavigatorState objectNames size = 1 and: 					[aNavigatorState pundles notEmpty]]) 		ifTrue: 			[protocols := Set new.			self inheritedClassesOf: class				do: 					[:each | 					protocols addAll: each organization categories	"Was self environment protocolsFor: each"].			"very special branch here to deal with TestCase in inheritance situation"			(class superclass notNil and: [class superclass inheritsFrom: SUnit.TestCase]) 				ifTrue: 					[class testSelectorsDo: 							[:eachSelector | 							| definition |							definition := (MethodDefinition class: class selector: eachSelector) 										resolve.							definition implementingClass ~= class 								ifTrue: 									[protocols add: (definition implementingClass organization 												categoryOfItem: eachSelector)]]]			"end special branch"]		ifFalse: [protocols := #()].	^protocols</body></methods><methods><class-id>Core.Class class</class-id> <category>compiling</category><body package="SUnitToo(ls)">instanceMethodsChanged	"We have to guard ourself against the case where the regenerator method is not yet loaded."	(self respondsTo: #regenerateTestClassQuery)		ifTrue: [self regenerateTestClassQuery].	^super instanceMethodsChanged</body></methods><methods><class-id>Core.Class class</class-id> <category>sunittools</category><body package="SUnitToo(ls)">regenerateTestClassQuery	| ws selectors |	self == Class ifFalse: [^self].	selectors := ((Pragma allNamed: #testClassQuery in: self)		collect: [:each | each selector]) asSortedCollection.	ws := String new writeStream.	ws nextPutAll: '[:arg | '.	selectors		do:			[:each | 			ws				nextPutAll: 'arg ';				nextPutAll: each]		separatedBy: [ws nextPutAll: ' ifNil: ['].	selectors size - 1 timesRepeat: [ws nextPut: $]].	ws nextPutAll: ']'.	TestClassQuery := Compiler		evaluate: ws contents		logged: false</body></methods><methods><class-id>Core.Class</class-id> <category>sunittools</category><body package="SUnitToo(ls)">guessTestClass	^TestClassQuery value: self</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="SUnitToo(ls)">isTestCase	^false</body></methods><methods><class-id>Refactory.Browser.NavigatorState</class-id> <category>sunittoo</category><body package="SUnitToo(ls)">apparentSelectedPackages	| packages |	packages := Set new.	self pundles do: [:each | packages addAll: each leafItems].	^packages</body><body package="SUnitToo(ls)">classOrAllPundleTestsDo: aBlock	self		classTestsDo: [:mclass :selector | aBlock value: mclass value: selector].	(self selectedClasses collect: [:each | self testClassFor: each]) asSet		isEmpty ifTrue: [self pundleTestsDo: aBlock]</body><body package="SUnitToo(ls)">classTestsDo: aBlock 	(self selectedClasses collect: [:each | self testClassFor: each]) asSet 		do: [:eachTestClass | self testSelectorsForClass: eachTestClass do: aBlock]</body><body package="SUnitToo(ls)">currentTestClassAndSelectorsDo: aBlock	self definitions isEmpty ifFalse: [^self methodOrAllClassTestsDo: aBlock].	self protocol ifNotNil: [^self protocolOrAllClassTestsDo: aBlock].	self selectedClass ifNotNil: [^self classOrAllPundleTestsDo: aBlock].	self pundle ifNotNil: [^self pundleTestsDo: aBlock]</body><body package="SUnitToo(ls)">effectivePackageForTestClass: aTestClass selector: aSelector	| definition methodPackage abstractClassPackage |	definition := (MethodDefinition class: aTestClass selector: aSelector)				resolve.	methodPackage := definition package.	definition implementingClass == definition inheritingClass		ifTrue: [^methodPackage].	"If the inherited selector resides in the same package as its class, then we consider it bound to the inheriting test class's package, otherwise the package it is defined in."	abstractClassPackage := Store.Registry				containingPackageForClass: definition implementingClass.	^abstractClassPackage == methodPackage		ifTrue: [Store.Registry containingPackageForClass: aTestClass]		ifFalse: [methodPackage]</body><body package="SUnitToo(ls)">methodOrAllClassTestsDo: aBlock	| enumerated |	enumerated := false.	definitions do: 			[:each |			(each isForSharedVariable not and: 					[each method notNil						and: [each method isTestCaseMethod and: [each inheritingClass isAbstract not]]])				ifTrue: 					[enumerated := true.					aBlock value: each inheritingClass value: each selector]].	enumerated ifFalse: [self classTestsDo: aBlock]</body><body package="SUnitToo(ls)">protocolOrAllClassTestsDo: aBlock	| enumerated filter |	enumerated := false.	filter := self protocols.	self		classTestsDo:			[:mclass :selector | 			(filter				includes:					((mclass whichClassIncludesSelector: selector) organization categoryOfItem:							selector))				ifTrue:					[enumerated := true.					aBlock value: mclass value: selector]].	enumerated ifFalse: [self classTestsDo: aBlock]</body><body package="SUnitToo(ls)">pundleTestsDo: aBlock	| packages visitedClasses |	packages := self apparentSelectedPackages.	visitedClasses := Set new.	packages do: 			[:eachPackage |			eachPackage classModelsDo: 					[:eachClassModel |					eachClassModel actual						ifNotNil: 							[:eachTestClass |							(visitedClasses includes: eachTestClass)								ifFalse: 									[visitedClasses add: eachTestClass.									self testSelectorsForClass: eachTestClass										do: 											[:class :selector |											(packages												includes: (self effectivePackageForTestClass: class selector: selector))													ifTrue: [aBlock value: class value: selector]]]]]]</body><body package="SUnitToo(ls)">testClassFor: aClass	| realClass |	realClass := aClass isMeta		ifTrue: [aClass soleInstance]		ifFalse: [aClass].	realClass isTestCase ifTrue: [^realClass].	^realClass guessTestClass</body><body package="SUnitToo(ls)">testSelectorsForClass: aClass do: aBlock	(aClass notNil and: [aClass isTestCase and: [aClass isAbstract not]])		ifTrue:			[aClass				testSelectorsDo:					[:each | 					aBlock						value: aClass						value: each]]</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>sunittoo</category><body package="SUnitToo(ls)">testClassAndSelectorsDo: aBlock	self classesDo: 			[:eachClass |			(eachClass isTestCase and: [eachClass isAbstract not])				ifTrue: 					[eachClass testSelectorsDo: 							[:selector |							(self includesSelector: selector in: eachClass)								ifTrue: [aBlock value: eachClass value: selector]]]]</body></methods><methods><class-id>Core.MessageNotUnderstood</class-id> <category>accessing</category><body package="SUnitToo(ls)">pretendDefaultAction	reachedDefaultHandler := true</body></methods><methods><class-id>Refactory.Browser.CodeModel</class-id> <category>test case support</category><body package="SUnitToo(ls)">environmentTestsDo: aBlock 	self environment classesDo: 			[:eachClass | 			self testSelectorsForClass: eachClass				do: 					[:mclass :selector | 					(self environment includesSelector: selector in: mclass) 						ifTrue: [aBlock value: mclass value: selector]]]</body></methods><methods><class-id>SUnit.Result class</class-id> <category>utility</category><body package="SUnitToo(ls)">testCaseIcon	^self subclassResponsibility</body><body package="SUnitToo(ls)">testMethodIcon	^self subclassResponsibility</body><body package="SUnitToo(ls)">testWorseThan: aResultType 	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="SUnitToo(ls)">canMakeTestTooFromSelectedClass	| testClassName |	self isClassSelected ifFalse: [^false].	('*Test' match: self selectedClass instanceBehavior name) ifTrue: [^false].	testClassName := (self selectedClass instanceBehavior name , 'Test') asSymbol.	^(self selectedClass environment includesKey: testClassName) not</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>sunittoo</category><body package="SUnitToo(ls)">currentTestClassAndSelectorsDo: aBlock	| enumerated |	enumerated := false.	self state currentTestClassAndSelectorsDo: 			[:mclass :selector |			enumerated := true.			aBlock value: mclass value: selector].	(enumerated not and: [self state hasSelection not])		ifTrue: [self environment testClassAndSelectorsDo: aBlock]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="SUnitToo(ls)">hasSUnitTooToXPSUnitCandidatesSelected	^#{XProgramming.SUnit.TestCase} isDefined and: 			[#{SUnit.TestCase} ifDefinedDo: 					[:parent | 					self selectedClasses 						anySatisfy: [:each | each instanceBehavior isDirectSubclassOf: parent]]				elseDo: [false]]</body><body package="SUnitToo(ls)">hasXPSUnitToSUnitTooCandidatesSelected	^#{SUnit.TestCase} isDefined and: 			[#{XProgramming.SUnit.TestCase} ifDefinedDo: 					[:parent | 					self selectedClasses 						anySatisfy: [:each | each instanceBehavior isDirectSubclassOf: parent]]				elseDo: [false]]</body></methods><methods><class-id>Core.UndefinedObject class</class-id> <category>accessing</category><body package="SUnitToo(ls)">testCaseIcon	^TestIcons caseNotRun</body><body package="SUnitToo(ls)">testMethodIcon		^TestIcons testNotRun</body><body package="SUnitToo(ls)">testWorseThan: aResultType 	^aResultType ~~ SUnit.Pass</body></methods><methods><class-id>SUnit.SomeError class</class-id> <category>utility</category><body package="SUnitToo(ls)">testCaseIcon	^TestIcons testError</body><body package="SUnitToo(ls)">testMethodIcon		^TestIcons testError</body><body package="SUnitToo(ls)">testWorseThan: aResultType 	^true</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>RefactoringBrowser</category><body package="SUnitToo(ls)">browserIcon	^self toolListIcon</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>compiling</category><body package="SUnitToo(ls)">classMethodsChanged	"For now, this happens when #testClassQuery noted methods are added. each time that happens, we want to regenerate an approprirate guessTestedClass method."	"We have to guard against the load order condition where this and the change triggering methods are loaded before the adaptive generator exists."	(self respondsTo: #regenerateTestedClassQuery)		ifTrue: [self regenerateTestedClassQuery].	^super classMethodsChanged</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>sunittools</category><body package="SUnitToo(ls)">guessTestedClass	^TestedClassQuery value: self</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>accessing</category><body package="SUnitToo(ls)">initialMethodCategory	^#tests</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>sunittools</category><body package="SUnitToo(ls)">regenerateTestedClassQuery	| ws selectors |	selectors := ((Pragma		allNamed: #testedClassQuery		in: self class) collect: [:each | each selector]) asSortedCollection.	ws := String new writeStream.	ws nextPutAll: '[:arg | '.	selectors		do:			[:each | 			ws				nextPutAll: 'arg ';				nextPutAll: each]		separatedBy: [ws nextPutAll: ' ifNil: ['].	selectors size - 1 timesRepeat: [ws nextPut: $]].	ws nextPutAll: ']'.	TestedClassQuery := Compiler		evaluate: ws contents		logged: false</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>accessing</category><body package="SUnitToo(ls)">toolListIcon	| stats |	self isAbstract ifTrue: [^TestIcons caseAbstract].	stats := (Refactory.Browser.AllTestsStatus classTestStatus: self) 				asSortedCollection: [:a :b | a testWorseThan: b].	stats isEmpty ifTrue: [^TestIcons caseNotRun].	^stats first testCaseIcon</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>menus</category><body package="SUnitToo(ls)">activateExistingBufferFor: aNonMetaClass	^(self toolsets		detect: [:each | each nonMetaClass = aNonMetaClass]		ifNone: [nil])		ifNotNil:			[:alreadyOpen | self switchToBuffer: (self toolsets indexOf: alreadyOpen)]</body><body package="SUnitToo(ls)">createBufferFor: aNonMetaClass	self newBuffer.	self currentToolset navigator selectClass: aNonMetaClass</body><body package="SUnitToo(ls)">flipToTestClass	| selectedClass testCaseClass |	selectedClass := self currentToolset nonMetaClass.	testCaseClass := selectedClass guessTestClass		ifNil: [^Screen default ringBell].	(self activateExistingBufferFor: testCaseClass) ifNotNil: [^self].	self unpairedTestingToolsets		do:			[:each | 			self currentToolset: each.			^self currentToolset navigator selectClass: testCaseClass].	self createBufferFor: testCaseClass</body><body package="SUnitToo(ls)">flipToTestedClass	| selectedClass |	selectedClass := self currentToolset nonMetaClass.	selectedClass guessTestedClass		ifNotNil:			[:testedClass | 			(self activateExistingBufferFor: testedClass)				ifNil: [self createBufferFor: testedClass]]		ifNil: [^Screen default ringBell]</body><body package="SUnitToo(ls)">testingToolsets	^self toolsets		select:			[:each | 			each nonMetaClass				ifNotNil: [:selectedClass | selectedClass isTestCase]				ifNil: [false]]</body><body package="SUnitToo(ls)">unpairedTestingToolsets	"find buffers which currently have a test class selected, but for which there is no buffer which is for its target, then we can use those for recycling"		^self testingToolsets		select:			[:each | 			each nonMetaClass isTestCase				and:					[each nonMetaClass guessTestedClass						ifNil: [false]						ifNotNil:							[:testedClass | (self toolsets anySatisfy: [:any | any selectedClass = testedClass]) not]]]</body></methods><methods><class-id>SUnit.Results</class-id> <category>accessing</category><body package="SUnitToo(ls)">codeToolLabelColor	self isEmpty ifTrue: [^nil].	self allPassed ifTrue: [^ColorValue green].	^ColorValue red</body></methods><methods><class-id>SUnit.Pass class</class-id> <category>utility</category><body package="SUnitToo(ls)">testCaseIcon	^TestIcons testPass</body><body package="SUnitToo(ls)">testMethodIcon		^TestIcons testPass</body><body package="SUnitToo(ls)">testWorseThan: aResultType 	^false</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="SUnitToo(ls)">addTestIcon: aTestIcon to: aBaseIcon 	^VisualBlock block: 			[:gc :box | 			gc display: aBaseIcon at: box origin.			gc display: aTestIcon at: (box left + aBaseIcon width) @ box top]		bounds: (Point zero 				extent: (aBaseIcon width + aTestIcon width) @ aBaseIcon height)</body><body package="SUnitToo(ls)">guessTestedPackage	"attempt to guess if there's a package loaded that is meant as the target for my tests"	| candidateName |	self isTestPackage ifFalse: [^nil].	candidateName := self name		copyFrom: 1		to: self name size - 'Tests' size.	[candidateName isEmpty not and: [candidateName last isAlphaNumeric]]		whileFalse:			[candidateName := candidateName				copyFrom: 1				to: candidateName size - 1].	^candidateName isEmpty		ifTrue: [nil]		ifFalse: [Store.Registry packageNamed: candidateName]</body><body package="SUnitToo(ls)">guessTestPackage	"attempt to guess if there's a package loaded that is meant for my tests"	self isTestPackage ifTrue: [^nil].	#('Tests' ' Tests' '-Tests')		do:			[:each | 			(Store.Registry packageNamed: self name , each)				ifNotNil: [:package | ^package]].	^nil</body><body package="SUnitToo(ls)">isTestPackage	"shady heuristic for determining if i'm a package for tests or not"	^'*Tests' match: self name</body><body package="SUnitToo(ls)">pundleListIcon	| baseIcon |	baseIcon := super pundleListIcon.		[| stats |	stats := (Refactory.Browser.AllTestsStatus packageTestStatus: self) 				asSortedCollection: [:a :b | a testWorseThan: b].	stats notEmpty 		ifTrue: [^self addTestIcon: stats first testCaseIcon to: baseIcon]] 			on: Error			do: 				[:ex | 				" we have to protect ourselves like this because of a method load order race condition when the parcel is first loading"				].	^baseIcon</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>converting</category><body package="SUnitToo(ls)">addUnitTestInitialBreakpoint	| probedMethod probe n |	self isProbed ifTrue: [^false].	probedMethod := self newFullProbedMethod.	probe := CodeProbe new.	n := self selector size + 1.	"this assumes a unary method name"	probe record: (probedMethod probeRecordFor: (n to: n)).	probedMethod addProbe: probe.	probe unconditionallyInsertInto: probedMethod replacing: self.	^true</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SUnitToo(ls)">isTestCaseMethod	^(self mclass inheritsFrom: SUnit.TestCase) 		and: [('test*' match: self selector) or: [self hasAttributeSelector: #test]]</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar</class-id> <category>action buttons</category><body package="SUnitToo(ls)">debugButton	&lt;subpart: 3&gt;	| button |	button := self newButton action: [self debugTests].	button label: TestIcons debugTests.	button helpText: #debugTests &gt;&gt; 'Debug Tests' &lt;&lt; #sunitToo.	^button</body><body package="SUnitToo(ls)">runButton	&lt;subpart: 1&gt;	| button |	button := self newButton action: [self runTests].	button label: TestIcons runTest.	button helpText: #runTests &gt;&gt; 'Run Tests' &lt;&lt; #sunitToo.	^button</body><body package="SUnitToo(ls)">stepButton	&lt;subpart: 2&gt;	| button |	button := self newButton action: [self stepIntoTest].	button label: TestIcons stepTests.	button helpText: #stepIntoTest &gt;&gt; 'Step Into Test' &lt;&lt; #sunitToo.	^button</body></methods><methods><class-id>Refactory.Browser.SUnitTooMiniBar class</class-id> <category>method tags</category><body package="SUnitToo(ls)">subpartMethodTag	&lt;pragmas: #instance&gt;	^#(#subpart:)</body></methods><methods><class-id>Core.Class class</class-id> <category>sunittools</category><body package="SUnitToo(ls)">testClassQueryTags	&lt;pragmas: #instance&gt;	^#(#testClassQuery)</body></methods><methods><class-id>Core.Class</class-id> <category>sunittools</category><body package="SUnitToo(ls)">guessTestClassByName	"An attempt to find a TestCase that is associated with me as my test class."	&lt;testClassQuery&gt;	| testClassName |	testClassName := (self name , 'Test') asSymbol.	(BindingReference simpleName: testClassName in: environment)		ifDefinedDo:			[:value | (value isForClass and: [value isTestCase]) ifTrue: [^value]].	^nil</body><body package="SUnitToo(ls)">guessTestClassByPackage	"now look to see if there's a TestClass in an associate test package"	&lt;testClassQuery&gt;	| testClassName |	testClassName := (self name , 'Test') asSymbol.	(Store.Registry containingPackageForClass: self)		ifNotNil:			[:package | 			package guessTestPackage				ifNotNil:					[:testPackage | 					(testPackage definedClasses						detect: [:each | each name = testClassName and: [each isTestCase]]						ifNone: []) ifNotNil: [:value | ^value]]].	^nil</body></methods><methods><class-id>Refactory.Browser.CodeModel</class-id> <category>status registration</category><body package="SUnitToo(ls)">sunitTooMiniBarClass	&lt;toolgap: 90 width: 1&gt;	&lt;tool: 90.1 width: #intrinsic&gt;		^BoundedWrapper on: (SUnitTooMiniBar new codeModel: self; touch; yourself)</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="SUnitToo(ls)">addTestTooClass	"think about the name, it's a great play on words"	&lt;menuItem: 'Add Test Case'		icon: nil		nameKey: #addTestTooClass		enablement: #canMakeTestTooFromSelectedClass		indication: nil		menu: #(#classMenu )		position:200.0&gt;	| testClassName defString change testeePackage |	testClassName := (self nonMetaClass name , 'Test') asSymbol.	defString := '&lt;1s&gt; defineClass: &lt;2p&gt;	superclass: #{SUnit.TestCase}	indexedType: #none	private: false	instanceVariableNames: ''''	classInstanceVariableNames: ''''	imports: ''''	category: '''''		expandMacrosWith: self selectedClass environment unambiguousName		with: testClassName.	change := AddClassChange definition: defString.	testeePackage := Store.Registry		containingPackageForClass: self nonMetaClass.	change package: (testeePackage guessTestPackage ifNil: [testeePackage]).	RefactoryChangeManager instance performChange: change.	self selectClass: (self selectedClass environment at: testClassName).	self refreshLists</body><body package="SUnitToo(ls)">changeSUnitTooTestCasesToXPSUnit	&lt;menuItem: 'Use XProgramming.SUnit'		icon: nil		nameKey: #changeSUnitTooTestCasesToXPSUnit		enablement: #hasSUnitTooToXPSUnitCandidatesSelected		indication: nil		menu: #(#classMenu )		position:200.2&gt;	| change |	change := CompositeRefactoryChange new.	((self selectedClasses select: 			[:each | 			each instanceBehavior isDirectSubclassOf: #{Root.Smalltalk.SUnit.TestCase} value]) 		collect: [:each | each instanceBehavior]) do: 				[:each | 				| rs ws |				rs := each definition readStream.				ws := String new writeStream.				ws					nextPutAll: (rs upTo: Character cr);					cr.	"copy first line"				rs upTo: Character cr.	"throw out old superclass line"				ws nextPutAll: 'superclass: #{Root.Smalltalk.XProgramming.SUnit.TestCase}'.				ws nextPutAll: rs upToEnd.				change defineClass: ws contents.				each environment = #{Root.Smalltalk.SUnit} value 					ifTrue: 						[change moveObjectNamed: each fullName							to: 'Root.Smalltalk.XProgramming.SUnit']].	RefactoryChangeManager instance performChange: change.	self refreshLists</body><body package="SUnitToo(ls)">changeXPSUnitTestCasesToSUnitToo	&lt;menuItem: 'Use SUnitToo'		icon: nil		nameKey: #changeXPSUnitTestCasesToSUnitToo		enablement: #hasXPSUnitToSUnitTooCandidatesSelected		indication: nil		menu: #(#classMenu )		position:200.1&gt;	| change rs ws |	change := CompositeRefactoryChange new.	((self selectedClasses select: 			[:each | 			each instanceBehavior 				isDirectSubclassOf: #{Root.Smalltalk.XProgramming.SUnit.TestCase} value]) 		collect: [:each | each instanceBehavior]) do: 				[:each | 				rs := each definition readStream.				ws := String new writeStream.				ws					nextPutAll: (rs upTo: Character cr);					cr.	"copy first line"				rs upTo: Character cr.	"throw out old superclass line"				ws nextPutAll: 'superclass: #{Root.Smalltalk.SUnit.TestCase}'.				ws nextPutAll: rs upToEnd.				change defineClass: ws contents.				each environment = #{Root.Smalltalk.XProgramming.SUnit} value 					ifTrue: [change moveObjectNamed: each fullName to: 'Root.Smalltalk.SUnit']].	RefactoryChangeManager instance performChange: change.	self refreshLists</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="SUnitToo(ls)">debugTests20x20	"UIMaskEditor new openOnClass: self andSelector: #debugTests20x20"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(771 771 771)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2313 2313 2313)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6167 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4626 4626 4626)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 7709 7709)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1285 1285 1285)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2827 2827 2827)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3598 3598 3598)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'QDQDQDP@QDQDQ@@@QDQDQDPCQDQDQ@@@QDQDQDPCQDQDQ@@@QDQDQDPCQDQDQ@@@QDQDQDPAIDQDQ@@@QDQDQDDAIDQDQ@@@QDQDQDDAIDQDQ@@@QDQDQDDAIDQDQ@@@QDQDQE@AIDQDQ@@@QDQDP@@AIDQDQ@@@QDQDXDD@QDQDQ@@@QDQD@DP@QDQDQ@@@QDQD@DQDQDQDQ@@@QDQD@@AVX4QDQ@@@QDQDP@AUUDQDQ@@@QDQDQ@ADQDQDQ@@@QDQDQ@AGQDQDQ@@@QDQDP@A@ADQDQ@@@QDQ@@G]7L"QDQ@@@QDP@@@@@UWIDQ@@@'))</body><body package="SUnitToo(ls)">debugTests20x20mask	"UIMaskEditor new openOnClass: self andSelector: #debugTests20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 48 0 0 0 48 0 0 0 48 0 0 0 48 0 0 0 56 0 0 0 120 0 0 0 120 0 0 0 120 0 0 0 248 0 0 1 248 0 0 3 112 0 0 3 48 0 0 3 0 0 0 3 252 0 0 1 248 0 0 0 192 0 0 0 208 0 0 1 216 0 0 7 254 0 0 15 255 0 0])</body><body package="SUnitToo(ls)">runTests20x20	"UIMaskEditor new openOnClass: self andSelector: #runTests20x20"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 6970 6970)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7452 7452 7452)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7773 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4689 7869 4625)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5396 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2055 2055 2055)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7387 7387 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3083 3083)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;U[P"H+FI%&amp;Y @@Y&amp;YU-BIA"YY&amp;Y @@Y&amp;Y%-BIA FY&amp;Y @@Y&amp;Y%-J)A FY&amp;Y @@Y&amp;Y%-J^*!&amp;Y&amp;Y @@Y&amp;Y%-J]7*&amp;Y&amp;Y @@Y&amp;Y%-J]7]:)&amp;Y @@Y&amp;Y%-J]7]7^&amp;Y @@Y&amp;Y%-J]7]7^&amp;Y @@Y&amp;Y%-J]7]&lt;1&amp;Y @@Y&amp;Y%-J]73FY&amp;Y @@Y&amp;Y%-J_L!&amp;Y&amp;Y @@Y&amp;Y%-L1A FY&amp;Y @@Y&amp;Y%-BIA"VY&amp;Y @@Y&amp;Y&amp;UTII%&amp;Y&amp;Y @@Y&amp;Y&amp;Y,2VY&amp;Y&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@'))</body><body package="SUnitToo(ls)">runTests20x20mask	"UIMaskEditor new openOnClass: self andSelector: #runTests20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 255 0 0 15 254 0 0 7 252 0 0 7 252 0 0 7 248 0 0 7 252 0 0 7 255 0 0 7 255 128 0 7 255 128 0 7 255 0 0 7 252 0 0 7 248 0 0 7 252 0 0 7 252 0 0 3 248 0 0 0 224 0 0 0 0 0 0 0 0 0 0])</body><body package="SUnitToo(ls)">stepIntoTest20x20	"UIMaskEditor new openOnClass: self andSelector: #stepIntoTest20x20"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 6970 6970)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3083 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 4111 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7387 7387 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7773 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2055 2055 2055)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@QDQI&amp;YQDQDQDQ@@@QDRTQD%DQDQDQ@@@QD%DQDRTQDQDQ@@@QD%FY7NUTH!DQ@@@QD%DY''NUBHQDQ@@@QD%DQ''NU@TQDQ@@@QD%DQ''NU@TQDQ@@@QD%DQ''NU@TQDQ@@@QI&amp;TQ''NU@TQDQ@@@QI&amp;TQ''NU@TQDQ@@@QDQDQ)&amp;Y$TQDQ@@@QDQDQ''&amp;Y@TQDQ@@@QDQDQ''NU@TQDQ@@@QDQDQ''M5@TQDQ@@@QDQDQ''MUBDQDQ@@@QDQDQF\@!DQDQ@@@QDQDQDH(QDQDQ@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="SUnitToo(ls)">stepIntoTest20x20mask	"UIMaskEditor new openOnClass: self andSelector: #stepIntoTest20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 128 0 0 8 64 0 0 16 32 0 0 23 255 0 0 19 254 0 0 17 252 0 0 17 252 0 0 17 252 0 0 57 252 0 0 57 252 0 0 1 252 0 0 1 252 0 0 1 252 0 0 1 252 0 0 1 252 0 0 0 248 0 0 0 112 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>sunittools</category><body package="SUnitToo(ls)">guessTestedClassByName	"attempt to determine what class i provide tests for by simple name lookup"	&lt;testedClassQuery&gt;	| testedClassName |	testedClassName := self name		copyFrom: 1		to: self name size - 'Test' size.	testedClassName isEmpty		ifTrue: [^nil]		ifFalse: [testedClassName := testedClassName asSymbol].	(BindingReference		simpleName: testedClassName		in: environment)		ifDefinedDo:			[:value | (value isForClass and: [value isTestCase not]) ifTrue: [^value]].	^nil</body><body package="SUnitToo(ls)">guessTestedClassByPackage	" see if we can find a class i provide tests for in an associated testPackage"	&lt;testedClassQuery&gt;	| testedClassName |	testedClassName := self name		copyFrom: 1		to: self name size - 'Test' size.	testedClassName isEmpty		ifTrue: [^nil]		ifFalse: [testedClassName := testedClassName asSymbol].	(Store.Registry containingPackageForClass: self)		ifNotNil:			[:package | 			package guessTestedPackage				ifNotNil:					[:testedPackage | 					(testedPackage definedClasses						detect:							[:each | each name = testedClassName and: [each isTestCase not]]						ifNone: []) ifNotNil: [:value | ^value]]].	^nil</body><body package="SUnitToo(ls)">testedClassQueryTags	&lt;pragmas: #class&gt;	^#(#testedClassQuery)</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>menus</category><body package="SUnitToo(ls)">toggleFromOrToTestingToolset	&lt;menuItem: '&amp;Toggle To/From Test Case' nameKey:			#toggleFromOrToTestingToolset enablement: true indication: nil		shortcutKeyCharacter: $t shortcutModifiers: 8 menu: #(#viewMenu)		position: 1000&gt;	| selectedClass |	(selectedClass := self currentToolset nonMetaClass)		ifNil: [^Screen default ringBell].	selectedClass isTestCase		ifTrue: [self flipToTestedClass]		ifFalse: [self flipToTestClass]</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>icons</category><body package="SUnitToo(ls)">sunitTooTestStatusIcon		&lt;icon: 50&gt;	^self method		ifNotNil:			[:method | 			method isTestCaseMethod				ifTrue:					[(Refactory.Browser.AllTestsStatus method: method definitionTestStatus:							self)						ifNil: [TestIcons testNotRun]						ifNotNil: [:result | result testMethodIcon]]]</body></methods><initialize><class-id>Refactory.Browser.AllTestsStatus</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>MessageNotUnderstood</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reachedDefaultHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NavigatorState</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractNavigatorState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Results</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errors passes failures </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>NavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>Panel</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layoutAlgorithm isInUpdate cachedPreferredExtent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>BrowserEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>RefactoringBrowser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractRefactoringBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policyClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-RB UI</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CodeModel</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractCodeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>TestSuite</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourceAndDefinitions </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>