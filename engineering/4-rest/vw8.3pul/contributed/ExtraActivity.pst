<?xml version="1.0"?><st-source><!-- Name: ExtraActivityNotice: Copyright 2003 - 2013 Travis GriggsThis utility is free to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: ExtraActivity adds a framework to VisualParts intended to make them easier to animate. Any VisualPart can respond to the following messages:#startActivityRate: aRateInHz	This message is uses to begin recieving periodic ticks with which any sort of work can be done, usually some sort of check for state change and redraw as appropriate#activityTickEvent: aTickEvent	This is the message you override in your subclass. You do your periodic work in here. Two important messages that aTickEvent respond to are #time and #deltaTime. #time acts as it does with all over events, the time according to the system micro clock that this event was initiated. #deltaTime returns the time in floating point seconds that has elapsed since the last time you recieved an event via this mechanism.#stopActivity	Shut down activity for this VisualPart. May be called redundantly.#isActivityTicking	Returns whether ticking is currently occuring, usually used as a guard clause if your using a trigger point such as displayOn: to start ticking.A view will only tick when it has a topComponent. When it doesn't ticking will be automatically shut down. Since tick events are serialized along the same event queue that other events occur, you don't have to worry about race conditions (e.g. a window closure pulling your GC out from under you). Also, the system is GC savvy. When your view is collected, any associated ticking overhead will be GC'ed as well.Look at the ClockExample class for an example.- - - ExtraActivity was written by Travis Griggs while at Key Technology. Much thanks to his teammates who used it and helped find bugs, and special thanks to Anthony Lander for helping evolve and critique the original design.DbIdentifier: bear73DbTrace: 401642DbUsername: tgriggsDbVersion: 18DevelopmentPrerequisites: #(#(#any 'Weaklings' ''))PackageName: ExtraActivityParcel: #('ExtraActivity')ParcelName: ExtraActivityPrerequisiteParcels: #(#('Weaklings' ''))PrintStringCache: (18,tgriggs)Version: 18Date: 10:18:25 AM April 10, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.1) of April 10, 2013 on April 10, 2013 at 10:18:25 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ExtraActivity</name><environment>Smalltalk</environment><private>false</private><imports>			Smalltalk.*			</imports><category>ExtraActivity</category><attributes><package>ExtraActivity</package></attributes></name-space><class><name>TickEvent</name><environment>ExtraActivity</environment><super>UI.Event</super><private>false</private><indexed-type>none</indexed-type><inst-vars>deltaMicroseconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>ExtraActivity</package></attributes></class><comment><class-id>ExtraActivity.TickEvent</class-id><body>You get one of these in your VisualPart's activityTickEvent: each time you get an activity tick. You can ask it (like any event) what its time is. But you can also ask it the deltaTime (which is a floating point value representing seconds) since the last one. Special care is taken by the queue-ing engine to make sure that missed events are skipped and the delta is adjusted appropriately.Instance Variables:	deltaMicroseconds	&lt;SmallInteger&gt;	number of microseconds since the last event. 0 for the first one</body></comment><class><name>ActivityLoop</name><environment>ExtraActivity</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process weakWidget microsecondGrid nextClockTick prevClockTick aliveCondition </inst-vars><class-inst-vars>registry </class-inst-vars><imports></imports><category>ExtraActivity</category><attributes><package>ExtraActivity</package></attributes></class><comment><class-id>ExtraActivity.ActivityLoop</class-id><body>One of me is created for each VisualPart that sends a startActivityTicking: message. My class has a registry for keeping track of me and managing me, such that there are never more than one activity loop per widget. I take special care to maintain that there is at most ever only one TickEvent in the widget's window manager queue for me. If one is found, it is reused and updated as appropriate.Instance Variables:	microsecondGrid	&lt;Integer&gt;	my API is in HZ, but internally, I turn that into the number of microseconds between each tick	nextClockTick	&lt;Integer&gt;	the next microsecond clock time we'll be ticking at, used in the wait and to compute the delta	prevClockTick	&lt;Integer&gt;	the last microsecond clock time we ticked at, used to compute the delta and filter the first tick as there is no delta at the first tick	process	&lt;Process&gt;	the actual process which does the wait/tick cycle	weakWidget	&lt;Weakling&gt;	weak reference to the widget i'm providing the ticking service for. I'll stop when it goes nil and not get in the way of the GC getting rid of him	aliveCondition &lt;BlockClosure&gt; this is used to optionally add a condition which further tunes how long we keep the activity loop alilve. Use the #stopWhen:/continueWhile: APIs to set it, otherwise it's initialized to be a no op</body></comment><methods><class-id>ExtraActivity.TickEvent</class-id> <category>accessing</category><body package="ExtraActivity">addMicrosecondDelta: aMicrosecondsDelta 	deltaMicroseconds := aMicrosecondsDelta + deltaMicroseconds</body><body package="ExtraActivity">deltaTime	^1e-6 * deltaMicroseconds</body></methods><methods><class-id>ExtraActivity.TickEvent</class-id> <category>testing</category><body package="ExtraActivity">isUnknownEvent	^true</body></methods><methods><class-id>ExtraActivity.TickEvent</class-id> <category>initialize-release</category><body package="ExtraActivity">initialize	deltaMicroseconds := 0</body></methods><methods><class-id>ExtraActivity.TickEvent</class-id> <category>dispatching</category><body package="ExtraActivity">dispatch	^initiator activityTickEvent: self</body><body package="ExtraActivity">dispatchTo: ingored 	^self dispatch</body></methods><methods><class-id>ExtraActivity.TickEvent class</class-id> <category>instance creation</category><body package="ExtraActivity">new	^super new initialize</body></methods><methods><class-id>ExtraActivity.ActivityLoop</class-id> <category>accessing</category><body package="ExtraActivity">continueWhile: aBlock	"Set aBlock which will allow the activity to continue ticking while it evaluates to true."	aliveCondition := aBlock</body><body package="ExtraActivity">initialize	self continueWhile: [:widget | true]</body><body package="ExtraActivity">isRunning	^process notNil</body><body package="ExtraActivity">rate: aHz 	microsecondGrid := 1000000 // aHz</body><body package="ExtraActivity">setWidget: aWidget 	weakWidget := aWidget asWeakling</body><body package="ExtraActivity">start	self stop.	process := 			[			[self pause.			self isAlive] whileTrue: [self tick].			process := nil] 					forkAt: 60	"half way between interrupt and scheduling"</body><body package="ExtraActivity">stop	process ifNotNil: 			[process terminate.			process := nil]</body><body package="ExtraActivity">stopWhen: aBlock	"Set aBlock which will end the ticking when it evaluates to true."	self continueWhile: [:widget | (aBlock value: widget) ~~ true]</body><body package="ExtraActivity">widget	^weakWidget value</body></methods><methods><class-id>ExtraActivity.ActivityLoop</class-id> <category>private</category><body package="ExtraActivity">deltaClockTick	^nextClockTick - prevClockTick</body><body package="ExtraActivity">isAlive	| wdgt |	^(wdgt := self widget) notNil		and:			[wdgt topComponent notNil and: [(aliveCondition value: wdgt) == true]]</body><body package="ExtraActivity">newEventFor: aVisualPart under: aWindow 	| event |	aWindow windowManager class == WindowManager ifFalse: [^self].	event := TickEvent new.	event window: aWindow.	event initiator: aVisualPart.	event setTime: nextClockTick.	event addMicrosecondDelta: self deltaClockTick.	aWindow addEvent: event</body><body package="ExtraActivity">pause	prevClockTick := nextClockTick.	nextClockTick := (Time microsecondClock // microsecondGrid + 1) 				* microsecondGrid.	(Delay untilMicroseconds: nextClockTick) wait</body><body package="ExtraActivity">tick	prevClockTick ifNotNil: 			[self widget ifNotNil: 					[:wdgt | 					wdgt topComponent ifNotNil: 							[:window | 							(self tryOldEventFor: wdgt under: window) 								ifFalse: [self newEventFor: wdgt under: window]]]]</body><body package="ExtraActivity">tryOldEventFor: aVisualPart under: aWindow 	| event |	aWindow windowManager class == WindowManager ifFalse: [^false].	event := aWindow windowManager eventQueue detect: 					[:each | 					each class == TickEvent 						and: [each window == aWindow and: [each initiator == aVisualPart]]]				ifNone: [^false].	event setTime: nextClockTick.	event addMicrosecondDelta: self deltaClockTick.	^true</body></methods><methods><class-id>ExtraActivity.ActivityLoop class</class-id> <category>registry</category><body package="ExtraActivity">isActive: aVisualPart 	^(registry at: aVisualPart ifAbsent: [^false]) isRunning</body><body package="ExtraActivity">registeredOrNewFor: aVisualPart 	^registry at: aVisualPart		ifAbsentPut: 			[(self new)				setWidget: aVisualPart;				yourself]</body><body package="ExtraActivity">unregister: aVisualPart 	(registry at: aVisualPart ifAbsent: [nil]) ifNotNil: [:loop | loop stop].	registry removeKey: aVisualPart ifAbsent: []</body></methods><methods><class-id>ExtraActivity.ActivityLoop class</class-id> <category>instance creation</category><body package="ExtraActivity">new	^super new initialize</body></methods><methods><class-id>ExtraActivity.ActivityLoop class</class-id> <category>class initialization</category><body package="ExtraActivity">initialize	"self initialize"	registry := EphemeronDictionary new</body></methods><methods><class-id>UI.WindowManager</class-id> <category>event processing</category><body package="ExtraActivity">processOutstandingEvents	| outstandingEventCount |	self hasWindows ifFalse: [^self].		[dontFilterEvents := true.	outstandingEventCount := eventQueue size.	outstandingEventCount timesRepeat: [self processNextAvailableEvent]] 			ensure: [dontFilterEvents := false]</body></methods><methods><class-id>Core.SharedQueue</class-id> <category>accessing</category><body package="ExtraActivity">detect: aBlock ifNone: noneBlock 	^[accessProtect critical: [contents detect: aBlock ifNone: noneBlock]] 		valueUninterruptably</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>extra activity</category><body package="ExtraActivity">activityTickEvent: anEvent</body><body package="ExtraActivity">getActivityLoop	^ExtraActivity.ActivityLoop registeredOrNewFor: self</body><body package="ExtraActivity">isActivityTicking	^ExtraActivity.ActivityLoop isActive: self</body><body package="ExtraActivity">startActivityRate: aHz	| loop |	loop := self getActivityLoop.	loop rate: aHz.	loop start.	^loop</body><body package="ExtraActivity">stopActivity	ExtraActivity.ActivityLoop unregister: self</body></methods><initialize><class-id>ExtraActivity.ActivityLoop</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SharedQueue</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents accessProtect readSynch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>WindowManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windows activeController interruptLock outstandingMetaOrDamage openInProgress eventQueue baseProcess dontFilterEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>Event</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time initiator window wasHandled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class></st-source>