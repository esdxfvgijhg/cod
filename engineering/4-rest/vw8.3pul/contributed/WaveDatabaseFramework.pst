<?xml version="1.0"?><st-source><!-- Name: WaveDatabaseFrameworkComment: This goodie contains a minimal framework for database connection pooling using VisualWorks.It provides a LogicalConnection class which can be used as a connection pool. For example, 	basicConnection = PostgreSQLEXDIConnection new		username 'username';		password 'password';			environment 'host5432_dbname'.	connection = LogicalConnection new basicConnection.	connection maxSessions 10.	connection connectionTimeout 15 * 60.We can connect this sesssion. 	connection connect.get a session to execute database commands 	connection getSession.and eventually disconnect 	connection disconnect.Note that this currently only handles pooling of connections for read. For write acess you will need to obtain a connection with its own non-shared transactional context.DbIdentifier: bear73DbTrace: 30239DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'Wave-Server' ''))PackageName: WaveDatabaseFrameworkParcel: #('WaveDatabaseFramework')PrerequisiteParcels: #(#('Database' '') #('Wave-Server' ''))PrintStringCache: (1.6,bobw)Version: 1.6Date: 6:15:45 AM August 5, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 6:15:45 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ConnectionPool</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>connections </class-inst-vars><imports></imports><category>WaveDatabaseFramework</category><attributes><package>WaveDatabaseFramework</package></attributes></class><comment><class-id>VisualWave.ConnectionPool</class-id><body></body></comment><class><name>LogicalConnection</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>template connections sessions lowConnectionWM highConnectionWM maxSessions sessionTimeout connectionTimeout pendingDisconnects </inst-vars><class-inst-vars>connectionLock </class-inst-vars><imports></imports><category>WaveDatabaseFramework</category><attributes><package>WaveDatabaseFramework</package></attributes></class><comment><class-id>VisualWave.LogicalConnection</class-id><body></body></comment><methods><class-id>VisualWave.ConnectionPool class</class-id> <category>private-dbaccess</category><body package="WaveDatabaseFramework" selector="closeAll">closeAll	connections do: [:each | each disconnect].</body><body package="WaveDatabaseFramework" selector="closeConnection:">closeConnection: aConnection	aConnection disconnect.</body><body package="WaveDatabaseFramework" selector="createNewConnection:environment:">createNewConnection: aConnection environment: dbName	"Register and return a connected database connection."	connections at: dbName put: aConnection.	^aConnection</body><body package="WaveDatabaseFramework" selector="createNewConnection:username:environment:password:">createNewConnection: connectionClass username: username environment: dbName password: password	"Register and return a connected database connection."	| connection |	connection := connectionClass new.	connection		username: username ;		environment: dbName ;		password: password.	connections at: dbName put: connection.	^connection</body></methods><methods><class-id>VisualWave.ConnectionPool class</class-id> <category>accessing</category><body package="WaveDatabaseFramework" selector="getConnection:">getConnection: dbName	"returns an active database for the indicated database connection" 	| connection |		connection := connections at: dbName ifAbsent: [^self error: 'Unregistered connection: ' , dbName].	connection isConnected ifFalse: [connection connect].	^connection</body><body package="WaveDatabaseFramework" selector="getSession:">getSession: dbName	"returns an active session for the indicated database connection,	or a WWError if no connection or session can be found." 	| aConnection |	^(aConnection := self getConnection: dbName) isError		ifTrue: [aConnection]		ifFalse: [aConnection getSession]</body></methods><methods><class-id>VisualWave.ConnectionPool class</class-id> <category>class initialization</category><body package="WaveDatabaseFramework" selector="initialize">initialize	"Initialize the receiver"	"self initialize"	"check for previous initialization, if so disconnect all registered connections"	connections notNil		ifTrue: [self closeAll]		ifFalse: [connections := Dictionary new].</body></methods><methods><class-id>VisualWave.LogicalConnection</class-id> <category>connection-accessing</category><body package="WaveDatabaseFramework" selector="addSession:forConnection:">addSession: session forConnection: someConnection 	(self sessions at: someConnection) add: session.</body><body package="WaveDatabaseFramework" selector="connect">connect	"connect all the receivers low WM connections."	self connections do:		[:aConnection |		aConnection isConnected			ifFalse:				[self connect: aConnection]		].</body><body package="WaveDatabaseFramework" selector="critical:">critical: aBlock	^self class connectionLock critical: aBlock.</body><body package="WaveDatabaseFramework" selector="disconnect">disconnect	"Disconnect all the receivers connections.	Also ensure all sessions release dependencies for the receiver."	| |	self connections do: 			[:aConnection | 			aConnection disconnect.			(self sessionsFor: aConnection) 				do: [:aSession | aSession stateHolder removeDependent: self].			self sessions at: aConnection				put: (OrderedCollection new: self maxSessions).			self pendingDisconnects remove: aConnection ifAbsent: []].</body><body package="WaveDatabaseFramework" selector="ensureConnected:">ensureConnected: connection 	connection isConnected ifFalse: [self connect: connection].</body><body package="WaveDatabaseFramework" selector="environment">environment	"Answer the receiver's connection template environment"	^self template environment</body><body package="WaveDatabaseFramework" selector="findAvailableConnection">findAvailableConnection	^self connections 		detect: [:aConnection | (self sessionsFor: aConnection) size &lt; self maxSessions]		ifNone: [self newConnection].</body><body package="WaveDatabaseFramework" selector="getSession">getSession	"Answer the next available session.	No notion of load balancing at all - yet! "	| connection session |	connection := self findAvailableConnection.	self critical: 			[self ensureConnected: connection.			session := connection getSession].	(session notNil and: [session isConnected]) 		ifTrue: 			[session stateHolder addDependent: self.			self addSession: session forConnection: connection].	^session.</body><body package="WaveDatabaseFramework" selector="isConnected">isConnected	"Answer true if at least one connection is connected."	^self connections allSatisfy: [:aConnection | aConnection isConnected].</body><body package="WaveDatabaseFramework" selector="password">password	"Answer the receiver's connection template password."	^self template password</body><body package="WaveDatabaseFramework" selector="username">username	"Answer the receiver's connection template username."	^self template username</body></methods><methods><class-id>VisualWave.LogicalConnection</class-id> <category>private</category><body package="WaveDatabaseFramework" selector="basicNewConnection">basicNewConnection	"Answer a new  connection after installing it into the receiver."	| newConnection |	newConnection := self templateCopy.	self connections add: newConnection.	self sessions at: newConnection		put: (OrderedCollection new: self maxSessions).	^newConnection.</body><body package="WaveDatabaseFramework" selector="canDisconnect:">canDisconnect: aConnection 	^(self connections includes: aConnection) 		and: [(self sessionsFor: aConnection) isEmpty].</body><body package="WaveDatabaseFramework" selector="connect:">connect: aConnection	"Answer the receiver after connecting aConnection."	[aConnection connect]		on: aConnection class unableToConnectToSQLserverSignal		do: [:ex |			Transcript cr.			Timestamp now printOn: Transcript.			Transcript				tab ;				nextPutAll: ex messageText ;				space ;				nextPutAll: aConnection environment ;				nextPutAll: '::' ;				nextPutAll: aConnection username ;				flush.			ex return].</body><body package="WaveDatabaseFramework" selector="delayedDisconnectBlockFor:">delayedDisconnectBlockFor: aConnection 	"Return a block that can be forked to disconnect the connection"	^	[(Delay forSeconds: self connectionTimeout) wait.	self critical: 			[(self canDisconnect: aConnection) ifTrue: [aConnection disconnect].			self pendingDisconnects remove: aConnection ifAbsent: []]].</body><body package="WaveDatabaseFramework" selector="disconnect:">disconnect: aConnection 	"Answer the receiver after forking a process to disconnect aConnection."	"I don't understand this. Why are we waiting, when others can still continue to use the connections"	| delayedBlock |	self critical: 			[(self pendingDisconnects includes: aConnection) ifTrue: [^self].			pendingDisconnects add: aConnection.			delayedBlock := self delayedDisconnectBlockFor: aConnection].	delayedBlock notNil 		ifTrue: [delayedBlock forkAt: Processor userBackgroundPriority].</body><body package="WaveDatabaseFramework" selector="newConnection">newConnection	| connection |	self connections size = self highConnectionWM 		ifTrue: [self error: 'Session Count Exceeded'].	connection := self basicNewConnection.	self connect: connection.	^connection.</body><body package="WaveDatabaseFramework" selector="pendingDisconnects">pendingDisconnects	"Answer the receivers collection of connects that are pending disconnection."	^pendingDisconnects</body><body package="WaveDatabaseFramework" selector="pendingDisconnects:">pendingDisconnects: aCollection	pendingDisconnects := aCollection.</body><body package="WaveDatabaseFramework" selector="release">release	"Answer the receiver after releasing any outstanding connections."	(self connections notNil and: [self connections isEmpty not])		ifTrue: [self disconnect].</body></methods><methods><class-id>VisualWave.LogicalConnection</class-id> <category>accessing</category><body package="WaveDatabaseFramework" selector="connectionTimeout">connectionTimeout	connectionTimeout isNil ifTrue: [^self defaultConnectionTimeout].	^connectionTimeout</body><body package="WaveDatabaseFramework" selector="connectionTimeout:">connectionTimeout: seconds 	connectionTimeout := seconds</body><body package="WaveDatabaseFramework" selector="connections">connections	^connections</body><body package="WaveDatabaseFramework" selector="connections:">connections: anOrderedCollection 	connections := anOrderedCollection</body><body package="WaveDatabaseFramework" selector="defaultConnectionTimeout">defaultConnectionTimeout	^30.</body><body package="WaveDatabaseFramework" selector="highConnectionWM">highConnectionWM	^highConnectionWM</body><body package="WaveDatabaseFramework" selector="highConnectionWM:">highConnectionWM: anInteger 	highConnectionWM := anInteger</body><body package="WaveDatabaseFramework" selector="lowConnectionWM">lowConnectionWM	^lowConnectionWM</body><body package="WaveDatabaseFramework" selector="lowConnectionWM:">lowConnectionWM: anInteger 	lowConnectionWM := anInteger</body><body package="WaveDatabaseFramework" selector="maxSessions">maxSessions	^maxSessions</body><body package="WaveDatabaseFramework" selector="maxSessions:">maxSessions: anInteger 	maxSessions := anInteger</body><body package="WaveDatabaseFramework" selector="sessionTimeout">sessionTimeout	^sessionTimeout</body><body package="WaveDatabaseFramework" selector="sessionTimeout:">sessionTimeout: seconds 	sessionTimeout := seconds</body><body package="WaveDatabaseFramework" selector="template">template	^template</body></methods><methods><class-id>VisualWave.LogicalConnection</class-id> <category>initializing</category><body package="WaveDatabaseFramework" selector="initialize">initialize	"Answer the receiver after initializing.	If %template is set then create %lowConnectionWM connection count."	self release.	self sessionTimeout: 3600.	"1 hour"	self connectionTimeout: nil.	"default timeout"	self lowConnectionWM: 1.	self highConnectionWM: 5.	"conservative"	self maxSessions: 1.	"universal default"	self connections: (OrderedCollection new: self highConnectionWM).	self pendingDisconnects: (OrderedCollection new: self highConnectionWM).	self sessions: Dictionary new.	self template notNil 		ifTrue: [self lowConnectionWM timesRepeat: [self basicNewConnection]].</body></methods><methods><class-id>VisualWave.LogicalConnection</class-id> <category>private-accessing</category><body package="WaveDatabaseFramework" selector="sessions">sessions	^sessions</body><body package="WaveDatabaseFramework" selector="sessions:">sessions: anOrderedCollection 	sessions := anOrderedCollection.</body><body package="WaveDatabaseFramework" selector="sessionsFor:">sessionsFor: aConnection 	^self sessions at: aConnection.</body><body package="WaveDatabaseFramework" selector="template:">template: aConnection	template := aConnection.</body><body package="WaveDatabaseFramework" selector="templateCopy">templateCopy	"Answer a copy of the receiver's %template."	^(self template class new)		environment: self template environment ;		username: self template username ;		password: self template password ;		yourself</body></methods><methods><class-id>VisualWave.LogicalConnection</class-id> <category>updating</category><body package="WaveDatabaseFramework" selector="update:with:from:">update: aspect with: aParameter from: sender 	"Answer the receiver after releasing the notifying Database Session.	If %connectionTimeout is nil, then disconnect the connection when last session is disconnected."	(aspect == #value and: [sender value == #new]) 		ifTrue: 			[| theSession sessionClass |			(theSession := sender firstOwner) class 				== (sessionClass := self template class sessionClass) 					ifFalse: 						["begin searching for the senders session"						[theSession class == sessionClass] 							whileFalse: [theSession := sender ownerAfter: theSession]].			(self connections includes: theSession connection) 				ifTrue: 					[| theConnection |					theConnection := theSession connection.					(self sessions at: theConnection) remove: theSession ifAbsent: [].					(self sessionsFor: theConnection) isEmpty 						ifTrue: [self disconnect: theConnection].					sender retractInterestsFor: self]				ifFalse: 					[self halt: 'Session connection does not match receivers connections']].</body></methods><methods><class-id>VisualWave.LogicalConnection class</class-id> <category>private</category><body package="WaveDatabaseFramework" selector="connectionLock">connectionLock	connectionLock == nil		ifTrue: [connectionLock := Semaphore forMutualExclusion].	^connectionLock</body></methods><methods><class-id>VisualWave.LogicalConnection class</class-id> <category>instance creation</category><body package="WaveDatabaseFramework" selector="new:">new: aConnectionTemplate	"Answer an initialised instance of the receiver based on aConnectionTemplate."	^(self new)		template: aConnectionTemplate ;		initialize ;		yourself</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>testing</category><body package="WaveDatabaseFramework" selector="isConnected">isConnected	^connection notNil and: [connection isConnected].</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-accessing</category><body package="WaveDatabaseFramework" selector="state:">state: aSymbol	"Set the current state of the External Database object.	Inform receivers %stateHolder's dependents if there are any."	stateHolder myDependents isNil		ifTrue: [stateHolder setValue: aSymbol]		ifFalse: [stateHolder value: aSymbol].</body><body package="WaveDatabaseFramework" selector="stateHolder">stateHolder	"Answer the value holder of state information."	^stateHolder</body></methods><initialize><class-id>VisualWave.ConnectionPool</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalDatabaseFramework</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateHolder traceStream traceLevel participants participantsSemaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class></st-source>