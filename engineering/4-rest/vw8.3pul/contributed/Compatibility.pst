<?xml version="1.0"?><st-source><!-- Name: CompatibilityHideSource: falseParcel: CompatibilitySaveSource: trueDate: 3:11:02 am February 25, 2000 --><time-stamp>From VisualWorksÂ®, Release 5i.1 of January 3, 2000 on February 25, 2000 at 3:11:02 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SqueakFileInCommentReader</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stamp1 stamp2 myClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compatibility</category></class><class><name>DolphinClassCategoryReader</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class category </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compatibility</category></class><class><name>DolphinMethodCategoryReader</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compatibility</category></class><methods><class-id>SqueakFileInCommentReader</class-id> <category>accessing</category><body>myClass	^myClass</body><body>myClass: aValue	myClass := aValue</body><body>stamp1	^stamp1</body><body>stamp1: aValue	aValue isString		ifTrue: [stamp1 := aValue]		ifFalse: [stamp1 := aValue printString].</body><body>stamp2	^stamp2</body><body>stamp2: aValue	aValue isString		ifTrue: [stamp2 := aValue]		ifFalse: [stamp2 := aValue printString].</body></methods><methods><class-id>SqueakFileInCommentReader</class-id> <category>fileIn/Out</category><body>scanFrom: stream using: formatter	| comment myStream |	comment := stream nextChunk.	myStream := WriteStream on: (String new: (comment size * 2)).	myStream nextPutAll: self stamp1.	myStream cr; cr.	myStream nextPutAll: stamp2.	myStream cr; cr.	myStream nextPutAll: comment.	self myClass comment: myStream contents</body></methods><methods><class-id>SqueakFileInCommentReader class</class-id> <category>instance creation</category><body>newStamp: stamp1 oldStamp: stamp2 forClass: aClass	^self new stamp1: stamp1; stamp2: stamp2; myClass: aClass</body></methods><methods><class-id>DolphinClassCategoryReader</class-id> <category>accessing</category><body>category	^category</body><body>category: aValue	category := aValue</body><body>class	^class</body><body>class: aValue	class := aValue</body></methods><methods><class-id>DolphinClassCategoryReader</class-id> <category>fileIn/Out</category><body>scanFrom: aStream using: aFormatter	"Grab class category and set it.  Ignore Package classification, 	although one could conceivably create/set the current parecl with 	that information"	| cat next | 	cat := aStream nextChunk.	next := aStream nextChunk.	next := aStream nextChunk.	self class category: cat.</body></methods><methods><class-id>DolphinClassCategoryReader class</class-id> <category>instance creation</category><body>class: aClass category: aCategory	| inst |	inst := self new class: aClass.	inst category: aCategory.	^inst</body></methods><methods><class-id>DolphinMethodCategoryReader</class-id> <category>accessing</category><body>class	^class</body><body>class: aValue	class := aValue</body><body>signature	^signature</body><body>signature: aValue	signature := aValue</body></methods><methods><class-id>DolphinMethodCategoryReader</class-id> <category>private</category><body>extractSignatureFrom: aString	| stream  sig |	stream := aString readStream.	stream upTo: $#.	sig := stream upToEnd.	^sig asSymbol.</body><body>getNextBeginningFrom: aStream atPosition: pos	| next |	next := aStream nextChunk; nextChunk.	next isEmpty		ifTrue: [next := aStream nextChunk].	('*categoriesFor:*' match: next)		ifTrue: [self signature: (self extractSignatureFrom: next)]		ifFalse: [aStream position: pos.				self signature: nil].</body><body>parseForProtocols: aStream	| org methodName protocol pos |	org := self class organization.	[self signature notNil]	whileTrue: [		methodName := self signature.		protocol := aStream nextChunk.		aStream nextChunk.		pos := aStream position.		org classify: methodName under: protocol.		self getNextBeginningFrom: aStream atPosition: pos]</body></methods><methods><class-id>DolphinMethodCategoryReader</class-id> <category>fileIn/Out</category><body>for: aClass on: aSymbol	self class: aClass.	self signature: aSymbol</body><body>scanFrom: aStream using: aFormatter	self parseForProtocols: aStream.	aStream nextChunk</body></methods><methods><class-id>DolphinMethodCategoryReader class</class-id> <category>fileIn/Out</category><body>for: aClass on: aStream	^self new for: aClass on: aStream</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>fileIn/Out</category><body>methodsFor	"For Dolphin fileout  source file compatibility.	Answer a ClassCategoryReader that will compile methods for the receiver. 	Methods that are in an existing category will remain there.	Methods that are not in an existing category will be place in a	category named 'As yet unclassified'."	^self methodsFor: self organization class defaultProtocol</body></methods><methods><class-id>Kernel.Parser</class-id> <category>compile time-expressions</category><body>evaluateNowAsCompileTimeExpression	| exprStart method |	exprStart := mark.	self primaryExpression.	method := builder 		newMethodSelector: #DoIt		primitive: nil		block: (builder newBlockBody: (builder newReturnValue: parseNode)).	Object errorSignal		handle: [:ex | self notify: 'evaluation error: ', ex errorString at: exprStart]		do: [parseNode := targetClass performMethod: 				(Compiler new compile: method in: targetClass class)]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>fileIn/Out</category><body>categoriesFor: aSymbol 	"Dolphin is now telling us which protocols methods belong in"	^DolphinMethodCategoryReader for: self on: aSymbol</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-true/false</category><body>constant	"Recognize a constant (named, number, character,	string, or quoted).  Leave the constant value in parseNode."	| size |	tokenType == #word		ifTrue: 			["Special check for nil / true / false"			size := token size.			size = 5				ifTrue: [token = 'false' ifTrue: [self scanToken.  parseNode := false.  ^true]]				ifFalse:					[size = 4						ifTrue: [token = 'true' ifTrue: [self scanToken.  parseNode := true.  ^true]]						ifFalse:							[size = 3								ifTrue: [token = 'nil' ifTrue: [self scanToken.  parseNode := nil.  ^true]]]].			^false].	(tokenType == #string or: [tokenType == #number or: [tokenType == #character]])		ifTrue: 			[parseNode := token.			self scanToken.			^true].	(token == #- and: [hereChar notNil and: [hereChar isDigit]])		ifTrue: 			[self scanToken.  "skip the -, read the number"			parseNode := token negated.			self scanToken.			^true].	tokenType == #literalQuote		ifFalse:			[^false].	"This is a quoted literal"	self scanToken.  "skip the #"	(tokenType == #word or: [tokenType == #binary or: [tokenType == #verticalBar or: [newLanguage and: [tokenType == #string]]]])		ifTrue:			[parseNode := token asSymbol.  self scanToken.  ^true].	tokenType == #keyword		ifTrue:			["Scan a multi-keyword literal."			self scanLitKeywords.			parseNode := token asSymbol.			self scanToken.			^true].	tokenType == #leftParenthesis		ifTrue:			[self scanToken.			self arrayLiteral.			^true].	tokenType == #leftBracket		ifTrue:			[self scanToken.			self byteArrayLiteral.			^true].	tokenType == #leftBrace		ifTrue:			[self scanToken.			self qualifiedNameLiteral.			^true].	"compile time expression uses '##()' notation"	(tokenType == #literalQuote and: [token = $#])		ifTrue: [self scanToken. 				tokenType == #leftParenthesis				ifTrue:					[self evaluateNowAsCompileTimeExpression. 					^true].			^self expected: 'parenthesized eval-when-compile expression'].	^self expected: 'word, binary, keyword, (, or ['</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>fileIn/Out</category><body>commentStamp: string1 prior: string2	^SqueakFileInCommentReader newStamp: string1 oldStamp: string2 forClass: self</body><body>methodsFor: aString stamp: aStamp	"Answer a ClassCategoryReader for accessing the messages in the method	dictionary category, aString, of the receiver."	^ClassCategoryReader class: self category: aString asSymbol	"False methodsFor: 'logical operations' inspect"</body><body>categoriesForClass	"For Dolphin fileout  source file compatibility.  At present, I just ignore this	information.  It really ought to be handled such that methods landed	in protocol categories"	^DolphinClassCategoryReader class: self category: nil</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category></class></st-source>