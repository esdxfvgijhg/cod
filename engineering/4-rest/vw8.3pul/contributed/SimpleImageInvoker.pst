<?xml version="1.0"?><st-source><!-- Name: Simple Image InvokerNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: There was a desire to want to start another VisualWorks image from an image that was currently running on the same machine.  This package provides a simple minded way to do this.  Here's how one might use this:	invoker := SimpleImageInvoker 				engineFilename: engineFilename 	"Make sure you use vwntconsole on windows."				imageFilename: imageFilename.		invoker workingDirectory: workingDirectory.	invoker addImageArgument: '-pcl UIPainter'.	invoker addImageArgument: 	('-doit "some doit").	invoker addImageArgument: ('-filein aFilename.ws').	result := invoker start.result would be whatever was written out to stdout by the image.Currently there are no convience methods, so addImageArgument is the way to add arguments one by one.  Arguments are executed in the order received.  Be sure you include something in the image to quit if you want it to quit.If you run the tests on windows, one needs to make sure the console image is used when running the image that is invoking the other image otherwise a few tests will fail.  This is because the test resource uses the engine that is returned by CEnvironment commandLine instead of hard coding a filename.Bob Westergaard & Bob ShadwickDbIdentifier: bear73DbTrace: 494050DbUsername: traabeDbVersion: 8.3 - 1PackageName: Simple Image InvokerParcel: #('Simple Image Invoker')ParcelName: Simple Image InvokerPrintStringCache: (8.3 - 1,traabe)Version: 8.3 - 1Date: 9:37:24 AM September 2, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (sep16.1) of September 2, 2016 on September 2, 2016 at 9:37:24 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SimpleInvalidImageInvokerArgument</name><environment>Tools</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Simple Image Invoker</package></attributes></class><comment><class-id>Tools.SimpleInvalidImageInvokerArgument</class-id><body>Raised when either the engine filename, image filename or working directory for SimpleImageInoker does not exist (or in the case of the working directory filename, it is not a directory).</body></comment><class><name>SimpleImageInvoker</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engineFilename imageFilename workingDirectory arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Simple Image Invoker</package></attributes></class><comment><class-id>Tools.SimpleImageInvoker</class-id><body>A client can use an instance of this class to start up another instance of VisualWorks on the same machine.  To start up an instance, one minimally needs to specify a vm (engineFilename) a vi (imageFilename) and a working directory.  For example:	invoker := SimpleImageInvoker 				engineFilename: engineFilename 	"Make sure you use vwntconsole on windows."				imageFilename: imageFilename.		invoker workingDirectory: workingDirectory.	result :=invoker startOne can optionally hand in one ore arguments the VI might understand.   These arguments are executed in order.  For example:	invoker addImageArgument: '-pcl UIPainter'.	invoker addImageArgument:  ('-doit "Dialog warn: 'Hello'.  ObjectMemory quit.").	result := invoker start#start will return whatever was written to stdout by the image.  Also, one can choose to not set the engine filename, and ask the class to use the engine that might be found in	$VISUALWORKS/bin/{moniker}This is done by sending #useDistributionEngine.  It will use the vwntconsole.exe engine on windows, and MacOSX it will use either the vwmacxx11 or vwmacxgui engine (to ensure keyboard input is working).  All other platforms will use visual.This class uses WinProcess and UnixProcess to invoke the image.  Before it starts up the image, it will cd to that specified working directory.  Prior to starting the image, the filenames are checked and if any do not pass muster, SimpleInvalidImageInvokerArgument is raised.The smalltalk process that calls #start will be suspended until the invoked image quits, so one could fork the send of #start:		[invoker start.	semaphore signal] fork.	...	semaphore wait. On Windows, one needs to ensure that the console engine is being used.  In fact, a check in #checkFilenames checks for this and will raise SimpleInvalidImageInvokerArgument if the console engine is not used.  Also, on Windows we pass the -nosound command line argument to the VM to get around the dopey sound for VisualWorks.Instance Variables:	arguments		&lt;(Collection of: String)&gt;	description of arguments	engineFilename	&lt;String|Filename&gt;	The object engine to use	imageFilename	&lt;String|Filename&gt;	The image to use	workingDirectory	&lt;String|Filename&gt;	The directory to start the image in</body></comment><methods><class-id>Tools.SimpleImageInvoker</class-id> <category>accessing</category><body package="Simple Image Invoker">addDoit: aString	self addImageArgument: ('-doit " &lt;1s&gt; " ' expandMacrosWith: aString)</body><body package="Simple Image Invoker">addImageArgument: aString	arguments add: aString</body><body package="Simple Image Invoker">engineFilename	"Because engineFilename might be a string, ensure that it is converted to a filename before answering."	^engineFilename asFilename</body><body package="Simple Image Invoker">engineFilename: aFilenameOrString	engineFilename := aFilenameOrString.</body><body package="Simple Image Invoker">imageFilename	"Because imageFilename might be a string, ensure that it is converted to a filename before answering."	^imageFilename asFilename</body><body package="Simple Image Invoker">imageFilename: arg2	imageFilename := arg2</body><body package="Simple Image Invoker">removeLastArgument	^arguments removeLast.</body><body package="Simple Image Invoker">start	| result |	self checkFilenames.	result := nil.	self isWindows ifTrue: [result := self startImageOnWindows].	ExternalInterface currentPlatform first = #unix		ifTrue: [result := self startImageOnUnix].	^result</body><body package="Simple Image Invoker">workingDirectory	"Dummy method template.  This was installed by the debugger	define method command."	^workingDirectory asFilename</body></methods><methods><class-id>Tools.SimpleImageInvoker</class-id> <category>private</category><body package="Simple Image Invoker">checkFilenames	"Before starting the image, ensure that all of the filenames are valid.  If on the 	 windows platform, make sure that the engine being used is the console engine.	 This method is simply appalling."	self validateWorkingDirectory.	self validateEngineFilename.	self validateImageFilename</body><body package="Simple Image Invoker">guessEngineFilename	self useDistributionEngine</body><body package="Simple Image Invoker">imageArguments	^arguments 		inject: String new 		into: [:string :arg| string , ' ', arg]</body><body package="Simple Image Invoker">startImageOnUnix	"Filenames need to be quoted to accommodate non-standard but valid file paths."	| result unixCommand |	unixCommand := 'cd ''&lt;1s&gt;''; ''&lt;2s&gt;'' ''&lt;3s&gt;'''		expandMacrosWith: self workingDirectory asString with: self engineFilename asString with: self imageFilename asString.	unixCommand := unixCommand , self imageArguments.	result := UnixProcess shOne: unixCommand.	^result</body><body package="Simple Image Invoker">startImageOnWindows	| winCommand process directoryCommand |	process := ExternalProcess new.	directoryCommand := ('cd "&lt;1s&gt;"' 				expandMacrosWith: self workingDirectory asString).	winCommand := '"&lt;1s&gt;" -nosound "&lt;2s&gt;"' 				expandMacrosWith: self engineFilename asString				with: self imageFilename asString.	"tail"	winCommand := winCommand , self imageArguments.	^process fork: process getCommandLineInterpreter arguments: (Array with: '/c' with: (directoryCommand, '&amp;&amp;', winCommand)).</body><body package="Simple Image Invoker">validateEngineFilename	self engineFilename exists		ifTrue: 			[self isWindows				ifTrue: 					[('*console*' match: self engineFilename tail)						ifFalse: 							[SimpleInvalidImageInvokerArgument								raiseSignal: ('&lt;1p&gt; is not the right engine for win32'										expandMacrosWith: self engineFilename)]]]		ifFalse: 			[SimpleInvalidImageInvokerArgument				raiseSignal: ('&lt;1p&gt; does not exist' expandMacrosWith: self engineFilename)]</body><body package="Simple Image Invoker">validateImageFilename	| filename |	filename := self imageFilename.	filename isAbsolute		ifTrue: 			[filename exists				ifFalse: 					[SimpleInvalidImageInvokerArgument						raiseSignal: ('&lt;1p&gt; does not exist' expandMacrosWith: filename)]]		ifFalse: 			[filename := self workingDirectory construct: filename asString.	"good grief"			filename exists				ifFalse: 					[SimpleInvalidImageInvokerArgument						raiseSignal: ('&lt;1p&gt; does not exist' expandMacrosWith: filename)]]</body><body package="Simple Image Invoker">validateWorkingDirectory	self workingDirectory exists		ifTrue: 			[self workingDirectory isDirectory				ifFalse: 					[SimpleInvalidImageInvokerArgument raiseSignal: ('&lt;1p&gt; is not a directory'								expandMacrosWith: self workingDirectory)]]		ifFalse: 			[SimpleInvalidImageInvokerArgument				raiseSignal: ('&lt;1p&gt; does not exist' expandMacrosWith: self workingDirectory)]</body></methods><methods><class-id>Tools.SimpleImageInvoker</class-id> <category>initialize-release</category><body package="Simple Image Invoker">findImageNamed: aFilename	| vwImageDir |	aFilename asFilename isAbsolute		ifTrue: [^aFilename].	^(self workingDirectory / aFilename asString) definitelyExists		ifTrue: [aFilename]		ifFalse: [			(ObjectMemory imageDirectory / aFilename asString) definitelyExists				ifTrue: [ObjectMemory imageDirectory / aFilename asString]				ifFalse: [					vwImageDir := (Filename fromComponents: #('$(VISUALWORKS)' 'image')) asAbsoluteFilename.					(vwImageDir / aFilename asString) definitelyExists						ifTrue: [vwImageDir / aFilename]						ifFalse: [self error: 'Unable to find image: ', aFilename asString]]]</body><body package="Simple Image Invoker">initialize	arguments := OrderedCollection new</body><body package="Simple Image Invoker">workingDirectory: aString	workingDirectory := aString.</body></methods><methods><class-id>Tools.SimpleImageInvoker</class-id> <category>printing</category><body package="Simple Image Invoker">printOn: aStream		super printOn: aStream.	aStream nextPutAll: ('&lt;n&gt;&lt;1s&gt; &lt;2s&gt; ' expandMacrosWith: self engineFilename asString with: self imageFilename asString).	arguments 		do: [:each| aStream nextPutAll: each] 		separatedBy: [aStream space]</body></methods><methods><class-id>Tools.SimpleImageInvoker</class-id> <category>setup</category><body package="Simple Image Invoker">addDoItToQuitImageAfter: seconds	"This is Alan's trick to try to make the invoker not be so flakey on failures."	|doitString|	doitString := '[(Delay forSeconds: &lt;1p&gt;) wait. ObjectMemory quit] fork' expandMacrosWith: seconds.	self addDoit: doitString</body><body package="Simple Image Invoker">addDoItToQuitImageAfterTwoSeconds	"This is Alan's trick to try to make the invoker not be so flakey on failures."	self addDoItToQuitImageAfter: 2</body></methods><methods><class-id>Tools.SimpleImageInvoker</class-id> <category>accessing - engine location</category><body package="Simple Image Invoker">distributionEngineFilename	"Try to make a reasonable guess as to what the engine filename might be	 based on the current value of the VISUALWORKS environment variable."	| components |	components :=  self standardEngineLocationComponentsForCurrentPlatform.	components addFirst: '$(VISUALWORKS)'.	components addLast: self standardEngineName.	^(PortableFilename fromComponents: components) asFilename</body><body package="Simple Image Invoker">findEngineInVWHome: vwHomeStringOrFilename"Try to make a reasonable guess as to what the engine filename might be in a standard VW home layout at the provided location."	^engineFilename :=		LogicalFilename fromComponents:			(OrderedCollection new				addAll: self standardEngineLocationComponentsForCurrentPlatform;				addFirst: vwHomeStringOrFilename asString;				addLast: self standardEngineName;				yourself)</body><body package="Simple Image Invoker">standardEngineLocationComponentsForCurrentPlatform	"Return the relative path to the VM executable's directory as an OrderedCollection of components.	 On the MacOSX platforms, include the part of the path inside the APP structure.	 To use the return value of this method, add the VW installation root directory name to the beginning and the executable name to the end."	| components moniker |	components := OrderedCollection with: 'bin'.	moniker := ObjectMemory platformMoniker.	(moniker beginsWith: 'macx')		ifTrue: [			| component |			component := 'macx'.			ObjectMemory is64Bit				ifTrue: [component := component , '64'].			(moniker last: 2) = '11'				ifTrue: [component := component , 'x11'].			components add: component.			components addAll: #('visual.app' 'Contents' 'MacOS')]		ifFalse:			[(moniker = 'linuxARM' or: [moniker = 'aix64'])				ifTrue: [components addFirst: 'preview'].			components add: moniker].	^components</body><body package="Simple Image Invoker">standardEngineName	^self isWindows ifTrue: ['vwntconsole.exe'] ifFalse: ['visual']</body><body package="Simple Image Invoker">useDistributionEngine	"Try to make a reasonable guess as to what the engine filename might be	 based on the current value of the VISUALWORKS environment variable."	engineFilename := self distributionEngineFilename</body></methods><methods><class-id>Tools.SimpleImageInvoker</class-id> <category>testing</category><body package="Simple Image Invoker">isWindows	^self class isWindows</body></methods><methods><class-id>Tools.SimpleImageInvoker class</class-id> <category>instance creation</category><body package="Simple Image Invoker">engineFilename: engineStringOrFilename imageFilename: imageStringOrFilename	^self new		engineFilename: engineStringOrFilename;		imageFilename: imageStringOrFilename</body><body package="Simple Image Invoker">new	^super new initialize</body><body package="Simple Image Invoker">withCurrentEngineAndImage	"Create an invoker that will invoke the current image, in the current directory, using the current engine."	^self new		engineFilename: self currentVMName;		imageFilename: self currentImageName;		workingDirectory: Filename defaultDirectory</body><body package="Simple Image Invoker">withDefaults	"Create an invoker that will invoke visual.im, in the current directory or if it doesn't exist there, in the current image's directory or $(VISUALWORKS)/image, using the distribution engine"	| invoker anImageFilename |	invoker := self new		workingDirectory: Filename defaultDirectory.	anImageFilename := invoker findImageNamed: self defaultImageName.	^invoker		imageFilename: anImageFilename;		useDistributionEngine.</body></methods><methods><class-id>Tools.SimpleImageInvoker class</class-id> <category>defaults</category><body package="Simple Image Invoker">defaultImageName	^self isCurrentPlatform64bit		ifTrue: ['visual64.im']		ifFalse: ['visual.im']</body><body package="Simple Image Invoker">standardEngineName	^self isWindows ifTrue: ['vwntconsole.exe'] ifFalse: ['visual']</body></methods><methods><class-id>Tools.SimpleImageInvoker class</class-id> <category>testing</category><body package="Simple Image Invoker">isCurrentPlatform64bit	^'*64*' match: ObjectMemory platformMoniker</body><body package="Simple Image Invoker">isWindows	^ExternalInterface currentPlatform first = #win32</body></methods><methods><class-id>Tools.SimpleImageInvoker class</class-id> <category>utilities</category><body package="Simple Image Invoker">currentImageName	^ObjectMemory imageName</body><body package="Simple Image Invoker">currentVMName	| filename |	filename := CEnvironment commandLine first asFilename asAbsoluteFilename.	(self isWindows and: [('*console*' match: filename tail) not])		ifTrue: [			filename := filename head asFilename.			filename := filename construct: self standardEngineName].	^filename</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>api</category><body package="Simple Image Invoker">parcelPathAddFirst:  filenameOrString	| dir |	[dir := filenameOrString isString		ifTrue: [(SystemUtils makeFilenamePortable: filenameOrString) asFilename]		ifFalse: [filenameOrString].	dir isDirectory] on: OsError do: [:ex | ex return].	(Parcel searchPathModel value)		remove: dir ifAbsent: [nil];		addFirst: dir.</body><body package="Simple Image Invoker">parcelPathAddLast: filenameOrString	| dir |	[dir := filenameOrString isString		ifTrue: [(SystemUtils makeFilenamePortable: filenameOrString) asFilename]		ifFalse: [filenameOrString].	dir isDirectory] on: OsError do: [:ex | ex return].	(Parcel searchPathModel value)		remove: dir ifAbsent: [nil];		addLast: dir.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>