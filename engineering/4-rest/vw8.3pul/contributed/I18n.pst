<?xml version="1.0"?><st-source><!-- Name: I18nNotice: Copyright © 2010-2000 Cincom Systems, Inc.  All Rights Reserved.Comment: Contains various parsers and rewrite tools for finding raw strings in source code and replacing them with UserMessages. Also contains code for finding (virtually) all of the UserMessages in the source code, and extracting them out into message catalogs.DbIdentifier: bear73DbTrace: 317845DevelopmentPrerequisites: #(#(#any 'DLLCC' '') #(#any 'AT Parser Compiler' ''))PackageName: I18nParcel: #('I18n')ParcelName: I18nPrerequisiteParcels: #(#('DLLCC' '') #('AT Parser Compiler' ''))PrintStringCache: (7.8 - 1002,nross)Version: 7.8 - 1002Date: 9:52:45 AM January 28, 2011 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:52:45 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>I18n</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>I18n</category><attributes><package>I18n</package></attributes></name-space><class><name>StringTester</name><environment>Kernel</environment><super>Kernel.ProgramNodeEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mode subMode nodes </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.IOConstants.*			</imports><category>System-Compiler-Support</category><attributes><package>I18n</package></attributes></class><class><name>I18nErrorBrowser</name><environment>I18n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeView changeList keyedErrors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n</package></attributes></class><comment><class-id>I18n.I18nErrorBrowser</class-id><body>I18nErrorBrowser allows a user to view the error report of a catalog scan and view, compare, edit, or apply changes to methods. It also enables a user to load a catalog report file generated by I18N and store changes to patch files.Instance Variables	changeList	&lt;SelectionInList&gt;	catalog error selection model	changeView	&lt;I18nPatchChangeList&gt;	change list to view, edit, or apply changes for selected UserMessage error.	keyedErrors	&lt;Dictionary&gt;	method definitions keyed by catalog error</body></comment><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry completeSourcePosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>I18n</package></attributes></class><comment><class-id>Kernel.ProgramNode</class-id><body>Class ProgramNode represents a generic superclass for objects representing program fragments (parse nodes).ProgramNode and all its subclasses provide a complete set of accessing messages.  With few exceptions, these are not needed for code generation, printing, or any other system functions;  they are provided for the convenience of users who wish to write their own external algorithms for manipulating program node trees.For code generation, all the emitxxx messages take an argument 'code' which is an instance of (a subclass of) CodeStream.  CodeStream combines the allocation functions of the old Smalltalk Encoder with code generation facilities in the form of specialized putxxx messages to put out the different kinds of instruction.By default, the sourcePosition instance variable contains an Interval of character positions in the source code.  However, some nodes may choose to store something else instead.  For example, VariableNodes store just the starting character position, since they can easily compute the Interval on demand.  Note that the character positions are 1-origin (i.e. text indices, not stream positions), and are inclusive, as is normal for intervals.Subclasses must implement the following messages:	enumerating		nodeDo:Instance Variables:	sourcePosition	&lt;Interval | Number&gt;  source range or starting point	completeSourcePosition	&lt;Interval | nil&gt;	comment	&lt;nil | (SequenceableCollection of: String)&gt;	compilerHints	&lt;nil | Object&gt;	blockIndex	&lt;nil | Integer&gt;	mapEntry	&lt;nil | SourceMapEntry&gt;	returnMapEntry	&lt;nil | SourceMapEntry&gt;</body></comment><class><name>CompoundLiteralNode</name><environment>Kernel</environment><super>Kernel.LiteralNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>I18n</package></attributes></class><class><name>CatalogDirectoryRequest</name><environment>I18n</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n</package></attributes></class><comment><class-id>I18n.CatalogDirectoryRequest</class-id><body>This is a notification raised by the catalog writer to request a directory into which it should write the catalogs. It is an exception in order to be able to handle the request in automated build scripts.	[ 	CatalogDirectoryRequest raiseSignal	] on: CatalogDirectoryRequest do: [ :ex | ex resume ]</body></comment><class><name>SystemSearchApp</name><environment>I18n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>select criteria stringMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>I18n</package></attributes></class><class><name>I18nErrorReportChange</name><environment>Kernel</environment><super>Kernel.OtherChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>myDefinition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>I18n</package></attributes></class><class><name>I18nPatchChangeList</name><environment>Tools</environment><super>Tools.ChangeList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastTextSearch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>I18n</category><attributes><package>I18n</package></attributes></class><comment><class-id>Tools.I18nPatchChangeList</class-id><body>I18nPatchChangeList is a specialization of ChangeList for viewing and modifying definitions associated with an I18n catalog error report.Instance Variables	lastTextSearch	&lt;String | nil&gt;	optional string defined to search methods by </body></comment><class><name>I18nEnumerator</name><environment>I18n</environment><super>Kernel.ProgramNodeEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class selector all stringMap literalType translatedMap inverseTranslatedMap interactive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>I18n</package></attributes></class><class><name>I18nMethodDefinitionChange</name><environment>Kernel</environment><super>Kernel.MethodDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalFile relatedChanges cachedText errors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>I18n</package></attributes></class><comment><class-id>Kernel.I18nMethodDefinitionChange</class-id><body>I18nMethodDefinitionChange exists for I18nCatalogWriterFromSource.  It differs from MethodDefinitionChenge by always answering its actual filename.</body></comment><class><name>MessageCatalogWriter</name><environment>I18n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalogWriter patchesDirectory sourceFileTree catalogsDirectory ignoreExtras </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>I18n</package></attributes></class><class><name>PragmaMessageNode</name><environment>Kernel</environment><super>Kernel.ProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n</package></attributes></class><class><name>LiteralChooserUI</name><environment>I18n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query map dependentRB stringList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>I18n</package></attributes></class><class><name>I18nClassDefinitionChange</name><environment>Kernel</environment><super>Kernel.ClassDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalFile relatedChanges cachedText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>I18n</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode constantNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>I18n</package></attributes></class><comment><class-id>Kernel.Parser</class-id><body>The Parser parses Smalltalk syntax and creates a parse tree.  It looks one token ahead, i.e. token and tokenType contain the next token to be inspected.Instance Variables:	builder		&lt;ProgramNodeBuilder&gt;   for building parse nodes 	requestor	&lt;CompilerErrorHandler&gt;   object from which parsing was invoked.  This object will be sent error:with:from: or error:with:at: prior to evaluating the failBlock 	oldLanguage	&lt;Boolean&gt;   if true, accept the "Blue" Book syntax 	newLanguage	&lt;Boolean&gt;   if true, accept ParcPlace Systems revised syntax 	extendedLanguage	&lt;Boolean&gt;   if true, accept ParcPlace Systems extensions (type declarations, ByteArray literals) 	parseNode	&lt;ProgramNode&gt;   result of current (recursive descent) parse 	failBlock	&lt;BlockClosure&gt;   to be evaluated in case of parse errors 	endTemps	&lt;Integer&gt;   mark of last temp; points to vert bar, or last char of pattern if no temps declared </body></comment><class><name>SystemSearchRequirement</name><environment>I18n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>application type data negated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>I18n</package></attributes></class><class><name>I18nCatalogWriterFromSource</name><environment>I18n</environment><super>I18n.I18nEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files fileRootDirectory patchDirectory catalogsDirectory cachedFileChanges currentChange currentPatchFilename currentPatches translationErrorLog inversionErrorLog syntaxErrorLog noCatalogErrorLog badKeyErrorLog recollectionBlock allErrors errorChangeList directoriesToIgnore parcelsToIgnore longKeyErrorLog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>I18n</package></attributes></class><comment><class-id>I18n.I18nCatalogWriterFromSource</class-id><body>I18nCatalogWriterFromSource generates message catalogs by scanning a set of source files, applying patches from a set of patch files if available.  The class provides error checking of i18n constructs and along with its UI class MessageCatalogWriter supports an iterative means of developing the set of patches to fix errors in i18n constructs in the source files.Instance Variables	badKeyErrorLog	&lt;Set of: Array&gt;	set of user messages (as Array tuples) of user messages with bad keys (keys must be unary messages)	cachedFileChanges	&lt;OrderedCollection of: MethodDefinitionChange&gt;	cache of method changes potentially containing i18n constructs, extracted from source files	catalogsDirectory	&lt;Filename&gt;	directory to which generated message catalog files will be written	currentChange	&lt;MethodDefinitionChange&gt;	The current change being parsed for i118n	currentPatches	&lt;Dictionary of: (String -&gt; MethodDefinitionChange)&gt;	set of patches that apply to the source file currently being scanned	currentPatchFilename	&lt;Filename&gt;	current patch file being applied as a source file is scanned.  Exists so that extra methods in a patch file can be scanned before the next source file is scanned.	fileRootDirectory	&lt;Filename&gt;	the root of the source file tree being scanned.	files	&lt;OrderedCollection of: Filename&gt;	the source files to scan	inversionErrorLog	&lt;Set of: Array&gt;	set of user messages (as Array tuples) of user messages with colliding default strings	noCatalogErrorLog	&lt;Set of: Array&gt;	set of user messages (as Array tuples) of user messages with no catalog id	patchDirectory	&lt;Filename&gt;	directory holding patch files	recollectionBlock	&lt;BlockClosure&gt;	hack to recollect bad user messages from changes being scanned when errors need to be reported.	syntaxErrorLog	&lt;(Collection of: I18nMethodDefinitionChange)&gt;	changes containing syntax errors in i18n constructs	translationErrorLog	&lt;Set of: Array&gt;	set of user messages (as Array tuples) of user messages with colliding keys	allErrors			&lt;(Collection of: I18nMethodDefinitionChange)&gt;		collection of all method definitions with reported errors	errorChangeList		&lt;I18nPatchChangeList&gt;	change list application to view and edit methods with user message errors. 	directoriesToIgnore	&lt;Array of: String&gt;	names of all directories to ignore scanning.	parcelsToIgnore		&lt;Array of: String&gt;	names of all parcels to ignore scanning.	longKeyErrorLog	&lt;Set of: Array&gt;	set of user messages (as Array tuples) of user messages with oversized keys</body></comment><class><name>I18nScanner</name><environment>Kernel</environment><super>XML.SourceScannerNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalFile relatedChanges </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.*			</imports><category>System-Changes</category><attributes><package>I18n</package></attributes></class><class><name>CatalogAndKeyDialog</name><environment>I18n</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalog key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>I18n</package></attributes></class><class><name>MessageCatalogTool</name><environment>I18n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalogs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>I18n</package></attributes></class><shared-variable><name>LastCatalog</name><environment>I18n.LiteralChooserUI</environment><private>false</private><constant>false</constant><category>Memory</category><initializer>String new</initializer><attributes><package>I18n</package></attributes></shared-variable><methods><class-id>Kernel.StringTester</class-id> <category>editing-support</category><body package="I18n" selector="catalogForDialogs">catalogForDialogs	| s |	^QueryNotification raiseSignal		at: #dialogs		ifAbsentPut:			[s := Dialog request: (#WhatCatalogWillYouUseForDialogs &lt;&lt; #I18nTool &gt;&gt; 'What catalog will you use for dialogs?')					initialAnswer: 'dialogs'.			s asSymbol]</body><body package="I18n" selector="catalogForLabels">catalogForLabels	| s |	^QueryNotification raiseSignal		at: #labels		ifAbsentPut:			[s := Dialog request: (#WhatCatalogWillYouUseForLabels &lt;&lt; #I18nTool &gt;&gt; 'What catalog will you use for labels?')					initialAnswer: 'labels'.			s asSymbol]</body><body package="I18n" selector="catalogForMenus">catalogForMenus	| s |	^QueryNotification raiseSignal		at: #menus		ifAbsentPut:			[s := Dialog request: (#WhatCatalogWillYouUseForMenus &lt;&lt; #I18nTool &gt;&gt; 'What catalog will you use for menus?')					initialAnswer: 'menus'.			s asSymbol]</body><body package="I18n" selector="collectConcat:into:">collectConcat: aNode into: s	(aNode respondsTo: #selector)		ifTrue: [aNode selector  =  #,			ifTrue:				[self collectConcat: aNode receiver into: s.				self collectConcat: aNode arguments first into: s]			ifFalse: [s add: aNode]]		ifFalse: [s add: aNode]</body><body package="I18n" selector="computeKeyFor:in:">computeKeyFor: default in: md	| s s2 upper ds |	^default size &lt; 30		ifTrue:			[s := default copy replaceAll: $&amp; with: $_.			s replaceAll: $: with: $C.			s2 := String new writeStream.			upper := false.			s do: [:c | (c = $_ or: [c isLetter or: [c isDigit]])				ifTrue:					[upper						ifTrue: [s2 nextPut: c asUppercase]						ifFalse: [s2 nextPut: c].					upper := false]				ifFalse: [c isSeparator ifTrue: [upper := true]]].			s := s2 contents.			(s isEmpty not and: [s first isDigit]) ifTrue: [s := 'x', s].			s]		ifFalse:			[ds := QueryNotification raiseSignal at: #genkey ifAbsentPut: [0].			QueryNotification raiseSignal at: #genkey put: ds+1.			ds := 'GenKey', ds printString.			s := ds.			(s allSatisfy: [:c | c = $_ or: [c isLetter or: [c isDigit]]])				ifFalse:					[Dialog warn: ((#ThisIsAnIllegalKeySMayCauseConflicts &lt;&lt; #I18nTool &gt;&gt; 'This is an illegal key. &lt;1s&gt; will be used&lt;n&gt;instead, but this may cause conflicts') expandMacrosWith: ds storeString).					s := ds].			^s]</body><body package="I18n" selector="involvesString:">involvesString: aNode	| r |	r := aNode.	[(r class == LiteralNode and: [r value isString and: [r value isSymbol not]])		ifTrue: [^true].	r respondsTo: #selector] whileTrue:		[(r selector == #&gt;&gt; and: [r arguments first value isString and: [r arguments first value isSymbol not]])			ifTrue: [^true].		r := r receiver].	^false</body><body package="I18n" selector="isComputedMessage:">isComputedMessage: aNode	| n n1 |	aNode selector == #&gt;&gt; ifFalse: [^false].	n := aNode arguments first.	(n class == LiteralNode and: [n value isString and: [n value isSymbol not]])		ifFalse: [^false].	n := aNode receiver.	n class == LiteralNode		ifTrue: [^n value isSymbol]		ifFalse: [(n isKindOf: SimpleMessageNode)			ifTrue:				[n1 := n arguments first.				(n1 class == LiteralNode and: [n1 value isSymbol])					ifFalse: [^false].				n1 := n receiver.				(n1 class == LiteralNode and: [n1 value isSymbol])					ifFalse: [^false].				^true]			ifFalse: [^false]]</body><body package="I18n" selector="looksLikeAUserMessage:">looksLikeAUserMessage: array	| k v |	subMode == nil		ifTrue:			[(array size between: 2 and: 3) ifFalse: [^false].			array first isSymbol ifFalse: [^false].			(array last isString and: [array last isSymbol not]) ifFalse: [^false].			^array size = 2 or: [(array at: 2) isSymbol]].	(array size = 5 or: [array size = 7]) ifFalse: [^false].	(array first == #UserMessage		or: [array first isBindingReference			and: [(array first valueOrDo: []) == UserMessage]])		ifFalse: [^false].	2 to: array size by: 2 do: [:i |		k := array at: i.		v := array at: i+1.		k == #key:			ifTrue: [v isSymbol ifFalse: [self error: (#BadKey &lt;&lt; #I18nTool &gt;&gt; 'Bad key')]]			ifFalse: [k == #defaultString:				ifTrue: [(v isString and: [v isSymbol not]) ifFalse: [self error: (#BadDefault &lt;&lt; #I18nTool &gt;&gt; 'Bad default')]]				ifFalse: [k == #catalogID:					ifTrue: [v isSymbol ifFalse: [self error: (#BadCatalog &lt;&lt; #I18nTool &gt;&gt; 'Bad catalog')]]					ifFalse: [self error: (#MalformedUserMessage &lt;&lt; #I18nTool &gt;&gt; 'Malformed UserMessage')]]]].	^true</body><body package="I18n" selector="looksLikeArrayOfStrings:">looksLikeArrayOfStrings: lit	^lit class == Array		and: [lit allSatisfy: [:i | i isString					ifTrue: [i isSymbol not]					ifFalse: [self looksLikeArrayOfStrings: i]]]</body><body package="I18n" selector="sendsMessageToString:">sendsMessageToString: aNode	^(aNode respondsTo: #selector) and: [self involvesString: aNode]	"| r |	(aNode respondsTo: #selector) ifFalse: [^false].	r := aNode receiver.	[(r class == LiteralNode and: [r value isString and: [r value isSymbol not]])		ifTrue: [^true].	r respondsTo: #selector] whileTrue:		[(r selector == #&gt;&gt; and: [r arguments first value isString and: [r arguments first value isSymbol not]])			ifTrue: [^true].		r := r receiver].	^false"</body><body package="I18n" selector="simplify:">simplify: aStringNode	| r |	r := aStringNode.	[r respondsTo: #selector] whileTrue:		[r selector == #&gt;&gt;			ifTrue: [r := r arguments first]			ifFalse: [(#(#asText #allBold #asString #emphasizeAllWith:) includes: r selector)				ifTrue: [r := r receiver]				ifFalse: [^r]]].	^r</body><body package="I18n" selector="storeArray:on:">storeArray: array on: stream	array size &lt;= 4		ifTrue:			[stream nextPutAll: '(Array'.			array do: [:lit |				stream nextPutAll: ' with: '.				(lit isKindOf: Array)					ifTrue: [self storeArray: lit on: stream]					ifFalse: [stream print: lit]].			stream nextPutAll: ')']		ifFalse:			[stream nextPutAll: '(OrderedCollection new'.			array do: [:lit |				stream nextPutAll: ' add: '.				(lit isKindOf: Array)					ifTrue: [self storeArray: lit on: stream]					ifFalse: [stream print: lit].				stream nextPut: $;].			stream nextPutAll: ' asArray)'].</body></methods><methods><class-id>Kernel.StringTester</class-id> <category>accessing</category><body package="I18n" selector="addNode:">addNode: aNode	(self nodes anySatisfy: [:n | (self getRealNode: n) == (self getRealNode: aNode)])		ifFalse: [self nodes add: aNode]</body><body package="I18n" selector="getRealNode:">getRealNode: aNode	^aNode class == Association		ifTrue: [(aNode key isKindOf: ProgramNode)			ifTrue: [aNode key]			ifFalse: [aNode value]]		ifFalse: [aNode]</body><body package="I18n" selector="mode:">mode: m	mode := m</body><body package="I18n" selector="nodes">nodes	nodes ifNil: [nodes := OrderedCollection new].	^nodes</body><body package="I18n" selector="subMode:">subMode: aSymbol	subMode := aSymbol</body></methods><methods><class-id>Kernel.StringTester</class-id> <category>editing</category><body package="I18n" selector="addMacroQuotes:">addMacroQuotes: aString	| s i i2 s2 |	s := aString.	#('%' '&lt;' '&gt;') do: [:c |		s := s copyReplaceAll: c with: ('%%&lt;1s&gt;' expandMacrosWith: c)].	[i := s findFirst: [:c | #(9 13) includes: c asInteger].	i = 0] whileFalse:		[i2 := (i to: s size) detect: [:n | (#(9 13) includes: (s at: n) asInteger) not] ifNone: [s size+1].		s2 := s copyFrom: i to: i2-1.		s2 replaceAll: CR with: $n.		s2 replaceAll: Character tab with: $t.		(s2 asSet - 'nt') isEmpty ifFalse: [self halt].		s := s copyReplaceFrom: i to: i2-1 with: ('%&lt;&lt;1s&gt;%&gt;'			expandMacrosWith: s2).		].	^s</body><body package="I18n" selector="changeSlashToCRs:mclass:selector:">changeSlashToCRs: source mclass: mclass selector: selector	| src idx |	src := source copy.	self nodes do: [:nd |		(nd isKindOf: LiteralNode)			ifTrue: [src replaceAll: $\ with: CR from: nd sourcePosition first to: nd sourcePosition last]].	self nodes reverseDo: [:nd |		(nd isKindOf: SimpleMessageNode)			ifTrue:				[idx := (nd sourcePosition first-1 to: 1 by: -1)					detect: [:i | (src at: i) isSeparator not].				src := src copyReplaceFrom: idx+1 to: nd sourcePosition last with: '']].	src = source		ifFalse: [mclass compile: src classified: (mclass organization categoryOfElement: selector)]</body><body package="I18n" selector="editArrayString:in:">editArrayString: node in: md	| msg source str |	(Dialog confirm: ((#DoYouWantToTranslaNn1sNnIn2s &lt;&lt; #I18nTool &gt;&gt; 'Do you want to translate the strings in the Array:&lt;nn&gt;&lt;1s&gt;&lt;nn&gt;in &lt;2s&gt;?')			expandMacrosWith: (node value storeString contractTo: 80)			with: md printString))		ifFalse: [^false].	str := String new writeStream.	self storeArray: node value on: str.	msg := str contents.	source := md method getSource		copyReplaceFrom: node sourcePosition first		to: node sourcePosition last		with: msg.	md implementingClass		compile: source		classified: (md implementingClass organization categoryOfElement: md selector).	^true</body><body package="I18n" selector="editFreeString:in:">editFreeString: node in: md	| catalog default key msg source |	catalog := self catalogForDialogs.	default := node value.	key := self computeKeyFor: default in: md.	(key == nil or: [key size = 0]) ifTrue: [^false].	msg := '(', key asSymbol storeString, ' &lt;&lt; ', catalog asSymbol storeString, ' &gt;&gt; ', default storeString, ')'.	source := md method getSource		copyReplaceFrom: node sourcePosition first		to: node sourcePosition last		with: msg.	md implementingClass		compile: source		classified: (md implementingClass organization categoryOfElement: md selector).	^true</body><body package="I18n" selector="editPragmaString:in:">editPragmaString: default in: md	| catalog key msg source idx |	catalog := self catalogForDialogs.	key := self computeKeyFor: default in: md.	(key == nil or: [key size = 0]) ifTrue: [^false].	msg := Array with: key asSymbol with: catalog asSymbol with: default.	source := md method getSource.	idx := source findString: default storeString startingAt: 1.	source := source		copyReplaceFrom: idx		to: idx+default storeString size-1		with: msg storeString.	md implementingClass		compile: source		classified: (md implementingClass organization categoryOfElement: md selector).	^true</body><body package="I18n" selector="editResourceString:in:">editResourceString: node in: md	| catalog default key msg source |	catalog := md method resourceType == #menu		ifTrue: [self catalogForMenus]		ifFalse: [self catalogForLabels].	default := node value.	key := self computeKeyFor: default in: md.	(key == nil or: [key size = 0]) ifTrue: [^false].	msg := key asSymbol &lt;&lt; catalog asSymbol &gt;&gt; default.	source := md method getSource		copyReplaceFrom: node sourcePosition first		to: node sourcePosition last		with: msg literalArrayEncoding storeString.	md implementingClass		compile: source		classified: (md implementingClass organization categoryOfElement: md selector).	^true</body><body package="I18n" selector="reportCommas:">reportCommas: md 	| a source nz args nzs src |	self nodes isEmpty 		ifFalse: 			[Transcript				cr;				show: md printString.			self nodes do: 					[:i | 					Transcript						crtab;						show: i printString].			a := self nodes first.			source := md method getSource.			nz := String new.			args := #().			a value do: 					[:n | 					(n class == LiteralNode 						and: [n value isString and: [n value isSymbol not]]) 							ifTrue: [nz := nz , (self addMacroQuotes: n value)]							ifFalse: 								[args := args copyWith: n.								nz := '&lt;1s&gt;%&lt;&lt;2s&gt;s%&gt;' expandMacrosWith: nz with: args size printString]].			args size = 0 				ifTrue: [nz := '&lt;1s&gt; expandMacros' expandMacrosWith: nz storeString]				ifFalse: 					[args size &lt;= 4 						ifTrue: 							[nzs := String new writeStream.							nzs								nextPutAll: '(';								store: nz;								nextPutAll: '&lt;nttt&gt;expandMacrosWith: ' expandMacros.							args do: 									[:i | 									i 										printOn: nzs										indent: 4										precedence: 3]								separatedBy: [nzs nextPutAll: '&lt;nttt&gt;with: ' expandMacros].							nzs nextPutAll: ')'.							nz := nzs contents]						ifFalse: 							[nzs := String new writeStream.							nzs								nextPutAll: '(';								store: nz;								nextPutAll: '&lt;nttt&gt;expandMacrosWithArguments: (OrderedCollection new ' 											expandMacros.							args do: 									[:i | 									nzs nextPutAll: '&lt;ntttt&gt;add: ' expandMacros.									i 										printOn: nzs										indent: 5										precedence: 3.									nzs nextPutAll: ';'].							nzs nextPutAll: ' asArray))'.							nz := nzs contents]].			src := source 						copyReplaceFrom: a key completeSourcePosition first						to: a key completeSourcePosition last						with: nz.			md implementingClass compile: src				classified: (md implementingClass organization 						categoryOfElement: md selector).			^true].	^false</body><body package="I18n" selector="reportStrings:">reportStrings: md	| edited s |	self nodes isEmpty		ifFalse:			[Transcript cr; show: md printString.			self nodes do: [:i |				i class == Association ifFalse: [self halt].				Transcript  crtab; show: i printString].			edited := false.			self nodes reverseDo: [:a |				edited := edited | (a key == nil					ifTrue: [self editFreeString: a value in: md]					ifFalse: [(#(canvas menu) includes: a key)						ifTrue: [self editResourceString: a value in: md]						ifFalse: [a key == #computeArray							ifTrue: [self editArrayString: a value in: md]							ifFalse: [a key == #pragma								ifTrue: [self editPragmaString: a value in: md]								ifFalse: [a key == #inArray									ifTrue:										[s := QueryNotification raiseSignal at: #noEdit ifAbsentPut: [Set new].										(s includes: md)											ifFalse:												[Dialog warn: ((#'_1sNContainsStringStBeEditedManually' &lt;&lt; #I18nTool &gt;&gt; '&lt;1s&gt;&lt;n&gt;contains strings in an Array which must be edited manually')													expandMacrosWith: md printString).												s add: md].										false]									ifFalse: [false]]]]])].			^edited].	^false</body></methods><methods><class-id>Kernel.StringTester</class-id> <category>enumerating</category><body package="I18n" selector="doCompoundLiteral:value:">doCompoundLiteral: aNode value: lit	| md |	mode == #userMessages		ifFalse: [^super doCompoundLiteral: aNode value: lit].	(subMode == nil and: [lit isEmpty not			and: [self looksLikeArrayOfStrings: lit]])		ifTrue: [^self addNode: #computeArray-&gt;aNode].	(self looksLikeAUserMessage: lit)		ifFalse:			[md := subMode.			subMode == nil ifTrue: [subMode := #inArray].			self doNodes: aNode nodes.			subMode := md].</body><body package="I18n" selector="doLiteral:value:">doLiteral: aNode value: lit	(mode == #withCRStrings and: [lit isString and: [lit isSymbol not]])		ifTrue: [self addNode: aNode].	(mode == #userMessages and: [subMode ~~ #image			and: [lit isString and: [lit isSymbol not]]])		ifTrue: [self addNode: subMode-&gt;aNode].	^aNode</body><body package="I18n" selector="doMessage:receiver:selector:arguments:">doMessage: aNode receiver: rcvr selector: sel arguments: args	| s old s2 |	(mode == #userMessages and: [self isComputedMessage: aNode])		ifTrue: [^self].	(mode == #comma and: [sel == #,])		ifTrue:			[s := OrderedCollection new.			self collectConcat: aNode into: s.			(s anySatisfy: [:n | self involvesString: n])				ifTrue:					[[1 to: s size do: [:i || n |						n := s at: i.						(self class new sendsMessageToString: n)							ifTrue: [s at: i put: (n := self simplify: n)].						s2 := OrderedCollection new.						self collectConcat: n into: s2.						s2 size &gt; 1 ifTrue: [							s := s copyReplaceFrom: i to: i with: s2.							RestartRequest raiseSignal].						(self class new sendsMessageToString: n)							ifTrue: [Transcript cr; tab; tab; show: n printString].						]] on: RestartRequest do: [:x | x restart].					self addNode: aNode -&gt; s].			self doNodes: s]		ifFalse: [((#(#withCRs #withCRStrings) includes: mode) and: [sel == #withCRs])			ifTrue:				[old := mode.				mode := #withCRStrings.				self addNode: aNode.				self doNode: rcvr.				self doNodes: args.				mode := old]			ifFalse:				[self doNode: rcvr.				self doNodes: args]]</body><body package="I18n" selector="doMethod:selector:primitive:block:">doMethod: aNode selector: sel primitive: prim block: block	mode == #userMessages		ifTrue: [aNode attributeMessages == nil			ifFalse: [aNode attributeMessages do: [:m |				m arguments do: [:s |					(s isString and: [s isSymbol not])						ifTrue: [self addNode: #pragma-&gt;s]]]]].	^self doNode: block</body></methods><methods><class-id>Kernel.StringTester class</class-id> <category>examples</category><body package="I18n" selector="commaFilter:">commaFilter: filter	"StringTester commaFilter: (MethodCollector new parcel: 'XML')"	"StringTester commaFilter: (MethodCollector new package: 'XML')"	"StringTester commaFilter: (MethodCollector new bundle: 'Store-UI')"	self eliminateWithCRsIn: filter.	self eliminateBackslashIn: filter.	[self eliminateCommasIn: filter] whileTrue</body><body package="I18n" selector="eliminateBackslashIn:">eliminateBackslashIn: filter	| m p |	Transcript clear.	(filter &amp; (MethodCollector new methodsSelect: [:me |			me resourceType ~~ #image				and: [me allLiterals anySatisfy:					[:lit | lit class == '' class and: [lit includes: $\]]]])) select do: [:md |		m := md method.		Transcript cr; show: md printString.		md isForSharedVariable			ifFalse:				[p := Compiler parse: m getSource					class: md implementingClass]]</body><body package="I18n" selector="eliminateCommasIn:">eliminateCommasIn: filter	| m p restart |	Transcript clear.	restart := false.	(filter &amp; (MethodCollector new referencesTo: #,)) select do: [:md |		m := md method."		Transcript cr; show: md printString."		md isForSharedVariable			ifFalse:				[p := Compiler parse: m getSource					class: md implementingClass.				p == nil ifFalse:					[(self new						mode: #comma;						doNode:  p;						reportCommas: md) ifTrue: [restart := true]]]].	^restart</body><body package="I18n" selector="eliminateWithCRsIn:">eliminateWithCRsIn: filter	| m p selector |	Transcript clear.	selector := #withCRs.	(filter &amp; (MethodCollector new referencesTo: selector)) select do: [:md |		m := md method.		Transcript cr; show: md printString.		md isForSharedVariable			ifFalse:				[p := Compiler parse: m getSource					class: md implementingClass.				p == nil ifFalse:					[self new mode: #withCRs;						doNode: p;						changeSlashToCRs: m getSource mclass: md implementingClass selector: md selector]]]</body><body package="I18n" selector="example">example	"StringTester example"	self commaFilter: (MethodCollector new nameSpace: 'Tools').	self messageFilter: (MethodCollector new nameSpace: 'Tools')</body><body package="I18n" selector="messageFilter:">messageFilter: filter	"StringTester messageFilter: (MethodCollector new parcel: 'XML')"	"StringTester messageFilter: (MethodCollector new package: 'XML')"	"StringTester messageFilter: (MethodCollector new bundle: 'Store-UI')"	| properties |	properties := Dictionary new.	[[self writeUserMessagesIn: filter] whileTrue]		on: QueryNotification do: [:x |			x creator == QueryNotification ifFalse: [x pass].			x resume: properties].</body><body package="I18n" selector="writeUserMessagesIn:">writeUserMessagesIn: filter	"This should only be called from #messageFilter:"	| m p restart |	Transcript clear.	restart := false.	(filter &amp; (MethodCollector new methodsSelect: [:me |			me allLiterals anySatisfy:				[:lit | lit isString and: [lit isSymbol not]]])) select do: [:md |		m := md method.		md isForSharedVariable			ifFalse:				[p := Compiler parse: m getSource					class: md implementingClass.				p == nil ifFalse:					[(self new mode: #userMessages;						subMode: md method resourceType;						doNode: p;						reportStrings: md) ifTrue: [restart := true]]]].	^restart</body></methods><methods><class-id>I18n.I18nErrorBrowser</class-id> <category>private</category><body package="I18n" selector="changes:">changes: aSequenceOfChanges	keyedErrors := Core.Dictionary new.	aSequenceOfChanges do: 			[:errorChange |			errorChange errors				do: [:error | (keyedErrors at: error ifAbsentPut: [Set new]) add: errorChange]].	self changeList list: keyedErrors keys asSortedCollection asList</body></methods><methods><class-id>I18n.I18nErrorBrowser</class-id> <category>aspects</category><body package="I18n" selector="changeList">changeList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^changeList isNil		ifTrue:			[changeList := UI.SelectionInList new]		ifFalse:			[changeList]</body></methods><methods><class-id>I18n.I18nErrorBrowser</class-id> <category>accessing</category><body package="I18n" selector="changeView">changeView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^changeView isNil		ifTrue:			[changeView := Tools.I18nPatchChangeList new]		ifFalse:			[changeView]</body><body package="I18n" selector="changes">changes	^self keyedErrors values inject: OrderedCollection new		into: [:sofar :value | sofar addAll: value; yourself]</body><body package="I18n" selector="keyedErrors">keyedErrors	^keyedErrors</body></methods><methods><class-id>I18n.I18nErrorBrowser</class-id> <category>interface opening</category><body package="I18n" selector="openOn:">openOn: aSequenceOfChanges	"Open up the receiver on the given set of changes."	self changes: aSequenceOfChanges.	self open</body></methods><methods><class-id>I18n.I18nErrorBrowser</class-id> <category>actions</category><body package="I18n" selector="openCatalogWriter">openCatalogWriter	MessageCatalogWriter raiseSingleInstance ifNil:[MessageCatalogWriter open]</body><body package="I18n" selector="scanFilename">scanFilename	self changeView scanFilename.	self changes: self changeView changes.</body><body package="I18n" selector="updatePatches">updatePatches	(I18nCatalogWriterFromSource new errorChangeList: (I18nPatchChangeList new changes: self changes)) updatePatches</body></methods><methods><class-id>I18n.I18nErrorBrowser</class-id> <category>notification</category><body package="I18n" selector="hasModifications">hasModifications	^self changeView hasModifications</body><body package="I18n" selector="updateChangeList">updateChangeList	self changeView  changes: (keyedErrors at: self changeList selection ifAbsent:[#()]) asList.</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>accessing</category><body package="I18n" selector="completeSourcePosition">completeSourcePosition	^completeSourcePosition == nil		ifTrue: [self sourcePosition]		ifFalse: [completeSourcePosition]</body><body package="I18n" selector="completeSourcePosition:">completeSourcePosition: pos	completeSourcePosition := pos</body></methods><methods><class-id>Kernel.CompoundLiteralNode</class-id> <category>initialize</category><body package="I18n" selector="nodes:">nodes: arrayOfNodes	nodes := arrayOfNodes</body></methods><methods><class-id>Kernel.CompoundLiteralNode</class-id> <category>accessing</category><body package="I18n" selector="nodes">nodes	^nodes</body></methods><methods><class-id>Kernel.CompoundLiteralNode</class-id> <category>enumerating</category><body package="I18n" selector="nodeDo:">nodeDo: anEnumerator	^anEnumerator doCompoundLiteral: self value: value</body></methods><methods><class-id>I18n.CatalogDirectoryRequest</class-id> <category>private - actions</category><body package="I18n" selector="defaultAction">defaultAction	^Dialog		requestDirectoryName: (#WriteCatalogsToWhichDirectory &lt;&lt; #I18nTool &gt;&gt; 'Write Catalogs to Which Directory?')		default: self defaultDirectory tail		version: #any		ifFail: [nil].</body></methods><methods><class-id>I18n.CatalogDirectoryRequest</class-id> <category>constants</category><body package="I18n" selector="defaultDirectory">defaultDirectory	^Filename defaultDirectory / 'MessageCatalogs'</body><body package="I18n" selector="defaultResumeValue">defaultResumeValue	^self defaultDirectory asString</body></methods><methods><class-id>I18n.SystemSearchApp</class-id> <category>aspects</category><body package="I18n" selector="criteria">criteria	^criteria</body><body package="I18n" selector="searchTypes">searchTypes	| s |	s := (Array new: 16) writeStream.	s		nextPut: (#i18nStrings &lt;&lt; #I18nTool &gt;&gt; 'i18n strings');		nextPut: (#implementors &lt;&lt; #I18nTool &gt;&gt; 'implementors');		nextPut: (#inBundle &lt;&lt; #I18nTool &gt;&gt; 'in bundle');		nextPut: (#inClassHierarchy &lt;&lt; #I18nTool &gt;&gt; 'in class hierarchy');		nextPut: (#inNameSpace &lt;&lt; #I18nTool &gt;&gt; 'in name space');		nextPut: (#inPackage &lt;&lt; #I18nTool &gt;&gt; 'in package');		nextPut: (#inParcel &lt;&lt; #I18nTool &gt;&gt; 'in parcel');		nextPut: (#instVarName &lt;&lt; #I18nTool &gt;&gt; 'inst var name');		nextPut: (#refersToStatic &lt;&lt; #I18nTool &gt;&gt; 'refers to static');		nextPut: (#refersToSymbol &lt;&lt; #I18nTool &gt;&gt; 'refers to symbol');		nextPut: (#refersToValue &lt;&lt; #I18nTool &gt;&gt; 'refers to value').	^s contents asValue</body><body package="I18n" selector="select">select	^select</body><body package="I18n" selector="selected">selected	^criteria selectionHolder</body><body package="I18n" selector="stringMap">stringMap	^stringMap</body></methods><methods><class-id>I18n.SystemSearchApp</class-id> <category>menus</category><body package="I18n" selector="addRestriction">addRestriction	criteria list add: (SystemSearchRequirement new for: self)</body><body package="I18n" selector="correctData">correctData	| index |	criteria selection == nil ifTrue: [^self].	criteria selection correctData.	index := criteria selectionIndex.	criteria selectionIndexHolder value: 0; value: index.</body><body package="I18n" selector="matchWildcard">matchWildcard	| index |	criteria selection == nil ifTrue: [^self].	criteria selection matchWildcard.	index := criteria selectionIndex.	criteria selectionIndexHolder value: 0; value: index.</body><body package="I18n" selector="newSearch">newSearch	criteria list removeAll: criteria list copy.	self addRestriction</body><body package="I18n" selector="removeRestriction">removeRestriction	criteria selection == nil ifTrue: [^self].	criteria list remove: criteria selection</body><body package="I18n" selector="search">search	| mf combine list aBrowser |	stringMap := Dictionary new.	mf := MethodFilterNull new.	combine := select value == #all ifTrue: [#&amp;] ifFalse: [#|].	criteria list do: 			[:s | 			| mf2 |			mf2 := s asFilter.			s negated ifTrue: [mf2 := mf2 not].			mf := mf perform: combine with: mf2].	Cursor wait showWhile: 			[(self criteria list contains: 					[:filter | 					filter type = (#i18nStrings &lt;&lt; #I18nTool &gt;&gt; 'i18n strings') asString]) 				ifTrue: 					[list := mf select.					list isEmpty 						ifTrue: 							[^Dialog warn: #Nobody &lt;&lt; #I18nTool &gt;&gt; 'Nobody' for: self builder window].					aBrowser := LiteralChooserUI new.					aBrowser						map: stringMap;						query: mf.					aBrowser open]				ifFalse: [mf browseSelect]].	stringMap := nil</body></methods><methods><class-id>I18n.SystemSearchApp</class-id> <category>initialize</category><body package="I18n" selector="initialize">initialize	super initialize.	select := #all asValue.	criteria := SelectionInList new.	self addRestriction</body></methods><methods><class-id>Kernel.I18nErrorReportChange</class-id> <category>accessing</category><body package="I18n" selector="myDefinition">myDefinition	^myDefinition</body><body package="I18n" selector="myDefinition:">myDefinition: anObject	myDefinition := anObject</body></methods><methods><class-id>Kernel.I18nErrorReportChange</class-id> <category>testing</category><body package="I18n" selector="isRelatedTo:">isRelatedTo: aChange 	^self = aChange	  or: [myDefinition notNil		  and: [myDefinition isRelatedTo: aChange]]</body></methods><methods><class-id>Tools.I18nPatchChangeList</class-id> <category>private</category><body package="I18n" selector="addFilter:">addFilter: aSymbol 	"Override to handle isRelatedTo:'s argument"	| filterKeyValue oldFilter |	aSymbol ~~ #isRelatedTo: ifTrue: [^super addFilter: aSymbol].	selectionIndex &gt; 0		ifTrue: [filterKeyValue := list at: selectionIndex]		ifFalse: [^self].	filter isNil		ifTrue: [filter := [:change | filterKeyValue isRelatedTo: change]]		ifFalse: 			[oldFilter := filter.			filter := [:change | (filterKeyValue isRelatedTo: change) and: [oldFilter value: change]]]</body><body package="I18n" selector="filterTemplates">filterTemplates	"return the templates for the filters"	^#(	#( filterByFile filterByType filterByClass filterByProtocol filterBySelector filterBySame filterByRelative )		#( fileName type className category selector values isRelatedTo:))</body><body package="I18n" selector="listEntryForChange:">listEntryForChange: aChange	"Return the string to display in the list for the supplied change.	 This depends on the showing filters."	| entry |	entry := super listEntryForChange: aChange.	(aChange isDefinition and: [aChange isModified]) ifTrue: [entry := '*', entry].	^entry</body><body package="I18n" selector="parseChanges:">parseChanges: aCollection	| parseStream |	parseStream := ReadStream on: aCollection.	changes := List new.	[parseStream atEnd] whileFalse: 			[| change errors |			change := parseStream next.			((change isKindOf: OtherChange) and: [change type = #comment])				ifTrue: 					[| errorStream |					errors := Set new.					errorStream := change text readStream.					[errorStream atEnd] whileFalse: 							[errors add: (errorStream upTo: Character cr) trimBlanks]].			(change isKindOf: I18nMethodDefinitionChange)				ifTrue: 					[change errors: errors.					changes add: change]]</body></methods><methods><class-id>Tools.I18nPatchChangeList</class-id> <category>aspects</category><body package="I18n" selector="relativesFilterAdaptor">relativesFilterAdaptor	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: 7]		putBlock: [:m :v | m switchFilter: 7 perform: #isRelatedTo:]		updateBlock: [:m :a :p | a == #filter and: [p = 7]]</body></methods><methods><class-id>Tools.I18nPatchChangeList</class-id> <category>actions</category><body package="I18n" selector="selectNextChangeContainingString">selectNextChangeContainingString	| string |	string := Dialog				request: (#SelectNextChangeContainingString &lt;&lt; #I18nTool &gt;&gt; 'Select next change containing string')				initialAnswer: (lastTextSearch isNil ifTrue: [''] ifFalse: [lastTextSearch]).	string isEmpty ifTrue: [^self].	lastTextSearch := string.	string := '*', string, '*'.	selectionIndex + 1 to: list size do:		[:i|		(string match: (list at: i) text) ifTrue:			[self toggleListIndex: i.			 self updateSelection: i.			 (builder componentAt: #listView) widget makeVisible: i.			 ^self]]</body></methods><methods><class-id>Tools.I18nPatchChangeList</class-id> <category>accessing</category><body package="I18n" selector="changes:">changes: aSequenceOfChanges	changes := aSequenceOfChanges asList.	self updateList.</body><body package="I18n" selector="value:">value: aValue	"The receiver's text for the currently selected change (if any) has 	changed. Update the text view, and update the change's text."	| thisChange |	value := aValue.	self changed: #value.	(value size &gt; 0 and: [selectionIndex &gt; 0])		ifTrue: 			[thisChange := list at: selectionIndex.			thisChange text ~= value asString				ifTrue: 					[thisChange text: value asString.					self updateSelection: selectionIndex]]</body></methods><methods><class-id>Tools.I18nPatchChangeList</class-id> <category>fileIn/Out</category><body package="I18n" selector="scanFile:">scanFile: aFileStream	"Obtain changes from aFileStream.  Depending on the checkSystem mode	 either read in all changes, or only changes which differ in source or code."	| rawChanges | 	rawChanges := OrderedCollection new.	(aFileStream isExternalStream and: [aFileStream fileName hasSourceExtension])		ifTrue: [aFileStream lineEndTransparent].	Cursor read showWhile: 			[			[ChangeScanner new scanFile: aFileStream				do: 					[:change |					(nil == checkSystem or: [(change sameAsSystem: self) not])						ifTrue: 							[rawChanges								add: (change isDefinition ifTrue: [change asI18nChange] ifFalse: [change])]]]					ensure: [aFileStream close]].	self parseChanges: rawChanges.</body></methods><methods><class-id>Tools.I18nPatchChangeList</class-id> <category>testing</category><body package="I18n" selector="hasModifications">hasModifications	^self changes contains: [:any | any isDefinition and: [any isModified]]</body></methods><methods><class-id>I18n.I18nEnumerator</class-id> <category>private</category><body package="I18n" selector="chooseLiteralTypeFor:">chooseLiteralTypeFor: object	(Pragma allNamed: #literalType: in: self class) do: [:pragma | (self perform: pragma method selector with: object) ifTrue: [^pragma arguments first]].	^object class == Array ifTrue: [#array] ifFalse: [#other]</body><body package="I18n" selector="class:selector:">class: c selector: s	class := c.	selector := s.</body><body package="I18n" selector="collectKey:catalog:default:">collectKey: key catalog: catalog default: default 	self class 		map: key		to: default		translated: (translatedMap at: catalog value ifAbsentPut: [Dictionary new])		inverse: (inverseTranslatedMap at: catalog value				ifAbsentPut: [Dictionary new])		interactive: interactive</body><body package="I18n" selector="isEncodedUserMessage:">isEncodedUserMessage: lit	self literalType == #pragma		ifTrue: [^self isEncodedUserMessageInPragma: lit].	^self isEncodedUserMessageInBody: lit</body><body package="I18n" selector="isEncodedUserMessageInBody:">isEncodedUserMessageInBody: lit 	| idx key catalog default |	(lit size = 5 or: [lit size = 7]) ifFalse: [^false].	lit first isSymbol 		ifTrue: [lit first == #UserMessage ifFalse: [^false]]		ifFalse: 			[lit first isBindingReference 				ifTrue: [lit first name == #UserMessage ifFalse: [^false]]				ifFalse: [^false]].	2 to: self size		by: 2		do: 			[:i | 			(#(#key: #catalogID: #defaultString:) includes: (lit at: i)) 				ifFalse: [^false]].	(idx := lit indexOf: #key:) &gt; 0 ifTrue: [key := lit at: idx + 1].	(idx := lit indexOf: #catalogID:) &gt; 0 ifTrue: [catalog := lit at: idx + 1].	(idx := lit indexOf: #defaultString:) &gt; 0 		ifTrue: [default := lit at: idx + 1].	catalog isNil 		ifFalse: 			[self 				collectKey: key				catalog: catalog				default: default]		ifTrue: 			[self 				halt: (#_1pClassSelectorHasNoCatalog &lt;&lt; #I18nTool 						&gt;&gt; '&lt;1p&gt;&gt;&gt;&lt;2s&gt; has no catalog: &lt;3p&gt;.' 							expandMacrosWith: self myClass							with: self selector							with: lit)].	^true</body><body package="I18n" selector="isEncodedUserMessageInPragma:">isEncodedUserMessageInPragma: lit 	| s |	(lit size = 2 or: [lit size = 3]) ifFalse: [^false].	1 to: lit size		do: 			[:i | 			s := lit at: i.			s isString ifFalse: [^false].			s isSymbol = (i &lt; lit size) ifFalse: [^false]].	self collectKey: lit first catalog: (lit size = 3 ifTrue: [lit at: 2]) default: lit last.	^true</body><body package="I18n" selector="isProgrammaticUserMessageReceiver:selector:arguments:">isProgrammaticUserMessageReceiver: rcvr selector: sel arguments: args 	sel = #defaultString:key:catalogID: ifFalse: [^false].	(rcvr name = 'UserMessage' or: [rcvr name = 'Kernel.UserMessage']) 		ifFalse: [^false].	args do: [:arg | (arg isMemberOf: LiteralNode) ifFalse: [^false]].	args first value isString ifFalse: [^false].	(args at: 2) value isSymbol ifFalse: [^false].	args last value isSymbol ifFalse: [^false].	^true</body><body package="I18n" selector="literalType">literalType	^literalType</body><body package="I18n" selector="location">location	^nil</body><body package="I18n" selector="logSyntaxError">logSyntaxError	interactive ifFalse:[^self].	(Dialog 		confirm: ('&lt;1p&gt;%&gt;%&gt;&lt;2s&gt; contains an invalid UserMessage.&lt;n&gt;Do you want to browse this method?' 				expandMacrosWith: class				with: selector)) 			ifTrue: 				[| method |				method := class compiledMethodAt: selector.				(MethodCollector new methodsSelect: [:m | m == method]) browseSelect]</body><body package="I18n" selector="map:">map: aDictionary	stringMap := aDictionary</body><body package="I18n" selector="testForCompleteUserMessageConstruction:">testForCompleteUserMessageConstruction: aNode	"Test for #key &lt;&lt; #catalog &gt;&gt; 'default' and add them to the maps."	| catalog key default |	(aNode receiver isKindOf: SimpleMessageNode) ifFalse: [^false].	(aNode selector == #&lt;&lt; 		ifTrue: [aNode receiver selector == #&gt;&gt;]		ifFalse: [aNode receiver selector == #&lt;&lt;]) ifFalse: [^false].	catalog := aNode selector == #&lt;&lt; 				ifTrue: [aNode arguments first]				ifFalse: [aNode receiver arguments first].	((catalog isKindOf: LiteralNode) and: [catalog value isSymbol]) 		ifFalse: [^false].	key := [aNode receiver receiver value] on: Error do:[:ex | ^false].	default := aNode selector == #&lt;&lt; 				ifTrue: [aNode receiver arguments first]				ifFalse: [aNode arguments first].	[self collectKey: key value catalog: catalog value default: default value]		on: MessageNotUnderstood		do: [:ex|			(ex receiver isKindOf: ProgramNode)				ifTrue: [self logSyntaxError]				ifFalse: [ex pass]].	^true</body><body package="I18n" selector="testForNoCatalogUserMessageConstruction:">testForNoCatalogUserMessageConstruction: aNode 	"Test for #key &gt;&gt; 'default' and add them to the maps."	| key default |	(aNode selector == #&gt;&gt;	 and: [(aNode receiver isKindOf: LiteralNode)	 and: [(key := aNode receiver value) isSymbol]]) ifFalse:		[^false].	default := aNode arguments first.	[self collectKey: key value catalog: nil default: default value]		on: MessageNotUnderstood		do: [:ex|			(ex receiver isKindOf: ProgramNode)				ifTrue: [self logSyntaxError]				ifFalse: [ex pass]].	^true</body><body package="I18n" selector="testForUserMessageConstruction:">testForUserMessageConstruction: aNode	"Test for either #key &lt;&lt; #catalog &gt;&gt; 'default' or #key &gt;&gt; 'default' and add them to the maps."	| catalog key default keyNode |	(aNode receiver isKindOf: SimpleMessageNode)		ifTrue: 			["key &lt;&lt; catalog &gt;&gt; default"			(aNode selector == #&lt;&lt;				ifTrue: [aNode receiver selector == #&gt;&gt;]				ifFalse: [aNode receiver selector == #&lt;&lt;]) ifFalse: [^false].			catalog := aNode selector == #&lt;&lt;						ifTrue: [aNode arguments first]						ifFalse: [aNode receiver arguments first].			((catalog isKindOf: LiteralNode) and: [catalog value isSymbol])				ifFalse: [^false].			keyNode := aNode receiver receiver.			((keyNode isKindOf: LiteralNode) and: [keyNode value isSymbol])				ifFalse: [^false].			key := keyNode value]		ifFalse: 			["key &gt;&gt; default"			(aNode selector == #&gt;&gt; and: 					[(aNode receiver isKindOf: LiteralNode)						and: [(key := aNode receiver value) isSymbol]])				ifFalse: [^false]].	default := aNode selector == #&lt;&lt;				ifTrue: [aNode receiver arguments first]				ifFalse: [aNode arguments first].		[self		collectKey: key value		catalog: catalog value		default: default value]			on: MessageNotUnderstood			do: 				[:ex |				(ex receiver isKindOf: ProgramNode)					ifTrue: [self logSyntaxError]					ifFalse: [ex pass]].	^true</body><body package="I18n" selector="testLiteralForString:">testLiteralForString: lit	| found def |	lit class == Array		ifTrue:			[(self isEncodedUserMessage: lit) ifTrue: [^false].			found := false.			1 to: lit size do: [:i |				found := found | (self testLiteralForString: (lit at: i))].			^found].	lit isString ifFalse: [^false].	^lit isSymbol		ifTrue: [false]		ifFalse:			[all == nil ifFalse:				[(all at: lit ifAbsentPut: [OrderedCollection new])					add: (Array with: nil with: self literalType).				def := class isBehavior					ifTrue: [MethodDefinition							class: class							selector: selector]					ifFalse: [InitializerDefinition							nameSpace: class environment							key: class name].				(stringMap at: lit ifAbsentPut: [Set new])					add: def].			true]</body><body package="I18n" selector="testMethodOrLiteralForString:">testMethodOrLiteralForString: lit	"returns true if the literal or compiled code &lt;lit&gt; contains a literal string"	(lit isKindOf: CompiledCode)		ifTrue: 			[((lit isKindOf: CompiledBlock) or: [lit attributeMessages == nil])				ifFalse: 					[lit attributeMessages do: 							[:msg |							msg arguments								do: [:arg | (self testLiteralForString: arg) ifTrue: [^true]]]].			1 to: lit numLiterals				do: [:i | (self testMethodOrLiteralForString: (lit literalAt: i)) ifTrue: [^true]]].	lit class == BlockClosure		ifTrue: [self testMethodOrLiteralForString: lit method].	^self testLiteralForString: lit</body><body package="I18n" selector="testPragma:">testPragma: aMessageNode	literalType := #pragma.	aMessageNode arguments do: 			[:each |			(each isKindOf: LiteralNode)				ifTrue: [self handleLiteral: each value: each value]].	literalType := nil</body><body package="I18n" selector="testPragma:blockStart:">testPragma: aMessage blockStart: startPosition	literalType := #pragma.	aMessage arguments do:		[:i | self testLiteralForString: i].	literalType := nil</body></methods><methods><class-id>I18n.I18nEnumerator</class-id> <category>accessing</category><body package="I18n" selector="encounteredStrings">encounteredStrings	^all == nil		ifTrue: [Dictionary new]		ifFalse: [all]</body><body package="I18n" selector="interactive">interactive	^interactive</body><body package="I18n" selector="interactive:">interactive: aBoolean	interactive := aBoolean</body><body package="I18n" selector="myClass">myClass	^class</body><body package="I18n" selector="selector">selector	^selector</body><body package="I18n" selector="translated:inverse:">translated: map1 inverse: map2	translatedMap := map1.	inverseTranslatedMap := map2</body></methods><methods><class-id>I18n.I18nEnumerator</class-id> <category>starting</category><body package="I18n" selector="containsInvalidKey:">containsInvalidKey: aMethod		self containsString: aMethod.	^translatedMap values		contains:			[:each | each keys contains: [:key | key size &gt; 53 or: [key precedence ~= 1]]]</body><body package="I18n" selector="containsString:">containsString: aMethod	| method |	(self testMethodOrLiteralForString: aMethod)		ifFalse: [^false].	all := Dictionary new.	method := aMethod mclass compilerClass new			parse: aMethod getSource			in: aMethod mclass			environment: aMethod environment			allowReceiver: true			noPattern: (aMethod isKindOf: CompiledInitializer)			notifying: nil.	method == nil ifTrue: [self error: (#TheCompilerForThisMethodWasNotFound &lt;&lt; #I18nTool &gt;&gt; 'The compiler for this method was not found')].	self doNode: method node.	^self encounteredStrings isEmpty not</body></methods><methods><class-id>I18n.I18nEnumerator</class-id> <category>enumerating</category><body package="I18n" selector="doLiteral:value:">doLiteral: aNode value: lit	| previousLiteralType |	previousLiteralType := literalType.	previousLiteralType isNil		ifTrue: [literalType := self chooseLiteralTypeFor: lit].	self handleLiteral: aNode value: lit.	literalType := previousLiteralType.	^aNode</body><body package="I18n" selector="doMessage:receiver:selector:arguments:">doMessage: aNode receiver: rcvr selector: sel arguments: args 	(#(#&lt;&lt; #&gt;&gt;) includes: sel) 		ifTrue: [self testForCompleteUserMessageConstruction: aNode]		ifFalse: 			[(self 				isProgrammaticUserMessageReceiver: rcvr				selector: sel				arguments: args) 					ifTrue: 						[self 							collectKey: (args at: 2)							catalog: args last							default: args first]					ifFalse: 						[self doNode: rcvr.						self doNodes: args]]</body><body package="I18n" selector="doMethod:selector:primitive:block:">doMethod: aNode selector: sel primitive: prim block: block	aNode attributeMessages == nil		ifFalse: 			[aNode attributeMessages				do: [:msg | self testPragma: msg ]].	^self doNode: block</body><body package="I18n" selector="handleLiteral:value:">handleLiteral: aNode value: lit	| def |	lit class == Array		ifTrue: 			[(self isEncodedUserMessage: lit)				ifFalse: [self doNodes: aNode nodes].			^self].	lit isString not ifTrue: [^self].	lit isSymbol ifTrue: [^self].	(all at: lit ifAbsentPut: [OrderedCollection new])		add: (Array with: aNode sourcePosition with: self literalType).	def := class isBehavior				ifTrue: [MethodDefinition class: class selector: selector]				ifFalse: 					[InitializerDefinition nameSpace: class environment						key: class name].	(stringMap at: lit ifAbsentPut: [Set new]) add: def</body></methods><methods><class-id>I18n.I18nEnumerator</class-id> <category>actions</category><body package="I18n" selector="findLocationAndTypeFor:in:">findLocationAndTypeFor: stringToReplace in: method	"find the string in a method and return all locations with their types.	returns Array of: #(Interval Symbol)"	self		class: method implementingClass selector: method selector;		map: Dictionary new;		containsString: method method.	^self encounteredStrings at: stringToReplace ifAbsent: [#()]</body></methods><methods><class-id>I18n.I18nEnumerator</class-id> <category>instance initialization</category><body package="I18n" selector="initialize">initialize	super initialize.	literalType := nil.	translatedMap := (Dictionary new: 1024).	inverseTranslatedMap := (Dictionary new: 1024).		interactive := true.</body></methods><methods><class-id>I18n.I18nEnumerator class</class-id> <category>instance creation</category><body package="I18n" selector="new">new	^super new initialize</body></methods><methods><class-id>I18n.I18nEnumerator class</class-id> <category>searching</category><body package="I18n" selector="map:to:translated:inverse:">map: key to: default translated: translated inverse: inverse 	self map: key to: default translated: translated inverse: inverse interactive: true</body><body package="I18n" selector="map:to:translated:inverse:interactive:">map: key to: default translated: translated inverse: inverse interactive: interactive	((translated at: key ifAbsentPut: [default]) ~= default and: 			[ interactive and:[Dialog 				confirm: (#MultipleDefaultStrinTheKey1pBrowse &lt;&lt; #I18nTool 						&gt;&gt; 'Multiple default strings for the key &lt;1p&gt;. Browse?' 							expandMacrosWith: key)]]) 		ifTrue: [(MethodCollector new referencesTo: key) browseSelect].	((inverse at: default ifAbsentPut: [key]) ~= key and: 			[ interactive and:[Dialog 				confirm: (#MultipleKeysForTheDefault1pBrowse &lt;&lt; #I18nTool 						&gt;&gt; 'Multiple keys for the default &lt;1p&gt;. Browse?' expandMacrosWith: default)]]) 		ifTrue: [(MethodCollector new referencesTo: default) browseSelect]</body><body package="I18n" selector="searchAll">searchAll	"This method reports all methods in the image containing strings which you _might_ wish to convert to UserMessage"	"I18nEnumerator searchAll"		^(MethodCollector new		methodsSelect:			[:i | 			i hasSource				and:					[(i isKindOf: CompiledInitializer) not						and:							[(self new)								class: i mclass									selector: i selector;								map: Dictionary new;								interactive: false;								containsString: i]]]) browseSelect</body><body package="I18n" selector="searchInvalidKeys">searchInvalidKeys	"This method reports all methods in the image that have invalid keys in a UserMessage"	"I18nEnumerator searchInvalidKeys"		^(MethodCollector new		methodsSelect:			[:i | 			i hasSource				and:					[(i isKindOf: CompiledInitializer) not						and:							[(self new)								interactive: false;								class: i mclass									selector: i selector;								map: Dictionary new;								interactive: false;								containsInvalidKey: i]]]) browseSelect</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>source code</category><body package="I18n" selector="cachedText:">cachedText: txt	cachedText := txt</body><body package="I18n" selector="text">text	"Answer the text displayed by the receiver."	cachedText == nil ifFalse: [^cachedText].	^super text</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>comparing</category><body package="I18n" selector="=">= anObject	^self == anObject	 or: [self class == anObject class		and: [selector == anObject selector		and: [className = anObject className		and: [self file = anObject file]]]]</body><body package="I18n" selector="hash">hash	^selector hash + className hash</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>private</category><body package="I18n" selector="updateAfterMutation">updateAfterMutation	originalFile := self file</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>related changes</category><body package="I18n" selector="addRelatedChange:">addRelatedChange: aChange	aChange ~= self ifTrue:		[relatedChanges isNil ifTrue: [relatedChanges := Set new].		 relatedChanges add: aChange]</body><body package="I18n" selector="addRelatedChanges:">addRelatedChanges: changes	relatedChanges isNil ifTrue:		[relatedChanges := Set new: changes size * 2].	changes do:		[:aChange|		aChange ~= self ifTrue:			[relatedChanges add: aChange]]</body><body package="I18n" selector="explanationChange">explanationChange	| errorReport |	errorReport := String new writeStream.	self errors asSortedCollection do: [:errorText | errorReport nextPutAll: errorText]		separatedBy: [errorReport cr].	^(OtherChange new)		text: errorReport contents;		type: #comment;		yourself</body><body package="I18n" selector="relatedChanges">relatedChanges	^relatedChanges notNil ifTrue: [relatedChanges] ifFalse: [#()]</body><body package="I18n" selector="removeRelatedChange:">removeRelatedChange: aChange	relatedChanges notNil ifTrue:		[relatedChanges remove: aChange ifAbsent: []]</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>converting</category><body package="I18n" selector="asI18nChange">asI18nChange	originalFile == nil ifTrue: [self updateAfterMutation].	^self</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>testing</category><body package="I18n" selector="isModified">isModified	^sourceCode isString</body><body package="I18n" selector="isRelatedTo:">isRelatedTo: aChange 	^self = aChange	  or: [relatedChanges notNil	  	  and: [relatedChanges includes: (aChange isDefinition 											ifTrue: [aChange]											ifFalse: [aChange myDefinition])]]</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>file accessing</category><body package="I18n" selector="fileName">fileName	"Return the name of the receiver's stream"	| file ds |	originalFile isNil		ifTrue: [(file := self file) == nil ifTrue: [^(#someLocalStream &lt;&lt; #I18nTool &gt;&gt; 'some local stream')]]		ifFalse: [file := originalFile].	true ifTrue:		[^file displayString copyReplaceAll: '$(VISUALWORKS)' with: 'VW'].	ds := file displayString.	^(ds indexOfSubCollection: '$(VISUALWORKS)' startingAt: 1) &gt; 0		ifTrue: [ds copyFrom: 16 to: ds size]		ifFalse: [ds]</body><body package="I18n" selector="originalFile">originalFile	^originalFile</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>printing</category><body package="I18n" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: (#for &lt;&lt; #I18nTool &gt;&gt; ' for ') asString;		nextPutAll: self checkingName</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange</class-id> <category>accessing</category><body package="I18n" selector="errors">errors	^errors ifNil:[errors := Set new]</body><body package="I18n" selector="errors:">errors: aCollection	errors := aCollection</body></methods><methods><class-id>Kernel.I18nMethodDefinitionChange class</class-id> <category>instance creation</category><body package="I18n" selector="fromChange:">fromChange: aMethodDefinitionChange	| new |	new := Array new: self instSize.	new 		replaceFrom: 1		to: MethodDefinitionChange instSize		with: (aMethodDefinitionChange shallowCopy changeClassTo: Array)		startingAt: 1.	self adoptInstance: new.	new updateAfterMutation.	^new</body></methods><methods><class-id>I18n.MessageCatalogWriter</class-id> <category>fly-by help</category><body package="I18n" selector="catalogsDirectoryHelp">catalogsDirectoryHelp	^(#TheDirectoryToWhichTalogsAreGenerated &lt;&lt; #I18nTool &gt;&gt; 'The directory to which message catalogs will be written&lt;n&gt;Existing catalog files in the direcrtory will be deleted when&lt;n&gt;new catalogs are generated.') expandMacros</body><body package="I18n" selector="ignoreExtrasHelp">ignoreExtrasHelp	^(#SelectToRemoveFilesEFilesBeingScaned &lt;&lt; #I18nTool &gt;&gt; 'Select to remove files in these directrories from the files being scaned.')</body><body package="I18n" selector="patchesDirectoryHelp">patchesDirectoryHelp	^(#TheDirectoryContainiWithAStExtension &lt;&lt; #I18nTool &gt;&gt; 'The directory containing patches to be applied to the scanned files&lt;n&gt;Patch files need to have the same base name as the source files&lt;n&gt;they apply to, but with a .st extension') expandMacros</body><body package="I18n" selector="scanCachedChangesHelp">scanCachedChangesHelp	^(#ClickToScanTheChanFTheCacheIsEmpty &lt;&lt; #I18nTool &gt;&gt; 'Click to scan the changes cached from a previous Scan Files run.&lt;n&gt;This is disabled if the cache is empty.') expandMacros</body><body package="I18n" selector="scanFilesHelp">scanFilesHelp	^(#ClickToScanSourceFSInTheSourceFiles &lt;&lt; #I18nTool &gt;&gt; 'Click to scan source files.  Patches in the patches directory&lt;n&gt;will replace corresponding changes in the source files') expandMacros</body><body package="I18n" selector="sourceFileTreeHelp">sourceFileTreeHelp	^(#TheRootDirectoryOfNEGVISUALWORKS &lt;&lt; #I18nTool &gt;&gt; 'The root directory of the source tree to scan.&lt;n&gt;e.g. $(VISUALWORKS)') expandMacros</body><body package="I18n" selector="updatePatchesHelp">updatePatchesHelp	| npd |	^(#ClickToMergeEditsILlBeWrittenTo1s &lt;&lt; #I18nTool &gt;&gt; 'Click to merge edits in All Errors ChangeList&lt;n&gt;with patches in patches directory.&lt;n&gt;New patches will be written to &lt;1s&gt;')		expandMacrosWith: ((npd := self catalogWriter nextPatchFileDirectory) isNil									ifTrue: [(#ADirectoryNameYouWBePromptedToSupply &lt;&lt; #I18nTool &gt;&gt; 'a directory name you will be prompted to supply')]									ifFalse: [npd])</body><body package="I18n" selector="writeCatalogsHelp">writeCatalogsHelp	^(#ClickToGenerateCatalogs &lt;&lt; #I18nTool &gt;&gt; 'Click to generate catalogs')</body></methods><methods><class-id>I18n.MessageCatalogWriter</class-id> <category>building</category><body package="I18n" selector="postOpenWith:">postOpenWith: aBuilder	self checkEnablement</body><body package="I18n" selector="preBuildWith:">preBuildWith: aBuilder	(self class organization listAtCategoryNamed: #'fly-by help') do:		[:selector|		aBuilder labelAt: selector put: (self perform: selector)]</body></methods><methods><class-id>I18n.MessageCatalogWriter</class-id> <category>actions</category><body package="I18n" selector="openErrorBrowser">openErrorBrowser	self catalogWriter openErrorBrowser</body><body package="I18n" selector="openErrorChangeList">openErrorChangeList	self catalogWriter openErrorChangeList</body><body package="I18n" selector="scanCachedChanges">scanCachedChanges	self disableButtonsWhile: [self catalogWriter scanCachedChanges]</body><body package="I18n" selector="scanFiles">scanFiles	self catalogWriter canScanCachedFileChanges ifTrue:		[(Dialog confirm: (#DoYouReallyWantToLeTheCacheIsFull &lt;&lt; #I18nTool &gt;&gt; 'Do you really want to scan files while the cache is full?')) ifFalse:			[^self]].	self disableButtonsWhile: [self catalogWriter scanFiles].	(self wrapperAt: #updatePatches) enable</body><body package="I18n" selector="updatePatches">updatePatches	self disableButtonsWhile:		[self catalogWriter updatePatches.		 patchesDirectory value: self catalogWriter patchesDirectory]</body><body package="I18n" selector="writeCatalogs">writeCatalogs	self disableButtonsWhile: [self catalogWriter writeCatalogs]</body></methods><methods><class-id>I18n.MessageCatalogWriter</class-id> <category>private</category><body package="I18n" selector="catalogWriter">catalogWriter	catalogWriter isNil ifTrue:		[catalogWriter := I18nCatalogWriterFromSource new].	^catalogWriter</body><body package="I18n" selector="checkEnablement">checkEnablement	(self wrapperAt: #scanCachedChanges)		isEnabled: self catalogWriter canScanCachedFileChanges.	(self wrapperAt: #writeCatalogs)		isEnabled: self catalogWriter canWriteCatalogs</body><body package="I18n" selector="disableButtonsWhile:">disableButtonsWhile: aBlock	| buttonNames enablementState |	buttonNames := #(scanFiles scanCachedChanges updatePatches writeCatalogs).	[enablementState := buttonNames collect:		[:buttonId| | wrapper isEnabled |		isEnabled := (wrapper := self wrapperAt: buttonId) isEnabled.		wrapper disable.		isEnabled].	 Cursor execute showWhile: aBlock]		ensure:			[buttonNames				with: enablementState				do: [:buttonId :isEnabled|					(self wrapperAt: buttonId) isEnabled: isEnabled].			 self checkEnablement]</body></methods><methods><class-id>I18n.MessageCatalogWriter</class-id> <category>aspects</category><body package="I18n" selector="catalogsDirectory">catalogsDirectory	catalogsDirectory isNil ifTrue:		[catalogsDirectory := (AspectAdaptor subject: self catalogWriter)								accessWith: #catalogsDirectory								assignWith: #catalogsDirectory:].	^catalogsDirectory</body><body package="I18n" selector="ignoreExtras">ignoreExtras	ignoreExtras isNil ifTrue:		[ignoreExtras := (AspectAdaptor subject: self catalogWriter)								accessWith: #ignoreExtras								assignWith: #ignoreExtras:].	^ignoreExtras</body><body package="I18n" selector="patchesDirectory">patchesDirectory	patchesDirectory isNil ifTrue:		[patchesDirectory := (AspectAdaptor subject: self catalogWriter)								accessWith: #patchesDirectory								assignWith: #patchesDirectory:].	^patchesDirectory</body><body package="I18n" selector="sourceFileTree">sourceFileTree	sourceFileTree isNil ifTrue:		[sourceFileTree := (AspectAdaptor subject: self catalogWriter)								accessWith: #sourceFileTree								assignWith: #sourceFileTree:].	^sourceFileTree</body></methods><methods><class-id>Kernel.PragmaMessageNode</class-id> <category>accessing</category><body package="I18n" selector="arguments">arguments	^arguments</body><body package="I18n" selector="arguments:">arguments: anObject	arguments := anObject</body><body package="I18n" selector="asMessage">asMessage	^Message selector: selector value arguments: (arguments collect:#value) asArray</body><body package="I18n" selector="selector">selector	^selector</body><body package="I18n" selector="selector:">selector: anObject	selector := anObject</body></methods><methods><class-id>Kernel.PragmaMessageNode</class-id> <category>initialize-release</category><body package="I18n" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	selector := nil.	arguments := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Kernel.PragmaMessageNode</class-id> <category>enumerating</category><body package="I18n" selector="nodeDo:">nodeDo: anEnumerator	" *** This method was defined by ProgramNode as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Kernel.PragmaMessageNode class</class-id> <category>instance creation</category><body package="I18n" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="I18n" selector="selector:">selector: aSymbol	^self selector: aSymbol arguments: #()</body><body package="I18n" selector="selector:arguments:">selector: aSymbol arguments: anArray	^(self new)		selector: aSymbol;		arguments: anArray;		yourself</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>accessing</category><body package="I18n" selector="dependentRB">dependentRB	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dependentRB</body><body package="I18n" selector="map:">map: aStringMap	map := aStringMap.	self stringList list: map keys asSortedCollection asList</body><body package="I18n" selector="query:">query: aFilter	query := aFilter</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>aspects</category><body package="I18n" selector="stringList">stringList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^stringList isNil		ifTrue:			[stringList := SelectionInList new]		ifFalse:			[stringList]</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>initialize release</category><body package="I18n" selector="initialize">initialize	super initialize.	self stringList selectionIndexHolder 		onChangeSend: #stringSelectionChanged		to: self.	self createBrowser</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>change update</category><body package="I18n" selector="stringSelectionChanged">stringSelectionChanged	"The selection in the list of undeclareds has changed, so recalculate 	its references and show them in the methodsList."	"Old style collection was done using a MethodCollector:		mc := MethodCollector new.		l := mc select: (mc referencesTo: (Undeclared bindingFor: sel))	But new researches have shown, a different way."	| sel |	(sel := self stringList selection) isNil 		ifFalse: [self methodsList: (map at: sel)]		ifTrue: [self methodsList: #()]</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>actions</category><body package="I18n" selector="autoEdit">autoEdit	"Open a dialog to confirm the user message. Then apply the modification to the selection.	If no methods are selected apply to all in the list"	| methodsToBeModified userMessage |	methodsToBeModified := dependentRB navigator definitions.	methodsToBeModified isEmpty		ifTrue: [methodsToBeModified := map at: self stringList selection].	methodsToBeModified isEmpty ifTrue: [^self].	userMessage := self getUserMessage ifNil: [^self].	methodsToBeModified do: [:method | self modify: method userMessage: userMessage].	self dependentRB navigator refreshLists</body><body package="I18n" selector="forgetLiterals">forgetLiterals	self stringList selectionDo: 			[:str |			map removeKey: str ifAbsent: [].			self stringList list remove: str]</body><body package="I18n" selector="searchAgain">searchAgain	"We can't just assign the map to be a new Dictionary,	because the old Dictionary is referred to inside the query."	map keys do: [:key | map removeKey: key].	query select.	self map: map</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>private</category><body package="I18n" selector="modify:userMessage:">modify: method userMessage: userMessage	| replacement src stringToReplace node formatter |	stringToReplace := userMessage defaultString.	replacement := nil.	src := method sourceCode.	(I18nEnumerator new findLocationAndTypeFor: stringToReplace		in: method) reverseDo: 				[:locationAndType |				| type location |				location := locationAndType first.				type := locationAndType last.				replacement := (self							replacementTemplateFor: userMessage							in: method							type: type)								expandMacrosWith: userMessage key asSymbol								with: stringToReplace								with: userMessage catalogID asSymbol.				src := src							copyReplaceFrom: location first							to: location last							with: replacement].	node := Refactory.Browser.RBParser parseMethod: src.	formatter := node formatterClass new.	src := formatter format: node.	^method implementingClass compile: src		classified: method protocol</body><body package="I18n" selector="proposedKey:">proposedKey: label 	| s capital |	s := (label species new: label size) writeStream.	capital := false.	label do: 			[:each | 			each == $&amp; 				ifTrue: [s nextPut: $_]				ifFalse: 					[each isAlphaNumeric 						ifTrue: 							[(s position = 0 and: [each isDigit]) ifTrue: [s nextPut: $_].							s nextPut: (capital 										ifTrue: 											[capital := false.											each asUppercase]										ifFalse: [each])]						ifFalse: [each == $' ifFalse: [capital := true]]]].	^s contents</body><body package="I18n" selector="replacementTemplateFor:in:type:">replacementTemplateFor: userMessage in: method type: type	(Pragma allNamed: #templateType: in: self class)		do: [:pragma | pragma arguments first = type ifTrue: [^self perform: pragma method selector with: userMessage]].	self error: (#CantEditArrayLiteAutomaticallyIn1p &lt;&lt; #I18nTool &gt;&gt; 'Can''t edit array literals automatically in &lt;1p&gt;' expandMacrosWith: method)</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>dependent browser</category><body package="I18n" selector="createBrowser">createBrowser	| browserEnvironment |	browserEnvironment := Refactory.Browser.SelectorEnvironment 				onMethods: Array new.	browserEnvironment label: (#Internationalizer &lt;&lt; #I18nTool &gt;&gt; 'Internationalizer').	dependentRB := Refactory.Browser.RefactoringBrowser 				onEnvironment: browserEnvironment</body><body package="I18n" selector="methodsList:">methodsList: aList 	aList isEmpty 		ifTrue: 			[dependentRB 				environment: (Refactory.Browser.SelectorEnvironment onMethods: aList)]		ifFalse: 			[dependentRB 				environment: ((Refactory.Browser.SelectorEnvironment onMethods: aList)						addSearchString: self stringList selection printString;						yourself)].	dependentRB navigator refreshLists</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>private dialog</category><body package="I18n" selector="getCatalog:key:">getCatalog: catalogValueHolder key: keyValueHolder	| dialog |	dialog := SimpleDialog				initializedFor: self dependentRB interfaceWindow.	dialog		setInitialGap;		addTextLine: (self stringList selection contractTo: 48)					asValue;		addGap;		addMessage: #Catalog &lt;&lt; #I18nTool &gt;&gt; 'Catalog:'			textLine: catalogValueHolder			boundary: 0.4;		addGap;		addMessage: #Key &lt;&lt; #I18nTool &gt;&gt; 'Key:'			textLine: keyValueHolder			boundary: 0.4;		addGap;		addOK: [true].	dialog openDialog.	^dialog accept value</body><body package="I18n" selector="getUserMessage">getUserMessage	"Open a dialog series to find a formally correct user message"	"Return: a UserMessage | nil"	| cat key |	cat := LastCatalog asValue.	key := (self proposedKey: (self stringList selection contractTo: 48)) asValue.		[(self getCatalog: cat key: key)		ifFalse: 			[Dialog warn: #EditingHasBeenCanceled &lt;&lt; #I18nTool &gt;&gt; 'Editing has been canceled'.			^nil].	Scanner isLiteralSymbol: key value]			whileFalse: [Dialog warn: (#_1pIsNotAnIdentifAyNotBeUsedAsKey &lt;&lt; #I18nTool &gt;&gt; '&lt;1p&gt; is not an Identifier and may not be used as key' expandMacrosWith: key)].	LastCatalog := cat value.	^UserMessage		defaultString: self stringList selection		key: key value		catalogID: LastCatalog</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>source code</category><body package="I18n" selector="cachedText:">cachedText: txt	cachedText := txt</body><body package="I18n" selector="text">text	"Answer the text displayed by the receiver."	cachedText == nil ifFalse: [^cachedText].	^super text</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>private</category><body package="I18n" selector="updateAfterMutation">updateAfterMutation	originalFile := self file</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>related changes</category><body package="I18n" selector="addRelatedChange:">addRelatedChange: aChange	aChange ~= self ifTrue:		[relatedChanges isNil ifTrue: [relatedChanges := Set new].		 relatedChanges add: aChange]</body><body package="I18n" selector="addRelatedChanges:">addRelatedChanges: changes	relatedChanges isNil ifTrue:		[relatedChanges := Set new: changes size * 2].	changes do:		[:aChange|		aChange ~= self ifTrue:			[relatedChanges add: aChange]]</body><body package="I18n" selector="relatedChanges">relatedChanges	^relatedChanges notNil ifTrue: [relatedChanges] ifFalse: [#()]</body><body package="I18n" selector="removeRelatedChange:">removeRelatedChange: aChange	relatedChanges notNil ifTrue:		[relatedChanges remove: aChange ifAbsent: []]</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>converting</category><body package="I18n" selector="asI18nChange">asI18nChange	originalFile == nil ifTrue: [self updateAfterMutation].	^self</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>testing</category><body package="I18n" selector="isModified">isModified	^sourceCode isString</body><body package="I18n" selector="isRelatedTo:">isRelatedTo: aChange 	^self = aChange	  or: [relatedChanges notNil	  	  and: [relatedChanges includes: (aChange isDefinition 											ifTrue: [aChange]											ifFalse: [aChange myDefinition])]]</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>comparing</category><body package="I18n" selector="=">= anObject	^self == anObject	 or: [self class == anObject class		and: [self parameters = anObject parameters		and: [self file = anObject file]]]</body><body package="I18n" selector="hash">hash	^className hash + classType hash</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>file accessing</category><body package="I18n" selector="fileName">fileName	"Return the name of the receiver's stream"	| file ds |	originalFile isNil		ifTrue: [(file := self file) == nil ifTrue: [^(#someLocalStream &lt;&lt; #I18nTool &gt;&gt; 'some local stream')]]		ifFalse: [file := originalFile].	true ifTrue:		[^file displayString copyReplaceAll: '$(VISUALWORKS)' with: 'VW'].	ds := file displayString.	^(ds indexOfSubCollection: '$(VISUALWORKS)' startingAt: 1) &gt; 0		ifTrue: [ds copyFrom: 16 to: ds size]		ifFalse: [ds]</body><body package="I18n" selector="originalFile">originalFile	^originalFile</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange</class-id> <category>printing</category><body package="I18n" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: (#for &lt;&lt; #I18nTool &gt;&gt; ' for ') asString;		nextPutAll: self checkingName</body></methods><methods><class-id>Kernel.I18nClassDefinitionChange class</class-id> <category>instance creation</category><body package="I18n" selector="fromChange:">fromChange: aClassDefinitionChange	| new |	new := Array new: self instSize.	new 		replaceFrom: 1		to: ClassDefinitionChange instSize		with: (aClassDefinitionChange shallowCopy changeClassTo: Array)		startingAt: 1.	self adoptInstance: new.	new updateAfterMutation.	^new</body></methods><methods><class-id>Kernel.Parser</class-id> <category>public access</category><body package="I18n" selector="parseArrayElementIn:">parseArrayElementIn: aString	| failure |	builder := ProgramNodeBuilder new.	failure := [^self error: (#ErrorExpectedEndOfData &lt;&lt; #dialogs &gt;&gt; 'Expected end of data')].	self		init: aString readStream		notifying: (SilentCompilerErrorHandler new failBlock: failure)		saveComments: false		failBlock: failure.	self arrayLiteralElement.	tokenType = #doIt		ifFalse: [failure value].	^parseNode</body><body package="I18n" selector="scanTokens:">scanTokens: textOrString 	"Answer with an Array which has been tokenized as though the input text	had appeared between #( and ) in a Smalltalk literal expression."	| s |	builder := ProgramNodeBuilder new.	self scan: (ReadStream on: textOrString asString).	s := WriteStream on: (Array new: 16).	[tokenType = #doIt]		whileFalse: 			[self arrayLiteralElement.			s nextPut: parseNode].	^s contents	"Parser new scanTokens: 			'identifier keyword: 8r31 ''string'' embedded.period key:word: .   '     "</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-true/false</category><body package="I18n" selector="constant">constant	"Recognize a constant (named, number, character,	string, or quoted).  Leave the constant value in parseNode."	| size trialValue start |	start := mark.	tokenType == #word		ifTrue: 			["Special check for nil / true / false"			trialValue := #noMatch.			size := token size.			size = 5				ifTrue: [token = 'false' ifTrue: [trialValue := false]]				ifFalse: [size = 4					ifTrue: [token = 'true' ifTrue: [trialValue := true]]					ifFalse: [size = 3						ifTrue: [token = 'nil' ifTrue: [trialValue := nil]]]].			trialValue == #noMatch				ifFalse:					[self completeConstant: trialValue start: start.					^true].			^false].	(tokenType == #string or: [tokenType == #number or: [tokenType == #character]])		ifTrue: 			[self completeConstant: token start: start.			^true].	(token == #- and: [hereChar notNil and: [hereChar isDigit]])		ifTrue: 			[self scanToken.  "skip the -, read the number"			self completeConstant: token negated start: start.			^true].	tokenType == #literalQuote		ifFalse:			[^false].	"This is a quoted literal"	self scanToken.  "skip the #"	(tokenType == #word or: [tokenType == #binary or: [tokenType == #verticalBar or: [newLanguage and: [tokenType == #string]]]])		ifTrue:			[self completeConstant: token asSymbol start: start.			^true].	tokenType == #keyword		ifTrue:			["Scan a multi-keyword literal."			self scanLitKeywords.			self completeConstant: token asSymbol start: start.			^true].	tokenType == #leftParenthesis		ifTrue:			[self scanToken.			self arrayLiteralStart: start.			^true].	tokenType == #leftBracket		ifTrue:			[self scanToken.			self byteArrayLiteralStart: start.			^true].	tokenType == #leftBrace		ifTrue:			[self scanToken.			mark := start.		"So that the source position of such constants is correct. May be a hack."			self qualifiedNameLiteral.			^true].	^self expected: 'word, binary, keyword, (, or ['</body><body package="I18n" selector="primaryExpression">primaryExpression	| pStart |	tokenType == #word		ifTrue: 			[self constant  "check for nil / true / false"				ifTrue:					[parseNode := constantNode]				ifFalse:					[parseNode := builder newVariableName: token.					parseNode sourcePosition: mark.					self scanToken].			^true].	tokenType == #compoundWord		ifTrue:			[parseNode := self bindingRefAt: token.			parseNode := builder newVariableName: parseNode.			parseNode sourcePosition: mark.			self scanToken.			^true].	tokenType == #leftBracket		ifTrue: 			[self blockExpression.			^true].	tokenType == #leftParenthesis		ifTrue: 			[pStart := mark.			self scanToken.			self expression ifFalse: [^self expected: (#Expression &lt;&lt; #dialogs &gt;&gt; 'expression')].			tokenType == #rightParenthesis				ifFalse: [^self expected: (#RightParenthesis &lt;&lt; #dialogs &gt;&gt; 'right parenthesis')].			parseNode completeSourcePosition: (pStart to: mark).			self scanToken.			^true].	self constant		ifTrue:			[parseNode := constantNode.			^true].	^false</body><body package="I18n" selector="simpleType">simpleType	" simpleType = className ['class'] | literal | '(' type ')' "	self constant ifTrue:		[parseNode := constantNode.		^true].	tokenType == #leftParenthesis ifTrue:		[self scanToken.		self typeExpression ifFalse: [^self expected: (#TypeExpression &lt;&lt; #dialogs &gt;&gt; 'type expression')].		tokenType == #rightParenthesis ifFalse: [^self expected: (#RightParenthesis &lt;&lt; #dialogs &gt;&gt; 'right parenthesis')].		self scanToken.		^true].	(tokenType == #compoundWord or:			[tokenType == #word])		ifFalse: [^false].	parseNode := builder newVariableName: token.  "the class name"	self scanToken.	(tokenType == #word and: [token = 'class'])		ifTrue:			[parseNode := builder newMessageReceiver: parseNode selector: #class arguments: #().			self scanToken].	^true</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-success/error</category><body package="I18n" selector="arrayLiteralElement">arrayLiteralElement	"It's just too hard to accept both	syntaxes.  New takes precedence."	| start |	newLanguage ifTrue:		[self constant ifTrue: [^self]].	oldLanguage ifFalse:		[^self expected: (#ArrayElement &lt;&lt; #dialogs &gt;&gt; 'array element')].	tokenType = #leftParenthesis ifTrue:		[start := mark.		self scanToken.		self arrayLiteralStart: start.		^self].	tokenType = #leftBracket ifTrue:		[start := mark.		self scanToken.		self byteArrayLiteralStart: start.		^self].	self scanLitToken.	self completeConstant: token start: mark.</body><body package="I18n" selector="arrayLiteralStart:">arrayLiteralStart: start	| s sn |	s := WriteStream on: (Array new: 16).	sn := WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis]		whileFalse: 			[tokenType == #doIt ifTrue:				[^self expected: (#ArrayElementOrRightParenthesis &lt;&lt; #dialogs &gt;&gt; 'array element or right parenthesis')].			self arrayLiteralElement.			s nextPut: parseNode.			sn nextPut: constantNode].	self scanToken.	parseNode := s contents.	constantNode := builder newArrayLiteralValue: parseNode.	constantNode sourcePosition: (start to: self endOfLastToken).	constantNode nodes: sn contents.</body><body package="I18n" selector="byteArrayLiteralStart:">byteArrayLiteralStart: start	| s |	s := WriteStream on: (ByteArray new: 16).	[tokenType = #rightBracket]		whileFalse: 			[(tokenType == #number and: [token isInteger and:			  [token &gt;= 0 and: [token &lt;= 255]]]) ifFalse:				[^self expected: (#EightBitIntegerOrRightBracket &lt;&lt; #dialogs &gt;&gt; '8-bit integer or right bracket')].			s nextPut: token.			self scanToken].	self completeConstant: s contents start: start.</body><body package="I18n" selector="qualifiedNameLiteral">qualifiedNameLiteral	| id start |	start := mark.	(tokenType == #word or: [tokenType == #compoundWord])		ifFalse: [^self expected: (#Identifier &lt;&lt; #dialogs &gt;&gt; 'Identifier')].	id := token.	self scanToken.	tokenType == #rightBrace		ifFalse: [^self expected: '}'].	self completeConstant: (self bindingRefAt: id) start: start.</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-^value/error</category><body package="I18n" selector="parseSimpleMeta:startingAt:name:">parseSimpleMeta: methodNode startingAt: p1 name: key	"This is a quoted literal"	| args sel pragmaNode argNodes |	pragmaNode := PragmaMessageNode selector: key asSymbol.	key last = $: ifFalse: [^pragmaNode ].	args := OrderedCollection new.	sel := key.	argNodes := OrderedCollection new.	[self constant		ifFalse: [^self expected: #LiteralConstant &lt;&lt; #dialogs &gt;&gt; 'Literal constant'].	args add: parseNode.	argNodes add: constantNode.	tokenType == #keyword]			whileTrue: 				[sel := sel , token.				self scanToken].	pragmaNode selector: sel asSymbol.	pragmaNode arguments: argNodes.	pragmaNode sourcePosition: (p1 to: self endOfLastToken).	^pragmaNode</body></methods><methods><class-id>Kernel.Parser</class-id> <category>private</category><body package="I18n" selector="completeConstant:start:">completeConstant: value start: start	self scanToken.	parseNode := value.	constantNode := builder newLiteralValue: parseNode.	constantNode sourcePosition: (start to: self endOfLastToken).</body></methods><methods><class-id>I18n.SystemSearchRequirement</class-id> <category>conversion</category><body package="I18n" selector="asFilter">asFilter	| mc map |	mc := MethodCollector new.	type := type asString.	type = (#i18nStrings &lt;&lt; #I18nTool &gt;&gt; 'i18n strings') asString		ifTrue:			[map := application stringMap.			^mc methodsSelect: [:c :s :m |					I18nEnumerator new						class: c selector: s;						map: map;						containsString: m]].	type = (#implementors &lt;&lt; #I18nTool &gt;&gt; 'implementors') asString		ifTrue: [^mc implementorsOf: data asSymbol].	type = (#inBundle &lt;&lt; #I18nTool &gt;&gt; 'in bundle') asString		ifTrue: [^mc bundle: data].	type = (#inClassHierarchy &lt;&lt; #I18nTool &gt;&gt; 'in class hierarchy') asString		ifTrue: [^mc searchClassHierarchy: data asQualifiedReference value].	type = (#inNameSpace &lt;&lt; #I18nTool &gt;&gt; 'in name space') asString		ifTrue: [^mc nameSpace: data].	type = (#inPackage &lt;&lt; #I18nTool &gt;&gt; 'in package') asString		ifTrue: [^mc package: data].	type = (#inParcel &lt;&lt; #I18nTool &gt;&gt; 'in parcel') asString		ifTrue: [^mc parcel: data].	type = (#instVarName &lt;&lt; #I18nTool &gt;&gt; 'inst var name') asString		ifTrue: [^mc instVarUse: data access: #readWrite].	type = (#refersToValue &lt;&lt; #I18nTool &gt;&gt; 'refers to value') asString		ifTrue: [^mc referencesTo: (Compiler evaluate: data)].	type = (#refersToSymbol &lt;&lt; #I18nTool &gt;&gt; 'refers to symbol') asString		ifTrue: [^mc referencesTo: data asSymbol].	type = (#refersToStatic &lt;&lt; #I18nTool &gt;&gt; 'refers to static') asString		ifTrue: [^mc referencesTo: data asQualifiedReference binding].	^self error: (#UnknownFilterType &lt;&lt; #I18nTool &gt;&gt; 'Unknown filter type')</body><body package="I18n" selector="correctData">correctData	| newData |	type = (#implementors &lt;&lt; #I18nTool &gt;&gt; 'implementors') asString		ifTrue:			[newData := Symbol correctMessage: data.			newData == nil ifTrue: [^self].			self data: newData.			^self].	type = (#refersToSymbol &lt;&lt; #I18nTool &gt;&gt; 'refers to symbol') asString		ifTrue:			[newData := Symbol correctMessage: data.			newData == nil ifTrue: [^self].			self data: newData.			^self].	^Dialog warn: (#ThisTypeOfSearchDoTSupportCorrection &lt;&lt; #I18nTool &gt;&gt; 'This type of search does not (yet) support correction')</body><body package="I18n" selector="matchWildcard">matchWildcard	| newData matches index confirm |	type = (#implementors &lt;&lt; #I18nTool &gt;&gt; 'implementors') 		ifTrue: 			[newData := SmalltalkWorkbench allImplementedMessages 						select: [:s | data match: s].			newData := newData asSortedCollection.			newData := Dialog 						choose: #ImplementorsOfWhichSymbol &lt;&lt; #I18nTool 								&gt;&gt; 'Implementors of which symbol?'						fromList: newData						values: newData						lines: 16						cancel: [^self].			self data: newData asString.			^self].	(index := (Array 				with: #inBundle &lt;&lt; #I18nTool &gt;&gt; 'in bundle'				with: #inPackage &lt;&lt; #I18nTool &gt;&gt; 'in package'				with: #inParcel &lt;&lt; #I18nTool &gt;&gt; 'in parcel') indexOf: type) 		&gt; 0 			ifTrue: 				[newData := index = 1 							ifTrue: [Store.Registry allBundles]							ifFalse: 								[index = 2 ifTrue: [Store.Registry allPackages] ifFalse: [Parcel parcels]].				newData := newData collect: [:s | s name].				newData := newData select: [:s | data match: s].				newData := newData asSortedCollection.				confirm := (Array 							with: (#SearchInWhichBundle &lt;&lt; #I18nTool &gt;&gt; 'Search in which bundle?')							with: (#SearchInWhichPackage &lt;&lt; #I18nTool &gt;&gt; 'Search in which package?')							with: (#SearchInWhichParcel &lt;&lt; #I18nTool &gt;&gt; 'Search in which parcel?')) at: index.				newData := Dialog 							choose: confirm							fromList: newData							values: newData							lines: 16							cancel: [^self].				self data: newData asString.				^self].	type = (#refersToSymbol &lt;&lt; #I18nTool &gt;&gt; 'refers to symbol') asString 		ifTrue: 			[newData := SmalltalkWorkbench allImplementedMessages 						select: [:s | data match: s].			newData := newData asSortedCollection.			newData := Dialog 						choose: #ImplementorsOfWhichSymbol &lt;&lt; #I18nTool 								&gt;&gt; 'Implementors of which symbol?'						fromList: newData						values: newData						lines: 16						cancel: [^self].			self data: newData asString.			^self].	(type = (#refersToStatic &lt;&lt; #I18nTool &gt;&gt; 'refers to static') asString or: 			[type = (#inClassHierarchy &lt;&lt; #I18nTool &gt;&gt; 'in class hierarchy') asString 				or: [type = (#inNameSpace &lt;&lt; #I18nTool &gt;&gt; 'in name space') asString]]) 		ifTrue: 			[Cursor execute showWhile: 					[| objects |					objects := Root withAllNameSpacesAndAllClassesAndStatics.					matches := objects select: [:mod | data match: mod name]].			(matches == nil or: [matches size = 0]) ifTrue: [^self].			newData := matches size = 1 						ifTrue: [matches first]						ifFalse: 							[matches := matches asSortedCollection: [:a :b | a fullName &lt; b fullName].							Dialog 								choose: #Choose &lt;&lt; #I18nTool &gt;&gt; 'Choose ...'								fromList: (matches collect: [:m | m fullName])								values: matches								lines: 10								cancel: [^false]								for: nil].			newData := newData fullyQualifiedReference asString.			self data: newData.			^self].	^Dialog warn: (#ThisTypeOfSearchDoesNotSupportWildcards &lt;&lt; #I18nTool &gt;&gt; 'This type of search does not support wildcards')</body></methods><methods><class-id>I18n.SystemSearchRequirement</class-id> <category>initialize</category><body package="I18n" selector="for:">for: aSearchApp	application := aSearchApp</body><body package="I18n" selector="initialize">initialize	super initialize.	type := (#i18nStrings &lt;&lt; #I18nTool &gt;&gt; 'i18n strings') asString.	data := ''.	negated := false</body></methods><methods><class-id>I18n.SystemSearchRequirement</class-id> <category>aspects</category><body package="I18n" selector="data">data	^data</body><body package="I18n" selector="data:">data: string	data := string</body><body package="I18n" selector="negated">negated	^negated</body><body package="I18n" selector="negated:">negated: aBoolean	negated := aBoolean</body><body package="I18n" selector="type">type	^type</body><body package="I18n" selector="type:">type: symbol	type := symbol</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>patch file generation</category><body package="I18n" selector="merge:with:to:">merge: existingFile with: updates to: newFile	| rs scs updateLookup |	updates isEmpty ifTrue: [^existingFile copyTo: newFile].	updateLookup := Dictionary new.	updates do: [:change| updateLookup at: change checkingName put: change].	existingFile exists ifTrue:		[rs := (existingFile withEncoding: #Source) readStream.		 [rs lineEndTransparent.		  I18nScanner new			scanFile: rs			do: [:aChange |				(updateLookup includesKey: aChange checkingName) ifFalse:					[updates add: aChange asI18nChange]]]			ensure: [rs close]].	scs := SourceCodeStream write: newFile.	[(self sortChanges: updates) do:		[:change| change fileOutOn: scs].	scs checkMethodChunkClass: nil protocol: nil]		ensure: [scs close]</body><body package="I18n" selector="patchesDirectory">patchesDirectory	^patchDirectory asString</body><body package="I18n" selector="patchesDirectory:">patchesDirectory: aString	patchDirectory := aString asLogicalFileSpecification</body><body package="I18n" selector="updatePatches">updatePatches	| allPatchFiles updatesByFile npfd updates |	allPatchFiles := (patchDirectory filesMatching: '*.st') asSet collect: [:ea| ea asLogicalFileSpecification].	npfd := self nextPatchFileDirectory asFilename.	npfd ensureDirectory.	updates := errorChangeList changes select: [:ea| ea isDefinition and: [ea isModified]].	updatesByFile := Dictionary new.	updates do:		[:change|		(updatesByFile			at: (allPatchFiles add: (self patchFileForFileName: change originalFile fileName))			ifAbsentPut: [Set new]) add: change].	allPatchFiles do:		[:patchFile|		self merge: patchFile with: (updatesByFile at: patchFile ifAbsent: [#()]) to: (npfd construct: patchFile tail)].	patchDirectory := npfd</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>error reporting</category><body package="I18n" selector="addExplanation:forError:">addExplanation: errorText forError: errorChange	errorChange errors add: errorText.</body><body package="I18n" selector="defaultsFor:fromChanges:">defaultsFor: tuple fromChanges: errorChanges	| defaults |	defaults := Set new.	self report:			[:key :catalog :default|			(key == (tuple at: 1) and: [catalog == (tuple at: 2)]) ifTrue:				[defaults add: default]]		while: [errorChanges do: [:errorChange| self parseChange: errorChange]].	^defaults asSortedCollection</body><body package="I18n" selector="keysFor:fromChanges:">keysFor: tuple fromChanges: errorChanges	| keys |	keys := Set new.	self report:			[:key :catalog :default|			(catalog == (tuple at: 2) and: [default = (tuple at: 3)]) ifTrue:				[keys add: key]]		while: [errorChanges do: [:errorChange| self parseChange: errorChange]].	^keys asSortedCollection</body><body package="I18n" selector="openErrorBrowser">openErrorBrowser	I18nErrorBrowser new openOn: allErrors</body><body package="I18n" selector="openErrorChangeList">openErrorChangeList	| errorsAndExplanations |	errorsAndExplanations := OrderedCollection new: allErrors size * 2.	allErrors do: 			[:errorChange |			errorsAndExplanations				addLast: errorChange explanationChange;				addLast: errorChange].	errorChangeList notNil		ifTrue: [[errorChangeList closeAndUnschedule] on: Error do: [:ex | ]].	((errorChangeList := I18nPatchChangeList new)		listName: 'I18n Errors'		changes: errorsAndExplanations		removed: #()) open</body><body package="I18n" selector="report:while:">report: collectBlock while: actionBlock	recollectionBlock := collectBlock.	actionBlock ensure: [recollectionBlock := nil]</body><body package="I18n" selector="reportErrors">reportErrors	(allErrors := OrderedCollection new)		addAll: self reportTranslationErrors;		addAll: self reportInverseTranslationErrors;		addAll: self reportSyntaxErrors;		addAll: self reportNoCatalogErrors;		addAll: self reportIllegalKeyErrors;		addAll: self reportTooLongKeyErrors.	allErrors isEmpty		ifTrue: 			[^Transcript				cr;				show: #NoErrorsFound &lt;&lt; #I18nTool &gt;&gt; 'No Errors Found!'].	self openErrorChangeList.	self openErrorBrowser</body><body package="I18n" selector="reportIllegalKeyErrors">reportIllegalKeyErrors	| errors |	errors := Set new.	badKeyErrorLog do:		[:tuple| | dict key relatedChanges errorText |		dict := translatedMap at: (tuple at: 2).		key := tuple first.		relatedChanges := (dict at: key) value.		errorText :=  'Illegal Key: ', key storeString.		relatedChanges do:			[:errorChange|			self addExplanation: errorText forError: errorChange.			errorChange addRelatedChanges: relatedChanges.			errors add: errorChange]].	^errors</body><body package="I18n" selector="reportInverseTranslationErrors">reportInverseTranslationErrors	| errors |	errors := Set new.	inversionErrorLog do:		[:tuple| | dict default relatedChanges errorText |		dict := inverseTranslatedMap at: (tuple at: 2).		default := tuple last.		relatedChanges := (dict at: default) value.		errorText := (self keysFor: tuple fromChanges: relatedChanges)							inject: (#BadInverse &lt;&lt; #I18nTool &gt;&gt; 'Bad Inverse: ') asString,									default storeString,									' ', (tuple at: 2) storeString							into: [:text :key|								text, ' ', key storeString].		relatedChanges do:			[:errorChange|			self addExplanation: errorText forError: errorChange.			errorChange addRelatedChanges: relatedChanges.			errors add: errorChange]].	^errors</body><body package="I18n" selector="reportNoCatalogErrors">reportNoCatalogErrors	| errors |	errors := Set new.	noCatalogErrorLog do:		[:tuple| | dict key relatedChanges errorText |		dict := translatedMap at: (tuple at: 2).		key := tuple first.		relatedChanges := (dict at: key) value.		errorText := (self defaultsFor: tuple fromChanges: relatedChanges)							inject: 'No Catalog: ', key storeString, ' &gt;&gt;'							into: [:text :default|								text, ' ', default storeString].		relatedChanges do:			[:errorChange|			self addExplanation: errorText forError: errorChange.			errorChange addRelatedChanges: relatedChanges.			errors add: errorChange]].	^errors</body><body package="I18n" selector="reportSyntaxErrors">reportSyntaxErrors	syntaxErrorLog do: [:change| self addExplanation: 'Syntax Error' forError: change].	^syntaxErrorLog</body><body package="I18n" selector="reportTooLongKeyErrors">reportTooLongKeyErrors	| errors |	errors := Set new.	longKeyErrorLog do:		[:tuple| | dict key relatedChanges errorText |		dict := translatedMap at: (tuple at: 2).		key := tuple first.		relatedChanges := (dict at: key) value.		errorText :=  'Too Long Key: ', key storeString.		relatedChanges do:			[:errorChange|			self addExplanation: errorText forError: errorChange.			errorChange addRelatedChanges: relatedChanges.			errors add: errorChange]].	^errors</body><body package="I18n" selector="reportTranslationErrors">reportTranslationErrors	| errors |	errors := Set new.	translationErrorLog do:		[:tuple| | dict key relatedChanges errorText |		dict := translatedMap at: (tuple at: 2).		key := tuple first.		relatedChanges := (dict at: key) value.		errorText := (self defaultsFor: tuple fromChanges: relatedChanges)							inject: (#KeyCollision &lt;&lt; #I18nTool &gt;&gt; 'Key Collision: ') asString,									key storeString,									' ', (tuple at: 2) storeString							into: [:text :default|								text, ' ', default storeString].		relatedChanges do:			[:errorChange|			self addExplanation: errorText forError: errorChange.			errorChange addRelatedChanges: relatedChanges.			errors add: errorChange]].	^errors</body><body package="I18n" selector="sortChanges:">sortChanges: aCollectionOfChanges	^aCollectionOfChanges asSortedCollection:		[:a :b| | fa fb sf |		fa := a file.		fb := b file.		fa = fb			ifTrue: [a checkingName &lt; b checkingName]			ifFalse:				[sf := SourceFileManager default fileAt: 1.				fa = sf				or: [fb ~= sf				and: [fa displayString &lt; fb displayString]]]]</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>logging</category><body package="I18n" selector="collectKey:catalog:default:">collectKey: key catalog: catalog default: default	| catalogKey translated translation inverted inverse |	catalogKey := catalog isNil ifTrue: [#'the null catalog'] ifFalse: [catalog].	recollectionBlock notNil ifTrue:		[^recollectionBlock value: key value: catalogKey value: default].	translated := translatedMap at: catalogKey ifAbsentPut: [Dictionary new].	translation := translated at: key ifAbsentPut: [default -&gt; Set new].	translation value add: currentChange.	translation key ~= default ifTrue:		[self logConflictingTranslationKey: key catalog: catalogKey default: default].	inverted := inverseTranslatedMap at: catalogKey ifAbsentPut: [Dictionary new].	inverse := inverted at: default ifAbsentPut: [key -&gt; Set new].	inverse value add: currentChange.	inverse key ~= key ifTrue:		[self logBadInverseKey: key catalog: catalogKey default: default].	catalog isNil ifTrue:		[self logNoCatalogKey: key default: default].	(self isLegalKey: key) ifFalse:		[self logIllegalTranslationKey: key catalog: catalogKey default: default].	(self isTooLongKey: key) ifTrue:[self logTooLongKey: key catalog: catalogKey default: default].</body><body package="I18n" selector="isLegalKey:">isLegalKey: aSymbol	^aSymbol precedence = 1</body><body package="I18n" selector="isTooLongKey:">isTooLongKey: aSymbol	^aSymbol size &gt; 53</body><body package="I18n" selector="logBadInverseKey:catalog:default:">logBadInverseKey: key catalog: catalog default: default 	Transcript cr; tab; nextPutAll: ((#DuplicateKeyIn1s &lt;&lt; #I18nTool &gt;&gt; 'Duplicate Key in &lt;1s&gt;') expandMacrosWith: currentChange checkingName); flush.	inversionErrorLog add: (Array			with: key			with: catalog			with: default)</body><body package="I18n" selector="logConflictingTranslationKey:catalog:default:">logConflictingTranslationKey: key catalog: catalog default: default 	Transcript		cr;		tab;		nextPutAll: ((#KeyCollisionIn1s &lt;&lt; #I18nTool &gt;&gt; 'Key Collision in &lt;1s&gt;') 					expandMacrosWith: currentChange checkingName);		flush.	translationErrorLog add: (Array 				with: key				with: catalog				with: default)</body><body package="I18n" selector="logIllegalTranslationKey:catalog:default:">logIllegalTranslationKey: key catalog: catalog default: default 	Transcript		cr;		tab;		nextPutAll: ((#KeyCollisionIn1s &lt;&lt; #I18nTool &gt;&gt; 'Key Collision in &lt;1s&gt;') 					expandMacrosWith: currentChange checkingName);		flush.	badKeyErrorLog add: (Array 				with: key				with: catalog				with: default)</body><body package="I18n" selector="logNoCatalogKey:default:">logNoCatalogKey: key default: default 	Transcript		cr;		tab;		nextPutAll: ((#NoCatalogIn1s &lt;&lt; #I18nTool &gt;&gt; 'No Catalog in &lt;1s&gt;') 					expandMacrosWith: currentChange checkingName);		flush.	noCatalogErrorLog add: (Array 				with: key				with: #'the null catalog'				with: default)</body><body package="I18n" selector="logSyntaxError">logSyntaxError	Transcript		cr;		tab;		nextPutAll: ((#SyntaxErrorIn1s &lt;&lt; #I18nTool &gt;&gt; 'Syntax Error in &lt;1s&gt;') 					expandMacrosWith: currentChange checkingName);		flush.	syntaxErrorLog add: currentChange</body><body package="I18n" selector="logTooLongKey:catalog:default:">logTooLongKey: key catalog: catalog default: default	Transcript		cr;		tab;		nextPutAll: ((#KeyTooLong &lt;&lt; #I18nTool &gt;&gt; 'Key Too Long in &lt;1s&gt;') 					expandMacrosWith: currentChange checkingName);		flush.	longKeyErrorLog add: (Array 				with: key				with: catalog				with: default)</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>public access</category><body package="I18n" selector="cachedFileChanges">cachedFileChanges	^cachedFileChanges</body><body package="I18n" selector="canScanCachedFileChanges">canScanCachedFileChanges	^cachedFileChanges notEmpty</body><body package="I18n" selector="canWriteCatalogs">canWriteCatalogs	^translatedMap anySatisfy: [:subDict| subDict notEmpty]</body><body package="I18n" selector="catalogsDirectory">catalogsDirectory	^catalogsDirectory asString</body><body package="I18n" selector="createCatalogs">createCatalogs	"Scan sources and parcels parsing methods as we go, collecting all messages into result"	"self new createCatalogs"	files isEmpty ifTrue: [self computeFileSet].	self scanFilesForUserMessages.	self reportErrors.	self writeCatalogs</body><body package="I18n" selector="files:">files: aCollectionOfFilenames	files := aCollectionOfFilenames collect: [:ea| ea asLogicalFileSpecification]</body><body package="I18n" selector="nextPatchFileDirectory">nextPatchFileDirectory	| npfd index value |	(npfd := self patchesDirectory) isEmpty ifTrue: [^nil].	index := npfd size.	[(npfd at: index) isDigit and: [index &gt; 0]]		whileTrue:			[index := index - 1].	index = npfd size ifTrue: [^nil].	value := Integer readFrom: (ReadStream on: npfd from: index + 1 to: npfd size).	^(npfd copyFrom: 1 to: index), (value + 1) printString</body><body package="I18n" selector="resetCachedFileChanges">resetCachedFileChanges	cachedFileChanges := OrderedCollection new: cachedFileChanges basicSize</body><body package="I18n" selector="scanCachedChanges">scanCachedChanges	self scanCachedChangesForUserMessages.	self reportErrors</body><body package="I18n" selector="scanCachedChangesForUserMessages">scanCachedChangesForUserMessages	| fileName |	self resetForScan.	fileName := nil.	cachedFileChanges do: 			[:aChange | 			aChange file ifNotNil:[:file | fileName ~= file fileName 				ifTrue: 					[fileName :=  file fileName.					self currentFileToPatch: fileName.					Transcript						cr;						nextPutAll: (#ScanningCacheFor1s &lt;&lt; #I18nTool &gt;&gt; 'Scanning cache for &lt;1s&gt;' 									expandMacrosWith: fileName asString);						flush]].			self parsePatchableChange: aChange]</body><body package="I18n" selector="scanFiles">scanFiles	self resetCachedFileChanges.	self computeFileSet.	[self scanFilesForUserMessages] ifCurtailed: [self resetCachedFileChanges].	self reportErrors</body><body package="I18n" selector="scanFilesForUserMessages">scanFilesForUserMessages	self resetForScan.	files do: 			[:fileName | 			| fs |			self currentFileToPatch: fileName.			(fs := (fileName withEncoding: #Source) readStream) lineEndTransparent.						[Transcript				cr;				nextPutAll: ((#Scanning1s &lt;&lt; #I18nTool &gt;&gt; 'Scanning &lt;1s&gt;') expandMacrosWith: fileName asString);				flush.			self scanStreamForUserMessages: fs] 					ensure: [fs close]]</body><body package="I18n" selector="sourceFileTree">sourceFileTree	^fileRootDirectory asString</body><body package="I18n" selector="sourceFileTree:">sourceFileTree: str	fileRootDirectory := str asLogicalFileSpecification.	self resetForScan.	self changed: #sourceFileTree</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>file scanning</category><body package="I18n" selector="computeFileSet">computeFileSet	| directories matches |	matches := OrderedCollection new: 256.	matches 		add: ((fileRootDirectory construct: 'image') construct: 'visual.sou').	directories := OrderedCollection with: fileRootDirectory.	[directories notEmpty] whileTrue: 			[(directories removeFirst filenamesMatching: '*') do: 					[:fn | 					fn isDirectory 						ifTrue: 							[(directoriesToIgnore includes: fn tail) ifFalse: [directories addLast: fn]]						ifFalse: 							[(parcelsToIgnore 								anySatisfy: [:filenameMatchString | filenameMatchString match: fn tail]) 									ifFalse: [('*.pst' match: fn tail) ifTrue: [matches add: fn]]]]].	files := matches</body><body package="I18n" selector="currentFileToPatch:">currentFileToPatch: fileName	| patchFile |	patchFile := self existingPatchFileForFileName: fileName.	(currentPatchFilename ~= patchFile	 and: [currentPatches notEmpty]) ifTrue:		[self processRemainingPatches].	currentPatchFilename := patchFile.	currentPatches := Dictionary new.	self scanPatchFile.</body><body package="I18n" selector="directoriesToIgnore">directoriesToIgnore	^directoriesToIgnore</body><body package="I18n" selector="directoriesToIgnore:">directoriesToIgnore: aCollection	directoriesToIgnore := aCollection</body><body package="I18n" selector="existingPatchFileForFileName:">existingPatchFileForFileName: fileName	| patchFilename |	patchFilename := self patchFileForFileName: fileName.	^patchFilename exists ifTrue:		[patchFilename]</body><body package="I18n" selector="ignoreExtras">ignoreExtras	^directoriesToIgnore notEmpty</body><body package="I18n" selector="ignoreExtras:">ignoreExtras: aBoolean	directoriesToIgnore := aBoolean							ifTrue: [#('examples' 'contributed' 'obsolete' 'preview')]							ifFalse: [#()].</body><body package="I18n" selector="mightContainI18nConstruct:">mightContainI18nConstruct: aChange 	| i text |	^aChange isDefinition	 and: [(#(#'method definition' #'shared variable definition') includes: aChange type)	 and: [((text := aChange text) indexOfSubCollection: 'UserMessage' startingAt: 1) &gt; 0			or: [((i := text indexOf: $&lt; ifAbsent: 0) &gt; 0 "Might contain &lt;&lt; or a pragma"				and: [(text indexOfSubCollection: '&lt;&lt;' startingAt: i) &gt; 0						or: [(text indexOf: $&gt; ifAbsent: 0) &gt; i "make sure pragma might contain a literal array"							and: [(text indexOfSubCollection: '#(' startingAt: i) &gt; i]]]) 			or: [(i := text indexOf: $&gt; ifAbsent: 0) &gt; 0 				 and: [(text indexOfSubCollection: '&gt;&gt;' startingAt: i) &gt; 0]]]]]</body><body package="I18n" selector="oldComputeFileSet">oldComputeFileSet	| dirs |	dirs := Set new.	files := OrderedCollection new.	Parcel withFileCachesDo: 			[Parcel searchPathModel value do: 					[:dirName | 					Parcel 						cachedParcelFileInfoIn: dirName						for: nil						do: 							[:info :fileName | 							(info at: #parcel ifAbsent: nil) notNil 								ifTrue: [dirs add: fileName directory]]]].	(dirs asSortedCollection: [:f1 :f2 | f1 asString &lt;= f2 asString]) do: 			[:dirName | 			(dirName componentStrings indexOfSubCollection: #('goodies') startingAt: 1) 				= 0 ifTrue: [files addAll: (dirName filenamesMatching: '*.pst')]].	files addFirst: (SourceFileManager default nameAt: 1)</body><body package="I18n" selector="parcelsToIgnore:">parcelsToIgnore: aCollection 	parcelsToIgnore := aCollection</body><body package="I18n" selector="parseChange:">parseChange: aChange 	| parse noPattern text |	self map: Dictionary new.	all := Dictionary new.	text := (noPattern := #'shared variable definition' == aChange type)				ifTrue: [aChange initializerText]				ifFalse: [aChange text].	parse := Parser new					parse: text readStream					class: Object					environment: Smalltalk					noPattern: noPattern					context: nil					notifying: SilentCompilerErrorHandler new					ifFail: [^nil].	parse notNil ifTrue: [self doNode: parse]</body><body package="I18n" selector="parsePatchableChange:">parsePatchableChange: aChange 	| patchOrOriginal |	patchOrOriginal := currentPatches removeKey: aChange checkingName ifAbsent: [aChange].	self parseChange: (currentChange := patchOrOriginal)</body><body package="I18n" selector="patchFileForFileName:">patchFileForFileName: fileName	^patchDirectory construct: (fileName tail									copyReplaceAll: fileName extension									with: '.st')</body><body package="I18n" selector="processRemainingPatches">processRemainingPatches	| remainingChanges |	remainingChanges := self sortChanges: currentPatches values.	Transcript		cr;		nextPutAll: ((#ScanningRemainingPatchesIn1s &lt;&lt; #I18nTool &gt;&gt; 'Scanning remaining patches in &lt;1s&gt;') 					expandMacrosWith: remainingChanges first fileName asString);		flush.	remainingChanges do: [:aChange | self parsePatchableChange: aChange]</body><body package="I18n" selector="scanPatchFile">scanPatchFile	| fs |	currentPatchFilename isNil ifTrue: [^self].	fs := (currentPatchFilename withEncoding: #Source) readStream.	[fs lineEndTransparent.	I18nScanner new		scanFile: fs		do: [:aChange |			(aChange isDefinition			and: [(#(#'method definition' #'shared variable definition') includes: aChange type)])				ifTrue: 					[currentPatches at: aChange checkingName put: aChange asI18nChange]]]		ensure: [fs close]</body><body package="I18n" selector="scanStreamForUserMessages:">scanStreamForUserMessages: fs 	I18nScanner new		scanFile: fs		do: [:aChange | 			(self mightContainI18nConstruct: aChange) ifTrue: 				[self parsePatchableChange: (cachedFileChanges addLast: aChange asI18nChange)]]</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>catalog writing</category><body package="I18n" selector="getDirectoryIfFail:">getDirectoryIfFail: failBlock	| dirName directory |	(dirName := CatalogDirectoryRequest raiseSignal)		ifNil: [^failBlock value].	directory := dirName asFilename.	directory exists ifFalse:		[[directory makeDirectory]			on: Error			do: [:ex| Dialog warn: ex errorString.					^failBlock value].		^directory].	directory isDirectory ifFalse:		[self error: ((#_1sExistsButIsNotADirectory &lt;&lt; #I18nTool &gt;&gt; '&lt;1s&gt; exists but is not a directory') expandMacrosWith: dirName).		 ^failBlock value].	directory directoryContents isEmpty ifTrue:		[^directory].	(Dialog confirm:  ((#_1sIsNotEmptyNPLesNOKToProceed &lt;&lt; #I18nTool &gt;&gt; '&lt;1s&gt; is not empty.&lt;n&gt;Proceeding will delete all lbl and idx files.&lt;n&gt;OK to proceed?')						expandMacrosWith: dirName)) ifTrue:		[^directory].	^failBlock value</body><body package="I18n" selector="writeCatalog:named:baseFilename:">writeCatalog: aDictionary named: cat baseFilename: catName	| file |	Transcript cr; nextPutAll: ((#writingCatalog1s &lt;&lt; #I18nTool &gt;&gt; 'writing catalog &lt;1s&gt;') expandMacrosWith: cat); flush.	file := ((catName, '.lbl') asFilename withEncoding: #UTF_8) writeStream.	[file lineEndTransparent.	file		nextPutAll: 'encoding: #UTF_8';		cr;		nextPutAll: 'catalog: ', cat asSymbol storeString;		cr; cr; cr.	aDictionary keys asSortedCollection do:		[:key |		((self isLegalKey: key) and:[(self isTooLongKey: key) not])			ifTrue:				[file nextPutAll: ('&lt;1s&gt; = &lt;2p&gt;'										expandMacrosWith: key asString										with: (aDictionary at: key) key); cr]			ifFalse:				[Transcript cr; tab; nextPutAll: ((#IllegalKey &lt;&lt; #I18nTool &gt;&gt; 'Illegal key &lt;1s&gt; not written') expandMacrosWith: key); flush]]]			ensure: [file close].	IndexedFileMessageCatalog compileCatalogIndexFor: catName</body><body package="I18n" selector="writeCatalogs">writeCatalogs	| directory |	directory := self getDirectoryIfFail: [^self].	(directory filesMatching: '*.lbl'),	(directory filesMatching: '*.idx') do:		[:fileName|		fileName asFilename delete].	translatedMap keys asSortedCollection do:		[:catName|		Cursor write showWhile:			[self				writeCatalog: (translatedMap at: catName)				named: catName				baseFilename: (directory constructString: catName)]]</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>private</category><body package="I18n" selector="testLiteralForString:">testLiteralForString: lit	| found |	lit class == Array		ifTrue: 			[(self isEncodedUserMessage: lit) ifTrue: [^false].			found := false.			1 to: lit size				do: [:i | found := found | (self testLiteralForString: (lit at: i))].			^found].	lit isString ifFalse: [^false].	^lit isSymbol		ifTrue: [false]		ifFalse: 			[all == nil				ifFalse: 					[(all at: lit ifAbsentPut: [OrderedCollection new])						add: (Array with: nil with: self literalType).					(stringMap at: lit ifAbsentPut: [Set new]) add: currentChange].			true]</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>enumerating</category><body package="I18n" selector="doMessage:receiver:selector:arguments:">doMessage: aNode receiver: rcvr selector: sel arguments: args 	(#(#&lt;&lt; #&gt;&gt;) includes: sel) 		ifTrue: [self testForUserMessageConstruction: aNode]		ifFalse: 			[(self 				isProgrammaticUserMessageReceiver: rcvr				selector: sel				arguments: args) 					ifTrue: 						[self 							collectKey: (args at: 2) value							catalog: args last value							default: args first value]					ifFalse: 						[self doNode: rcvr.						self doNodes: args]]</body><body package="I18n" selector="handleLiteral:value:">handleLiteral: aNode value: lit	lit class == Array		ifTrue: 			[(self isEncodedUserMessage: lit) ifFalse: [self doNodes: aNode nodes].			^self].	lit isString not ifTrue: [^self].	lit isSymbol ifTrue: [^self].	(all at: lit ifAbsentPut: [OrderedCollection new])		add: (Array with: aNode sourcePosition with: self literalType).	(stringMap at: lit ifAbsentPut: [Set new]) add: currentChange</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>accessing</category><body package="I18n" selector="errorChangeList:">errorChangeList: anI18nPatchChangeList	errorChangeList := anI18nPatchChangeList</body><body package="I18n" selector="myClass">myClass	^currentChange className</body><body package="I18n" selector="selector">selector	^currentChange selector</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>testing</category><body package="I18n" selector="hasModifications">hasModifications	^errorChangeList notNil and: [errorChangeList hasModifications]</body></methods><methods><class-id>I18n.I18nCatalogWriterFromSource</class-id> <category>instance initialization</category><body package="I18n" selector="initialize">initialize	super initialize.	files := #().	fileRootDirectory := '$(VISUALWORKS)' asLogicalFileSpecification.	patchDirectory := 'i18n-patches0' asLogicalFileSpecification.	catalogsDirectory := 'catalogs' asLogicalFileSpecification.	self ignoreExtras: true.	parcelsToIgnore := #().	cachedFileChanges := OrderedCollection new: 256.	self resetForScan</body><body package="I18n" selector="resetForScan">resetForScan	translatedMap := Dictionary new: translatedMap basicSize.	inverseTranslatedMap := Dictionary new: inverseTranslatedMap basicSize.	currentChange := nil.	currentPatchFilename := nil.	currentPatches := Dictionary new: currentPatches basicSize.	translationErrorLog := Set new.	inversionErrorLog := Set new.	syntaxErrorLog := Set new.	noCatalogErrorLog := Set new.	badKeyErrorLog := Set new.	longKeyErrorLog := Set new.	allErrors := Set new.	recollectionBlock := nil</body></methods><methods><class-id>Kernel.I18nScanner</class-id> <category>scanning</category><body package="I18n" selector="scanFile:do:">scanFile: file do: aBlock	[super scanFile: file do: aBlock] on: MalformedSignal		do: 			[:ex |			"Ignore malformed errors caused by missing endtags			 in changes files"			ex getSignal = BadCharacterSignal				ifTrue: 					[Transcript						cr;						show: #errBadCharacter &lt;&lt; #dialogs &gt;&gt; 'Bad character'.					ex resume].			(file size = file position or: [file position = 1]) ifTrue: [ex return].			ex pass]</body><body package="I18n" selector="scan_methods:">scan_methods: anElement	| class protocol bodies classObject selector attributes savedCurrentPosition m |	class := self getGlobalId: 'class-id' from: anElement.	classObject := (class includes: Character space)				ifTrue: 					[((class copyUpTo: Character space) asQualifiedReference valueOrDo: [])						class]				ifFalse: [class asQualifiedReference valueOrDo: []].	classObject isBehavior ifFalse: [classObject := Object].	protocol := self				getSymbol: 'category'				from: anElement				default: ClassOrganizer defaultProtocol.	bodies := anElement elementsNamed: 'body'.	savedCurrentPosition := currentPosition.	bodies do: 			[:elm |			attributes := Dictionary new.			elm attributes				do: [:attr | attributes at: attr tag type asSymbol put: attr value].			selector := classObject parserClass new parseSelector: elm characterData.			selector				ifNotNil: 					[currentPosition := self positionAt: elm.					self doChange: (m := (I18nMethodDefinitionChange new)										className: class;										selector: selector;										category: protocol;										attributes: attributes;										cachedText: elm characterData;										yourself).					m cachedText: nil].			self forgetPosition: elm].	currentPosition := savedCurrentPosition</body></methods><methods><class-id>I18n.CatalogAndKeyDialog</class-id> <category>aspects</category><body package="I18n" selector="catalog">catalog	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^catalog isNil		ifTrue:			[catalog := String new asValue]		ifFalse:			[catalog]</body><body package="I18n" selector="key">key	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^key isNil		ifTrue:			[key := String new asValue]		ifFalse:			[key]</body></methods><methods><class-id>I18n.MessageCatalogTool</class-id> <category>actions</category><body package="I18n" selector="update">update	Cursor wait showWhile:		[| catalogList cat |		catalogList := Set new.		Array allInstancesDo: [:a |			cat := self getCatalogFromSpec: a.			cat == nil ifFalse: [catalogList add: cat]].		Message allGeneralInstancesDo: [:m |			m arguments do: [:a |				cat := self getCatalogFromPragma: a.				cat == nil ifFalse: [catalogList add: cat]]].		(MethodCollector new referencesTo: #&lt;&lt;)			select do: [:md || i18n trans |				i18n := I18nEnumerator new.				i18n class: md implementingClass selector: md selector.				i18n map: Dictionary new.				i18n translated: (trans := Dictionary new)					inverse: Dictionary new.				i18n containsString: md method.				catalogList addAll: trans keys].		self catalogs list: catalogList asSortedCollection asList]</body><body package="I18n" selector="writeCatalog">writeCatalog	| catName file val |	Cursor wait showWhile: 			[| cat result inverse filter |			self catalogs selection == nil				ifTrue: 					[^Dialog warn: #NoCatalogHasBeenSelected &lt;&lt; #I18nTool &gt;&gt; 'No catalog has been selected'						for: self builder window].			cat := self catalogs selection.			result := Dictionary new.			result at: cat put: Dictionary new.			inverse := Dictionary new.			inverse at: cat put: Dictionary new.			CompiledMethod allGeneralInstancesDo: 					[:m |					m allLiteralsDo: 							[:a |							self								filterCatalog: cat								inArray: a								into: (result at: cat)								inverse: (inverse at: cat)]].			Message allGeneralInstancesDo: 					[:m |					m arguments do: 							[:a |							self								filterCatalog: cat								inPragma: a								into: (result at: cat)								inverse: (inverse at: cat)]].			filter := MethodCollector new.			filter := (filter referencesTo: cat) &amp; (filter referencesTo: #&lt;&lt;).			filter select do: 					[:md |					| i18n |					i18n := I18nEnumerator new.					i18n class: md implementingClass selector: md selector.					i18n map: Dictionary new.					i18n translated: result inverse: inverse.					i18n containsString: md method].			catName := Dialog requestFileName: #WhereDoYouWantToPutTheCatalogFile &lt;&lt; #I18nTool								&gt;&gt; 'Where do you want to put the catalog file?'						default: cat , '.lbl'.			(catName isEmpty or: ['*.lbl' match: catName])				ifFalse: 					[Dialog warn: #CatalogFileDoesNotHaveTheLblExtension &lt;&lt; #I18nTool								&gt;&gt; 'Catalog file does not have the .lbl extension'.					catName := ''].			catName isEmpty				ifFalse: 					[file := catName asFilename withEncoding: #UTF_8.					file := file writeStream.					file lineEndTransparent.										[file						nextPutAll: 'encoding: #UTF_8';						cr.					file						nextPutAll: 'catalog: ' , cat asSymbol storeString;						cr;						cr;						cr.					(result at: cat) keys asSortedCollection do: 							[:key |							val := (result at: cat) at: key.							file								nextPutAll: ('&lt;1s&gt; = &lt;2p&gt;' expandMacrosWith: key asString with: val);								cr							"file nextPutAll: key, ' = ', val asString storeString; cr"]]							ensure: [file close].					IndexedFileMessageCatalog compileCatalogIndexFor: (catName copyFrom: 1 to: catName size - 4)]]</body></methods><methods><class-id>I18n.MessageCatalogTool</class-id> <category>initialize</category><body package="I18n" selector="initialize">initialize	super initialize.	catalogs := SelectionInList new</body></methods><methods><class-id>I18n.MessageCatalogTool</class-id> <category>private</category><body package="I18n" selector="filterCatalog:inArray:into:inverse:">filterCatalog: cat inArray: anObject into: translated inverse: inverse	(anObject isMemberOf: Array) ifFalse: [^self].	self		filterCatalog: cat		inSpec: anObject		into: translated		inverse: inverse</body><body package="I18n" selector="filterCatalog:inPragma:into:inverse:">filterCatalog: cat inPragma: anArray into: translated inverse: inverse 	| key default |	(anArray isKindOf: Array) ifFalse: [^nil].	anArray size = 3 ifFalse: [^nil].	(anArray contains: [:i | i isString not]) ifTrue: [^nil].	(1 to: 3) do: [:i | i &lt; 3 = (anArray at: i) isSymbol ifFalse: [^nil]].	(anArray at: 2) = cat ifFalse: [^self].	key := anArray at: 1.	default := anArray at: 3.	I18nEnumerator 		map: key		to: default		translated: translated		inverse: inverse</body><body package="I18n" selector="filterCatalog:inSpec:into:inverse:">filterCatalog: cat inSpec: anArray into: translated inverse: inverse 	| index key default |	(anArray size = 5 or: [anArray size = 7]) ifFalse: [^nil].	(anArray first == #UserMessage or: 			[anArray first isBindingReference 				and: [(anArray first valueOrDo: []) == UserMessage]]) 		ifFalse: [^nil].	index := anArray indexOf: #catalogID:.	index = 0 ifTrue: [^nil].	(anArray at: index + 1) = cat ifFalse: [^self].	index := anArray indexOf: #key:.	index = 0 ifTrue: [^nil].	(key := anArray at: index + 1) isSymbol ifFalse: [^self].	index := anArray indexOf: #defaultString:.	index = 0 ifTrue: [^nil].	(default := anArray at: index + 1) isString ifFalse: [^self].	I18nEnumerator 		map: key		to: default		translated: translated		inverse: inverse</body><body package="I18n" selector="getCatalogFromPragma:">getCatalogFromPragma: anArray	(anArray isKindOf: Array) ifFalse: [^nil].	anArray size = 3 ifFalse: [^nil].	(anArray contains: [:i | i isString not]) ifTrue: [^nil].	(1 to: 3) do: [:i |		(i &lt; 3) = (anArray at: i) isSymbol ifFalse: [^nil]].	^anArray at: 2</body><body package="I18n" selector="getCatalogFromSpec:">getCatalogFromSpec: anArray	| index |	(anArray size = 5 or: [anArray size = 7]) ifFalse: [^nil].	(anArray first == #UserMessage			or: [anArray first isBindingReference			and: [(anArray first valueOrDo: []) == UserMessage]])		ifFalse: [^nil].	index := anArray indexOf: #catalogID:.	index = 0 ifTrue: [^nil].	^anArray at: index+1</body></methods><methods><class-id>I18n.MessageCatalogTool</class-id> <category>aspects</category><body package="I18n" selector="catalogs">catalogs	^catalogs</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>accessing</category><body package="I18n" selector="completeSourcePosition">completeSourcePosition	^completeSourcePosition == nil		ifTrue: [variable sourcePosition first to: self sourcePosition last]		ifFalse: [completeSourcePosition]</body></methods><methods><class-id>Kernel.Change</class-id> <category>testing</category><body package="I18n" selector="isRelatedTo:">isRelatedTo: aChange 	^self = aChange</body></methods><methods><class-id>Kernel.Change</class-id> <category>accessing</category><body package="I18n" selector="myDefinition">myDefinition	"Not applicable for all but class I18nErrorReportChange"	^nil</body></methods><methods><class-id>Kernel.ProgramNodeBuilder</class-id> <category>node creation-basic</category><body package="I18n" selector="newArrayLiteralValue:">newArrayLiteralValue: lit	^CompoundLiteralNode new value: lit</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>converting</category><body package="I18n" selector="asI18nChange">asI18nChange	^I18nClassDefinitionChange fromChange: self</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>accessing</category><body package="I18n" selector="initializerText">initializerText	^(otherParameters detect: [:asc | asc key == #initializer:] ifNone: []) value</body></methods><methods><class-id>Kernel.SimpleMessageNode</class-id> <category>accessing</category><body package="I18n" selector="completeSourcePosition">completeSourcePosition	^completeSourcePosition == nil		ifTrue: [receiver completeSourcePosition first to: self sourcePosition last]		ifFalse: [completeSourcePosition]</body></methods><methods><class-id>Tools.MethodCollector</class-id> <category>building queries</category><body package="I18n" selector="bundle:">bundle: aPundleOrItsName	"Answer a filter that answers methods in a Store pundle.	| mc |	mc := MethodCollector new.	mc browseSelect: (mc bundle: 'External').	mc browseSelect: (mc bundle: 'External')			&amp; (mc searchClassHierarchy: Collection).	"	^MethodFilterPundle new bundleName: (aPundleOrItsName isCharacters											ifTrue: [aPundleOrItsName]											ifFalse: [aPundleOrItsName name])</body><body package="I18n" selector="package:">package: aPundleOrItsName	"Answer a filter that answers methods in a Store pundle.	| mc |	mc := MethodCollector new.	mc browseSelect: (mc package: 'BOSS').	mc browseSelect: (mc package: 'BOSS')			&amp; (mc searchClassHierarchy: Collection).	"	^MethodFilterPundle new packageName: (aPundleOrItsName isCharacters											ifTrue: [aPundleOrItsName]											ifFalse: [aPundleOrItsName name])</body></methods><methods><class-id>Kernel.CascadeNode</class-id> <category>accessing</category><body package="I18n" selector="completeSourcePosition">completeSourcePosition	^completeSourcePosition == nil		ifTrue: [receiver completeSourcePosition first to: self sourcePosition last]		ifFalse: [completeSourcePosition]</body></methods><methods><class-id>Kernel.AnnotatedMethod</class-id> <category>accessing</category><body package="I18n" selector="attributeMessages:">attributeMessages: anArray	attributes := anArray == nil				ifFalse: 					[(anArray asArray collect: [:eachPragmaMessage | eachPragmaMessage asMessage])						collect: 							[:eachMessage |							Message selector: eachMessage selector								arguments: (self updateBindingsIn: eachMessage arguments)]]</body></methods><methods><class-id>Core.Message</class-id> <category>As yet unclassified</category><body package="I18n" selector="asMessage">asMessage	^self</body></methods><methods><class-id>Kernel.ProgramNodeEnumerator</class-id> <category>enumerating</category><body package="I18n" selector="doCompoundLiteral:value:">doCompoundLiteral: aNode value: lit	^self doLiteral: aNode value: lit</body></methods><methods><class-id>Kernel.MethodDefinitionChange</class-id> <category>converting</category><body package="I18n" selector="asI18nChange">asI18nChange	^I18nMethodDefinitionChange fromChange: self</body></methods><methods><class-id>I18n.I18nErrorBrowser class</class-id> <category>resources</category><body package="I18n" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Read Catalog Report(s)...' 							#value: #scanFilename ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save Patches' 							#enabled: false 							#value: #updatePatches 							#enablementSelector: #hasModifications ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MessageCatalogs_Writer 								#defaultString: 'Message Catalogs &amp;Writer' 								#catalogID: #I18nTool ) 							#value: #openCatalogWriter ) 						#(#{UI.MenuItem} 							#rawLabel: 'Exit' 							#value: #closeRequest ) ) #(2 1 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>I18n.I18nErrorBrowser class</class-id> <category>interface specs</category><body package="I18n" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #cascade #openType #advanced ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #ChangeBrowser 				#defaultString: 'I18n Error Browser' 				#catalogID: #I18nTool ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 440 405 890 853 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 20 0 -53 0.5 -5 1 ) 					#name: #List1 					#flags: 15 					#model: #changeList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateChangeList ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} -45 0.5 20 0 -4 1 -5 1 ) 					#name: #Subcanvas1 					#majorKey: #{Tools.I18nPatchChangeList} 					#minorKey: #windowSpec 					#clientKey: #changeView ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -50 0.5 5 0 -47 0.5 -2 1 ) 					#name: #ResizingSplitter2 					#flags: 8 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'List1 ' 					#belowWidgets: 'Subcanvas1 Label2' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Errors 						#defaultString: 'Errors' 						#catalogID: #I18nTool ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -45 0.5 0 0 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #MessageDefinitions 						#defaultString: 'Message Definitions' 						#catalogID: #I18nTool ) ) ) ) )</body></methods><methods><class-id>I18n.SystemSearchApp class</class-id> <category>interface specs</category><body package="I18n" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #SystemSearch #catalogID: #I18nTool #defaultString: 'System Search') 			#min: #(#{Core.Point} 482 302 ) 			#max: #(#{Core.Point} 482 302 ) 			#bounds: #(#{Graphics.Rectangle} 399 361 881 663 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 1 2 ) 					#model: #search 					#label: #(#{UserMessage} #key: #Search #catalogID: #I18nTool #defaultString: 'Search') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 2 0 ) 					#model: #select 					#label: #(#{UserMessage} #key: #All #catalogID: #I18nTool #defaultString: 'All') 					#select: #all ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.75 2 0 ) 					#model: #select 					#label: #(#{UserMessage} #key: #Any #catalogID: #I18nTool #defaultString: 'Any') 					#select: #any ) 				#(#{UI.DataSetSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 32 0 -1 1 -1 1 ) 					#flags: 4 					#model: #criteria 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#model: #'selected negated' 							#label: #(#{UserMessage} #key: #Not #catalogID: #I18nTool #defaultString: 'Not?') 							#labelIsImage: false 							#width: 40 							#rendererType: #CheckBox 							#editorType: #CheckBox 							#choices: #searchTypes 							#noScroll: true 							#formatString: '' ) 						#(#{UI.DataSetColumnSpec} 							#model: #'selected type' 							#label: #(#{UserMessage} #key: #SearchType #catalogID: #I18nTool #defaultString: 'Search type') 							#labelIsImage: false 							#width: 160 							#rendererType: #Text 							#editorType: #ComboBox 							#choices: #searchTypes 							#noScroll: true 							#formatString: '' ) 						#(#{UI.DataSetColumnSpec} 							#model: #'selected data' 							#label: #(#{UserMessage} #key: #SearchFor #catalogID: #I18nTool #defaultString: 'Search for') 							#labelIsImage: false 							#width: 280 							#editorType: #InputField 							#noScroll: false ) ) ) ) ) )</body></methods><methods><class-id>I18n.SystemSearchApp class</class-id> <category>resources</category><body package="I18n" selector="menuBar">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Search #catalogID: #I18nTool #defaultString: 'Search') 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #_New #catalogID: #I18nTool #defaultString: '&amp;New') 							#value: #newSearch ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #_Search #catalogID: #I18nTool #defaultString: '&amp;Search') 							#value: #search ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #E_xit #catalogID: #I18nTool #defaultString: 'E&amp;xit') 							#value: #closeRequest ) ) #(1 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Edit #catalogID: #I18nTool #defaultString: 'Edit') 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #_AddRestriction #catalogID: #I18nTool #defaultString: '&amp;Add restriction') 							#value: #addRestriction ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #_RemoveRestriction #catalogID: #I18nTool #defaultString: '&amp;Remove restriction') 							#nameKey: #remove 							#value: #removeRestriction ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #_Correct #catalogID: #I18nTool #defaultString: '&amp;Correct') 							#value: #correctData ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #_MatchWildcard #catalogID: #I18nTool #defaultString: '&amp;Match wildcard') 							#value: #matchWildcard ) ) #(4 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.I18nPatchChangeList class</class-id> <category>interface specs</category><body package="I18n" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadFilesDot 								#defaultString: '&amp;Read File(s)...' 								#catalogID: #menus ) 							#value: #fileIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadDifferentSourceFromFilesDot 								#defaultString: 'Read Different &amp;Source from File(s)...' 								#catalogID: #menus ) 							#value: #fileInSourceDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadDifferentCodeFromFilesDot 								#defaultString: 'Read Different &amp;Code from File(s)...' 								#catalogID: #menus ) 							#value: #fileInDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #WriteFileDot 								#defaultString: '&amp;Write File...' 								#catalogID: #menus ) 							#value: #fileOut 							#enablementSelector: #anyToFileOut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RecoverLastChanges 								#defaultString: 'Recover &amp;Last Changes' 								#catalogID: #menus ) 							#value: #recover ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayS_ystemChanges 								#defaultString: 'Display S&amp;ystem Changes' 								#catalogID: #menus ) 							#value: #getChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayAllSystemChanges 								#defaultString: 'Display &amp;All System Changes' 								#catalogID: #menus ) 							#value: #getAllChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Display_ParcelDot 								#defaultString: 'Display &amp;Parcel...' 								#catalogID: #menus ) 							#value: #getParcel ) ) #(1 2 1 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Replay 					#defaultString: '&amp;Replay' 					#catalogID: #menus ) 				#nameKey: #replay 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #doThis 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromTheTop 								#defaultString: 'All from the &amp;Top' 								#catalogID: #menus ) 							#value: #doAll 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromHereDown 								#defaultString: 'All from here &amp;Down' 								#catalogID: #menus ) 							#value: #doFromHere 							#enablementSelector: #hasSelection ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Re_move 					#defaultString: 'Re&amp;move' 					#catalogID: #menus ) 				#nameKey: #remove 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #removeItem 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #A_ll 								#defaultString: 'A&amp;ll' 								#catalogID: #menus ) 							#value: #removeAll 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllAbove 								#defaultString: 'All &amp;Above' 								#catalogID: #menus ) 							#value: #removeAllAbove 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllBelow 								#defaultString: 'All &amp;Below' 								#catalogID: #menus ) 							#value: #removeAllBelow 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExchangeRemoved 								#defaultString: 'E&amp;xchange Removed' 								#catalogID: #menus ) 							#value: #exchangeRemoved 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameCodeAsSystem 								#defaultString: 'Same &amp;Code as System' 								#catalogID: #menus ) 							#value: #removeSameAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSourceAsSystem 								#defaultString: 'Same &amp;Source as System' 								#catalogID: #menus ) 							#value: #removeSameSourceAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentCodeToSystem 								#defaultString: 'Different C&amp;ode to System' 								#catalogID: #menus ) 							#value: #removeConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentSourceToSystem 								#defaultString: 'Different So&amp;urce to System' 								#catalogID: #menus ) 							#value: #removeSourceConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CodeForClassesNotInSystem 								#defaultString: 'Code for Classes &amp;not in System' 								#catalogID: #menus ) 							#value: #removeClassesNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MethodsNotInSystem 								#defaultString: '&amp;Methods not in System' 								#catalogID: #menus ) 							#value: #removeMethodsNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OldVersions 								#defaultString: 'Old &amp;Versions' 								#catalogID: #menus ) 							#value: #removeOldVersions 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExactDuplicates 								#defaultString: 'Exact &amp;Duplicates' 								#catalogID: #menus ) 							#value: #removeDuplicates 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Con_flicts 								#defaultString: 'Con&amp;flicts' 								#catalogID: #menus ) 							#value: #removeConflictsInList 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangesWithTextDot 								#defaultString: 'Changes with &amp;Text ...' 								#catalogID: #menus ) 							#value: #removeChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(4 1 2 2 2 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #For_get 					#defaultString: 'For&amp;get' 					#catalogID: #menus ) 				#nameKey: #forget 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetSelection 								#defaultString: 'Forget &amp;Selection' 								#catalogID: #menus ) 							#value: #forgetSelection 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Forget_Marked 								#defaultString: 'Forget &amp;Marked' 								#catalogID: #menus ) 							#value: #forgetThese 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetAllMarked 								#defaultString: 'Forget &amp;All Marked' 								#catalogID: #menus ) 							#value: #forgetAll 							#enablementSelector: #hasRemovedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreSelection 								#defaultString: '&amp;Restore Selection' 								#catalogID: #menus ) 							#value: #restoreItem 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreAll 								#defaultString: 'R&amp;estore All' 								#catalogID: #menus ) 							#value: #restoreAll 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreChangesWithTextDot 								#defaultString: 'Restore Changes with &amp;Text...' 								#catalogID: #menus ) 							#value: #restoreChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Fi_nd 					#defaultString: 'Fi&amp;nd' 					#catalogID: #menus ) 				#nameKey: #find 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileDot 								#defaultString: '&amp;File ...' 								#catalogID: #menus ) 							#value: #findFile ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_TypeDot 								#defaultString: '&amp;Type ...' 								#catalogID: #menus ) 							#value: #findType ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassDot 								#defaultString: '&amp;Class ...' 								#catalogID: #menus ) 							#value: #findClass ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ProtocolDot 								#defaultString: '&amp;Protocol ...' 								#catalogID: #menus ) 							#value: #findProtocol ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectorDot 								#defaultString: '&amp;Selector ...' 								#catalogID: #menus ) 							#value: #findSelector ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnSelection 								#defaultString: 'Spa&amp;wn Selection' 								#catalogID: #menus ) 							#value: #spawnBrowserOnSelection 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Spawn_All 								#defaultString: 'Spawn &amp;All' 								#catalogID: #menus ) 							#value: #copyView 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnChangesWithTextDot 								#defaultString: 'Spawn Changes with &amp;Text ...' 								#catalogID: #menus ) 							#value: #spawnChangesContainingString 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectNextChangeWithTextDot 								#defaultString: 'Select &amp;Next Change with Text ...' 								#catalogID: #menus ) 							#value: #selectNextChangeContainingString 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassMatching 								#defaultString: 'Class &amp;Matching' 								#catalogID: #menus ) 							#nameKey: #classMatching 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #InstanceAndClass 											#defaultString: '&amp;Instance and Class' 											#catalogID: #menus ) 										#nameKey: #groupClassAndMetaclass 										#value: #groupClassAndMetaclass 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SelectedClassOnly 											#defaultString: 'Selected Class &amp;Only' 											#catalogID: #menus ) 										#nameKey: #ungroupClassAndMetaclass 										#value: #ungroupClassAndMetaclass 										#indication: true ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameFile 								#defaultString: 'Same File' 								#catalogID: #menus ) 							#nameKey: #filterByFile 							#value: #toggleFileFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameType 								#defaultString: 'Same Type' 								#catalogID: #menus ) 							#nameKey: #filterByType 							#value: #toggleTypeFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameClass 								#defaultString: 'Same Class' 								#catalogID: #menus ) 							#nameKey: #filterByClass 							#value: #toggleClassFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameProtocol 								#defaultString: 'Same Protocol' 								#catalogID: #menus ) 							#nameKey: #filterByProtocol 							#value: #toggleProtocolFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSelector 								#defaultString: 'Same Selector' 								#catalogID: #menus ) 							#nameKey: #filterBySelector 							#value: #toggleSelectorFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameChange 								#defaultString: 'Same Change' 								#catalogID: #menus ) 							#nameKey: #filterBySame 							#value: #toggleSameFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RelatedChange 								#defaultString: 'Related Change' 								#catalogID: #menus ) 							#nameKey: #filterByRelative							#value: #toggleRelatedFilter 							#indication: true ) ) #(5 4 1 6 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Conflicts 					#defaultString: '&amp;Conflicts' 					#catalogID: #menus ) 				#nameKey: #conflicts 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SaveConflictsAsDot 								#defaultString: '&amp;Save Conflicts As...' 								#catalogID: #menus ) 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_ConflictsWithSystemAsDot 								#defaultString: 'Save &amp;Conflicts with System As...' 								#catalogID: #menus ) 							#value: #checkWithSystem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveConflicts 								#defaultString: '&amp;Remove Conflicts' 								#catalogID: #menus ) 							#value: #removeConflictsInList ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveConflictsWithSystem 								#defaultString: 'Remove Conflicts &amp;with System' 								#catalogID: #menus ) 							#value: #removeConflictsWithSystem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddSystemConflicts 								#defaultString: '&amp;Add System Conflicts' 								#catalogID: #menus ) 							#value: #addSystemConflicts ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddOriginalVersions 								#defaultString: 'Add &amp;Original Versions' 								#catalogID: #menus ) 							#value: #addOriginals ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddToChangeSet 								#defaultString: 'A&amp;dd to Change Set' 								#catalogID: #menus ) 							#value: #addChangesToCurrentChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveFromChangeSet 								#defaultString: 'Remove &amp;from Change Set' 								#catalogID: #menus ) 							#value: #removeChangesFromCurrentChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BuildScriptToSystem 								#defaultString: '&amp;Build Script to System' 								#catalogID: #menus ) 							#value: #spawnConvergeScriptToSystem ) ) #(2 2 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show 					#defaultString: '&amp;Show' 					#catalogID: #menus ) 				#nameKey: #show 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowFile 								#defaultString: 'Show &amp;File' 								#catalogID: #menus ) 							#nameKey: #showFile 							#value: #toggleShowFile 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowProtocol 								#defaultString: 'Show &amp;Protocol' 								#catalogID: #menus ) 							#nameKey: #showProtocol 							#value: #toggleShowProtocol 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowConflicts 								#defaultString: 'Show &amp;Conflicts' 								#catalogID: #menus ) 							#nameKey: #showConflicts 							#value: #toggleShowConflicts 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Co_nflicts 								#defaultString: 'Co&amp;nflicts' 								#catalogID: #menus ) 							#nameKey: #showConflicts 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #VerticalView 											#defaultString: '&amp;Vertical View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsVertically 										#value: #viewConflictsVertically 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #HorizontalView 											#defaultString: '&amp;Horizontal View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsHorizontally 										#value: #viewConflictsHorizontally 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SourceDifferences 											#defaultString: '&amp;Source Differences' 											#catalogID: #menus ) 										#nameKey: #highlightSourceDifferences 										#value: #highlightSourceDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #CodeDifferences 											#defaultString: 'Co&amp;de Differences' 											#catalogID: #menus ) 										#nameKey: #highlightCodeDifferences 										#value: #highlightCodeDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #EmphasizeInList 											#defaultString: '&amp;Emphasize in List' 											#catalogID: #menus ) 										#nameKey: #toggleListEmphasis 										#value: #toggleListEmphasis ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #IndicateSameMethods 											#defaultString: '&amp;Indicate Same Methods' 											#catalogID: #menus ) 										#nameKey: #toggleTypesIncludeSame 										#value: #toggleTypesIncludeSame ) ) #(2 2 2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LineEndTreatment 								#defaultString: '&amp;Line End Treatment' 								#catalogID: #menus ) 							#nameKey: #lineEndTreatment 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #AsInFile 											#defaultString: '&amp;As in File' 											#catalogID: #menus ) 										#nameKey: #lineEndsRaw 										#value: #lineEndsRaw 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #C_onvertedToCRs 											#defaultString: 'C&amp;onverted to CRs' 											#catalogID: #menus ) 										#nameKey: #lineEndsTreated 										#value: #lineEndsTreated 										#indication: true ) ) #(2 ) nil ) ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ChangeList 								#defaultString: '&amp;Change List' 								#catalogID: #menus ) 							#value: #helpChangeList 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #C_hangesAndChangeSets 								#defaultString: 'C&amp;hanges and Change Sets' 								#catalogID: #menus ) 							#value: #helpChangesAndChangeSets ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(2 1 ) nil ) ) ) #(8 ) nil ) decodeAsLiteralArray</body><body package="I18n" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ChangeList #defaultString: 'Change List' #catalogID: #labels) 			#min: #(#{Core.Point} 300 400 ) 			#bounds: #(#{Graphics.Rectangle} 512 268 942 768 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -100 1 150 0 ) 					#name: #listView 					#model: #selectionInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#toggleRemoveForListController: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #changeListMenuHolder ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 0 ) 							#model: #fileFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #file #defaultString: 'file' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 25 ) 							#model: #changeTypeFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #type #defaultString: 'type' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 50 ) 							#model: #classNameFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #class #defaultString: 'class' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 75 ) 							#model: #selectorFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #selector #defaultString: 'selector' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 100 ) 							#model: #valuesFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #same #defaultString: 'same' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 125 ) 							#model: #relativesFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #related #defaultString: 'related' #catalogID: #labels) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -100 1 0 0 0 1 150 0 ) 						#name: #filters 						#flags: 8 ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 150 0 0 1 153 0 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 150 					#minBelowSize: 25 					#aboveWidgets: 'listView filters' 					#belowWidgets: 'textCanvas' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 153 0 0 1 0 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #standardText ) ) ) )</body></methods><methods><class-id>I18n.I18nEnumerator</class-id> <category>literal types</category><body package="I18n" selector="specTypeForLiteral:">specTypeForLiteral: aLiteral	&lt;literalType: #spec&gt;	^aLiteral class = Array and: [aLiteral size &gt; 0 and: [aLiteral first isBindingReference]]</body><body package="I18n" selector="stringTypeForLiteral:">stringTypeForLiteral: aLiteral	&lt;literalType: #string&gt;	^aLiteral isString</body></methods><methods><class-id>I18n.I18nEnumerator class</class-id> <category>searching</category><body package="I18n" selector="literalTypePragma">literalTypePragma	&lt;pragmas: #instance&gt;	^#(#literalType:)</body></methods><methods><class-id>I18n.MessageCatalogWriter class</class-id> <category>resources</category><body package="I18n" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Open 					#defaultString: 'Open' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ErrorBrowser 								#defaultString: 'Error Browser' 								#catalogID: #I18nTool ) 							#value: #openErrorBrowser ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangeList 								#defaultString: 'Change List' 								#catalogID: #I18nTool ) 							#value: #openErrorChangeList ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>I18n.MessageCatalogWriter class</class-id> <category>interface specs</category><body package="I18n" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #positionSystemDefault #openType #advanced ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #CatalogWriterFromSource 				#defaultString: 'Catalog Writer From Source Files' 				#catalogID: #I18nTool ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 483 355 907 667 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 208 64 400 96 ) 					#name: #patchesDirectory 					#model: #patchesDirectory 					#helpText: #patchesDirectoryHelp ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 208 17 400 49 ) 					#name: #sourceFileTree 					#model: #sourceFileTree 					#helpText: #sourceFileTreeHelp ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 25 22 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #SourceFileTree 						#defaultString: 'Source File Tree' 						#catalogID: #I18nTool ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 23 69 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #PatchesDirectory 						#defaultString: 'Patches Directory' 						#catalogID: #I18nTool ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 153 208 265 232 ) 					#name: #updatePatches 					#flags: 40 					#model: #updatePatches 					#helpText: #updatePatchesHelp 					#label: 					#(#{Kernel.UserMessage} 						#key: #UpdatePatches 						#defaultString: 'Update Patches' 						#catalogID: #I18nTool ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 290 208 402 232 ) 					#name: #writeCatalogs 					#model: #writeCatalogs 					#helpText: #writeCatalogsHelp 					#label: 					#(#{Kernel.UserMessage} 						#key: #WriteCatalogs 						#defaultString: 'Write Catalogs' 						#catalogID: #I18nTool ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 23 116 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #CatalogsDirectory 						#defaultString: 'Catalogs Directory' 						#catalogID: #I18nTool ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 208 111 400 143 ) 					#name: #catalogsDirectory 					#model: #catalogsDirectory 					#helpText: #catalogsDirectoryHelp ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.Rectangle} 16 244 128 276 ) 					#name: #scanCachedChanges 					#model: #scanCachedChanges 					#helpText: #scanCachedChangesHelp 					#label: 					#(#{Kernel.UserMessage} 						#key: #ScanCache 						#defaultString: 'Scan Cache' 						#catalogID: #I18nTool ) 					#isDefault: false 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 24 160 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #IgnoreExamplesGoodiesObsoletePreview 						#defaultString: 'Ignore examples, goodies, obsolete, preview?' 						#catalogID: #I18nTool ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 384 160 ) 					#name: #ignoreExtras 					#model: #ignoreExtras 					#helpText: #ignoreExtrasHelp ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.Rectangle} 16 204 128 236 ) 					#name: #scanFiles 					#model: #scanFiles 					#helpText: #scanFilesHelp 					#label: 					#(#{Kernel.UserMessage} 						#key: #ScanFiles 						#defaultString: 'Scan Files' 						#catalogID: #I18nTool ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>I18n.LiteralChooserUI</class-id> <category>tempates</category><body package="I18n" selector="pragmaTemplateFor:">pragmaTemplateFor: userMessage	&lt;templateType: #pragma&gt;	^userMessage catalogID isEmpty ifTrue: ['#(&lt;1p&gt; &lt;2p&gt;)'] ifFalse: ['#(&lt;1p&gt; &lt;3p&gt; &lt;2p&gt;)']</body><body package="I18n" selector="specTemplateFor:">specTemplateFor: userMessage	&lt;templateType: #spec&gt;	^userMessage catalogID isEmpty		ifTrue: ['#(#{UserMessage} #key: &lt;1p&gt; #defaultString: &lt;2p&gt;)']		ifFalse: ['#(#{UserMessage} #key: &lt;1p&gt; #catalogID: &lt;3p&gt; #defaultString: &lt;2p&gt;)']</body><body package="I18n" selector="stringTemplateFor:">stringTemplateFor: userMessage	&lt;templateType: #string&gt;	^userMessage catalogID isEmpty ifTrue: ['(&lt;1p&gt; &gt;&gt; &lt;2p&gt;)'] ifFalse: ['(&lt;1p&gt; %&lt;%&lt; &lt;3p&gt; &gt;&gt; &lt;2p&gt;)']</body></methods><methods><class-id>I18n.LiteralChooserUI class</class-id> <category>resources</category><body package="I18n" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Forget #catalogID: #I18nTool #defaultString: 'Forget') 				#nameKey: #forgetLiterals 				#value: #forgetLiterals ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #AutoEdit #catalogID: #I18nTool #defaultString: 'AutoEdit') 				#nameKey: #autoEdit 				#value: #autoEdit ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #SearchAgain #catalogID: #I18nTool #defaultString: 'Search again') 				#nameKey: #searchAgain 				#value: #searchAgain ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="I18n" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #File #catalogID: #I18nTool #defaultString: 'File') 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #E_xit #catalogID: #I18nTool #defaultString: 'E&amp;xit') 							#value: #closeRequest ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Literals #catalogID: #I18nTool #defaultString: 'Literals') 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Forget 								#defaultString: 'Forget' 								#catalogID: #I18nTool ) 							#nameKey: #forgetLiterals 							#value: #forgetLiterals ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AutoEdit 								#defaultString: 'AutoEdit' 								#catalogID: #I18nTool ) 							#nameKey: #autoEdit 							#value: #autoEdit ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SearchAgain 								#defaultString: 'Search again' 								#catalogID: #I18nTool ) 							#nameKey: #searchAgain 							#value: #searchAgain ) ) #(3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="I18n" selector="templatePragmas">templatePragmas	&lt;pragmas: #instance&gt;	^#(templateType:)</body></methods><methods><class-id>I18n.LiteralChooserUI class</class-id> <category>interface specs</category><body package="I18n" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #LiteralBrowser 				#defaultString: 'Literal-Browser' 				#catalogID: #I18nTool ) 			#bounds: #(#{Graphics.Rectangle} 713 271 1268 751 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 0 0.3 -2 1 ) 					#name: #stringList 					#model: #stringList 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.3 2 0 8 0.3 -2 1 ) 					#name: #Splitter1 					#flags: 8 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#stringList' 					#belowWidgets: '#RBHolder' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.3 2 0 0 1 0 1 ) 					#name: #RBHolder 					#majorKey: #{Refactory.Browser.RefactoringBrowser} 					#minorKey: #windowSpec 					#clientKey: #dependentRB ) ) ) )</body></methods><methods><class-id>I18n.CatalogAndKeyDialog class</class-id> <category>interface specs</category><body package="I18n" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #SelectCatalogAndKey #catalogID: #I18nTool #defaultString: 'Select catalog and key') 			#bounds: #(#{Graphics.Rectangle} 724 447 1064 686 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Core.Point} 29 27 ) 					#name: #original 					#label: #original ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 29 84 ) 					#name: #Label1 					#label: #(#{UserMessage} #key: #Catalog #catalogID: #I18nTool #defaultString: 'Catalog:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 29 141 ) 					#name: #Label2 					#label: #(#{UserMessage} #key: #Key #catalogID: #I18nTool #defaultString: 'Key:') ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 101 83 201 106 ) 					#name: #Eingabefeld1 					#model: #catalog ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 101 138 312 164 ) 					#name: #Eingabefeld2 					#model: #key ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 101 191 182 214 ) 					#name: #Aktionsknopf1 					#model: #accept 					#label: #(#{UserMessage} #key: #OK #catalogID: #I18nTool #defaultString: 'OK') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 231 191 312 214 ) 					#name: #Aktionsknopf2 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #I18nTool #defaultString: 'Cancel') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>I18n.MessageCatalogTool class</class-id> <category>interface specs</category><body package="I18n" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #MessageCatalogs #catalogID: #I18nTool #defaultString: 'Message Catalogs') 			#bounds: #(#{Graphics.Rectangle} 412 284 612 484 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 1 -1 1 ) 					#model: #catalogs 					#menu: #catalogsMenu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>I18n.MessageCatalogTool class</class-id> <category>resources</category><body package="I18n" selector="catalogsMenu">catalogsMenu	"MenuEditor new openOnClass: self andSelector: #catalogsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #WriteCatalog #catalogID: #I18nTool #defaultString: 'Write Catalog') 				#nameKey: #writeCatalog 				#value: #writeCatalog ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Update #catalogID: #I18nTool #defaultString: 'Update') 				#value: #update ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="I18n" selector="menuBar">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Catalogs #catalogID: #I18nTool #defaultString: 'Catalogs') 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #WriteCatalog #catalogID: #I18nTool #defaultString: 'Write Catalog') 							#nameKey: #writeCatalog 							#value: #writeCatalog ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #_Update #catalogID: #I18nTool #defaultString: '&amp;Update') 							#value: #update ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #E_xit #catalogID: #I18nTool #defaultString: 'E&amp;xit') 							#value: #closeRequest ) ) #(2 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="I18n" selector="browseMethods">browseMethods	"Open a new SystemSearchApp."	&lt;menuItem: #(#_Not_Iternationalied_Methods #I18nTool '&amp;Methods containing not internationalized strings')		icon: nil		nameKey: nil		menu: #(#menuBar browse)		position: 20.3&gt;	self openApplicationForClassNamed: #{I18n.SystemSearchApp}</body><body package="I18n" selector="checkMessageCatalogs">checkMessageCatalogs	"Open a new MessageCatalogTool."	&lt;menuItem: #(#_MessageCatalogs #I18nTool '&amp;Message Catalogs')		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 20.8&gt;	self openApplicationForClassNamed: #{I18n.MessageCatalogTool}</body><body package="I18n" selector="openCatalogErrorBrowser">openCatalogErrorBrowser	"Open a new Catalog Error Browser."	&lt;menuItem: #(#CatalogReport_Browser #I18nTool 'Catalog Report &amp;Browser')	icon: nil	nameKey: nil	menu: #(#menuBar #tools)	position: 20.9&gt;	self openApplicationForClassNamed: #{I18n.I18nErrorBrowser}</body><body package="I18n" selector="openMessageCatalogsWriter">openMessageCatalogsWriter	"Open a new MessageCatalogTool."	&lt;menuItem: #(#MessageCatalogs_Writer #I18nTool 'Message Catalogs &amp;Writer')		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 20.85&gt;	self openApplicationForClassNamed: #{I18n.MessageCatalogWriter}</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Message</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>AssignmentNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value leftArrow assignToArgOK </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>MethodCollector</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>browser interfaceWindow filter </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.RefactoringBrowser			</imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>LiteralNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SimpleMessageNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector arguments precedence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>Change</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCode manager name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ProgramNodeBuilder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>CascadeNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>ChangeList</name><environment>Tools</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><class><name>OtherChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>AnnotatedMethod</name><environment>Kernel</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Scanner</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source mark prevEnd hereChar token tokenType saveComments currentComment buffer typeTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>ClassDefinitionChange</name><environment>Kernel</environment><super>Kernel.ClassChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassName nameSpaceName classType otherParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>MethodDefinitionChange</name><environment>Kernel</environment><super>Kernel.MethodChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes methodSources </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ProgramNodeEnumerator</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class></st-source>