<?xml version="1.0"?><st-source><!-- Name: LinuxSymlinkSupportNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: Linux OS support for symlinks.Originally developed for use in the PackingListTool.DbIdentifier: bear73DbTrace: 146954PackageName: LinuxSymlinkSupportParcel: #('LinuxSymlinkSupport')ParcelName: LinuxSymlinkSupportPrintStringCache: (7.7 - 1,smichael)Version: 7.7 - 1Date: 10:54:51 AM August 7, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (aug09.1) of August 7, 2009 on August 7, 2009 at 10:54:51 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LinuxSymlinkSupport</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.LinuxSymlinkSupportDictionary.*			</imports><category>OS-Unix</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libc.so</item></libraryFiles><libraryDirectories><item>/usr/lib</item> <item>/lib</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>LinuxSymlinkSupport</package></attributes></class><comment><class-id>OS.LinuxSymlinkSupport</class-id><body>Linux OS support for symlinks.</body></comment><shared-variable><name>LinuxSymlinkSupportDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>LinuxSymlinkSupport</package></attributes></shared-variable><methods><class-id>OS.LinuxSymlinkSupport</class-id> <category>wrappers</category><body package="LinuxSymlinkSupport" selector="canonicalPathOf:">canonicalPathOf: fileName	"Return the canonical absolute pathname of fileName, resolving all symlinks 	and path specials (e.g., '..')."		| buffer answer |	["PATH_MAX"	buffer := (ByteString new: 4095) copyToHeap.	self		realpath: fileName asString		into: buffer.	answer := buffer copyCStringFromHeap]		ensure: [buffer isValid ifTrue: [buffer free]].	^answer</body><body package="LinuxSymlinkSupport" selector="fstat:using:">fstat: fd using: structStatPtr 	^self 		__fxstat: fd		using: structStatPtr		version: 3</body><body package="LinuxSymlinkSupport" selector="lstat:using:">lstat: fileName using: structStatPtr 	^self 		__lxstat: fileName		using: structStatPtr		version: 3</body><body package="LinuxSymlinkSupport" selector="stat:using:">stat: fileName using: structStatPtr 	^self 		__xstat: fileName		using: structStatPtr		version: 3</body></methods><methods><class-id>OS.LinuxSymlinkSupport</class-id> <category>user support</category><body package="LinuxSymlinkSupport" selector="fullyResolveSymlink:">fullyResolveSymlink: fileName	"Fully resolve the symbolic link named fileName and return the result."		| target |	target := fileName asString.	[self isSymlink: target]		whileTrue: [target := self resolveSymlink: target].	^target</body><body package="LinuxSymlinkSupport" selector="isSymlink:">isSymlink: aFilename 	"Check to see if aFilename is a symbolic link.  Answer a boolean."	| status result statPtr |		[statPtr := self stat malloc.	status := self lstat: aFilename asString using: statPtr.	status = -1 		ifTrue: 			[| err |			err := self errno.			self halt].	result := ((statPtr memberAt: #st_mode) bitAnd: 8r0170000) == 8r0120000] 			ensure: [statPtr isValid ifTrue: [statPtr free]].	^result</body><body package="LinuxSymlinkSupport" selector="resolveSymlink:">resolveSymlink: fileName 	"Resolve the symbolic link named fileName and return the result.	Assume that fileName is a symlink."	| target value |		[target := (ByteString new: 256) copyToHeap.	self 		readlink: fileName		into: target		size: 256.	value := target copyCStringFromHeap] 			ensure: [target isValid ifTrue: [target free]].	^value</body></methods><methods><class-id>OS.LinuxSymlinkSupport</class-id> <category>error reporting</category><body package="LinuxSymlinkSupport" selector="errorReporterInstance">errorReporterInstance	"Answer the class which can interpret the receiver's error codes."	^self class errorReporter new</body></methods><methods><class-id>OS.LinuxSymlinkSupport</class-id> <category>defaults</category><body package="LinuxSymlinkSupport" selector="errorReporter">errorReporter	"Answer the appropriate error forwarder (e.g. the one who	can interpret errorHolders) for me."	^self class errorReporter</body></methods><methods><class-id>OS.LinuxSymlinkSupport class</class-id> <category>defaults</category><body package="LinuxSymlinkSupport" selector="errorReporter">errorReporter	"Return the appropriate error code interpreter."	^OSErrorHolder</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>file utilities</category><body package="LinuxSymlinkSupport" selector="fullyResolveAsSymlink">fullyResolveAsSymlink	"Fully resolve the symbolic link represented by the receiver and return the result."		^self runningLinux		ifTrue: [(LinuxSymlinkSupport new fullyResolveSymlink: self) asFilename]		ifFalse: [self]</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>testing</category><body package="LinuxSymlinkSupport" selector="isSymlink">isSymlink		^self runningLinux		ifTrue: [LinuxSymlinkSupport new isSymlink: self asString]		ifFalse:			[(UnixProcess shOne: ('ls -Al "&lt;1s&gt;"' expandMacrosWith: self asString))				first = $l]</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>file utilities</category><body package="LinuxSymlinkSupport" selector="resolveAsSymlink">resolveAsSymlink		^self runningLinux		ifTrue:			[[(LinuxSymlinkSupport new resolveSymlink: self asString) asFilename]				on: OsInvalidArgumentsError				do: [:ex | self]]		ifFalse: [self]</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>testing</category><body package="LinuxSymlinkSupport" selector="runningLinux">runningLinux		^#(40 42 43 44 45 64) includes: (ObjectMemory versionId at: 2)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>UnixFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class></st-source>