<?xml version="1.0"?><st-source><!-- Name: Fix Colored Text SelectionComment: At Smalltalk Solutions 2006 Alan Knight showed how colored code could be almost unreadable when selected. This package changes that.Colored text, like other text, will sometimes be highlighted (selected). With syntax coloring, which often means a variety of colors used for text segments, and an operating system with a configurable text selection color, it's easy to end up with cases where your text just "disappears" when selected because the colors are similar.  Because it is a tricky problem, the changes this package makes to solve it are deep and intrusive. And it trades the problem of "disappearing colors" for "that's not the color I expected there." So making this package a hard prerequisite of RBCodeHighlighting is too intrusive.  Users may not want the text/highlighting rendering pipeline being rewritten just to solve a problem they may not be experiencing.  Instead, loading the RBCodeHighlighting package prints	RBCodeHighlighting suggests loading 'Fix Colored Text Selection'on the Transcript.DbIdentifier: bear73DbTrace: 318666DevelopmentPrerequisites: #(#(#any 'ExtraEmphases' ''))PackageName: Fix Colored Text SelectionParcel: #('Fix Colored Text Selection')ParcelName: Fix Colored Text SelectionPrerequisiteDescriptions: #(#(#name 'ExtraEmphases' #componentType #package))PrerequisiteParcels: #(#('ExtraEmphases' ''))PrintStringCache: (7.7 - 2,nross)Version: 7.7 - 2Date: 10:25:38 AM February 4, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (feb11.1) of February 4, 2011 on February 4, 2011 at 10:25:38 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>UI.ComposedTextView</class-id> <category>private</category><body package="Fix Colored Text Selection" selector="displayFromCharacter:to:startX:on:backgroundColor:defaultBackground:">displayFromCharacter: start to: stop startX: x on: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the character from start to stop on aGraphicsContext.  The	first character starts at x position x.  Useful for displaying selections."	displayContents 		displayFromCharacter: start		to: stop		startX: x		forTranslation: self displayOrigin		on: aGraphicsContext		backgroundColor: aColor		defaultBackground: defaultColor</body><body package="Fix Colored Text Selection" selector="displaySelectedFromSelectionBlock:toSelectionBlock:on:fColor:bColor:within:defaultBackground:">displaySelectedFromSelectionBlock: cBlock1 toSelectionBlock: cBlock2 on: gc fColor: fColor bColor: bColor within: aRectangle defaultBackground: defaultColor 	"Hilite area between the two character blocks given as arguments."	| start stop left first last lineRange leftX rightX |	(cBlock1 = cBlock2 or: [displayContents numberOfLines = 0]) 		ifTrue: [^self].	cBlock1 &lt; cBlock2 		ifTrue: 			[start := cBlock1.			stop := cBlock2]		ifFalse: 			[start := cBlock2.			stop := cBlock1].	start top &gt; aRectangle bottom ifTrue: [^self].	stop bottom &lt; aRectangle top ifTrue: [^self].	gc paint: bColor.	start top = stop top 		ifTrue: 			[gc displayRectangle: ((start origin corner: stop bottomLeft) 						intersect: aRectangle).			gc paint: fColor.			^self 				displayFromCharacter: start stringIndex				to: stop stringIndex - 1				startX: start left				on: gc				backgroundColor: bColor				defaultBackground: defaultColor].	left := start left.	(start top &gt;= aRectangle top and: [stop bottom &lt;= aRectangle bottom]) 		ifTrue: 			[first := start stringIndex.			last := stop stringIndex - 1]		ifFalse: 			[lineRange := displayContents 						lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).			first := (displayContents lineAt: lineRange first) first.			last := (displayContents lineAt: lineRange last) last.			start stringIndex &gt; first ifTrue: [first := start stringIndex].			stop stringIndex - 1 &lt; last ifTrue: [last := stop stringIndex - 1]].	leftX := self displayOrigin x.	rightX := leftX + self displayObject bounds right.	gc displayRectangle: ((start origin corner: rightX @ start bottom) 				intersect: aRectangle).	gc displayRectangle: ((leftX @ start bottom corner: rightX @ stop top) 				intersect: aRectangle).	gc displayRectangle: ((leftX @ stop top corner: stop bottomLeft) 				intersect: aRectangle).	gc paint: fColor.	self 		displayFromCharacter: first		to: last		startX: left		on: gc		backgroundColor: bColor		defaultBackground: defaultColor</body><body package="Fix Colored Text Selection" selector="displayTextIn:on:">displayTextIn: aRectangle on: gc 	"Display the receiver's text that intersects aRectangle on GraphicsContext gc.	Show all text whether selected or not in one pass."	| first last ss es x lineRange |	gc paint: self foregroundColor.	(displaySelection not or: [selectionShowing not]) 		ifTrue: [^self displayObject displayOn: gc copy at: self displayOrigin].	displayContents numberOfLines = 0 		ifTrue: [^self displayInsertionPointFor: self startBlock on: gc].	lineRange := displayContents 				lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).	first := (displayContents lineAt: lineRange first) first.	last := (displayContents lineAt: lineRange last) last.	x := self displayOrigin x.	ss := self startBlock stringIndex.	es := self stopBlock stringIndex.	((ss &gt; last or: [es &lt; first]) or: [ss = es]) 		ifTrue: 			[self displayObject displayOn: gc copy at: self displayOrigin.			^self displayInsertionPointFor: self startBlock on: gc].	ss &gt; first 		ifTrue: 			[gc paint: self foregroundColor.			self 				displayFromCharacter: first				to: ss - 1				startX: x				on: gc.			first := ss.			x := self startBlock left].	self showSelectionBoxOn: gc within: aRectangle.	gc paint: self selectionForegroundColor.	last &lt; es 		ifTrue: 			[self 				displayFromCharacter: first				to: last				startX: x				on: gc				backgroundColor: self selectionBackgroundColor				defaultBackground: self backgroundColor]		ifFalse: 			[self 				displayFromCharacter: first				to: es - 1				startX: x				on: gc				backgroundColor: self selectionBackgroundColor				defaultBackground: self backgroundColor.			gc paint: self foregroundColor.			x := self stopBlock left.			self 				displayFromCharacter: es				to: last				startX: x				on: gc]</body><body package="Fix Colored Text Selection" selector="showSelectionFrom:to:on:within:">showSelectionFrom: characterBlock1 to: characterBlock2 on: gc within: aRectangle 	"Hilite area between the two character blocks given as arguments."	self 		displaySelectedFromSelectionBlock: characterBlock1		toSelectionBlock: characterBlock2		on: gc		fColor: self selectionForegroundColor		bColor: self selectionBackgroundColor		within: aRectangle		defaultBackground: self backgroundColor</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>private</category><body package="Fix Colored Text Selection" selector="displayTextIn:on:">displayTextIn: aRectangle on: gc 	"Display the receiver's text that intersects aRectangle on GraphicsContext gc.	Show all text whether selected or not in one pass."	| first last ss es x lineRange |	gc paint: self foregroundColor.	(self displaySelection not or: [selectionShowing not]) 		ifTrue: [^self displayObject displayOn: gc copy at: self displayOrigin].	displayContents numberOfLines = 0 		ifTrue: [^self displayInsertionPointFor: self startBlock on: gc].	lineRange := displayContents 				lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).	first := (displayContents lineAt: lineRange first) first.	last := (displayContents lineAt: lineRange last) last.	x := self displayOrigin x.	ss := self startBlock stringIndex.	es := self stopBlock stringIndex.	((ss &gt; last or: [es &lt; first]) or: [ss = es]) 		ifTrue: 			[self displayObject displayOn: gc copy at: self displayOrigin.			^self displayInsertionPointFor: self startBlock on: gc].	ss &gt; first 		ifTrue: 			[gc paint: self foregroundColor.			self 				displayFromCharacter: first				to: ss - 1				startX: x				on: gc.			first := ss.			x := self startBlock left].	self showSelectionBoxOn: gc within: aRectangle.	gc paint: self selectionForegroundColor.	last &lt; es 		ifTrue: 			[self 				displayFromCharacter: first				to: last				startX: x				on: gc				backgroundColor: self selectionBackgroundColor				defaultBackground: self backgroundColor]		ifFalse: 			[self 				displayFromCharacter: first				to: es - 1				startX: x				on: gc				backgroundColor: self selectionBackgroundColor				defaultBackground: self backgroundColor.			gc paint: self foregroundColor.			x := self stopBlock left.			self 				displayFromCharacter: es				to: last				startX: x				on: gc]</body></methods><methods><class-id>Graphics.TranslatingWrapper</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver's component after translating aGraphicsContext."	aGraphicsContext translateBy: self translation.	component displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor .</body></methods><methods><class-id>UI.LabelAndIcon</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses.	Make sure on non Windows platforms that the icon is positioned	slightly higher against the text label, than normal."	icon == nil 		ifFalse: 			[icon displayOn: aGraphicsContext				at: self offset x @ 0].	super 		displayOn: aGraphicsContext		backgroundColor: aColor		defaultBackground: defaultColor</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayFromCharacter:to:startX:forTranslation:on:backgroundColor:defaultBackground:">displayFromCharacter: startIndex to: stopIndex startX: startX forTranslation: aPoint on: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the characters between startIndex and stopIndex on 	aGraphicsContext. The x position of the first character is at startX. 	This is useful for displaying text selections.	It is important to start displaying at the character before startIndex 	if startIndex is not the start of a line and after stopIndex if the stop 	is not the end of a line because some hosts do kerning for us. This 	would result in some missing parts of characters that intruded into 	the bounding box of the characters. This is most noticable with italic 	text."	| stop lineIndex startForLine stopForLine leftX rightX top scanner textSize lineRecord lineGrid left gc |	self fontPolicy: aGraphicsContext fontPolicy.	textSize := self text size.	startIndex &gt; textSize ifTrue: [^self].	stop := stopIndex.	stop &gt; textSize ifTrue: [stop := textSize].	scanner := self getDisplayScanner.	scanner textStyle: self textStyle.	lineIndex := self lineIndexOfCharacterIndex: startIndex.	lineRecord := self lineAt: lineIndex.	stopForLine := lineRecord last.	stopIndex &lt; stopForLine ifTrue: [stopForLine := stopIndex].	startForLine := startIndex.	rightX := self rightMarginForDisplay + aPoint x.	top := (self topAtLineIndex: lineIndex) + aPoint y.	lineGrid := self lineGridFor: aGraphicsContext fontPolicy.	left := (self leftMarginForDisplayForLine: lineIndex) + aPoint x.	gc := aGraphicsContext.	lineRecord first = startForLine 		ifTrue: [leftX := left]		ifFalse: 			["move the start index back by one if the previous character is				not white space.  Change the clipping box of the first line so it appears that				we started displaying at startX"			| line index char |			line := self textAt: lineIndex.			index := startForLine - 1.			(char := line at: index) isSeparator 				ifTrue: [leftX := startX]				ifFalse: 					[| font r |					font := aGraphicsContext 								findFont: (self textStyle fontAt: (line emphasisAt: index)										for: self fontPolicy).					gc := aGraphicsContext copy.					r := gc clippingBounds.					gc clippingRectangle: (r left: (startX max: r left)).					leftX := startX - (font widthOf: char).					startForLine := index]].		[scanner 		displayLine: lineRecord		inText: (self textAt: lineIndex)		left: left		right: rightX		startX: leftX		top: top		startIndex: startForLine		stopIndex: stopForLine		on: gc		backgroundColor: aColor		defaultBackground: defaultColor.	stop &lt;= stopForLine 		ifTrue: 			[| cRect cb |			stopForLine = lineRecord last ifTrue: [^self].			cb := gc clippingBounds.			leftX := scanner destX.			cRect := cb origin corner: (leftX min: cb right) @ cb bottom.			gc clippingRectangle: cRect.			scanner 				displayLine: lineRecord				inText: (self textAt: lineIndex)				left: left				right: rightX				startX: leftX				top: top				startIndex: stopForLine + 1				stopIndex: stopForLine + 1				on: gc				backgroundColor: aColor				defaultBackground: defaultColor.			gc clippingRectangle: cb.			^self].	"Set the GraphicsContext back to the original since the clipping may have been changed	for the first line."	gc := aGraphicsContext.	lineIndex := lineIndex + 1.	lineRecord := self lineAt: lineIndex.	startForLine := lineRecord first.	stopForLine := lineRecord last.	stop &lt; stopForLine ifTrue: [stopForLine := stop].	leftX := (self leftMarginForDisplayForLine: lineIndex) + aPoint x.	left := leftX.	top := top + lineGrid] 			repeat</body></methods><methods><class-id>UI.SequenceView</class-id> <category>private</category><body package="Fix Colored Text Selection" selector="displayTextObjectsOn:">displayTextObjectsOn: aGraphicsContext 	"Display the receiver's content on aGraphicsContext."	| rect interval scanner bounds |	sequence isNil ifTrue: [^self].	rect := aGraphicsContext clippingBounds.	bounds := self bounds.	interval := self visibleIntervalForBounds: bounds.	scanner := DisplayScanner new.	scanner textStyle: self textStyle.	interval first to: interval last		do: 			[:index | 			| elementBounds |			elementBounds := self boundsOfElementIndex: index inBounds: bounds.			(rect intersects: elementBounds) 				ifTrue: 					[| displayString oldPaint |					oldPaint := nil.					displayString := self displayStringAt: index.					(self isSelected: index) 						ifTrue: 							[oldPaint := aGraphicsContext paint.							aGraphicsContext paint: self selectionBackgroundColor.							aGraphicsContext displayRectangle: elementBounds.							aGraphicsContext paint: (self selectionForegroundColor).								scanner 								displayLine: (1 to: displayString size)								inText: displayString								left: elementBounds left + self offsetForTextDisplay								right: elementBounds right								top: elementBounds top								on: aGraphicsContext								backgroundColor: self selectionBackgroundColor 								defaultBackground: self backgroundColor ]						ifFalse: 							[scanner 								displayLine: (1 to: displayString size)								inText: displayString								left: elementBounds left + self offsetForTextDisplay								right: elementBounds right								top: elementBounds top								on: aGraphicsContext].					oldPaint isNil ifFalse: [aGraphicsContext paint: oldPaint].					(targetIndex = index and: [self hasFocus]) 						ifTrue: 							[| selectionBorder |							selectionBorder := SimpleBorder new.							selectionBorder setBorderColor: SymbolicPaint listDataTraversalHilite.							selectionBorder 								displayOn: aGraphicsContext								forDisplayBox: elementBounds								using: self]]]</body></methods><methods><class-id>Graphics.Wrapper</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver's component on aGraphicsContext.	Only use displayOn:backgroundColor:defaultBackground: if displayOn: is not implemented in a younger parent class."	((self component class whichClassIncludesSelector: #displayOn:)  includesSelector: #displayOn:backgroundColor:defaultBackground:) 		ifTrue: 			[self component 				displayOn: aGraphicsContext				backgroundColor: aColor				defaultBackground: defaultColor]		ifFalse: [self component displayOn: aGraphicsContext]</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Fix Colored Text Selection" selector="hue:saturation:lightness:">hue: aHue saturation: aSaturation lightness: aLightness 	"Create a Colorvalue from the HSL model.	This algorithm looks awful, it has been copied from Python"	| red green blue var_2 var_1 |	aSaturation == 0 ifTrue: [^self brightness: aLightness].	aLightness &lt; 0.5 		ifTrue: [var_2 := aLightness * (1 + aSaturation)]		ifFalse: [var_2 := aLightness + aSaturation - (aSaturation * aLightness)].	var_1 := 2 * aLightness - var_2.	red := self 				hue2rgbHue: aHue + (1 / 3)				v1: var_1				v2: var_2.	green := self 				hue2rgbHue: aHue				v1: var_1				v2: var_2.	blue := self 				hue2rgbHue: aHue - (1 / 3)				v1: var_1				v2: var_2.	^ColorValue 		red: red		green: green		blue: blue</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>private</category><body package="Fix Colored Text Selection" selector="hue2rgbHue:v1:v2:">hue2rgbHue: aHue v1: v1 v2: v2 	"This algorithm looks awful, it has been copied from Python"	| vH |	vH := aHue \\ 1.	^6 * vH &lt; 1 		ifTrue: [v1 + ((v2 - v1) * 6 * vH)]		ifFalse: 			[2 * vH &lt; 1 				ifTrue: [v2]				ifFalse: 					[3 * vH &lt; 2 ifTrue: [(v1 + (v2 - v1)) * (2 / 3 - vH) * 6] ifFalse: [v1]]]</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Fix Colored Text Selection" selector="asColorValueOn:">asColorValueOn: aGc 	"we need no convertion"	^self</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>accessing</category><body package="Fix Colored Text Selection" selector="hslSaturation">hslSaturation	| maxColorValue minColorValue deltaColorValue |	maxColorValue := (self red max: self green) max: self blue.	minColorValue := (self red min: self green) min: self blue.	deltaColorValue := maxColorValue - minColorValue.	deltaColorValue = 0 ifTrue: [^0].	self lightness &lt; 0.5 		ifTrue: [^deltaColorValue / (maxColorValue + minColorValue)]		ifFalse: [^deltaColorValue / (2 - maxColorValue - minColorValue)]</body><body package="Fix Colored Text Selection" selector="lightness">lightness	| maxColorValue minColorValue |	maxColorValue := (self red max: self green) max: self blue.	minColorValue := (self red min: self green) min: self blue.	^(maxColorValue + minColorValue) / 2</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Fix Colored Text Selection" selector="onBackgroundColor:defaultBackground:">onBackgroundColor: aColor defaultBackground: defaultColor 	| newBrightness newHue newSaturation light sat myHue |	light := self lightness.	myHue := self hue.	sat := self hslSaturation.	myHue - defaultColor hue = 0 		ifTrue: 			[myHue := myHue + aColor hue.			myHue &gt; 1 ifTrue: [(myHue = 2) - myHue]].	newBrightness := (light - defaultColor lightness) abs + aColor lightness.	newBrightness &gt; 1 ifTrue: [newBrightness := 2 - newBrightness].	newHue := (myHue - defaultColor hue) abs + aColor hue.	newHue &gt; 1 ifTrue: [newHue := newHue - 1].	newSaturation := (sat - defaultColor hslSaturation) abs 				+ aColor hslSaturation.	newSaturation &gt; 1 ifTrue: [newSaturation := newSaturation - 1].	^self class 		hue: newHue		saturation: newSaturation		lightness: newBrightness</body></methods><methods><class-id>UI.TabControlLabelAndIcon</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver on aGraphicsContext. The receiver may alter aGraphicsContext 	in any way it chooses. Unlike LabelAndIcon the icon is centered vertically."	icon isNil 		ifTrue: [super displayOn: aGraphicsContext]		ifFalse: 			[| height |			height := (self preferredBounds height - 4 - icon preferredBounds height) 						// 2 max: 0.			icon displayOn: aGraphicsContext at: self offset + (0 @ height).			self fontPolicy: aGraphicsContext fontPolicy.			self 				displayTextOn: aGraphicsContext				backgroundColor: aColor				defaultBackground: defaultColor]</body></methods><methods><class-id>UI.IndentedLabelAndIcon</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayLabelOn:backgroundColor:defaultBackground:">displayLabelOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	self fontPolicy: aGraphicsContext fontPolicy.	self displayTextOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor</body><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	| selectionsIcon verticalIcon spaceIcon totalXOffset yOffset |	selectionsIcon := self getIconForSelection.	yOffset := 0.	self indentLevel = 0 		ifTrue: [totalXOffset := 0]		ifFalse: 			[totalXOffset := 0.			verticalIcon := self class eraseBackground: #vline.			spaceIcon := self class eraseBackground: #blank.			1 to: self indentLevel				do: 					[:indentLevelx | 					(self displayableIndents includes: indentLevelx - 1) 						ifTrue: 							[verticalIcon displayOn: aGraphicsContext at: totalXOffset @ yOffset.							totalXOffset := totalXOffset + verticalIcon preferredBounds width]						ifFalse: 							[spaceIcon displayOn: aGraphicsContext at: totalXOffset @ yOffset.							totalXOffset := totalXOffset + spaceIcon preferredBounds width]]].	selectionsIcon displayOn: aGraphicsContext at: totalXOffset @ yOffset.	icon == nil 		ifFalse: 			[icon displayOn: aGraphicsContext				at: (totalXOffset + selectionsIcon preferredBounds width) @ yOffset].	aGraphicsContext translateBy: 0 @ yOffset.	self 		displayLabelOn: aGraphicsContext		backgroundColor: aColor		defaultBackground: defaultColor.	aGraphicsContext translateBy: 0 @ yOffset negated</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display each of the receiver's components."	| clipBox |	clipBox := aGraphicsContext clippingBounds.	1 to: components size		do: 			[:i | 			| component |			component := components at: i.			(component intersects: clipBox) 				ifTrue: 					[component 						displayOn: aGraphicsContext copy						backgroundColor: aColor						defaultBackground: defaultColor]]</body></methods><methods><class-id>UI.TreeViewIndentedLabelAndIcon</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver on aGraphicsContext. The receiver may alter 	aGraphicsContext in any way it chooses."	| height xOffset |	xOffset := self displayLinesOn: aGraphicsContext.	icon isNil 		ifFalse: 			[height := ((self bounds height - icon preferredBounds height) / 2) rounded 						max: 0.			icon displayOn: aGraphicsContext at: xOffset @ height.			self displayAdditionalLineOn: aGraphicsContext				top: height + icon preferredBounds height].	self 		displayTextOn: aGraphicsContext		backgroundColor: aColor		defaultBackground: defaultColor</body><body package="Fix Colored Text Selection" selector="displayTextOn:backgroundColor:defaultBackground:">displayTextOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Center text vertically inside assigned bounds. 	This is important when using the receiver inside a tree view."	| t |	t := (self bounds height - self preferredBounds height) / 2 max: 0.	aGraphicsContext translateBy: 0 @ t.	(self localTextDisplayedOn: aGraphicsContext) 		ifFalse: 			[super 				displayTextOn: aGraphicsContext				backgroundColor: aColor				defaultBackground: defaultColor].	aGraphicsContext translateBy: 0 @ t negated</body></methods><methods><class-id>UI.ReversingWrapper</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:">displayOn: aGraphicsContext 	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	reverse value 		ifTrue: 			[| gc box |			box := container == nil 						ifTrue: [self bounds]						ifFalse: [container compositionBoundsFor: self].			box left: box left + offset.			gc := aGraphicsContext copy.			gc paint: self selectionBackgroundColor.			gc displayRectangle: box.			gc paint: self selectionForegroundColor.			super 				displayOn: gc				backgroundColor: self selectionBackgroundColor				defaultBackground: self backgroundColor]		ifFalse: [super displayOn: aGraphicsContext]</body></methods><methods><class-id>Graphics.DisplayScanner</class-id> <category>scanning</category><body package="Fix Colored Text Selection" selector="displayLine:inText:left:right:startX:top:startIndex:stopIndex:on:backgroundColor:defaultBackground:">displayLine: aLine inText: aText left: left right: right startX: startX top: top startIndex: strtIndex stopIndex: stpIndex on: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to 	the StopConditions array passed to the primitive at which time the 	code to handle the stopCondition is run and the call on the primitive 	continued until a stopCondition returns true which means the line has 	terminated. The start or stop index for displaying can be different from those specified	in aLine.  The initial x to start displaying is given by startX."	fontPolicy := aGraphicsContext fontPolicy.	leftMargin := left.	rightMargin := right.	aLine initializeScanner: self.	self text: aText.	self lineLast: stpIndex.	(strtIndex &gt; self lineFirst and: [textStyle alignment = Justified]) 		ifTrue: 			[spaceCount := 0.			lineFirst to: strtIndex				do: [:i | (string at: i) == Space ifTrue: [spaceCount := spaceCount + 1]]].	self lineFirst: strtIndex.	graphicsContext := aGraphicsContext.	destX := startX.	lineY := top + (textStyle baselineFor: fontPolicy).	self scanOnBackgroundColor: aColor defaultBackground: defaultColor.	graphicsContext := nil.	fontPolicy := nil</body><body package="Fix Colored Text Selection" selector="displayLine:inText:left:right:top:on:backgroundColor:defaultBackground:">displayLine: aLine inText: aText left: left right: right top: top on: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor	"The central display routine.  The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to 	the StopConditions array passed to the primitive at which time the 	code to handle the stopCondition is run and the call on the primitive 	continued until a stopCondition returns true which means the line has 	terminated. "	fontPolicy := aGraphicsContext fontPolicy.	leftMargin := left.	rightMargin := right.	destX := left.	aLine initializeScanner: self.	graphicsContext := aGraphicsContext.	lineY := top + (textStyle baselineFor: fontPolicy).	self text: aText.	self scanOnBackgroundColor: aColor defaultBackground: defaultColor.	graphicsContext := nil.	fontPolicy := nil</body></methods><methods><class-id>Graphics.DisplayScanner</class-id> <category>private</category><body package="Fix Colored Text Selection" selector="scanOnBackgroundColor:defaultBackground:">scanOnBackgroundColor: aColor defaultBackground: defaultColor 	| runLength done stopCondition last p lastFont |	lastIndex := self lineFirst.	last := self lineLast.	self setStopConditions.	"also sets the font"	runLength := text runLengthFor: lastIndex.	(runStopIndex := lastIndex + (runLength - 1)) &gt; last 		ifTrue: [runStopIndex := last].	spaceCount := 0.	done := false.	p := 0 @ lineY.	lastFont := nil.	[done] whileFalse: 			[| code tmpLastIndex |			(font class = ExtraEmphases.ColoredFont and: [font ~~ lastFont]) 				ifTrue: 					[lastFont := font := font copy.					font color: ((font color asColorValueOn: graphicsContext) 								onBackgroundColor: (aColor asColorValueOn: graphicsContext)								defaultBackground: (defaultColor asColorValueOn: graphicsContext))].			p x: destX.			tmpLastIndex := lastIndex.			code := self 						scanCharactersFrom: lastIndex						to: runStopIndex						in: string						rightX: rightMargin						stopConditions: characterMap.			stopCondition := self stopConditionFor: code.			tmpLastIndex &lt;= lastIndex 				ifTrue: 					[graphicsContext font: font.					font 						displayString: string						from: tmpLastIndex						to: ((stopCondition == #endOfRun or: [stopCondition == #crossedX]) 								ifTrue: [lastIndex]								ifFalse: [lastIndex - 1])						at: p						on: graphicsContext						map: characterMap].			done := self perform: stopCondition].	font := nil</body></methods><methods><class-id>Graphics.SymbolicPaint</class-id> <category>converting</category><body package="Fix Colored Text Selection" selector="asColorValueOn:">asColorValueOn: aGc 	"use the graphicsContext for convertion, if that is nil, use the defaultImplementation."	aGc ifNil: [^self asColorValue].	^aGc colorValueForPaint: self</body></methods><methods><class-id>UI.TreeViewIndentedLabelAndMultipleIcon</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver on aGraphicsContext. The receiver may alter 	aGraphicsContext in any way it chooses."	| xOffset |	xOffset := self displayLinesOn: aGraphicsContext.	icons isEmpty 		ifFalse: 			[1 to: icons size				do: 					[:i | 					| anIcon height |					(anIcon := icons at: i) notNil 						ifTrue: 							[height := ((self preferredBounds height - anIcon preferredBounds height) 										/ 2) rounded 										max: 0.							anIcon displayOn: aGraphicsContext at: xOffset @ height.							i = 1 								ifTrue: 									[self displayAdditionalLineOn: aGraphicsContext										top: height + anIcon preferredBounds height].							xOffset := xOffset + anIcon preferredBounds width + iconGap]]].	self 		displayTextOn: aGraphicsContext		backgroundColor: aColor		defaultBackground: defaultColor</body></methods><methods><class-id>UI.Label</class-id> <category>displaying</category><body package="Fix Colored Text Selection" selector="displayOn:backgroundColor:defaultBackground:">displayOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	self fontPolicy: aGraphicsContext fontPolicy.	self 		displayTextOn: aGraphicsContext		backgroundColor: aColor		defaultBackground: defaultColor</body><body package="Fix Colored Text Selection" selector="displayTextOn:backgroundColor:defaultBackground:">displayTextOn: aGraphicsContext backgroundColor: aColor defaultBackground: defaultColor 	| scanner wid |	(text == nil or: [text isEmpty]) ifTrue: [^self].	"Do the check for change of emphasis now because clients may	choose to change the emphasis at any time."	(text hasChangeOfEmphasis or: [needsScan]) 		ifFalse: 			[| theFont |			theFont := (self attributes fontAt: (text emphasisAt: 1)						for: aGraphicsContext fontPolicy) copy.			theFont color isNil 				ifFalse: 					[theFont color: ((theFont color asColorValueOn: aGraphicsContext) 								onBackgroundColor: (aColor asColorValueOn: aGraphicsContext)								defaultBackground: (defaultColor asColorValueOn: aGraphicsContext))].			aGraphicsContext				font: theFont;				displayString: text string					from: 1					to: text size					at: self left @ (self offset y 									+ (self attributes baselineFor: aGraphicsContext fontPolicy)).			^self].	wid := width == nil ifTrue: [SmallInteger maxVal] ifFalse: [width].	scanner := DisplayScanner new.	scanner textStyle: self attributes.	scanner 		displayLine: (1 to: text size)		inText: text		left: self left		right: wid		top: self offset y		on: aGraphicsContext		backgroundColor: aColor		defaultBackground: defaultColor</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Label</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text attributes width offset needsScan fontPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>LabelAndIcon</name><environment>UI</environment><super>UI.Label</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icon gap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>TabControlLabelAndIcon</name><environment>UI</environment><super>UI.LabelAndIcon</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ComposedTextView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayContents startBlock stopBlock selectionShowing displaySelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>TranslatingWrapper</name><environment>Graphics</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>IndentedLabelAndIcon</name><environment>UI</environment><super>UI.ExtendedLabelAndIcon</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indentLevel hasChildren hasParent trailingIcon isFirst isLast rootIcon isExpanded displayLastIndentVerticalLine displayableIndents view index components lookType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>CompositePart</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components preferredBounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ComposedText</name><environment>Graphics</environment><super>Graphics.TextLines</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text compositionWidth compositionHeight wordWrap fontPolicy lineTable fitWidth </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Support</category><attributes><package>Graphics-Text Support</package></attributes></class><class><name>SymbolicPaint</name><environment>Graphics</environment><super>Graphics.Paint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key constantCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.SymbolicPaintConstants.*			</imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>SequenceView</name><environment>UI</environment><super>UI.SelectionView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visualBlock selectedVisualBlock measureWidth cachedWidth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>DisplayScanner</name><environment>Graphics</environment><super>Graphics.CharacterScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphicsContext lineY </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Scanning</category><attributes><package>Graphics-Text Scanning</package></attributes></class><class><name>ReversingWrapper</name><environment>UI</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reverse offset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>TreeViewIndentedLabelAndIcon</name><environment>UI</environment><super>UI.LabelAndIcon</super><private>false</private><indexed-type>none</indexed-type><inst-vars>levelDescription hasChildren openedChildren boundsHeight props </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>TextEditorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>TreeViewIndentedLabelAndMultipleIcon</name><environment>UI</environment><super>UI.TreeViewIndentedLabelAndIcon</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icons iconGap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class></st-source>