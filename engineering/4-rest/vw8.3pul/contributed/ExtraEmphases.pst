<?xml version="1.0"?><st-source><!-- Name: ExtraEmphasesComment: This parcel adds super/sub script attributes to the font system. Try the following:"| txt ct cp vb|	txt := 'X' asText.txt := txt , ('2' asText emphasizeAllWith: #superscript).txt := txt, ' + Y' asText.txt := txt , ('2' asText emphasizeAllWith: #superscript).txt := txt, ' + Z' asText.txt := txt , ('2' asText emphasizeAllWith: #superscript).txt := txt, ' = 0' asText.ct := ComposedText withText: txt.vb := VisualBlock block: [:gc :box | gc display: ct at: box origin] bounds: (0@0 corner: 100 @ 40).cp := CompositePart new.cp add: vb in: (0@0 extent: 1@1).ApplicationWindow new component: cp; openWithExtent: vb bounds extent"It also changes the PDP highlighting probe annotation scheme to use something other than standard emphases.DbIdentifier: bear73DbTrace: 412279DbUsername: smichaelDbVersion: 56PackageName: ExtraEmphasesParcel: #('ExtraEmphases')ParcelName: ExtraEmphasesPrintStringCache: (56,smichael)Version: 56Date: 12:17:13 PM September 20, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (sep13.2) of September 20, 2013 on September 20, 2013 at 12:17:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ExtraEmphases</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>ExtraEmphases</category><attributes><package>ExtraEmphases</package></attributes></name-space><class><name>DecoratedFont</name><environment>ExtraEmphases</environment><super>Graphics.ImplementationFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseFont </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>AdornedFont</name><environment>ExtraEmphases</environment><super>ExtraEmphases.DecoratedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>ResizedFont</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>widthTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>TrailingInsert</name><environment>ExtraEmphases</environment><super>ExtraEmphases.ResizedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphic </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>Substitute</name><environment>ExtraEmphases</environment><super>ExtraEmphases.ResizedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphic </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>Underline</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>ColoredUnderline</name><environment>ExtraEmphases</environment><super>ExtraEmphases.Underline</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ExtraEmphases</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>ColoredDoubleUnderline</name><environment>ExtraEmphases</environment><super>ExtraEmphases.ColoredUnderline</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ExtraEmphases</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>ExtendedFontDescription</name><environment>Graphics</environment><super>Graphics.FontDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extensions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>WarpedFont</name><environment>ExtraEmphases</environment><super>ExtraEmphases.DecoratedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>UnderGraphic</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visualBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>BackColor</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>paint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>Subscript</name><environment>ExtraEmphases</environment><super>ExtraEmphases.WarpedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>DoubleUnderline</name><environment>ExtraEmphases</environment><super>ExtraEmphases.Underline</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ExtraEmphases</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>Shadow</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>JaggedEdge</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>Overline</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>Superscript</name><environment>ExtraEmphases</environment><super>ExtraEmphases.WarpedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>BackHalf</name><environment>ExtraEmphases</environment><super>ExtraEmphases.ResizedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>LeadingInsert</name><environment>ExtraEmphases</environment><super>ExtraEmphases.ResizedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphic </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>LeadingInsertSpace</name><environment>ExtraEmphases</environment><super>ExtraEmphases.LeadingInsert</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ExtraEmphases</category><attributes><package>ExtraEmphases</package></attributes></class><comment><class-id>ExtraEmphases.LeadingInsertSpace</class-id><body>Like LeadingInsert, but adds a space's worth of width between the graphic and the character. Thus mostly useful for the first character on a line, otherwise it appears as the preceding character, the graphic looking like a TrailingInsert for the preceding character, a space, and then the emphasized character.</body></comment><class><name>Strikeout</name><environment>ExtraEmphases</environment><super>ExtraEmphases.AdornedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><class><name>ColoredFont</name><environment>ExtraEmphases</environment><super>ExtraEmphases.WarpedFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>ExtraEmphases</package></attributes></class><shared-variable><name>ExtraDefaults</name><environment>Graphics.CharacterAttributes</environment><private>false</private><constant>false</constant><category>ExtraEmphases</category><attributes><package>ExtraEmphases</package></attributes></shared-variable><shared-variable><name>SubscriptFlag</name><environment>Graphics.FontDescription</environment><private>false</private><constant>false</constant><category>ExtraEmphases</category><initializer>16r400000</initializer><attributes><package>ExtraEmphases</package></attributes></shared-variable><shared-variable><name>JaggedEdgeFlag</name><environment>Graphics.FontDescription</environment><private>false</private><constant>false</constant><category>ExtraEmphases</category><initializer>16r10000000</initializer><attributes><package>ExtraEmphases</package></attributes></shared-variable><shared-variable><name>SuperscriptFlag</name><environment>Graphics.FontDescription</environment><private>false</private><constant>false</constant><category>ExtraEmphases</category><initializer>16r200000</initializer><attributes><package>ExtraEmphases</package></attributes></shared-variable><shared-variable><name>JagMask</name><environment>ExtraEmphases.JaggedEdge</environment><private>false</private><constant>false</constant><category>JagMask</category><initializer>nil</initializer><attributes><package>ExtraEmphases</package></attributes></shared-variable><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>private</category><body package="ExtraEmphases">displayChars: string from: start to: stop at: aPoint on: aGraphicsContext 	| displayPoint |	displayPoint := aPoint.	start to: stop		do: 			[:charIndex | 			baseFont 				displayString: string				from: charIndex				to: charIndex				at: displayPoint				on: aGraphicsContext.			displayPoint := (self widthOf: (string at: charIndex)) @ 0 + displayPoint]</body><body package="ExtraEmphases">encodingType	^baseFont encodingType</body><body package="ExtraEmphases">getFontFor: aCharacter 	"Get the device font used for rendering this character."	^baseFont getFontFor: aCharacter</body><body package="ExtraEmphases">illegalCharacterWidth	^baseFont illegalCharacterWidth</body></methods><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>accessing</category><body package="ExtraEmphases">ascent	^baseFont ascent</body><body package="ExtraEmphases">baseFont: aFont 	baseFont := aFont</body><body package="ExtraEmphases">descent	^baseFont descent</body><body package="ExtraEmphases">encode: aCharacter 	^baseFont encode: aCharacter</body><body package="ExtraEmphases">fontDescription	^baseFont fontDescription</body><body package="ExtraEmphases">name	^baseFont name</body><body package="ExtraEmphases">unDecoratedFont	^baseFont unDecoratedFont</body><body package="ExtraEmphases">widthAt: index 	^baseFont widthAt: index</body><body package="ExtraEmphases">widthOf: aCharacter 	^baseFont widthOf: aCharacter</body><body package="ExtraEmphases">widthOfChar: char index: index inPlatformFont: platformFont	"If the baseFont changes the width, we want to take that into account too"	^baseFont widthOfChar: char index: index inPlatformFont: platformFont</body><body package="ExtraEmphases">widthOfString: aString from: aStart to: aStop 	| width |	width := 0.	aStart to: aStop do: [:i | width := width + (self widthOf: (aString at: i))].	^width</body><body package="ExtraEmphases">widthTable	^baseFont widthTable</body></methods><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>testing</category><body package="ExtraEmphases">isAccessible	"Answer whether the font can currently be used for display"	^baseFont isAccessible</body><body package="ExtraEmphases">isCompositeFont	^baseFont isCompositeFont</body><body package="ExtraEmphases">specifiesNativeStrikeout	^baseFont specifiesNativeStrikeout</body><body package="ExtraEmphases">specifiesNativeUnderline	^baseFont specifiesNativeUnderline</body></methods><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>Twoflower-compat</category><body package="ExtraEmphases">tfAsDeviceFont	^self asDeviceFont</body></methods><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>installing</category><body package="ExtraEmphases">installOn: aGraphicsContext 	"Install myself on the specified GraphicsContext."	baseFont installOn: aGraphicsContext</body></methods><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>converting</category><body package="ExtraEmphases">asDeviceFont	^baseFont asDeviceFont</body></methods><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>Unicode-Compat</category><body package="ExtraEmphases">selectFontForEncoding: aSymbol of: aString 	"With the Unicode parcel loaded, this message needs to be forwarded back to the	baseFont, which is a CompositeFont object"	^baseFont selectFontForEncoding: aSymbol of: aString</body></methods><methods><class-id>ExtraEmphases.DecoratedFont</class-id> <category>displaying</category><body package="ExtraEmphases">displayByteIndexedString: string from: start to: stop at: aPoint on: aGraphicsContext	self asDeviceFont displayByteIndexedString: string from: start to: stop at: aPoint on: aGraphicsContext</body><body package="ExtraEmphases">displayTwoByteString: string from: start to: stop at: aPoint on: aGraphicsContext	self asDeviceFont displayTwoByteString: string from: start to: stop at: aPoint on: aGraphicsContext</body><body package="ExtraEmphases">measureByteIndexedString: string from: start to: stop	^self asDeviceFont measureByteIndexedString: string from: start to: stop</body><body package="ExtraEmphases">measureTwoByteString: string from: start to: stop	^self asDeviceFont measureTwoByteString: string from: start to: stop</body></methods><methods><class-id>ExtraEmphases.DecoratedFont class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^aFont</body></methods><methods><class-id>ExtraEmphases.DecoratedFont class</class-id> <category>instance creation</category><body package="ExtraEmphases">on: aBaseFont 	^self new baseFont: aBaseFont</body></methods><methods><class-id>ExtraEmphases.DecoratedFont class</class-id> <category>class initialization</category><body package="ExtraEmphases">unDecorateAll	self 		allGeneralInstancesDo: [:each | each oneWayBecome: each unDecoratedFont]</body></methods><methods><class-id>ExtraEmphases.ResizedFont</class-id> <category>accessing</category><body package="ExtraEmphases">computeWidthTable	self subclassResponsibility</body><body package="ExtraEmphases">widthAt: index	^self widthTable at: index+1</body><body package="ExtraEmphases">widthOfChar: char index: index inPlatformFont: platformFont	^(self widthAt: index) ifNil: 		"Not quite brave enough to update from here, so don't cache the answer"		["self widthTable at: index+1 put:" (self widthOf: char)]</body><body package="ExtraEmphases">widthTable	^widthTable ifNil: [self computeWidthTable]</body></methods><methods><class-id>ExtraEmphases.ResizedFont</class-id> <category>private</category><body package="ExtraEmphases">drawGraphic: aGraphic at: aPoint on: aGC 	"Draw the graphic in the middle of the whole font height: we'd prefer to rest it on the baseline, but there is no way of knowing how high the line is (that information is in the TextAttributes), and guessing based on font ascent gives worse results than this way. This way runs the least risk of going outside the line. We could try clipping, but since TextLines doesn't bother, and mostly we just clip part of the image that didn't fit in the font height but would have fitted in the line height, why bother?"	| drawPoint |	drawPoint := aPoint x @ (aPoint y - self ascent - ((aGraphic preferredHeight - self height) // 2)).		"box := drawPoint extent: aGraphic extent x @ self height.		oldClip := aGC clippingRectangleOrNil.		aGC clippingRectangle: (oldClip ifNil: [box] ifNotNil: [oldClip intersect: box])."	aGraphic displayOn: aGC at: drawPoint.		"aGC clippingRectangle: oldClip."</body></methods><methods><class-id>ExtraEmphases.TrailingInsert</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self 		displayString: (String with: char)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	| pt delta |	pt := aPoint.	delta := graphic preferredWidth.	aStartIndex to: aStopIndex		do: 			[:i | 			baseFont 				displayString: aString				from: i				to: i				at: pt				on: aGC.			pt := (pt x + (self widthOf: (aString at: i))) @ pt y.			self drawGraphicAt: (pt x - delta) @ pt y on: aGC]</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	| pt delta |	pt := aPoint.	delta := graphic preferredWidth.	aStartIndex to: aStopIndex		do: 			[:i | 			baseFont 				displayString: aString				from: i				to: i				at: pt				on: aGC				map: aMap.			pt := (pt x + (self widthOf: (aString at: i))) @ pt y.			self drawGraphicAt: (pt x - delta) @ pt y on: aGC]</body></methods><methods><class-id>ExtraEmphases.TrailingInsert</class-id> <category>accessing</category><body package="ExtraEmphases">computeWidthTable	| extra |	widthTable := baseFont widthTable copy.	extra := graphic preferredWidth.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) + extra].	^widthTable</body><body package="ExtraEmphases">graphic	^graphic</body><body package="ExtraEmphases">graphic: anObject	graphic := anObject</body><body package="ExtraEmphases">widthOf: aCharacter 	^(super widthOf: aCharacter) + graphic preferredWidth</body></methods><methods><class-id>ExtraEmphases.TrailingInsert</class-id> <category>private</category><body package="ExtraEmphases">drawGraphicAt: aPoint on: aGraphicsContext 	self drawGraphic: graphic at: aPoint on: aGraphicsContext</body></methods><methods><class-id>ExtraEmphases.TrailingInsert class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #trailingInsert		put: [:query :value :fontPolicy | query trailingInsert: value]</body></methods><methods><class-id>ExtraEmphases.TrailingInsert class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription trailingInsert		ifNil: [aFont]		ifNotNil: [:graphic | (self on: aFont) graphic: graphic]</body></methods><methods><class-id>ExtraEmphases.Substitute</class-id> <category>accessing</category><body package="ExtraEmphases">computeWidthTable	| sameWidth |	widthTable := baseFont widthTable copy.	sameWidth := graphic preferredWidth.	"widthTable nonEmptyIndicesDo: [:i | widthTable at: i put: sameWidth]."widthTable atAllPut: sameWidth.	^widthTable</body><body package="ExtraEmphases">graphic	^graphic</body><body package="ExtraEmphases">graphic: anObject	graphic := anObject</body><body package="ExtraEmphases">widthOf: aCharacter 	^graphic preferredWidth</body></methods><methods><class-id>ExtraEmphases.Substitute</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self drawGraphicAt: aPoint on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	| pt delta |	pt := aPoint.	delta := graphic preferredWidth.	aStartIndex to: aStopIndex		do: 			[:ignored | 			self drawGraphicAt: pt on: aGC.			pt := (pt x + delta) @ pt y]</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	self 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC</body></methods><methods><class-id>ExtraEmphases.Substitute</class-id> <category>private</category><body package="ExtraEmphases">drawGraphicAt: aPoint on: aGC		graphic		displayOn: aGC		at:			aPoint x				@					(aPoint y - ((graphic preferredHeight + baseFont ascent) // 2))</body></methods><methods><class-id>ExtraEmphases.Substitute class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #substitute		put: [:query :value :fontPolicy | query substitute: value]</body></methods><methods><class-id>ExtraEmphases.Substitute class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription substitute		ifNil: [aFont]		ifNotNil: [:graphic | (self on: aFont) graphic: aFontDescription substitute]</body></methods><methods><class-id>ExtraEmphases.Underline</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: aCharacter at: aPoint on: aGC 	self 		displayString: (String with: aCharacter)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC.	self 		drawUnderlineFrom: aStartIndex		to: aStopIndex		under: aString		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC		map: aMap.	self 		drawUnderlineFrom: aStartIndex		to: aStopIndex		under: aString		at: aPoint		on: aGC</body></methods><methods><class-id>ExtraEmphases.Underline</class-id> <category>private</category><body package="ExtraEmphases">drawUnderlineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC 	| startP stopP oldWidth |	oldWidth := aGC lineWidth.	aGC lineWidth: self underlineThickness.	startP := aPoint + self underlinePosition.	stopP := (self 				widthOfString: aString				from: aStartIndex				to: aStopIndex) @ 0 				+ startP.	aGC displayLineFrom: startP to: stopP.	aGC lineWidth: oldWidth</body></methods><methods><class-id>ExtraEmphases.Underline</class-id> <category>accessing</category><body package="ExtraEmphases">underlinePosition	"Answer the position for a synthetic underline, relative to the left 	 edge of the baseline. Built-in windows fonts seem to need an	 underline 1 pixel below the baseline; Mac OS X fonts need 2, 	 so we defer this choice to the base font rather than guessing.	 The VW default synthetic underline is placed right at the bottom	 of the whole descent, which is clearly too low."	^baseFont underlinePosition</body></methods><methods><class-id>ExtraEmphases.Underline class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^(aFontDescription underline and: [aFont specifiesNativeUnderline not]) 		ifTrue: [self on: aFont]		ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.ColoredUnderline</class-id> <category>accessing</category><body package="ExtraEmphases">color	^color</body><body package="ExtraEmphases">color: anObject	color := anObject</body></methods><methods><class-id>ExtraEmphases.ColoredUnderline</class-id> <category>private</category><body package="ExtraEmphases">color: aGC while: aBlock 	"Change the color to that specified in this font"	| originalPaint defColors |	"If we are on Windows and displaying a selection, don't change color 	(i.e. use the already set selectionForeground color, probably white)"	"Windows-like, i.e. normal selected text is not the same color as normal text"	defColors := aGC medium defaultWidgetPolicy class defaultColorWidgetColors.	((defColors matchAt: SymbolicPaint selectionForeground ifAbsent: [ColorValue black]) ~= 	(defColors matchAt: SymbolicPaint foreground ifAbsent: [ColorValue black])		and: 	["Telling if we are in a selection is tricky, so we need to try a couple of ways"	"Scrolling and normal display in a TextView"	aGC paint == SymbolicPaint selectionForeground or:		["DataSet visuals for InputFieldView - see DataSetView&gt;&gt;displayVisualsOn:"		(aGC paintPreferencesMatchAt: SymbolicPaint selectionForeground) == 		(aGC paintPreferencesMatchAt: SymbolicPaint foreground)]]) 		ifTrue:	[aBlock value]		ifFalse:	[originalPaint := aGC paint.				aGC paint: self color.				aBlock ensure: [aGC paint: originalPaint]]</body><body package="ExtraEmphases">drawUnderlineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC	| oldPaint |	oldPaint := aGC paint.	aGC paint: color.	super		drawUnderlineFrom: aStartIndex		to: aStopIndex		under: aString		at: aPoint		on: aGC.	aGC paint: oldPaint</body></methods><methods><class-id>ExtraEmphases.ColoredUnderline class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #coloredUnderline		put: [:query :value :fontPolicy | query coloredUnderline: value]</body></methods><methods><class-id>ExtraEmphases.ColoredUnderline class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription coloredUnderline		ifNil: [aFont]		ifNotNil: [:paint | (self on: aFont) color: paint]</body></methods><methods><class-id>ExtraEmphases.ColoredDoubleUnderline</class-id> <category>private</category><body package="ExtraEmphases">drawUnderlineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC 	| startP stopP oldWidth |	super drawUnderlineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC .	self color: aGC while:		[oldWidth := aGC lineWidth.		aGC lineWidth: self underlineThickness.		stopP := (self 					widthOfString: aString					from: aStartIndex					to: aStopIndex) @ 0.		startP := aPoint + self underlinePosition.		aGC displayLineFrom: startP to: startP + stopP.		startP := aPoint + self doubleUnderlinePosition.		aGC displayLineFrom: startP to: startP + stopP.		aGC lineWidth: oldWidth]</body></methods><methods><class-id>ExtraEmphases.ColoredDoubleUnderline</class-id> <category>accessing</category><body package="ExtraEmphases">doubleUnderlinePosition	"Answer the position for a synthetic underline, relative to the left 	 edge of the baseline.  Built-in windows fonts seem to have an	 underline just below the baseline;  the synthetic underline that	 is used for colored underlines is normally placed at the descent,	 which is just too low."	^self underlinePosition + (0 @ 2)</body></methods><methods><class-id>ExtraEmphases.ColoredDoubleUnderline class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription coloredDoubleUnderline		ifNil: [aFont]		ifNotNil: [:paint | (self on: aFont) color: paint]</body><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #coloredDoubleUnderline		put: [:query :value :fontPolicy | query coloredDoubleUnderline: value]</body></methods><methods><class-id>Graphics.ExtendedFontDescription</class-id> <category>extended</category><body package="ExtraEmphases">extend: aSymbol with: anObject 	extensions at: aSymbol put: anObject</body><body package="ExtraEmphases">extensionAt: aSymbol ifNone: aBlock 	^extensions at: aSymbol ifAbsent: aBlock</body><body package="ExtraEmphases">removeExtension: aSymbol 	extensions removeKey: aSymbol ifAbsent: [].	extensions isEmpty ifTrue: [self unextend]</body></methods><methods><class-id>Graphics.ExtendedFontDescription</class-id> <category>comparing</category><body package="ExtraEmphases">= anFD 	^super = anFD and: [self hasSameExtensions: anFD]</body><body package="ExtraEmphases">hasSameExtensions: anExtendedFD 	| hisExtensions |	hisExtensions := anExtendedFD extensions.	hisExtensions size = extensions size ifFalse: [^false].	extensions keysAndValuesDo: 			[:key :value | 			(hisExtensions at: key ifAbsent: [^false]) = value ifFalse: [^false]].	^true</body><body package="ExtraEmphases">hash	| extensionHash |	extensionHash := 16rAAAAAAA.	extensions keysAndValuesDo: 		[:key :value | 			extensionHash := extensionHash bitXor:				(key hash bitXor: value hash)		].	^super hash bitXor: extensionHash</body></methods><methods><class-id>Graphics.ExtendedFontDescription</class-id> <category>private</category><body package="ExtraEmphases">unextend	| a |	a := self shallowCopy changeClassTo: Array.	self become: ((a copyFrom: 1 to: self class superclass instSize) 				changeClassTo: self class superclass)</body></methods><methods><class-id>Graphics.ExtendedFontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">extensions	^extensions</body></methods><methods><class-id>Graphics.ExtendedFontDescription</class-id> <category>copying</category><body package="ExtraEmphases">postCopy	super postCopy.	extensions := extensions copy.</body></methods><methods><class-id>Graphics.ExtendedFontDescription class</class-id> <category>class initialization</category><body package="ExtraEmphases">unExtendAll	self allInstancesDo: [:each | each unextend]</body></methods><methods><class-id>ExtraEmphases.UnderGraphic</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self 		displayString: (String with: char)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	self 		drawBehind: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC.	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	self 		drawBehind: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC.	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC		map: aMap</body><body package="ExtraEmphases">drawBehind: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	| box oldClip |	box := aPoint x @ (aPoint y - self ascent) 				extent: (self 						widthOfString: aString						from: aStartIndex						to: aStopIndex) @ self height.	oldClip := aGC clippingRectangleOrNil.	aGC clippingRectangle: (oldClip intersect: box).	visualBlock value: aGC value: box.	aGC clippingRectangle: oldClip</body></methods><methods><class-id>ExtraEmphases.UnderGraphic</class-id> <category>accessing</category><body package="ExtraEmphases">visualBlock	^visualBlock</body><body package="ExtraEmphases">visualBlock: anObject	visualBlock := anObject</body></methods><methods><class-id>ExtraEmphases.UnderGraphic class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #underGraphic		put: [:query :value :fontPolicy | query underGraphic: value]</body></methods><methods><class-id>ExtraEmphases.UnderGraphic class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription underGraphic		ifNil: [aFont]		ifNotNil: [:graphic | (self on: aFont) visualBlock: graphic]</body></methods><methods><class-id>ExtraEmphases.BackColor</class-id> <category>accessing</category><body package="ExtraEmphases">paint	^paint</body><body package="ExtraEmphases">paint: anObject	paint := anObject</body></methods><methods><class-id>ExtraEmphases.BackColor</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: aCharacter at: aPoint on: aGC 	self 		displayString: (String with: aCharacter)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGraphicsContext 	self 		drawRectangleBehind: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGraphicsContext.	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGraphicsContext</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGraphicsContext map: aMap 	self 		drawRectangleBehind: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGraphicsContext.	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGraphicsContext		map: aMap</body></methods><methods><class-id>ExtraEmphases.BackColor</class-id> <category>private</category><body package="ExtraEmphases">drawRectangleBehind: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	| box oldClip oldPaint |	box := aPoint x @ (aPoint y - baseFont ascent) 				corner: (aPoint x + (self 								widthOfString: aString								from: aStartIndex								to: aStopIndex)) 						@ (aPoint y + baseFont descent).	oldClip := aGC clippingRectangleOrNil.	aGC intersectClip: box.	oldPaint := aGC paint.	aGC paint: paint.	aGC displayRectangle: box.	aGC paint: oldPaint.	aGC clippingRectangle: oldClip</body></methods><methods><class-id>ExtraEmphases.BackColor class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #backColor		put: [:query :value :fontPolicy | query backColor: value]</body></methods><methods><class-id>ExtraEmphases.BackColor class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription backColor		ifNil: [aFont]		ifNotNil: [:color | (self on: aFont) paint: color]</body></methods><methods><class-id>ExtraEmphases.Subscript</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self translate: aGC		while: 			[baseFont 				displayCharacter: char				at: aPoint				on: aGC]</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGC 	self translate: aGC		while: 			[baseFont 				displayString: string				from: start				to: stop				at: aPoint				on: aGC]</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGC map: aMap 	self translate: aGC		while: 			[baseFont 				displayString: string				from: start				to: stop				at: aPoint				on: aGC				map: aMap]</body></methods><methods><class-id>ExtraEmphases.Subscript</class-id> <category>private</category><body package="ExtraEmphases">offset	^(self ascent + self descent) // 4</body><body package="ExtraEmphases">translate: aGC while: aBlock 	| originalTranslation |	originalTranslation := aGC translation.	aGC 		translation: originalTranslation x @ (originalTranslation y + self offset).	aBlock ensure: [aGC translation: originalTranslation]</body></methods><methods><class-id>ExtraEmphases.Subscript class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #subscript		put: 			[:query :value :fontPolicy | 			| size |			size := query pixelSize.			query				pixelSize: (size * 3 // 4 max: 1);				subscript: true]</body></methods><methods><class-id>ExtraEmphases.Subscript class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^aFontDescription subscript ifTrue: [self on: aFont] ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.DoubleUnderline</class-id> <category>private</category><body package="ExtraEmphases">drawUnderlineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC 	| startP stopP oldWidth |	super drawUnderlineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC .	oldWidth := aGC lineWidth.	aGC lineWidth: self underlineThickness.	stopP := (self 				widthOfString: aString				from: aStartIndex				to: aStopIndex) @ 0.	startP := aPoint + self underlinePosition.	aGC displayLineFrom: startP to: startP + stopP.	startP := aPoint + self doubleUnderlinePosition.	aGC displayLineFrom: startP to: startP + stopP.	aGC lineWidth: oldWidth</body></methods><methods><class-id>ExtraEmphases.DoubleUnderline</class-id> <category>accessing</category><body package="ExtraEmphases">doubleUnderlinePosition	"Answer the position for a synthetic underline, relative to the left 	 edge of the baseline.  Built-in windows fonts seem to have an	 underline just below the baseline;  the synthetic underline that	 is used for colored underlines is normally placed at the descent,	 which is just too low."	^self underlinePosition + (0 @ 2)</body></methods><methods><class-id>ExtraEmphases.DoubleUnderline class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #doubleUnderline		put: [:query :value :fontPolicy | query doubleUnderline: value]</body></methods><methods><class-id>ExtraEmphases.DoubleUnderline class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^(aFontDescription doubleUnderline) 		ifTrue: [self on: aFont]		ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.Shadow</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: aCharacter at: aPoint on: aGC 	self shadow: aGC		while: 			[baseFont 				displayCharacter: aCharacter				at: aPoint + 1				on: aGC].	baseFont 		displayCharacter: aCharacter		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	self shadow: aGC		while: 			[baseFont 				displayString: aString				from: aStartIndex				to: aStopIndex				at: aPoint + 1				on: aGC].	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	self shadow: aGC		while: 			[baseFont 				displayString: aString				from: aStartIndex				to: aStopIndex				at: aPoint + 1				on: aGC				map: aMap].	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC		map: aMap</body></methods><methods><class-id>ExtraEmphases.Shadow</class-id> <category>private</category><body package="ExtraEmphases">shadow: aGC while: aBlock 	| originalPaint |	originalPaint := aGC paint.	aGC paint: self color.	aBlock ensure: [aGC paint: originalPaint]</body></methods><methods><class-id>ExtraEmphases.Shadow</class-id> <category>accessing</category><body package="ExtraEmphases">color	^color</body><body package="ExtraEmphases">color: anObject	color := anObject</body></methods><methods><class-id>ExtraEmphases.Shadow class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #shadowed		put: [:query :value :fontPolicy | query shadowed: value]</body></methods><methods><class-id>ExtraEmphases.Shadow class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription shadowed		ifNil: [aFont]		ifNotNil: [:paint | (self on: aFont) color: paint]</body></methods><methods><class-id>ExtraEmphases.JaggedEdge</class-id> <category>private</category><body package="ExtraEmphases">drawJaglineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC 	| startPoint box oldClip y extent |	startPoint := aPoint + (0 @ baseFont descent // 2).	extent := (self 				widthOfString: aString				from: aStartIndex				to: aStopIndex) @ JagMask height.	box := startPoint extent: extent.	oldClip := aGC clippingRectangleOrNil.	aGC intersectClip: box.	y := box top.	box origin x // self class jagStride * self class jagStride 		to: box corner x		by: JagMask width		do: [:x | aGC display: JagMask at: x @ y].	aGC clippingRectangle: oldClip</body></methods><methods><class-id>ExtraEmphases.JaggedEdge</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self 		displayString: (String with: char)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGraphicsContext 	baseFont 		displayString: string		from: start		to: stop		at: aPoint		on: aGraphicsContext.	self 		drawJaglineFrom: start		to: stop		under: string		at: aPoint		on: aGraphicsContext</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGraphicsContext map: aMap 	baseFont 		displayString: string		from: start		to: stop		at: aPoint		on: aGraphicsContext		map: aMap.	self 		drawJaglineFrom: start		to: stop		under: string		at: aPoint		on: aGraphicsContext</body></methods><methods><class-id>ExtraEmphases.JaggedEdge class</class-id> <category>class initialization</category><body package="ExtraEmphases">initJagMask	| y |	JagMask := Image 				extent: 100 @ 2				depth: 1				palette: CoveragePalette monoMaskPalette.	y := 0.	0 to: JagMask width		by: self jagStride		do: 			[:x | 			0 to: self jagStride - 1				do: 					[:n | 					JagMask 						atX: x + n						y: y						put: 1].			y := y = 0 ifTrue: [1] ifFalse: [0]]</body><body package="ExtraEmphases">initialize	"self initialize"	self initJagMask.	CharacterAttributes defaultsAt: #jaggedEdge		put: [:query :value :fontPolicy | query jaggedEdge: true]</body><body package="ExtraEmphases">jagStride	^2</body></methods><methods><class-id>ExtraEmphases.JaggedEdge class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^aFontDescription jaggedEdge ifTrue: [self on: aFont] ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.Overline</class-id> <category>private</category><body package="ExtraEmphases">drawOverlineFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC 	| startP stopP oldWidth |	oldWidth := aGC lineWidth.	aGC lineWidth: self overlineThickness.	startP := aPoint + self overlinePosition.	stopP := (self 				widthOfString: aString				from: aStartIndex				to: aStopIndex) @ 0 				+ startP.	aGC displayLineFrom: startP to: stopP.	aGC lineWidth: oldWidth</body></methods><methods><class-id>ExtraEmphases.Overline</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: aCharacter at: aPoint on: aGC 	self 		displayString: (String with: aCharacter)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC.	self 		drawOverlineFrom: aStartIndex		to: aStopIndex		under: aString		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC		map: aMap.	self 		drawOverlineFrom: aStartIndex		to: aStopIndex		under: aString		at: aPoint		on: aGC</body></methods><methods><class-id>ExtraEmphases.Overline class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^aFontDescription overline ifTrue: [self on: aFont] ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.Overline class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #overline		put: [:query :value :fontPolicy | query overline: true]</body></methods><methods><class-id>ExtraEmphases.Superscript</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self translate: aGC		while: 			[baseFont 				displayCharacter: char				at: aPoint				on: aGC]</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGC 	self translate: aGC		while: 			[baseFont 				displayString: string				from: start				to: stop				at: aPoint				on: aGC]</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGC map: aMap 	self translate: aGC		while: 			[baseFont 				displayString: string				from: start				to: stop				at: aPoint				on: aGC				map: aMap]</body></methods><methods><class-id>ExtraEmphases.Superscript</class-id> <category>private</category><body package="ExtraEmphases">offset	^(self ascent + self descent) * 3 // 4</body><body package="ExtraEmphases">translate: aGC while: aBlock 	| originalTranslation |	originalTranslation := aGC translation.	aGC 		translation: originalTranslation x @ (originalTranslation y - self offset).	aBlock ensure: [aGC translation: originalTranslation]</body></methods><methods><class-id>ExtraEmphases.Superscript class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #superscript		put: 			[:query :value :fontPolicy | 			| size |			size := query pixelSize.			query				pixelSize: (size * 3 // 4 max: 1);				superscript: true]</body></methods><methods><class-id>ExtraEmphases.Superscript class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^aFontDescription superscript ifTrue: [self on: aFont] ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.BackHalf</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	baseFont 		displayCharacter: char		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGraphicsContext 	baseFont 		displayString: string		from: start		to: stop		at: aPoint		on: aGraphicsContext</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGraphicsContext map: aMap 	baseFont 		displayString: string		from: start		to: stop		at: aPoint		on: aGraphicsContext		map: aMap</body></methods><methods><class-id>ExtraEmphases.BackHalf</class-id> <category>accessing</category><body package="ExtraEmphases">computeWidthTable	widthTable := baseFont widthTable copy.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) // 2].	^widthTable</body><body package="ExtraEmphases">widthOf: aCharacter 	^(baseFont widthOf: aCharacter) // 2</body></methods><methods><class-id>ExtraEmphases.BackHalf class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #backHalf		put: [:query :value :fontPolicy | query backHalf: true]</body></methods><methods><class-id>ExtraEmphases.BackHalf class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^aFontDescription backHalf ifTrue: [self on: aFont] ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.LeadingInsert</class-id> <category>accessing</category><body package="ExtraEmphases">computeWidthTable	| extra |	widthTable := baseFont widthTable copy.	extra := self extraWidth.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) + extra].	^widthTable</body><body package="ExtraEmphases">extraWidth	^graphic preferredWidth</body><body package="ExtraEmphases">graphic	^graphic</body><body package="ExtraEmphases">graphic: anObject	graphic := anObject</body><body package="ExtraEmphases">widthOf: aCharacter 	^(super widthOf: aCharacter) + self extraWidth</body></methods><methods><class-id>ExtraEmphases.LeadingInsert</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self 		displayString: (String with: char)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	| pt delta |	pt := aPoint.	delta := self extraWidth.	aStartIndex to: aStopIndex		do: 			[:i | 			self drawGraphicAt: pt on: aGC.			baseFont 				displayString: aString				from: i				to: i				at: (pt x + delta) @ aPoint y				on: aGC.			pt := (pt x + (self widthOf: (aString at: i))) @ pt y]</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	| pt delta |	pt := aPoint.	delta := self extraWidth.	aStartIndex to: aStopIndex		do: 			[:i | 			self drawGraphicAt: pt on: aGC.			baseFont 				displayString: aString				from: i				to: i				at: (pt x + delta) @ aPoint y				on: aGC				map: aMap.			pt := (pt x + (self widthOf: (aString at: i))) @ pt y]</body></methods><methods><class-id>ExtraEmphases.LeadingInsert</class-id> <category>private</category><body package="ExtraEmphases">drawGraphicAt: aPoint on: aGraphicsContext 	self drawGraphic: graphic at: aPoint on: aGraphicsContext</body></methods><methods><class-id>ExtraEmphases.LeadingInsert class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"		#{OneshotProbe} isDefined		ifTrue: [self initializeProbesWithOneshots]		ifFalse: [self initializeProbesLegacy].	CharacterAttributes		defaultsAt: #leadingInsert		put: [:query :value :fontPolicy | query leadingInsert: value]</body><body package="ExtraEmphases">initializeProbesLegacy	"self initializeProbesLegacy"		| cachedGraphic |	cachedGraphic := self stopImage.	CharacterAttributes		defaultsAt: #probe		put: [:query :value :fontPolicy | query leadingInsert: cachedGraphic].	CharacterAttributes		defaultsAt: #tempProbe		put: [:query :value :fontPolicy | query leadingInsert: cachedGraphic]</body><body package="ExtraEmphases">initializeProbesWithOneshots	"self initializeProbesWithOneshots"	"It would be nice to just have one emphasis and let the probe dynamically answer the right graphic, problem is that these are cached and queried against, so they can't really be dynamic."	CharacterAttributes defaultsAt: #probe		put: [:query :value :fontPolicy | query leadingInsert: value baseParent breakpointGlyph].	CharacterAttributes defaultsAt: #tempProbe		put: [:query :value :fontPolicy | query leadingInsert: value baseParent breakpointGlyph].	CharacterAttributes defaultsAt: #armedOneshotProbe		put: [:query :value :fontPolicy | query leadingInsert: value baseParent breakpointGlyph].	CharacterAttributes defaultsAt: #disarmedOneshotProbe		put: [:query :value :fontPolicy | query leadingInsert: value baseParent breakpointGlyph]</body></methods><methods><class-id>ExtraEmphases.LeadingInsert class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription leadingInsert		ifNil: [aFont]		ifNotNil: [:graphic | (self on: aFont) graphic: graphic]</body></methods><methods><class-id>ExtraEmphases.LeadingInsertSpace</class-id> <category>accessing</category><body package="ExtraEmphases">extraWidth	^graphic preferredWidth + (baseFont widthOf: Character space)</body></methods><methods><class-id>ExtraEmphases.LeadingInsertSpace class</class-id> <category>class initialization</category><body package="ExtraEmphases">initialize	"self initialize"	CharacterAttributes defaultsAt: #leadingInsertSpace		put: [:query :value :fontPolicy | query leadingInsertSpace: value]</body></methods><methods><class-id>ExtraEmphases.LeadingInsertSpace class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription leadingInsertSpace		ifNil: [aFont]		ifNotNil: [:graphic | (self on: aFont) graphic: graphic]</body></methods><methods><class-id>ExtraEmphases.Strikeout</class-id> <category>private</category><body package="ExtraEmphases">drawStrikeoutFrom: aStartIndex to: aStopIndex under: aString at: aPoint on: aGC 	| startP stopP oldWidth |	oldWidth := aGC lineWidth.	aGC lineWidth: self strikeoutThickness.	startP := aPoint + self strikeoutPosition.	stopP := (self 				widthOfString: aString				from: aStartIndex				to: aStopIndex) @ 0 				+ startP.	aGC displayLineFrom: startP to: stopP.	aGC lineWidth: oldWidth</body></methods><methods><class-id>ExtraEmphases.Strikeout</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: aCharacter at: aPoint on: aGC 	self 		displayString: (String with: aCharacter)		from: 1		to: 1		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC 	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC.	self 		drawStrikeoutFrom: aStartIndex		to: aStopIndex		under: aString		at: aPoint		on: aGC</body><body package="ExtraEmphases">displayString: aString from: aStartIndex to: aStopIndex at: aPoint on: aGC map: aMap 	baseFont 		displayString: aString		from: aStartIndex		to: aStopIndex		at: aPoint		on: aGC		map: aMap.	self 		drawStrikeoutFrom: aStartIndex		to: aStopIndex		under: aString		at: aPoint		on: aGC</body></methods><methods><class-id>ExtraEmphases.Strikeout class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont 	^(aFontDescription strikeout and: [aFont specifiesNativeStrikeout not]) 		ifTrue: [self on: aFont]		ifFalse: [aFont]</body></methods><methods><class-id>ExtraEmphases.ColoredFont</class-id> <category>accessing</category><body package="ExtraEmphases">color	^color</body><body package="ExtraEmphases">color: anObject	color := anObject</body></methods><methods><class-id>ExtraEmphases.ColoredFont</class-id> <category>displaying</category><body package="ExtraEmphases">displayCharacter: char at: aPoint on: aGC 	self color: aGC		while: 			[baseFont 				displayCharacter: char				at: aPoint				on: aGC]</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGC 	self color: aGC		while: 			[baseFont 				displayString: string				from: start				to: stop				at: aPoint				on: aGC]</body><body package="ExtraEmphases">displayString: string from: start to: stop at: aPoint on: aGC map: aMap 	self color: aGC		while: 			[baseFont 				displayString: string				from: start				to: stop				at: aPoint				on: aGC				map: aMap]</body></methods><methods><class-id>ExtraEmphases.ColoredFont</class-id> <category>private</category><body package="ExtraEmphases">color: aGC while: aBlock 	"Change the color to that specified in this font"	| originalPaint defColors |	"If we are on Windows and displaying a selection, don't change color 	(i.e. use the already set selectionForeground color, probably white)"	"Windows-like, i.e. normal selected text is not the same color as normal text"	defColors := aGC medium defaultWidgetPolicy class defaultColorWidgetColors.	((defColors matchAt: SymbolicPaint selectionForeground ifAbsent: [ColorValue black]) ~= 	(defColors matchAt: SymbolicPaint foreground ifAbsent: [ColorValue black])		and: 	["Telling if we are in a selection is tricky, so we need to try a couple of ways"	"Scrolling and normal display in a TextView"	aGC paint == SymbolicPaint selectionForeground or:		["DataSet visuals for InputFieldView - see DataSetView&gt;&gt;displayVisualsOn:"		(aGC paintPreferencesMatchAt: SymbolicPaint selectionForeground) == 		(aGC paintPreferencesMatchAt: SymbolicPaint foreground)]]) 		ifTrue:	[aBlock value]		ifFalse:	[originalPaint := aGC paint.				aGC paint: self color.				aBlock ensure: [aGC paint: originalPaint]]</body></methods><methods><class-id>ExtraEmphases.ColoredFont class</class-id> <category>decorating</category><body package="ExtraEmphases">apply: aFontDescription to: aFont	^aFontDescription color		ifNil: [aFont]		ifNotNil: [:paint | (self on: aFont) color: paint]</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>ExtraEmphases</category><body package="ExtraEmphases">addDefaultColors	| colors |	colors := Dictionary new.	ColorValue constantNames do: 			[:each | 			colors at: each				put: [:query :value :fontPolicy | query color: (ColorValue perform: each)]].	self defaultsAddAll: colors</body><body package="ExtraEmphases">addSize	self defaultsAt: #pixelSize		put: [:query :value :fontPolicy | query pixelSize: value]</body><body package="ExtraEmphases">defaultsAddAll: aDictionary 	aDictionary 		keysAndValuesDo: [:key :value | self extraDefaults at: key put: value].	self allGeneralInstancesDo: 			[:each | 			aDictionary keysAndValuesDo: [:key :value | each at: key put: value]]</body><body package="ExtraEmphases">defaultsAt: aKey put: aValue 	self defaultsAddAll: (Dictionary with: aKey -&gt; aValue)</body><body package="ExtraEmphases">extraDefaults	^#{DefaultAttributes} ifDefinedDo: [:obj | obj]		elseDo: 			[ExtraDefaults == nil ifTrue: [ExtraDefaults := Dictionary new].			ExtraDefaults]</body><body package="ExtraEmphases">fixFamily	self defaultsAt: #family		put: 			[:query :family | 			query				family: family;				manufacturer: nil;				encoding: nil]</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>instance creation</category><body package="ExtraEmphases">newWithDefaultAttributes	^#{DefaultAttributes} 		ifDefinedDo: [:attributes | self new sharedAttributes: attributes]		elseDo: [self newWithDefaultAttributesFor72AndEarlier]</body><body package="ExtraEmphases">newWithDefaultAttributesFor72AndEarlier	| style |	style := self new.	"Compute small and large sizes by ratios.  6/5 (1.2) and 5/4 (1.25) are good choices.	Ensure sizes differ by at least a point."	style at: #small		put: 			[:query :value :fontPolicy | 			| size |			size := (style defaultFontFor: fontPolicy) pixelSize.			query pixelSize: ((size * 5 / 6) rounded min: size - 1)].	style at: #large		put: 			[:query :value :fontPolicy | 			| size |			size := (style defaultFontFor: fontPolicy) pixelSize.			query pixelSize: ((size * 6 / 5) rounded max: size + 1)].	style at: #serif put: [:query | query serif: true].	style at: #sansSerif put: [:query | query serif: false].	style at: #normal		put: 			[:query | 			query				boldness: 0.5;				italic: false].	style at: #bold put: [:query | query boldness: 0.7].	style at: #italic put: [:query | query italic: true].	style at: #underline put: [:query | query underline: true].	style at: #strikeout put: [:query | query strikeout: true].	style at: #color put: [:query :color | query color: color].	style at: #family put: [:query :family | query family: family].	style at: #TITLE put: [:query | query boldness: 0.7].	style at: #H1		put: 			[:query :fontPolicy | 			| size |			size := (style defaultFontFor: fontPolicy) pixelSize.			query				pixelSize: size + 6;				boldness: 0.6;				family: 'times'].	"style at: #H1 put: [:query | query pixelSize: 18; boldness: 0.6; family: 'times']."	style at: #H2		put: 			[:query | 			query				pixelSize: 14;				boldness: 0.8;				family: 'times'].	style at: #H3		put: 			[:query | 			query				pixelSize: 14;				boldness: 0.6;				family: 'times'].	style at: #H4		put: 			[:query | 			query				pixelSize: 12;				boldness: 0.8;				family: 'times'].	style at: #H5		put: 			[:query | 			query				pixelSize: 12;				boldness: 0.6;				family: 'times'].	style at: #H6		put: 			[:query | 			query				pixelSize: 10;				boldness: 0.6;				family: 'times'].	style at: #STRONG		put: 			[:query | 			query				boldness: 0.7;				family: 'times'].	style at: #EM		put: 			[:query | 			query				italic: true;				family: 'times'].	style at: #CODE put: [:query | query family: 'courier'].	style at: #KBD put: [:query | query family: 'courier'].	style at: #VAR		put: 			[:query | 			query				italic: true;				family: 'times'].	style at: #SAMP put: [:query | query family: 'courier'].	style at: #DEF put: [:query | query family: 'times'].	style at: #CITE		put: 			[:query | 			query				italic: true;				family: 'times'].	style at: #TT put: [:query | query family: 'courier'].	self extraDefaults 		keysAndValuesDo: [:key :value | style at: key put: value].	^style</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>ExtraEmphases</category><body package="ExtraEmphases">removeAllDefaults	self removeDefaultKeys: self extraDefaults keys</body><body package="ExtraEmphases">removeDefaultKey: aKey 	self removeDefaultKeys: (Array with: aKey)</body><body package="ExtraEmphases">removeDefaultKeys: aCollection 	aCollection do: [:key | self extraDefaults removeKey: key ifAbsent: []].	self 		allGeneralInstancesDo: [:each | aCollection do: [:key | each removeKey: key]]</body></methods><methods><class-id>Graphics.CharacterAttributes</class-id> <category>accessing</category><body package="ExtraEmphases">removeKey: aKey 	"it's possible when swapping looks to end up with instances that have no attributes, protect against that"	(aKey isSymbol and: [attributes ~~ nil]) 		ifTrue: 			[attributes removeKey: aKey ifAbsent: [].			self invalidateQueryCache]</body></methods><methods><class-id>Graphics.FontPolicy</class-id> <category>utilities</category><body package="ExtraEmphases">decorateFont: aFont with: aFontDescription 	| decorated |	decorated := aFont.	ExtraEmphases.AdornedFont allSubclasses do: 			[:each | 			decorated := [each apply: aFontDescription to: decorated] on: Error						do: [:ex | ex returnWith: decorated]].	ExtraEmphases.WarpedFont allSubclasses do: 			[:each | 			decorated := [each apply: aFontDescription to: decorated] on: Error						do: [:ex | ex returnWith: decorated]].	^decorated</body><body package="ExtraEmphases">findFont: aFontDescription 	"Answer the nearest font from those available on this device	to the requested FontDescription"	| font bestMatch |	fdCache = aFontDescription ifTrue: [^dfCache].	font := fontCache at: aFontDescription ifAbsent: [nil].	font == nil 		ifFalse: 			[fdCache := aFontDescription copy.			dfCache := font.			^font].	bestMatch := self findBestFont: aFontDescription.	aFontDescription isComposite 		ifTrue: 			[font := CompositeFont 						createFont: bestMatch						toResemble: aFontDescription						for: self]		ifFalse: 			[font := fontClass 						createFont: bestMatch						toResemble: aFontDescription						on: device].	font := self decorateFont: font with: aFontDescription.	fontCache at: aFontDescription copy put: font.	fdCache := aFontDescription.	dfCache := font.	^font</body><body package="ExtraEmphases">resetFontCache	fontCache := Dictionary new</body></methods><methods><class-id>Core.TextStream</class-id> <category>extra emphases</category><body package="ExtraEmphases">currentEmphases	currentEmphasis ifNil: [^Array new].	^(currentEmphasis isSequenceable and: [currentEmphasis isSymbol not]) 		ifTrue: [currentEmphasis]		ifFalse: [Array with: currentEmphasis]</body><body package="ExtraEmphases">deemphasize: anObject 	| newEmphases |	(anObject isSequenceable and: [anObject isSymbol not]) 		ifTrue: 			[anObject do: [:each | self deemphasize: each].			^self].	newEmphases := self currentEmphases.	(newEmphases includes: anObject) ifFalse: [^self].	newEmphases := newEmphases copyWithout: anObject.	self emphasis: (newEmphases isEmpty 				ifTrue: [nil]				ifFalse: 					[newEmphases size = 1 ifTrue: [newEmphases first] ifFalse: [newEmphases]])</body><body package="ExtraEmphases">deemphasize: anObject while: aBlock 	| originalEmphasis |	originalEmphasis := currentEmphasis.	self deemphasize: anObject.	aBlock ensure: [self emphasis: originalEmphasis]</body><body package="ExtraEmphases">emphasize: anObject 	| newEmphases |	(anObject isSequenceable and: [anObject isSymbol not]) 		ifTrue: 			[anObject do: [:each | self emphasize: each].			^self].	newEmphases := self currentEmphases.	(newEmphases includes: anObject) ifTrue: [^self].	newEmphases := newEmphases copyWith: anObject.	self emphasis: (newEmphases size = 1 				ifTrue: [newEmphases first]				ifFalse: [newEmphases])</body><body package="ExtraEmphases">emphasize: anObject while: aBlock 	| originalEmphasis |	originalEmphasis := currentEmphasis.	self emphasize: anObject.	aBlock ensure: [self emphasis: originalEmphasis]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">backColor	^self extensionAt: #backColor ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">backColor: aPaint 	aPaint ifNil: [self removeExtension: #backColor]		ifNotNil: [self extend: #backColor with: aPaint]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">backHalf	^self extensionAt: #backHalf ifNone: [false]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">backHalf: aBoolean 	aBoolean 		ifTrue: [self extend: #backHalf with: true]		ifFalse: [self removeExtension: #backHalf]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">coloredDoubleUnderline	^self extensionAt: #coloredDoubleUnderline ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">coloredDoubleUnderline: aPaint 	aPaint ifNil: [self removeExtension: #coloredDoubleUnderline]		ifNotNil: [self extend: #coloredDoubleUnderline with: aPaint]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">coloredUnderline	^self extensionAt: #coloredUnderline ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">coloredUnderline: aPaint 	aPaint ifNil: [self removeExtension: #coloredUnderline]		ifNotNil: [self extend: #coloredUnderline with: aPaint]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">doubleUnderline	^self extensionAt: #doubleUnderline ifNone: [false]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">doubleUnderline: aBoolean 	aBoolean 		ifTrue: [self extend: #doubleUnderline with: true]		ifFalse: [self removeExtension: #doubleUnderline]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>extended</category><body package="ExtraEmphases">extend: aSymbol with: anObject 	| a |	a := (self shallowCopy changeClassTo: Array) 				copyWith: (Dictionary with: aSymbol -&gt; anObject).	self become: (a changeClassTo: ExtendedFontDescription)</body><body package="ExtraEmphases">extensionAt: aSymbol ifNone: aBlock 	^aBlock value</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">jaggedEdge	^(flags bitAnd: JaggedEdgeFlag) &gt; 0</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">jaggedEdge: aBooleanOrNil 	aBooleanOrNil == nil 		ifTrue: 			[masks := masks maskClear: JaggedEdgeFlag.			^self].	masks := masks bitOr: JaggedEdgeFlag.	flags := aBooleanOrNil 				ifTrue: [flags bitOr: JaggedEdgeFlag]				ifFalse: [flags maskClear: JaggedEdgeFlag]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">leadingInsert	^self extensionAt: #leadingInsert ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">leadingInsert: aVisualComponent 	aVisualComponent ifNil: [self removeExtension: #leadingInsert]		ifNotNil: [self extend: #leadingInsert with: aVisualComponent]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">leadingInsertSpace	^self extensionAt: #leadingInsertSpace ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">leadingInsertSpace: aVisualComponent 	aVisualComponent ifNil: [self removeExtension: #leadingInsertSpace]		ifNotNil: [self extend: #leadingInsertSpace with: aVisualComponent]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">overline	^self extensionAt: #overline ifNone: [false]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">overline: aBoolean 	aBoolean 		ifTrue: [self extend: #overline with: true]		ifFalse: [self removeExtension: #overline]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>extended</category><body package="ExtraEmphases">removeExtension: aSymbol</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">shadowed	^self extensionAt: #shadowed ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">shadowed: aColorValue 	aColorValue ifNil: [self removeExtension: #shadowed]		ifNotNil: [self extend: #shadowed with: aColorValue]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">subscript	^(flags bitAnd: SubscriptFlag) &gt; 0</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">subscript: aBooleanOrNil 	aBooleanOrNil == nil 		ifTrue: 			[masks := masks maskClear: SubscriptFlag.			^self].	masks := masks bitOr: SubscriptFlag.	flags := aBooleanOrNil 				ifTrue: [flags bitOr: SubscriptFlag]				ifFalse: [flags maskClear: SubscriptFlag]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">substitute	^self extensionAt: #substitute ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">substitute: aVisualComponent 	aVisualComponent ifNil: [self removeExtension: #substitute]		ifNotNil: [self extend: #substitute with: aVisualComponent]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">superscript	^(flags bitAnd: SuperscriptFlag) &gt; 0</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">superscript: aBooleanOrNil 	aBooleanOrNil == nil 		ifTrue: 			[masks := masks maskClear: SuperscriptFlag.			^self].	masks := masks bitOr: SuperscriptFlag.	flags := aBooleanOrNil 				ifTrue: [flags bitOr: SuperscriptFlag]				ifFalse: [flags maskClear: SuperscriptFlag]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">trailingInsert	^self extensionAt: #trailingInsert ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">trailingInsert: aVisualComponent 	aVisualComponent ifNil: [self removeExtension: #trailingInsert]		ifNotNil: [self extend: #trailingInsert with: aVisualComponent]</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="ExtraEmphases">underGraphic	^self extensionAt: #underGraphic ifNone: []</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="ExtraEmphases">underGraphic: aBlock 	aBlock ifNil: [self removeExtension: #underGraphic]		ifNotNil: [self extend: #underGraphic with: aBlock]</body></methods><methods><class-id>Graphics.DeviceFont</class-id> <category>converting</category><body package="ExtraEmphases">asDeviceFont	^self</body></methods><methods><class-id>Graphics.DisplayScanner</class-id> <category>stop conditions</category><body package="ExtraEmphases">characterNotInFont	"All fonts have an illegal character to be used when a character is 	not within the font's legal range. When characters outside of the legal range 	are encountered while scanning text, then this special character 	indicates the appropriate behavior. The character is usually treated 	as a unary message understood by a subclass of CharacterScanner."	| char |	char := string at: lastIndex.	font displayCharacter: char at: destX@lineY on: graphicsContext.	^super characterNotInFont</body></methods><methods><class-id>Graphics.ImplementationFont</class-id> <category>accessing</category><body package="ExtraEmphases">overlinePosition	^0 @ self ascent negated</body><body package="ExtraEmphases">overlineThickness	^(self ascent / 10) rounded max: 1</body></methods><methods><class-id>Graphics.ImplementationFont</class-id> <category>converting</category><body package="ExtraEmphases">removeDecorated	"recursion stopper"</body></methods><methods><class-id>Graphics.ImplementationFont</class-id> <category>testing</category><body package="ExtraEmphases">specifiesNativeStrikeout	^false</body><body package="ExtraEmphases">specifiesNativeUnderline	^false</body></methods><methods><class-id>Graphics.ImplementationFont</class-id> <category>accessing</category><body package="ExtraEmphases">unDecoratedFont	^self</body><body package="ExtraEmphases">widthOfChar: char index: index inPlatformFont: platformFont	"Implement this message with all possible arguments so we can have the quick answer from the platform font, or allow the ImplementationFont subclass to override to specify its own calculation"	^platformFont widthAt: index</body></methods><methods><class-id>Graphics.MSWindowsFont</class-id> <category>testing</category><body package="ExtraEmphases">specifiesNativeStrikeout	^true</body><body package="ExtraEmphases">specifiesNativeUnderline	^true</body></methods><methods><class-id>Graphics.TextMeasurer</class-id> <category>private</category><body package="ExtraEmphases">scanCharactersFrom: start to: stop in: sourceString rightX: rightX stopConditions: stops 	"This is the workhorse for text measuring. startIndex and stopIndex 	are indices (inclusive) in the string being measured, the byteString. 	codeMap is a WordArray of size 256 that maps character codes in the 	string to indices in the width table. 		The method also uses three instance variables of the receiver: 	destX, widthTable, and lastIndex. destX is a SmallInteger that 	represents the initial X position when the method is invoked, and 	that is set to the final X position when the method exits. 	widthTable is an Array of 256 elements, indexed by character codes 	mapped through the codeMap: each entry is a SmallInteger that 	represents the width of the character. lastIndex is set by the 	method to the index in the string of the last character scanned. 		The scanning loop fetches successive characters from the string and 	indexes into the codeMap. If the entry in the codeMap is 256 or 	greater, the method exits, returning the (unmapped) character 	code. If destX + the widthTable 	entry &gt; rightX, the method exits (without incrementing lastIndex), 	returning 257. Otherwise, the method increments lastIndex and 	continues. If the method scans the entire string successfully, it sets 	lastIndex to stopIndex and returns 256.	If the string being scanned is a GapString the concret indexes are assumed to	not span a gap."	^(sourceString isString and: [sourceString isByteIndexed and: [font isCompositeFont not]])		ifTrue: [| result cstart  delta|				cstart := sourceString concreteIndexFor: start.				delta := cstart - start.				result := self					primScanCharactersFrom: cstart					to: stop + delta					in: sourceString concreteString					rightX: rightX					stopConditions: stops					widths: widthTable.				lastIndex := lastIndex - delta.				result]		ifFalse: 			[			lastIndex := start.			[lastIndex &lt;= stop]				whileTrue: 					[| char nextDestX newAscii platformFont |					char := sourceString at: lastIndex.					char isInteger						ifTrue:	[newAscii := char.								char := font decode: newAscii.								platformFont := font getFontFor: char]						ifFalse:	[platformFont := font getFontFor: char.								newAscii := platformFont encode: char].					(self stopConditions includesKey: char)						ifTrue:	[^sourceString stringEncoding encode: char].					newAscii == 65535						ifTrue: [^sourceString stringEncoding encode: char].					"ExtraEmphases change: allow either the font or platform font to decide the width"					nextDestX := destX + (font widthOfChar: char index: newAscii inPlatformFont: platformFont).					nextDestX &gt; rightX ifTrue: [^CrossedX].					destX := nextDestX.					lastIndex := lastIndex + 1].			lastIndex := stop.			EndOfRun]</body></methods><methods><class-id>Core.Text</class-id> <category>private-accessing</category><body package="ExtraEmphases">addAllBold	self 		addEmphasis: #(#bold)		removeEmphasis: #()		allowDuplicates: false</body></methods><methods><class-id>ExtraEmphases.Substitute class</class-id> <category>resources</category><body package="ExtraEmphases">smiley	"UIMaskEditor new openOnClass: self andSelector: #smiley"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue yellow; at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[170 128 2 170 168 21 84 42 161 85 85 74 133 85 85 82 133 69 81 82 21 1 64 84 21 69 81 84 21 85 85 84 20 85 85 20 16 85 85 4 20 21 84 20 133 5 80 82 133 64 1 82 161 85 85 74 168 21 84 42 170 128 2 170])))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[7 224 0 0 31 248 0 0 63 252 0 0 127 254 0 0 127 254 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 127 254 0 0 127 254 0 0 63 252 0 0 31 248 0 0 7 224 0 0])))</body></methods><methods><class-id>ExtraEmphases.LeadingInsert class</class-id> <category>resources</category><body package="ExtraEmphases">stopImage	"UIMaskEditor new openOnClass: self andSelector: #stopImage"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 6135 scaledBlue: 6135); at: 4 put: Graphics.ColorValue green; at: 5 put: Graphics.ColorValue red; at: 6 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 0 scaledBlue: 0); yourself)) usingBits: #[51 51 18 34 34 36 51 51 51 49 68 68 68 68 67 51 51 20 68 68 68 68 68 51 49 68 68 68 68 68 68 67 20 68 68 68 68 68 68 68 33 17 65 17 65 20 17 69 33 68 68 20 20 20 20 21 36 20 68 20 20 20 20 21 36 65 68 20 20 20 17 69 33 65 68 20 20 20 20 69 33 17 68 20 17 68 20 69 36 68 68 68 68 68 68 64 52 68 68 68 68 68 68 3 51 68 68 68 68 68 64 51 51 52 68 68 68 68 3 51 51 51 69 85 85 80 51 51])))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 240 0 0 31 248 0 0 63 252 0 0 127 254 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0])))</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>class initialization</category><body package="ExtraEmphases">addAdditionalExtraEmphasesStyles: aDictionary	&lt;stylesWithOrder: 100&gt;	aDictionary		at: #family		put:			[:query :value | 			query				family: value;				manufacturer: nil;				encoding: nil].	aDictionary		at: #pixelSize		put: [:query :value :fontPolicy | query pixelSize: value].	ColorValue constantNames		do:			[:each | 			aDictionary				at: each				put:					[:query :value :fontPolicy | query color: (ColorValue perform: each)]]</body></methods><initialize><class-id>ExtraEmphases.TrailingInsert</class-id></initialize><initialize><class-id>ExtraEmphases.Substitute</class-id></initialize><initialize><class-id>ExtraEmphases.ColoredUnderline</class-id></initialize><initialize><class-id>ExtraEmphases.ColoredDoubleUnderline</class-id></initialize><initialize><class-id>ExtraEmphases.UnderGraphic</class-id></initialize><initialize><class-id>ExtraEmphases.BackColor</class-id></initialize><initialize><class-id>ExtraEmphases.Subscript</class-id></initialize><initialize><class-id>ExtraEmphases.DoubleUnderline</class-id></initialize><initialize><class-id>ExtraEmphases.Shadow</class-id></initialize><initialize><class-id>ExtraEmphases.JaggedEdge</class-id></initialize><initialize><class-id>ExtraEmphases.Overline</class-id></initialize><initialize><class-id>ExtraEmphases.Superscript</class-id></initialize><initialize><class-id>ExtraEmphases.BackHalf</class-id></initialize><initialize><class-id>ExtraEmphases.LeadingInsert</class-id></initialize><initialize><class-id>ExtraEmphases.LeadingInsertSpace</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ImplementationFont</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>DeviceFont</name><environment>Graphics</environment><super>Graphics.ImplementationFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>TextMeasurer</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>destX lastIndex widthTable font fontPolicy </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Scanning</category><attributes><package>Graphics-Text Scanning</package></attributes></class><class><name>DisplayScanner</name><environment>Graphics</environment><super>Graphics.CharacterScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphicsContext lineY </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Scanning</category><attributes><package>Graphics-Text Scanning</package></attributes></class><class><name>FontPolicy</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>availableFonts device fontClass defaultFont fontCache tolerance nameWeight familyWeight manufacturerWeight encodingWeight pixelSizeWeight boldnessWeight italicWeight serifWeight fixedWidthWeight setWidthWeight verticalWeight fdCache dfCache noFontBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>FontDescription</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name family manufacturer pixelSize flags masks color encoding encodings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>TextStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lengths emphases currentEmphasis runStartPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>CharacterAttributes</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes sharedAttributes defaultQuery queryCache policyCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>MSWindowsFont</name><environment>Graphics</environment><super>Graphics.ScreenFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class></st-source>