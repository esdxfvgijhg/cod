<?xml version="1.0"?><st-source><!-- Name: SmallBrotherNotice: Copyright 2002-2013 Roel Wuyts.  All rights reserved.This utility is free to use under the Simplified BSD license, as detailed below.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" ANDANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE AREDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FORANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED ANDON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THISSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.Comment: This package tracks the methods you browsed and the methods that you changed (see VisualLauncher>>Browse>>Method History to open a GUI on the method tracker).  This parcel is also the basis for adding history and popularity classifications to the StarBrowser.DbIdentifier: psql_public_cst_2007DbTrace: 87629DbUsername: niallrDbVersion: 1.138DevelopmentPrerequisites: #(#(#any 'StarBrowser2' ''))PackageName: SmallBrotherParcel: #('SmallBrother')ParcelName: SmallBrotherPrerequisiteDescriptions: #(#(#name 'StarBrowser2' #componentType #bundle))PrerequisiteParcels: #(#('StarBrowser2' ''))PrintStringCache: (1.138,niallr)Version: 1.138Post-Load Block: 	[:package | Classifications2.StarBrowser2 defaultClassification at: 1 put:  Classifications2.MenuService recentMethodsClassification; at: 1 put: Classifications2.MenuService popularClassesClassification]Pre-Unload Block: 	[:package | SmallBrother.MethodHistory preUnloadActionFor: package]Date: 3:24:40 PM May 10, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (may13.1) of 3 May 2013 on 10 May 2013 at 15:24:40</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SmallBrother</name><environment>Smalltalk</environment><private>false</private><imports>			XProgramming.SUnit.*			private Smalltalk.*			</imports><category>SmallBrother</category><attributes><package>SmallBrother</package></attributes></name-space><class><name>AbstractMethodHistoryEntry</name><environment>SmallBrother</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>SmallBrother</package></attributes></class><class><name>MethodHistoryEntry</name><environment>SmallBrother</environment><super>SmallBrother.AbstractMethodHistoryEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dateAndTime millisecondHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>SmallBrother</package></attributes></class><class><name>RoelAfterSystemChanges</name><environment>SmallBrother</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallBrother</category><attributes><package>SmallBrother</package></attributes></class><comment><class-id>SmallBrother.RoelAfterSystemChanges</class-id><body>[Comment taken when porting from Envy. Since this notifier is still there, it means the comment has not been updated yet to the 5i4 version and hence is probably not completely correct. See the tests for working specs.]I am a model that sends change messages after changes that occur in the Smalltalk system. Other classes use the regular Smalltalk dependency mechanism to show interest in these changes, and can thus be notified of events that occur in the system.  The aspectSymbol, together with the arguments, can be used to do a  perform (which makes it easy to respond to a change). Note that I use exactly the same update messages as the ChangeSet , but I take care that they are delivered after the change is performed. This makes it easier to correctly respond, for example to a changed method body (with the ChangeSet you still have the old method body, here you have the new one). The following changed messages and arguments are sent currently:	- class changes:		#addClass: #(class)			Indicate that a new class was created.		#changeClass: #(class) 			Indicate that a class definition has been changed.		#reorganizeClass: #(class)			Indicate that a class was reorganized.		#removeClass: #(class) 			Indicate that a class has been forgotten.		#renameClass:as: #(class newName) 			Indicate that a class has been renamed.		#commentClass: #(class) 			Indicate that a class comment has been changed.	- method changes:		#addSelector:class: #(selector class) 			Indicate that a method has been added.		#changeSelector:class: #(selector class)			Indicate that a method has been edited.		#removeSelector:class: #(selector class)  			Indicate that a method has been forgotten.	-various changes:			#reorganizeSystem			Indicate that the system classes were reorganized.		#addDoIt: #(smalltalkExpression)			When filing out changes, append this string to the file.'</body></comment><class><name>AddRecentMethodsAction</name><environment>Classifications2</environment><super>Classifications2.AddClassificationAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StarBrowser2Actions</category><attributes><package>SmallBrother</package></attributes></class><class><name>AddPopularClassesAction</name><environment>Classifications2</environment><super>Classifications2.AddClassificationAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StarBrowser2Actions</category><attributes><package>SmallBrother</package></attributes></class><class><name>MethodHistory</name><environment>SmallBrother</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history maxSize tracksBrowsing mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>SmallBrother</package></attributes></class><shared-variable><name>UniqueInstance</name><environment>SmallBrother.RoelAfterSystemChanges</environment><private>false</private><constant>false</constant><category>unique instance</category><initializer>nil</initializer><attributes><package>SmallBrother</package></attributes></shared-variable><shared-variable><name>UniqueInstance</name><environment>SmallBrother.MethodHistory</environment><private>false</private><constant>false</constant><category>unique instance</category><initializer>nil</initializer><attributes><package>SmallBrother</package></attributes></shared-variable><shared-variable><name>MinimumDelay</name><environment>SmallBrother.MethodHistoryEntry</environment><private>false</private><constant>false</constant><category>delay</category><initializer>nil</initializer><attributes><package>SmallBrother</package></attributes></shared-variable><methods><class-id>SmallBrother.AbstractMethodHistoryEntry</class-id> <category>saving</category><body package="SmallBrother">saveOnStream: aStream	"Export the history on the given stream."	self subclassResponsibility</body></methods><methods><class-id>SmallBrother.AbstractMethodHistoryEntry</class-id> <category>public</category><body package="SmallBrother">wasJustBrowsedIn: aCodePane	"The element was just browsed. Update the history information."	"The delay is inserted to make sure that sequential entries do not overlap."	self subclassResponsibility</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry</class-id> <category>saving</category><body package="SmallBrother">saveOnStream: aStream	"Export the history on the given stream."	dateAndTime do: [:stamp | aStream print: stamp] separatedBy: [aStream space].	aStream		tab;		print: self popularity;		tab.	millisecondHistory do: [:clockStamp | aStream print: clockStamp] separatedBy: [aStream space]</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry</class-id> <category>initialize-release</category><body package="SmallBrother">initialize	millisecondHistory := OrderedCollection new</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry</class-id> <category>printing</category><body package="SmallBrother">printOn: aStream 	aStream		print: self dateAndTime;		nextPutAll: ' - ';		print: self popularity</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry</class-id> <category>private</category><body package="SmallBrother">dateAndTime: aDateAndTime	dateAndTime := aDateAndTime</body><body package="SmallBrother">lastMillisecondStamp	^self millisecondHistory last</body><body package="SmallBrother">millisecondHistory	^millisecondHistory</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry</class-id> <category>public</category><body package="SmallBrother">wasJustBrowsedIn: aCodePane	"The element was just browsed. Update the history information."	"The delay is inserted to make sure that sequential entries do not overlap."	self class minimumDelay wait.	self dateAndTime: Time dateAndTimeNow.	self millisecondHistory add: Time millisecondClockValue</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry</class-id> <category>accessing</category><body package="SmallBrother">dateAndTime	"Return the date and time that the element was browsed last."	^dateAndTime</body><body package="SmallBrother">popularity	"Return the number of times that the element was browsed."	^self millisecondHistory size</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry class</class-id> <category>sorting blocks</category><body package="SmallBrother">sortByAgeBlock: aBoolean 	"sort ascending when the argument is true (e.g. oldest first), 	descending otherwise"	^aBoolean		ifTrue: [			[:assoc1 :assoc2 | assoc1 value lastMillisecondStamp &lt; assoc2 value lastMillisecondStamp]]		ifFalse: [			[:assoc1 :assoc2 | assoc1 value lastMillisecondStamp &gt; assoc2 value lastMillisecondStamp]]</body><body package="SmallBrother">sortByNameBlock: aBoolean 	"sort ascending when the argument is true (e.g. a before b), 	descending otherwise"	^aBoolean		ifTrue: [[:assoc1 :assoc2 | assoc1 key &lt; assoc2 key]]		ifFalse: [[:assoc1 :assoc2 | assoc1 key &gt; assoc2 key]]</body><body package="SmallBrother">sortByPopularityBlock: aBoolean 	"sort ascending when the argument is true (e.g. less popular 	first), descending otherwise"	^aBoolean		ifTrue: [[:assoc1 :assoc2 | assoc1 value popularity &lt; assoc2 value popularity]]		ifFalse: [[:assoc1 :assoc2 | assoc1 value popularity &gt; assoc2 value popularity]]</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry class</class-id> <category>instance creation</category><body package="SmallBrother">new	^self basicNew initialize</body></methods><methods><class-id>SmallBrother.MethodHistoryEntry class</class-id> <category>delay</category><body package="SmallBrother">minimumDelay	"Return the delay that corresponds to the minimum granularity of 	the time stamp mechanism used. So, if the entries are compared 	using second information, this delay should be set to 1000. 	Since by default I compare using milliseconds, a delay of 1 	milliseconds should be used."	MinimumDelay isNil ifTrue: [MinimumDelay := Delay forMilliseconds: 1].	^MinimumDelay</body></methods><methods><class-id>SmallBrother.RoelAfterSystemChanges</class-id> <category>private</category><body package="SmallBrother">hookup	"add myself as dependent of the current ChangeSet"	(self systemChangesNotifier dependents includes: self) 		ifFalse: [self systemChangesNotifier addDependent: self]</body><body package="SmallBrother">systemChangesNotifier	^ChangeSet</body><body package="SmallBrother">unhook	"remove myself as dependent of the current ChangeSet"		self systemChangesNotifier removeDependent: self</body><body package="SmallBrother">unhookWhile: aBlock 	"remove myself as a dependent of the current ChangeSet while evaluating the 	block. Otherwise it could happen that I get two change notifications: one via 	the current ChangeSet, and one directly via Object class"	[self unhook.	aBlock value]		ensure: 			[self hookup]</body></methods><methods><class-id>SmallBrother.RoelAfterSystemChanges</class-id> <category>changes</category><body package="SmallBrother">update: anAspectSymbol with: aParameter from: aSender 	aSender = self systemChangesNotifier		ifTrue: 			[^self changed: anAspectSymbol with: aParameter].	^super 		update: anAspectSymbol		with: aParameter		from: aSender</body></methods><methods><class-id>SmallBrother.RoelAfterSystemChanges</class-id> <category>initialize-release</category><body package="SmallBrother">initialize	self hookup</body><body package="SmallBrother">release	super release.	self unhook</body></methods><methods><class-id>SmallBrother.RoelAfterSystemChanges</class-id> <category>propagation</category><body package="SmallBrother">selectorChanged: selector inClass: aClass	"selector in aClass was added or changed. Notify my dependents (I use the 	same format as ChangeSet)"		self changed: #changeSelector:class: with: (Array with: selector with: aClass)</body></methods><methods><class-id>SmallBrother.RoelAfterSystemChanges class</class-id> <category>instance creation</category><body package="SmallBrother">new	"There can only be one instance, my unique instance. Override new to enforce this policy."	^self shouldNotImplement</body></methods><methods><class-id>SmallBrother.RoelAfterSystemChanges class</class-id> <category>unique instance</category><body package="SmallBrother">resetUniqueInstance	"Set the unique instance to nil. When it is needed afterwards, it will get re-initialized."	"self resetUniqueInstance"	UniqueInstance release.	UniqueInstance := nil</body><body package="SmallBrother">uniqueInstance	"Returns my unique instance. Initialize it when needed."	"self uniqueInstance"	UniqueInstance isNil ifTrue: [UniqueInstance := self basicNew initialize].	^UniqueInstance</body></methods><methods><class-id>SmallBrother.RoelAfterSystemChanges class</class-id> <category>parcel load/unload/save</category><body package="SmallBrother">preUnloadActionFor: package 	UniqueInstance isNil ifTrue: [^self].	self uniqueInstance clear.	self resetUniqueInstance</body></methods><methods><class-id>Classifications2.AddRecentMethodsAction</class-id> <category>accessing</category><body package="SmallBrother">name	^'Add Recent Methods'</body></methods><methods><class-id>Classifications2.AddRecentMethodsAction</class-id> <category>private</category><body package="SmallBrother">createNewClassification	^(Classifications2.UpdatingClassification name: 'Recent Methods'		source: 'SmallBrother.MethodHistory uniqueInstance recentMethods: 10') 			notifier: SmallBrother.MethodHistory uniqueInstance</body></methods><methods><class-id>Classifications2.AddPopularClassesAction</class-id> <category>accessing</category><body package="SmallBrother">name	^'Add Popular Classes'</body></methods><methods><class-id>Classifications2.AddPopularClassesAction</class-id> <category>private</category><body package="SmallBrother">createNewClassification	^(Classifications2.UpdatingClassification name: 'Popular Classes'		source: 'SmallBrother.MethodHistory uniqueInstance popularClasses: 10') 			notifier: SmallBrother.MethodHistory uniqueInstance</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>accessing</category><body package="SmallBrother">byAgeAscending	"return the elements sorted by age (oldest first)"		^self byAgeAscending: true</body><body package="SmallBrother">byAgeAscending: aBoolean 	"sort ascending when the argument is true (e.g. oldest first), descending otherwise"	^self elementsSortedBy: (self historyEntryClass sortByAgeBlock: aBoolean)</body><body package="SmallBrother">byAgeDescending	"return the elements sorted by age (youngest first)"		^self byAgeAscending: false</body><body package="SmallBrother">byNameAscending	"return the element sorted alphabetcally"	^self byNameAscending: true</body><body package="SmallBrother">byNameAscending: aBoolean 	"sort ascending when the argument is true (e.g. a before b), descending otherwise"	^self elementsSortedBy: (self historyEntryClass sortByNameBlock: aBoolean)</body><body package="SmallBrother">byNameDescending	"return the element sorted alphabetcally"	^self byNameAscending: false</body><body package="SmallBrother">byPopularityAscending	"return the element sorted (least popular first)"	^self byPopularityAscending: true</body><body package="SmallBrother">byPopularityAscending: aBoolean 	"sort ascending when the argument is true (e.g. less popular first), descending otherwise"	^self 		elementsSortedBy: (self historyEntryClass sortByPopularityBlock: aBoolean)</body><body package="SmallBrother">byPopularityDescending	"return the element sorted (most popular first)"	^self byPopularityAscending: false</body><body package="SmallBrother">changeMaxSize: aNumber	"Change the current maxsize. Remove as many of the oldest elements if the current size of the history is too big for this new size."	(self currentSize &gt; aNumber) ifTrue: [self removeOldest: self currentSize - aNumber].	maxSize := aNumber</body><body package="SmallBrother">maxSize	maxSize isNil ifTrue: [maxSize := self defaultMaxSize].	^maxSize</body><body package="SmallBrother">oldestElement	"Does not use #elementsByAge because I want it to be as efficient as possible, since this method is used a lot when the the history is full (and hence the oldest elements needs to be removed every time)" 	| oldestElement oldestStamp |	oldestElement := nil.	oldestStamp := Time millisecondClockValue.	self history		associationsDo: 			[:assoc | |stamp|			stamp := assoc value lastMillisecondStamp.			stamp &lt; oldestStamp				ifTrue: 					[oldestElement := assoc.					oldestStamp := stamp]].	^oldestElement</body><body package="SmallBrother">tracksBrowsing	"Returns whether the receiver is currently tracking changes or not"	^tracksBrowsing</body><body package="SmallBrother">tracksBrowsing: aBoolean	"Sets whether the receiver should track browsing or not. If true, then information for each method browsed is stored. If not, then nothing happens."	tracksBrowsing := aBoolean</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>private</category><body package="SmallBrother">basicRemoveMethodDefinition: aMethodDefinition	"Remove the entry for the given method definition, if it exists. Do nothing if the entry does not exist.Do not send a change message."	self history removeKey: aMethodDefinition ifAbsent: []</body><body package="SmallBrother">elementsSortedBy: aBlock 	"sort the associations by the given block"	^self history associations asSortedCollection: aBlock</body><body package="SmallBrother">historyEntryClass	^MethodHistoryEntry</body><body package="SmallBrother">isFull	"Return whether the history is full"	^self currentSize = self maxSize</body><body package="SmallBrother">removeOldest	"remove the oldest element in the history. Do not send a change message! "	self basicRemoveMethodDefinition: self oldestElement key</body><body package="SmallBrother">removeOldest: aNumber	"remove aNumber oldest elements in the history. Do not send a change message! "	aNumber timesRepeat: [self removeOldest]</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>queries</category><body package="SmallBrother">popularClasses	| classesByPopularity theClass classPopularity |	classesByPopularity := Dictionary new.	self byPopularityDescending do: [:info |		theClass := info key implementingClass.		classPopularity := classesByPopularity at: theClass ifAbsent: [0].		classesByPopularity at: theClass put: (classPopularity + info value popularity)].	^(classesByPopularity associations asSortedCollection: [:x :y | x value &gt; y value]) collect: [:assoc | assoc key]</body><body package="SmallBrother">popularClasses: max	"Return the max number of popular classes instead of all of them."	| popularClasses |	popularClasses := self popularClasses.	^popularClasses copyFrom: 1 to: (max min: popularClasses size)</body><body package="SmallBrother">popularMethods	^self byPopularityDescending collect: [:info | info key]</body><body package="SmallBrother">recentMethods	^(self byAgeAscending: false) collect: [:assoc | assoc key]</body><body package="SmallBrother">recentMethods: max	| recentMethods |	recentMethods := self recentMethods.	^recentMethods copyFrom: 1 to: (max min: recentMethods size)</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>testing</category><body package="SmallBrother">hasMethodDefinition: aMethodDefinition	"Returns whether the receiver has an entry for the given method definition."	^self history includesKey: aMethodDefinition</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>adding-removing</category><body package="SmallBrother">clear	self initializeHistory.	self changed: #initializeHistory with: self</body><body package="SmallBrother">removeMethodDefinition: aMethodDefinition	"Remove the entry for the given method definition, if it exists. Do nothing if the entry doesnot exist."	self basicRemoveMethodDefinition: aMethodDefinition.	self changed: #removeMethodDefinition with: self</body><body package="SmallBrother">visitedClass: aClass selector: aMethodSymbol 		self visitedClass: aClass selector: aMethodSymbol in: nil</body><body package="SmallBrother">visitedClass: aClass selector: aMethodSymbol in: aCodePane	"Add an entry for the class&gt;&gt;selector that were just browsed. Remove an older element when the history is full. Do nothing when I am not tracking the browsing of methods."	| md |	self tracksBrowsing ifFalse: [^self].	aMethodSymbol isNil ifTrue: [^self].	mutex critical: [		md := MethodDefinition class: aClass selector: aMethodSymbol.		(self hasMethodDefinition: md)			ifTrue: [(self history at: md) wasJustBrowsedIn: aCodePane]			ifFalse: [				self isFull ifTrue: [self removeOldest].				self history at: md put: (self historyEntryClass new wasJustBrowsedIn: aCodePane)]].	self changed: #visitedSelector with: self</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>private-accessing</category><body package="SmallBrother">currentSize	"Return the current number of elements in the history"	^self history size</body><body package="SmallBrother">defaultMaxSize	"Return the default maximum number of elements in the history."	^100</body><body package="SmallBrother">history	^history</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>saving</category><body package="SmallBrother">outputToFileNamed: aName	| str |	str := (Filename named: aName) appendStream.	self saveOnStream: str.	str close</body><body package="SmallBrother">saveOnStream: aStream	"Export the history on the given stream."	| methodDefinition |	self history associationsDo: [:assoc | 		methodDefinition := assoc key.		aStream			nextPutAll: methodDefinition implementingClass fullName;			tab;			nextPutAll: methodDefinition selector;			tab.		assoc value saveOnStream: aStream.		aStream cr.		]</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>initialize-release</category><body package="SmallBrother">initialize	mutex := Semaphore forMutualExclusion.	self initializeHistory.	self initializeTracksBrowsing</body><body package="SmallBrother">initializeHistory	history := Dictionary new.</body><body package="SmallBrother">initializeTracksBrowsing	tracksBrowsing := true</body></methods><methods><class-id>SmallBrother.MethodHistory</class-id> <category>printing</category><body package="SmallBrother">printOn: aStream	"Print the contents of the history by popularity"	self byPopularityDescending do: [:each | aStream print: each] separatedBy: [aStream cr]</body></methods><methods><class-id>SmallBrother.MethodHistory class</class-id> <category>instance creation</category><body package="SmallBrother">new	"There can only be one instance, my unique instance. Override new to enforce this policy."	^self shouldNotImplement</body></methods><methods><class-id>SmallBrother.MethodHistory class</class-id> <category>unique instance</category><body package="SmallBrother">resetUniqueInstance	"Set the unique instance to nil. When it is needed afterwards, it will get re-initialized."	"self resetUniqueInstance"	UniqueInstance := nil</body><body package="SmallBrother">uniqueInstance	"Returns my unique instance. Initialize it when needed."	"self uniqueInstance"	UniqueInstance isNil ifTrue: [UniqueInstance := self basicNew initialize].	^UniqueInstance</body></methods><methods><class-id>SmallBrother.MethodHistory class</class-id> <category>parcel load/unload/save</category><body package="SmallBrother">preUnloadActionFor: package 	UniqueInstance isNil 		ifFalse: 			[self uniqueInstance clear.			self resetUniqueInstance].	SmallBrother.MethodHistoryEntry.MinimumDelay := nil</body></methods><methods><class-id>Core.Object class</class-id> <category>roelAfterSystemChanges</category><body package="SmallBrother">changeNotifier	"The model that is responsible for distributing system changes to its dependents."	^SmallBrother.RoelAfterSystemChanges uniqueInstance</body><body package="SmallBrother">compile: code classified: heading notifying: requestor 	"Traps compilation of methods. Needed because the change notification sent by the ChangeSet is sent before the method is added, and we want to have the notification afterwards."	| return |	self changeNotifier unhookWhile: [return := super compile: code classified: heading notifying: requestor].	self changeNotifier selectorChanged: return inClass: self.	^return</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>private</category><body package="SmallBrother">updateTextWidget	"Overriden by SmallBrother to trap browsing of methods. Used to use updateContents, but that is used in 7.1 by PDP."	| widget prefs |	builder isNil ifTrue: [^self].	[SmallBrother.MethodHistory uniqueInstance visitedClass: self methodClass selector: self selector in: self] fork.	widget := builder componentAt: #textEditor.	widget isNil ifTrue: [^self].	modified = (widget lookPreferences foregroundColor = self modifiedTextColor) ifTrue: [^self].	prefs := modified ifTrue: [initialLookPrefs copy foregroundColor: self modifiedTextColor] ifFalse: [initialLookPrefs].	widget lookPreferences: prefs</body></methods><methods><class-id>Classifications2.MenuService class</class-id> <category>adding classifications</category><body package="SmallBrother">popularClassesClassification	^(Classifications2.UpdatingClassification name: 'Popular Classes'		source: 'SmallBrother.MethodHistory uniqueInstance popularClasses: 10') 			notifier: SmallBrother.MethodHistory uniqueInstance</body><body package="SmallBrother">recentMethodsClassification	^(Classifications2.UpdatingClassification name: 'Recent Methods'		source: 'SmallBrother.MethodHistory uniqueInstance recentMethods: 10') 			notifier: SmallBrother.MethodHistory uniqueInstance</body></methods><methods><class-id>Classifications2.MenuService</class-id> <category>submenu-add</category><body package="SmallBrother">addPopularClasses	&lt;menuItem: 'Popular Classes'		nameKey: #addPopularClasses		menu: #(#menu add)		position: 6.6		disabledFor:#(undefinedObject smartClassification)&gt;	self starBrowser performAction: AddPopularClassesAction</body><body package="SmallBrother">addRecentMethods	&lt;menuItem: 'Recent Methods'		nameKey: #addRecentMethods		menu: #(#menu add)		position: 6.3		disabledFor:#(undefinedObject smartClassification)&gt;	self starBrowser performAction: AddRecentMethodsAction</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MenuService</name><environment>Classifications2</environment><super>Classifications2.PragmaBasedService</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu toolbar overrides </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StarBrowserUI2</category><attributes><package>StarBrowserUI2</package></attributes></class><class><name>AddClassificationAction</name><environment>Classifications2</environment><super>Classifications2.AbstractAddAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StarBrowser2Actions</category><attributes><package>StarBrowser2Actions</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class></st-source>