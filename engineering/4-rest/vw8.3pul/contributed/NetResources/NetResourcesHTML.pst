<?xml version="1.0"?><st-source><!-- Name: NetResourcesHTMLDbIdentifier: psql_public_cst_2007DbTrace: 19024DbUsername: jamesrDbVersion: 1.1PackageName: NetResourcesHTMLParcel: #('NetResourcesHTML')ParcelName: NetResourcesHTMLPrintStringCache: (1.1,jamesr)Version: 1.1Date: 3:24:12 PM January 27, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 27, 2016 at 3:24:12 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>HTML</name><environment>XML</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>NetResourcesHTML</category><attributes><package>NetResourcesHTML</package></attributes></name-space><class><name>HTMLParser</name><environment>XML.HTML</environment><super>XML.XMLParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>NetResourcesHTML</package></attributes></class><methods><class-id>XML.HTML.HTMLParser</class-id> <category>element processing</category><body package="NetResourcesHTML">elementContent: tag openedIn: str"This alteration allows parsing of dodgy IE5 entities such as &lt;!IF &gt;"	| data str1 braceCount size textType |	braceCount := 0.	buffer reset.	[hereChar == nil		ifTrue: [self malformed: ((#expectedEndTag &lt;&lt; #xml &gt;&gt; 'The end tag for %&lt;&lt;1s&gt;&gt; was expected') expandMacrosWith: tag)].	hereChar == $&lt;		ifTrue:			[braceCount := 0.			buffer position &gt; 0				ifTrue:					[data := buffer collection.	"Not necessarily portable, but faster than #contents"					size := buffer position.					textType := self						validateText: data						from: 1						to: size						testBlanks: true.					textType == #whitespace						ifTrue:							[(self isValidating and: [self isDeclaredStandalone and: [elementStack last isDefinedExternal]])								ifTrue: [self invalid: (#NotStandalone &lt;&lt; #xml &gt;&gt; 'This document is not standalone')].							sax ignorableWhitespace: data from: 1 to: size]						ifFalse: [sax characters: data from: 1 to: size]].			str1 := currentSource.			(self skipIf: '&lt;/')				ifTrue:					[self closeTag: tag.					str == lastSource						ifFalse: [self malformed: (#elementNestingInEntities &lt;&lt; #xml &gt;&gt; 'Elements must nest properly within entities')].					^self]				ifFalse: [(self skipIf: '&lt;?')					ifTrue: [self completePI: str1]					ifFalse: [(self skipIf: '&lt;![CDATA[')						ifTrue: [self completeCDATA: str1]						ifFalse: [(self skipIf: '&lt;!--')							ifTrue: [self completeComment: str1]							ifFalse: [(self skipIf: '&lt;![')								ifTrue: [self completeUnrecognisedCommand: str1]								ifFalse: [self getElement]]]]].			buffer reset]		ifFalse: [hereChar == $&amp;			ifTrue:				[braceCount := 0.				str1 := currentSource.				(self skipIf: '&amp;#')					ifTrue: [self charEntity: buffer startedIn: str1]					ifFalse: [self getNextChar; generalEntityInText: buffer canBeExternal: true]]			ifFalse:				[hereChar == $]					ifTrue: [braceCount := braceCount+1]					ifFalse:						[(hereChar == $&gt; and: [braceCount &gt;= 2])							ifTrue: [self malformed: #embeddedCdataClose &lt;&lt; #xml &gt;&gt; ']]&gt; is not permitted in element content'].						braceCount := 0].				buffer nextPut: hereChar.				self getNextChar]]] repeat</body></methods><methods><class-id>XML.HTML.HTMLParser</class-id> <category>private</category><body package="NetResourcesHTML">completeUnrecognisedCommand: str1	buffer reset.	self upToAll: ']&gt;'</body></methods><methods><class-id>XML.Document</class-id> <category>API</category><body package="NetResourcesHTML">transformHTML	self root transformHTML</body></methods><methods><class-id>XML.Element</class-id> <category>API</category><body package="NetResourcesHTML">isBlockInLink: node	self tag type asLowercase = 'a' ifFalse: [^false].	^#( 'p' 'div' 'form' 'table' ) includes: node tag type asLowercase</body><body package="NetResourcesHTML">isBodyInHead: node	node tag type asLowercase = 'body' ifFalse: [^false].	^self tag type asLowercase = 'head'</body><body package="NetResourcesHTML">isLinkInLink: node	node tag type asLowercase = 'a' ifFalse: [^false].	^self tag type asLowercase = 'a'</body><body package="NetResourcesHTML">isMisplacedCell: node	node tag type asLowercase = 'td' ifFalse: [^false].	^(#( 'tr' 'table' 'th' ) includes: self tag type asLowercase) not</body><body package="NetResourcesHTML">isScriptInNoScript: node	node tag type asLowercase = 'script' ifFalse: [^false].	^self tag type asLowercase = 'noscript'</body><body package="NetResourcesHTML">isTerminal	^#( 'br' 'nobr' 'meta' 'title' 'base' 'img' 'script' 'spacer' 'link' ) includes: self tag type asLowercase</body><body package="NetResourcesHTML">makeNodesChangeable	elements ifNil: [^elements := OrderedCollection new].	elements := elements asOrderedCollection</body><body package="NetResourcesHTML">shouldRemoveNode: node	self isTerminal ifTrue: [^true].	node isElement ifFalse: [^false].	(self isBlockInLink: node) ifTrue: [^true].	(self isLinkInLink: node) ifTrue: [^true].	(self isMisplacedCell: node) ifTrue: [^true].	(self isBodyInHead: node) ifTrue: [^true].	(self isScriptInNoScript: node) ifTrue: [^true].	^false</body><body package="NetResourcesHTML">transformHTML	self makeNodesChangeable.	elements copy do: [:node | node transformHTML: elements]</body><body package="NetResourcesHTML">transformHTML: parentNodes	self transformHTML.	self transformNodesHTML: parentNodes</body><body package="NetResourcesHTML">transformNodesHTML: parentNodes	self makeNodesChangeable.	elements copy reverseDo: [:node |		(self shouldRemoveNode: node) ifTrue:			[elements remove: node.			parentNodes add: node after: self]]</body></methods><methods><class-id>XML.Node</class-id> <category>API</category><body package="NetResourcesHTML">transformHTML: parentNodes</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>XMLParser</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceStack hereChar hereCharNumBytes lastSource currentSource dtd unresolvedIDREFs definedIDs latestID sax elementStack validating flags eol buffer nameBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><class><name>Node</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent flags userData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Document</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root nodes dtd ids </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class></st-source>