<?xml version="1.0"?><st-source><!-- Name: NetResourcesHTTPComment: NetResourcesHTTP provides HTTP support for the NetResources package.For complete documentation, see the comment for the NetResources package.This parcel does not pre-req BOSS (used for export/import of encrypted passwords) or TLS (it used to pre-req SSL, so should prereq TLS in recent releases, but does not appear to need it).DbIdentifier: psql_public_cst_2007DbTrace: 92374DbUsername: niallrDbVersion: 1.89DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'HTTP' '') #(#any 'Http-Overrides' '') #(#any 'NetResources' '') #(#any 'Wave-Server' '') #(#any 'X509' '') #(#any 'MD5' '') #(#any 'MIME' '') #(#any 'NetConfigTool' '') #(#any 'Compression-ZLib' ''))PackageName: NetResourcesHTTPParcel: #('NetResourcesHTTP')ParcelName: NetResourcesHTTPPrerequisiteDescriptions: #(#(#name 'NetClientBase' #componentType #package) #(#name 'HTTP') #(#name 'Http-Overrides') #(#name 'NetResources') #(#name 'Wave-Server') #(#name 'X509') #(#name 'MD5') #(#name 'MIME') #(#name 'NetConfigTool') #(#name 'Compression-ZLib'))PrerequisiteParcels: #(#('NetClientBase' '') #('HTTP' '') #('Http-Overrides' '') #('NetResources' '') #('Wave-Server' '') #('X509' '') #('MD5' '') #('MIME' '') #('NetConfigTool' '') #('Compression-ZLib' ''))PrintStringCache: (1.89,niallr)Version: 1.89Post-Load Block: 	[:package | ''reset the agent string, so that a relevant version string gets reported''			Net.Resources.HttpClientModel userAgent: nil]Date: 4:34:28 PM January 27, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 27, 2016 at 4:34:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HttpCacheItem</name><environment>Net.Resources</environment><super>Net.Resources.CacheItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>etags failedGzip realm newLocation code </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>NetResourcesHTTP</package></attributes></class><class><name>HttpClientResponse</name><environment>Net.Resources</environment><super>Net.HttpResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>NetResourcesHTTP</package></attributes></class><class><name>UserAuthorizationDialog</name><environment>Net.Resources</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>password username realm promptURL remember </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>NetResourcesHTTP</package></attributes></class><class><name>HttpClientBuildHandler</name><environment>Net.Resources</environment><super>Net.HttpBuildHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>NetResourcesHTTP</package></attributes></class><class><name>HttpClientModel</name><environment>Net.Resources</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url cacheItem response hasTriedAuth shouldKeepAlive retry </inst-vars><class-inst-vars>liveConnections liveConnectionsTimeout </class-inst-vars><imports></imports><category></category><attributes><package>NetResourcesHTTP</package></attributes></class><shared-variable><name>HostLocks</name><environment>Net.HttpURL</environment><private>false</private><constant>false</constant><category>HTTP</category><initializer>Net.Resources.ThreadSafeDictionary new</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>HttpTrace</name><environment>Net.HttpURL</environment><private>false</private><constant>false</constant><category>Debug</category><initializer>false</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>LiveConnections</name><environment>Net.Resources.HttpClientModel</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>Online</name><environment>Net.Resources.HttpClientModel</environment><private>false</private><constant>false</constant><category>user-agent</category><initializer>true</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>AgentString</name><environment>Net.Resources.HttpClientModel</environment><private>false</private><constant>false</constant><category>user-agent</category><initializer>nil</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>DefaultAccept</name><environment>Net.Resources.HttpClientModel</environment><private>false</private><constant>false</constant><category>headers</category><initializer>nil</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>Passwords</name><environment>Net.Resources.Cache</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Dictionary new</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>CanSaves</name><environment>Net.Resources.Cache</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>OrderedCollection new</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><shared-variable><name>Cookies</name><environment>Net.Resources.Cache</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Dictionary new</initializer><attributes><package>NetResourcesHTTP</package></attributes></shared-variable><methods><class-id>Net.Resources.HttpCacheItem</class-id> <category>authorization</category><body package="NetResourcesHTTP">addDigestAuthTo: aRequest username: user password: pass	"add digest authorization"	| theRealm parms qop digestResponse algorithm nonce cnonce theUrl |	parms := realm  params.	theRealm := parms at: 'realm'.	algorithm := parms at: 'algorithm' ifAbsent: 'MD5'.	qop := parms at: 'qop' ifAbsent: [nil].	nonce := parms at: 'nonce' ifAbsent: [nil].	cnonce := Timestamp now asSeconds printString md5Hash asLowercase.	theUrl := aRequest requestLine url pathString.	digestResponse := self 		getDigestHashFor: algorithm		username: user		password: pass		realm: theRealm		nonce: nonce		cnonce: cnonce		uri: theUrl.	aRequest 		realm: theRealm		username: user		password: pass		qop: qop		nonce: nonce		cnonce: cnonce		uri: theUrl		digestResponse: digestResponse.</body><body package="NetResourcesHTTP">getDigestHashFor: algorithm username: user password: pass realm: digestRealm nonce: nonce cnonce: cnonce uri: digestURI	"get the digest hash"	| stream a1 a2 hashStream data |	stream := WriteStream on: String new.	stream nextPutAll: self username, ':', digestRealm, ':', self password.	a1 := stream contents md5Hash asLowercase.	a2 := ('GET:', digestURI) md5Hash asLowercase.	hashStream := WriteStream on: String new.	hashStream nextPutAll: nonce.	hashStream nextPut: $:.	hashStream nextPutAll: '00000001'.	hashStream nextPut: $:.	hashStream nextPutAll: cnonce.	hashStream nextPut: $:.	hashStream nextPutAll: 'auth'.	hashStream nextPut: $:.	hashStream nextPutAll: a2.	data := hashStream contents.	^(a1, ':', data) md5Hash asLowercase</body><body package="NetResourcesHTTP">isBasicAuth	"answer true if this is a basic auth request"	^self realm value asLowercase = 'basic'</body></methods><methods><class-id>Net.Resources.HttpCacheItem</class-id> <category>accessing</category><body package="NetResourcesHTTP">code	^code</body><body package="NetResourcesHTTP">code: anObject	code := anObject</body><body package="NetResourcesHTTP">cookies	^self cache cookiesForHost: self hostAndPort</body><body package="NetResourcesHTTP">cookies: aCookies	| mergedCookies |	mergedCookies := aCookies copy.	self cookies do: [:each | ((mergedCookies collect: [:ea | ea name]) includes: each name) ifFalse: [mergedCookies add: each]].	^self cache setCookies: mergedCookies onHost: self hostAndPort</body><body package="NetResourcesHTTP">etags	^etags</body><body package="NetResourcesHTTP">etags: anObject	etags := anObject</body><body package="NetResourcesHTTP">failedGzip	^failedGzip ifNil: [failedGzip := false]</body><body package="NetResourcesHTTP">failedGzip: anObject	failedGzip := anObject</body><body package="NetResourcesHTTP">hostAndPort	^self uri hostAndPort</body><body package="NetResourcesHTTP">lastModifiedTimestamp	| str |	lastModified isString ifTrue: [^lastModified].	str := WriteStream on: String new.	TimestampPrintPolicy 		print: lastModified		on: str		using: 'ddd, dd mmm yyyy hh:mm:ss'.	^str contents</body><body package="NetResourcesHTTP">newLocation	^newLocation</body><body package="NetResourcesHTTP">newLocation: anObject	newLocation := anObject</body><body package="NetResourcesHTTP">password	^self usernameAndPassword value</body><body package="NetResourcesHTTP">password: aPassword	self setUsername: self username password: aPassword</body><body package="NetResourcesHTTP">realm	^realm</body><body package="NetResourcesHTTP">realm: anObject	realm := anObject</body><body package="NetResourcesHTTP">realmName	realm ifNil: [^nil].	^realm realm</body><body package="NetResourcesHTTP">setUsername: aUsername password: aPassword	self realm ifNil: [^self].	self cache setUsername: aUsername password: aPassword onHost: self hostAndPort realm: self realmName</body><body package="NetResourcesHTTP">username	^self usernameAndPassword key</body><body package="NetResourcesHTTP">username: aUsername	self setUsername: aUsername password: self password</body><body package="NetResourcesHTTP">usernameAndPassword	self realm ifNil: [^'' -&gt; ''].	^self cache usernameAndPassForHost: self hostAndPort realm: self realmName</body></methods><methods><class-id>Net.Resources.HttpCacheItem</class-id> <category>testing</category><body package="NetResourcesHTTP">hasCookies	^self cookies notNil and: [self cookies notEmpty]</body><body package="NetResourcesHTTP">hasMoved	^self newLocation notNil</body><body package="NetResourcesHTTP">isFailure	^self isSuccess not</body><body package="NetResourcesHTTP">isMoved	^self hasMoved</body><body package="NetResourcesHTTP">isPermanentMove	^self newLocation notNil and: ['*301*' match: self code]</body><body package="NetResourcesHTTP">isSuccess	self code ifNil: [^false].	^(('3##' match: self code) or: ['2##' match: self code])</body><body package="NetResourcesHTTP">isValidForCache	^(self lastModified notNil and: [self etags notNil]) or: [self hasCookies]</body><body package="NetResourcesHTTP">isValidForLastModified	^self lastModified notNil or: [self etags notNil]</body><body package="NetResourcesHTTP">usesAuthorization	^realm notNil</body></methods><methods><class-id>Net.Resources.HttpCacheItem</class-id> <category>private</category><body package="NetResourcesHTTP">dropCacheState	super dropCacheState.	etags := nil.</body><body package="NetResourcesHTTP">getRealmFrom: aResponse	| entire basics digest |	entire := (aResponse wwwAuthenticate) first.	basics := entire  value select: [:each | 'Basic' match: each value].	basics notEmpty		ifTrue: [^basics first].	digest := (entire  value select: [:each | 'Digest' match: each value]).	^digest isEmpty		ifTrue: [nil]		ifFalse: [digest first]</body><body package="NetResourcesHTTP">isHappyWithContent	failedGzip ifTrue: [^true].	contents ifNil: [^false].	^self handler isHappyWithFirstCharacter: contents first asCharacter</body><body package="NetResourcesHTTP">setNewURLFromOriginal: originalUrl	| newLoc |	newLoc := self newLocation.	^newLoc looksLikeAnURL		ifTrue: [newLoc]		ifFalse: [(originalUrl asURI resolveRelativePath: newLoc asString) asString].</body></methods><methods><class-id>Net.Resources.HttpCacheItem</class-id> <category>initialize-release</category><body package="NetResourcesHTTP">initialize	super initialize.	failedGzip := false</body></methods><methods><class-id>Net.Resources.HttpCacheItem</class-id> <category>disk-cache</category><body package="NetResourcesHTTP">representedInstanceVariables	^super representedInstanceVariables		at: #etags: put: etags;		at: #failedGzip: put: failedGzip;		at: #realm: put: realm;		at: #newLocation: put: newLocation;		at: #code: put: code;		yourself</body></methods><methods><class-id>Net.Resources.HttpCacheItem</class-id> <category>API</category><body package="NetResourcesHTTP">addAuthorizationTo: aRequest	"site expects user auth.  Add appropriate header"	self username ifNil: [^self].	self username isEmpty ifTrue: [^self].	self isBasicAuth		ifTrue:	[aRequest username: self username password: self password]		ifFalse:	[self addDigestAuthTo: aRequest username: self username password: self password]</body></methods><methods><class-id>Net.Resources.HttpClientResponse</class-id> <category>parsing</category><body package="NetResourcesHTTP">downloadAt: aPosition of: aSize	self triggerEvent: #downloadAt:of: with: aPosition with: aSize</body><body package="NetResourcesHTTP">parse: rfc822Scanner	| builder result |	builder := self builder.	builder options: self parsingOptions.	builder when: #downloadAt:of: send: #downloadAt:of: to: self.	result := builder parse: self from: rfc822Scanner.	builder removeActionsWithReceiver: self forEvent: #downloadAt:of:.	^result</body></methods><methods><class-id>Net.Resources.HttpClientResponse class</class-id> <category>constants</category><body package="NetResourcesHTTP">defaultBuilderType	^HttpClientBuildHandler</body></methods><methods><class-id>Net.Resources.UserAuthorizationDialog</class-id> <category>initialize-release</category><body package="NetResourcesHTTP">initialize	super initialize.	self realm value: 'Basic'</body></methods><methods><class-id>Net.Resources.UserAuthorizationDialog</class-id> <category>aspects</category><body package="NetResourcesHTTP">password	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^password isNil		ifTrue:			[password := String new asValue]		ifFalse:			[password]</body><body package="NetResourcesHTTP">promptURL	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^promptURL isNil		ifTrue:			[promptURL := String new asValue]		ifFalse:			[promptURL]</body><body package="NetResourcesHTTP">realm	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^realm isNil		ifTrue:			[realm := String new asValue]		ifFalse:			[realm]</body><body package="NetResourcesHTTP">remember	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^remember isNil		ifTrue:			[remember := true asValue]		ifFalse:			[remember]</body><body package="NetResourcesHTTP">username	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^username isNil		ifTrue:			[username := String new asValue]		ifFalse:			[username]</body></methods><methods><class-id>Net.Resources.HttpClientBuildHandler</class-id> <category>private</category><body package="NetResourcesHTTP">privateStartBody: body stream: aStream length: lengthOrNil" Copy the body (next counter bytes or to the end of the stream if nil) "	| binary lineEndConvention counter c start bodyLength |	binary := body isBinary.	lineEndConvention := aStream lineEndConvention.	binary		ifTrue: [aStream binary]		ifFalse: [aStream lineEndTransparent].	start := aStream position.	bodyLength := (body parent header at: 'content-length') value.	counter := lengthOrNil.	[ 		[(counter == nil or: [counter &gt; 0]) and: [aStream atEnd not]]			whileTrue: 				[((aStream position - start) \\ 1024) isZero ifTrue: [self triggerEvent: #downloadAt:of: with: (aStream position - start) with: bodyLength].				c := aStream next.				binary ifTrue: [c := c asInteger].				body source nextPut: c.				counter notNil ifTrue: [counter := counter - 1]].		aStream text; lineEndConvention: lineEndConvention	]  on: Error 	  do: [ :ex | self handleStartBodyException: ex ].	self triggerEvent: #downloadAt:of: with: (aStream position - start) with: bodyLength.</body><body package="NetResourcesHTTP">readStream: aStream length: lengthOrNil lineEndConvention: lineEndConvention"Always read Http body in binary mode. Need to reset text for chunked format "" Decompress the stream contents if the option is on and the message header includes gzip "	| counter body start bodyLength |	body := self entity body.	counter := lengthOrNil. 	start := aStream position.	bodyLength := (body parent header at: 'content-length') value.	[(counter == nil or: [counter &gt; 0]) and: [aStream atEnd not]]		whileTrue: 			[((aStream position - start) \\ 1024) isZero ifTrue: [self triggerEvent: #downloadAt:of: with: (aStream position - start) with: bodyLength].			body byteSource nextPut: aStream next asInteger.			counter notNil ifTrue: [counter := counter - 1]].</body></methods><methods><class-id>Net.Resources.HttpClientModel</class-id> <category>private</category><body package="NetResourcesHTTP">behaviourForException: ex	ex class = Security.SSLBadCertificate		ifTrue: [[| cert |				cert := (ex parameter isSequenceable)						ifTrue: [ex parameter first]						ifFalse: [ex parameter].				cert class = Security.X509.RootNotTrusted					ifTrue: [ex resume].				Security.X509.X509Registry default addCertificate: cert]				on: Security.X509.BadCAConstraints, Security.X509.BadCAKeyUsage				do: [:ex2 | ex2 resume]].	(self class possibleTimeoutExceptions includes: ex class) 		ifTrue: [self updateCacheResponseCodeOnly.				^self class triggerTimeoutEvent: url].	(ex isResumable and: [self class exceptionsWeShouldResume includes: ex class] ) 		ifTrue: [ex resume]		ifFalse: [self reportTheErrorType: ex]</body><body package="NetResourcesHTTP">confirmCompressionSucceeded	self isGzipEncoding ifFalse: [^self].	cacheItem isHappyWithContent ifTrue: [^self].	Transcript cr; show: 'gzip compressed get failed, trying again on ', url asString.	cacheItem failedGzip: true.	cacheItem dropCacheState.	retry value</body><body package="NetResourcesHTTP">doRequest: requestBlock	| client request |	Online ifFalse: [^false].	request := requestBlock value.	self fillRequest: request.	client := self getLiveConnection.	client keepAlive: self shouldKeepAlive.	client when: #downloadAt:of: send: #downloadAt:of: to: self.	self getResponseFor: client request: request.	client removeActionsWithReceiver: self forEvent: #downloadAt:of:.	response ifNil: [response := client originalResponse].	self registerLiveConnection: client.	self updateCacheItem.	response ifNil: [^true].	^response code ~= '304'</body><body package="NetResourcesHTTP">downloadAt: aPosition of: aSize	url triggerEvent: #downloadAt:of: with: aPosition with: aSize</body><body package="NetResourcesHTTP">fillRequest: request	(request getFieldAt: 'User-Agent') value: self userAgent.	(request requestLine method = 'POST')		ifTrue: [(request getFieldAt: 'Content-Length') value: request contents size.				request contentType: 'application/x-www-form-urlencoded'].	self shouldAskForGzip ifTrue: [request acceptEncoding: #( '*')].	request accept: self class defaultAccept.	cacheItem hasMoved ifTrue: [request url: (request url resolvePath: cacheItem newLocation)].	cacheItem isValidForLastModified ifTrue:		[cacheItem lastModifiedTimestamp ifNotNil:			[(request getFieldAt: 'If-Modified-Since') value: cacheItem lastModifiedTimestamp].		cacheItem etags ifNotNil:			[(request getFieldAt: 'If-None-Match') value: cacheItem etags]].	cacheItem usesAuthorization ifTrue: [cacheItem addAuthorizationTo: request].	cacheItem hasCookies ifTrue: [request addCookies: cacheItem cookies]</body><body package="NetResourcesHTTP">getRealmFrom: aResponse	| entire basics digest |	entire := (aResponse wwwAuthenticate) first.	basics := entire  value select: [:each | 'Basic' match: each value].	basics notEmpty		ifTrue: [^basics first].	digest := (entire  value select: [:each | 'Digest' match: each value]).	^digest isEmpty		ifTrue: [nil]		ifFalse: [digest first]</body><body package="NetResourcesHTTP">getResponseFor: client request: request	response := nil.	client request: request.	response := [client executeRequestDo: [:connection | client getNotifyingResponse: connection]]		on: (self class httpExceptions, Error) do: [:ex | self behaviourForException: ex. nil].	response ifNil: [^self].	response isMoved ifTrue: [cacheItem newLocation: response location].	(response isUnauthorized and: [hasTriedAuth ~= #prompted]) ifTrue:		[cacheItem realm: (self getRealmFrom: response).		(cacheItem password isEmpty or: [hasTriedAuth = #optimistic])			ifTrue:	[hasTriedAuth := #prompted. self promptForAuthorization]			ifFalse:	[hasTriedAuth := #optimistic].		^retry value].	response code = '404' ifTrue: [response := nil]</body><body package="NetResourcesHTTP">isGzipEncoding	| encoding |	encoding := [response contentEncoding] on: MessageNotUnderstood				do: [:ex | nil].	encoding ifNil: [^false].	encoding = 'gzip' ifTrue: [^true].	encoding = 'deflate' ifTrue: [^true].	^encoding anySatisfy: [:each | #( 'gzip' 'deflate' ) includes: each]</body><body package="NetResourcesHTTP">promptForAuthorization	"get a username and password, then stuff a new cache object"	| dlg cookies |	dlg := UserAuthorizationDialog new.	dlg realm value: cacheItem realmName.	dlg promptURL value: url asString.	dlg open ifTrue:		[dlg remember value ifTrue:			[Net.Resources.Cache addCanSave: (dlg username value -&gt; dlg password value)].		cacheItem username: dlg username value.		cacheItem password: dlg password value].	cookies := response getCookies.	cacheItem cookies: cookies.</body><body package="NetResourcesHTTP">reportTheErrorType: ex	self class triggerEvent: #error with: ex with: self.	#{RSSError.RuntimeErrorLog} isDefined		ifTrue: [#{RSSError.RuntimeErrorLog} value addErrorText: 'NetResources Error: &lt;&lt;', ex errorString, '&gt;&gt; on url: ', url asString].	Transcript show: 'NetResources Error: &lt;&lt;', ex errorString, '&gt;&gt; on url: ', url asString; cr</body><body package="NetResourcesHTTP">shouldAskForGzip	^cacheItem failedGzip not</body><body package="NetResourcesHTTP">uncompress: gzippedContents	| size stream contents |	size := gzippedContents size.	contents := [| result |			stream := OS.ZLib.GZipReadStream on: gzippedContents from: 1 to: size.			result := stream decompressAll contents.			result]		on: Error		do: [:ex | nil].	^contents notNil		ifTrue: [contents]		ifFalse: [nil]</body><body package="NetResourcesHTTP">updateCacheItem	response ifNil: [^self].	cacheItem code: response code.	cacheItem lastModified: (response getFieldAt: 'last-modified') value.	cacheItem etags: (response getFieldAt: 'etag') value.	cacheItem cookies: response getCookies.	response code = '304' ifTrue: [^self].	cacheItem mimeType: response contentType.	response wwwAuthenticate notEmpty ifTrue: [cacheItem realm: (self getRealmFrom: response)].	cacheItem contents: self responseContents.	cacheItem encoding: response charset.	response isMoved ifTrue: [cacheItem newLocation: response location].	self confirmCompressionSucceeded</body><body package="NetResourcesHTTP">updateCacheResponseCodeOnly	cacheItem ifNil: [^self].	response ifNil: [^cacheItem code: '408'].	cacheItem code: response code.</body></methods><methods><class-id>Net.Resources.HttpClientModel</class-id> <category>initialize-release</category><body package="NetResourcesHTTP">initialize	hasTriedAuth := #no.	shouldKeepAlive := true</body><body package="NetResourcesHTTP">uri: aURI cacheItem: aCacheItem	self initialize.	url := aURI.	cacheItem := aCacheItem</body></methods><methods><class-id>Net.Resources.HttpClientModel</class-id> <category>API</category><body package="NetResourcesHTTP">delete	retry := MessageSend receiver: self selector: #delete.	^self doRequest: [HttpRequest delete: url]</body><body package="NetResourcesHTTP">get	Online ifFalse: [^false].	retry := MessageSend receiver: self selector: #get.	^self doRequest: [HttpRequest get: url]</body><body package="NetResourcesHTTP">post: content encoding: encoding	retry := MessageSend receiver: self selector: #post:encoding: arguments: (Array with: content with: encoding).	^self doRequest:		[(HttpRequest post: url)			contentType: encoding;			contents: content;			yourself]</body><body package="NetResourcesHTTP">put: content encoding: encoding	retry := MessageSend receiver: self selector: #put:encoding: arguments: (Array with: content with: encoding).	^self doRequest:		[(HttpRequest put: url)			contentType: encoding;			contents: content;			yourself]</body></methods><methods><class-id>Net.Resources.HttpClientModel</class-id> <category>accessing</category><body package="NetResourcesHTTP">defaultVersionString	| version parcel |	parcel := Parcel parcelNamed: 'NetResourcesHTTP'.	version := parcel isNil ifTrue: [''] ifFalse: [parcel version].	version notEmpty		ifTrue: [| stream part |				stream := version readStream.				part := stream upTo: $,.				version := part copyWithout: $(].	^'NetResources/1 (' , (ExternalInterface currentPlatform at: 2) , '; ' 		, Locale current name , ')  NetResourcesHTTP/' 		, version</body><body package="NetResourcesHTTP">platform	OSHandle currentOS = #win32 ifTrue: [^'Windows'].	OSHandle currentOS = #unix ifTrue: [^'Unix'].	OSHandle currentOS = #os2 ifTrue: [^'OS/2'].	^'Unknown'</body><body package="NetResourcesHTTP">responseContents	| responseContents |	(response body respondsTo: #byteSource)		ifTrue:			[response body byteSource notNil				ifTrue: [responseContents := response body byteSource reset; upToEnd]				ifFalse:					[response body source ifNil: [^''].					responseContents := response body source stream reset; upToEnd]]		ifFalse:			[response body source ifNil: [^''].			responseContents := response body source stream reset; upToEnd].	^self isGzipEncoding		ifTrue:	[self uncompress: responseContents]		ifFalse:	[responseContents]</body><body package="NetResourcesHTTP">userAgent	self class userAgent isNil 		ifTrue: [self class userAgent: self defaultVersionString].	^self class userAgent</body></methods><methods><class-id>Net.Resources.HttpClientModel</class-id> <category>private - live connections</category><body package="NetResourcesHTTP">getLiveConnection	^self liveConnections		nrAt:			url host		ifPresent:	[:connection |			self liveConnections removeKey: url host ifAbsent: [].			(self liveConnectionsTimeout removeKey: url host ifAbsent: [nil]) ifNotNil: [:process | process terminate].			connection]		ifAbsent:	[url newClient]</body><body package="NetResourcesHTTP">liveConnections	^self class liveConnections</body><body package="NetResourcesHTTP">liveConnectionsTimeout	^self class liveConnectionsTimeout</body><body package="NetResourcesHTTP">newTimeoutProcessFor: client 	^	[ | connection |	(Delay forSeconds: 2) wait.	connection := self liveConnections at: url host ifAbsent: [nil].	connection == client ifTrue: [[self timeoutConnection: client] fork]	]</body><body package="NetResourcesHTTP">registerLiveConnection: client 	| timeoutProcess |	response ifNil: [^client close].	response version asNumber &gt; 1 ifFalse: [^client close].	(response connection notNil and: [response connection includes: 'close']) ifTrue: [^client close].	self shouldKeepAlive ifFalse: [^client close].	timeoutProcess := (self newTimeoutProcessFor: client) newProcess.	timeoutProcess name: 'Timeout live connection to: ' , url host.	client originalResponse: nil.	self liveConnections at: url host put: client.	self liveConnectionsTimeout at: url host put: timeoutProcess.	timeoutProcess resume</body><body package="NetResourcesHTTP">shouldKeepAlive	^shouldKeepAlive and: [LiveConnections]</body><body package="NetResourcesHTTP">shouldKeepAlive: anObject	shouldKeepAlive := anObject</body><body package="NetResourcesHTTP">timeoutConnection: client	self liveConnections removeKey: url host ifAbsent: [].	self liveConnectionsTimeout removeKey: url host ifAbsent: [].	client close</body></methods><methods><class-id>Net.Resources.HttpClientModel class</class-id> <category>instance creation</category><body package="NetResourcesHTTP">newFor: aURI on: aCacheItem	^self new uri: aURI cacheItem: aCacheItem; yourself</body></methods><methods><class-id>Net.Resources.HttpClientModel class</class-id> <category>accessing</category><body package="NetResourcesHTTP">defaultAccept	^DefaultAccept isNil		ifTrue: [DefaultAccept := '*/*']		ifFalse: [DefaultAccept].</body><body package="NetResourcesHTTP">defaultAccept: acceptString	^DefaultAccept := acceptString</body><body package="NetResourcesHTTP">liveConnections	^liveConnections ifNil: [liveConnections := ThreadSafeDictionary new]</body><body package="NetResourcesHTTP">liveConnectionsTimeout	^liveConnectionsTimeout ifNil: [liveConnectionsTimeout := ThreadSafeDictionary new]</body><body package="NetResourcesHTTP">online	^Online</body><body package="NetResourcesHTTP">online: aBoolean	Online := aBoolean</body><body package="NetResourcesHTTP">userAgent	^AgentString</body><body package="NetResourcesHTTP">userAgent: aString	AgentString := aString</body></methods><methods><class-id>Net.Resources.HttpClientModel class</class-id> <category>exception-handling</category><body package="NetResourcesHTTP">exceptionsWeShouldResume	"which ones should we actually resume?"	^Array		with: Security.SSLBadCertificate		with: Net.HttpRedirectionError		with: HttpUnauthorizedError</body><body package="NetResourcesHTTP">httpExceptions	| set |	set := ExceptionSet new.	set add: HttpException.	set add: HttpRedirectionError. 	set add: HttpObjectNotFound.	set add: Smalltalk.OSErrorHolder notReadySignal.	set add: OS.OSErrorHolder notReadySignal.	set add: OS.OSErrorHolder unsupportedOperationSignal.	set add: OS.OSErrorHolder peerFaultSignal.	set add: OS.OSErrorHolder inaccessibleSignal.	set add: OS.OsTransferFaultError.	set add: OS.OsIllegalOperation.	set add: HttpServerError.	set add: HttpTimeout.	set add: HttpStatusLineError. 	set add: Security.SSLBadCertificate.	set add: HttpUnauthorizedError.	^set</body><body package="NetResourcesHTTP">possibleTimeoutExceptions	^Array 		with:OS.OSErrorHolder peerFaultSignal		with: HttpTimeout		with: OsTransferFaultError</body><body package="NetResourcesHTTP">triggerTimeoutEvent: anUrl	"we send a change event when getting a timeout.  This allows clients to deal with the possibility	of a cascading set of network failures"	self triggerEvent: #timeoutEvent: with: anUrl</body></methods><methods><class-id>Net.MimeEncodedWordCoDec</class-id> <category>parsing</category><body package="NetResourcesHTTP">decodeText: text " Decoding of text is similar to decoding of comment, but RFC2047 requires that an encoded word that appears in in *text token MUST be separated from any adjacent encoded word or text by a linear-white-spaceRFC 2047:  When displaying a particular header field that contains multiple 'encoded-word's, any 'linear-white-space' that separates a pair of adjacent 'encoded-word's is ignored.  (This is to allow the use of multiple 'encoded-word's to represent long strings of unencoded text,  without having to separate 'encoded-word's where spaces occur in the  unencoded text.)""Modified by JR, 8/23/06.  If no header for a spot, answer nil.  Yes, that's bogus"	| output word spaces |	text ifNil: [^text].	(text indexOfSubCollection: '=?' startingAt: 1) = 0 		ifTrue: [^text].		self on: text readStream.	output := (String new: text size) writeStream.	[self atEnd]		whileFalse: 			[word := self scanWord. 			self decode: word on: output.			spaces := self scanSpaces.			self shouldAddSpaces ifTrue: [output nextPutAll: spaces]]. 	^output contents</body></methods><methods><class-id>Core.StreamEncoder class</class-id> <category>private</category><body package="NetResourcesHTTP">lookupEncoderDirectory: sym	"modified by JR 8/24/06.  If we have no charset, assume utf8"	| val |	val := sym.	val ifNil: [^self encoderDirectory at: #utf8].	[val := self encoderDirectory at: val asLowercase asSymbol.	val class == BlockClosure		ifTrue: [val := val value].	val isSymbol] whileTrue.	^val</body></methods><methods><class-id>Net.HttpURL class</class-id> <category>accessing</category><body package="NetResourcesHTTP">httpTrace	^HttpTrace ifNil: [false]</body><body package="NetResourcesHTTP">httpTrace: aTrace	HttpTrace := aTrace</body></methods><methods><class-id>Net.HttpURL</class-id> <category>private-NetResources</category><body package="NetResourcesHTTP">cacheItemClass	^Net.Resources.HttpCacheItem</body><body package="NetResourcesHTTP">canCache	^true</body><body package="NetResourcesHTTP">deleteCacheItem: aCacheItem	"Transcript cr; show: 're-deleting on web: ', self asString."	^self hostLock critical:		[(Net.Resources.HttpClientModel newFor: self on: aCacheItem) delete.		aCacheItem]</body></methods><methods><class-id>Net.HttpURL</class-id> <category>accessing</category><body package="NetResourcesHTTP">hostLock	^HostLocks at: self host ifAbsentPut: [RecursionLock new]</body><body package="NetResourcesHTTP">httpTrace	^self class httpTrace</body></methods><methods><class-id>Net.HttpURL</class-id> <category>API-NetResources</category><body package="NetResourcesHTTP">isAvailable	^super isAvailable and: [self hostLock isLocked not]</body></methods><methods><class-id>Net.HttpURL</class-id> <category>private-NetResources</category><body package="NetResourcesHTTP">post: contents cacheItem: aCacheItem encoding: encoding	"Transcript cr; show: 'post on web: ', self asString."	^self hostLock critical:		[(Net.Resources.HttpClientModel newFor: self on: aCacheItem) post: contents encoding: encoding.		aCacheItem]</body><body package="NetResourcesHTTP">put: contents cacheItem: aCacheItem encoding: encoding	"Transcript cr; show: 'put on web: ', self asString."	^self hostLock critical:		[(Net.Resources.HttpClientModel newFor: self on: aCacheItem) put: contents encoding: encoding.		aCacheItem]</body><body package="NetResourcesHTTP">reconcileCacheItem: aCacheItem	^self hostLock critical:		[ | contents |		self httpTrace ifTrue:			[Transcript cr; show: 'reconcile: ', self asString.			self resourceManagerDo: [:x | Transcript show: ' .. in RM']].		(Net.Resources.HttpClientModel newFor: self on: aCacheItem) get			ifFalse: [aCacheItem hasChanged: false. ^false].		contents := aCacheItem contents.		aCacheItem dropVolitileState.		aCacheItem contents: contents.		aCacheItem hasChanged: true.		true]</body></methods><methods><class-id>Net.Resources.Cache class</class-id> <category>accessing</category><body package="NetResourcesHTTP">addCanSave: aCanSave	self canSaves add: aCanSave</body><body package="NetResourcesHTTP">canSaves	^CanSaves ifNil: [CanSaves := OrderedCollection new]</body><body package="NetResourcesHTTP">cookies	^Cookies ifNil: [Cookies := Dictionary new]</body><body package="NetResourcesHTTP">cookies: anObject	Cookies := anObject</body><body package="NetResourcesHTTP">passwords	^Passwords ifNil: [Passwords := Dictionary new]</body><body package="NetResourcesHTTP">passwords: anObject	Passwords := anObject</body></methods><methods><class-id>Net.Resources.Cache</class-id> <category>accessing</category><body package="NetResourcesHTTP">cookiesForHost: aHostAndPort	self class cookies keysAndValuesDo: [:url :cookies |		cookies do: [:cookie |			(cookie expires notNil and: [cookie expires isString])				ifTrue: [cookie fixDate]]].	^self class cookies at: aHostAndPort ifAbsent: [OrderedCollection new]</body><body package="NetResourcesHTTP">httpCacheItemsInMemory	^self memory values select: [:each | each uri isKindOf: HttpURL]</body><body package="NetResourcesHTTP">saveEncryptedPasswords	| encrypted boss |	encrypted := Dictionary new.	self class passwords keysAndValuesDo: [:key :value |		| node |		node := Net.NetSettings createPasswordNode: value value tag: 'password'.		node := node attributes detect: [:e | e tag type = 'password'].		(self class canSaves includes: value) ifTrue:			[encrypted at: key put: (value key -&gt; node value)]].	[boss := BinaryObjectStorage onNew: 'passwords.dat' asFilename writeStream.	[boss nextPut: encrypted] ensure: [boss close]] on: Error do: [:sig | ]</body><body package="NetResourcesHTTP">setCookies: cookies onHost: aHostAndPort	self class cookies at: aHostAndPort put: cookies</body><body package="NetResourcesHTTP">setUsername: username password: password onHost: aHostAndPort realm: aRealm	self class passwords at: (aHostAndPort -&gt; aRealm) put: (username -&gt; password).	self saveEncryptedPasswords</body><body package="NetResourcesHTTP">tryEncryptedPasswords: aKey	| encrypted boss password |	'passwords.dat' asFilename exists ifFalse: [^nil].	[boss := BinaryObjectStorage onOld: 'passwords.dat' asFilename readStream.	[encrypted := boss next] ensure: [boss close]] on: Error do: [:sig | ^nil].	password := encrypted at: aKey ifAbsent: [^nil].	^password key -&gt; (Net.NetSettings restorePassword: password value)</body><body package="NetResourcesHTTP">usernameAndPassForHost: aHostAndPort realm: aRealm	^self class passwords at: (aHostAndPort -&gt; aRealm) ifAbsent:		[(self tryEncryptedPasswords: (aHostAndPort -&gt; aRealm)) ifNotNil:			[:answer |			self class passwords at: (aHostAndPort -&gt; aRealm) put: answer.			self class addCanSave: answer.			^answer].		'' -&gt; '']</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>cookie-access</category><body package="NetResourcesHTTP">getCookieNamed: aString	^self getCookies detect: [:each | each name asLowercase = aString asLowercase] ifNone: [nil]</body><body package="NetResourcesHTTP">getCookies	"Returns all Cookies"	| cookies theCookies |	theCookies := OrderedCollection new.	cookies := self fieldsAt:  'set-cookie'.	cookies do: [:each | theCookies addAll: each value].	^theCookies</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="NetResourcesHTTP">isFailure	^true</body></methods><methods><class-id>VisualWave.HTTPCookie class</class-id> <category>instance creation</category><body package="NetResourcesHTTP">readFromHeader: cookieAsHeader	^self new readFromHeader: cookieAsHeader</body></methods><methods><class-id>VisualWave.HTTPCookie</class-id> <category>initialize-release</category><body package="NetResourcesHTTP">fixDate	"fix the string into a Timestamp"	| ts |	self expires isNil		ifTrue: [^self].	ts := [Net.RFC822Scanner dateAndTimeFrom: self expires]			on: Error			do: [:ex | [Timestamp nrFromISO8601: self expires]					on: Error					do: [:ex2 | [Timestamp readFrom: self expires readStream]						on: Error						do: [:ex3 | nil]]].	self expires: ts</body></methods><methods><class-id>VisualWave.HTTPCookie</class-id> <category>printing</category><body package="NetResourcesHTTP">printOn: stream	super printOn: stream.	stream nextPutAll: ' (', self name, '-&gt;', self value, ')'</body></methods><methods><class-id>VisualWave.HTTPCookie</class-id> <category>initialize-release</category><body package="NetResourcesHTTP">readFromHeader: cookieAsHeader	| stream |	stream := cookieAsHeader value readStream.	self readFromStream: stream</body><body package="NetResourcesHTTP">readFromStream: stream	self name: (stream upTo: $=).	self value: (stream upTo: $;).	[stream atEnd]		whileFalse: [| next msg val |			next := (stream upTo: $=) trimBlanks asLowercase.			stream atEnd				ifFalse: [msg := (next, ':') asSymbol.						val := stream upTo: $;.						[self perform: msg with: val]							on: MessageNotUnderstood							do: [:ex | ex resume]]].	self fixDate</body></methods><methods><class-id>Core.RecursionLock</class-id> <category>mutual exclusion</category><body package="NetResourcesHTTP">isLocked	^owner notNil</body></methods><methods><class-id>Net.AuthorizationField</class-id> <category>convenience</category><body package="NetResourcesHTTP">scheme: aString	self addScheme: aString</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="NetResourcesHTTP">nrFromISO8601: aString	"Timestamp fromISO8601: '1998-07-17T14:08:55' "	| year month day date time stream |	stream := aString readStream.	year := (stream upTo: $-) asNumber.	month := (stream upTo: $-) asNumber.	day := (stream next: 2) asNumber.	stream skip: 1.	time := Time readFrom: stream upToEnd readStream.	date := Date 		newDay: day		monthNumber: month		year:  year.	^self 		fromDate: date		andTime: time</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing fields</category><body package="NetResourcesHTTP">addCookie: aCookie	(self getFieldAt: 'set-cookie') value: aCookie valueString</body><body package="NetResourcesHTTP">addCookies: cookies	(self getFieldAt: 'Cookie')		version: nil;		value: cookies</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>private-auth</category><body package="NetResourcesHTTP">realm: realm username: user password: pass qop: qop nonce: nonce cnonce: cnonce uri: uri digestResponse: digestResponse 	| stream |	stream := WriteStream on: String new.	stream nextPutAll: 'Digest '.	stream nextPutAll: 'username="', user.	stream nextPut: $".	stream nextPutAll: ', realm="', realm.	stream nextPutAll: '", '.	stream nextPutAll: 'nonce="', nonce.	stream nextPutAll: '", '.	stream nextPutAll: 'uri="', uri.	stream nextPutAll: '", '.	stream nextPutAll: 'algorithm=MD5, '.	stream nextPutAll: 'response="', digestResponse.	stream nextPutAll: '", '.	stream nextPutAll: 'qop='.	stream nextPutAll: qop.	stream nextPutAll: ', '.	stream nextPutAll: 'nc=00000001, '.	stream nextPutAll: 'cnonce="', cnonce.	stream nextPut: $".	self addAuthorizationCode: stream contents</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing fields</category><body package="NetResourcesHTTP">username: unString password: pString	^self realm: 'Basic' username: unString password: pString</body></methods><methods><class-id>Net.HttpClient</class-id> <category>accessing</category><body package="NetResourcesHTTP">downloadAt: aPosition of: aSize	self triggerEvent: #downloadAt:of: with: aPosition with: aSize</body><body package="NetResourcesHTTP">getNotifyingResponse: aConnection	| resp stream | 	^[stream := self clientPI responseStream. 	request headerOnly		ifTrue: [resp := Net.Resources.HttpClientResponse readHeaderFrom: stream ]		ifFalse: 				[resp := Net.Resources.HttpClientResponse new.			resp when: #downloadAt:of: send: #downloadAt:of: to: self.			resp readFrom: stream.			resp removeActionsWithReceiver: self forEvent: #downloadAt:of:].	resp log.	self originalResponse: resp.	(resp connection notNil and: [resp isConnectionTransient ]) ifTrue: [ self close]. 	 HttpException handleResponse: resp.	"If the response is nil, but we cached the original and it's unauthorized, use that"	resp := self possiblyReplaceResponse: resp.	"response is success "	self registerCookiesFromResponse: resp.	resp	] on: HttpException	 do:  [ :ex | 		(resp := self clientPI handleResponseException: ex ) isNil 			ifTrue: [ ex pass]			ifFalse: [ resp ]].</body><body package="NetResourcesHTTP">possiblyReplaceResponse: resp	"if the response is nil AND the original was unauthorized, then answer the original"	self originalResponse ifNil: [^resp].	^(resp isNil and: [self originalResponse isUnauthorized])		ifTrue: [self originalResponse]		ifFalse: [resp]</body></methods><methods><class-id>Net.Resources.UserAuthorizationDialog class</class-id> <category>interface specs</category><body package="NetResourcesHTTP">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 'Security Notice' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1056 703 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #authRealm 							#label: 'Authorization:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 68 ) 							#name: #usernameLabel 							#label: '&amp;Username:' 							#mnemonic: #username ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 98 ) 							#name: #passwordLabel 							#label: '&amp;Password:' 							#mnemonic: #password ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 79 0 70 0 0 0.997537 90 0 ) 							#name: #username 							#model: #username ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 79 0 100 0 0 0.997537 120 0 ) 							#name: #password 							#model: #password 							#type: #password ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 95 0 0 0.00813008 0 1.0 23 0 ) 							#name: #realm 							#flags: 0 							#model: #realm 							#tabable: false 							#isReadOnly: true ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 30 ) 							#name: #forURLLabel 							#label: 'For URL:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.23399 0 0.252033 0 1.0 0 0.430894 ) 							#name: #promptURL 							#flags: 0 							#model: #promptURL 							#tabable: false 							#isReadOnly: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.0120192 0 0.0209424 0 0.987981 0 0.664921 ) 						#name: #Composite1 ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -120 0.5 -30 1 -20 0.5 -5 1 ) 					#name: #accept 					#model: #accept 					#label: '&amp;Accept' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0.5 -30 1 120 0.5 -5 1 ) 					#name: #cancel 					#model: #cancel 					#label: '&amp;Cancel' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 85 130 ) 					#name: #remember 					#model: #remember 					#label: 'Save Password' ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>HttpResponse</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statusLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>Cache</name><environment>Net.Resources</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory </inst-vars><class-inst-vars>singleton cachePath </class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MimeEncodedWordCoDec</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>RecursionLock</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>HTTPCookie</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value expires path domain secure comment httponly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Wave-Server</package></attributes></class><class><name>AuthorizationField</name><environment>Net</environment><super>Net.AuthenticateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>HttpClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request keepAlive protocol originalResponse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>Http-Overrides</package></attributes></class><class><name>HttpBuildHandler</name><environment>Net</environment><super>Net.MimeParserHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>HttpURL</name><environment>Net</environment><super>OS.URLwithAuthority</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user decompressContents decodeContents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>HttpRequest</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>CacheItem</name><environment>Net.Resources</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encodings contents encoding mimeType lastModified uri hasChanged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>NetResources</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>