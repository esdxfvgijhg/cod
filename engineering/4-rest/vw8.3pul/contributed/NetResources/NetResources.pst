<?xml version="1.0"?><st-source><!-- Name: NetResourcesComment: NetResources provides a simple API for accessing content via URIs.Usage:NetResources can transform the content of a URI into a relevant object. For example:	'http://www.w3.org' asURI asResourceThis package can use the following other packages:	a) GIFSupport - for viewing GIF images	b) WinGDIPlusInterface - for viewing many kinds of images. Windows only. Needs the gdi+.dll	c) LibTidy or Twoflower - for viewing badly formed XML and HTML and using HTML entities	d) PNGImageReader - for viewing PNG imagesLimitations:This package does not provide HTTP behaviour, see NetResourcesHTTP to use the API with HTTP. NetResources works with URIs. It currently supports File URLs, HTTP URLs and Resource URLs. It does not work with FTP URLs at present.Implementation:NetResources provides a new kind of URI called a 'resource' URI. It works like so:	resource://MyNamespace.MyClass/myClassMethodAccessing this URI sends myClassMethod to MyClass. For a POST, the same method name is called except with a : (i.e., myClassMethod:) and an argument that contains the parameters of the post.NetResources has an in-memory and on-disk cache mechanism using CacheItem objects. If the directory './cache' exists then instances of CacheItem are written to disk for later retrieval if the CacheItem is not already in memory. A CacheItem checks its own timestamp to ensure the content is not out of date.NetResources provides the following API for URIs:	#asCacheItem	#asCacheItemUnreconciled	#asEncodedCacheItem	#asResource	#asResourceInEncoding: anEncoding	#asResourceInMimeType: aMimeType	#asResourceInMimeType: aMimeType encoding: anEncoding	#binaryValueStream	#valueStream	#delete	#refresh	#post: contents	#post: contents encoding: anEncoding	#put: contents	#put: contents encoding: anEncoding	#isAvailable	#hasChangedConverting the contents of a URL into a Resource object such as an XML DOM tree or an Image object is done using a ResourceHandler. All ResourcesHandlers are subclasses of ResourceHandler. A specific ResourceHandler is picked based on the MimeType of a URI. For File URIs, this is guessed from the filename extension. For HTTP, the HTTP request itself gives the mime type, etc. Each ResourceHandler class must implement the class-side method #canHandle: to say whether that class can handle a given mime type for a URI. On the instance side, a ResourceHandler must implement #handle: contents for: aURI to return the object of interest for a URIs contents.License:The intent of this document is to state the conditions under which a Package may be copied, such that the Copyright Holder maintains some semblance of artistic control over the development of the package, while giving the users of the package the right to use and distribute the Package in a more-or-less customary fashion, plus the right to make reasonable modifications.Definitions:    * "Package" refers to the collection of files distributed by the Copyright Holder, and derivatives of that collection of files created through textual modification.    * "Standard Version" refers to such a Package if it has not been modified, or has been modified in accordance with the wishes of the Copyright Holder.    * "Copyright Holder" is whoever is named in the copyright or copyrights for the package.    * "You" is you, if you're thinking about copying or distributing this Package.    * "Reasonable copying fee" is whatever you can justify on the basis of media cost, duplication charges, time of people involved, and so on. (You will not be required to justify it to the Copyright Holder, but only to the computing community at large as a market that must bear the fee.)    * "Freely Available" means that no fee is charged for the item itself, though there may be fees involved in handling the item. It also means that recipients of the item may redistribute it under the same conditions they received it.1. You may make and give away verbatim copies of the source form of the Standard Version of this Package without restriction, provided that you duplicate all of the original copyright notices and associated disclaimers.2. You may apply bug fixes, portability fixes and other modifications derived from the Public Domain or from the Copyright Holder. A Package modified in such a way shall still be considered the Standard Version.3. You may otherwise modify your copy of this Package in any way, provided that you insert a prominent notice in each changed file stating how and when you changed that file, and provided that you do at least ONE of the following:    a) place your modifications in the Public Domain or otherwise make them Freely Available, such as by posting said modifications to Usenet or an equivalent medium, or placing the modifications on a major archive site such as ftp.uu.net, or by allowing the Copyright Holder to include your modifications in the Standard Version of the Package.    b) use the modified Package only within your corporation or organization.    c) rename any non-standard executables so the names do not conflict with standard executables, which must also be provided, and provide a separate manual page for each non-standard executable that clearly documents how it differs from the Standard Version.    d) make other distribution arrangements with the Copyright Holder.4. You may distribute the programs of this Package in object code or executable form, provided that you do at least ONE of the following:    a) distribute a Standard Version of the executables and library files, together with instructions (in the manual page or equivalent) on where to get the Standard Version.    b) accompany the distribution with the machine-readable source of the Package with your modifications.    c) accompany any non-standard executables with their corresponding Standard Version executables, giving the non-standard executables non-standard names, and clearly documenting the differences in manual pages (or equivalent), together with instructions on where to get the Standard Version.    d) make other distribution arrangements with the Copyright Holder.5. You may charge a reasonable copying fee for any distribution of this Package. You may charge any fee you choose for support of this Package. You may not charge a fee for this Package itself. However, you may distribute this Package in aggregate with other (possibly commercial) programs as part of a larger (possibly commercial) software distribution provided that you do not advertise this Package as a product of your own.6. The scripts and library files supplied as input to or produced as output from the programs of this Package do not automatically fall under the copyright of this Package, but belong to whomever generated them, and may be sold commercially, and may be aggregated with this Package.7. C or perl subroutines supplied by you and linked into this Package shall not be considered part of this Package.8. The name of the Copyright Holder may not be used to endorse or promote products derived from this software without specific prior written permission.9. THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.10. The user must assume all risk of using this packageThe EndCopyright Holders: Software WithStyle, James RobertsonDbIdentifier: psql_public_cst_2007DbTrace: 92373DbUsername: niallrDbVersion: 1.103DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'URISupport' '') #(#any 'ImageReaders' '') #(#any 'Protocols-Common' ''))PackageName: NetResourcesParcel: #('NetResources')ParcelName: NetResourcesPrerequisiteDescriptions: #(#(#name 'NetClientBase' #componentType #package) #(#name 'URISupport') #(#name 'ImageReaders' #componentType #package) #(#name 'Protocols-Common' #componentType #package))PrerequisiteParcels: #(#('NetClientBase' '') #('URISupport' '') #('ImageReaders' '') #('Protocols-Common' ''))PrintStringCache: (1.103,niallr)Version: 1.103Pre-Save Block: 	[:package | ]Date: 4:34:20 PM January 27, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 27, 2016 at 4:34:20 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Resources</name><environment>Net</environment><private>false</private><imports>			private Smalltalk.*			private Net.*			</imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></name-space><class><name>ResourceHandler</name><environment>Net.Resources</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerImages</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerImageXBM</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandlerImages</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>DataURI</name><environment>Net.Resources</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mimeType characterSet base64 data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NetResources</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceManager</name><environment>Net.Resources</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uris </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><comment><class-id>Net.Resources.ResourceManager</class-id><body>ResourceManager is used to hold on to Resources within a "session" of User Interface activity. This will allow a resource not to be refreshed from a website (for example) while-ever this resource manager is activate.Instance Variables:	uris	&lt;Collection&gt;	description of uris</body></comment><class><name>SmalltalkURI</name><environment>Net.Resources</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>script </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NetResources</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerPlain</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerImagePNG</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandlerImages</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerImagePixmap</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandlerImages</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerImageJPEG</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandlerImages</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerXML</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>allowHTML </class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ThreadSafeDictionary</name><environment>Net.Resources</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>lock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>Cache</name><environment>Net.Resources</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory </inst-vars><class-inst-vars>singleton cachePath </class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>ResourceURL</name><environment>Net.Resources</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><comment><class-id>Net.Resources.ResourceURL</class-id><body>Like http:// and ftp://, this class provides method://.The URI format is: method://Namespace.ClassName/MethodName.method://Thing.Something/aMethodis like writing the code:^Thing.Something aMethodInstance Variables:	className	The Namespace.ClassName string</body></comment><class><name>ResourceHandlerImageGIF</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandlerImages</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>EncodedCacheItem</name><environment>Net.Resources</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cacheItem resource contents encoding mimeType failed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerImageBMP</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandlerImages</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><class><name>CacheItem</name><environment>Net.Resources</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encodings contents encoding mimeType lastModified uri hasChanged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>NetResources</package></attributes></class><class><name>ResourceHandlerImageWinGDIPlus</name><environment>Net.Resources</environment><super>Net.Resources.ResourceHandlerImages</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WithStyle</category><attributes><package>NetResources</package></attributes></class><methods><class-id>Net.Resources.ResourceHandler</class-id> <category>API</category><body package="NetResources">defaultEncodingType	^#binary</body><body package="NetResources">getEncodingFor: aCacheItem	^self defaultEncodingType</body><body package="NetResources">handle: valueStream for: aURL	^nil</body></methods><methods><class-id>Net.Resources.ResourceHandler</class-id> <category>testing</category><body package="NetResources">isHappyWithFirstCharacter: aCharacter	^true</body></methods><methods><class-id>Net.Resources.ResourceHandler class</class-id> <category>API</category><body package="NetResources">canHandle: aMimeType	^self mimeTypes includes: aMimeType</body><body package="NetResources">handlerClassFor: aMimeType	| mimeTypeClasses |	mimeTypeClasses := self allSubclasses select: [:each | each canHandle: aMimeType].	mimeTypeClasses isEmpty ifTrue: [^self].	^(mimeTypeClasses asSortedCollection: [:a :b | a weight &gt; b weight]) first</body><body package="NetResources">mimeTypes	^#()</body><body package="NetResources">weight	^0</body></methods><methods><class-id>Net.Resources.ResourceHandlerImages</class-id> <category>constants</category><body package="NetResources">imageClass	^self subclassResponsibility</body></methods><methods><class-id>Net.Resources.ResourceHandlerImages</class-id> <category>API</category><body package="NetResources">handle: valueStream for: aURL	| reader |	reader := [self imageClass new from: valueStream]		on: Error do: [:sig | Transcript cr; show: self class name printString, '&gt;&gt;handle:for: | ', sig printString. ^nil].	^reader image asCachedImage.</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageXBM</class-id> <category>constants</category><body package="NetResources">imageClass	^XBMImageReader</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageXBM class</class-id> <category>API</category><body package="NetResources">mimeTypes	^#( 'image/xbm' )</body></methods><methods><class-id>Net.Resources.DataURI</class-id> <category>accessing</category><body package="NetResources">asString	^self class protocol, ':', mimeType, self characterSetString, self base64String, ',', data</body><body package="NetResources">base64	^base64</body><body package="NetResources">base64: anObject	base64 := anObject</body><body package="NetResources">base64String	base64 ifFalse: [^''].	^';base64'</body><body package="NetResources">characterSet	^characterSet</body><body package="NetResources">characterSet: anObject	characterSet := anObject</body><body package="NetResources">characterSetString	characterSet ifNil: [^''].	^';charset=', characterSet</body><body package="NetResources">data	^data</body><body package="NetResources">data: anObject	data := anObject</body><body package="NetResources">mimeType	^mimeType</body><body package="NetResources">mimeType: anObject	mimeType := anObject</body><body package="NetResources">resource	" *** This method was defined by Net.URI as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Net.Resources.DataURI</class-id> <category>stream creation</category><body package="NetResources">binaryReadStream	| decodedArray |	base64 ifFalse: [^data readStream].	decodedArray := ByteArray fromBase64String: data.	^decodedArray asString readStream</body><body package="NetResources">binaryWriteStream	self error: 'Data URI''s are read only'</body><body package="NetResources">readStream	^self binaryReadStream</body><body package="NetResources">readStreamDo: aBlock	aBlock value: self binaryReadStream</body><body package="NetResources">writeStream	^self binaryWriteStream</body><body package="NetResources">writeStreamDo: aBlock	aBlock value: self binaryWriteStream</body></methods><methods><class-id>Net.Resources.DataURI</class-id> <category>private-NetResources</category><body package="NetResources">deleteCacheItem: aCacheItem	^aCacheItem</body><body package="NetResources">post: contents cacheItem: aCacheItem encoding: encoding	| cacheItem |	cacheItem := aCacheItem class new.	cacheItem uri: aCacheItem uri.	characterSet := encoding.	data := base64		ifTrue: [contents asByteArray asBase64String]		ifFalse: [contents].	cacheItem		encoding: (characterSet ifNil: [#binary]);		mimeType: mimeType;		hasChanged: true;		lastModified: data;		contents: contents inEncoding: (encoding ifNil: [#binary]).	^cacheItem</body><body package="NetResources">put: contents cacheItem: aCacheItem encoding: encoding	^aCacheItem</body><body package="NetResources">reconcileCacheItem: aCacheItem	aCacheItem lastModified = data ifTrue:		[aCacheItem hasChanged: false.		^false].	aCacheItem		encoding: (characterSet ifNil: [#binary]);		hasChanged: true;		contents: self binaryReadStream upToEnd inEncoding: (characterSet ifNil: [#binary]);		mimeType: mimeType;		lastModified: data.	^true</body></methods><methods><class-id>Net.Resources.DataURI class</class-id> <category>accessing</category><body package="NetResources">protocol	^'data'</body></methods><methods><class-id>Net.Resources.DataURI class</class-id> <category>instance creation</category><body package="NetResources">fromString: aString	| comma uri meta |	comma := aString indexOf: $,.	comma isZero ifTrue: [^self error: 'This URI does not contain the expect comma'].	uri := self new.	uri data: (aString copyFrom: comma + 1 to: aString size).	meta := (aString copyFrom: 1 to: comma - 1) tokensBasedOn: $;.	meta isEmpty ifTrue: [^self error: 'This URI is missing its mime/type'].	uri mimeType: meta first.	uri base64: ((meta collect: [:ea | ea asLowercase]) includes: 'base64').	(meta detect: [:each | 'charset=*' match: each] ifNone: [nil]) ifNotNil: [:charset |		uri characterSet: (charset copyFrom: 9 to: charset size) asLowercase].	^uri</body></methods><methods><class-id>Net.Resources.ResourceManager</class-id> <category>API</category><body package="NetResources">activate	Processor activeProcess environmentAt: #resourceManager put: self</body><body package="NetResources">clear	uris := Set new</body><body package="NetResources">deactivate	Processor activeProcess environment localRemoveKey: #resourceManager</body></methods><methods><class-id>Net.Resources.ResourceManager</class-id> <category>private</category><body package="NetResources">addURI: uri	uris add: uri</body><body package="NetResources">includesURI: uri	^uris includes: uri</body><body package="NetResources">removeURI: uri	uris remove: uri ifAbsent: []</body></methods><methods><class-id>Net.Resources.ResourceManager</class-id> <category>initialize-release</category><body package="NetResources">initialize	uris := Set new</body></methods><methods><class-id>Net.Resources.ResourceManager class</class-id> <category>instance creation</category><body package="NetResources">new	^super new initialize</body></methods><methods><class-id>Net.Resources.SmalltalkURI</class-id> <category>accessing</category><body package="NetResources">asString	^self class protocol, ':', script</body><body package="NetResources">resource	" *** This method was defined by Net.URI as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="NetResources">script	^script</body><body package="NetResources">script: anObject	script := anObject</body></methods><methods><class-id>Net.Resources.SmalltalkURI</class-id> <category>private-NetResources</category><body package="NetResources">deleteCacheItem: aCacheItem	^aCacheItem</body><body package="NetResources">post: contents cacheItem: aCacheItem encoding: encoding	^aCacheItem</body><body package="NetResources">put: contents cacheItem: aCacheItem encoding: encoding	^aCacheItem</body><body package="NetResources">reconcileCacheItem: aCacheItem	^true</body></methods><methods><class-id>Net.Resources.SmalltalkURI</class-id> <category>testing</category><body package="NetResources">isScriptURI	^true</body><body package="NetResources">isSmalltalkURI	^true</body></methods><methods><class-id>Net.Resources.SmalltalkURI</class-id> <category>stream creation</category><body package="NetResources">binaryReadStream	^Compiler evaluate: script</body><body package="NetResources">binaryWriteStream	self error: 'Smalltalk URI''s are read only'</body><body package="NetResources">readStream	^self binaryReadStream</body><body package="NetResources">readStreamDo: aBlock	aBlock value: self binaryReadStream</body><body package="NetResources">writeStream	^self binaryWriteStream</body><body package="NetResources">writeStreamDo: aBlock	aBlock value: self binaryWriteStream</body></methods><methods><class-id>Net.Resources.SmalltalkURI class</class-id> <category>instance creation</category><body package="NetResources">fromString: aString	^self new		script: aString;		yourself</body></methods><methods><class-id>Net.Resources.SmalltalkURI class</class-id> <category>accessing</category><body package="NetResources">protocol	^'smalltalk'</body></methods><methods><class-id>Net.Resources.ResourceHandlerPlain</class-id> <category>API</category><body package="NetResources">defaultEncodingType	^ByteString encodingType</body><body package="NetResources">handle: valueStream for: aURI	^valueStream upToEnd</body></methods><methods><class-id>Net.Resources.ResourceHandlerPlain class</class-id> <category>API</category><body package="NetResources">mimeTypes	^#( 'text/plain' 'text/txt' )</body></methods><methods><class-id>Net.Resources.ResourceHandlerImagePNG</class-id> <category>constants</category><body package="NetResources">imageClass	^#{Graphics.PNGImageReader} valueOrDo: [nil]</body></methods><methods><class-id>Net.Resources.ResourceHandlerImagePNG class</class-id> <category>API</category><body package="NetResources">mimeTypes	self basicNew imageClass ifNil: [^#()].	^#( 'image/png' )</body></methods><methods><class-id>Net.Resources.ResourceHandlerImagePixmap</class-id> <category>API</category><body package="NetResources">handle: valueStream for: aURL	(valueStream collection isKindOf: OpaqueImage) ifTrue: [^valueStream collection asCachedImage].	^valueStream collection image asCachedImage</body></methods><methods><class-id>Net.Resources.ResourceHandlerImagePixmap class</class-id> <category>API</category><body package="NetResources">mimeTypes	^#( 'image/pixmap' )</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageJPEG</class-id> <category>constants</category><body package="NetResources">imageClass	^JPEGImageReader</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageJPEG class</class-id> <category>API</category><body package="NetResources">mimeTypes	^#( 'image/jpg' 'image/jpeg' )</body></methods><methods><class-id>Net.Resources.ResourceHandlerXML</class-id> <category>API</category><body package="NetResources">addTwoflowerEntities: details 	| entities |	(details includesKey: #characterEntities) ifTrue: [^self].	entities := Core.Dictionary new				add: 'Otilde' -&gt; 213;				add: 'Iacute' -&gt; 205;				add: 'Egrave' -&gt; 200;				add: 'iexcl' -&gt; 161;				add: 'Atilde' -&gt; 195;				add: 'copy' -&gt; 169;				add: 'frac12' -&gt; 189;				add: 'ccedil' -&gt; 231;				add: 'Icirc' -&gt; 206;				add: 'ntilde' -&gt; 241;				add: 'deg' -&gt; 176;				add: 'szlig' -&gt; 223;				add: 'eth' -&gt; 240;				add: 'oacute' -&gt; 243;				add: 'Uacute' -&gt; 218;				add: 'raquo' -&gt; 187;				add: 'iquest' -&gt; 191;				add: 'shy' -&gt; 173;				add: 'iuml' -&gt; 239;				add: 'Ouml' -&gt; 214;				add: 'frac14' -&gt; 188;				add: 'ocirc' -&gt; 244;				add: 'Ucirc' -&gt; 219;				add: 'aacute' -&gt; 225;				add: 'oslash' -&gt; 248;				add: 'quot' -&gt; 34;				add: 'Scaron' -&gt; 352;				add: 'Dagger' -&gt; 8225;				add: 'uuml' -&gt; 252;				add: 'amp' -&gt; 38;				add: 'ndash' -&gt; 8211;				add: 'Auml' -&gt; 196;				add: 'acirc' -&gt; 226;				add: 'igrave' -&gt; 236;				add: 'Ograve' -&gt; 210;				add: 'cedil' -&gt; 184;				add: 'yen' -&gt; 165;				add: 'aring' -&gt; 229;				add: 'lsquo' -&gt; 8216;				add: 'yacute' -&gt; 253;				add: 'ugrave' -&gt; 249;				add: 'Eacute' -&gt; 201;				add: 'Agrave' -&gt; 192;				add: 'lsaquo' -&gt; 8249;				add: 'sup1' -&gt; 185;				add: 'reg' -&gt; 174;				add: 'oelig' -&gt; 339;				add: 'Yuml' -&gt; 376;				add: 'lt' -&gt; 60;				add: 'plusmn' -&gt; 177;				add: 'Ecirc' -&gt; 202;				add: 'euro' -&gt; 8364;				add: 'rdquo' -&gt; 8221;				add: 'sup2' -&gt; 178;				add: 'acute' -&gt; 180;				add: 'uml' -&gt; 168;				add: 'thinsp' -&gt; 8201;				add: 'sup3' -&gt; 179;				add: 'aelig' -&gt; 230;				add: 'euml' -&gt; 235;				add: 'not' -&gt; 172;				add: 'otilde' -&gt; 245;				add: 'para' -&gt; 182;				add: 'macr' -&gt; 175;				add: 'sect' -&gt; 167;				add: 'Ccedil' -&gt; 199;				add: 'pound' -&gt; 163;				add: 'Ntilde' -&gt; 209;				add: 'cent' -&gt; 162;				add: 'nbsp' -&gt; 160;				add: 'iacute' -&gt; 237;				add: 'egrave' -&gt; 232;				add: 'laquo' -&gt; 171;				add: 'Oacute' -&gt; 211;				add: 'zwj' -&gt; 8205;				add: 'atilde' -&gt; 227;				add: 'zwnj' -&gt; 8204;				add: 'Iuml' -&gt; 207;				add: 'times' -&gt; 215;				add: 'icirc' -&gt; 238;				add: 'lrm' -&gt; 8206;				add: 'Ocirc' -&gt; 212;				add: 'sbquo' -&gt; 8218;				add: 'bdquo' -&gt; 8222;				add: 'uacute' -&gt; 250;				add: 'Aacute' -&gt; 193;				add: 'Oslash' -&gt; 216;				add: 'ordf' -&gt; 170;				add: 'ouml' -&gt; 246;				add: 'Uuml' -&gt; 220;				add: 'THORN' -&gt; 222;				add: 'ucirc' -&gt; 251;				add: 'Acirc' -&gt; 194;				add: 'dagger' -&gt; 8224;				add: 'scaron' -&gt; 353;				add: 'Igrave' -&gt; 204;				add: 'curren' -&gt; 164;				add: 'micro' -&gt; 181;				add: 'OElig' -&gt; 338;				add: 'auml' -&gt; 228;				add: 'rlm' -&gt; 8207;				add: 'Aring' -&gt; 197;				add: 'divide' -&gt; 247;				add: 'mdash' -&gt; 8212;				add: 'Yacute' -&gt; 221;				add: 'ograve' -&gt; 242;				add: 'Ugrave' -&gt; 217;				add: 'permil' -&gt; 8240;				add: 'AElig' -&gt; 198;				add: 'emsp' -&gt; 8195;				add: 'gt' -&gt; 62;				add: 'tilde' -&gt; 732;				add: 'rsquo' -&gt; 8217;				add: 'middot' -&gt; 183;				add: 'ldquo' -&gt; 8220;				add: 'circ' -&gt; 710;				add: 'thorn' -&gt; 254;				add: 'agrave' -&gt; 224;				add: 'eacute' -&gt; 233;				add: 'rsaquo' -&gt; 8250;				add: 'brvbar' -&gt; 166;				add: 'ETH' -&gt; 208;				add: 'yuml' -&gt; 255;				add: 'Euml' -&gt; 203;				add: 'ensp' -&gt; 8194;				add: 'frac34' -&gt; 190;				add: 'ecirc' -&gt; 234;				add: 'ordm' -&gt; 186;				yourself.	details at: #characterEntities put: entities</body><body package="NetResources">applyDetails: content for: parser	| details |	details := Dictionary new.	XML.Element allSubclasses do: [:each | each setupDetails: details for: content].	self addTwoflowerEntities: details.	details at: #characterEntities ifAbsent: [^details].	(details at: #characterEntities) keysAndValuesDo: [:key :value |		parser dtd generalEntityAt: key put: (XML.GeneralEntity new name: key; text: (String with: (Character value: value))) from: parser].	^details</body><body package="NetResources">handle: valueStream for: aURL	| contents |	contents := valueStream upToEnd.	contents isEmpty ifTrue: [^nil].	self class allowHTML ifFalse: [^self handleSpecialisedXML: contents for: aURL].	([self handleSpecialisedXML: contents for: aURL isDirty: false] on: Core.Error do: [:sig | nil]) ifNotNil: [:doc | ^doc].	([self handleSpecialisedHTML: contents for: aURL] on: Core.Error do: [:sig | nil]) ifNotNil: [:doc | ^doc].	([self handleSpecialisedXML: (self xmlTidy: contents) for: aURL isDirty: true] on: Core.Error do: [:sig | nil]) ifNotNil: [:doc | ^doc].	([self handleSpecialisedHTML: (self xmlTidy: contents) for: aURL] on: Core.Error do: [:sig | nil]) ifNotNil: [:doc | ^doc].	([self handleSpecialisedXML: (self htmlTidy: contents) for: aURL isDirty: true] on: Core.Error do: [:sig | nil]) ifNotNil: [:doc | ^doc].	([self handleSpecialisedHTML: (self htmlTidy: contents) for: aURL] on: Core.Error do: [:sig | nil]) ifNotNil: [:doc | ^doc].	([self handleHTMLViaTfParser: contents for: aURL] on: Core.Error do: [:sig | nil]) ifNotNil: [:doc | ^doc].	^nil</body><body package="NetResources">handleHTMLViaTfParser: content for: aURL	| details result |	result := ((#{WithStyle.TwoflowerBridge.WsTfHTMLParser} valueOrDo: [^self handleSpecialisedHTML: content for: aURL])		processDocumentString: content beforeScanDo: [ :parser | details := self applyDetails: content for: parser ]).	(result respondsTo: #sourceURI) ifTrue: [result sourceURI: aURL].	(result respondsTo: #extraDetails:) ifTrue: [result extraDetails: details].	result addNamespaceDetails.	^result</body><body package="NetResources">handleSpecialisedHTML: content for: aURL	| details result |	result := ((#{XML.HTML.HTMLParser} valueOrDo: [^nil])		processDocumentString: content beforeScanDo: [ :parser | details := self applyDetails: content for: parser ]).	(result respondsTo: #sourceURI) ifTrue: [result sourceURI: aURL].	(result respondsTo: #extraDetails:) ifTrue: [result extraDetails: details].	(result respondsTo: #transformHTML) ifTrue: [result transformHTML].	result addNamespaceDetails.	^result</body><body package="NetResources">handleSpecialisedXML: content for: aURL	| parserClass parser details |	parserClass := #{WithStyle.Specialisation.Document} valueOrDo: [^self handleXML: content for: aURL].	parser := parserClass newParser.	parser on: content readStream.	details := self applyDetails: content for: parser.	^parser scanDocument		sourceURI: aURL;		extraDetails: details;		addNamespaceDetails;		yourself</body><body package="NetResources">handleSpecialisedXML: content for: aURL isDirty: isDirty	| xml |	xml := self handleSpecialisedXML: content for: aURL.	(isDirty and: [xml respondsTo: #transformHTML]) ifTrue: [xml transformHTML].	^xml</body><body package="NetResources">handleXML: content for: aURL	^XML.XMLParser processDocumentString: content beforeScanDo: [:p | p validate: false]</body></methods><methods><class-id>Net.Resources.ResourceHandlerXML</class-id> <category>encoding</category><body package="NetResources">checkHTTPEncoding: contentSnippit	"if this looks like xml, see if we have a content type"	| stream |	('*&lt;meta http-equiv="Content-Type"*' match: contentSnippit) ifFalse: [^nil].	stream := contentSnippit readStream.	stream throughAll: 'charset='.	^stream upTo: $"</body><body package="NetResources">checkXMLEncoding: contentSnippit	"if this looks like xml, see if we have a content type"	| stream nextChar xmlEncoding |	stream := contentSnippit readStream.	stream throughAll: '&lt;?xml version='.	stream atEnd		ifTrue: [^nil].	stream throughAll: 'encoding='.	nextChar := stream peek.	xmlEncoding := (nextChar = $" or: [nextChar = $'])		ifTrue: [stream next.				stream upTo: nextChar]		ifFalse: [stream upTo: $?].	stream atEnd ifTrue: [xmlEncoding := nil].	^xmlEncoding</body><body package="NetResources">defaultEncodingType	^#utf8</body><body package="NetResources">getEncodingFor: aCacheItem	| assumedEncoding encodedContents reasonableContentSnippit xmlEncoding httpEncoding |	assumedEncoding := aCacheItem encoding ifNil: [self defaultEncodingType].	encodedContents := (aCacheItem asEncodedCacheItemEncoding: assumedEncoding) asEncodedContents.	reasonableContentSnippit := encodedContents copyFrom: 1 to: (2000 min: encodedContents size).	xmlEncoding := self checkXMLEncoding: reasonableContentSnippit.	httpEncoding := self checkHTTPEncoding: reasonableContentSnippit.	^httpEncoding ifNil: [xmlEncoding ifNil: [assumedEncoding]]</body><body package="NetResources">htmlTidy: contents	#{XML.Tidy.TidyInterface} value ifNil: [^contents].	#{XML.Tidy.TidyInterface} value isAvailable ifFalse: [^contents].	^#{XML.Tidy.TidyInterface} value current		tidy: contents		onWarnings: [:w | ]		onErrors: [:e | contents]		asXHTML: true</body><body package="NetResources">xmlTidy: contents	#{XML.Tidy.TidyInterface} value ifNil: [^contents].	#{XML.Tidy.TidyInterface} value isAvailable ifFalse: [^contents].	^#{XML.Tidy.TidyInterface} value current		tidy: contents		onWarnings: [:w | ]		onErrors: [:e | contents]		asXHTML: false</body></methods><methods><class-id>Net.Resources.ResourceHandlerXML</class-id> <category>testing</category><body package="NetResources">isHappyWithFirstCharacter: aCharacter	^aCharacter = $&lt;</body></methods><methods><class-id>Net.Resources.ResourceHandlerXML class</class-id> <category>accessing</category><body package="NetResources">allowHTML	^allowHTML ifNil: [allowHTML := true]</body><body package="NetResources">allowHTML: anObject	allowHTML := anObject</body></methods><methods><class-id>Net.Resources.ResourceHandlerXML class</class-id> <category>API</category><body package="NetResources">canHandle: aMimeType	aMimeType ifNil: [^false].	('*/*xml*' match: aMimeType) ifTrue: [^true].	('*/*html*' match: aMimeType) ifTrue: [^true].		^super canHandle: aMimeType</body><body package="NetResources">mimeTypes	^#( 'text/xhtml' 'text/xml' 'text/html' 'application/xml' 'application/xhtml+xml' 'text/xsl' 'text/xsd' 'text/xconf' 'text/xsource' 'text/xvocab' 'text/xlookandfeel' )</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary</class-id> <category>enumerating</category><body package="NetResources">do: aBlock 	^lock critical: [super do: aBlock]</body><body package="NetResources">keysAndValuesDo: aBlock 	^lock critical: [super keysAndValuesDo: aBlock]</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary</class-id> <category>accessing</category><body package="NetResources">associationAt: key ifAbsent: aBlock 	^lock critical: [super associationAt: key ifAbsent: aBlock]</body><body package="NetResources">at: key ifAbsent: aBlock 	^lock critical: [super at: key ifAbsent: aBlock]</body><body package="NetResources">at: key ifAbsentPut: valueBlock 	^lock critical: [super at: key ifAbsentPut: valueBlock]</body><body package="NetResources">at: key put: anObject 	^lock critical: [super at: key put: anObject]</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary</class-id> <category>adding</category><body package="NetResources">add: anAssociation 	^lock critical: [super add: anAssociation]</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary</class-id> <category>initialize-release</category><body package="NetResources">initialize	lock := RecursionLock new</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary</class-id> <category>dictionary removing</category><body package="NetResources">removeKey: key ifAbsent: aBlock 	^lock critical: [super removeKey: key ifAbsent: aBlock]</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary</class-id> <category>dictionary testing</category><body package="NetResources">includesKey: key 	^lock critical: [super includesKey: key]</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary</class-id> <category>dictionary enumerating</category><body package="NetResources">associationsDo: aBlock 	^lock critical: [super associationsDo: aBlock]</body></methods><methods><class-id>Net.Resources.ThreadSafeDictionary class</class-id> <category>instance creation</category><body package="NetResources">new: aSize	^(super new: aSize) initialize</body></methods><methods><class-id>Net.Resources.Cache</class-id> <category>accessing</category><body package="NetResources">memory	^memory</body><body package="NetResources">memory: anObject	memory := anObject</body></methods><methods><class-id>Net.Resources.Cache</class-id> <category>API</category><body package="NetResources">cacheItemFor: uri	| result hasChanged |	result := self unreconciledCacheItemFor: uri do: [:cacheItem :isNew |		isNew ifFalse:			[self resourceManagerDo: [:manager | (manager includesURI: uri) ifTrue:				[self monitor: 'GET-NONET EXISTING UNCHANGED ', uri asString.				^cacheItem]]].		hasChanged := uri reconcileCacheItem: cacheItem.		self monitor:			'GET ',			(isNew ifTrue: ['NEW '] ifFalse: ['EXISTING ']),			(hasChanged ifTrue: ['CHANGED '] ifFalse: ['UNCHANGED ']),			uri asString.		(isNew or: [hasChanged]) ifTrue: [cacheItem commit]].	self resourceManagerDo: [:manager | manager addURI: uri].	^result</body><body package="NetResources">deleteFor: uri	^self unreconciledCacheItemFor: uri do: [:cacheItem :isNew |		isNew ifFalse: [uri deleteCacheItem: cacheItem].		self monitor:			'DELETE ',			(isNew ifTrue: ['NEW '] ifFalse: ['EXISTING ']),			uri asString.		cacheItem clear.		self resourceManagerDo: [:manager | manager removeURI: uri]]</body><body package="NetResources">isAvailable: aURI	^self memory includesKey: aURI</body><body package="NetResources">post: contents for: uri encoding: encoding	| result |	self unreconciledCacheItemFor: uri do: [:cacheItem :isNew |		result := uri post: contents cacheItem: cacheItem copy encoding: encoding.		self monitor:			'POST ',			(isNew ifTrue: ['NEW '] ifFalse: ['EXISTING ']),			uri asString.		^result]</body><body package="NetResources">put: contents for: uri encoding: encoding	| result |	self unreconciledCacheItemFor: uri do: [:cacheItem :isNew |		result := uri put: contents cacheItem: cacheItem copy encoding: encoding.		self monitor:			'PUT ',			(isNew ifTrue: ['NEW '] ifFalse: ['EXISTING ']),			uri asString.		^result]</body><body package="NetResources">unreconciledCacheItemFor: uri	^self unreconciledCacheItemFor: uri do: [:cacheItem :isNew |		isNew ifTrue: [uri reconcileCacheItem: cacheItem].		self monitor:			'PEEK ',			(isNew ifTrue: ['NEW '] ifFalse: ['EXISTING ']),			uri asString.		cacheItem]</body><body package="NetResources">unreconciledCacheItemFor: uri do: aOneArgBlock	| cacheItem isNew |	(self memory includesKey: uri) ifFalse: [self recoverFromDiskCache: uri].	isNew := false.	cacheItem := self memory at: uri ifAbsent: [isNew := true. uri cacheItemClass uri: uri].	aOneArgBlock value: cacheItem value: isNew.	isNew ifTrue: [self memory at: uri put: cacheItem].	^cacheItem</body></methods><methods><class-id>Net.Resources.Cache</class-id> <category>displaying</category><body package="NetResources">printOn: aStream	aStream nextPutAll: 'Cache of ', self memory size printString, ' items'</body></methods><methods><class-id>Net.Resources.Cache</class-id> <category>private</category><body package="NetResources">monitor: message	[self class triggerEvent: #updated with: message] fork</body><body package="NetResources">recoverCacheItemFromDiskCache: aURI	| filename object |	(filename := aURI diskCacheName) ifNil: [^nil].	filename exists ifFalse: [^nil].	object := self recoverObjectFromDiskCache: filename.	object ifNil: [self monitor: 'RECOVER-FAILED! ', aURI asString].	^object</body><body package="NetResources">recoverFromDiskCache: aURI	| cacheItem |	cacheItem := self recoverCacheItemFromDiskCache: aURI.	cacheItem ifNil: [^self].	self monitor: 'RECOVER ', aURI asString.	self memory at: aURI put: cacheItem</body><body package="NetResources">recoverObjectFromDiskCache: filename	| boss cacheItem |	#{BinaryObjectStorage} valueOrDo: [^nil].	[boss := #{BinaryObjectStorage} value onOld: filename readStream.	[cacheItem := boss next] ensure: [boss close]]		on: Error do: [:sig | ^nil].	^cacheItem</body><body package="NetResources">removeInMemoryFor: aURI	^self memory removeKey: aURI ifAbsent: [nil]</body></methods><methods><class-id>Net.Resources.Cache</class-id> <category>initialize</category><body package="NetResources">initialize	memory := ThreadSafeDictionary new</body></methods><methods><class-id>Net.Resources.Cache class</class-id> <category>API</category><body package="NetResources">current	^self singleton</body><body package="NetResources">dropCache	singleton := nil</body></methods><methods><class-id>Net.Resources.Cache class</class-id> <category>accessing</category><body package="NetResources">cachePath	cachePath ifNil: [cachePath := 'cache'].	^cachePath, (String with: Filename separator)</body><body package="NetResources">cachePath: anObject	cachePath := anObject</body><body package="NetResources">singleton	^singleton ifNil: [singleton := self new initialize]</body><body package="NetResources">singleton: anObject	singleton := anObject</body></methods><methods><class-id>Net.Resources.ResourceURL</class-id> <category>accessing</category><body package="NetResources">className" return the namespace.classname part of the URI "	^className</body><body package="NetResources">className: anObject" set the namespace.classname part of the URI "	className := anObject</body><body package="NetResources">parameters" returns a dictionary of variables for a 'dynamic' method:// access "	^parameters ifNil: [self getParameters]</body><body package="NetResources">parameters: anObject" sets the 'dynamic' parameters for the uri "	parameters := anObject</body><body package="NetResources">query	^super query ifNil: [query := '']</body></methods><methods><class-id>Net.Resources.ResourceURL</class-id> <category>stream -- unguarded</category><body package="NetResources">binaryReadStream" probably could be implemented.. but.. why? "	^self shouldNotImplement</body><body package="NetResources">binaryWriteStream" cannot write to a method like this "	^self shouldNotImplement</body><body package="NetResources">getContents" return whatever kind of object the perform gives us. Note if you're crashing here, you should have set isValid first "	(query notNil and: [query notEmpty and: [self getClass respondsTo: (self symbol, ':') asSymbol]]) ifTrue:		[^self getClass perform: (self symbol, ':') asSymbol with: self queries].	^self parameters isEmpty		ifTrue:	[self getClass perform: self symbol]		ifFalse:	[self getClass perform: self symbol with: self parameters]</body><body package="NetResources">readStream" return a stream to read the contents from "	self isValid ifFalse: [^nil].	^ReadStream on: self getContents</body><body package="NetResources">writeStream" cannot write to a method like this "	^self shouldNotImplement</body></methods><methods><class-id>Net.Resources.ResourceURL</class-id> <category>private</category><body package="NetResources">getClass" fetch the class for the path. if we don't find it return nil "	^self className asStrictReference valueOrDo: [nil]</body><body package="NetResources">getParameters" aHostSpecification is the path after the namespace.classname/ section "	| queryBits |	parameters := Dictionary new.	queryBits := self query tokensBasedOn: $&amp;.	queryBits first = '' ifTrue: [^parameters].	queryBits do:		[:pair |		| pairTmp key value |		pairTmp := pair tokensBasedOn: $=.		key := pairTmp first.		value := pairTmp last.		parameters at: key put: value].	^parameters</body><body package="NetResources">symbol" return whatever kind of object the perform gives us. Note if you're crashing here, you should have set isValid first "	^self parameters isEmpty		ifTrue:	[self path first asSymbol]		ifFalse:	[(self path first, ':') asSymbol]</body></methods><methods><class-id>Net.Resources.ResourceURL</class-id> <category>private-NetResources</category><body package="NetResources">canCache	^true</body><body package="NetResources">deleteCacheItem: aCacheItem	" do nothing - could delete the method? nah! "</body><body package="NetResources">guessMimeType	| result |	(result := self readStream) ifNil: [^''].	result collection isPixmap ifTrue: [^'image/pixmap'].	(result collection isKindOf: OpaqueImage) ifTrue: [^'image/pixmap'].	result := result upToEnd.	(result isString and: [result first = $&lt;]) ifTrue: [^'text/xml'].	(result isString and: [result includes: ${]) ifTrue: [^'text/css'].	result isString ifTrue: [^'text/plain'].	self error: 'need to fill in different mime types from objects of results here, if you want'.</body><body package="NetResources">isAvailable	^self isValid</body><body package="NetResources">isValid" return a boolean if we can evaluate this URI and return a result "	self getClass isNil ifTrue: [^false].	^self getClass respondsTo: self symbol</body><body package="NetResources">put: contents cacheItem: aCacheItem encoding: encoding	#{Workspace} valueOrDo: [Transcript cr; show: (self putMessage: contents). ^aCacheItem].	(#{Workspace} value on: (self putMessage: contents) asValue) open.	^aCacheItem</body><body package="NetResources">putMessage: contents	^'WithStyle does not auto-save resource:// URL''s back in to their methods, instead a Workspace is opened. Here is the content to save below:', contents</body><body package="NetResources">reconcileCacheItem: aCacheItem	| contents |	contents := self readStream.	contents ifNotNil:		[(contents collection isKindOf: Collection)			ifTrue:	[contents := contents upToEnd]			ifFalse:	[contents := contents collection]].	contents = aCacheItem lastModified ifTrue: [aCacheItem hasChanged: false. ^false].	aCacheItem dropVolitileState.	aCacheItem mimeType: self guessMimeType.	aCacheItem contents: contents inEncoding: ByteString encodingType.	aCacheItem lastModified: contents.	aCacheItem hasChanged: true.	^true</body></methods><methods><class-id>Net.Resources.ResourceURL</class-id> <category>initialize</category><body package="NetResources">parseHost: aHostSpecification" aHostSpecification is the path after the namespace.classname/ section "	self className: aHostSpecification.</body></methods><methods><class-id>Net.Resources.ResourceURL</class-id> <category>api</category><body package="NetResources">resource	| data |	data := self getContents asByteArray.	data := (data withEncoding: #UTF_8) readStream lineEndTransparent.	^XML.InputSource		uri: self		encoding: nil		stream: data</body></methods><methods><class-id>Net.Resources.ResourceURL</class-id> <category>conversion</category><body package="NetResources">asString	| newString |	newString := self class protocol, '://', self className, '/', path first.	self parameters isEmpty ifFalse:		[ | concat |		concat := '?'.		parameters keysAndValuesDo: [:key :value |			newString := newString, concat, key, '=', value.			concat := '&amp;']].	^newString</body></methods><methods><class-id>Net.Resources.ResourceURL class</class-id> <category>accessing</category><body package="NetResources">protocol	^'resource'</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageGIF</class-id> <category>constants</category><body package="NetResources">imageClass"Can't use Arbor GIF Reader as its GPL license requires this software to become GPL too, and any software then using this software"	^GIFImageReader</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageGIF</class-id> <category>API</category><body package="NetResources">handle: valueStream for: aURL	#{GIFImage} valueOrDo: [^super handle: valueStream for: aURL].	^[(#{GIFImage} value from: valueStream upToEnd asByteArray) asImage asCachedImage] on: Error do: [:sig | ^nil]</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageGIF class</class-id> <category>API</category><body package="NetResources">mimeTypes	^#( 'image/gif' )</body></methods><methods><class-id>Net.Resources.EncodedCacheItem</class-id> <category>private</category><body package="NetResources">handler	^cacheItem handlerFor: mimeType</body><body package="NetResources">uri	^cacheItem uri</body></methods><methods><class-id>Net.Resources.EncodedCacheItem</class-id> <category>instance creation</category><body package="NetResources">setContents: someContents	contents := someContents</body><body package="NetResources">setMimeType: aMimeType encoding: anEncoding cacheItem: aCacheItem	failed := false.	mimeType := aMimeType.	encoding := anEncoding.	cacheItem := aCacheItem</body></methods><methods><class-id>Net.Resources.EncodedCacheItem</class-id> <category>testing</category><body package="NetResources">hasEncoding: anEncoding	^encoding = anEncoding</body><body package="NetResources">isMimeType: aMimeType andEncoding: anEncoding	^mimeType = aMimeType and: [encoding = anEncoding]</body></methods><methods><class-id>Net.Resources.EncodedCacheItem</class-id> <category>API</category><body package="NetResources">asCacheItem	^cacheItem</body><body package="NetResources">asCacheItemUnreconciled	^self asCacheItem</body><body package="NetResources">asEncodedCacheItem	^self</body><body package="NetResources">asEncodedContents	^contents</body><body package="NetResources">asResource	resource ifNotNil: [^resource].	failed ifTrue: [^nil].	contents isSequenceable ifFalse: [^resource := contents].	resource := self handler handle: contents readStream for: self uri.	resource ifNil: [failed := true].	^resource</body><body package="NetResources">binaryValueStream	^self asCacheItem binaryValueStream</body><body package="NetResources">hasChanged	^self asCacheItem hasChanged</body><body package="NetResources">isAvailable	^true</body><body package="NetResources">mimeType	^mimeType ifNil: ['unknown/unknown']</body><body package="NetResources">refresh	^self uri asCacheItem asEncodedCacheItemMimeType: mimeType encoding: encoding</body><body package="NetResources">valueStream	^self asEncodedContents readStream</body></methods><methods><class-id>Net.Resources.EncodedCacheItem</class-id> <category>displaying</category><body package="NetResources">printOn: aStream	aStream nextPutAll: self mimeType, '+', encoding</body></methods><methods><class-id>Net.Resources.EncodedCacheItem class</class-id> <category>instance creation</category><body package="NetResources">mimeType: aMimeType encoding: anEncoding cacheItem: aCacheItem	^self new setMimeType: aMimeType encoding: anEncoding cacheItem: aCacheItem</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageBMP</class-id> <category>constants</category><body package="NetResources">imageClass	^BMPImageReader</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageBMP class</class-id> <category>API</category><body package="NetResources">mimeTypes	^#( 'image/bmp' )</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>accessing</category><body package="NetResources">code	^'200'</body><body package="NetResources">contents	^contents</body><body package="NetResources">contents: anObject	contents := anObject</body><body package="NetResources">contents: anObject inEncoding: anEncoding	| encodedCacheItem |	encodedCacheItem := self newEncodedCacheItem: mimeType encoding: anEncoding.	encodedCacheItem setContents: anObject.	encodings add: encodedCacheItem.	contents := self decode: anObject from: anEncoding.	encoding := anEncoding</body><body package="NetResources">encoding	^encoding</body><body package="NetResources">encoding: anObject	encoding := anObject</body><body package="NetResources">hasChanged	^hasChanged</body><body package="NetResources">hasChanged: anObject	hasChanged := anObject</body><body package="NetResources">lastModified	^lastModified</body><body package="NetResources">lastModified: anObject	lastModified := anObject</body><body package="NetResources">mimeType	^mimeType ifNil: ['unknown/unknown']</body><body package="NetResources">mimeType: anObject	mimeType := anObject</body><body package="NetResources">uri	^uri</body><body package="NetResources">uri: anObject	uri := anObject</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>testing</category><body package="NetResources">hasEncoding: anEncoding	^encodings anySatisfy: [:each | each hasEncoding: anEncoding]</body><body package="NetResources">isCacheItem	^true</body><body package="NetResources">isFailure	^self isSuccess not</body><body package="NetResources">isSuccess	^self contents notNil and: [self contents notEmpty]</body><body package="NetResources">usesAuthorization	^false</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>private</category><body package="NetResources">cache	^Cache current</body><body package="NetResources">dropCacheState	self dropVolitileState.	lastModified := nil</body><body package="NetResources">dropVolitileState	encodings := OrderedCollection new</body><body package="NetResources">encodedCacheItem: aMimeType encoding: anEncoding	^encodings		detect:	[:each | each isMimeType: aMimeType andEncoding: anEncoding]		ifNone:	[self makeEncodedCacheItem: aMimeType encoding: anEncoding]</body><body package="NetResources">getEncoding	^self handler getEncodingFor: self</body><body package="NetResources">handler	^self handlerFor: mimeType</body><body package="NetResources">handlerClassFor: aMimeType	^Net.Resources.ResourceHandler handlerClassFor: aMimeType</body><body package="NetResources">handlerFor: aMimeType	^(self handlerClassFor: aMimeType) new</body><body package="NetResources">isHappyWithContent	self error: 'should not be called, only HttpCacheItem has this'</body><body package="NetResources">makeEncodedCacheItem: aMimeType encoding: anEncoding	| encodedCacheItem |	encodedCacheItem := self newEncodedCacheItem: aMimeType encoding: anEncoding.	encodedCacheItem setContents: (self encode: contents to: anEncoding).	encodings add: encodedCacheItem.	^encodedCacheItem</body><body package="NetResources">newEncodedCacheItem: aMimeType encoding: anEncoding	^EncodedCacheItem mimeType: aMimeType encoding: anEncoding cacheItem: self</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>API</category><body package="NetResources">asCacheItem	^self</body><body package="NetResources">asCacheItemUnreconciled	^self asCacheItem</body><body package="NetResources">asEncodedCacheItem	^self encodedCacheItem: mimeType encoding: self getEncoding</body><body package="NetResources">asEncodedCacheItemEncoding: anEncoding	^self encodedCacheItem: mimeType encoding: anEncoding</body><body package="NetResources">asEncodedCacheItemMimeType: aMimeType	^self encodedCacheItem: aMimeType encoding: self getEncoding</body><body package="NetResources">asEncodedCacheItemMimeType: aMimeType encoding: anEncoding	^self encodedCacheItem: aMimeType encoding: anEncoding</body><body package="NetResources">asResource	^self asEncodedCacheItem asResource</body><body package="NetResources">asResourceInEncoding: anEncoding	^(self asEncodedCacheItemEncoding: anEncoding) asResource</body><body package="NetResources">asResourceInMimeType: aMimeType	^(self asEncodedCacheItemMimeType: aMimeType) asResource</body><body package="NetResources">asResourceInMimeType: aMimeType encoding: anEncoding	^(self asEncodedCacheItemMimeType: aMimeType encoding: anEncoding) asResource</body><body package="NetResources">binaryValueStream	^self contents readStream</body><body package="NetResources">clear	| filename |	self cache removeInMemoryFor: self uri.	(filename := self uri diskCacheName) ifNil: [^self].	filename canBeWritten ifFalse: [^self].	[filename delete] on: Error do: [:ex | ex return]</body><body package="NetResources">isAvailable	^true</body><body package="NetResources">refresh	^self uri asCacheItem</body><body package="NetResources">valueStream	^self asEncodedCacheItem valueStream</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>displaying</category><body package="NetResources">printOn: aStream	aStream nextPutAll: 'CacheItem for: ', self uri asString.	encodings do: [:each | aStream cr. each printOn: aStream]</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>encode/decode</category><body package="NetResources">decode: text from: anEncoding 	^[text asByteArrayEncoding: anEncoding]		on: Error		do: [:ex | text]</body><body package="NetResources">encode: text to: anEncoding	anEncoding = #binary ifTrue: [^text]. 	^[text asStringEncoding: anEncoding]		on: Error		do: [:ex |			anEncoding = encoding				ifTrue:	['']				ifFalse:	[self encode: text to: encoding]]</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>initialize-release</category><body package="NetResources">initialize	encodings := OrderedCollection new.	hasChanged := true</body></methods><methods><class-id>Net.Resources.CacheItem</class-id> <category>disk-cache</category><body package="NetResources">commit	| boss filename |	#{BinaryObjectStorage} valueOrDo: [^self].	(filename := self uri diskCacheName) ifNil: [^self].	filename canBeWritten ifFalse: [^self].	[boss := #{BinaryObjectStorage} value onNew: filename writeStream.	[boss nextPut: self] ensure: [boss close]] on: Error do: [:sig |		[Cache triggerEvent: #updated with: 'COMMIT-FAILED! ', uri asString] fork.		^self].	[Cache triggerEvent: #updated with: 'COMMIT ', uri asString] fork</body><body package="NetResources">representBinaryOn: binWriter	^MessageSend		receiver: self class 		selector: #recover:		argument: self representedInstanceVariables</body><body package="NetResources">representedInstanceVariables	^Dictionary new		at: #uri: put: uri;		at: #mimeType: put: mimeType;		at: #encoding: put: encoding;		at: #lastModified: put: lastModified;		at: #hasChanged: put: hasChanged;		at: #contents: put: contents;		yourself</body></methods><methods><class-id>Net.Resources.CacheItem class</class-id> <category>instance creation</category><body package="NetResources">new	^super new initialize</body><body package="NetResources">recover: variables	| new |	new := self new.	variables keysAndValuesDo: [:key :value | new perform: key with: value].	^new</body><body package="NetResources">uri: uri	^self new uri: uri; yourself</body><body package="NetResources">uri: uri contents: contents inEncoding: anEncoding mimeType: mimeType lastModified: lastModified	^self new		uri: uri;		mimeType: mimeType;		lastModified: lastModified;		contents: contents inEncoding: anEncoding;		yourself</body><body package="NetResources">uri: uri contents: contents mimeType: mimeType lastModified: lastModified	^self new		uri: uri;		mimeType: mimeType;		lastModified: lastModified;		contents: contents;		yourself</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageWinGDIPlus</class-id> <category>private</category><body package="NetResources">gdiInterface	^#{WinGDIPlusInterface} value current</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageWinGDIPlus</class-id> <category>API</category><body package="NetResources">handle: valueStream for: aURL	valueStream contents isEmpty ifTrue: [^nil].	^[(self gdiInterface loadImageFromBytes: valueStream upToEnd) asCachedImage] on: Error do: [:sig | nil]</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageWinGDIPlus class</class-id> <category>testing</category><body package="NetResources">isAvailable	^(#{WinGDIPlusInterface} valueOrDo: [^false]) isAvailable</body></methods><methods><class-id>Net.Resources.ResourceHandlerImageWinGDIPlus class</class-id> <category>API</category><body package="NetResources">canHandle: aMimeType	aMimeType ifNil: [^false].	^self isAvailable and: ['image/*' match: aMimeType]</body><body package="NetResources">weight	^1</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="NetResources">asResource	^self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="NetResources">isCacheItem	^false</body><body package="NetResources">isPixmap	^false</body><body package="NetResources">isUnauthorized	^false</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="NetResources">memoryUsage	^self memoryUsage: OrderedCollection new</body><body package="NetResources">memoryUsage: visited	| size |	(visited includes: self) ifTrue: [^0].	visited add: self.	size := self basicSize + self class instSize.	1 to: self basicSize do: [:index | size := size + ((self basicAt: index) memoryUsage: visited)].	1 to: self class instSize do: [:index | size := size + ((self instVarAt: index) memoryUsage: visited)].	^size</body><body package="NetResources">refreshResourcesDo: aBlock	| result oldManager |	self resourceManagerDo: [:manager | oldManager := manager. manager deactivate].	[result := aBlock value] ensure: [oldManager ifNotNil: [oldManager activate]].	^result</body><body package="NetResources">resourceManager	^Processor activeProcess environmentAt: #resourceManager</body><body package="NetResources">resourceManagerDo: aOneArgBlock	self resourceManager ifNotNil: aOneArgBlock</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="NetResources">contentType	^self</body></methods><methods><class-id>Graphics.PixelArray</class-id> <category>testing</category><body package="NetResources">isPixmap	^true</body></methods><methods><class-id>Graphics.CachedImage</class-id> <category>converting</category><body package="NetResources">asCachedImage	^self</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>testing</category><body package="NetResources">isUnknown	^true</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>converting</category><body package="NetResources">treatAsFileURI	"we have an unknown url.  Make like it's a file URI"	| string |	string := self asString.	^('file:///', string) asURI</body></methods><methods><class-id>Graphics.OpaqueImage</class-id> <category>converting</category><body package="NetResources">asCachedImage	^self class 		figure: figure asCachedImage		shape:  shape asCachedImage</body></methods><methods><class-id>OS.URI</class-id> <category>testing</category><body package="NetResources">isScriptURI	^false</body><body package="NetResources">isSmalltalkURI	^false</body><body package="NetResources">isUnknown	^false</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="NetResources">ensureDirectoryExists	self exists ifTrue: [^self].	self directory ensureDirectoryExists.	self makeDirectory</body></methods><methods><class-id>OS.FileURL</class-id> <category>private-NetResources</category><body package="NetResources">canCache	^true</body><body package="NetResources">deleteCacheItem: aCacheItem	self asFilename delete</body><body package="NetResources">guessMimeType	| extension |	extension := missingSlashes = true		ifTrue: [(path tokensBasedOn: $.) last asLowercase]		ifFalse: [(path last tokensBasedOn: $.) last asLowercase].	Net.Resources.ResourceHandler allSubclasses		do: [:aClass |			(aClass mimeTypes				detect: [:mimeType | ('*/', extension) match: mimeType]				ifNone: [nil]) ifNotNil: [:mimeType | ^mimeType]].	^'text/', extension</body><body package="NetResources">lastModified	self asFilename exists ifFalse: [^Date today].	^self asFilename dates at: #modified</body><body package="NetResources">post: contents cacheItem: aCacheItem encoding: encoding	| file |	aCacheItem uri asFilename directory ensureDirectoryExists.	file := (aCacheItem uri asFilename withEncoding: encoding) writeStream.	file nextPutAll: contents.	file close.	self writeLockfile.	^contents</body><body package="NetResources">put: contents cacheItem: aCacheItem encoding: encoding	| file |	aCacheItem uri asFilename directory ensureDirectoryExists.	file := (aCacheItem uri asFilename withEncoding: encoding) writeStream.	file nextPutAll: contents.	file close.	self writeLockfile.	^aCacheItem</body><body package="NetResources">reconcileCacheItem: aCacheItem	| stream |	[self asFilename] on: Error do: [:sig | ^false].	self lastModified = aCacheItem lastModified ifTrue: [aCacheItem hasChanged: false. ^false].	aCacheItem dropVolitileState.	stream := self asFilename exists		ifTrue: [self binaryReadStream]		ifFalse: [String new readStream].	[aCacheItem		contents: stream upToEnd;		mimeType: self guessMimeType;		lastModified: self lastModified;		hasChanged: true] ensure:			[stream close].	^true</body></methods><methods><class-id>OS.FileURL</class-id> <category>private</category><body package="NetResources">writeLockfile	| filename file |	(filename := CEnvironment commandLine indexOf: '-lock') isZero ifTrue: [^self].	CEnvironment commandLine size &lt; (filename + 1) ifTrue: [^self].	filename := CEnvironment commandLine at: filename + 1.	#( 'file:*' 'http:*' 'resource:*' ) do: [:e | (e match: filename) ifTrue: [file := filename asURI asFilename writeStream]].	file ifNil: [file := filename asFilename writeStream].	file close.</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="NetResources">nrAt: aKey ifPresent: presentBlock ifAbsent: absentBlock	^presentBlock value: (self at: aKey ifAbsent: [^absentBlock value])</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">asCacheItem	^self cache cacheItemFor: self</body><body package="NetResources">asCacheItemUnreconciled	^self cache unreconciledCacheItemFor: self</body><body package="NetResources">asEncodedCacheItem	^self asCacheItem asEncodedCacheItem</body><body package="NetResources">asResource	^self asCacheItem asResource</body><body package="NetResources">asResourceInEncoding: anEncoding	^self asCacheItem asResourceInEncoding: anEncoding</body><body package="NetResources">asResourceInMimeType: aMimeType	^self asCacheItem asResourceInMimeType: aMimeType</body><body package="NetResources">asResourceInMimeType: aMimeType encoding: anEncoding	^self asCacheItem asResourceInMimeType: aMimeType encoding: anEncoding</body><body package="NetResources">binaryValueStream	^self asCacheItem binaryValueStream</body></methods><methods><class-id>OS.URL</class-id> <category>accessing</category><body package="NetResources">cache	^Net.Resources.Cache current</body></methods><methods><class-id>OS.URL</class-id> <category>private-NetResources</category><body package="NetResources">cacheItemClass	^Net.Resources.CacheItem</body><body package="NetResources">canCache	^false</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">delete	self cache deleteFor: self</body></methods><methods><class-id>OS.URL</class-id> <category>private-NetResources</category><body package="NetResources">deleteCacheItem: aCacheItem	self subclassResponsibility</body><body package="NetResources">diskCacheName	^[(Net.Resources.Cache cachePath, ((((((self asString copyReplaceAll: '/' with: '-')		copyReplaceAll: ':' with: '-')			copyReplaceAll: '?' with: '-')				copyReplaceAll: '&amp;' with: '-')					copyReplaceAll: '.' with: '-'))) asFilename]					on: Error do: [:sig | nil]</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">hasChanged	^self asCacheItem hasChanged</body><body package="NetResources">isAvailable	self canCache ifFalse: [^true].	^self cache isAvailable: self</body></methods><methods><class-id>OS.URL</class-id> <category>private-NetResources</category><body package="NetResources">isValid	^true</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">mimeType	^self asCacheItem mimeType</body><body package="NetResources">post: contents	^self post: contents encoding: self asCacheItem getEncoding</body></methods><methods><class-id>OS.URL</class-id> <category>private-NetResources</category><body package="NetResources">post: contents cacheItem: aCacheItem encoding: encoding	self subclassResponsibility</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">post: contents encoding: encoding	^self cache post: contents for: self encoding: encoding</body><body package="NetResources">put: contents	^self put: contents encoding: self asCacheItem getEncoding</body></methods><methods><class-id>OS.URL</class-id> <category>private-NetResources</category><body package="NetResources">put: contents cacheItem: aCacheItem encoding: encoding	self subclassResponsibility</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">put: contents encoding: encoding	^self cache put: contents for: self encoding: encoding</body></methods><methods><class-id>OS.URL</class-id> <category>private-NetResources</category><body package="NetResources">reconcileCacheItem: aCacheItem	"return true for the Cache to update and false for nothing to happen"	^self subclassResponsibility</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">refresh	^self asCacheItem</body></methods><methods><class-id>OS.URL</class-id> <category>private-NetResources</category><body package="NetResources">removeInMemory	self cache removeInMemoryFor: self</body><body package="NetResources">resourceHandlerFor: aMimeType	^Net.Resources.ResourceHandler handlerClassFor: aMimeType</body></methods><methods><class-id>OS.URL</class-id> <category>API-NetResources</category><body package="NetResources">valueStream	| encodedContents |	encodedContents := self asEncodedCacheItem asEncodedContents.	encodedContents ifNil: [^String new readStream].	^encodedContents readStream</body></methods><methods><class-id>Graphics.Image</class-id> <category>converting</category><body package="NetResources">asCachedImage	^CachedImage on: self</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>As yet unclassified</category><body package="NetResources">queries	| queries |	queries := OrderedCollection new.	(query tokensBasedOn: $&amp;) do: [:pair |		| bits |		bits := pair tokensBasedOn: $=.		queries add: (bits first -&gt; bits second)].	^queries</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="NetResources">removeLastComponent	"Override for the www.foo.com/ case"	path isEmpty ifTrue: [^self].	path := path copyFrom: 1 to: path size-1</body><body package="NetResources">resolveRelativePath: pathString	"overridden in WithStyle to handle empty stream properly (href='?stuff')"	| stream copy compStream ch newQuery |	pathString isEmpty ifTrue: [^self copy].	('*:/*' match: pathString) ifTrue: [^pathString asURI].	('//*' match: pathString) ifTrue: [^self class fromString: pathString].	newQuery := nil.	(pathString includes: $?)		ifFalse:	[stream := pathString readStream]		ifTrue:			[newQuery := pathString readStream upTo: $?; upToEnd.			stream := (pathString readStream upTo: $?) readStream].	copy := self copy.	copy query: newQuery; fragment: nil.	(stream atEnd or: [stream peekFor: $/])		ifTrue: [copy path: #()]		ifFalse: [copy removeLastComponent].	compStream := (String new: 10) writeStream.	[stream atEnd]		whileFalse:			[ch := stream next.			ch = $/				ifTrue:					[copy addComponent: compStream contents.					compStream reset]				ifFalse: [self class decodeChar: ch from: stream to: compStream]].	compStream position = 0		ifFalse: [copy addComponent: compStream contents].	pathString last = $/ ifTrue: [copy addComponent: ''].	^copy</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="NetResources">dropNetResourcesCache	&lt;triggerAtSystemEvent: #aboutToSnapshot&gt;	Net.Resources.Cache dropCache</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>URI</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>encoder </class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>URL</name><environment>OS</environment><super>OS.URI</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>URLwithPath</name><environment>OS</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path query fragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>FileURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>missingSlashes host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>PixelArray</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>CachedImage</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image retainedMedium conversionMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Image</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bits width height depth bitsPerPixel palette maxPixelValue rowByteSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>OpaqueImage</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure shape </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>UnknownURLType</name><environment>OS</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>