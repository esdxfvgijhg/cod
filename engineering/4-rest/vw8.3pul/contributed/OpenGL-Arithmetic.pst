<?xml version="1.0"?><st-source><!-- Name: OpenGL-ArithmeticComment: This package contains CPU based arithmetic functions that can be applied to vectors, matrices and colors.DbIdentifier: bear73DbTrace: 205253DevelopmentPrerequisites: #(#(#any 'OpenGL' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #()PackageName: OpenGL-ArithmeticParcel: #('OpenGL-Arithmetic')PrerequisiteParcels: #(#('OpenGL' ''))PrintStringCache: (3.0 7,mlucassmith)Version: 3.0 7Date: 8:40:16 AM September 18, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (sep09.3) of September 18, 2009 on September 18, 2009 at 8:40:16 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>OpenGL.Vector3 class</class-id> <category>instance creation</category><body package="OpenGL-Arithmetic" selector="x:y:z:">x: x y: y z: z	^Vector3 new		x: x;		y: y;		z: z;		yourself</body></methods><methods><class-id>OpenGL.Vector3</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_crossProduct:">_crossProduct: aVector	| nx ny nz |	nx := (self y * aVector z) - (self z * aVector y).	ny := (self z * aVector x) - (self x * aVector z).	nz := (self x * aVector y) - (self y * aVector x).	self x: nx.	self y: ny.	self z: nz</body><body package="OpenGL-Arithmetic" selector="_reverse">_reverse	| temp |	temp := self x.	self x: self z.	self z: temp</body><body package="OpenGL-Arithmetic" selector="_shiftLeft">_shiftLeft	| temp |	temp := self x.	self x: self y.	self y: self z.	self z: temp</body><body package="OpenGL-Arithmetic" selector="_shiftRight">_shiftRight	| temp |	temp := self z.	self z: self y.	self y: self x.	self x: temp</body></methods><methods><class-id>OpenGL.Vector3</class-id> <category>copying</category><body package="OpenGL-Arithmetic" selector=",">, aNumber	aNumber isSequenceable ifTrue: [^super , aNumber].	^Vector4 x: self x y: self y z: self z w: aNumber</body></methods><methods><class-id>OpenGL.Vector3</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="crossProduct:">crossProduct: aVector	^self copy _crossProduct: aVector</body></methods><methods><class-id>OpenGL.Vector3</class-id> <category>accessing</category><body package="OpenGL-Arithmetic" selector="xy">xy	^Vector2 new		x: self x;		y: self y;		yourself</body></methods><methods><class-id>Core.Array</class-id> <category>enumerating</category><body package="OpenGL-Arithmetic" selector="asBezierCurve:">asBezierCurve: slices	| curve |	curve := OrderedCollection new.	self bezier: 1 / (slices - 1) do: [:each | curve add: each].	^curve asArray</body><body package="OpenGL-Arithmetic" selector="asBezierSurface:">asBezierSurface: uv	" Return a 2D array of UxV starting "	| u surface |	u := self collect: [:curve | curve asBezierCurve: uv x].	surface := Array new: uv y.	1 to: uv y do: [:y | surface at: y put: (Array new: uv x)].	1 to: uv x do: [:x |		| curve column |		curve := (1 to: self size) collect: [:i | (u at: i) at: x].		column := curve asBezierCurve: uv y.		column keysAndValuesDo: [:y :point | (surface at: y) at: x put: point]].	^surface</body><body package="OpenGL-Arithmetic" selector="bezier:do:">bezier: step do: aBlock	| output input |	0 to: 1 by: step do: [:t |		input := self copy.		self size - 1 to: 1 by: -1 do: [:size |			output := Array new: size.			1 to: size do: [:i |				| p0 p1 pt |				p0 := input at: i.				p1 := input at: i + 1.				pt := (p1 - p0) * t + p0.				output at: i put: pt].			input := output].		aBlock value: output first]</body></methods><methods><class-id>OpenGL.Color3</class-id> <category>converting</category><body package="OpenGL-Arithmetic" selector="blendWith:">blendWith: aColor3	^(self asColorValue blendWith: aColor3 asColorValue) asColor3</body></methods><methods><class-id>Core.Number</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="_differenceFromVector:">_differenceFromVector: aVector	^aVector apply: [:each | each - self]</body><body package="OpenGL-Arithmetic" selector="_moduloFromVector:">_moduloFromVector: aVector	aVector apply: [:each | each \\ self].	^aVector</body><body package="OpenGL-Arithmetic" selector="_productFromVector:">_productFromVector: aVector	^aVector apply: [:each | each * self]</body><body package="OpenGL-Arithmetic" selector="_quotientFromVector:">_quotientFromVector: aVector	^aVector apply: [:each | each / self]</body><body package="OpenGL-Arithmetic" selector="_sumFromVector:">_sumFromVector: aVector	^aVector apply: [:each | each + self]</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="OpenGL-Arithmetic" selector=",">, aNumber	^OpenGL.Vector2 x: self y: aNumber</body></methods><methods><class-id>Core.Number</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="clamp:and:">clamp: min and: max	^(self max: min) min: max</body></methods><methods><class-id>Core.Number</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="differenceFromMatrix:">differenceFromMatrix: aMatrix	^aMatrix copy		apply: [:each | each - self];		yourself</body><body package="OpenGL-Arithmetic" selector="differenceFromVector:">differenceFromVector: aVector		^self _differenceFromVector: aVector copy</body><body package="OpenGL-Arithmetic" selector="moduloFromVector:">moduloFromVector: aVector	^self _moduloFromVector: aVector copy</body><body package="OpenGL-Arithmetic" selector="productFromMatrix:">productFromMatrix: aMatrix	^aMatrix copy		apply: [:each | each * self];		yourself</body><body package="OpenGL-Arithmetic" selector="productFromVector:">productFromVector: aVector		^self _productFromVector: aVector copy</body><body package="OpenGL-Arithmetic" selector="quotientFromMatrix:">quotientFromMatrix: aMatrix	^aMatrix copy		apply: [:each | each / self];		yourself</body><body package="OpenGL-Arithmetic" selector="quotientFromVector:">quotientFromVector: aVector		^self _quotientFromVector: aVector copy</body><body package="OpenGL-Arithmetic" selector="sumFromMatrix:">sumFromMatrix: aMatrix	^aMatrix copy		apply: [:each | each + self];		yourself</body><body package="OpenGL-Arithmetic" selector="sumFromVector:">sumFromVector: aVector		^self _sumFromVector: aVector copy</body></methods><methods><class-id>OpenGL.Matrix class</class-id> <category>instance creation</category><body package="OpenGL-Arithmetic" selector="dimensions:">dimensions: dimensions	Matrix allSubclassesDo: [:subclass |		(subclass columns = dimensions x and: [subclass rows = dimensions y]) ifTrue: [^subclass new]].	self error: 'dimensions mismatched'</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="-">- delta	^delta differenceFromMatrix: self</body><body package="OpenGL-Arithmetic" selector="*">* scale	^scale productFromMatrix: self</body><body package="OpenGL-Arithmetic" selector="/">/ scale	^scale quotientFromMatrix: self</body><body package="OpenGL-Arithmetic" selector="+">+ delta	^delta sumFromMatrix: self</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>transforming!</category><body package="OpenGL-Arithmetic" selector="apply:">apply: aBlock	1 to: self size do: [:index | self at: index put: (aBlock value: (self at: index))]</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>private</category><body package="OpenGL-Arithmetic" selector="columnVectorClass">columnVectorClass	self columns = 2 ifTrue: [^Vector2].	self columns = 3 ifTrue: [^Vector3].	self columns = 4 ifTrue: [^Vector4].	self incompatibleDimensionsError</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>accessing</category><body package="OpenGL-Arithmetic" selector="columnVectors">columnVectors	| vectors |	vectors := Array new: self columns.	1 to: self columns do: [:column |		| vector |		vector := self rowVectorClass new.		vectors at: column put: vector.		1 to: self rows do: [:row | vector at: row put: (self valueAt: column @ row)]].	^vectors</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="differenceFromDouble:">differenceFromDouble: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromFloat:">differenceFromFloat: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromFraction:">differenceFromFraction: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromInteger:">differenceFromInteger: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromMatrix:">differenceFromMatrix: aMatrix"	matrixA (NxM) - matrixB (NxM) == matrixC (NxM)"	aMatrix dimensions = self dimensions ifFalse: [self incompatibleDimensionsError].	^aMatrix copy		with: self apply: [:a :b | a - b];		yourself</body><body package="OpenGL-Arithmetic" selector="differenceFromNumber:">differenceFromNumber: aNumber	^self copy apply: [:each | aNumber - each]</body><body package="OpenGL-Arithmetic" selector="differenceFromVector:">differenceFromVector: aVector"	aVector (1xN) - aMatrix (1xN) == aVector (1xN)"	| newVector |	(self columns = 1 and: [self rows = aVector size]) ifFalse: [self incompatibleDimensionsError].	newVector := aVector class new.	newVector with: aVector with: self apply: [:uninitialized :a :b | a - b].	^newVector</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>private</category><body package="OpenGL-Arithmetic" selector="incompatibleDimensionsError">incompatibleDimensionsError	self error: 'cannot combine matrices with incompatible dimensions'</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="productFromDouble:">productFromDouble: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromFloat:">productFromFloat: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromFraction:">productFromFraction: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromInteger:">productFromInteger: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromMatrix:">productFromMatrix: aMatrix"	matrixA (NxM) * matrixB (OxN) == matrixC (OxM)"	| matrixA matrixB matrixC rows columns i |	matrixA := aMatrix.	matrixB := self.	matrixA columns = matrixB rows ifFalse: [self incompatibleDimensionsError].	matrixC := self class dimensions: matrixB columns @ matrixA rows.	rows := matrixA rowVectors.	columns := matrixB columnVectors.	i := 1.	columns do: [:column |		rows do: [:row |			matrixC at: i put: (row dot: column).			i := i + 1]].	^matrixC</body><body package="OpenGL-Arithmetic" selector="productFromNumber:">productFromNumber: aNumber	^self copy apply: [:each | aNumber * each]</body><body package="OpenGL-Arithmetic" selector="productFromVector:">productFromVector: aVector"	vectorA (Nx1) * matrixB (MxN) == vectorC (Mx1)"	| vectorA matrixB vectorC rows columns i |	vectorA := aVector.	matrixB := self.	vectorA size = matrixB rows ifFalse: [self incompatibleDimensionsError].	matrixB columns = 2 ifTrue: [vectorC := Vector2 new].	matrixB columns = 3 ifTrue: [vectorC := Vector3 new].	matrixB columns = 4 ifTrue: [vectorC := Vector4 new].	rows := Array with: vectorA.	columns := matrixB columnVectors.	i := 1.	columns do: [:column |		rows do: [:row |			vectorC at: i put: (row dot: column).			i := i + 1]].	^vectorC</body><body package="OpenGL-Arithmetic" selector="quotientFromDouble:">quotientFromDouble: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromFloat:">quotientFromFloat: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromFraction:">quotientFromFraction: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromInteger:">quotientFromInteger: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromMatrix:">quotientFromMatrix: aMatrix"	matrixA (NxM) / matrixB (OxN) == error"	self error: 'matrixA / matrixB is not supported'</body><body package="OpenGL-Arithmetic" selector="quotientFromNumber:">quotientFromNumber: aNumber	^self copy apply: [:each | aNumber / each]</body><body package="OpenGL-Arithmetic" selector="quotientFromVector:">quotientFromVector: aVector"	vectorA (1xN) / matrixB (NxM) == error"	self error: 'vectorA / matrixB is not supported'</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>private</category><body package="OpenGL-Arithmetic" selector="rowVectorClass">rowVectorClass	self rows = 2 ifTrue: [^Vector2].	self rows = 3 ifTrue: [^Vector3].	self rows = 4 ifTrue: [^Vector4].	self incompatibleDimensionsError</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>accessing</category><body package="OpenGL-Arithmetic" selector="rowVectors">rowVectors	| vectors |	vectors := Array new: self rows.	1 to: self rows do: [:row |		| vector |		vector := self columnVectorClass new.		vectors at: row put: vector.		1 to: self columns do: [:column | vector at: column put: (self valueAt: column @ row)]].	^vectors</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="sumFromDouble:">sumFromDouble: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromFloat:">sumFromFloat: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromFraction:">sumFromFraction: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromInteger:">sumFromInteger: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromMatrix:">sumFromMatrix: aMatrix"	matrixA (NxM) + matrixB (NxM) == matrixC (NxM)"	aMatrix dimensions = self dimensions ifFalse: [self incompatibleDimensionsError].	^aMatrix copy		with: self apply: [:a :b | a + b];		yourself</body><body package="OpenGL-Arithmetic" selector="sumFromNumber:">sumFromNumber: aNumber	^self copy apply: [:each | aNumber + each]</body><body package="OpenGL-Arithmetic" selector="sumFromVector:">sumFromVector: aVector"	aVector (1xN) + aMatrix (1xN) == aVector (1xN)"	| newVector |	(self columns = 1 and: [self rows = aVector size]) ifFalse: [self incompatibleDimensionsError].	newVector := aVector class new.	newVector with: aVector with: self apply: [:uninitialized :a :b | a + b].	^newVector</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="transpose">transpose	| transposed |	transposed := self class dimensions: self rows, self columns.	1 to: self rows do: [:row |		1 to: self columns do: [:column | transposed at: row @ column transpose put: (self valueAt: (column @ row))]].	^transposed</body></methods><methods><class-id>OpenGL.Matrix</class-id> <category>transforming!</category><body package="OpenGL-Arithmetic" selector="with:apply:">with: aMatrix apply: aBlock	aMatrix dimensions ~= self dimensions ifTrue: [^self error: 'cannot combine matrices with different dimensions'].	1 to: self size do: [:index | self at: index put: (aBlock value: (self at: index) value: (aMatrix at: index))]</body></methods><methods><class-id>OpenGL.Vector2 class</class-id> <category>instance creation</category><body package="OpenGL-Arithmetic" selector="x:y:">x: x y: y	^Vector2 new		x: x;		y: y;		yourself</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_abs">_abs	self apply: [:each | each abs]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation!</category><body package="OpenGL-Arithmetic" selector="_ceiling">_ceiling	self apply: [:each | each ceiling]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_clamp:and:">_clamp: min and: max	^self _min: max max: min</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="_differenceFromVector:">_differenceFromVector: aVector	^aVector with: self apply: [:a :b | a - b]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation!</category><body package="OpenGL-Arithmetic" selector="_floor">_floor	self apply: [:each | each floor]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_half">_half	self apply: [:each | each half]</body><body package="OpenGL-Arithmetic" selector="_max:">_max: aVector	self with: aVector apply: [:a :b | a max: b]</body><body package="OpenGL-Arithmetic" selector="_midpoint:">_midpoint: aVector	(self add: aVector) _half</body><body package="OpenGL-Arithmetic" selector="_min:">_min: aVector	self with: aVector apply: [:a :b | a min: b]</body><body package="OpenGL-Arithmetic" selector="_min:max:">_min: minVector max: maxVector	self with: minVector with: maxVector apply: [:a :b :c | (a min: b) max: c]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="_moduloFromVector:">_moduloFromVector: aVector	^aVector with: self apply: [:a :b | a \\ b]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_negated">_negated	self apply: [:each | each negated]</body><body package="OpenGL-Arithmetic" selector="_normalize">_normalize	self divide: self radius</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="_productFromVector:">_productFromVector: aVector	^aVector with: self apply: [:a :b | a * b]</body><body package="OpenGL-Arithmetic" selector="_quotientFromVector:">_quotientFromVector: aVector	^aVector with: self apply: [:a :b | a / b]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_reverse">_reverse	| temp |	temp := self x.	self x: self y.	self y: temp</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation!</category><body package="OpenGL-Arithmetic" selector="_rounded">_rounded	self apply: [:each | each rounded]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_shiftLeft">_shiftLeft	| temp |	temp := self x.	self x: self y.	self y: temp</body><body package="OpenGL-Arithmetic" selector="_shiftRight">_shiftRight	| temp |	temp := self y.	self y: self x.	self x: temp</body><body package="OpenGL-Arithmetic" selector="_sign">_sign	self apply: [:each | each sign]</body><body package="OpenGL-Arithmetic" selector="_squared">_squared	self apply: [:each | each * each]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="_sumFromVector:">_sumFromVector: aVector	^aVector with: self apply: [:a :b | a + b]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation!</category><body package="OpenGL-Arithmetic" selector="_truncated">_truncated	self apply: [:each | each truncated]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="-">- delta	^delta differenceFromVector: self</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>copying</category><body package="OpenGL-Arithmetic" selector=",">, aNumber	aNumber isSequenceable ifTrue: [^super , aNumber].	^Vector3 x: self x y: self y z: aNumber</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="*">* scale	^scale productFromVector: self</body><body package="OpenGL-Arithmetic" selector="/">/ scale	^scale quotientFromVector: self</body><body package="OpenGL-Arithmetic" selector="//">// scale	^(self / scale) _floor</body><body package="OpenGL-Arithmetic" selector="\\">\\ scale	^scale moduloFromVector: self</body><body package="OpenGL-Arithmetic" selector="+">+ delta	^delta sumFromVector: self</body><body package="OpenGL-Arithmetic" selector="abs">abs	^self copy _abs</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>transforming!</category><body package="OpenGL-Arithmetic" selector="apply:">apply: aBlock		1 to: self size do: [:index | self at: index put: (aBlock value: (self at: index))]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>copying</category><body package="OpenGL-Arithmetic" selector="asPoint">asPoint	^self x @ self y</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation</category><body package="OpenGL-Arithmetic" selector="ceiling">ceiling	^self copy _ceiling</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="cheapDistance:">cheapDistance: aVector	" Returns a slightly inaccurate distance between points, but does so in a slightly CPU cheaper fashion than #distance: "	| delta |	delta := 0.	self with: aVector do: [:a :b | delta := delta + ((b - a) truncated ** 2)].	^delta sqrt</body><body package="OpenGL-Arithmetic" selector="clamp:and:">clamp: min and: max	^self copy _clamp: min and: max</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="differenceFromDouble:">differenceFromDouble: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromFloat:">differenceFromFloat: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromFraction:">differenceFromFraction: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromInteger:">differenceFromInteger: aNumber	^self differenceFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="differenceFromMatrix:">differenceFromMatrix: aMatrix"	matrixA (1xN) - vectorB (1xN) == vectorC (1xN)"	| newVector |	(aMatrix columns = 1 and: [aMatrix rows = self size]) ifFalse: [aMatrix incompatibleDimensionsError].	newVector := self class new.	newVector with: aMatrix with: self apply: [:uninitialized :a :b | a - b].	^newVector</body><body package="OpenGL-Arithmetic" selector="differenceFromNumber:">differenceFromNumber: aNumber	^self copy apply: [:each | aNumber - each]</body><body package="OpenGL-Arithmetic" selector="differenceFromVector:">differenceFromVector: aVector	^self _differenceFromVector: aVector copy</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="distance:">distance: aVector	^(aVector - self) radius</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="divide:">divide: scale	scale _quotientFromVector: self</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="dot:">dot: aVector	| result |	result := 0.	self with: aVector do: [:a :b | result := result + (a * b)].	^result</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="equalFromVector:">equalFromVector: aVector	aVector size = self size ifFalse: [^false].	aVector with: self do: [:a :b | a = b ifFalse: [^false]].	^true</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation</category><body package="OpenGL-Arithmetic" selector="floor">floor	^self copy _floor</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="half">half	^self copy _half</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>testing</category><body package="OpenGL-Arithmetic" selector="isZero">isZero	self do: [:each | each isZero ifFalse: [^false]].	^true</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="lessFromVector:">lessFromVector: aVector	aVector size = self size ifFalse: [^false].	aVector with: self do: [:a :b | a &lt; b ifFalse: [^false]].	^true</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="max:">max: aVector	^self copy _max: aVector</body><body package="OpenGL-Arithmetic" selector="midpoint:">midpoint: aVector	^self copy _midpoint: aVector</body><body package="OpenGL-Arithmetic" selector="min:">min: aVector	^self copy _min: aVector</body><body package="OpenGL-Arithmetic" selector="min:max:">min: minVector max: maxVector	^self copy _min: minVector max: maxVector</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="modulo:">modulo: scale	scale _moduloFromVector: self</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="moduloFromVector:">moduloFromVector: aVector	^self _moduloFromVector: aVector copy</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="multiply:">multiply: scale	scale _productFromVector: self</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="negated">negated	^self copy _negated</body><body package="OpenGL-Arithmetic" selector="normalize">normalize	^self / self radius</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="plus:">plus: delta	delta _sumFromVector: self</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="productFromDouble:">productFromDouble: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromFloat:">productFromFloat: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromFraction:">productFromFraction: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromInteger:">productFromInteger: aNumber	^self productFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="productFromMatrix:">productFromMatrix: aMatrix"	matrixA (NxM) * vectorB (1xN) == vectorC (1xM)"	| matrixA vectorB vectorC rows columns i |	matrixA := aMatrix.	vectorB := self.	matrixA columns = vectorB size ifFalse: [self incompatibleDimensionsError].	matrixA rows = 2 ifTrue: [vectorC := Vector2 new].	matrixA rows = 3 ifTrue: [vectorC := Vector3 new].	matrixA rows = 4 ifTrue: [vectorC := Vector4 new].	rows := matrixA rowVectors.	columns := Array with: self.	i := 1.	columns do: [:column |		rows do: [:row |			vectorC at: i put: (row dot: column).			i := i + 1]].	^vectorC</body><body package="OpenGL-Arithmetic" selector="productFromNumber:">productFromNumber: aNumber	^self copy apply: [:each | aNumber * each]</body><body package="OpenGL-Arithmetic" selector="productFromVector:">productFromVector: aVector	^self _productFromVector: aVector copy</body><body package="OpenGL-Arithmetic" selector="quotientFromDouble:">quotientFromDouble: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromFloat:">quotientFromFloat: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromFraction:">quotientFromFraction: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromInteger:">quotientFromInteger: aNumber	^self quotientFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="quotientFromMatrix:">quotientFromMatrix: aMatrix"	matrixA (NxM) / vectorB (Mx1) == error"	self error: 'matrixA / vectorB is not supported'</body><body package="OpenGL-Arithmetic" selector="quotientFromNumber:">quotientFromNumber: aNumber	^self copy apply: [:each | aNumber / each]</body><body package="OpenGL-Arithmetic" selector="quotientFromVector:">quotientFromVector: aVector	^self _quotientFromVector: aVector copy</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="radius">radius	^(self dot: self) sqrt</body><body package="OpenGL-Arithmetic" selector="reverse">reverse	^self copy _reverse</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation</category><body package="OpenGL-Arithmetic" selector="rounded">rounded	^self copy _rounded</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="shiftLeft">shiftLeft	^self copy _shiftLeft</body><body package="OpenGL-Arithmetic" selector="shiftRight">shiftRight	^self copy _shiftRight</body><body package="OpenGL-Arithmetic" selector="sign">sign	^self copy _sign</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="subtract:">subtract: delta	delta _differenceFromVector: self</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>arithmetic</category><body package="OpenGL-Arithmetic" selector="sum">sum	| sum |	sum := 0.	self do: [:each | sum := sum + each].	^sum</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>double dispatching</category><body package="OpenGL-Arithmetic" selector="sumFromDouble:">sumFromDouble: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromFloat:">sumFromFloat: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromFraction:">sumFromFraction: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromInteger:">sumFromInteger: aNumber	^self sumFromNumber: aNumber</body><body package="OpenGL-Arithmetic" selector="sumFromMatrix:">sumFromMatrix: aMatrix"	matrixA (1xN) + vectorB (1xN) == vectorC (1xN)"	| newVector |	(aMatrix columns = 1 and: [aMatrix rows = self size]) ifFalse: [aMatrix incompatibleDimensionsError].	newVector := self class new.	newVector with: aMatrix with: self apply: [:uninitialized :a :b | a + b].	^newVector</body><body package="OpenGL-Arithmetic" selector="sumFromNumber:">sumFromNumber: aNumber	^self copy apply: [:each | aNumber + each]</body><body package="OpenGL-Arithmetic" selector="sumFromVector:">sumFromVector: aVector	^self _sumFromVector: aVector copy</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>truncation</category><body package="OpenGL-Arithmetic" selector="truncated">truncated	^self copy _truncated</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>transforming!</category><body package="OpenGL-Arithmetic" selector="with:apply:">with: aVector apply: aBlock	1 to: self size do: [:index | self at: index put: (aBlock value: (self at: index) value: (aVector at: index))]</body><body package="OpenGL-Arithmetic" selector="with:with:apply:">with: vectorA with: vectorB apply: aBlock		1 to: self size do: [:index | self at: index put: (aBlock value: (self at: index) value: (vectorA at: index) value: (vectorB at: index))]</body></methods><methods><class-id>OpenGL.Vector2</class-id> <category>accessing</category><body package="OpenGL-Arithmetic" selector="yx">yx	^self class x: self y y: self x</body></methods><methods><class-id>OpenGL.Vector4 class</class-id> <category>instance creation</category><body package="OpenGL-Arithmetic" selector="x:y:z:w:">x: x y: y z: z w: w	^Vector4 new		x: x;		y: y;		z: z;		w: w;		yourself</body></methods><methods><class-id>OpenGL.Vector4</class-id> <category>arithmetic!</category><body package="OpenGL-Arithmetic" selector="_reverse">_reverse	| temp1 temp2 |	temp1 := self x.	temp2 := self y.	self x: self w.	self y: self z.	self w: temp1.	self z: temp2</body><body package="OpenGL-Arithmetic" selector="_shiftLeft">_shiftLeft	| temp |	temp := self x.	self x: self y.	self y: self z.	self z: self w.	self w: temp</body><body package="OpenGL-Arithmetic" selector="_shiftRight">_shiftRight	| temp |	temp := self w.	self w: self z.	self z: self y.	self y: self x.	self x: temp</body></methods><methods><class-id>OpenGL.Vector4</class-id> <category>copying</category><body package="OpenGL-Arithmetic" selector=",">, aCollection	aCollection isSequenceable ifFalse: [self error: 'vector has a maximum of four components'].	^super , aCollection</body></methods><methods><class-id>OpenGL.Vector4</class-id> <category>opengl</category><body package="OpenGL-Arithmetic" selector="transform:in:">transform: aMatrix in: aViewport	" Given aMatrix, do the transformation pipeline a coordinate goes through in OpenGL standard and produce a window coordinate inside aViewport.	  Note that any z values outside of 0..1 are clipped by the hardware. "	| clip device |	clip := aMatrix * self.	device := (clip / clip w) xyz.	^	(aViewport width half * device x + aViewport width half),		(aViewport height half * device y + aViewport height half),		(0.5 * device z + 0.5)</body></methods><methods><class-id>OpenGL.Vector4</class-id> <category>accessing</category><body package="OpenGL-Arithmetic" selector="xyz">xyz	^Vector3 new		x: self x;		y: self y;		z: self z;		yourself</body></methods><methods><class-id>OpenGL.Color4</class-id> <category>converting</category><body package="OpenGL-Arithmetic" selector="blendWith:">blendWith: aColor4	^(self asColorValue blendWith: aColor4 asColorValue) asColor4</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Vector2</name><environment>OpenGL</environment><super>OpenGL.FloatArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL</package></attributes></class><class><name>Vector3</name><environment>OpenGL</environment><super>OpenGL.Vector2</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL</package></attributes></class><class><name>Vector4</name><environment>OpenGL</environment><super>OpenGL.Vector3</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Matrix</name><environment>OpenGL</environment><super>OpenGL.FloatArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL</package></attributes></class><class><name>Color3</name><environment>OpenGL</environment><super>OpenGL.FloatArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL</package></attributes></class><class><name>Color4</name><environment>OpenGL</environment><super>OpenGL.Color3</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenGL</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>