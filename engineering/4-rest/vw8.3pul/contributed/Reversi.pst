<?xml version="1.0"?><st-source><!-- Name: ReversiCard-catalog:       NAME	Reversi
       AUTHOR	rjs@atl.ema.eds.com (Robert J. Sullivan)
       URL	(none)
       FUNCTION	VW 2.5 board game
       KEYWORDS	reversi othello
       ST-VERSIONS	VisualWorks 2.5
       PREREQUISITES	(none)
       CONFLICTS	(none known)
       DISTRIBUTION	world
       VERSION	2.0
       DATE	23-Jul-97

SUMMARY

  The rules are simple.  White moves first and the moves alternate between players.  A player must move as long as he has at least one legal move, else he passes.  A legal move consists ofany move that 'flips' at least one of the opposing pieces.  An opposing piece is flipped if it stands between (either alone or with a line of other opposing pieces and either vertically, horizontally, or diagonally) the piece just played and another piece of the same color as that just played.  When a piece isflipped, it becomes the opposite color to what it was prior to flipping. The game ends when neither player has a legal move.  The winner of the game is the player with the most pieces of his color at the end ofthe game.

				Robert J. Sullivan
Comment: Robert J. Sullivan's Reversi from the Smalltalk Archive at the UIUC.DbIdentifier: bear73DbTrace: 443627DbUsername: kgreekDbVersion: 8.0PackageName: ReversiParcel: #('Reversi')ParcelName: ReversiPrintStringCache: (8.0,kgreek)Version: 8.0Post-Load Block: 	[:package | |pages wb|pages := (#(#'card-catalog' #comment) collect:	[:name|	WorkspacePage		labeled: name asString		with: (package propertyAt: name)]) readStream.wb := Workbook new.wb		replaceAllTextPagesWith: pages next;	addPage: pages next;	open.wb builder window label: 'Reversi Information']Date: 10:03:10 AM August 1, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (aug14.1) of August 1, 2014 on August 1, 2014 at 10:03:10 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Reversi</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageArea view board valueBoard player opponent opponentMove playLevel lookAheadLevel lookAheadBoard lookAheadBoards lookAheadMoves lookAheadMove lookAheadPlayers lookAheadPlayer lookAheadThreshold lookAheadRatio computerMoveProcess animation debug rand </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IntegrationManagementTemplate-IMTGamesApplication</category><attributes><package>Reversi</package></attributes></class><comment><class-id>Reversi</class-id><body>Written by: Robert J. Sullivan 9595 North Pond CircleRoswell GA 30076rjs@atl.ema.eds.comThis class represents the model portion of the game.All game-playing logic, including look-ahead, is inthis class.  See the comments method in the lookahead category.</body></comment><class><name>ReversiView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>first splashScreen repainting </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IntegrationManagementTemplate-IMTGamesApplication</category><attributes><package>Reversi</package></attributes></class><comment><class-id>ReversiView</class-id><body>Written by: Robert J. Sullivan 9595 North Pond CircleRoswell GA 30076rjs@atl.ema.eds.comThis class displays the Reversi game board.  The animation option allows pieces, when changing, to flipup and over.  The way this is accomplished is by displayinga series of images composed of a background with a phaseof the flip layered on top.  This technique achieves smooth animation.  The alternative, drawing a phase of the flip anderasing it before drawing the next phase, produces a flickeringdisplay.  All of the phases of the flip are store in the cachedImagesdictionary.  The images are generated the first time on-the-fly. Thereafter the cached images are used.    When a piece is about to be flipped the square is first blanked out and then captured to be the background image that is combined with each of the flip phases.  By capturing the background for each square we are able to allow the flipping piece to raise up a bit as it flips.  The raising up causes it to partially obscure the square above and behind it and that square may be empty, or occupied by either a black or white piece.</body></comment><class><name>ReversiController</name><environment>Smalltalk</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mouseColRow button1DownState lookAheadInProgress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IntegrationManagementTemplate-IMTGamesApplication</category><attributes><package>Reversi</package></attributes></class><comment><class-id>ReversiController</class-id><body>Written by: Robert J. Sullivan 9595 North Pond CircleRoswell GA 30076rjs@atl.ema.eds.comThis class provides mouse and keyboard control logic for ReversiView.</body></comment><methods><class-id>Reversi</class-id> <category>private move making</category><body package="Reversi">axisFlip: aSquare rowDir: rowDir colDir: colDir for: aPlayer 	| row col x opp |	col := aSquare x.	row := aSquare y.	aPlayer = 1		ifTrue: [opp := 0]		ifFalse: [opp := 1].	x := 1.	[x &lt;= 8]		whileTrue: 			[| curSquare |			row := row + rowDir.			col := col + colDir.			row &lt; 1 | (row &gt; 8) | (col &lt; 1) | (col &gt; 8)				ifTrue: 					["Test for out-of-bounds conditions."					row := row - rowDir.					col := col - colDir.					x := 8].	"What is the next square?"			curSquare := board atPoint: col @ row.			curSquare = opp				ifTrue: 					["As long as it is an opponent, keep going."					board atPoint: col @ row put: self player.					self lookAheadPlayer = nil ifTrue: [view displaySquareAt: (board integerIndexFor: col @ row)]]				ifFalse: [^self].			x := x + 1]</body><body package="Reversi">computerMove	self messageArea value: 'Searching...'.	self perform: playLevel value.	view displaySquareAt: (board integerIndexFor: opponentMove).	(self messageArea value = self stillAChance or: [self messageArea value = self noChance])		ifFalse: [self messageArea value: self computerMoveMsg]</body><body package="Reversi">gameOver	| score |	score := self score.	self messageArea value: 'Game Over !     White: ' , score x printString , '  Black: ' , score y printString</body><body package="Reversi">moveAt: aSquare 	self moveAt: aSquare for: player</body><body package="Reversi">moveAt: aSquare for: aPlayer	board atPoint: aSquare put: self player.	view first: true.	self lookAheadPlayer = nil ifTrue: [view displaySquareAt: (board integerIndexFor: aSquare)].	Cursor normal beCursor.		"Flip in all eight directions."	(self axisMoveable: aSquare rowDir: 1 colDir: 0 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: 1 colDir: 0 for: aPlayer)].	(self axisMoveable: aSquare rowDir: 1 colDir: 1 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: 1 colDir: 1 for: aPlayer)].	(self axisMoveable: aSquare rowDir: 0 colDir: 1 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: 0 colDir: 1 for: aPlayer)].		(self axisMoveable: aSquare rowDir: -1 colDir: 1 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: -1 colDir: 1 for: aPlayer)].			(self axisMoveable: aSquare rowDir: -1 colDir: 0 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: -1 colDir: 0 for: aPlayer)].			(self axisMoveable: aSquare rowDir: -1 colDir: -1 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: -1 colDir: -1 for: aPlayer)].			(self axisMoveable: aSquare rowDir: 0 colDir: -1 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: 0 colDir: -1 for: aPlayer)].			(self axisMoveable: aSquare rowDir: 1 colDir: -1 for: aPlayer) ifTrue: [(self axisFlip: aSquare rowDir: 1 colDir: -1 for: aPlayer)]</body><body package="Reversi">moveOpponent	"We get this message from the view after the controller 	has told it about a left-mouse button click."	self moveAt: opponentMove for: player.	opponentMove := nil.	self switchPlayer</body><body package="Reversi">playAt: aSquare 	"We get this message from the view after the controller 	has told it about a left-mouse button click."	opponentMove ~~ nil ifTrue: [^self moveOpponent].	(self playableAt: aSquare for: player)		ifFalse: [^self].	self moveAt: aSquare.	self switchPlayer</body><body package="Reversi">randomBetween: start and: stop 	"Answer a random float between start and stop."	| num |	num := rand next * (stop - start) abs.	start &lt; stop		ifTrue: [^start + num]		ifFalse: [^stop + num]</body><body package="Reversi">switchPlayer	| msg |	msg := 'Your move...'.	player = self white		ifTrue: [self blackCanMove				ifTrue: [player := self black]				ifFalse: [self whiteCanMove						ifTrue: [msg := 'White moves again...']						ifFalse: [^self gameOver]]]		ifFalse: [self whiteCanMove				ifTrue: [player := self white]				ifFalse: [self blackCanMove						ifTrue: [msg := 'Black moves again...']						ifFalse: [^self gameOver]]].	player = opponent value		ifTrue: [self computerMoveProcess: [self computerMove] fork]		ifFalse: [self messageArea value: msg]</body></methods><methods><class-id>Reversi</class-id> <category>private move testing</category><body package="Reversi">adjacentEmpty: aSquare rowDir: rowDir colDir: colDir 	"Answer true if the adjacent square for a given 	row and column direction is nil."	(colDir = 1 and: [aSquare x = 8])		ifTrue: [^true].	(colDir = -1 and: [aSquare x = 1])		ifTrue: [^true].	(rowDir = 1 and: [aSquare y = 8])		ifTrue: [^true].	(rowDir = -1 and: [aSquare y = 1])		ifTrue: [^true].	^(board atPoint: aSquare + (colDir @ rowDir))		= nil</body><body package="Reversi">adjacentOpponentsAt: aSquare for: aPlayer	"Answer a statistic calculated by adding 1 for every adjacent square that will	flip to an opponent, adding 3 for every empty adjacent square. The lowest value	is the most desirable. This statistic will emphasize internal moves over parimeter moves."	| stat |	stat := 0.		"Check in all eight directions for adjacent opponents."	(self axisMoveable: aSquare rowDir: 1 colDir: 0 for: aPlayer) ifTrue: [stat := stat + 1].		"Down"	(self axisMoveable: aSquare rowDir: 1 colDir: 1 for: aPlayer) ifTrue: [stat := stat + 1].		"Down Right"	(self axisMoveable: aSquare rowDir: 0 colDir: 1 for: aPlayer) ifTrue: [stat := stat + 1].		"Right"	(self axisMoveable: aSquare rowDir: -1 colDir: 1 for: aPlayer) ifTrue: [stat := stat + 1].		"Up Right"	(self axisMoveable: aSquare rowDir: -1 colDir: 0 for: aPlayer) ifTrue: [stat := stat + 1].		"Up"	(self axisMoveable: aSquare rowDir: -1 colDir: -1 for: aPlayer) ifTrue: [stat := stat + 1].		"Up Left"	(self axisMoveable: aSquare rowDir: 0 colDir: -1 for: aPlayer) ifTrue: [stat := stat + 1].		"Left"	(self axisMoveable: aSquare rowDir: 1 colDir: -1 for: aPlayer) ifTrue: [stat := stat + 1].		"Down Left"	"Check in all eight directions for adjacent empty squares."	(self adjacentEmpty: aSquare rowDir: 1 colDir: 0) ifTrue: [stat := stat + 3].		"Down"	(self adjacentEmpty: aSquare rowDir: 1 colDir: 1) ifTrue: [stat := stat + 3].		"Down Right"	(self adjacentEmpty: aSquare rowDir: 0 colDir: 1) ifTrue: [stat := stat + 3].		"Right"	(self adjacentEmpty: aSquare rowDir: -1 colDir: 1) ifTrue: [stat := stat + 3].		"Up Right"	(self adjacentEmpty: aSquare rowDir: -1 colDir: 0) ifTrue: [stat := stat + 3].		"Up"	(self adjacentEmpty: aSquare rowDir: -1 colDir: -1) ifTrue: [stat := stat + 3].	"Up Left"	(self adjacentEmpty: aSquare rowDir: 0 colDir: -1) ifTrue: [stat := stat + 3].		"Left"	(self adjacentEmpty: aSquare rowDir: 1 colDir: -1) ifTrue: [stat := stat + 3].		"Down Left"	^stat</body><body package="Reversi">availableMoves	"Answer a collection of available moves for the current player."	^self availableMovesFor: player</body><body package="Reversi">availableMovesFor: aPlayer	"Answer a collection of available moves for aPlayer."	| moves |	moves := OrderedCollection new.	1 to: 64		do: 			[:ea | 			| pt |			pt := self board pointIndexFor: ea.			(self playableAt: pt for: aPlayer)				ifTrue: [moves add: pt]].	^moves</body><body package="Reversi">axisMoveable: aSquare rowDir: rowDir colDir: colDir for: aPlayer 	"Test for a valid move along one of the eight axis. 	The rules for a valid move in reversi are as follows: 	1. the test square must be empty. 	2. the square adjacent to the test square must contain the opponent. 	3. when opponents stop, the stopper must be aPlayer. 	This describes a 'straddle', which is a valid move."	| row col oppCount opp x |	col := aSquare x.	row := aSquare y.	oppCount := 0.	aPlayer = 1		ifTrue: [opp := 0]		ifFalse: [opp := 1].	x := 1.	[x &lt;= 8]		whileTrue: 			[| curSquare |			row := row + rowDir.			col := col + colDir.			row &lt; 1 | (row &gt; 8) | (col &lt; 1) | (col &gt; 8)				ifTrue: 					["Test for out-of-bounds conditions."					row := row - rowDir.					col := col - colDir.					x := 8].	"What is the next square?"			curSquare := board atPoint: col @ row.			curSquare = opp				ifTrue: ["As long as it is an opponent, keep going."					oppCount := oppCount + 1]				ifFalse: ["If we have counted opponents and this square is me, eureka!"					oppCount &gt; 0 &amp; curSquare = aPlayer						ifTrue: [^true]						ifFalse: [x := 8]].			x := x + 1].	^false</body><body package="Reversi">blackCanMove	^self playerCanMove: self black</body><body package="Reversi">optionsFor: aPlayer at: aSquare 	"We know aSquare is playable. We want to know the results 	of playing aSquare in terms of the number of available moves aPlayer 	will have versus the opponent's."	| stat |	self lookAheadPlayer: self player.	self lookAheadBoard: board copy.	self view controller lookAheadInProgress: true.	self moveAt: aSquare for: aPlayer.	stat := (self availableMovesFor: self player) size - (self availableMovesFor: self opponent) size.	self LACleanUp.	^stat</body><body package="Reversi">playableAt: aSquare for: aPlayer	"Easy check for an empty square."	(board atPoint: aSquare) notNil ifTrue: [^false].	"Check in all eight directions for a valid move."	(self axisMoveable: aSquare rowDir: 1 colDir: 0 for: aPlayer) ifTrue: [^true].		"Down"	(self axisMoveable: aSquare rowDir: 1 colDir: 1 for: aPlayer) ifTrue: [^true].		"Down Right"	(self axisMoveable: aSquare rowDir: 0 colDir: 1 for: aPlayer) ifTrue: [^true].		"Right"	(self axisMoveable: aSquare rowDir: -1 colDir: 1 for: aPlayer) ifTrue: [^true].		"Up Right"	(self axisMoveable: aSquare rowDir: -1 colDir: 0 for: aPlayer) ifTrue: [^true].		"Up"	(self axisMoveable: aSquare rowDir: -1 colDir: -1 for: aPlayer) ifTrue: [^true].	"Up Left"	(self axisMoveable: aSquare rowDir: 0 colDir: -1 for: aPlayer) ifTrue: [^true].		"Left"	(self axisMoveable: aSquare rowDir: 1 colDir: -1 for: aPlayer) ifTrue: [^true].		"Down Left"	^false</body><body package="Reversi">playerCanMove: aPlayer 	1 to: 64 do: [:ea | (self playableAt: (self board pointIndexFor: ea)			for: aPlayer)			ifTrue: [^true]].	^false</body><body package="Reversi">remainingMoves	"Answer the number of unoccupied squares."	^(self board asOrderedCollection select: [:sq | sq isInteger not]) size</body><body package="Reversi">whiteCanMove	^self playerCanMove: self white</body></methods><methods><class-id>Reversi</class-id> <category>accessing</category><body package="Reversi">animation	"Answer the value of animation."	^animation</body><body package="Reversi">board	"Answer the value of board."	^board</body><body package="Reversi">board: aBoard 	"Set the value of board."	board := aBoard</body><body package="Reversi">computerMoveProcess	"Answer the value of computerMoveProcess."	^computerMoveProcess</body><body package="Reversi">computerMoveProcess: aProcess 	"Set the value of computerMoveProcess."	computerMoveProcess := aProcess</body><body package="Reversi">lookAheadBoard	"Answer the value of lookAheadBoard."	^lookAheadBoard</body><body package="Reversi">lookAheadBoard: aBoard 	"Set the value of lookAheadBoard."	lookAheadBoard := aBoard</body><body package="Reversi">lookAheadPlayer	"Answer the currentPlayer who is getting look ahead analysis."	^lookAheadPlayer</body><body package="Reversi">lookAheadPlayer: aValue 	"Set the value of lookAheadPlayer."	lookAheadPlayer := aValue</body><body package="Reversi">lookAheadRatio	"Answer the value of lookAheadRatio."	^lookAheadRatio</body><body package="Reversi">lookAheadThreshold	"Answer the value of lookAheadThreshold."	^lookAheadThreshold</body><body package="Reversi">lookAheadThreshold: aValue 	"Set the value of lookAheadThreshold."	| val |	val := aValue asNumber.	val &gt; 25 ifTrue: [val := 25].	val &lt; 5 ifTrue: [val := 5].	lookAheadThreshold := val</body><body package="Reversi">messageArea	"Answer the value of messageArea."	^messageArea</body><body package="Reversi">opponent	"Answer the value of opponent."	player = 1		ifTrue: [^0]		ifFalse: [^1]</body><body package="Reversi">opponentMove	"Answer the value of opponentMove."	^opponentMove</body><body package="Reversi">playLevel	"Answer the value of playLevel."	^playLevel</body><body package="Reversi">player	"Answer the value of player."	^player</body><body package="Reversi">score	"Answer the value of score."	| w b |	w := b := 0.	self board		do: 			[:ea | 			ea = self white ifTrue: [w := w + 1].			ea = self black ifTrue: [b := b + 1]].	^w @ b</body><body package="Reversi">valueBoard	"Answer the value of valueBoard."	^valueBoard</body><body package="Reversi">view	"Answer the value of view."	^view</body><body package="Reversi">windowTitle	"Answer the value of windowTitle."	^'Reversi'</body></methods><methods><class-id>Reversi</class-id> <category>constants</category><body package="Reversi">aBoard	^TwoDList columns: 8 rows: 8</body><body package="Reversi">black	^0</body><body package="Reversi">computerMoveMsg	^'Here''s my move.  Click for me.'</body><body package="Reversi">noChance	^'I''m gonna clean your clock.  Click for me.'</body><body package="Reversi">stillAChance	^'You still have a chance.  Click for me.'</body><body package="Reversi">valueArray	"	|_99_|_1__|_25_|_20_|_20_|_25_|_1__|_99_| 	|_1__|_1__|_20_|_25_|_25_|_20_|_1__|_1__| 	|_25_|_20_|_35_|_30_|_30_|_35_|_20_|_25_| 	|_20_|_25_|_30_|_W_|_B__|_30_|_25_|_20_| 	|_20_|_25_|_30_|_B__|_W_|_30_|_25_|_20_| 	|_25_|_20_|_35_|_30_|_30_|_35_|_20_|_25_| 	|_1__|_1__|_20_|_25_|_25_|_20_|_1__|_1__| 	|_99_|_1__|_25_|_20_|_20_|_25_|_1__|_99_|"	^#(99 1 25 20 20 25 1 99 1 1 20 25 25 20 1 1 25 20 35 30 30 35 20 25 20 25 30 0 0 30 25 20 20 25 30 0 0 30 25 20 25 20 35 30 30 35 20 25 1 1 20 25 25 20 1 1 99 1 25 20 20 25 1 99)</body><body package="Reversi">white	^1</body><body package="Reversi">xvalueArray	" This array puts more emphasis on the edge - 	a strategy that may not be the best as statistics	show that the first one to take the edge usually	loses - but this game may not be smart enough	to take advantage of that.	|_99_|_1__|_35_|_30_|_30_|_35_|_1__|_99_| 	|_1__|_1__|_20_|_25_|_25_|_20_|_1__|_1__| 	|_35_|_20_|_35_|_30_|_30_|_35_|_20_|_35_| 	|_30_|_25_|_30_|_W_|_B__|_30_|_25_|_30_| 	|_30_|_25_|_30_|_B__|_W_|_30_|_25_|_30_| 	|_35_|_20_|_35_|_30_|_30_|_35_|_20_|_35_| 	|_1__|_1__|_20_|_25_|_25_|_20_|_1__|_1__| 	|_99_|_1__|_35_|_30_|_30_|_35_|_1__|_99_|"	^#(99 1 35 30 30 35 1 99 1 1 20 25 25 20 1 1 35 20 35 30 30 35 20 35 30 25 30 0 0 30 25 30 30 25 30 0 0 30 25 30 35 20 35 30 30 35 20 35 1 1 20 25 25 20 1 1 99 1 35 30 30 35 1 99)</body></methods><methods><class-id>Reversi</class-id> <category>look ahead</category><body package="Reversi">LABoards	| brdLA |	brdLA := OrderedCollection new.	self lookAheadThreshold + 1 timesRepeat: [brdLA addLast: self aBoard].	brdLA at: 1 put: board copy.	^brdLA</body><body package="Reversi">LACleanUp	self view controller lookAheadInProgress: false.	self LAProgressClear.	lookAheadMove := nil.	player := self lookAheadPlayer.	self lookAheadPlayer: nil.	board := self lookAheadBoard.	self lookAheadBoard: nil</body><body package="Reversi">LAProgressAt: anIndex 	"Ask our view to display a uniquely colored piece in the 	square that is being analyzed. Save the square coordinate 	as the lookAheadMove in case it is a winner."	self LAProgressClear. 	lookAheadMove := board pointIndexFor: anIndex.	self lookAheadBoard at: anIndex put: 4.	self view displaySquareAt: anIndex.	self board at: anIndex put: self lookAheadPlayer</body><body package="Reversi">LAProgressClear	"Clear the progress indicator."	lookAheadMove ~~ nil		ifTrue: 			[self lookAheadBoard at: lookAheadMove put: 2.			self view displaySquareAt: (board integerIndexFor: lookAheadMove).			self lookAheadBoard at: lookAheadMove put: nil.			lookAheadMoves at: (Fraction numerator: lookAheadRatio x denominator: (lookAheadRatio y max: 1))				put: lookAheadMove.			lookAheadRatio := 0 @ 0]</body><body package="Reversi">LAScore	"Calculate the score for a played look-ahead game.	Yield the processor to other tasks to give a smoothness	to the multitasking.  This method will be called many	time per second."	| w b |	Processor yield.	w := b := 0.	self board		do: 			[:ea | 			ea = self white ifTrue: [w := w + 1].			ea = self black ifTrue: [b := b + 1]].	^w @ b</body><body package="Reversi">LASwitchPlayer	"Just switch the player value."	player = self white		ifTrue: [player := self black]		ifFalse: [player := self white]</body><body package="Reversi">accumulateWinLossRatio: score 	| ratioChange |	score x &gt; score y		ifTrue: [ratioChange := 1 @ 0]		ifFalse: [score y &gt; score x				ifTrue: [ratioChange := 0 @ 1]				ifFalse: [ratioChange := 1 @ 1]].	self lookAheadPlayer = self black ifTrue: [ratioChange := ratioChange transpose].	lookAheadRatio := lookAheadRatio + ratioChange.	InputState default shiftDown ifTrue: [self messageArea value: 'Searching... (' , (lookAheadRatio x + lookAheadRatio y) printString , ') games analyzed']</body><body package="Reversi">comments	"The purpose of this look ahead logic is to determine if a move	can guarantee a win. A guaranteed win will result if, no matter which	way the opponent moves, a way can be found to win. The possible games	are played out with each move being stored on a seperate board. If	there are 12 spaces left on the board, 12 boards will be used to play	out (if necessary) all possible remaining games. As soon as a guaranteed	win is found, that move is chosen. The move may not result in the most	lopsided margin of victory, but a win is a win even if only by one point. 	Here are the logical steps:	1) Mark all of the moves the computer can make on the top level board.	 2) Copy the board down 1 level. Take the first marked move, and		  erase the marked move from the previous level.	3) Mark all of the moves the opponent can respond with at this level.		  Repeat steps 2 - 3 until a game is played out.	4) If the game is won, go back to the closest level that contains		  the next opponent move and play out the next marked response		  by repeating steps 2 - 4.  If you make it back to the top level,		  without losing a game, the top level move was a guaranteed winner!		  If the game is lost, go back to the closest level that contains		  the next computer move and continue by repeating steps 2 - 4."</body><body package="Reversi">findAvailableMoves	"Mark all possibleMoves on the current look-ahead board 	with 'W's and B's. If this is the top level, capture all of the 	top-level moves. Capture the player at this level as well."	| playable |	playable := false.	board := lookAheadBoards at: lookAheadLevel.	self board keysAndValuesDo: [:x :v | v == #W | (v == #B) ifTrue: [self board at: x put: nil]].	1 to: 64		do: 			[:ea | 			| pt |			pt := self board pointIndexFor: ea.			(self playableAt: pt for: player)				ifTrue: 					[playable := true.					player = self white						ifTrue: [board at: pt put: #W]						ifFalse: [board at: pt put: #B]]].	playable ifTrue: [lookAheadPlayers at: lookAheadLevel put: player].	^playable</body><body package="Reversi">interrupt	"The Escape key has been pressed indicating the user wants 	the look-ahead to abort and the computer to makes its move."	self lookAheadBoard ~~ nil		ifTrue: 			[self computerMoveProcess terminate.			self LACleanUp.			self board keysAndValuesDo: [:x :v | v ~~ 0 &amp; (v ~~ 1) ifTrue: [self board at: x put: nil]]. 			self playLevel value: #intermediate.			self computerMove.			self playLevel value: #expert]		ifFalse: [self closeRequest]</body><body package="Reversi">lookAhead	"See comments method for detailed explaination."	| result direction | 	self lookAheadPlayer: self player.	lookAheadLevel := 1.	lookAheadRatio := 0 @ 0.	lookAheadBoards := self LABoards.	lookAheadMoves := Dictionary new.	lookAheadPlayers := Array new: lookAheadBoards size.	self findAvailableMoves ifFalse: [^nil].	[true]		whileTrue: 			[self findAvailableMoves				ifTrue: 					[direction := #FORWARD.					self takeFirstMove]				ifFalse: 					[self LASwitchPlayer.					self findAvailableMoves						ifTrue: 							[direction := #FORWARD.							self takeFirstMove]						ifFalse: 							[direction := #BACKWARD.							result := self prevGameLevel.							result = #WINNER ifTrue: [^lookAheadMove].							result == #LOSER ifTrue: [^#LOSER]]].			direction = #FORWARD				ifTrue: [self LASwitchPlayer]				ifFalse: 					[(lookAheadPlayers at: lookAheadLevel)						~~ player ifTrue: [self LASwitchPlayer].					self takeFirstMove.					self LASwitchPlayer]]</body><body package="Reversi">prevGameLevel	"Move back up to the previous level to play out the next possible game. 	The level to move up to is determined by who won the game. If I win, 	I don't need to analyze my other options, but I need to analyze my 	opponents options. If I lose, I need to see if my other options might 	result in a win for me. 		The PlayerAtLevel array stores the type of marked move(s) for every 	level. As soon as all of the marked moves at a level have been unmarked, 	the PlayerAtLevel indicator is unmarked (in #takeFirstMove). 	As soon as the analysis has percolated back up to the top, either 	we have a winner, or, if all plays have been tested, no winner. 	A winner is determined if the opponent has no more options and the 	CurrentPlayer is ahead."	| score |	score := self LAScore.	self accumulateWinLossRatio: score.	(score x &gt; score y or: ["White won OR tie and CurrentPlayer is Black"		self lookAheadPlayer = self black &amp; (score x = score y)])		ifTrue: 			["Find previous Black move level."			[lookAheadLevel &gt; 1]				whileTrue: 					[lookAheadLevel := lookAheadLevel - 1.					(lookAheadPlayers at: lookAheadLevel)						= self black ifTrue: [^nil]].			self lookAheadPlayer = self white				ifTrue: ["No more black moves to try -- 					maybe we have a winner if lookAheadPlayer is white."					^#WINNER]				ifFalse: [^#LOSER]].	(score y &gt; score x or: ["Black won OR tie and CurrentPlayer is White"		self lookAheadPlayer = self white &amp; (score x = score y)])		ifTrue: 			["Find previous White move level."			[lookAheadLevel &gt; 1]				whileTrue: 					[lookAheadLevel := lookAheadLevel - 1.					(lookAheadPlayers at: lookAheadLevel)						= self white ifTrue: [^nil]].			self lookAheadPlayer = self black				ifTrue: ["No more white moves to try -- 					maybe we have a winner if lookAheadPlayer is black."					^#WINNER]				ifFalse: [^#LOSER]]</body><body package="Reversi">randomizeBoard	"For look ahead testing to create an almost-done game."	| r |	r := Random new.	1 to: 64 do: [:x | self board at: x put: r next rounded].	[self remainingMoves &lt; 17]		whileTrue: [self board at: (Random from: 1 to: 64) truncated put: nil]</body><body package="Reversi">takeFirstMove	"Copy one level down to the next and take the first available move. 	If there are no more available moves go to a previous level to play 	out more games."	| firstMoveFound |	firstMoveFound := false.	lookAheadLevel := lookAheadLevel + 1.	lookAheadBoards at: lookAheadLevel put: (lookAheadBoards at: lookAheadLevel - 1) copy.	board := lookAheadBoards at: lookAheadLevel.	board keysAndValuesDo: [:index :sq | sq = #W | (sq = #B) ifTrue: [firstMoveFound				ifTrue: [^self]				ifFalse: 					["unmark move"					firstMoveFound := true.					sq = #W						ifTrue: [player := self white]						ifFalse: [player := self black].					(lookAheadBoards at: lookAheadLevel - 1)						at: index put: nil.					self moveAt: (board pointIndexFor: index).					lookAheadLevel = 2 ifTrue: [self LAProgressAt: index]]]].	lookAheadPlayers at: lookAheadLevel - 1 put: nil</body></methods><methods><class-id>Reversi</class-id> <category>private about</category><body package="Reversi">about	"Display a pop-up window with basic game rules scrolling by. 	Close the about window about 3 seconds after the scrolling stops 	unless the user closes it first."	| bg win text gc |	bg := self splashScreenImage.	win := self class				popUpWith: bg				backgroundColor: nil				at: #window.	text := 'The rules are simple.  White moves first and the moves alternate between players.  A player must move as long as he has at least one legal move, else he passes.  A legal move consists of any move that "flips" at least one of the opposing pieces.  An opposing piece is flipped if it stands between (either alone or with a line of other opposing pieces and either vertically, horizontally, or diagonally) the piece just played and another piece of the same color as that just played.  When a piece is flipped, it becomes the opposite color to what it was prior to flipping. The game ends when neither player has a legal move.  The winner of the game is the player with the most pieces of his color at the end of the game.' asText emphasizeAllWith: #color -&gt; ColorValue navy.	text := text asComposedText compositionWidth: 235.	1 to: text height - 100		do: 			[:x | 			| pm |			win sensor isActive ifFalse: [^win close].			pm := Pixmap extent: bg extent.			gc := pm graphicsContext.			gc display: bg at: 0 @ 0.			gc clippingRectangle: (80 @ 45 extent: text width @ 200).			gc display: text at: 80 @ (45 - x).			win graphicsContext display: pm at: 5 @ 5.			(Delay forMilliseconds: (x = 1					ifTrue: [2000]					ifFalse: [60])) wait].	1 to: 100		do: 			[:x | 			win sensor isActive ifFalse: [^win close].			(Delay forMilliseconds: 30) wait].	win close</body><body package="Reversi">splashScreenImage	"Display a splash screen for the IMT. 	Build up an image by layering components on a PixMap. 	Pop-up a window with the contructed image as the content."	"self splashScreen"	| gc extent text bg stucco |	CharacterAttributes allInstances do: [:ea | ea at: #size put: [:query :size | query pixelSize: size]].	stucco := self stucco.	extent := stucco extent * (3 @ 4).	bg := Pixmap extent: extent.	gc := bg graphicsContext.	0 to: 2 do: [:x | gc display: stucco at: stucco width * x @ 0].	0 to: 2 do: [:x | gc display: stucco at: stucco width * x @ 50].	0 to: 2 do: [:x | gc display: stucco at: stucco width * x @ 100].	0 to: 2 do: [:x | gc display: stucco at: stucco width * x @ 150].	gc display: self class colorIcon at: 5 @ 5.	gc display: self class colorIcon at: 345 @ 5.	text := 'Reversi' asText emphasizeAllWith: (Array with: (#size -&gt; 40) with: (#color -&gt; ColorValue black)).	gc display: text at: 130 @ 35.	gc display: text at: 131 @ 34.	text emphasizeAllWith: (Array with: (#size -&gt; 40) with: (#color -&gt; ColorValue blue)).	gc display: text at: 132 @ 33.	^bg</body><body package="Reversi">stucco	^Image		extent: 128 @ 50		depth: 3		bitsPerPixel: 4		palette: (MappedPalette withColors: self stuccoPalette)		usingBits: (ByteArray fromPackedString: 'UBP$UEQTUETUMUQTDDUTETUDIEQTMET$UQUEUEUTUEQUPATPQUQUQEUDIQTPMAP4MEURMEPPEUTTUSQTUBTTMTUDQEQTUTUEUTUCQPEUH%QUUTQTQEDA@UUTQTUCQEQTTPDQ@UT"PUIDUUEU@TICPPDAT4EUUEQDT$EQ@PUEUTUEUTUEQTUEQUQTUETUMCPUQTQTUBQPEQDTUBQDIEUEQT@PDDUTL%UDUQTPUEP4UCTUUTP5QEP$IDQUUQ@UQQP$UDUEUUQTUUEUQEPAT2UBUEUCQTUETUIQT$QTUTQEQUQUP4UEP#ITUTUE@UUBL$QUUEQBITIEQDMTUDMTUDTEH5P4UATUUEQUQBQUERL%EEQUUCP4UQUDQSQUETUUQTUTUBITT#H5DAUTMTUTP"PPEUUUQCUDUUTPDDP$UBP5ERQEP"IBQTUEQEUCQET"PPUETUQEQUUBP5ESQTMEQEPAUTQBQTH2PPQTP4EUH"IEUUDAAEQQAUET@PEETPETU@ECQTQTUCQTMCQEQUQTMADTMAATMETUUDQUETP"UEUEDDP$QAT4IETTIBH%QBH"QTU@QQUEQQTPQTAEH%@PDA@PUEEUQUEUUTMBQTQTUTTAT4IQQTUQADMUQ@UDP$UEQUUEP4MQTUDDT$ETTUMEQEUT@TMCQDIBQTUQARMQUUUTUDQPQETPQQUTEEP$QQUDUEQDUSQUEUP4ERTUITUEQUQTUDQTMTU@EEQUUQ@TUEU@DAT"MBP2UEUUQQP$ESQTUUP$PUIETUMQP5UEP4UUP"IDUTUCQEMCP0ED@UDAQUQTP4MBQEUCQEIA@UQUT4UETQEUP4EUP5DATTICQUQEUEQEH2QDQUP"URIUUQUEMEP4UUP5EBUDUDTPMAAEESTPQBQDT"PUUBTTMTUUQTP4UQDPQEQPEQU@QSP"UTUTMTUUQBQTT$EEP5ECTUDETUUQTPESPPUAUTUQDTITP$H%@UUDUTUEUUDAAEESQTQUQPDQUTIETPMQ@PQUP5DAQUETUDUEDAP$IDTUIAT$QETTUBTUQEUDTDQTTAP"UCQTMAADUTUEUTUUDAUPEEP%ECTQDDUDUETTMUTUEQTPQRPPUEP$U@UBITMCUDLAQTIDT$UET4MTP%EBQEESH4QQTUIEP$EU@UDAUUUUQTIAQUUADUQTUTUEUUESP4IETUUEUTUEQTTUUETPETUEDEQRIDU@DAP$ESTPMEP$UCQTUSTUUEH%QQAEPAUEUCQTMUTUMQT$QTUEQTUUECP4MBQUEEQTUEQTDUUQ@UUEQUEBH4UQ@PQTQ@EQDTUUP$UEP$ESTUQSPPUUP4UTTUQEUEETADMUH4UEQUDAT4IA@PESQTIEP$QUUQUDUUUTUUP%QBTUUTUEUBQ@PAUUEQTUUEQUEET4ESTTUEP5UBQTIAUUUQUEEBQUUEQUQUP4UQTPEQUTQTQPEQUCP$UCQUEQQTH!@TUBQEQCTPQUQUQT@UUQUUIAP EET4UDTUQEUDUUQTMSQTUDTUMDUEQTPUMBP4MQUEUETUUUIDQTUDUTICPTIUT4EUUTUQDUUEQTMEUEQUPTHATTIAT4IDUEQEP4QCQUEUP"ITTTIEQUQBTTMEUDMUUEQUQTUBUEQTIAQTL"UTDDP%EQUTUQUTUBH4UTUTUBTPDAT2LAQDMCP5UEP$UUUEEQP4ERT2UEQTUCQTQQUUEUQUEBP4T5T"QDIBITUQT0ETQUMEQTUCP4P"QDUEQTUD@UUEH$DBQTUTTUMQQUEEP4MBIUEQT5QSQTMEP$QUQPEEQUUAP4TUIETTUBQUDQTPQUTUICQTMDP$IDUTUUQTUEP2IBPQEEQTEUTUQUQTH#P$MBQUQQTPEBQDUQP5QTUDIEQTUUQQ@TEUAEEEU@EUTUQT@TESQTUTTUQTP$EUQTUBP5ET@PQTP%ETAEQTQTIATPEEUUMCTPETP"UUQEQUP4UCQTUCUCP$UAT$UAAEUBQEUEP%EEUEQT@UQUQ@UEP4UA@PDAATQBQEMAUTUBPTUT@UPATTMET5QEP$MCQ@ESPUUEQUQQIDP4MTQELAUEP"QDUEQTH%QTTAATUE@UUCH4UQUTUTT"MAUTITP$UCUTTAT$DEUTQQUUMDTUQUTUUC@UUEQTUUQQUUQSTUDEQTIEP$UEUDIEUUETQTUADTL#QTUUP4QQT4IEQTDEQTQQT$DAP0ECP5TDTEUTADUTUUUQADMEQTTUUTTPEUUUEBQDQTQTUQUDUQUTIEQTIQT#IDUUQBH%QQTUUEUUETUTUQQUUBPUMDTUERQUEQT%EUTPDAT2MEP4QTDE@PEQUUMDT4UEUTUTUUPAUDMBQEDDP4PA@PUDTPURPUUQT4UDQTICPUMEP2IAUUETUDIQPPQT@TIEP4QSQSP0ETT4IQUTPAP4MQUUUEQ@DEP4EUU@EUQUDA@TIQ@UESUUEUQDICQDUCUTQSQTITP%QEP4URTUUQ@4QUQUETUCTPUTP4MEP4ESQEDDTUUCTPECH0EQUTIDU@QUQTQUQPEQAEUCQUQBP$QQT5EUTUQUTUICQUECUEQQP5EUQPEQQQ@UEUPUUUH$H"U@QTAEUDT4H"PPUCP2UTTPQBQEQCPUMQUTUT@PQQQUPATPEQUUEQ@TMETUMDUTICQEQETPMTUEP4UCTPEBPUUA@UTAQTQUH$QQ@TUEP$UE@UUCQTH"@TMEQUDA@UQUQ@DEUTIEP5QUUTDAATTAUDUCP4IETUUEMCP2H#UEQE@UPA@UESQTUCPPQUP$QTTUUDUTUEUDUQ@2MDUEQTT4QBTQETP$QBQDMTP%DAUUDEUDUTQTQTUE@TIEP4UEP$UQT4QRQTH"QTL%@UH"H$UE@UQUQTUAAUDQP4MUP"IDP$UQDUUEQEUDUUEUP5UTUDUDP$DEUEUEUUUDDAUDMAUEESH%EEP"UDT2MQADUEPUUQATUEQTIQU@EUQTEUH4UTQUDAADIETUUQU@ETTUUTT4UEH0EEQTIDUUP%PAURIUQUUCPPUQP$QQP5DQUUDDATQTQUQUQTQUQDIDUPESPPEUU@QUP"QUUTQUQUQUTUUDP4H#TUH%TUEUETQPERH$ESP4H%@UUTQTIUTQDDU@DAT%UCQTUUQUERH2TA@UT"QTUEPUUEP%EEP5QTP$QBQDIEQDIADTMTAEUEQUPPECIUEQTTMQAEQUQTQTTUUEQUQQTUUEUUEUQUEBP%DQT4H%P$UBUEQTPUH#QEQUQET#UTUCPUTAP$EQUTUTUCQTH"QTIEUTDAUTUEQUDEUDUEQUQUTUUQUEQTP5QQTQEBIDMTTPQEUTUCUDIEUEQBQDIAUTUBQEERITIEUEQDH2P4UEQTMCP5UUP"H#QPESP$UEUEUEUTQTUEUCQTUQ@UL#UEDA@TIAUTQTUTEUQTUDT"LAUTUEP$T#QTUEQUT4MEQUQETUUQUEUEQTICTPQEP4UEQTUEQTMEUDH%QTUCUDIDU@QTT4QUP$UEQUQUUTUQQUDDP5EUQUIEUEUEQQPPDA@UMQDPDQ@PQTTTDADUUAUTUEQTUCP"UTQRIEQUMD@UUETTMUQEUEPUUEUUQQP4UCPQESQUQQ@UDA@UUCUBTUUQUTPAUUEUTUUUP%DAADIQUTUEQRH$P5EBP2UUTTMQDTUET4EUQEQUUDUA@UUBITH2TUUDUUQQ@PDAT4UBL%UTUSH$QUP$UEUTEBIEUTP"UUQTH"H#ITQUIDP%DAT4DQ@4UEQUQBQUESP4IEQTL"QRMQT"MAUEMUUUUTP5P$MQP"UCQUQTQUUEP5UC@TUTQUEBQDL"P5ESTPDAPQEBH%DAP4UEUTMEUTUEUDUBH$QQT$DEH$IBPUQTQRICPPTPDDP$UETPEUTUUCIUQQT$QUUEUDUTUATQEQ@UERTUH%PPUBIUQTQEDAT$MAUPECQ@DAQPEBPUEBUDUCP4QUUADPETQEQEUUQCUEUCTUQQP4QTQTUDQUPD@UUUP$L%UTMEQUQBQEQSQUDATUMTTPUA@TITTPMAA@EQT4MCQPEEPQUUUBQTIQUEUEQTUDUTIBIUQBQTIBQ@ETT4QCQDIAUDUBPPEUQTT"P5UT@UERPTMUP"QUTTMUQ@QTQTQQ@UMBDDUEQETPDEQTUEQTUTUDUCTUL#UEQETPUEH$MEQRIUP4UE@PECH"IATUUEUUEBT4QSH%ECQUEBTTH"QUPAADQPUEQUQQ@PEEQTUEUTUDUTUAADUQTUUEURH"QEUCP4ESQEQTT4H2P4MT@UUEQUUAT5EEQTH2UTUA@"IDUUDDP4Tb')</body><body package="Reversi">stuccoPalette	"Answer an array of 6 random colors. Because Random 	often produces similar results make sure each element 	is at least 0.05 different from its neighbor."	| array |	array := Array new: 6.	array at: 1 put: (self randomBetween: 0.7 and: 0.99).	2 to: 6		do: 			[:i | 			array at: i put: (self randomBetween: 0.7 and: 0.99).			[((array at: i)				- (array at: i - 1)) abs &lt; 0.05]				whileTrue: [array at: i put: (self randomBetween: 0.7 and: 0.99)]].	^array collect: [:ea | ColorValue brightness: ea]</body></methods><methods><class-id>Reversi</class-id> <category>competition</category><body package="Reversi">beginner	"Move is random."	| moves |	moves := self availableMoves.	opponentMove := moves at: (self randomBetween: 1 and: moves size) rounded.	board at: opponentMove put: 3</body><body package="Reversi">expert	"Utilize a brute force look ahead scheme to determine if 	there is a winning move. If not, use the move with the best 	win/lose ratio. Give our view a copy of the board to use if a 	repaint is needed before the look ahead is complete. 	Otherwise the current state of the look ahead will get painted."	self remainingMoves &gt; self lookAheadThreshold ifTrue: [^self intermediate].	self lookAheadBoard: board copy.	self view controller lookAheadInProgress: true.	opponentMove := self lookAhead.	self LACleanUp.	opponentMove = #LOSER		ifTrue: 			[self messageArea value: self stillAChance.			opponentMove := lookAheadMoves at: lookAheadMoves keys asSortedCollection last]		ifFalse: [self messageArea value: self noChance].	board at: opponentMove put: 3</body><body package="Reversi">expertLevel	self playLevel value: #expert.	self builder = nil ifTrue: [^self].	self lookAheadThreshold: (Dialog request: 'Enter the number of moves to look ahead.  ( 5 to: 25 )' initialAnswer: self lookAheadThreshold)</body><body package="Reversi">intermediate	"Move is position-value based stategy with run-time adjustments. 	The basic sqaure value is adjusted for an adjacent opponents statistic 	as well as maximized options for the player and minimized options for 	the opponent."	| moves values highMoves |	moves := self availableMoves.	values := SortedCollection withAll: (moves					collect: 						[:ea | 						| bv ao op |						bv := valueBoard atPoint: ea.						self playLevel value == #expert							ifTrue: 								[ao := self adjacentOpponentsAt: ea value for: player.								op := self optionsFor: self player at: ea]							ifFalse: [ao := op := 0].						bv - ao + op -&gt; ea]).	values sortBlock: [:a :b | a key &gt; b key].	highMoves := OrderedCollection new.	values reverseDo: [:ea | ea key = values first key ifTrue: [highMoves add: ea]].	opponentMove := (highMoves at: (self randomBetween: 1 and: highMoves size) rounded) value.	board at: opponentMove value put: 3</body></methods><methods><class-id>Reversi</class-id> <category>private debugging</category><body package="Reversi">debugMethod: aString 	"Invoke this message to output logical state information to a 	debug.txt file that can be analyzed for look-ahead logic errors."	debug ~~ nil		ifTrue: 			[debug cr; nextPutAll: aString tab; nextPutAll: 'Player: ' , player asString.			debug cr.			lookAheadPlayers printOn: debug.			debug cr.			lookAheadMoves printOn: debug.			debug tab.			lookAheadRatio printOn: debug.			lookAheadLevel &gt; 1 ifTrue: [debug cr; nextPutAll: 'Level ' , (lookAheadLevel - 1) asString; cr; nextPutAll: (lookAheadBoards at: lookAheadLevel - 1) asString].			debug cr; nextPutAll: 'Level ' , lookAheadLevel asString; cr; nextPutAll: (lookAheadBoards at: lookAheadLevel) asString]</body><body package="Reversi">testBoard	"Inset a line in initailizeBoard to call this method	to set up a debugging environment for logic testing."	debug := (Filename named: 'debug.txt') writeStream.	debug nextPutAll: Timestamp now asString.	self board setCollection: #(nil nil 0 1 nil 0 nil 1   nil nil nil 1 1 1 1 1   nil nil 0 1 0 0 0 1   nil 0 0 1 1 0 0 1   0 0 0 1 1 0 0 1   0 0 1 1 1 0 nil 1    nil 1 1 1 1 0 nil 1   0 0 0 0 0 0 nil nil) copy	columns: 8	rows: 8</body></methods><methods><class-id>Reversi</class-id> <category>initialize-release</category><body package="Reversi">changeRequest	Cursor normal beCursor.	^true</body><body package="Reversi">closeRequest	self computerMoveProcess ~~ nil ifTrue: [self computerMoveProcess terminate].	debug ~~ nil ifTrue: [debug close].	^super closeRequest</body><body package="Reversi">initialize	self computerMoveProcess ~~ nil ifTrue: [self computerMoveProcess terminate].	self view ~~ nil ifTrue: [self view controller lookAheadInProgress: false].	self lookAheadPlayer: nil.	self lookAheadBoard: nil.	player := nil.	opponent := #computer -&gt; self black.	opponentMove := nil.	board := self aBoard.	self initializeBoard.	self lookAheadThreshold: '15'.	valueBoard := TwoDList				on: self valueArray				columns: 8				rows: 8.	view = nil		ifTrue: 			[view := ReversiView new.			view model: self].	messageArea = nil ifTrue: [messageArea := String new asValue].	playLevel = nil		ifTrue: 			[playLevel := #expert asValue.			self view controller expert].	animation = nil ifTrue: [animation := false asValue].	self switchPlayer.	rand := Random new.</body><body package="Reversi">initializeBoard	self board atPoint: 4 @ 4 put: 1.	self board atPoint: 4 @ 5 put: 0.	self board atPoint: 5 @ 4 put: 0.	self board atPoint: 5 @ 5 put: 1</body><body package="Reversi">newGame	self initialize.	(self builder componentAt: #view) widget invalidate</body><body package="Reversi">postBuildWith: aBuilder 	"Give the message are an inset border for a sculpted look."	super postBuildWith: aBuilder.	"(aBuilder componentAt: #messageArea) component border: BeveledBorder inset1."	aBuilder window icon: (Icon image: self class icon)</body><body package="Reversi">postOpenWith: aBuilder 	self messageArea value: 'Click the mouse to start.'.	self view splashScreen.	self messageArea value: 'Your move...'</body></methods><methods><class-id>Reversi class</class-id> <category>popup utility</category><body package="Reversi">popUpSize: aRect backgroundColor: aColor	"Display a pop-up window sized to aRect with a given backgroundColor"	| win gc displayRect color lp |	lp := LookPreferences defaultForWindows.	color := lp backgroundColor.	aColor isNil ifFalse: [color := aColor].	win := Window				openNewIn: aRect				withType: #popUp				backgroundColor: color.	displayRect := 0@0 extent: aRect extent.	gc := win graphicsContext.	color ~= ColorValue white ifTrue: ["This code produces the border which, on some platforms, will take on 		a 3-D sculpted effect. This should only be used if the backgroundColor 		matches the LookPreferences - otherwise use a plain black border."		1 to: 4			do: 				[:count | 				| borderRect |				borderRect := displayRect insetBy: count.				gc paint: color asHiliteColor.				gc displayLineFrom: borderRect bottomLeft to: borderRect topLeft.				gc displayLineFrom: borderRect topLeft to: borderRect topRight.				gc paint: color asShadowColor.				gc displayLineFrom: borderRect bottomLeft to: borderRect bottomRight.				gc displayLineFrom: borderRect bottomRight to: borderRect topRight]].	gc paint: ColorValue black.	gc displayRectangularBorder: (0 @ 0 extent: displayRect extent - 1).	^win</body><body package="Reversi">popUpWith: anObj backgroundColor: aColor at: aValue 	"Display a pop-up window sized to accomodate anObj 	with a given backgroundColor positioned at aValue."	"self popUpWith: Image fromUser backgroundColor: nil at: #center"	| win rect gc origin extent |	extent := anObj preferredBounds extent + 10.	aValue == #cursor ifTrue: [origin := WindowSensor cursorPoint].	aValue == #window ifTrue: [Window currentWindow = nil			ifTrue: [origin := WindowSensor cursorPoint]			ifFalse: [origin := Window currentWindow displayBox center - (extent / 2) rounded]].	aValue == #center | (aValue = nil) ifTrue: [origin := Screen default bounds center - (extent / 2) rounded].	aValue class == Rectangle ifTrue: [origin := aValue origin].	aValue class == Point ifTrue: [origin := aValue].	rect := origin extent: extent.	win := self popUpSize: rect backgroundColor: aColor.	gc := win graphicsContext.	gc display: anObj at: 5 @ 5.	^win</body></methods><methods><class-id>ReversiView</class-id> <category>displaying</category><body package="Reversi">display3DPieceOn: gc in: aRect direction: anInteger 	| rect thickness topColor bottomColor oldColor |	self first: false.	rect := aRect moveBy: 0 @ 1.	thickness := (aRect width / ((aRect height max: 1)					/ 2)) rounded * aRect height / 18 max: 2.	oldColor := gc paint.	topColor := gc paint.	topColor = ColorValue darkGreen		ifTrue: [bottomColor := topColor]		ifFalse: [topColor = ColorValue black				ifTrue: [bottomColor := ColorValue white]				ifFalse: [bottomColor := ColorValue black]].	gc paint: bottomColor.	thickness - 1		timesRepeat: 			[rect := rect moveBy: 0 @ anInteger.			gc				displayWedgeBoundedBy: rect				startAngle: 0				sweepAngle: 360].	gc paint: topColor.	thickness		timesRepeat: 			[rect := rect moveBy: 0 @ anInteger.			gc				displayWedgeBoundedBy: rect				startAngle: 0				sweepAngle: 360].	gc paint: ColorValue gray.	gc		displayArcBoundedBy: rect		startAngle: 0		sweepAngle: 360.	gc paint: oldColor</body><body package="Reversi">displayGridOn: aGC	| rect sqW sqH color |	rect := self bounds.	aGC paint: ColorValue darkGreen.	aGC displayRectangle: rect.	aGC paint: ColorValue black.	sqW := rect width - 8 / 8.	sqH := rect height - 8 / 8.	"Draw 7 dark vertical lines."		1 to: 7 do: 	[: i |		| x y |		x := (sqW * i) rounded + 4.		y := (sqH * i) rounded + 4.		aGC displayLineFrom: x@0 to: x@rect bottom.		aGC displayLineFrom: 0@y to: rect right@y			].	aGC paint: ColorValue lightGray.	"Draw 7 light vertical lines."		1 to: 7 do: 	[: i |		| x y |		x := (sqW * i) rounded + 4.		y := (sqH * i) rounded + 4.		aGC displayLineFrom: x+1@0 to: x+1@rect bottom.		aGC displayLineFrom: 0@y+1 to: rect right@y+1			].	"Draw a beveled border."	color := ColorValue darkGreen.	0 to: 3 do:	[:count |  | borderRect |		borderRect := rect insetBy: count.		aGC paint: color asShadowColor.		aGC displayLineFrom: borderRect bottomLeft to: borderRect topLeft.		aGC displayLineFrom: borderRect topLeft to: borderRect topRight.		aGC paint: color asHiliteColor.		aGC displayLineFrom: borderRect bottomLeft to: borderRect bottomRight.		aGC displayLineFrom: borderRect bottomRight to: borderRect topRight.	].</body><body package="Reversi">displayOn: aGC 	splashScreen		ifFalse: 			[repainting := true.			self displayGridOn: aGC.			self displayPiecesOn: aGC.			repainting := false]</body><body package="Reversi">displayPiecesOn: aGC 	self board keysAndValuesDo: [:i :piece | piece isNil ifFalse: [self displaySquareAt: i]]</body><body package="Reversi">displaySquareAt: anIndex 	"Paint the piece at the index."	| rect sqW sqH aGC sqV xlate |	rect := self bounds.	sqW := rect width - 8 / 8.	sqH := rect height - 8 / 8.	rect := self pieceRect.	aGC := self graphicsContext.	sqV := self board at: anIndex.	sqV = 0 ifTrue: [aGC paint: ColorValue black].	sqV = 1 ifTrue: [aGC paint: ColorValue white].	sqV = 2 ifTrue: [aGC paint: ColorValue darkGreen].	sqV = 3 ifTrue: [aGC paint: ColorValue magenta].	sqV = 4 ifTrue: [aGC paint: ColorValue magenta asShadowColor].	xlate := (self board pointIndexFor: anIndex)				- 1.	sqV &gt; 1		ifTrue: [aGC				displayWedgeBoundedBy: (rect translatedBy: sqW @ sqH * xlate + (4 @ 4))				startAngle: 0				sweepAngle: 360]		ifFalse: [(self model animation value and: [first = false and: [repainting = false]])				ifTrue: [self flip3DPieceOn: aGC in: (rect translatedBy: sqW @ sqH * xlate + (4 @ 4))]				ifFalse: [self						display3DPieceOn: aGC						in: (rect translatedBy: sqW @ sqH * xlate + (4 @ 4))						direction: -1]]</body><body package="Reversi">flip3DPieceOn: gc in: aRect 	| origin rect size pm pmgc oldPaint win |	rect := aRect copy.	size := rect height.	origin := 0 @ 0.	oldPaint := gc paint.	gc paint: ColorValue darkGreen.	self		display3DPieceOn: gc		in: rect		direction: -1.	gc paint: oldPaint.	pm := Pixmap extent: rect extent rounded.	pmgc := pm graphicsContext.	gc paint = ColorValue white		ifTrue: [pmgc paint: ColorValue black]		ifFalse: [pmgc paint: ColorValue white].	win := self model builder window.	size / 3 to: size		do: 			[:x | 			(splashScreen and: [win sensor anyButtonPressed" | win sensor nextKeyboardEvent"])				ifTrue: [^self splashScreen: false].			rect := origin extent: rect width @ (size - x).			self clear: pmgc to: ColorValue darkGreen.			self				display3DPieceOn: pmgc				in: rect				direction: -1.			gc display: pm at: aRect origin].	pmgc paint = ColorValue white		ifTrue: [pmgc paint: ColorValue black]		ifFalse: [pmgc paint: ColorValue white].	size		to: 0		by: -1		do: 			[:x | 			(splashScreen and: [win sensor anyButtonPressed])				ifTrue: [^self splashScreen: false].			rect := origin extent: rect width @ (size - x).			self clear: pmgc to: ColorValue darkGreen.			self				display3DPieceOn: pmgc				in: rect				direction: 1.			gc display: pm at: aRect origin].	0 to: size / 3		do: 			[:x | 			(splashScreen and: [win sensor anyButtonPressed])				ifTrue: [^self splashScreen: false].			rect := origin extent: rect width @ (size - x).			self clear: pmgc to: ColorValue darkGreen.			self				display3DPieceOn: pmgc				in: rect				direction: -1.			gc display: pm at: aRect origin].	self clear: pmgc to: ColorValue darkGreen.	gc display: pm at: aRect origin.	self		display3DPieceOn: gc		in: aRect		direction: -1</body><body package="Reversi">splashScreen	| displayPt gc text text1 text2 |	displayPt := 175 @ 25.	gc := self graphicsContext.	self clear: gc to: ColorValue darkGreen.	text1 := ' Reversi  Reversi  Reversi  Reversi' asComposedText compositionWidth: 800.	text2 := 'ersi  Reversi  Reversi  Reversi' asComposedText compositionWidth: 800.	text1 textStyle characterAttributes at: #size put: [:q :s | q pixelSize: s].	text1 text emphasizeAllWith: (Array			with: #color -&gt; ColorValue gray			with: #size -&gt; 48			with: #bold).	text2 textStyle characterAttributes at: #size put: [:q :s | q pixelSize: s].	text2 text emphasizeAllWith: (Array			with: #color -&gt; ColorValue gray			with: #size -&gt; 48			with: #bold).	2 to: 6 do: [:i | i odd			ifTrue: [gc display: text1 at: 0 @ (45 * i)]			ifFalse: [gc display: text2 at: 0 @ (45 * i + 1)]].	text := 'Reversi' asComposedText compositionWidth: 200.	text textStyle characterAttributes at: #size put: [:q :s | q pixelSize: s].	text text emphasizeAllWith: (Array with: #color -&gt; ColorValue white with: #size -&gt; 48).	gc display: text at: 5 @ 45.	text text emphasizeAllWith: (Array with: #color -&gt; ColorValue black with: #size -&gt; 48).	gc display: text at: 6 @ 44.	self model builder keyboardProcessor currentConsumer: self controller.	[splashScreen]		whileTrue: [self flip3DPieceOn: gc in: (displayPt extent: 48 @ 48)].	self invalidate</body></methods><methods><class-id>ReversiView</class-id> <category>cursor</category><body package="Reversi">button1Down: aSquare	"The first button of the mouse was pressed over a square"	self model playAt: aSquare</body><body package="Reversi">mousePos: aSquare	"The row and/or column position of the mouse has changed.	If it is over a square that is a legal move, change the cursor."	(self model playableAt: aSquare for: self model player)		ifTrue: [Cursor bull beCursor] 		ifFalse: [Cursor normal beCursor]</body></methods><methods><class-id>ReversiView</class-id> <category>private</category><body package="Reversi">clear: aGC to: aColor 	| oldPaint |	oldPaint := aGC paint.	aGC paint: aColor.	aGC displayRectangle: aGC clippingBounds.	aGC paint: oldPaint</body><body package="Reversi">pieceRect	"Answer a rectangle approximatly 1/8 the size of the board."	| rect sqW sqH |	rect := self bounds.	sqW := rect width - 8 / 8.	sqH := rect height - 8 / 8.	rect := sqW * 0.12 @ (sqH * 0.12) extent: sqW * 0.8 @ (sqH * 0.8).	^rect rounded</body></methods><methods><class-id>ReversiView</class-id> <category>accessing</category><body package="Reversi">board	"Answer the value of board."	self model lookAheadBoard == nil		ifTrue: [^self model board]		ifFalse: [^self model lookAheadBoard]</body><body package="Reversi">first: aBoolean 	"Set the value of first."	first := aBoolean</body><body package="Reversi">splashScreen: aBoolean 	"Set the value of splashScreen."	splashScreen := aBoolean</body></methods><methods><class-id>ReversiView</class-id> <category>controller accessing</category><body package="Reversi">defaultControllerClass	"Answer the class of the default controller for the receiver."	"Subclasses should redefine defaultControllerClass if the class of the 	default controller is not Controller."	^ReversiController</body></methods><methods><class-id>ReversiView</class-id> <category>initialize</category><body package="Reversi">initialize	super initialize.	splashScreen := true</body></methods><methods><class-id>ReversiController</class-id> <category>menu actions</category><body package="Reversi">about	self model about</body><body package="Reversi">animationOff	self checkMarkFor: 'Off'  fromArray: self animations.	self model = nil ifFalse: [self model animation value: false]</body><body package="Reversi">animationOn	self checkMarkFor: 'On'  fromArray: self animations.	self model animation value: true</body><body package="Reversi">beginner	self checkMarkFor: 'Beginner' fromArray: self levels.	self model playLevel value: #beginner</body><body package="Reversi">expert	self checkMarkFor: 'Expert'  fromArray: self levels.	self model expertLevel</body><body package="Reversi">intermediate	self checkMarkFor: 'Intermediate'  fromArray: self levels.	self model playLevel value: #intermediate</body><body package="Reversi">newGame	self model newGame.	self button1DownState: #up</body><body package="Reversi">quit	self model closeRequest</body></methods><methods><class-id>ReversiController</class-id> <category>events</category><body package="Reversi">mouseMovedEvent: event 	super mouseMovedEvent: event.	self cursorActivity.	event anyButtonPressed		ifTrue: [^event]		ifFalse: [^nil]</body><body package="Reversi">processKeyboardEvent: event  	| key | 	key := event keyValue.	key = Character cr and: [self model opponentMove ~~ nil ifTrue: [^self model moveOpponent]].	key = Character esc		ifTrue: 			[button1DownState := #up.			self lookAheadInProgress: false.			^self model interrupt]</body><body package="Reversi">redButtonPressedEvent: event	^self redButtonActivity</body></methods><methods><class-id>ReversiController</class-id> <category>accessing</category><body package="Reversi">button1DownState	"Answer the value of button1DownState."	^button1DownState</body><body package="Reversi">button1DownState: aValue 	"Set the value of button1DownState."	button1DownState := aValue</body><body package="Reversi">lookAheadInProgress	"Answer the value of lookAheadInProgress."	^lookAheadInProgress</body><body package="Reversi">lookAheadInProgress: aBoolean 	"Set the value of lookAheadInProgress."	lookAheadInProgress := aBoolean</body><body package="Reversi">mouseColRow	"Answer the value of mouseColRow."	^mouseColRow</body><body package="Reversi">mouseColRow: aValue 	"Set the value of mouseColRow."	mouseColRow := aValue</body></methods><methods><class-id>ReversiController</class-id> <category>private</category><body package="Reversi">animations	^#('On' 'Off')</body><body package="Reversi">checkMarkFor: aString  fromArray: anArray	"Check an options from anArray."	| item |	anArray		do: 			[:ea | 			item := self menuHolder value someMenuItemLabeled: ea ifNone: [].			item isNil ifFalse: [item beOff]].	item := self menuHolder value someMenuItemLabeled: aString ifNone: [].	item isNil ifFalse: [item beOn]</body><body package="Reversi">levels	^#('Beginner' 'Intermediate' 'Expert')</body></methods><methods><class-id>ReversiController</class-id> <category>control defaults</category><body package="Reversi">controlActivity 	self sensor keyboardPressed ifTrue: [self keyboardActivity].	self viewHasCursor		ifTrue: 			[self sensor redButtonPressed ifTrue: [^self redButtonActivity].			self sensor yellowButtonPressed ifTrue: [^self yellowButtonActivity].			self lookAheadInProgress ifFalse: [^self cursorActivity]].	Cursor normal show.	super controlActivity</body><body package="Reversi">cursorActivity	"Track the mouse position and update the row and column when they change. 	Notifiy the view of changes."	| sen cursorPos row col rect sqW sqH |	button1DownState := #up.	sen := self sensor.	cursorPos := sen cursorPoint.	rect := self view bounds.	sqW := rect width / 8.	sqH := rect height / 8.	row := 1 + (cursorPos y / sqH) truncated.	row &lt; 1 ifTrue: [row := 1].	row &gt; 8 ifTrue: [row := 8].	col := 1 + (cursorPos x / sqW) truncated.	col &lt; 1 ifTrue: [col := 1].	col &gt; 8 ifTrue: [col := 8].	col @ row ~~ mouseColRow		ifTrue: 			[mouseColRow := col @ row.			self view mousePos: mouseColRow]</body><body package="Reversi">keyboardActivity	self processKeyboardEvent: self sensor keyboardEvent</body><body package="Reversi">redButtonActivity	"Only accept the first message after the button is pressed."	button1DownState = #down ifTrue: [^self].	button1DownState := #down.	mouseColRow ~~ nil ifTrue: [self view button1Down: mouseColRow]</body></methods><methods><class-id>ReversiController</class-id> <category>initialize</category><body package="Reversi">initialize	super initialize.	self menuHolder value: self class menu.	lookAheadInProgress := false.	self animationOff</body></methods><methods><class-id>Reversi class</class-id> <category>resources</category><body package="Reversi">colorIcon	"UIMaskEditor new openOnClass: self andSelector: #colorIcon"	&lt;resource: #image&gt;	^(Image extent: 32@31 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@**"**J*(**B**J*(**"*(J*(**"**J* **"**J*(**B**J*(**"*(J*(**"**J* @@@@@@@@@@B**J*(**"*(J*(*J"(*J* **" JJD(**B**H@H!T"*(J*((B"!JJ* **"(*J"(**B**J*(**"*(@@@@@@@@@@@**"**J*(**B**J"(*J"*(J*((R" JJ* **"ERH@H**B**JD((B"*(J*(*J"(*J* **"**J*(**@@@@@@@@@@@J*(**"**J* **"**J*(**B**J*(**"*(J*(**"**J* **"**J*(**B**J*(**"*(@@@@@@@@@@@b'))</body><body package="Reversi">icon	"UIMaskEditor new openOnClass: self andSelector: #icon"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 255 255 255 255 128 128 128 129 128 128 128 129 128 128 128 129 128 128 128 129 128 128 128 129 128 128 128 129 255 255 255 255 128 128 128 129 128 136 136 129 128 156 148 129 128 190 162 129 128 156 148 129 128 136 136 129 128 128 128 129 255 255 255 255 128 128 128 129 128 136 136 129 128 148 156 129 128 162 190 129 128 148 156 129 128 136 136 129 128 128 128 129 255 255 255 255 128 128 128 129 128 128 128 129 128 128 128 129 128 128 128 129 128 128 128 129 128 128 128 129 255 255 255 255])</body></methods><methods><class-id>Reversi class</class-id> <category>interface specs</category><body package="Reversi">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Reversi' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 1023 744 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0 -24 1 2 1 2 1 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6200 6200 6200 ) ) ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0 -1 0 0 1 -25 1 ) 					#name: #view 					#flags: 0 					#component: #view ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 0 1 -23 1 ) 					#name: #divider ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -22 1 -2 1 -2 1 ) 					#name: #messageArea 					#model: #messageArea 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>ReversiController class</class-id> <category>resources</category><body package="Reversi">menu	"UIMenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 'New Game' 				#value: #newGame ) 			#(#MenuItem 				#rawLabel: 'Level' 				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: 'Beginner' 							#value: #beginner ) 						#(#MenuItem 							#rawLabel: 'Intermediate' 							#value: #intermediate ) 						#(#MenuItem 							#rawLabel: 'Expert' 							#value: #expert ) ) #(3 ) nil ) ) 			#(#MenuItem 				#rawLabel: 'Animation' 				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: 'On' 							#value: #animationOn ) 						#(#MenuItem 							#rawLabel: 'Off' 							#value: #animationOff ) ) #(2 ) nil ) ) 			#(#MenuItem 				#rawLabel: 'About' 				#value: #about ) 			#(#MenuItem 				#rawLabel: 'Close' 				#value: #quit ) ) #(3 2 ) nil ) decodeAsLiteralArray</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ControllerWithMenu</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class></st-source>