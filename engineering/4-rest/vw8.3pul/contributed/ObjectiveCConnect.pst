<?xml version="1.0"?><st-source><!-- Name: ObjectiveCConnectComment: This package provides a convenient and efficient ObjectiveC Connect framework.Usage"Center the current window."Window currentWindow windowHandle __from_objc_id center"Looking up ObjectiveC classes."Root.ObjectiveC.NSString"Converting between String and NSString."| string1 nsstring string2 |string1 := 'testing'.nsstring := Root.ObjectiveC.NSString stringWithCharacters: (string1 asByteArrayEncoding: #utf16) length: string1 size.string2 := (nsstring cStringUsingEncoding: ObjectiveCObject.Runtime NSUTF16LittleEndianStringEncoding) copyDoubleByteStringFromHeap: #utf16"Converting between String and NSString the easy way."| string1 nsstring string2 |string1 := 'string1'.nsstring := string1 asNSString.string2 := String fromNSString: nsstring."Doing an affine rotation transform."| matrix |matrix := Root.ObjectiveC.NSAffineTransform transform.matrix rotateByDegrees: 45.matrix transformPoint: (1 @ 0)."Getting the current date"Root.ObjectiveC.NSDate date printStringImplementationThe Root.ObjectiveC namespace gets transformed in to an instance of ObjectiveCNameSpace when started up on MacOSX. On other platforms, it remains (or transforms back to) a regular NameSpace instance. The ObjectiveCNameSpace handles class lookups. It caches class lookup results. When a new class is looked up, it will find the ObjectiveC class object and generate a Smalltalk ObjectiveCObject subclass to represent that ObjectiveC class. All of the methods on the ObjectiveC class are generated as methods on the Smalltalk class as DLLCC interfaces. Both the instance and class sides are generated. Arguments and return types get type cast, the list of type casting is described below.The ObjectiveCCallback can be used to install code in to the ObjectiveC runtime environment on NSObject with a generate selector. This is useful when working with AppKit to hook up UI action callbacks. They typically have a "target" and an "action". The target is an object and the action is a selector (an instance of SEL). An ObjectiveCCallback generates a method on NSObject that can be called as the action and creates an instance of an NSObject that can be used as the target. You must keep a reference to the ObjectiveCCallback otherwise it will become garbage collected.Argument type casts:id				CCompositePointer<objc_object>, ObjectiveCObject, SmallInteger, String	__to_objc_idClass			CCompositePointer<objc_class>, ObjectiveCObject, Class				__to_objc_ClassSEL				CCompositePointer<objc_selector>, Symbol, String						__to_objc_SELBOOL			Boolean																__to_objc_BOOLfloat				Number																__to_objc_floatdouble			Number																__to_objc_doubleint				Number																__to_objc_int_NSPoint		CComposite<_NSPoint>, Point										__to_objc_NSPoint_NSRange		CComposite<_NSRange>, Interval										__to_objc_NSRange_NSRect		CComposite<_NSRect>, Rectangle									__to_objc_NSRect_NSSize		CComposite<_NSSize>, Point											__to_objc_NSSizeReturn type casts:id				ObjectiveCObject		__from_objc_idClass			Class				__from_objc_ClassSEL				Symbol				__from_objc_SELBOOL			SmallInteger			__from_objc_BOOL_NSPoint		Point				__from_objc_NSPoint_NSRange		Interval				__from_objc_NSRange_NSRect		Rectangle			__from_objc_NSRect_NSSize		Point				__from_objc_NSSizeLimitationsObjectiveC objects and classes do not survive across image save, you cannot resume using an ObjectiveCObject once an image has restarted.Some ObjectiveC methods conflict with Smalltalk methods, such as the class side methods #initialize, #copy, #finalize, #release, #new, #hash, #superclass, #class and the instance side methods #hash and #class. Any method that has already been implemented in the ObjectiveCObject hierarchy (which subclasses from Object) will not be wrapped as a DLLCC call.DbIdentifier: bear73DbTrace: 471703DbUsername: mlucas-smithDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#package 'DLLCC' '') #(#package 'SUnitToo' ''))PackageName: ObjectiveCConnectParcel: #('ObjectiveCConnect')ParcelName: ObjectiveCConnectPrerequisiteParcels: #(#('DLLCC' '') #('SUnitToo' ''))PrintStringCache: (8.2 - 1,mlucas-smith)Version: 8.2 - 1Post-Load Block: 	[:package | SystemEventInterest configureObjectiveCConnect]Date: 8:28:23 AM September 18, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (sep15.3) of September 18, 2015 on September 18, 2015 at 8:28:23 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ObjectiveC</name><environment>Root</environment><private>false</private><imports></imports><category></category><attributes><package>ObjectiveCConnect</package></attributes></name-space><class><name>ObjectiveCNameSpace</name><environment>OS</environment><super>Kernel.NameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes interfaces argumentTypeCasts resultTypeCasts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>ObjectiveCConnect</package></attributes></class><comment><class-id>OS.ObjectiveCNameSpace</class-id><body>ObjectiveCNameSpace is a class factory for ObjectiveC. When a class is looked up, a lightweight copy of ObjectiveCObject is created and methods for the ObjectiveC class are installed on to the copy. The new class is held on to in this namespace until the image is restarted.Instance Variables	argumentTypeCasts	&lt;Dictionary | KeyedCollection&gt;	selectors used to typecast for arguments	classes	&lt;(Dictionary of: (ObjectiveCObject class))&gt;		class name to interface instance	interfaces	&lt;Dictionary&gt;								objcClassId to interface instance	resultTypeCasts	&lt;Dictionary | KeyedCollection&gt;	selectors used to typecast for results</body></comment><class><name>ObjectiveCCallback</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object selector block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>ObjectiveCConnect</package></attributes></class><comment><class-id>OS.ObjectiveCCallback</class-id><body>ObjectiveCCallback is used to install a Smalltalk block on to NSObject under a generated selector. This selector and an instance of NSObject can then be handed to UI components as action targets.The first two parameters must be ObjectiveCRuntime id and ObjectiveCRuntime SEL as that is the definition of IMP for a method installed on an ObjectiveC class.callback := ObjectiveCCallback do: [:id :sel :x | x + 1] resultType: CIntegerType int argumentTypes: (Array with: ObjectiveCRuntime id with: ObjectiveCRuntime SEL with: CIntegerType int).(ObjectiveCRuntime perform: callback selector on: callback object __to_objc_id with: 2)</body></comment><class><name>ObjectiveCObject</name><environment>OS</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars>id </class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>ObjectiveCConnect</package></attributes></class><comment><class-id>OS.ObjectiveCObject</class-id><body>ObjectiveCObject is a prototypical class for ObjectiveC object instances. When an object is instantiated, its class is looked up and a lightweight copy of this class is generate (and it's metaclass) for the new instance. All the methods for that class are installed on to the class as fast C calls.</body></comment><shared-variable><name>ThrowException</name><environment>Core.SystemEventInterest</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>ObjectiveCConnect</package></attributes></shared-variable><shared-variable><name>CocoaBundles</name><environment>OS.ObjectiveCNameSpace</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>ObjectiveCConnect</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>OS.ObjectiveCCallback</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>ExternalRegistry new</initializer><attributes><package>ObjectiveCConnect</package></attributes></shared-variable><shared-variable><name>Callbacks</name><environment>OS.ObjectiveCCallback</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Dictionary new</initializer><attributes><package>ObjectiveCConnect</package></attributes></shared-variable><methods><class-id>OS.ObjectiveCNameSpace</class-id> <category>initialize</category><body package="ObjectiveCConnect">configure	classes := Dictionary new.	interfaces := Dictionary new.	argumentTypeCasts := self defaultArgumentTypeCasts.	resultTypeCasts := self defaultResultTypeCasts</body><body package="ObjectiveCConnect">defaultArgumentTypeCasts	^Dictionary new		at: ObjectiveCRuntime id put: #__to_objc_id;		at: ObjectiveCRuntime Class put: #__to_objc_Class;		at: ObjectiveCRuntime SEL put: #__to_objc_SEL;		at: ObjectiveCRuntime BOOL put: #__to_objc_BOOL;		at: ObjectiveCRuntime _NSPoint put: #__to_objc_NSPoint;		at: ObjectiveCRuntime _NSRange put: #__to_objc_NSRange;		at: ObjectiveCRuntime _NSRect put: #__to_objc_NSRect;		at: ObjectiveCRuntime _NSSize put: #__to_objc_NSSize;		at: CLimitedPrecisionRealType float put: #__to_objc_float;		at: CLimitedPrecisionRealType double put: #__to_objc_double;		at: CIntegerType unsignedShort put: #__to_objc_int;		at: CIntegerType short put: #__to_objc_int;		at: CIntegerType unsignedShort put: #__to_objc_int;		at: CIntegerType int put: #__to_objc_int;		at: CIntegerType unsignedInt put: #__to_objc_int;		at: CIntegerType long put: #__to_objc_int;		at: CIntegerType unsignedLong put: #__to_objc_int;		at: CIntegerType longLong put: #__to_objc_int;		at: CIntegerType unsignedLongLong put: #__to_objc_int;		yourself</body><body package="ObjectiveCConnect">defaultResultTypeCasts	^Dictionary new		at: ObjectiveCRuntime id put: #__from_objc_id;		at: ObjectiveCRuntime Class put: #__from_objc_Class;		at: ObjectiveCRuntime SEL put: #__from_objc_SEL;		at: ObjectiveCRuntime BOOL put: #__from_objc_BOOL;		at: ObjectiveCRuntime _NSPoint put: #__from_objc_NSPoint;		at: ObjectiveCRuntime _NSRange put: #__from_objc_NSRange;		at: ObjectiveCRuntime _NSRect put: #__from_objc_NSRect;		at: ObjectiveCRuntime _NSSize put: #__from_objc_NSSize;		"While not strictly true, it seems that 99% of the APIs that return a char are really returning a Boolean."		at: CIntegerType char put: #__from_objc_BOOL;		yourself</body></methods><methods><class-id>OS.ObjectiveCNameSpace</class-id> <category>testing</category><body package="ObjectiveCConnect">includesKey: aKey	self at: aKey ifAbsent: [^false].	^true</body></methods><methods><class-id>OS.ObjectiveCNameSpace</class-id> <category>collection accessing</category><body package="ObjectiveCConnect">at: aKey ifAbsent: aBlock 	^classes at: aKey ifAbsentPut: [self interfaceAt: (ObjectiveCRuntime getClassNamed: aKey asString) ifAbsent: [^aBlock value]]</body><body package="ObjectiveCConnect">interfaceAt: anId ifAbsent: aBlock	anId isValid ifFalse: [^aBlock value].	^interfaces at: anId ifAbsent: [self generateInterfaceClassFor: anId]</body><body package="ObjectiveCConnect">interfaceKeyAtValue: aClass ifAbsent: aBlock	^interfaces keyAtValue: aClass ifAbsent: aBlock</body></methods><methods><class-id>OS.ObjectiveCNameSpace</class-id> <category>enumerating</category><body package="ObjectiveCConnect">bindingsDo: aBlock	self keysAndValuesDo: [:aName :anInterface |		aBlock value:			((VariableBinding key: aName value: anInterface)				environment: self;				yourself)]</body><body package="ObjectiveCConnect">keysAndValuesDo: aBlock	classes do: [:each | aBlock value: each name value: each]</body></methods><methods><class-id>OS.ObjectiveCNameSpace</class-id> <category>interface generation</category><body package="ObjectiveCConnect">generateInterfaceClassFor: objcClass	| class smalltalkSuperclass |	smalltalkSuperclass := self		interfaceAt:	(ObjectiveCRuntime getSuperclass: objcClass)		ifAbsent:		[ObjectiveCObject].	class := smalltalkSuperclass copy		superclass: smalltalkSuperclass;		methodDictionary: MethodDictionary new;		setInstanceFormat: (Behavior formatFromType: smalltalkSuperclass behaviorType super: smalltalkSuperclass instVars: '');		instanceVariables: nil;		setOrganization: nil;		environment: Root.ObjectiveC;		setName: (ObjectiveCRuntime getClassName: objcClass);		setClassPool: nil;		yourself.	interfaces at: objcClass put: class.	class __id: objcClass.	self generateInterfaceMetaClassFor: (objcClass memberAt: #isa) instance: class.	self generateInterfaceMethodsFor: objcClass on: class.	^class</body><body package="ObjectiveCConnect">generateInterfaceMetaClassFor: objcClass instance: instanceOfThisClass	| class smalltalkSuperclass objcSuperclass |	objcSuperclass := ObjectiveCRuntime getSuperclass: objcClass.	smalltalkSuperclass := (ObjectiveCRuntime isMetaClass: objcSuperclass)		ifTrue:	[interfaces at: objcSuperclass ifAbsent: [self error: 'missing metaclass superclass']]		ifFalse:			["Metaclass Meta-Cycle, we want to break it in our implementation.			 NSObject class's superclass is NSObject just like			 Object class's eventual-superclass is Object."			ObjectiveCObject class].	class := smalltalkSuperclass copy		superclass: smalltalkSuperclass;		methodDictionary: MethodDictionary new;		setInstanceFormat: (Behavior formatFromType: smalltalkSuperclass behaviorType super: smalltalkSuperclass instVars: '');		instanceVariables: nil;		setOrganization: nil;		adoptInstance: instanceOfThisClass;		adopt: instanceOfThisClass;		yourself.	interfaces at: objcClass put: class.	self generateInterfaceMethodsFor: objcClass on: class.	^class</body><body package="ObjectiveCConnect">generateInterfaceMethodsFor: objcClass on: smalltalkClass	| smalltalkSuperclass bundle bundleIdentifier bundleName isCocoa |	isCocoa := false.	bundle := ObjectiveCRuntime object: (ObjectiveCRuntime getClassNamed: 'NSBundle') perform: #bundleForClass: with: objcClass.	bundle isNull ifFalse: [		bundleIdentifier := ObjectiveCRuntime object: bundle perform: #bundleIdentifier.		bundleIdentifier isNull ifFalse: [			bundleName := (ObjectiveCRuntime object: bundleIdentifier perform: #UTF8String) copyCStringFromHeap: #utf8.			isCocoa := CocoaBundles includes: bundleName]].	smalltalkSuperclass := smalltalkClass superclass.	(ObjectiveCRuntime getAllMethodsForClass: objcClass) do: [:objcMethod |		| objcMethodName procedure |		objcMethodName := (ObjectiveCRuntime getMethodName: objcMethod) asSymbol.		(objcMethodName beginsWith: '_') ifFalse: [			(smalltalkSuperclass canUnderstand: objcMethodName) ifFalse: [				procedure := [ObjectiveCRuntime procedureForMethod: objcMethod] on: Error do: [nil].				procedure == nil ifFalse: [					isCocoa						ifTrue: [self generateCocoaMethod: objcMethodName procedure: procedure into: smalltalkClass for: objcClass]						ifFalse: [							self generatePrivateMethod: objcMethodName procedure: procedure into: smalltalkClass.							self generatePublicMethod: objcMethodName procedure: procedure into: smalltalkClass]]]]]</body></methods><methods><class-id>OS.ObjectiveCNameSpace</class-id> <category>accessing</category><body package="ObjectiveCConnect">bindingFor: aName modifiers: modifiers	| class |	class := self at: aName ifAbsent: [^nil].	^(VariableBinding key: aName asSymbol value: class)		environment: self;		forClass</body><body package="ObjectiveCConnect">protectedBindingFor: aName modifiers: modifiers	| class |	class := self at: aName ifAbsent: [^nil].	^(VariableBinding key: aName asSymbol value: class)		environment: self;		forClass</body></methods><methods><class-id>OS.ObjectiveCNameSpace</class-id> <category>method generation</category><body package="ObjectiveCConnect">generateCallbackMethodSource: blockType	"Generates source code of a block for the blockType, eg:	void(id, SEL, char*) -&gt; [:arg1 :arg2 :arg3 | ObjectiveCCallback performCallback: [:block block cull: arg1] for: arg1].	void(id, SEL, char*, id) -&gt; [:arg1 :arg2 :arg3 :arg4 | ObjectiveCCallback performCallback: [:block | block cullWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)] for: arg1].	"	| code tails |	code := String new writeStream.	code nextPutAll: '['.	1 to: blockType numArgs do: [:i | code nextPutAll: ':arg', i printString; space].	tails := blockType argumentTypes collect: [:type | resultTypeCasts at: type ifAbsent: nil].	code nextPutAll: '| ObjectiveCCallback performCallback: [:block | '.	argumentTypeCasts at: blockType resultType ifPresent: [:conversion | code nextPutAll: '('].	code nextPutAll: 'block'.	blockType numArgs &gt; 3		ifTrue:			[code nextPutAll: ' cullWithArguments: (Array'.			1 to: blockType numArgs do: [:i |				code nextPutAll: ' with: arg', i printString.				(tails at: i) ifNotNil: [:tail | code space; nextPutAll: tail]].			code nextPutAll: ')']		ifFalse: [1 to: blockType numArgs do: [:i |			code nextPutAll: ' cull: arg', i printString.			(tails at: i) ifNotNil: [:tail | code space; nextPutAll: tail]]].	argumentTypeCasts at: blockType resultType ifPresent: [:conversion | code nextPutAll: ') '; nextPutAll: conversion].	code nextPutAll: '] for: arg1]'.	^code contents</body><body package="ObjectiveCConnect">generateCocoaMethod: aMethodName procedure: aProcedure into: aSmalltalkClass for: objcClass	| stream replacements method |	replacements := OrderedCollection new.	stream := String new writeStream.	stream nextPutAll: (self generateMethodSelector: aMethodName procedure: aProcedure).	stream cr; tab; nextPutAll: '| invocation buffer '.	aProcedure type resultType isVoid ifFalse: [stream nextPutAll: 'result '].	stream nextPutAll: '|'.	replacements add: (ObjectiveCRuntime sel_getUid: 'invoke').	replacements add: (ObjectiveCRuntime object: objcClass perform: #instanceMethodSignatureForSelector: with: (ObjectiveCRuntime sel_getUid: aMethodName asString)).	stream cr; tab; nextPutAll: 'invocation := STInvocation invocationWithMethodSignature: #replace2.'.	replacements add: (ObjectiveCRuntime sel_getUid: aMethodName asString).	stream cr; tab; nextPutAll: 'invocation setSelector: #replace3.'.	stream cr; tab; nextPutAll: 'invocation setTarget: id.'.	aProcedure type resultType = ObjectiveCRuntime id ifTrue: [stream cr; tab; nextPutAll: 'invocation retainReturnValue.'].	(aProcedure type argumentNames allButFirst: 2) with: (aProcedure type argumentTypes allButFirst: 2) do: [:argumentName :argumentType |		replacements add: argumentType.		stream cr; tab; nextPutAll: 'buffer := #replace'; print: replacements size; nextPutAll: ' malloc.'.		stream cr; tab; nextPutAll: 'buffer contents: '; nextPutAll: argumentName.		argumentTypeCasts at: argumentType ifPresent: [:conversion | stream space; nextPutAll: conversion].		stream nextPutAll: '.'.		stream cr; tab; nextPutAll: 'invocation setArgument: buffer atIndex: '; print: replacements size - 2; nextPutAll: '.'.		stream cr; tab; nextPutAll: 'buffer free.'].	stream cr; tab; nextPutAll: 'invocation performSelectorOnMainThread: #replace1 withObject: nil waitUntilDone: 1.'.	aProcedure type resultType isVoid		ifTrue: [stream cr; tab; nextPutAll: '^nil']		ifFalse: [			replacements add: aProcedure type resultType.			stream cr; tab; nextPutAll: 'buffer := #replace'; print: replacements size; nextPutAll: ' malloc.'.			stream cr; tab; nextPutAll: 'invocation getReturnValue: buffer.'.			stream cr; tab; nextPutAll: 'result := buffer contents'.			resultTypeCasts at: aProcedure type resultType ifPresent: [:conversion | stream space; nextPutAll: conversion].			stream nextPutAll: '.'.			stream cr; tab; nextPutAll: 'buffer free.'.			aProcedure type resultType = ObjectiveCRuntime id ifTrue: [stream cr; tab; nextPutAll: 'result __isObjectiveCObject ifTrue: [result autorelease].'].			stream cr; tab; nextPutAll: '^result'].	method := (aSmalltalkClass compilerClass new		environment: aSmalltalkClass environment;		compile: stream contents in: aSmalltalkClass notifying: nil ifFail: [^nil]) generate.	method sourcePointer: stream contents.	replacements keysAndValuesDo: [:index :replacement |		method at: (method literals indexOf: ('replace', index printString) asSymbol) put: replacement].	aSmalltalkClass addSelector: aMethodName withMethod: method category: 'api'</body><body package="ObjectiveCConnect">generateMethodSelector: aMethodName procedure: aProcedure	| stream |	stream := String new writeStream.	(aMethodName includes: $:)		ifFalse:	[stream nextPutAll: aMethodName]		ifTrue:			[((aMethodName tokensBasedOn: $:) allButLast: 1) keysAndValuesDo: [:index :token |				token isEmpty					ifTrue:	[stream nextPutAll: 'with']					ifFalse:	[stream nextPutAll: token].				stream nextPutAll: ': '.				stream nextPutAll: (aProcedure type argumentNames at: (index + 2)).				stream space].			stream skip: -1].	^stream contents</body><body package="ObjectiveCConnect">generatePrivateMethod: aMethodName procedure: aProcedure into: aSmalltalkClass	| method selector |	method := AssemblerCodeStream new		class: aSmalltalkClass;		forMethod: aProcedure type argumentNames methodClass: ExternalMethod;		addTemporaries: #('_errorCode');		putPrimitive: 395;		putStorePopLocal: aProcedure type numArgs scope: 0;		pushStatic: #{OS.ObjectiveCRuntime};		putLoadLocal: aProcedure type numArgs argument: false scope: 0;		sendNonImmediate: #externalAccessFailedWith: numArgs: 1;		putMethodReturn;		generateMethod.	selector := ('primitive ', aMethodName) asSymbol.	method for: nil -&gt; aProcedure selector: selector.	method sourcePointer: (self generatePrivateMethodSource: aMethodName procedure: aProcedure).	aSmalltalkClass addSelector: selector withMethod: method category: 'primitive'</body><body package="ObjectiveCConnect">generatePrivateMethodSource: aMethodName procedure: aProcedure	| stream |	stream := String new writeStream.	stream nextPutAll: '&lt;primitive&gt; id: arg1 selector: arg2 '.	stream nextPutAll: (self generateMethodSelector: aMethodName procedure: aProcedure).	stream		cr;		tab;		nextPutAll: '&lt;C: ';		print: aProcedure;		nextPutAll: '&gt;'.	stream		cr;		tab;		nextPutAll: '^AbstractObjectiveCRuntime concreteClass new externalAccessFailedWith: _errorCode'.	^stream contents</body><body package="ObjectiveCConnect">generatePublicMethod: aMethodName procedure: aProcedure into: aSmalltalkClass	| assembler method selector |	selector := ('primitive ', aMethodName) asSymbol.	(assembler := AssemblerCodeStream new)		class: aSmalltalkClass;		forMethod: (aProcedure type argumentNames allButFirst: 2).	" Debug information "	"assembler pushConstant: Stdout; sendNoCheck: #cr numArgs: 0; pop.	assembler pushConstant: Stdout; pushConstant: 'calling: '; sendNoCheck: #nextPutAll: numArgs: 1; pop.	assembler pushConstant: Stdout; pushConstant: aMethodName; sendNoCheck: #print: numArgs: 1; pop.	assembler pushConstant: Stdout; sendNoCheck: #flush numArgs: 0; pop."	" Push on to stack: self __id __selector "	assembler putLoadReceiver: 0.	assembler putLoadInst: (aSmalltalkClass allInstVarNames indexOf: 'id') - 1 scope: 0.	assembler pushConstant: (ObjectiveCRuntime sel_getUid: aMethodName asString).	" Push arguments, converting if required "	(aProcedure type argumentNames allButFirst: 2) with: (aProcedure type argumentTypes allButFirst: 2) do: [:argument :type |		assembler pushLocal: argument.		argumentTypeCasts at: type ifPresent: [:conversion | assembler sendNoCheck: conversion numArgs: 0]].	" Call the primitive method "	assembler sendNoCheck: selector numArgs: aProcedure type numArgs.	" Convert the result "	resultTypeCasts at: aProcedure type resultType ifPresent: [:conversion | assembler sendNoCheck: conversion numArgs: 0].	" Return from the method "	assembler putMethodReturn.	method := assembler generateMethod.	method sourcePointer: (self generatePublicMethodSource: aMethodName procedure: aProcedure).	aSmalltalkClass addSelector: aMethodName withMethod: method category: 'api'</body><body package="ObjectiveCConnect">generatePublicMethodSource: aMethodName procedure: aProcedure	| stream resultConversion |	stream := String new writeStream.	stream nextPutAll: (self generateMethodSelector: aMethodName procedure: aProcedure).	stream cr; tab.	resultConversion := resultTypeCasts at: aProcedure type resultType ifAbsent: [nil].	stream nextPutAll: '^'.	(resultConversion notNil and: [aProcedure type numArgs &gt; 2]) ifTrue: [stream nextPutAll: '('].	stream nextPutAll: '&lt;primitive&gt; '.	(aMethodName includes: $:)		ifFalse:	[stream nextPutAll: aMethodName]		ifTrue:			[((aMethodName tokensBasedOn: $:) allButLast: 1) keysAndValuesDo: [:index :token |				token isEmpty					ifTrue:	[stream nextPutAll: 'with']					ifFalse:	[stream nextPutAll: token].				stream nextPutAll: ': '.				stream nextPutAll: (aProcedure type argumentNames at: (index + 2)).				argumentTypeCasts at: (aProcedure type argumentTypes at: (index + 2)) ifPresent: [:conversion | stream space; nextPutAll: conversion].				stream space].			stream skip: -1].	resultConversion ifNotNil:		[aProcedure type numArgs &gt; 2 ifTrue: [stream nextPutAll: ')'].		stream space; nextPutAll: resultConversion].	^stream contents</body></methods><methods><class-id>OS.ObjectiveCNameSpace class</class-id> <category>initialize</category><body package="ObjectiveCConnect">initialize	"self initialize"	CocoaBundles := OrderedCollection with: 'com.apple.AppKit'</body></methods><methods><class-id>OS.ObjectiveCCallback</class-id> <category>accessing</category><body package="ObjectiveCConnect">block	^block</body><body package="ObjectiveCConnect">block: anObject	block := anObject</body><body package="ObjectiveCConnect">object	^object</body><body package="ObjectiveCConnect">object: anObject	object := anObject</body><body package="ObjectiveCConnect">selector	^selector</body><body package="ObjectiveCConnect">selector: anObject	selector := anObject</body></methods><methods><class-id>OS.ObjectiveCCallback</class-id> <category>finalization</category><body package="ObjectiveCConnect">finalize	object release</body></methods><methods><class-id>OS.ObjectiveCCallback class</class-id> <category>private</category><body package="ObjectiveCConnect">callbackBlockFor: blockType	^Compiler evaluate: (Root.ObjectiveC generateCallbackMethodSource: blockType)</body><body package="ObjectiveCConnect">performCallback: aBlock for: id	"We cannot stay in the callback if we have any kind of error, so we ensure the callback completes before handling any errors."	| semaphore result callback |	semaphore := Semaphore new.	[[callback := (ObjectiveCCallback.Registry at: id referentAddress).	result := [aBlock value: callback block] on: Error do: [:exception | semaphore signal. exception pass]] ensure: [semaphore signal]] forkAt: CCallback.ForeignCallbackPriority.	semaphore wait.	^result</body><body package="ObjectiveCConnect">primitiveCallbackFor: blockType	^Callbacks at: blockType ifAbsentPut:		[ | callback rtti NSObject selector result |		callback := CCallback do: (self callbackBlockFor: blockType) ofType: blockType pointerType.		rtti := ObjectiveCRuntime typeEncoder encode: blockType.		NSObject := ObjectiveCRuntime getClassNamed: 'NSObject'.		selector := ('smalltalkCallback', callback identityHash printString) asSymbol.		result := ObjectiveCRuntime class_addMethod: NSObject with: selector __to_objc_SEL with: callback with: rtti.		result = ObjectiveCRuntime YES ifFalse: [self error: 'Could not register the callback'].		callback -&gt; selector]</body></methods><methods><class-id>OS.ObjectiveCCallback class</class-id> <category>instance creation</category><body package="ObjectiveCConnect">do: aBlock ofType: blockType	| callback object instance |	callback := self primitiveCallbackFor: blockType.	object := Root.ObjectiveC.NSObject alloc.	object init.	instance := self new		object: object;		selector: callback value;		block: aBlock;		yourself.	Registry at: object __id referentAddress put: instance.	^instance</body><body package="ObjectiveCConnect">do: aBlock resultType: aResultType argumentTypes: argumentTypes	^self do: aBlock ofType: (CProcedureType resultType: aResultType argumentTypes: argumentTypes argumentNames: ((1 to: argumentTypes size) collect: [:e | 'arg', e printString]))</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>accessing</category><body package="ObjectiveCConnect">__id	^id</body><body package="ObjectiveCConnect">__id: anId	id := anId</body><body package="ObjectiveCConnect">basicAt: index	"Answer the value of an indexable field in the receiver. Fail if the	argument index is not an Integer or is out of bounds. Do not override this	message in any subclass."	&lt;primitive: 60&gt;	index isInteger ifTrue: [^self subscriptBoundsErrorFor: #basicAt: index: index].	index respondsToArithmetic		ifTrue: [^self basicAt: index asSmallInteger]		ifFalse: [^self nonIntegerIndexError: index]</body><body package="ObjectiveCConnect">basicAt: index put: value	"Store the second argument value in the indexable field of the receiver	indicated by index. Fail if the index is not an Integer or is out of bounds. Or	fail if the value is not of the right type for this kind of collection. Answer	the value that was stored. Do not override in a subclass."	&lt;primitive: 61&gt;	index isInteger ifTrue:		[(index &gt;= 1 and: [index &lt;= self basicSize])			ifTrue:				[self isImmutable					ifTrue: [^self noModificationErrorFor: #basicAt:put: index: index value: value]					ifFalse: [^self improperStoreError]]			ifFalse: [^self subscriptBoundsErrorFor: #basicAt:put: index: index value: value]].	index respondsToArithmetic		ifTrue: [^self basicAt: index asSmallInteger put: value]		ifFalse: [^self nonIntegerIndexError: index]</body><body package="ObjectiveCConnect">basicSize	"Answer the number of indexable fields in the receiver. This value is the	same as the largest legal subscript. Do not override in any subclass."	&lt;primitive: 62&gt;	"The number of indexable fields of fixed-length objects is 0"	^0</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>comparing</category><body package="ObjectiveCConnect">= anObject	^anObject class == self class and: [anObject __id referentAddress = id referentAddress]</body><body package="ObjectiveCConnect">== anObject	"Answer true if the receiver and the argument are the same object (have the same	object pointer) and false otherwise.  Do not redefine the message == in any	other class!  No Lookup."	&lt;primitive: 110&gt;	self primitiveFailed</body><body package="ObjectiveCConnect">hash	id ifNil: [^0 hash].	^id referentAddress hash</body><body package="ObjectiveCConnect">identityHash	"Answer a SmallInteger that is equal to the identityHash of 	any object that is == to the receiver. 	When two objects are not ==, their identityHash values may or may not 	be the same. The identityHash value does not change across the life	of the object."	"If identityHash is redefined in a subclass, the new implementation must	answer the same identityHash when two objects are ==. Changing the	== method has no effect on the execution machinery -- in effect, you	cannot redefine == to echo a changed implementation of identityHash.	Primitive 75 fails for immediate objects, so immediate subclasses such as	SmallInteger must override this method."	&lt;primitive: 75&gt;	self primitiveFailed</body><body package="ObjectiveCConnect">~= anObject 	"Answer whether the receiver and the argument do not represent the same 	object."	^self = anObject == false</body><body package="ObjectiveCConnect">~~ anObject 	"Answer true if the receiver and the argument are not the same object 	(have the same object pointer) and false otherwise."	&lt;primitive: 109&gt;	^(self == anObject) not</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>converting</category><body package="ObjectiveCConnect">__isObjectiveCObject	^true</body><body package="ObjectiveCConnect">__to_objc_id	^id</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>class membership</category><body package="ObjectiveCConnect">changeClassTo: aClass	"Change the class of the receiver to aClass."	aClass adoptInstance: self.	^self</body><body package="ObjectiveCConnect">changeClassToThatOf: anObject 	"Change the class of the receiver to the class of anObject. Fail if either the	 receiver or anObject is immutable (which includes immediates), 	 or if none of the following cases holds:	1. The receiver and anObject are both byte-type.	2. The receiver is any pointer-type object, anObject is a		non-indexable pointer-type object, and the storage sizes (i.e. the		number of named instance variables plus the number of indexed		instance variables, if any) of the two objects are the same.	3. The receiver is any pointer-type object, anObject is an indexable		pointer-type object, and the storage size of the receiver is at least		as large as the number of named instance variables of anObject.	Compare with the adoptInstance: primitive."	&lt;primitive: 535 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #changeClassToThatOf: index: nil value: anObject]		ifFalse: [self primitiveFailed]</body><body package="ObjectiveCConnect">class	"Answer the object which is the receiver's class."	&lt;primitive: 111&gt;	self primitiveFailed</body><body package="ObjectiveCConnect">isKindOf: aClass 	"Answer a Boolean as to whether the class, aClass, is a superclass or class of	the receiver."	^self class includesBehavior: aClass</body><body package="ObjectiveCConnect">respondsTo: aSymbol 	"Answer a Boolean as to whether the method dictionary of the receiver's class 	contains aSymbol as a message selector."	^self class canUnderstand: aSymbol</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>error handling</category><body package="ObjectiveCConnect">doesNotUnderstand: aMessage 	^MessageNotUnderstood new		parameter: aMessage;		messageText: [| selectorString |			selectorString :=				[aMessage selector printString]					on: Error					do: [:ex |						ex return:							(#errSelectorNotPrintable &lt;&lt; #dialogs &gt;&gt; '** unprintable selector **')							expandMacros asString].			(#errNotUnderstood &lt;&lt; #dialogs &gt;&gt; 'Message not understood: &lt;1s&gt;')				expandMacrosWith: selectorString];		raiseSignal.</body><body package="ObjectiveCConnect">handleFailedBecome: otherObject 	"Called if the primBecome: primitive fails. This primitive can fail for	one of the following reasons: 	1. Either object is immutable (which includes immediate objects)	2. Either object is a MethodContext 	3. Either object is a BlockContext 	4. If there is insufficient memory to perform the become. 	In the first three cases, raise an error. In the latter case, attempt to 	make space and try again."	| recClass argClass  bytesInOop om overheadBytes recBytes argBytes |	(self isImmutable	or: [otherObject isImmutable]) ifTrue:		[^Error raiseSignal: (#cannotBecomeObject &lt;&lt; #dialogs &gt;&gt; 'cannot use become: on immutable objects')].	((recClass := self class) == MethodContext	 or: [(argClass := otherObject class) == MethodContext]) ifTrue:		[^Error raiseSignal: (#cannotBecomeMethod &lt;&lt; #dialogs &gt;&gt; 'cannot use become: on a MethodContext')].	(recClass == BlockContext or: [argClass == BlockContext]) ifTrue:		[^Error raiseSignal: (#cannotBecomeBlock &lt;&lt; #dialogs &gt;&gt; 'cannot use become: on a BlockContext')].	om := ObjectMemory current.	bytesInOop := om bytesPerOOP.	overheadBytes := om bytesPerOTE + bytesInOop.	"Includes size-overflow field"	recBytes := recClass isBits					ifTrue: [self basicSize]					ifFalse: [(self basicSize + recClass instSize) * bytesInOop].	argBytes := argClass isBits					ifTrue: [otherObject basicSize]					ifFalse: [(otherObject basicSize + argClass instSize) * bytesInOop].	ObjectMemory makeSpaceFor: overheadBytes + recBytes + overheadBytes + argBytes.	^self becomeNoRetry: otherObject</body><body package="ObjectiveCConnect">improperStoreError	"Create an error notification that an improper store was attempted."	Error raiseSignal: (#errImproperIndex &lt;&lt; #dialogs &gt;&gt; 'Improper store into indexable object')</body><body package="ObjectiveCConnect">mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the VM."	SystemNotification		raiseRequestWith: thisContext		errorString: (#nonBoolReceiver &lt;&lt; #dialogs &gt;&gt; 'NonBoolean receiver--proceed for truth.').	^true</body><body package="ObjectiveCConnect">noModificationErrorFor: selector index: index value: value	^(NoModificationError receiver: self selector: selector index: index value: value) raiseRequest</body><body package="ObjectiveCConnect">nonIntegerIndexError: index	"Raise a signal indicating that an improper object was used as an index."	^Object nonIntegerIndexSignal raiseWith: index</body><body package="ObjectiveCConnect">primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	Error raiseSignal: (#errPrimitiveFailed &lt;&lt; #dialogs &gt;&gt; 'a primitive has failed')</body><body package="ObjectiveCConnect">subscriptBoundsErrorFor: selector index: index	"Raise a signal indicating that an improper index was used as an index in a send of selector with index."	^(SubscriptOutOfBoundsError receiver: self selector: selector index: index value: nil) raiseRequest</body><body package="ObjectiveCConnect">subscriptBoundsErrorFor: selector index: index value: aValue	"Raise a signal indicating that an improper index was used as an index in a send of selector with index and aValue."	^(SubscriptOutOfBoundsError receiver: self selector: selector index: index value: aValue) raiseRequest</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>testing</category><body package="ObjectiveCConnect">isBehavior	"Answer whether the object can be the 'class' of another object"	^false</body><body package="ObjectiveCConnect">isImmediate	"Answer true if this object has immediate representation."	"Currently, SmallInteger and Character are represented as	immediate (or zero-sized storage) objects."	^self class hasImmediateInstances</body><body package="ObjectiveCConnect">isImmutable	"Answer if the receiver is immutable.  This is always true of immediates.	 Cannot fail."	&lt;primitive: 1063&gt;	^false</body><body package="ObjectiveCConnect">isNil	"Coerce nil to true and everything else to false.  UndefinedObject 	overrides with ^true"	^false</body><body package="ObjectiveCConnect">isVariableBinding 	^false</body><body package="ObjectiveCConnect">notNil	"Coerce nil to false and everything else to true.  UndefinedObject 	overrides with ^false"	^true</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>user interface</category><body package="ObjectiveCConnect">inspect	"Create and schedule an Inspector in which the user can examine the	receiver's variables."	Tools.Trippy.Inspector useSimpleInspector		ifTrue: [self inspectorClass openOn: self]		ifFalse: [Tools.Trippy.Inspector openOn: self]</body><body package="ObjectiveCConnect">inspectorActions	"Answer a collection of Action instances listing the common actions	a user might want to perform on an object. They are added to the 	inspector's Object menu."	^#()</body><body package="ObjectiveCConnect">inspectorClass	^Inspector</body><body package="ObjectiveCConnect">inspectorClasses	"Answer a sequence of inspector classes that can represent the receiver in an	inspector. The first page in the array is the one used by default in a new inspector."	^Array with: Tools.Trippy.BasicInspector</body><body package="ObjectiveCConnect">inspectorCollaborators	"Answer a collection of Collaborator instances listing the important other	objects a person looking at this one might want to see. For example,	collaborators of a view would be its model and the controller.	Collaborators are added to the inspector's Go menu."	^#()</body><body package="ObjectiveCConnect">inspectorExtraAttributes	"Subclasses may reimplement this to answer a sequence of	DerivedAttribute or TextAttribute instances that should show up	in the inspector in addition to named instance variables and	indexed variables. See implementors for an example."	^#()</body><body package="ObjectiveCConnect">inspectorHierarchies	"Answer a collection of instances of Hierarchy describing the hierarchies	this object is a member of."	^#()</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>private</category><body package="ObjectiveCConnect">becomeNoRetry: otherObject 	"Swap the instance data and appropriate header information of the receiver and the	argument, otherObject. In other words, transform the receiver into the argument and	vice-versa.  Fail if either object is an immediate or a MethodContext or a	BlockContext or if there is insufficient memory to perform the become. Answer	with the argument which is now the semantic equivalent of the object that formerly	denoted the receiver."	&lt;primitive: 72 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #becomeNoRetry: index: nil value: otherObject]		ifFalse: [self primitiveFailed]</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>system primitives</category><body package="ObjectiveCConnect">beImmutable	"Set the receiver to be immutable"	self isImmutable: true.	^self</body><body package="ObjectiveCConnect">beMutable	"Set the receiver to be mutable"	self isImmutable: false.	^self</body><body package="ObjectiveCConnect">become: otherObject " Swap the state of the receiver with that of anObject."	self primBecome: otherObject</body><body package="ObjectiveCConnect">instVarAt: index	"Answer with a fixed variable in an object.  The numbering of the variables	corresponds to the named instance variables.  Fail if the index is not an	Integer or is not the index of a fixed variable."	&lt;primitive: 73&gt;	"Access beyond fixed variables."	^self basicAt: index - self class instSize</body><body package="ObjectiveCConnect">instVarAt: anInteger put: anObject	"Store a value into a fixed variable in the receiver.  The numbering of	 the variables corresponds to the named instance variables.  Fail if	 the index is not an Integer or is not the index of a fixed variable, or	 if the receiver is immutable. Answer with the value stored as the result.	 (Using this message violates the principle that each object has sovereign	 control over the storing of values into its instance variables.)."	&lt;primitive: 74&gt;	self isImmutable ifTrue:		[^self noModificationErrorFor: #instVarAt:put: index: anInteger value: anObject].	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject</body><body package="ObjectiveCConnect">isImmutable: aBoolean	"Set the receiver's immutability.   Answer if the receiver was	 previously immutable.  Fail if the argument is not a boolean	 or if the receiver is immediate and the argument is false."	&lt;primitive: 1064 errorCode: error&gt;	^self primitiveFailed</body><body package="ObjectiveCConnect">primBecome: otherObject 	"Swap the instance data and appropriate header information of the receiver and the	 argument, otherObject. In other words, transform the receiver into the argument and	 vice-versa.  Fail if either object is an immediate or a MethodContext or a	 BlockContext or if there is insufficient memory to perform the become, or if either	 object is immutable. Answer with the argument which is now the semantic equivalent	 of the object that formerly denoted the receiver."	&lt;primitive: 72 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #primBecome: index: nil value: otherObject]		ifFalse: [self handleFailedBecome: otherObject]</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>printing</category><body package="ObjectiveCConnect">basicPrintOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printString.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body><body package="ObjectiveCConnect">basicPrintString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self basicPrintOn: aStream.	^aStream contents</body><body package="ObjectiveCConnect">printOn: aStream	(id isNil or: [id isValid not]) ifTrue: [^aStream nextPutAll: 'an Invalid ObjectiveC Object'].	aStream nextPutAll: (self description UTF8String copyCStringFromHeap: #UTF8)</body><body package="ObjectiveCConnect">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>message handling</category><body package="ObjectiveCConnect">perform: aSymbol	"Send the receiver the unary message indicated by the argument. The argument is	 the selector of the message.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect zero arguments."	&lt;primitive: 511&gt;	^self perform: aSymbol withArguments: (Array new: 0)</body><body package="ObjectiveCConnect">perform: aSymbol with: anObject 	"Send the receiver the keyword or binary message indicated by the 	 arguments. The first argument is the selector of the message. The other 	 argument is the argument of the message to be sent.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect one argument."	&lt;primitive: 512&gt;	^self perform: aSymbol withArguments: (Array with: anObject)</body><body package="ObjectiveCConnect">perform: aSymbol with: firstObject with: secondObject	"Send the receiver the keyword message indicated by the arguments. The first	 argument is the selector of the message. The other arguments are the	 arguments of the message to be sent.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect two arguments."	&lt;primitive: 513&gt;	^self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)</body><body package="ObjectiveCConnect">perform: aSymbol with: firstObject with: secondObject with: thirdObject	"Send the receiver the keyword message indicated by the arguments. The first	 argument is the selector of the message.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect three arguments."	&lt;primitive: 514&gt;	^self perform: aSymbol withArguments: (Array			with: firstObject			with: secondObject			with: thirdObject)</body><body package="ObjectiveCConnect">perform: selector withArguments: anArray	"Send the receiver the message indicated by the arguments. The argument	 selector is the selector of the message. The arguments of the message are	 the elements of anArray.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if anArray is not an Array with the same number of elements as	 the number of arguments expected by the looked-up method."	&lt;primitive: 510&gt;	^self primitiveFailed</body><body package="ObjectiveCConnect">performMethod: method	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The method must be expecting no arguments."	^self performMethod: method arguments: #()</body><body package="ObjectiveCConnect">performMethod: method arguments: args	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the list of arguments of the method.	The number of arguments expected by the method must match the size of the	Array."	^method valueWithReceiver: self arguments: args</body><body package="ObjectiveCConnect">performMethod: method with: arg1	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the argument of the method. The method	must be expecting one argument."	^self performMethod: method arguments: (Array with: arg1)</body><body package="ObjectiveCConnect">performMethod: method with: arg1 with: arg2	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other arguments are the arguments of the method. The method	must be expecting two arguments."	^self performMethod: method arguments: (Array with: arg1 with: arg2)</body><body package="ObjectiveCConnect">performMethod: method with: arg1 with: arg2 with: arg3	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other arguments are the arguments of the method. The method	must be expecting three arguments."	^self performMethod: method arguments: (Array with: arg1 with: arg2 with: arg3)</body></methods><methods><class-id>OS.ObjectiveCObject</class-id> <category>controlling</category><body package="ObjectiveCConnect">ifNil: aBlock	"Return the receiver if it is not nil, or evaluate the block	and return the result if the receiver is nil."	^self</body><body package="ObjectiveCConnect">ifNil: nilBlock ifNotNil: notNilBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.	 UndefinedObject redefines this to answer the evaluation of nilBlock, and hence	 since here the receiver is not nil answer the evaluation of notNilBlock."	^0 == notNilBlock numArgs		ifTrue: [notNilBlock value]		ifFalse: [notNilBlock value: self]</body><body package="ObjectiveCConnect">ifNotNil: aBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.  Since the receiver is not nil,	 answer aBlock's evaluation.  Passing the receiver to aBlock is handy for idioms	 such as		self toolBarSpec ifNotNil: [:spec | ...].	UndefinedObject reimplements this to not evaluate aBlock."	^0 == aBlock numArgs		ifTrue: [aBlock value]		ifFalse: [aBlock value: self]</body><body package="ObjectiveCConnect">ifNotNil: notNilBlock ifNil: nilBlock	"If the receiver is not nil, answer the evaluation of notNilBlock (with the	 receiver as its argument if it takes one), otherwise answer the evaluation	 of nilBlock.  UndefinedObject redefines this to answer the evaluation of nilBlock,	 and hence since here the receiver is not nil answer the evaluation of notNilBlock."	^0 == notNilBlock numArgs		ifTrue: [notNilBlock value]		ifFalse: [notNilBlock value: self]</body></methods><methods><class-id>OS.ObjectiveCObject class</class-id> <category>external interface</category><body package="ObjectiveCConnect">isVirtual	^false</body><body package="ObjectiveCConnect">libraryFiles	^ObjectiveCRuntime class libraryFiles</body><body package="ObjectiveCConnect">libraryFilesSearchSignals	^ObjectiveCRuntime class libraryFilesSearchSignals</body></methods><methods><class-id>OS.ObjectiveCObject class</class-id> <category>accessing</category><body package="ObjectiveCConnect">__id	^id</body><body package="ObjectiveCConnect">__id: anId	id := anId</body></methods><methods><class-id>OS.ObjectiveCObject class</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_Class	^id</body><body package="ObjectiveCConnect">__to_objc_id	^id</body></methods><methods><class-id>Core.Integer</class-id> <category>converting</category><body package="ObjectiveCConnect">__from_objc_BOOL	^self = ObjectiveCRuntime YES</body><body package="ObjectiveCConnect">__from_objc_id	^self __to_objc_id __from_objc_id</body><body package="ObjectiveCConnect">__to_objc_id	^ObjectiveCRuntime id newOfAddress: self</body></methods><methods><class-id>Core.False</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_BOOL	^0</body></methods><methods><class-id>OS.ObjectiveCRuntimeTypeEncoder</class-id> <category>initialize-release</category><body package="ObjectiveCConnect">initialize	"*** OVERRIDDEN *** removed the 'b' type, which is bitfield because OSX Objective-C #instanceMethodSignatureForSelector: does not  currently support bitfields."	"Initialize the values we can. 4 values are runtime specific and should be set by the instantiating object."	super initialize.	typeTable := Dictionary new.	typeTable		at: self _C_CHR put: CIntegerType signedChar;		at: self _C_UCHR put: CIntegerType unsignedChar;		at: self _C_SHT put: CIntegerType signedShort;		at: self _C_USHT put: CIntegerType unsignedShort;		at: self _C_INT put: CIntegerType signedInt;		at: self _C_UINT put: CIntegerType unsignedInt;		at: self _C_LNG put: CIntegerType signedLong;		at: self _C_ULNG put: CIntegerType unsignedLong;		at: self _C_LNG_LNG put: CIntegerType signedLongLong;		at: self _C_ULNG_LNG put: CIntegerType unsignedLongLong;		at: self _C_FLT put: CLimitedPrecisionRealType float;		at: self _C_DBL put: CLimitedPrecisionRealType double;		at: self _C_VOID put: CVoidType void;		at: self _C_UNDEF put: CVoidType void;		at: self _C_CHARPTR put: CIntegerType unsignedChar pointerType</body></methods><methods><class-id>Kernel.AssemblerCodeStream</class-id> <category>accessing</category><body package="ObjectiveCConnect">forMethod: argNames methodClass: aMethodClass	methodClass := aMethodClass.	self arguments: (argNames collect: [:s | VariableNode new name: s])</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="ObjectiveCConnect">__from_objc_BOOL	^self error: 'cannot convert from ObjectiveCRuntime BOOL'</body><body package="ObjectiveCConnect">__from_objc_Class	^self error: 'cannot convert from ObjectiveCRuntime Class'</body><body package="ObjectiveCConnect">__from_objc_id	^self error: 'cannot convert from ObjectiveCRuntime id'</body><body package="ObjectiveCConnect">__from_objc_NSPoint	^self error: 'cannot convert from ObjectiveCRuntime _NSPoint'</body><body package="ObjectiveCConnect">__from_objc_NSRange	^self error: 'cannot convert from ObjectiveCRuntime _NSRange'</body><body package="ObjectiveCConnect">__from_objc_NSRect	^self error: 'cannot convert from ObjectiveCRuntime _NSRect'</body><body package="ObjectiveCConnect">__from_objc_NSSize	^self error: 'cannot convert from ObjectiveCRuntime _NSSize'</body><body package="ObjectiveCConnect">__from_objc_SEL	^self error: 'cannot convert from ObjectiveCRuntime SEL'</body><body package="ObjectiveCConnect">__isObjectiveCObject	^false</body><body package="ObjectiveCConnect">__to_objc_BOOL	^self error: 'cannot convert to ObjectiveCRuntime BOOL'</body><body package="ObjectiveCConnect">__to_objc_Class	^self error: 'cannot convert to ObjectiveCRuntime Class'</body><body package="ObjectiveCConnect">__to_objc_double	^self error: 'cannot convert to double'</body><body package="ObjectiveCConnect">__to_objc_float	^self error: 'cannot convert to float'</body><body package="ObjectiveCConnect">__to_objc_id	^self error: 'cannot convert to ObjectiveCRuntime id'</body><body package="ObjectiveCConnect">__to_objc_int	^self error: 'cannot convert to int'</body><body package="ObjectiveCConnect">__to_objc_NSPoint	^self error: 'cannot convert to _NSPoint'</body><body package="ObjectiveCConnect">__to_objc_NSRange	^self error: 'cannot convert to _NSRange'</body><body package="ObjectiveCConnect">__to_objc_NSRect	^self error: 'cannot convert to _NSRect'</body><body package="ObjectiveCConnect">__to_objc_NSSize	^self error: 'cannot convert to _NSSize'</body><body package="ObjectiveCConnect">__to_objc_SEL	^self error: 'cannot convert to ObjectiveCRuntime SEL'</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_id	^self asString __to_objc_id</body><body package="ObjectiveCConnect">__to_objc_SEL	^ObjectiveCRuntime sel_getUid: self asString</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_double	^self asDouble</body><body package="ObjectiveCConnect">__to_objc_float	^self asFloat</body><body package="ObjectiveCConnect">__to_objc_int	^self asInteger</body></methods><methods><class-id>Core.Point</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_NSPoint	^ObjectiveCRuntime _NSPoint new		memberAt: #x put: x;		memberAt: #y put: y;		yourself</body><body package="ObjectiveCConnect">__to_objc_NSSize	^ObjectiveCRuntime _NSSize new		memberAt: #width put: x;		memberAt: #height put: y;		yourself</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_id	^nil</body><body package="ObjectiveCConnect">__to_objc_SEL	^nil</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="ObjectiveCConnect">transformRootObjectiveCToNameSpace	[ | mutation |	Root.ObjectiveC changeClassTo: Array.	mutation := Root.ObjectiveC first: NameSpace instSize.	Root.ObjectiveC become: mutation.	NameSpace adoptInstance: Root.ObjectiveC.	Root.ObjectiveC initialize.	SystemUtils linkSystem]		valueUnpreemptively</body><body package="ObjectiveCConnect">transformRootObjectiveCToObjectiveCNameSpace	[Root.ObjectiveC changeClassTo: Array.	Root.ObjectiveC changeSizeTo: ObjectiveCNameSpace instSize.	ObjectiveCNameSpace adoptInstance: Root.ObjectiveC.	Root.ObjectiveC initialize.	SystemUtils linkSystem]		valueUnpreemptively</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_NSRect	| rect  |	rect := ObjectiveCRuntime _NSRect new.	rect memberAt: #origin put: (self origin __to_objc_NSPoint).	rect memberAt: #size put: (self extent __to_objc_NSSize).	^rect</body></methods><methods><class-id>External.CCompositePointer</class-id> <category>converting</category><body package="ObjectiveCConnect">__from_objc_Class	^Root.ObjectiveC interfaceAt: self ifAbsent: [nil]</body><body package="ObjectiveCConnect">__from_objc_id	| objc_class |	self isNull ifTrue: [^nil].	objc_class := Root.ObjectiveC interfaceAt: (self memberAt: #isa) ifAbsent: [ObjectiveCObject].	^objc_class new __id: self</body><body package="ObjectiveCConnect">__from_objc_SEL	^(ObjectiveCRuntime sel_getName: self) copyCStringFromHeap asSymbol</body><body package="ObjectiveCConnect">__to_objc_Class	^self</body><body package="ObjectiveCConnect">__to_objc_id	^self</body><body package="ObjectiveCConnect">__to_objc_SEL	^self</body></methods><methods><class-id>Core.True</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_BOOL	^1</body></methods><methods><class-id>Core.CharacterArray class</class-id> <category>converting</category><body package="ObjectiveCConnect">fromNSString: aNSString	^aNSString UTF8String copyCStringFromHeap: #utf8</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_id	^(Root.ObjectiveC.NSString		stringWithCharacters: (self asByteArrayEncoding: #utf16)		length: self size)			__to_objc_id</body><body package="ObjectiveCConnect">asNSString	^self __to_objc_id __from_objc_id</body></methods><methods><class-id>External.CComposite</class-id> <category>converting</category><body package="ObjectiveCConnect">__from_objc_NSPoint	^(self memberAt: #x) @ (self memberAt: #y)</body><body package="ObjectiveCConnect">__from_objc_NSRange	^(self memberAt: #location) to: ((self memberAt: #location) + (self memberAt: #length) - 1)</body><body package="ObjectiveCConnect">__from_objc_NSRect	^(self memberAt: #origin) __from_objc_NSPoint extent: (self memberAt: #size) __from_objc_NSSize</body><body package="ObjectiveCConnect">__from_objc_NSSize	^(self memberAt: #width) @ (self memberAt: #height)</body><body package="ObjectiveCConnect">__to_objc_NSPoint	^self</body><body package="ObjectiveCConnect">__to_objc_NSRange	^self</body><body package="ObjectiveCConnect">__to_objc_NSRect	^self</body><body package="ObjectiveCConnect">__to_objc_NSSize	^self</body></methods><methods><class-id>Core.Interval</class-id> <category>converting</category><body package="ObjectiveCConnect">__to_objc_NSRange	^ObjectiveCRuntime _NSRange new		memberAt: #location put: self first;		memberAt: #length put: self size;		yourself</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="ObjectiveCConnect">configureObjectiveCConnect	&lt;triggerAtSystemEvent: #returnFromSnapshot&gt;	#{ObjectiveCCallback.Callbacks} initialize.	#{ObjectiveCCallback.Registry} initialize.	OSSystemSupport concreteClass ~~ MacOSXSystemSupport ifTrue:		[Root.ObjectiveC class ~~ NameSpace ifTrue: [self transformRootObjectiveCToNameSpace].		^self].	Root.ObjectiveC class == NameSpace ifTrue: [self transformRootObjectiveCToObjectiveCNameSpace].	Root.ObjectiveC configure</body></methods><initialize><class-id>OS.ObjectiveCNameSpace</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ObjectiveCRuntimeTypeEncoder</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-MacOSX</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CComposite</name><environment>External</environment><super>External.CDatum</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>True</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>AssemblerCodeStream</name><environment>Kernel</environment><super>Kernel.ByteCodeStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodClass needsFrame hybrid forContext method innerBlocks allowNewLiterals copiedVars segments owner outerStream </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Assembler</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>CCompositePointer</name><environment>External</environment><super>External.CPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>