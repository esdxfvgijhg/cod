<?xml version="1.0"?><st-source><!-- Name: StoreForGlorpReplicationNotice: Copyright 2005 - 2016 Cincom Systems, Inc.  All Rights Reserved.Comment: This defines a mechanism for replicating packages and bundles between different Store databases using the StoreForGlorp schema. This attempts to implement the underpinnings of a UI, but remain portable. (For an actual UI see StoreForGlorpReplicationUI.)DbIdentifier: bear73DbTrace: 491476DbUsername: dwallenDbVersion: 8.2 - 2DevelopmentPrerequisites: #(#(#bundle 'Glorp' '') #(#bundle 'StoreBase' ''))PackageName: StoreForGlorpReplicationParcel: #('StoreForGlorpReplication')ParcelName: StoreForGlorpReplicationPrerequisiteParcels: #(#('Glorp' '') #('StoreBase' ''))PrintStringCache: (8.2 - 2,dwallen)Version: 8.2 - 2Date: 1:32:15 PM June 3, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.1) of June 3, 2016 on June 3, 2016 at 1:32:15 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NoReplicationLog</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.NoReplicationLog</class-id><body>I receive events from replicators and log them. What logging means depends on me. By default it means do nothing.</body></comment><class><name>ProgressNotifierLog</name><environment>Store.Glorp</environment><super>Store.Glorp.NoReplicationLog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.ProgressNotifierLog</class-id><body>I log things by incrementing the progress status for each thing that happens, probably meaning that there's a progress dialog reflecting this.</body></comment><class><name>StoreAutoReplicator</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>replicator rules period process cachedSessions busy ruleFileName cutOffTimestamp quitAfterReplicating </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.StoreAutoReplicator</class-id><body>This automatically replicates between repositories, based on a set of rules. It can also run regularly as a background process to keep the repositories in sync.Instance Variables:	replicator	&lt;StoreReplicator&gt; The thing actually doing the replicating.	rules	&lt;(Collection of: ReplicationRule)&gt; The rules describing which things to replicate.	period	&lt;Integer&gt; Every "period" minutes, run the replication.	process	&lt;Process&gt; The background process running the replication.	cachedSessions	&lt;Object&gt; undocumented	busy	&lt;Object&gt; undocumented	ruleFileName	&lt;Object&gt; undocumented	cutOffTimestamp	&lt;Timestamp&gt; ignore any versions that are older than thisClass Instance Variables:	default	&lt;Object&gt; undocumented</body></comment><class><name>ReplicatorPundleWriter</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePundleWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startTime endTime duration parent targetDatabaseIdentifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.ReplicatorPundleWriter</class-id><body>This writes (either by replicating from another database, or direct from memory)  an individual bundle or package version.Instance Variables:	parent	&lt;StoreReplicator&gt;	The replicator controlling the overall process. If not replicating, this may just be a stub.	pundle	&lt;StorePundle&gt;	The thing we're writing.	newPundle	&lt;StorePundle&gt;	The new pundle we've created, ready to be written to the database.	previousVersionInTargetDatabase	&lt;StorePundle&gt;	The previous version, if there is one.	targetSession &lt;GlorpSession&gt; The target database.	startTime &lt;Time&gt; When we started this operation.	endTime &lt;Time&gt; When we finished this operation.	duration &lt;Integer&gt; The number of seconds between endTime and startTime</body></comment><class><name>StoreReplicationManager</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceLogin targetLogin bundles packages replicator gui backgroundProcess semaphore pundleQueue sourceSession topLevelOnly retrieveBundles retrievePackages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.StoreReplicationManager</class-id><body>This is trying to abstract out the core of a GUI for managing replication, kept independent of the particular GUI framework so that it can be portable.Instance Variables:	backgroundProcess	&lt;Process&gt;	The background replication process.	bundles	&lt;Collection of: StoreBundle&gt;	Bundles to be replicated.	gui	&lt;ReplicationUI&gt;	The actual gui that we're the back end for.	packages	&lt;Collection of: StorePackage&gt;	Packages to be replicated	pundleQueue	&lt;SharedQueue&gt;	The queue of packages/bundles to be handled by the background process.	replicator	&lt;StoreReplicator&gt;	The thing actually doing the replication.	retrieveBundles	&lt;Boolean&gt;	Do we look for bundles matching our search criteria?	retrievePackages	&lt;Boolean&gt;	Do we look for packages matching our search criteria?	semaphore	&lt;Semaphore&gt;	Semaphore used to tell us when we're done replicating.	sourceLogin	&lt;Login&gt;	The source database	sourceSession	&lt;GlorpSession&gt;	source that we read things from for the user interface. Note that this isn't used in replication, it's just for the UI.	targetLogin	&lt;Login&gt;	The target database	topLevelOnly	&lt;Boolean&gt;	Do we search for top-level pundles only? Top-level means not contained, in their most recent version, inside a bundle.</body></comment><class><name>LogToFile</name><environment>Store.Glorp</environment><super>Store.Glorp.NoReplicationLog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.LogToFile</class-id><body>This is a log created for headless logging into a file when running the replicator as a cron job. The full log is way too chatty if you intend to review the logs from time to time, so this one tries to be more conscise while still providing sufficient amount of feedback. (Tips how to set up a replication cron job follow)For example it logs each processed pundle on one line as it goes in the form of	pundle -&gt;repo1-&gt;, -&gt;repo2-&gt;, ...where each arrow indicates the replication direction being processed at any given moment. So you can actually monitor the progress if you tail -f the log file.Here is how I got the replication going as a cron job on a Linux box. First of course you need to build a replicator image (in my case I have it in $HOME/st/replicator directory). Then create a text file with replication rules (rules.txt), the format is the same you use in the rules settings tab, one rule per line. Don't forget to set HeadlessLog as the log type in replication settings (or any other log type you might prefer).Then I created a replicate shell script ($HOME/bin/replicate) that looks like this:#!/bin/shcd $HOME/st/replicatorexport LD_LIBRARY_PATH=$LD_LIBRARAY_PATH:/opt/oracle/10g2/32/client/opt/bin/vw741 \	 -nologo replicator.im -nogui \	-replicateOnce \	-replicationRules rules.txt \	&gt;&gt; replicator.logThe /opt/bin/vw741 is another shell script for running the right VW VM. Here is mine for completeness:#!/bin/bashexport VISUALWORKS=/opt/vw7.4.1$VISUALWORKS/bin/linux86/vwlinux86 "$@"The export command in the replication script is necessary so that VW can find the Oracle 10g Instant Client libraries. As you can see the log output is redirected into a file replicator.log in the image directory. As I mentioned earlier, you can monitor replication progress by opening a terminal, changing to the image directory and issuing 'tail -f replicator.log' command.Finally we need to add a cron job entry. Execute crontab -e command which opens an editor (possibly vi) and add the following line there	0 8-20 * * Mon-Fri $HOME/bin/replicateThis means that at 0 minutes from 8am to 8pm, Monday to Friday run the shell script. Save the file and exit the editor and you should be all set.Instance Variables:	pundle	&lt;String&gt; currently processed pundle</body></comment><class><name>ReplicationRule</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isBundle name primary secondaries oneWay </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.ReplicationRule</class-id><body>This describes a rule for replicating between different store databases.Instance Variables:	isBundle	&lt;Boolean&gt;	Is this a bundle or a package.	name	&lt;String&gt;	The name of the pundle.	primary	&lt;String&gt;	The name (as a saved store login) of the primary database.	secondaries	&lt;(SequenceableCollection of: String)&gt;	The name of all the secondary databases. Replication will be bidirectional between the primary and each of the secondaries. Note that secondaries won't be replicated to each other. This is to accomodate the case of a local primary repository and multiple remote secondaries.</body></comment><class><name>StoreReplicator</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceSession sourceDatabaseIdentifier targetSession targetDatabaseIdentifier replicationLog maximumRetries numberToReplicateAtOnce replicateOnlyOriginalVersions replicateRecursively shouldFixExistingVersions skipOldVersions sourcePundleIdentifiers targetPundleIdentifiers knownInvalid alreadyCheckedBundles alreadyCheckedPackages oldestMatchingVersion hasIndexes isBundle depth retries targetVersionName parentVersionName </inst-vars><class-inst-vars>replicationLog </class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.StoreReplicator</class-id><body>This lets you replicate a package or bundle from one store database to another.Instance Variables:	sourceSession	&lt;GlorpSession&gt; description of sourceSession	replicateRecursively	&lt;Boolean&gt; description of replicateRecursively	numberToReplicateAtOnce	&lt;Magnitude&gt; description of numberToReplicateAtOnce	targetSession	&lt;GlorpSession&gt; description of targetSession	isBundle	&lt;Object&gt; undocumented	retries	&lt;Object&gt; undocumented	maximumRetries	&lt;Object&gt; undocumented	knownInvalid	&lt;Object&gt; undocumented	sourcePundleIdentifiers	&lt;Object&gt; undocumented	targetPundleIdentifiers	&lt;Object&gt; undocumented	hasIndexes	&lt;Object&gt; undocumented	skipOldVersions	&lt;Boolean&gt; If true, don't go back any further than the oldest matching version in the two databases. Assume that the old ones represent versions that are in both databases, but were published independently rather than replicated.	oldestMatchingVersion	&lt;Object&gt; undocumented	shouldFixParents	&lt;Object&gt; undocumented	replicationLog	&lt;ReplicationLog&gt; the receiver of replication events	targetVersionName &lt;String&gt; If this is non-nil, then we're replicating and renaming the version, so use this name for all target versions.	Class Instance Variables:	replicationLog	&lt;ReplicationLog&gt; the default log instance</body></comment><class><name>RenamingRule</name><environment>Store.Glorp</environment><super>Store.Glorp.ReplicationRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceVersion targetVersion parentVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.RenamingRule</class-id><body>This is a rule which replicates while renaming. It expects to replicate exactly one version.</body></comment><class><name>GlorpReplicationDontBotherToDoThisQuery</name><environment>Store.Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.GlorpReplicationDontBotherToDoThisQuery</class-id><body>In the replication UI we can build up some complex queries. Some of these may end up not making any sense, e.g. we're looking for packages that have sub-bundles satisfying some criteria. Rather than trying to weed out these conditions in advance, we raise an exception when preparing to execute the query, telling the caller that they shouldn't expect any results from it, and we won't bother executing.</body></comment><class><name>FullTranscriptLog</name><environment>Store.Glorp</environment><super>Store.Glorp.NoReplicationLog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>StoreForGlorpReplication</package></attributes></class><comment><class-id>Store.Glorp.FullTranscriptLog</class-id><body>I log all the events to the Transcript.</body></comment><methods><class-id>Store.Glorp.NoReplicationLog</class-id> <category>events</category><body package="StoreForGlorpReplication">finishingActivity: aString duration: ms</body><body package="StoreForGlorpReplication">startingActivity: aString</body></methods><methods><class-id>Store.Glorp.NoReplicationLog</class-id> <category>events-auto replicator</category><body package="StoreForGlorpReplication">autoReplicateLoginError: anException</body><body package="StoreForGlorpReplication">autoReplicateLoginError: anException from: sourceName to: targetName</body><body package="StoreForGlorpReplication">autoReplicating: aPundleName from: sourceName to: targetName</body><body package="StoreForGlorpReplication">autoReplicatingFrom: sourceName to: targetName</body><body package="StoreForGlorpReplication">finishedAutoReplicationAt: aTime</body><body package="StoreForGlorpReplication">startingAutoReplicationAt: aTime</body></methods><methods><class-id>Store.Glorp.NoReplicationLog</class-id> <category>events-individual pundle replicator</category><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration</body><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration depth: anInteger 	self finishedReplicationOf: aPundle time: endTime duration: duration</body><body package="StoreForGlorpReplication">invalidPundle: aPundle</body><body package="StoreForGlorpReplication">patchingParentFor: targetPundle</body><body package="StoreForGlorpReplication">reconcilingPundle: aPundle</body><body package="StoreForGlorpReplication">skipping: aPundle time: aTime</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime depth: anInteger	self startingReplicationOf: aPundle time: aTime</body><body package="StoreForGlorpReplication">updatingBlessingsFor: targetPundle</body></methods><methods><class-id>Store.Glorp.NoReplicationLog</class-id> <category>events-replicator</category><body package="StoreForGlorpReplication">checkingInformationInOldVersionsFor: aPundleName</body><body package="StoreForGlorpReplication">disconnected</body><body package="StoreForGlorpReplication">examining: aPundleName depth: anInteger</body><body package="StoreForGlorpReplication">givingUpAfterTooManyFailures</body><body package="StoreForGlorpReplication">reconnectingTo: aString</body><body package="StoreForGlorpReplication">replicating: aNumber versionsOf: aPundleName from: sourceSession to: targetSession depth: anInteger</body><body package="StoreForGlorpReplication">replicatingAllVersionsOf: aPundleName from: sourceSession to: targetSession</body><body package="StoreForGlorpReplication">skipping: aPundleName</body><body package="StoreForGlorpReplication">skipping: aPundleName depth: anInteger</body></methods><methods><class-id>Store.Glorp.NoReplicationLog</class-id> <category>accessing</category><body package="StoreForGlorpReplication">operation	^operation</body><body package="StoreForGlorpReplication">operation: aString	operation := aString</body></methods><methods><class-id>Store.Glorp.NoReplicationLog</class-id> <category>initialize-release</category><body package="StoreForGlorpReplication">initialize	operation := 'Replication'.</body></methods><methods><class-id>Store.Glorp.NoReplicationLog class</class-id> <category>instance creation</category><body package="StoreForGlorpReplication">new	^super new initialize.</body></methods><methods><class-id>Store.Glorp.ProgressNotifierLog</class-id> <category>events-individual pundle replicator</category><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration 	IncrementNotification signal.</body><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration depth: anInteger  	IncrementNotification signal.</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime	 IncrementNotification signal.</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime depth: anInteger	 	IncrementNotification signal.</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator</class-id> <category>accessing</category><body package="StoreForGlorpReplication">addRule: aReplicationRule	rules add: aReplicationRule.</body><body package="StoreForGlorpReplication">busy	^busy</body><body package="StoreForGlorpReplication">cutOffDate	^self cutOffTimestamp ifNotNil: [ :ts | ts asDate ]</body><body package="StoreForGlorpReplication">cutOffDate: aDate"	aDate &lt;Date&gt; ignore any versions that are older than this"	self cutOffTimestamp: (aDate ifNotNil: [ :d | d asTimestamp ])</body><body package="StoreForGlorpReplication">cutOffTimestamp	^cutOffTimestamp</body><body package="StoreForGlorpReplication">cutOffTimestamp: aTimestamp"	aTimestamp &lt;Timestamp&gt; ignore any versions that are older than this"	cutOffTimestamp := aTimestamp</body><body package="StoreForGlorpReplication">period	^period</body><body package="StoreForGlorpReplication">period: anInteger	period := anInteger</body><body package="StoreForGlorpReplication">quitAfterReplicating	^quitAfterReplicating ifNil: [quitAfterReplicating := false].</body><body package="StoreForGlorpReplication">quitAfterReplicating: aBoolean	quitAfterReplicating := aBoolean</body><body package="StoreForGlorpReplication">replicationLog	^self replicator replicationLog</body><body package="StoreForGlorpReplication">replicationLog: aReplicationLog	^self replicator replicationLog: aReplicationLog</body><body package="StoreForGlorpReplication">replicator	^replicator</body><body package="StoreForGlorpReplication">replicator: aStoreReplicator	replicator := aStoreReplicator</body><body package="StoreForGlorpReplication">ruleFileName	^ruleFileName</body><body package="StoreForGlorpReplication">ruleFileName: aString	ruleFileName := aString</body><body package="StoreForGlorpReplication">ruleStrings: aCollectionOfStrings	rules := aCollectionOfStrings collect: [:each | ReplicationRule readFrom: each readStream].</body><body package="StoreForGlorpReplication">rules	^rules.</body><body package="StoreForGlorpReplication">rules: aCollection	rules := aCollection.</body><body package="StoreForGlorpReplication">shouldFixExistingVersions	^self replicator shouldFixExistingVersions</body><body package="StoreForGlorpReplication">shouldFixExistingVersions: aBoolean	^self replicator shouldFixExistingVersions: aBoolean.</body><body package="StoreForGlorpReplication">shouldReplicateOnlyOriginalVersions	^self replicator replicateOnlyOriginalVersions</body><body package="StoreForGlorpReplication">shouldReplicateOnlyOriginalVersions: aBoolean	^self replicator shouldReplicateOnlyOriginalVersions: aBoolean.</body><body package="StoreForGlorpReplication">skipOldVersions	^self replicator isNil ifTrue: [true] ifFalse: [self replicator skipOldVersions].</body><body package="StoreForGlorpReplication">skipOldVersions: aBoolean 	self replicator skipOldVersions: aBoolean</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator</class-id> <category>api</category><body package="StoreForGlorpReplication">replicateAll	[	busy := true.		self traceReplicating.		self readRules.		rules do: [:each | each replicateIn: self]	] ensure: [		busy := false.		self logout.		self traceFinishedReplicating ].</body><body package="StoreForGlorpReplication">replicateAllForked	"Fork off the individual replication, so that if there's an error, it will only affect that particular iteration, not break the main delay loop"	busy ifTrue: [self error: 'Another replication is still in progress'].	"The thing can sometimes lock up completely on database exceptions. If we're in quit-after-replicating mode, then just quit anyway after 12 hours."	self startQuitIfReplicationIsStuckLoop.	[self replicateAll.	self quitAfterReplicating ifTrue: [Dialect quitTheImage]] forkAt: Processor userBackgroundPriority.</body><body package="StoreForGlorpReplication">replicateBundleNamed: aString from: sourceName to: targetName	"self new replicateBundleNamed: 'A' from: 'cst' to: 'very local postgres'."	self replicatePundleNamed: aString from: sourceName to: targetName bundle: true.</body><body package="StoreForGlorpReplication">replicatePackageNamed: aString from: sourceName to: targetName	"self new replicatePackageNamed: 'A' from: 'cst' to: 'very local postgres'."	self replicatePundleNamed: aString from: sourceName to: targetName bundle: false.</body><body package="StoreForGlorpReplication">replicatePundleNamed: aString changingVersionNameFrom: sourceVersion to: targetVersion fromRepository: sourceName to: targetName bundle: aBoolean	"A very special purpose sort of replication. Replicate the given pundle, with the given name, from the source repository to the target, but give it a particular version name in the target. Used if you want to copy versions from an internal repository into something where they'll be given externally visible names."	"self new replicateBundleNamed: 'A' from: 'cst' to: 'very local postgres'."		self traceReplicationOf: aString from: sourceName to: targetName.	replicator replicateRecursively: false.	replicator targetVersionName: targetVersion.	[replicator sourceSession: (self sessionForName: sourceName).	replicator targetSession: (self sessionForName: targetName)]		on: Error		do:			[:ex | 			self traceLoginError: ex from: sourceName to: targetName.			Dialect isHeadless ifFalse: [ex pass].			^self].	aBoolean		ifTrue: [replicator replicateBundleNamed: aString version: sourceVersion ]		ifFalse: [replicator replicatePackageNamed: aString version: sourceVersion].</body><body package="StoreForGlorpReplication">replicatePundleNamed: aString changingVersionNameFrom: sourceVersion to: targetVersion withParentNamed: parentVersion fromRepository: sourceName to: targetName bundle: aBoolean	"A very special purpose sort of replication. Replicate the given pundle, with the given name, from the source repository to the target, but give it a particular version name in the target. Used if you want to copy versions from an internal repository into something where they'll be given externally visible names."	"self new replicateBundleNamed: 'A' from: 'cst' to: 'very local postgres'."		self traceReplicationOf: aString from: sourceName to: targetName.	replicator replicateRecursively: false.	replicator targetVersionName: targetVersion.	replicator parentVersionName: parentVersion.	[replicator sourceSession: (self sessionForName: sourceName).	replicator targetSession: (self sessionForName: targetName)]		on: Error		do:			[:ex | 			self traceLoginError: ex from: sourceName to: targetName.			Dialect isHeadless ifFalse: [ex pass].			^self].	aBoolean		ifTrue: [replicator replicateBundleNamed: aString version: sourceVersion ]		ifFalse: [replicator replicatePackageNamed: aString version: sourceVersion].</body><body package="StoreForGlorpReplication">replicatePundleNamed: aString from: sourceName to: targetName bundle: aBoolean	"self new replicateBundleNamed: 'A' from: 'cst' to: 'very local postgres'."	| names |	self traceReplicationOf: aString from: sourceName to: targetName.	names := self pundlesToReplicateFrom: sourceName 	matching: aString bundle: aBoolean.	names		do:			[:each | 			[replicator sourceSession: (self sessionForName: sourceName).			replicator targetSession: (self sessionForName: targetName)]				on: Error				do:					[:ex | 					self						traceLoginError: ex						from: sourceName						to: targetName.					Dialect isHeadless ifFalse: [ex pass].					^self].			aBoolean 				ifTrue: [replicator replicateBundleNamed: each]					ifFalse: [replicator replicatePackageNamed: each]].</body><body package="StoreForGlorpReplication">startPeriodicReplication	(process isNil or: [process isTerminated]) ifFalse: [^self].	process := [[self replicateAllForked. (Delay forSeconds: 60 * period) wait] repeat] forkAt: Processor userBackgroundPriority.</body><body package="StoreForGlorpReplication">startQuitIfReplicationIsStuckLoop	"Fork off a loop to try and check if we're stuck by seeing if the transcript has changed in the last two hours. Only applies if we're in replicateOnce mode."	"self new quitAfterReplicating: true; startQuitIfReplicationIsStuckLoop"	| previousTranscript |	self quitAfterReplicating ifFalse: [^self].	previousTranscript := nil.	[		"We have to do the asByteArray because GapString comparison is weird."		[previousTranscript = Transcript value asString asByteArray] whileFalse: [			previousTranscript := Transcript value asString asByteArray.			(Delay forSeconds: (2 * 60 * 60)) wait].			"Notify them we're quitting, but fork it off in case Transcript is part of the problem."			[Transcript cr; show: (Dialect timestampNow printString, ' - '); show: 'Too much time elapsed. Assuming the system is hung and quitting.'] fork. 			(Delay forSeconds: 10) wait.			ObjectMemory quitPrimitive.	]			forkAt: Processor userInterruptPriority.</body><body package="StoreForGlorpReplication">stopPeriodicReplication	process isNil		ifFalse:			[[replicator logout] on: Error do: [:ex | ex return].			process terminate.			process := nil].	self logout.</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator</class-id> <category>writing</category><body package="StoreForGlorpReplication">ruleStrings	^rules collect: [:each | each definitionString].</body><body package="StoreForGlorpReplication">rulesAsString	| stream |	stream := WriteStream on: String new.	rules do: [:each | stream nextPutAll: each definitionString. stream cr].	^stream contents.</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator</class-id> <category>tracing</category><body package="StoreForGlorpReplication">traceFinishedReplicating	"Subclasses may override to provide different sorts of information"	self replicationLog finishedAutoReplicationAt: Timestamp now.</body><body package="StoreForGlorpReplication">traceLoginError: anException from: sourceName to: targetName	self replicationLog autoReplicateLoginError: anException from: sourceName to: targetName.</body><body package="StoreForGlorpReplication">traceReplicating	"Subclasses may override to provide different sorts of information"	self replicationLog startingAutoReplicationAt: Timestamp now.</body><body package="StoreForGlorpReplication">traceReplicationFrom: sourceName to: targetName	"Subclasses may override to provide different sorts of information"	self replicationLog autoReplicatingFrom: sourceName to: targetName</body><body package="StoreForGlorpReplication">traceReplicationOf: aPundleName from: sourceName to: targetName	"Subclasses may override to provide different sorts of information"	self replicationLog autoReplicating: aPundleName from: sourceName to: targetName</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator</class-id> <category>initialize-release</category><body package="StoreForGlorpReplication">initialize	replicator := StoreReplicator new.	replicator skipOldVersions: true.	rules := OrderedCollection new.	period := 60.	busy := false.	cachedSessions := Dictionary new.	quitAfterReplicating := false.</body><body package="StoreForGlorpReplication">logout	replicator logout.	cachedSessions do: [:each | [each accessor logout] on: Error do: [:ex | ex return]].	cachedSessions := Dictionary new.</body><body package="StoreForGlorpReplication">release	super release.	busy := false.	self logout.	replicator := nil.</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator</class-id> <category>setup</category><body package="StoreForGlorpReplication">areThereWildcardsIn: aString	^aString includes: $%.</body><body package="StoreForGlorpReplication">pundlesToReplicateFrom: databaseName matching: pundleName bundle: aBoolean 	| session targetClass versionless |	(self areThereWildcardsIn: pundleName) ifFalse: [^Array with: pundleName].	session := self sessionForName: databaseName.	targetClass := aBoolean 				ifTrue: [StoreVersionlessBundle]				ifFalse: [StoreVersionlessPackage].		[	[versionless := self 				versionlessPundlesFrom: session				matching: pundleName				pundleClass: targetClass.	false] 			on: GlorpDatabaseReadError			do: 				[:ex | 				replicator handleDisconnect: ex.				true]] 			whileTrue.	^versionless collect: [:each | each name]</body><body package="StoreForGlorpReplication">sessionForName: aString	| storeLogin |	Dialect isVWWithNameSpaces ifFalse: [self error: 'Don''t have a mechanism to find store logins in this dialect'].	^cachedSessions at: aString ifAbsentPut: [		storeLogin := (Dialect smalltalkAt: #'Store.RepositoryManager') repositories detect: [:each |			each name = aString].		StoreLoginFactory sessionForStoreLogin: storeLogin].</body><body package="StoreForGlorpReplication">versionlessPundlesFrom: session matching: pundleName pundleClass: targetClass 	"First, help out the database if we have a universal wildcard."	| cutOffClause |	cutOffClause := [:each | 			self cutOffDate isNil 			ifTrue: [true]			ifFalse: [each versions anySatisfyJoin: [:eachVersion | 				eachVersion timestamp &gt; self cutOffDate]]].	(pundleName = '%') ifTrue: [^session execute: ((Query read: targetClass where: cutOffClause) orderBy: #name)].	"If not, look for matching pundles."	^session execute: ((Query read: targetClass		where: [:each | 			(each name like: pundleName) AND: (cutOffClause value: each)]) 		orderBy: #name).</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator</class-id> <category>reading</category><body package="StoreForGlorpReplication">readRules	ruleFileName isNil ifTrue: [^self].	rules := OrderedCollection new.	self readRulesFrom: (ReadStream on: (Dialect contentsOfFileNamed: ruleFileName)).</body><body package="StoreForGlorpReplication">readRulesFrom: aStream	"Read our replication rules from a comma-delimited text stream"		[aStream atEnd] whileFalse: [self addRule: (ReplicationRule readFrom: aStream). aStream skipSeparators].</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator class</class-id> <category>examples</category><body package="StoreForGlorpReplication">example1	"self example1"	| replicator |	replicator := self new.	replicator addRule: ReplicationRule example1.	replicator replicateAll.</body><body package="StoreForGlorpReplication">example2	"self example2"	| replicator |	replicator := self new.	replicator addRule: ReplicationRule example1.	replicator period: 1.	replicator startPeriodicReplication.	(Delay forSeconds: 5 * 60) wait.	replicator stopPeriodicReplication.</body><body package="StoreForGlorpReplication">example3	"self example3"	| replicator |	replicator := self readFrom: ('B,Glorp,cst,very local postgresB,Glorp,very local postgres,cstP,StoreForGlorpReplication,cst,very local postgresP,StoreForGlorpReplication,very local postgres,cst' readStream).	replicator period: 1.	replicator startPeriodicReplication.	(Delay forSeconds: 5 * 60) wait.	replicator stopPeriodicReplication.</body><body package="StoreForGlorpReplication">exampleRenaming	"self exampleRenaming"	| replicator |	replicator := self new.	replicator addRule: RenamingRule example1.	replicator replicateAll.</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator class</class-id> <category>instance creation</category><body package="StoreForGlorpReplication">default	default isNil ifTrue: [default := self new].	^default.</body><body package="StoreForGlorpReplication">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="StoreForGlorpReplication">readFrom: aStream	"Read our replication rules from a tab-delimited text stream"	"self readFrom: (ReplicationRule exampleRuleStream contents, '', ReplicationRule exampleRuleStream2 contents) readStream"	| replicator |	replicator := self new.	replicator readRulesFrom: aStream.	^replicator.</body><body package="StoreForGlorpReplication">reset	default := nil.</body></methods><methods><class-id>Store.Glorp.StoreAutoReplicator class</class-id> <category>As yet unclassified</category><body package="StoreForGlorpReplication">hasDefault	^default notNil.</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter</class-id> <category>publishing</category><body package="StoreForGlorpReplication">dealWithAbsentParent	"If we are not replicating recursively, this is just like publishing a new pundle.  If we are, replicate the ancestors and then reconcile to the paremt.  (Note: we put off instantiating the whole package until we've done any recursive replications Otherwise we end up potentially doing unnecessary reads, and wasting memory in the meantime.)"	| previous |	self shouldReplicatePreviousVersion		ifFalse: [super dealWithAbsentParent]		ifTrue: 			[previous := self replicatePreviousVersions.			self instantiateAllOf: pundle.			self newPundleReconcileWith: previous].</body><body package="StoreForGlorpReplication">fixBlessingsFor: aPundleInSourceDB	| targetPundle sourceBlessings targetBlessings addedBlessings newBlessings |	pundle := aPundleInSourceDB.	targetPundle := self alreadyPresentVersionOf: aPundleInSourceDB.	targetPundle isNil ifTrue: [^self].	sourceBlessings := pundle blessings asSortedCollection: [:a :b | a timestamp &lt;= b timestamp].	targetBlessings := targetPundle blessings asSortedCollection: [:a :b | a timestamp &lt;= b timestamp].	sourceBlessings = targetBlessings ifTrue: [^self].	addedBlessings := sourceBlessings reject: [:each | targetBlessings includes: each].	addedBlessings isEmpty ifTrue: [^self].	newBlessings := targetBlessings copy.	newBlessings addAll: (addedBlessings collect: [:each | each copy]).	self parent updatingBlessingsFor: targetPundle.	[targetSession accessor permitEverything.	targetSession transact: [		targetSession register: targetPundle.		targetPundle currentBlessingLevel: pundle currentBlessingLevel.		targetPundle blessings: newBlessings]] ensure: [targetSession accessor insertOnly].</body><body package="StoreForGlorpReplication">fixParentFor: aPundleInTargetDB	| targetPundle aPundleInSourceDB |	aPundleInSourceDB := self sourceVersionOf: aPundleInTargetDB.	aPundleInSourceDB isNil ifTrue: [^self].	pundle := aPundleInSourceDB.	self isPreviousVersionPresent ifFalse: [^self].	targetPundle := self alreadyPresentVersionOf: aPundleInSourceDB.	targetPundle isNil ifTrue: [^self].	targetPundle previous yourSelf == previousVersionInTargetDatabase ifTrue: [^self].	self parent patchingParentFor: targetPundle.	[targetSession accessor permitEverything.	targetSession transact: [		targetSession register: targetPundle.		targetPundle previous: previousVersionInTargetDatabase]] ensure: [targetSession accessor insertOnly].</body><body package="StoreForGlorpReplication">isPublishing	^self isReplicating not.</body><body package="StoreForGlorpReplication">isReplicating	parent isNil ifFalse: [^parent isReplicating].	^pundle primaryKey notNil.</body><body package="StoreForGlorpReplication">logEndOf: aPundle	self parent		finishedReplicationOf: aPundle		time: endTime asTime		duration: duration.</body><body package="StoreForGlorpReplication">logStartOf: aPundle	self parent		startingReplicationOf: aPundle		time: startTime asTime.</body><body package="StoreForGlorpReplication">modifyNewPundle	"In most cases, if replicating, we just copy the pundle as is. But if we're trying to export a production version, then we're changing the name, blessings, author, and parent."	| newBlessing oldVersion |	self targetVersionName isNil ifTrue: [^self].	oldVersion := newPundle version.	newPundle version: self targetVersionName.	self isReplicating ifFalse:	"when replicating, we need to preserve the username to match in alreadyPresentVersionOf:"		[newPundle username: 'cincom'].		newBlessing := StoreBlessing new.	newBlessing blessingLevel: ((Dialect smalltalkAt: #'Store.Policies') blessingPolicy blessingNumber: 'Released').	newBlessing comment: 'Released as part of version ', self targetVersionName, 'Internal version: ', oldVersion.	newBlessing timestamp: (Dialect storeTimestampIn: self targetSession) .	newBlessing username: 'cincom'.	newPundle blessings: (OrderedCollection with: newBlessing).	newPundle currentBlessingLevel: newBlessing blessingLevel.</body><body package="StoreForGlorpReplication">newPundleFromPundle	"We are replicating;  the pundle we write is a copy of the original."		newPundle := self isReplicating ifTrue: [pundle copy] ifFalse: [pundle].	self modifyNewPundle.	^newPundle.</body><body package="StoreForGlorpReplication">numberOfDistinctPundlesIn: aPundle	"If we write this pundle, how many distinct pundles will we write in sub-steps. Needed so we can do progress calculations"	splitPundles ifFalse: [^1].	^(aPundle isBundle and: [aPundle bundles isEmpty not])		ifTrue: [1 + (aPundle pundles 			inject: 0 				into: [:sum :each | sum + (self numberOfDistinctPundlesIn: each)])]		ifFalse: [1]</body><body package="StoreForGlorpReplication">readPreviousVersion	"Find our previous version. If we've been told it by version name, use that. Otherwise (normally) use the previous timestamp."	| result |	result := self targetSession		readOneOf: self pundleType		where:			[:each | 			(self parentVersionName isNil 				ifTrue: [each timestamp = pundle previous timestamp]				ifFalse: [each version = self parentVersionName])				&amp; (each name = pundle previous name)].	"This is a complete hack for finding out if we've got missing parents we need to fix up when replicating and renaming."	(self parentVersionName notNil and: [result isNil])		ifTrue: [Transcript cr; show: 'Missing ancestor for ', pundle name. pundle inspect].	^result.</body><body package="StoreForGlorpReplication">readPundleNamed: aPundleName withVersion: versionString	^self parent readPundleNamed: aPundleName withVersion: versionString.</body><body package="StoreForGlorpReplication">shouldReplicatePreviousVersion	"Return true if the pundle we're told to write has a missing parent, and we should recursively replicate it too."	self replicateRecursively ifFalse: [^false].	pundle previous yourself isNil ifTrue: [^false].	(self parent cutOffDate notNil and: [self parent cutOffDate asTimestamp&gt; pundle previous timestamp])		ifTrue: [^false].	pundle previous yourself isValid ifFalse: [^false].	^true.</body><body package="StoreForGlorpReplication">sourceDatabaseIdentifier	"If we don't have a valid parent, then that means we're not replicating, and there is no meaningful source session, so we'll get back the error response 'none', but that's OK"	^self parent sourceDatabaseIdentifier.</body><body package="StoreForGlorpReplication">sourceSession	^self parent sourceSession.</body><body package="StoreForGlorpReplication">targetDatabaseIdentifier	"We have to also have this implemented here, rather than just delegate this to our parent replicator, because we may not have a valid one if publishing"	| session |	targetDatabaseIdentifier isNil ifFalse: [^targetDatabaseIdentifier].	session := self targetSession.	session isNil ifTrue: [^'none'].	targetDatabaseIdentifier := session system databaseIdentifier.	^targetDatabaseIdentifier.</body><body package="StoreForGlorpReplication">updateForReplication	"Do any additional changes we need to do if replicating, rather than publishing. In particular, append a blessing that indicates when replication happened"	self isReplicating ifFalse: [^self].	newPundle blessWithReplicationNoticeIn: self.</body><body package="StoreForGlorpReplication">validateNewPundle: aPundle	"Validate, but using the validation for new things, which can short-circuit over things that aren't new, and so be more efficient."	aPundle isValidAsNew		ifFalse:			[self parent invalidPundle: aPundle.			(InvalidStorePundleError new pundle: pundle) signal].</body><body package="StoreForGlorpReplication">validatePundle: aPundle	aPundle isValid		ifFalse:			[self parent invalidPundle: aPundle.			(InvalidStorePundleError new pundle: pundle) signal].</body><body package="StoreForGlorpReplication">validateVersionStringFor: aStorePundle	aStorePundle version: self sourceDatabaseIdentifier , '-' , aStorePundle version.</body><body package="StoreForGlorpReplication">writeNewPundle	"This is a bit ugly. If the old pundle had a version, carry it forward (probably means we're replicating). But if it didn't, and the new one does, that means the user assigned it, and we're probably publishing. Push it back to the original, just to make sure that any logging shows it. We should never have both nil."	newPundle version isNil ifTrue: [newPundle version: pundle version].	pundle version isNil ifTrue: [pundle version: newPundle version].	self validateNewPundle: newPundle.	self checkForNameConflict.	self updateForReplication.	self targetSession transact: [self targetSession register: newPundle].	^newPundle</body><body package="StoreForGlorpReplication">writePundle: aPundle	"Copying shoved inside reconcile:with:.  Should we use self class or self parent pundleWriterClass to write subcomponents (no difference as yet)?"	"The next line is probably long redundant;  if we, not the superclass, are doing this, we're replicating."	self parent replicationLog operation: (self isReplicating ifTrue: ['Replicating'] ifFalse: ['Publishing']).	startTime := Timestamp now.	self logStartOf: aPundle.	(super writePundle: aPundle) isNil ifTrue: [^nil].	endTime := Timestamp now.	duration := (endTime - startTime) asSeconds rounded.	self logEndOf: aPundle.	^newPundle</body><body package="StoreForGlorpReplication">writePundlePhase1: aPundle withChangesBasedOn: anImagePundle using: aCollection	"Prepare to write out the pundle, using information from the image change sets. Do our initial reading of the previous version, but don't reconcile and don't write yet"	startTime := Timestamp now.	pundle := aPundle.	self parent replicationLog operation: 'Publishing'.	self logStartOf: aPundle.	self isPreviousVersionPresent ifFalse: [^self].	self instantiateIndividualMethodsIn: aPundle requiredFor: anImagePundle.	self instantiateAllOf: previousVersionInTargetDatabase requiredFor: anImagePundle.</body><body package="StoreForGlorpReplication">writePundlePhase2: aPundle withChangesBasedOn: anImagePundle	(super writePundlePhase2: aPundle withChangesBasedOn: anImagePundle)		isNil ifTrue: [^nil].	endTime := Timestamp now.	duration := (endTime - startTime) asSeconds rounded.	self logEndOf: aPundle.	^newPundle</body><body package="StoreForGlorpReplication">writeSubComponentsOf: aPundle	"If it's too big to handle at one gulp, write the sub-components first. If we're publishing, we should only write those components that have changed. We know they've changed if they've been assigned a version number by the publish dialog or whatever else set up the publishing, but don't have a primary key. Once we've written it out, read it back as a proxy, so we won't have to trace through all of its relationships when we write the parent, and so memory that we don't need any more can be reused."	(self isPundleTooBig: aPundle) ifTrue: [		aPundle componentsDo: [:each |				(self isReplicating or: [each needsPublishing])					ifTrue: [						(self newWriterFor: self parent) writePundle: each.						each componentsDo: [:x | self targetSession refresh: x]]					ifFalse: [each]]].</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter</class-id> <category>api-publishing</category><body package="StoreForGlorpReplication">assignDefaultBlessingTo: aPundle	aPundle allComponentsDo: [:each |		each blessings isEmpty ifTrue: [			| blessing |			blessing := StoreBlessing new.			blessing blessingLevel: Store.Policies blessingPolicy defaultBlessing.			blessing comment: 'Default publish of ', aPundle name.			each bless: blessing]].</body><body package="StoreForGlorpReplication">assignDefaultVersionNumberTo: aStorePundle	"We are publishing this pundle. Assign the next default version number to it and all of its modified subcomponents"	aStorePundle allComponentsDo: [:each | 		| nextVersionNumber storeModel |		each version isNil ifTrue:			[storeModel := each storeModel.			nextVersionNumber := Store.Policies versionPolicy				nextVersion: storeModel parentVersionString				forPundle: storeModel				in: self targetSession.			each version: nextVersionNumber]].</body><body package="StoreForGlorpReplication">publishImagePundleWithDefaults: anImagePundle	"Take an image pundle, that is either a PackageModel or BundleModel and publish it to the database with a default blessing level and default version number, based on the parent of the pundles in question."	| dbPundle |	dbPundle := anImagePundle asNewStorePundleIn: targetSession.	self preWriteAction: [:aPundle |		self assignDefaultVersionNumberTo: aPundle.		self assignDefaultBlessingTo: aPundle].	self writePundle: dbPundle.	newPundle applyPundleVersionsToTheImage.</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter</class-id> <category>reconciling</category><body package="StoreForGlorpReplication">alreadyPresentVersionOf: aPundle	"Notes that in this case we do not check for the version name, as opposed to publishing, where we do.  In replication, we're looking for something potentially from a different database, and the name may have been modified if there was a conflict."	| alreadyThere |	alreadyThere := self targetSession		read: self pundleType		where:			[:each | each timestamp = aPundle timestamp &amp; (each name = aPundle name) &amp; (each username = aPundle username) ].	alreadyThere size &gt; 2 ifTrue: [self halt. "Uh oh - we have a conflict. User intervention is probably required"].	alreadyThere isEmpty ifTrue: [^nil].	^alreadyThere first.</body><body package="StoreForGlorpReplication">newPundleReconcileWith: anotherPundle	"Assign a publishable version of my pundle to newPundle and reconcile it."	super newPundleReconcileWith: anotherPundle.	newPundle componentsCollect: 		[:each | self pundleVersionToUseFor: each withPreviousParentVersion: anotherPundle].	^newPundle</body><body package="StoreForGlorpReplication">pundleVersionToUseFor: each withPreviousParentVersion: anotherPundle	| existingTargetVersion secondaryWriter unchanged |	unchanged := self matchingPundleTo: each in: anotherPundle.	unchanged isNil ifFalse: [^unchanged].	secondaryWriter := self class for: self parent.	secondaryWriter pundle: each.	secondaryWriter targetSession: self targetSession.	"If we are replicating, then we need to know if there is already a version in the target corresponding to the thing we want to write. If we're publishing, then there's only one database, so we know that anotherPundle is it"	existingTargetVersion := (self isPublishing and: [anotherPundle notNil])		ifTrue: ["each previous isNil ifTrue: [self halt]."			"This caused an error when replicating versionless and the parent bundle was handled before a sub-bundle. It would			end up not using a previous version that it should. But just making it use the replication case also had problems. And 			now the problem seems to have disappeared with other changes. But I'm still suspicious of it"			secondaryWriter previousVersionInTargetDatabase: each previous. nil] 		ifFalse: [secondaryWriter alreadyPresentVersionOf: each].	^existingTargetVersion isNil		ifTrue:			[secondaryWriter newPundleReconcileWith: secondaryWriter previousVersionInTargetDatabase]		ifFalse: [existingTargetVersion]</body><body package="StoreForGlorpReplication">sourceVersionOf: aPundle	| alreadyThere |	alreadyThere := self sourceSession		readOneOf: (aPundle isBundle ifTrue: [StoreBundle] ifFalse: [StorePackage])		where:			[:each | each timestamp = aPundle timestamp &amp; (each name = aPundle name)].	^alreadyThere.</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter</class-id> <category>accessing</category><body package="StoreForGlorpReplication">parent	parent isNil ifTrue: [parent := StoreReplicator new targetSession: self targetSession].	^parent</body><body package="StoreForGlorpReplication">parent: aStoreReplicator	parent := aStoreReplicator</body><body package="StoreForGlorpReplication">parentVersionName	"Return the specific parent version we've been told to use by name, if it's defined."	self parent isNil ifTrue: [^nil].	^self parent parentVersionName.</body><body package="StoreForGlorpReplication">replicateRecursively	"If there's no source session then we have nowhere to go back to and look recursively. This happens when publishing"	self sourceSession isNil ifTrue: [^false].	^self parent replicateRecursively.</body><body package="StoreForGlorpReplication">replicationLog: aReplicationLog	self parent replicationLog: aReplicationLog.</body><body package="StoreForGlorpReplication">targetSession	targetSession isNil ifTrue: [targetSession := self parent targetSession].	^targetSession.</body><body package="StoreForGlorpReplication">targetVersionName	self parent isNil ifTrue: [^nil].	^self parent targetVersionName.</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter</class-id> <category>instantiating</category><body package="StoreForGlorpReplication">instantiateIndividualMethodsIn: aPundle requiredFor: aPackageModel	"Go through the methods changed in the change set for the image model and make sure that we've touched all of them"	| methodList changeSet |	aPundle leafItems do: [:each |		changeSet := each storeModel changeSetFor: aPundle session system databaseIdentifier.		methodList := changeSet isNil ifTrue:[#()] ifFalse: [changeSet modifiedMethodDescriptors].		methodList do: [:eachMethod | (each methodFor: eachMethod) ifNotNil: [:method | method source yourself]]].</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter</class-id> <category>logging</category><body package="StoreForGlorpReplication">log: aString for: aBlock	self parent log: aString for: aBlock.</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter</class-id> <category>replicating</category><body package="StoreForGlorpReplication">replicatePreviousVersions	| replicator |	replicator := self copy.	replicator removePackageInfo.	^replicator replicatePundleNamed: pundle previous name version: pundle previous version.</body><body package="StoreForGlorpReplication">replicatePundleNamed: aPackageName version: versionString	| pundleToReplicate | 	pundleToReplicate := self readPundleNamed: aPackageName withVersion: versionString.	pundleToReplicate isNil ifTrue: [self error: 'package not found'].	^self parent replicatePundle: pundleToReplicate.</body></methods><methods><class-id>Store.Glorp.ReplicatorPundleWriter class</class-id> <category>instance creation</category><body package="StoreForGlorpReplication">for: aStoreReplicator	^self new parent: aStoreReplicator.</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>accessing</category><body package="StoreForGlorpReplication">bundles	^bundles</body><body package="StoreForGlorpReplication">bundles: aCollection	bundles := aCollection</body><body package="StoreForGlorpReplication">gui	^gui</body><body package="StoreForGlorpReplication">gui: aReplicationUI	gui := aReplicationUI</body><body package="StoreForGlorpReplication">packages	^packages</body><body package="StoreForGlorpReplication">packages: aCollection	packages := aCollection</body><body package="StoreForGlorpReplication">replicator	^replicator.</body><body package="StoreForGlorpReplication">replicator: aReplicator	^replicator := aReplicator</body><body package="StoreForGlorpReplication">retrieveBundles	^retrieveBundles</body><body package="StoreForGlorpReplication">retrieveBundles: anObject	retrieveBundles := anObject</body><body package="StoreForGlorpReplication">retrievePackages	^retrievePackages</body><body package="StoreForGlorpReplication">retrievePackages: anObject	retrievePackages := anObject</body><body package="StoreForGlorpReplication">sourceLogin	^sourceLogin</body><body package="StoreForGlorpReplication">sourceLogin: aLogin	sourceLogin := aLogin.	self setUpSourceSession.	self getPundles.</body><body package="StoreForGlorpReplication">sourceSession	sourceSession isNil ifTrue:		[replicator sourceSession isNil ifTrue: [^nil].		sourceSession := Store.DbRegistry createPrivateSessionForLogin: sourceLogin].	^sourceSession</body><body package="StoreForGlorpReplication">targetLogin	^targetLogin</body><body package="StoreForGlorpReplication">targetLogin: aLogin	targetLogin := aLogin.	self setUpTargetSession.</body><body package="StoreForGlorpReplication">topLevelOnly	^topLevelOnly</body><body package="StoreForGlorpReplication">topLevelOnly: aBoolean	topLevelOnly := aBoolean</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>conditions</category><body package="StoreForGlorpReplication">applicableConditionsFor: aQuery	| hasConditionsThatDontMakeSense applicableConditions |	applicableConditions := self conditionNames		select:			[:eachConditionName | (self gui perform: eachConditionName asSymbol) value].	hasConditionsThatDontMakeSense := applicableConditions		anySatisfy:			[:eachConditionName | (self condition: eachConditionName appliesTo: aQuery) not].	"What this means is that if we have conditions that apply only to packages, then don't bother to select bundles at all"	hasConditionsThatDontMakeSense		ifTrue: [GlorpReplicationDontBotherToDoThisQuery new signal].	^applicableConditions.</body><body package="StoreForGlorpReplication">applyConditionsTo: each for: aQuery	| applicableConditions |	"What this means is that if we have conditions that apply only to packages, then don't bother to select bundles at all"	applicableConditions := self applicableConditionsFor: aQuery.	^applicableConditions		collect:			[:eachCondition | 			| aspect1 aspect2 aspect3 aspectsThatExist values methodName |			aspect1 := (eachCondition , 'Text') asSymbol.			aspect2 := (eachCondition , 'Text1') asSymbol.			aspect3 := (eachCondition , 'Text2') asSymbol.			aspectsThatExist := (Array				with: aspect1				with: aspect2				with: aspect3) select: [:eachSymbol | self gui respondsTo: eachSymbol].			values := aspectsThatExist				collect: [:eachSymbol | (gui perform: eachSymbol) value].			methodName := ('evaluate' , eachCondition , (values size = 1 ifTrue: ['For:value:'] ifFalse: ['For:value:value:']))				asSymbol.			self perform: methodName withArguments: (Array with: each) , values].</body><body package="StoreForGlorpReplication">bundleConditions	^#(#queryPundleName #queryPublishDate #queryPublisher #queryArbitrary ).</body><body package="StoreForGlorpReplication">condition: aSymbol appliesTo: aQuery	"Return true if the condition works for us"	^aQuery resultClass isBundle		ifTrue: [self bundleConditions includes: aSymbol]		ifFalse: [true].</body><body package="StoreForGlorpReplication">conditionNames	^#(#queryClassName #queryClassWithMethod #queryMethodName #queryClassExtensionName #queryPundleName #queryMethodsInClass #querySharedName #queryPublishDate #queryPublisher #queryArbitrary).</body><body package="StoreForGlorpReplication">evaluatequeryArbitraryFor: each value: aString	^(Compiler evaluate: aString) value: each.</body><body package="StoreForGlorpReplication">evaluatequeryClassExtensionNameFor: each value: classLongName	^each versions anySatisfy: [:eachVersion | eachVersion classExtensions anySatisfy: [:eachClassExtension | eachClassExtension longName like: classLongName]].</body><body package="StoreForGlorpReplication">evaluatequeryClassNameFor: each value: className	^each versions anySatisfy: [:eachVersion | eachVersion classDefinitions anySatisfy: [:eachClassDefinition | eachClassDefinition definition name like: className]].</body><body package="StoreForGlorpReplication">evaluatequeryClassWithMethodFor: each value: className value: methodName	^each versions anySatisfy:		[:eachVersion |		(eachVersion methods beOuterJoin anySatisfy:			[:eachMethod | (eachMethod definition name like: methodName) 						&amp; (eachMethod definition className like: className)])]</body><body package="StoreForGlorpReplication">evaluatequeryMethodNameFor: each value: methodName	^each versions anySatisfy:		[:eachVersion  |		(eachVersion methods beOuterJoin anySatisfy:			[:eachMethod | eachMethod definition name like: methodName])]</body><body package="StoreForGlorpReplication">evaluatequeryMethodsInClassFor: each value: className	^each versions anySatisfy:		[:eachVersion |	  	(eachVersion methods beOuterJoin anySatisfy:			[:eachMethod | (eachMethod definition className like: className)])]</body><body package="StoreForGlorpReplication">evaluatequeryPublishDateFor: each value: anInteger	^each versions anySatisfy: [:eachVersion | eachVersion timestamp &gt; (Date today subtractDays: anInteger)].</body><body package="StoreForGlorpReplication">evaluatequeryPublisherFor: each value: aString	^each versions anySatisfy: [:eachVersion | eachVersion username like: aString].</body><body package="StoreForGlorpReplication">evaluatequeryPundleNameFor: each value: aString	^each name like: aString.</body><body package="StoreForGlorpReplication">evaluatequerySharedNameFor: each value: sharedName	^each versions anySatisfy:		[:eachVersion |		(eachVersion sharedVariables beOuterJoin anySatisfy:			[:eachShared | (eachShared definition name like: sharedName)])]</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>actions</category><body package="StoreForGlorpReplication">addToReplicationList: aPundle whenDone: aBlock	backgroundProcess isNil ifTrue: [self startBackgroundReplicationProcess].	pundleQueue nextPut: aPundle.	[semaphore wait.	aBlock value] fork.</body><body package="StoreForGlorpReplication">applyReadConditionsTo: query	"This is kind of tricky. We want to pass a message archiver in, but the result doesn't come back as an expression, because it gets returned in an array and that gets turned into a constant expression of an array with an archiver. So extract them individually and then convert to expressions"	query queries		do:			[:eachQuery | 			| expressions archivers |			archivers := [:each | self applyConditionsTo: each for: eachQuery] asGlorpExpression.			expressions := archivers value collect: [:each | each asGlorpExpression].			expressions do: [:each | eachQuery AND: each]].</body><body package="StoreForGlorpReplication">emptyQueue	[pundleQueue isEmpty] whileFalse: [pundleQueue next].</body><body package="StoreForGlorpReplication">evaluateInMemoryBundleConditions	| applicableConditions |	applicableConditions := [self applicableConditionsFor: (Query read: StoreVersionlessBundle)] on: GlorpReplicationDontBotherToDoThisQuery do: [:ex | ex resume: true].	self bundleInMemoryConditions select: [:each | applicableConditions includes: each].</body><body package="StoreForGlorpReplication">evaluateInMemoryConditions	self evaluateInMemoryPackageConditions.	self evaluateInMemoryBundleConditions.</body><body package="StoreForGlorpReplication">evaluateInMemoryPackageConditions</body><body package="StoreForGlorpReplication">getPundles	(self sourceSession isNil or: [self sourceSession accessor isNil]) ifTrue: [^self].	gui isNil ifTrue: [^self].	gui slowOperation: [		bundles := retrieveBundles ifTrue: [self readBundles] ifFalse: [#()].		packages := retrievePackages ifTrue: [self readPackages] ifFalse: [#()].		self evaluateInMemoryConditions.		self gui setPundleList: (bundles, packages)].</body><body package="StoreForGlorpReplication">isBusy	^pundleQueue isEmpty not</body><body package="StoreForGlorpReplication">readBundles	| query applies queryToModify result |	query := self topLevelBundlesQueryIn: self sourceSession.	queryToModify := query class == CompoundQuery ifTrue: [query queries first] ifFalse: [query].	applies := [self applyReadConditionsTo: queryToModify] on: GlorpReplicationDontBotherToDoThisQuery do: [:ex | ex return: nil].	applies isNil ifTrue: [^#()]. 	result := query executeIn: self sourceSession.	^(result asSortedCollection: [:a :b | a name &lt;= b name]) asArray.</body><body package="StoreForGlorpReplication">readPackages	| query applies queryToModify result |	query := self topLevelPackagesQueryIn: self sourceSession.	queryToModify := query class == CompoundQuery ifTrue: [query queries first] ifFalse: [query].	applies := [self applyReadConditionsTo: queryToModify] on: GlorpReplicationDontBotherToDoThisQuery do: [:ex | ex return: nil].	applies isNil ifTrue: [^#()]. 	result := query executeIn: self sourceSession.	^(result asSortedCollection: [:a :b | a name &lt;= b name]) asArray.</body><body package="StoreForGlorpReplication">replicateNextPundle	"If the queue is empty, the attempt to get #next hangs until an item is added to the queue, i.e. the backgroundProcess enters wait state till then.  (We would use #nextAvailable in pace of #next if we wanted to return nil when the queue was empty instead of hanging.)"	| aPundle realPundle |	replicator login.	aPundle := pundleQueue next.	aPundle isNil ifTrue: [^false].	replicator isBundle: aPundle isBundle.	(aPundle isKindOf: StoreVersionlessPundle) ifTrue:		[replicator replicatePundleNamed: aPundle name].	(aPundle isKindOf: StorePundle) ifTrue:		[realPundle := replicator pundleMatching: aPundle.		replicator replicatePundleSkippingErrorsAsInvalidPundles: realPundle].	^true</body><body package="StoreForGlorpReplication">shutdown	replicator logout.	sourceSession isNil ifFalse: [sourceSession accessor logout. sourceSession := nil].	backgroundProcess isNil ifFalse: [backgroundProcess terminate].	backgroundProcess := nil.	self emptyQueue.	semaphore isNil ifFalse: [		[semaphore excessSignals &lt;= 0] whileTrue: [semaphore signal]].</body><body package="StoreForGlorpReplication">startBackgroundReplicationProcess	"When a SharedQueue is empty, the backgroundProcess hangs inside the call of #replicateNextPundle till the arrival of a new element in that queue;  it will reach the last line of its outer block only if nil were explicitly added to the queue.  If another kind of queue were used, one where calling #next on empty returned nil, then it would terminate whenever the queue was empty."	semaphore := Semaphore new.	backgroundProcess :=		[| moreToDo |		[moreToDo := self replicateNextPundle.		semaphore signal.		moreToDo] whileTrue.		backgroundProcess := nil]			forkAt: Processor userBackgroundPriority.</body><body package="StoreForGlorpReplication">stop	replicator logout.	replicator retries: 0.	sourceSession accessor logout.	backgroundProcess isNil ifFalse: [backgroundProcess terminate].	backgroundProcess := nil.	self emptyQueue.	[semaphore excessSignals &lt;= 0] whileTrue: [semaphore signal].	replicator logout.	self setUpSourceSession.	self setUpTargetSession.	sourceSession := nil.	self getPundles.</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>initialize-release</category><body package="StoreForGlorpReplication">initialize	replicator := self replicatorClass new.	pundleQueue := (Dialect smalltalkAt: #SharedQueue				ifAbsent: [self error: 'no shared queues']) new.	topLevelOnly := false.	retrieveBundles := true.	retrievePackages := true</body><body package="StoreForGlorpReplication">setUpSourceSession	| session |	replicator sourceSession isNil ifFalse:		[replicator sourceSession accessor logout].	session := Store.DbRegistry createPrivateSessionForLogin: sourceLogin.	replicator sourceSession: session.	sourceSession := nil.</body><body package="StoreForGlorpReplication">setUpTargetSession	| session |	replicator targetSession isNil ifFalse:		[replicator targetSession accessor logout].	session := Store.DbRegistry createPrivateSessionForLogin: targetLogin.	replicator targetSession: session.</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>logins</category><body package="StoreForGlorpReplication">availableLogins	"Return Logins or objects that return logins when sent asGlorpLogin."	Dialect isVWWithNameSpaces ifFalse: [self error: 'No mechanism to find Store logins in this dialect'].	^(Dialect smalltalkAt: #'Store.RepositoryManager') repositories</body><body package="StoreForGlorpReplication">convertStoreLogin: aStoreConnectionProfile	^StoreLoginFactory convertStoreLogin: aStoreConnectionProfile.</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>As yet unclassified</category><body package="StoreForGlorpReplication">bundleInMemoryConditions	^#().</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>accessing-classes</category><body package="StoreForGlorpReplication">replicatorClass	^StoreReplicator</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager</class-id> <category>queries</category><body package="StoreForGlorpReplication">topLevelBundlesQuery2	| bundleLinkTable allBundlesQuery containedBundlesQuery topLevelBundlesQuery |	containedBundlesQuery := Query read: StoreVersionlessBundle.	bundleLinkTable := self sourceSession system tableNamed: 'TW_Bundles'.	containedBundlesQuery		whereClause: [:each | each versions anySatisfy:			[:eachVersion | 			((eachVersion getTable: bundleLinkTable) getField: 'subBundleRef')				= eachVersion primaryKey]].	containedBundlesQuery		retrieve: [:each | each name].	allBundlesQuery := Query read: StoreVersionlessBundle.	topLevelBundlesQuery := allBundlesQuery minus: containedBundlesQuery.	^topLevelOnly ifTrue: [topLevelBundlesQuery] ifFalse: [allBundlesQuery].</body><body package="StoreForGlorpReplication">topLevelBundlesQueryIn: aSession	"The things we do in the name of efficiency.  We want to be reading versionless pundles here, but if we do an anySatisfy: to versions then we'll end up with two instances of the table and a join between them by name, which is slow. Also, if we refer directly to parent bundles that's a double join, one to the link table and one to the other side. We only care if they exist, so a link table row is sufficient. So go directly down to the field level."	| bundleLinkTable allBundlesQuery containedBundlesQuery topLevelBundlesQuery bundleTable |	bundleTable := aSession system tableNamed: 'TW_Bundle'.	bundleLinkTable := aSession system tableNamed: 'TW_Bundles'.	containedBundlesQuery := Query read: StoreVersionlessBundle.	containedBundlesQuery		whereClause: [:each | ((each getTable: bundleLinkTable) getField: 'subBundleRef')				= ((each getTable: bundleTable) getField: 'primaryKey')].	allBundlesQuery := Query read: StoreVersionlessBundle.	topLevelBundlesQuery := allBundlesQuery minus: containedBundlesQuery.	^topLevelOnly ifTrue: [topLevelBundlesQuery] ifFalse: [allBundlesQuery].</body><body package="StoreForGlorpReplication">topLevelPackagesQuery	"The things we do in the name of efficiency.  We want to be reading versionless pundles here, but if we do an anySatisfy: to versions then we'll end up with two instances of the table and a join between them by name, which is slow. Also, if we refer directly to parent bundles that's a double join, one to the link table and one to the other side. We only care if they exist, so a link table row is sufficient. So go directly down to the field level."	| packageLinkTable allPackagesQuery containedPackagesQuery topLevelPackagesQuery packageTable |	packageTable := self sourceSession system tableNamed: 'TW_Package'.	packageLinkTable := self sourceSession system tableNamed: 'TW_Packages'.	containedPackagesQuery := Query read: StoreVersionlessPackage.	containedPackagesQuery		whereClause: [:each | ((each getTable: packageLinkTable) getField: 'packageRef')				= ((each getTable: packageTable) getField: 'primaryKey')].	allPackagesQuery := Query read: StoreVersionlessPackage.	topLevelPackagesQuery := allPackagesQuery minus: containedPackagesQuery.	^topLevelOnly ifTrue: [topLevelPackagesQuery] ifFalse: [allPackagesQuery].</body><body package="StoreForGlorpReplication">topLevelPackagesQueryIn: aSession	"The things we do in the name of efficiency.  We want to be reading versionless pundles here, but if we do an anySatisfy: to versions then we'll end up with two instances of the table and a join between them by name, which is slow. Also, if we refer directly to parent bundles that's a double join, one to the link table and one to the other side. We only care if they exist, so a link table row is sufficient. So go directly down to the field level."	| packageLinkTable allPackagesQuery containedPackagesQuery topLevelPackagesQuery packageTable |	packageTable := aSession system tableNamed: 'TW_Package'.	packageLinkTable := aSession system tableNamed: 'TW_Packages'.	containedPackagesQuery := Query read: StoreVersionlessPackage.	containedPackagesQuery		whereClause: [:each | ((each getTable: packageLinkTable) getField: 'packageRef')				= ((each getTable: packageTable) getField: 'primaryKey')].	allPackagesQuery := Query read: StoreVersionlessPackage.	topLevelPackagesQuery := allPackagesQuery minus: containedPackagesQuery.	^topLevelOnly ifTrue: [topLevelPackagesQuery] ifFalse: [allPackagesQuery].</body></methods><methods><class-id>Store.Glorp.StoreReplicationManager class</class-id> <category>instance creation</category><body package="StoreForGlorpReplication">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Store.Glorp.LogToFile</class-id> <category>events-replicator</category><body package="StoreForGlorpReplication">checkingInformationInOldVersionsFor: aPundleName	Transcript cr; show: 'Checking information in old versions for ', aPundleName; flush</body><body package="StoreForGlorpReplication">disconnected	Transcript cr; show: 'Disconnected...'; flush</body><body package="StoreForGlorpReplication">examining: aPundleName depth: anInteger	"('Components of *' match: aPundleName) ifFalse: [		pundle := aPundleName.		self show ]"</body><body package="StoreForGlorpReplication">givingUpAfterTooManyFailures	Transcript cr; show: 'Too many retries. Operation failed.'; flush</body><body package="StoreForGlorpReplication">reconnectingTo: aString	Transcript cr; show: 'Reconnecting to ', aString, ' database'; flush</body><body package="StoreForGlorpReplication">replicating: aNumber versionsOf: aPundleName from: sourceSession to: targetSession depth: anInteger	Transcript cr; print: aNumber;		nextPutAll: ' version(s) of ';		nextPutAll: aPundleName;		nextPutAll: ' to replicate from ';		nextPutAll: sourceSession accessor currentLogin name;		nextPutAll: ' to ';		nextPutAll: targetSession accessor currentLogin name;		flush</body><body package="StoreForGlorpReplication">replicatingAllVersionsOf: aPundleName from: sourceSession to: targetSession	Transcript		cr; show: ('*******WARNING: Replicating *ALL* versions of &lt;1s&gt; from &lt;2s&gt; to &lt;3s&gt;!'					expandMacrosWith: aPundleName					with: sourceSession accessor currentLogin name asString					with: targetSession accessor currentLogin name asString);		show: ' The "Skip Old Versions" flag is ON, but there isn''t any shared version between the two repositories.';		flush</body></methods><methods><class-id>Store.Glorp.LogToFile</class-id> <category>events-auto replicator</category><body package="StoreForGlorpReplication">autoReplicateLoginError: anException from: sourceName to: targetName	Transcript cr;		nextPutAll: sourceName; nextPutAll: ' -&gt; '; nextPutAll: targetName;				nextPutAll: ': Login failure - '; print: anException;		flush</body><body package="StoreForGlorpReplication">autoReplicating: aPundleName from: sourceName to: targetName	pundle = aPundleName ifFalse: [		pundle := aPundleName.		Transcript cr; nextPutAll: pundle; space ].	sourceName = 'local'		ifTrue: [ Transcript nextPutAll: '-&gt;'; nextPutAll: targetName ]		ifFalse: [ Transcript nextPutAll: '-&gt;, ' ].	Transcript flush</body><body package="StoreForGlorpReplication">finishedAutoReplicationAt: aTime	pundle := nil.	Transcript cr;		nextPutAll: 'Finished auto-replication at ', aTime printString;		flush</body><body package="StoreForGlorpReplication">startingAutoReplicationAt: aTime	Transcript cr; cr;		nextPutAll: 'Starting auto-replication at ', aTime printString;		flush</body></methods><methods><class-id>Store.Glorp.LogToFile</class-id> <category>events-individual pundle replicator</category><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration 	Transcript cr;		show: ' Done ' , aPundle displayString;		show: ' at ' , endTime printString;		show: ' (' , duration printString, ' seconds)';		flush</body><body package="StoreForGlorpReplication">invalidPundle: aPundle	 Transcript cr; show: 'Invalid ' , aPundle printString; flush</body><body package="StoreForGlorpReplication">patchingParentFor: targetPundle	 Transcript cr; show: 'Patching parent for ', targetPundle printString; flush</body><body package="StoreForGlorpReplication">reconcilingPundle: aPundle	 Transcript cr; show: 'Reconciling ', aPundle displayString; flush</body><body package="StoreForGlorpReplication">skipping: aPundle time: aTime	Transcript cr;		nextPutAll: 'SKIPPING ' , aPundle displayString;		flush</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime	self startingReplicationOf: aPundle time: aTime depth: 0</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime depth: anInteger	Transcript	cr;			nextPutAll: operation, ' ' , aPundle displayString;			nextPutAll: ' starting at ';			print: aTime.	anInteger &lt; 1 ifTrue: [		Transcript cr; nextPutAll: aPundle versionComment asString ].	Transcript flush</body><body package="StoreForGlorpReplication">updatingBlessingsFor: targetPundle	 Transcript cr; show: 'Updating blessings for ', targetPundle printString; flush</body></methods><methods><class-id>Store.Glorp.ReplicationRule</class-id> <category>accessing</category><body package="StoreForGlorpReplication">addSecondary: aString	"A complete hack. If we encounter a +, then that's not a secondary database, it means this is a one-way replication"	aString = '+' ifTrue: [^self oneWay: true].	secondaries add: aString.</body><body package="StoreForGlorpReplication">isBundle	^isBundle</body><body package="StoreForGlorpReplication">isBundle: aBoolean	isBundle := aBoolean</body><body package="StoreForGlorpReplication">name	^name</body><body package="StoreForGlorpReplication">name: aString	name := aString</body><body package="StoreForGlorpReplication">oneWay	^oneWay</body><body package="StoreForGlorpReplication">oneWay: aBoolean	oneWay := aBoolean</body><body package="StoreForGlorpReplication">primary	^primary</body><body package="StoreForGlorpReplication">primary: aString	primary := aString</body><body package="StoreForGlorpReplication">secondary: aString	self addSecondary: aString.</body></methods><methods><class-id>Store.Glorp.ReplicationRule</class-id> <category>initialize-release</category><body package="StoreForGlorpReplication">initialize	secondaries := OrderedCollection new.	oneWay := false.</body></methods><methods><class-id>Store.Glorp.ReplicationRule</class-id> <category>replicating</category><body package="StoreForGlorpReplication">replicateIn: aStoreAutoReplicator	"Apply our rule to the replicator"	secondaries do: [:each |		self replicateIndividualTo: each in: aStoreAutoReplicator].</body><body package="StoreForGlorpReplication">replicateIndividualTo: aRepositoryName in: aStoreAutoReplicator	"Replicate a package or bundle between two databases"	isBundle 		ifTrue: [			aStoreAutoReplicator replicateBundleNamed: name from: primary to: aRepositoryName.			oneWay ifFalse: [				aStoreAutoReplicator replicateBundleNamed: name from: aRepositoryName to: primary]]		ifFalse: [			aStoreAutoReplicator replicatePackageNamed: name from: primary to: aRepositoryName.			oneWay ifFalse: [				aStoreAutoReplicator replicatePackageNamed: name from: aRepositoryName to: primary]].</body></methods><methods><class-id>Store.Glorp.ReplicationRule</class-id> <category>printing</category><body package="StoreForGlorpReplication">definitionString	| result |	result := (isBundle ifTrue: ['B'] ifFalse: ['P']), ',', name,',', primary.	oneWay ifTrue: [result := result, ',+'].	secondaries do: [:each | result := result, ',', each].	^result.</body><body package="StoreForGlorpReplication">printOn: aStream	aStream nextPutAll: 'Copy ', (isBundle ifTrue: ['Bundle'] ifFalse: ['Package']), ' "',name, '" between "', primary.	aStream nextPutAll: '" and '.	secondaries do: [:each |		aStream nextPut: $".		aStream nextPutAll: each.		aStream nextPut: $".		each = secondaries last ifFalse: [aStream nextPut: $,]].</body></methods><methods><class-id>Store.Glorp.ReplicationRule class</class-id> <category>examples</category><body package="StoreForGlorpReplication">example1	"self example1 replicateIn: StoreAutoReplicator new"	^self new		name: 'StoreForGlorpReplication';		isBundle: false;		primary: 'cst';		secondary: 'very local postgres'.</body><body package="StoreForGlorpReplication">exampleRuleStream	"self readFrom: self exampleRuleStream"	^'P,StoreForGlorpReplication,cst,very local postgres' readStream.</body><body package="StoreForGlorpReplication">exampleRuleStream2	"self readFrom: self exampleRuleStream2"	^'B,Glorp,cst,very local postgres' readStream.</body></methods><methods><class-id>Store.Glorp.ReplicationRule class</class-id> <category>instance creation</category><body package="StoreForGlorpReplication">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="StoreForGlorpReplication">readFrom: aStream	| result line tokens |	result := self new.	line := aStream upTo: Character cr.	tokens := line tokensBasedOn: $,.	result isBundle: tokens first = 'B'.	result name: (tokens at: 2).	result primary: (tokens at: 3).	4 to: tokens size do: [:i | 		result addSecondary: (tokens at: i) trimBlanks].	^result.</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>accessing</category><body package="StoreForGlorpReplication">alreadyCheckedBundles	"Note that we lazy initialize this, but we reset both at the same time. This is because these are shared amongst copied instances for sub-components, so we want to make sure they're already initialized, but we also have the persistent instance in the auto-replicator, who may need to lazy initialize them. "	alreadyCheckedBundles isNil ifTrue: [self resetAlreadyChecked].	^alreadyCheckedBundles.</body><body package="StoreForGlorpReplication">alreadyCheckedPackages	alreadyCheckedPackages isNil ifTrue: [self resetAlreadyChecked].	^alreadyCheckedPackages.</body><body package="StoreForGlorpReplication">defaultNumberToReplicateAtOnce	^10.</body><body package="StoreForGlorpReplication">depth	depth isNil ifTrue: [depth := 0].	^depth.</body><body package="StoreForGlorpReplication">depth: anInteger	depth := anInteger.</body><body package="StoreForGlorpReplication">hasMatchingVersion	"Return true if the source and target databases have a common version. That means that if we're skipping old versions, we only need to go from that point forward. Note that if you ask this question before it's been computed, you'll get a meaningless answer"	^oldestMatchingVersion notNil.</body><body package="StoreForGlorpReplication">isBundle	^isBundle</body><body package="StoreForGlorpReplication">isBundle: anObject	isBundle := anObject</body><body package="StoreForGlorpReplication">isLoggedIn	^sourceSession accessor isLoggedIn and: [targetSession accessor isLoggedIn].</body><body package="StoreForGlorpReplication">isReplicating	^sourceSession notNil.</body><body package="StoreForGlorpReplication">login	sourceSession isLoggedIn ifFalse: [sourceSession login].	targetSession isLoggedIn ifFalse: [targetSession login].</body><body package="StoreForGlorpReplication">logout	[sourceSession accessor logout] on: Dialect error do: [:ex | ex return: nil].	[targetSession accessor logout] on: Dialect error do: [:ex | ex return: nil].	sourceSession isNil ifFalse: [sourceSession reset].	targetSession isNil ifFalse: [targetSession reset].	self retries: 0.	self resetAlreadyChecked.</body><body package="StoreForGlorpReplication">maximumRetries: anInteger	maximumRetries := anInteger.</body><body package="StoreForGlorpReplication">numberToReplicateAtOnce	numberToReplicateAtOnce isNil ifTrue: [numberToReplicateAtOnce := self defaultNumberToReplicateAtOnce].	^numberToReplicateAtOnce.</body><body package="StoreForGlorpReplication">numberToReplicateAtOnce: anInteger	numberToReplicateAtOnce := anInteger.</body><body package="StoreForGlorpReplication">numberToReplicateAtOnceOf: aPundleSpecification	"If the pundle takes a lot of memory, then replicate in smaller chunks. A guess, because we have no idea how big the packages actually are. If we're doing bundles, note that making this increment too small actually hurts performance if replicating multiple versions of the same thing, so give it a minimum size."	| heuristicNumber query |	"Do a read-many here in order to work around a stupid bug with a cache hit on a read-one vs. a retrieve that doesn't actually bring back the object"	query := Query		read: self pundleType		where: [:each | each primaryKey = aPundleSpecification last].	heuristicNumber := self pundleType isBundle		ifTrue: [ | aPundle |			aPundle := (sourceSession execute: query) first.			(aPundle bundles size * 5 + (aPundle packages size max: 1)) // 8]		ifFalse: [ | count |			query retrieve: [:each | each methods countStar].			count := (sourceSession execute: query) first.			(count max: 1) // 1000].	^self numberToReplicateAtOnce // (heuristicNumber max: 1) max: 5.</body><body package="StoreForGlorpReplication">oldestMatchingVersion	^oldestMatchingVersion</body><body package="StoreForGlorpReplication">parentVersionName	^parentVersionName</body><body package="StoreForGlorpReplication">parentVersionName: aString	parentVersionName := aString</body><body package="StoreForGlorpReplication">replicateOnlyOriginalVersions	replicateOnlyOriginalVersions isNil ifTrue: [replicateOnlyOriginalVersions := false].	^replicateOnlyOriginalVersions.</body><body package="StoreForGlorpReplication">replicateOnlyOriginalVersions: aBoolean	replicateOnlyOriginalVersions := aBoolean</body><body package="StoreForGlorpReplication">replicateRecursively	replicateRecursively isNil ifTrue: [replicateRecursively := true].	^replicateRecursively.</body><body package="StoreForGlorpReplication">replicateRecursively: aBoolean	replicateRecursively := aBoolean.</body><body package="StoreForGlorpReplication">replicationLog	^replicationLog ifNil: [ replicationLog := self class replicationLog ]</body><body package="StoreForGlorpReplication">replicationLog: aReplicationLog	replicationLog := aReplicationLog</body><body package="StoreForGlorpReplication">retries: anInteger	retries := anInteger.</body><body package="StoreForGlorpReplication">shouldReplicateOnlyOriginalVersions	^replicateOnlyOriginalVersions.</body><body package="StoreForGlorpReplication">shouldReplicateOnlyOriginalVersions: aBoolean	replicateOnlyOriginalVersions := aBoolean</body><body package="StoreForGlorpReplication">skipOldVersions	^skipOldVersions</body><body package="StoreForGlorpReplication">skipOldVersions: aBoolean	skipOldVersions := aBoolean</body><body package="StoreForGlorpReplication">sourceDatabaseIdentifier	| session |	sourceDatabaseIdentifier isNil ifFalse: [^sourceDatabaseIdentifier].	session := self sourceSession.	session isNil ifTrue: [^'none'].	sourceDatabaseIdentifier := session system databaseIdentifier.	^sourceDatabaseIdentifier.</body><body package="StoreForGlorpReplication">sourceSession	^sourceSession</body><body package="StoreForGlorpReplication">sourceSession: aSession	sourceSession := aSession.	sourceDatabaseIdentifier := nil.	sourceSession accessor beReadOnly.	self packageAttributesToPreread do: [:each |		((sourceSession system descriptorFor: StorePackage) mappingForAttributeNamed: each) useFilteredRead].</body><body package="StoreForGlorpReplication">targetDatabaseIdentifier	| session |	targetDatabaseIdentifier isNil ifFalse: [^targetDatabaseIdentifier].	session := self targetSession.	session isNil ifTrue: [^'none'].	targetDatabaseIdentifier := session system databaseIdentifier.	^targetDatabaseIdentifier.</body><body package="StoreForGlorpReplication">targetSession	^targetSession</body><body package="StoreForGlorpReplication">targetSession: aSession	targetSession := aSession.	targetDatabaseIdentifier := nil.	targetSession accessor insertOnly.	self packageAttributesToPreread do: [:each |		((sourceSession system descriptorFor: StorePackage) mappingForAttributeNamed: each) useFilteredRead].</body><body package="StoreForGlorpReplication">targetVersionName	^targetVersionName</body><body package="StoreForGlorpReplication">targetVersionName: aString	targetVersionName := aString</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>replicating</category><body package="StoreForGlorpReplication">alreadyChecked	^self isBundle		ifTrue: [self alreadyCheckedBundles]		ifFalse: [self alreadyCheckedPackages].</body><body package="StoreForGlorpReplication">alreadyPresentVersionOf: aPundle	"It is possible for there to be two different versions simultaneously published, so distinguish them by username. We can't rely on the version name because of possible renaming, but the likelihood the two were published by the same user starts to make it very remote."	| alreadyThere  |	alreadyThere := targetSession readOneOf: self pundleType				where: 					[:each |					(each timestamp = aPundle timestamp) &amp; (each name = aPundle name) &amp; (each username = aPundle username)].	^alreadyThere</body><body package="StoreForGlorpReplication">checkForAlreadyPresentVersionOf: aPundle	| alreadyThere |	alreadyThere := self alreadyPresentVersionOf: aPundle.	^alreadyThere notNil.</body><body package="StoreForGlorpReplication">filterOriginalVersions: realInstances 	"If we are only replicating out versions that originated in our source database, then filter out the ones that don't qualify, based on the replication notice"	^realInstances reject: 			[:each | 			replicateOnlyOriginalVersions and: 					[each blessings anySatisfy: 							[:eachBlessing | 							| matchIndex shouldBeSkipped |							matchIndex := eachBlessing comment 										indexOfSubCollection: 'to: ' , self sourceDatabaseIdentifier										startingAt: 1.							shouldBeSkipped := matchIndex ~= 0.							shouldBeSkipped								ifTrue: [									self noteDone: each.									self skipping: each time: Timestamp now].							shouldBeSkipped]]]</body><body package="StoreForGlorpReplication">findOldestCommonVersion	oldestMatchingVersion := nil.	skipOldVersions ifFalse: [^1-&gt;1].	1 to: targetPundleIdentifiers size do: [:i |		| eachToPkg |		eachToPkg := targetPundleIdentifiers at: i.		1 to: sourcePundleIdentifiers size do: [:j |			| eachFromPkg |			eachFromPkg := sourcePundleIdentifiers at: j.			(eachFromPkg at: 2) = (eachToPkg at: 2) 				ifTrue: [					oldestMatchingVersion := eachFromPkg.					^j -&gt; i]]].	^1-&gt;1.</body><body package="StoreForGlorpReplication">fixExistingVersionsOf: aPundleName	self shouldFixExistingVersions		ifTrue:			[| parentlessVersions extraBlessingVersions |			self replicationLog checkingInformationInOldVersionsFor: aPundleName.			parentlessVersions := targetSession				read: self pundleType				where: [:each | each name = aPundleName &amp; (each previousID = 0)].			parentlessVersions				do:					[:each | (self pundleWriterClass for: self) fixParentFor: each].			extraBlessingVersions := sourceSession				read: self pundleType				where: [:each | each name = aPundleName &amp; (each blessings sqlCount &gt; 1)].			extraBlessingVersions				do:					[:each | (self pundleWriterClass for: self) fixBlessingsFor: each]].</body><body package="StoreForGlorpReplication">handleDisconnect: ex	| isForSourceConnection |	self replicationLog disconnected.	retries &gt; maximumRetries		ifTrue: [			self replicationLog givingUpAfterTooManyFailures.			ex pass].	sourceSession isNil ifTrue: [ex pass].	"We were logged out"	isForSourceConnection := ex accessor == sourceSession accessor.	^(isForSourceConnection or: [ex accessor isInTransaction not])		ifTrue: [			retries := retries + 1.			self replicationLog reconnectingTo: (isForSourceConnection ifTrue: ['source'] ifFalse: ['target']).			ex resume: true]		ifFalse: [ex pass].</body><body package="StoreForGlorpReplication">hasAlreadyChecked: aPundleName	"And while we're at it, skip anything named Garbage. Mostly because that's what I do when I don't have delete permission in the database in order to get rid of stuff"	aPundleName = 'Garbage' ifTrue: [^true].	^self alreadyChecked includes: (self pundleNamePlusDatabaseIdentifiersFor: aPundleName).</body><body package="StoreForGlorpReplication">hasAlreadyCheckedPundle: aPundle	"Have we already examined this particular pundle"	| checkedSet |	aPundle name = 'Garbage' ifTrue: [^true].	checkedSet := aPundle isBundle		ifTrue: [self alreadyCheckedBundles]		ifFalse: [self alreadyCheckedPackages].	^checkedSet includes: (self pundleNamePlusDatabaseIdentifiersFor: aPundle name).</body><body package="StoreForGlorpReplication">isReplicatingVersionless	"Return true if we are in the middle of replicating a versionless pundle, false if we are replicating an individual version. Used when checking sub-components. If we were originally replicating versionless, then do the sub-components versionlessly as well. If we were doing a specific version, then only replicate the specific versions of sub-components"	^sourcePundleIdentifiers notNil.</body><body package="StoreForGlorpReplication">mostRecentVersionOf: aPundleName	| result |	[[	| q |	q := Query readOneOf: self pundleType where: [:each | each name = aPundleName].	q orderBy: [:each | each timestamp descending].	q limit: 1.	result := sourceSession execute: q.	false] on: GlorpDatabaseReadError		do:			[:ex | 			self handleDisconnect: ex.			true]] whileTrue.	^result.</body><body package="StoreForGlorpReplication">noteChecking: aPundleName	self alreadyChecked add: (self pundleNamePlusDatabaseIdentifiersFor: aPundleName).</body><body package="StoreForGlorpReplication">noteDone: newPundle	newPundle isNil ifTrue: [^self].	^targetPundleIdentifiers		add:			(Array				with: newPundle name				with: newPundle timestamp				with: newPundle username				with: newPundle primaryKey).</body><body package="StoreForGlorpReplication">pundleMatching: pundleFromAnotherSession	| targetClass ourPundle |	targetClass := pundleFromAnotherSession isBundle		ifTrue: [StoreBundle]		ifFalse: [StorePackage].	ourPundle := sourceSession		readOneOf: targetClass		where: [:each | each primaryKey = pundleFromAnotherSession primaryKey].	^ourPundle.</body><body package="StoreForGlorpReplication">pundleNamePlusDatabaseIdentifiersFor: aPundleName	^aPundleName, ' from: ', self sourceSession accessor currentLogin name, ' to: ', self targetSession accessor currentLogin name.</body><body package="StoreForGlorpReplication">pundleType	^isBundle ifTrue: [StoreBundle] ifFalse: [StorePackage].</body><body package="StoreForGlorpReplication">readIdentifiersForPundleNamed: aPundleName from: aSession	| query |	query := Query		read: self pundleType		where: [:each | each name = aPundleName].	StoreAutoReplicator default cutOffTimestamp ifNotNil: [ :cutOff |		query AND: [:each | each timestamp &gt;= cutOff ] ].	query retrieve: [:each | each name].	query retrieve: [:each | each timestamp].	query retrieve: [:each | each username].	query retrieve: [:each | each primaryKey].	query orderBy: [:each | each timestamp].	query collectionType: OrderedCollection.	^aSession execute: query.</body><body package="StoreForGlorpReplication">readPundleNamed: aPundleName from: aSession	^self readPundleNamed: aPundleName from: aSession additionalConditions: nil.</body><body package="StoreForGlorpReplication">readPundleNamed: aPundleName from: aSession additionalConditions: aBlock	| query |	query := Query		read: self pundleType		where: [:each | each name = aPundleName].	query alsoFetch: [:each | each comment beOuterJoin].	aSession system hasPropertiesAsBlob ifTrue:		[query alsoFetch: [:each | each propertiesBlob beOuterJoin]].	query collectionType: OrderedCollection.	query orderBy: [:each | each timestamp].	query AND: aBlock.	^aSession execute: query</body><body package="StoreForGlorpReplication">readPundleNamed: aPackageName withVersion: versionString	| query |	query := Query		readOneOf: self pundleType		where: [:each | each name = aPackageName &amp; (each version = versionString)].	query alsoFetch: [:each | each comment beOuterJoin].	sourceSession system hasPropertiesAsBlob ifTrue:		[query alsoFetch: [:each | each propertiesBlob beOuterJoin]].	 ^sourceSession execute: query</body><body package="StoreForGlorpReplication">readSourcesAndTargetsFor: aPundleName	| oldestIndexes |	sourcePundleIdentifiers isNil		ifTrue: 			[sourcePundleIdentifiers := self readIdentifiersForPundleNamed: aPundleName						from: sourceSession.			targetPundleIdentifiers := self readIdentifiersForPundleNamed: aPundleName						from: targetSession.			knownInvalid do: 					[:each |					sourcePundleIdentifiers remove: each						ifAbsent: [knownInvalid := OrderedCollection new]]].	oldestIndexes := self findOldestCommonVersion.	sourcePundleIdentifiers := sourcePundleIdentifiers				copyFrom: oldestIndexes key				to: sourcePundleIdentifiers size.	targetPundleIdentifiers := targetPundleIdentifiers				copyFrom: oldestIndexes value				to: targetPundleIdentifiers size.	^self versionsNotReplicated</body><body package="StoreForGlorpReplication">replicateFirstFewOfPundleNamed: aPundleName 	"This is rather ugly. Memory gets out of hand, so only do a few at a time, then reset the sessions"	| notReplicated shortList realInstances |	notReplicated := self readSourcesAndTargetsFor: aPundleName.	notReplicated isEmpty ifTrue: [^false].	(skipOldVersions and: [self hasMatchingVersion not]) 		ifTrue: 			[self replicationLog 				replicatingAllVersionsOf: aPundleName				from: sourceSession				to: targetSession].	self replicationLog 		replicating: notReplicated size		versionsOf: aPundleName		from: sourceSession		to: targetSession		depth: self depth.	shortList := (notReplicated copyFrom: 1				to: ((self numberToReplicateAtOnceOf: notReplicated first) 						min: notReplicated size)) 					collect: [:each | each last].	realInstances := self 				readPundleNamed: aPundleName				from: sourceSession				additionalConditions: [:each | each primaryKey in: shortList].	realInstances := self filterOriginalVersions: realInstances.	realInstances do: 			[:each | 			self replicatePundleSkippingErrorsAsInvalidPundles: each.			self noteDone: each].	sourceSession initializeCache.	targetSession initializeCache.	Dialect garbageCollect.	^true</body><body package="StoreForGlorpReplication">replicatePundle: aPundle	isBundle := aPundle isBundle.	^	[(self checkForAlreadyPresentVersionOf: aPundle)		ifTrue: [nil]		ifFalse: 			[			self replicateSubComponentsOfPundle: aPundle.			aPundle currentBlessingLevel = -54 ifFalse: [(self pundleWriterClass for: self) writePundle: aPundle]]]			on: GlorpDatabaseReadError			do: 				[:ex |				self handleDisconnect: ex.				nil]</body><body package="StoreForGlorpReplication">replicatePundleNamed: aPundleName	(self hasAlreadyChecked: aPundleName) ifTrue: [self replicationLog skipping: aPundleName depth: depth. ^self].	self replicationLog examining: aPundleName depth: self depth.	self noteChecking: aPundleName.	self replicateSubComponentsOfPundleNamed: aPundleName.	sourcePundleIdentifiers := nil.	targetPundleIdentifiers := nil.	knownInvalid := OrderedCollection new.	[[[self replicateFirstFewOfPundleNamed: aPundleName] 		on: InvalidStorePundleError		do:			[:ex | 			knownInvalid				add:					(Array						with: ex pundle name						with: ex pundle timestamp						with: ex pundle primaryKey).			sourcePundleIdentifiers remove: knownInvalid last.			ex return: true]]		on: GlorpDatabaseReadError		do:			[:ex | 			self handleDisconnect: ex.			true]] whileTrue.	[self fixExistingVersionsOf: aPundleName]		on: GlorpDatabaseReadError		do: [:ex | self handleDisconnect: ex].	sourceSession reset.	targetSession reset.	sourcePundleIdentifiers := nil.	targetPundleIdentifiers := nil.</body><body package="StoreForGlorpReplication">replicatePundleNamed: aPackageName version: versionString	| pundle |	pundle := self readPundleNamed: aPackageName withVersion: versionString.	pundle isNil ifTrue: [self error: 'package not found'].	^self replicatePundleSkippingErrorsAsInvalidPundles: pundle.</body><body package="StoreForGlorpReplication">replicatePundleSkippingErrorsAsInvalidPundles: aPundle	"Replicate the pundle, but if we encounter a character encoding error, turn it into an 	invalid pundle error, so that we will skip over it. This is for pundles which have characters 	in comments, class names, etc. that we can't store into a particular database due to encoding issues. 	If would be better if the information about the invalid character was preserved in the new exception, but 	that would require rework of the other InvalidStorePundleError invokers. VisualWorks specific"	^[self replicatePundle: aPundle]		on: UnsupportedCharacterError		do: [:ex | (InvalidStorePundleError new pundle: aPundle) signal]</body><body package="StoreForGlorpReplication">replicateSubComponentsOfPundle: aPundle	self pundleType isBundle ifFalse: [^self].	self replicationLog examining: 'Components of ', aPundle displayString depth: self depth.	aPundle bundles do: [:each | 			self copy replicatePundle: each].	aPundle packages do: [:each | 			self copy replicatePundle: each].</body><body package="StoreForGlorpReplication">replicateSubComponentsOfPundleNamed: aPundleName	| latest |	self pundleType isBundle ifFalse: [^self].	self replicationLog		examining: 'Components of ' , aPundleName		depth: self depth.	latest := self mostRecentVersionOf: aPundleName.	latest isNil ifTrue: [^self].	latest bundles do: [:each | self copy replicateBundleNamed: each name].	latest packages do: [:each | self copy replicatePackageNamed: each name].</body><body package="StoreForGlorpReplication">shouldFixExistingVersions	shouldFixExistingVersions isNil ifTrue: [shouldFixExistingVersions := false].	^shouldFixExistingVersions.</body><body package="StoreForGlorpReplication">shouldFixExistingVersions: aBoolean	shouldFixExistingVersions := aBoolean.</body><body package="StoreForGlorpReplication">versionsNotReplicated	"Versions are considered not to have been replicated if they match on name (we know that already from the query) and if their timestamp and username are the same. Different packages published with the same timestamp are not unlikely, since the resolution is only 1 second, but having them published by the same user should be unlikely." 	| notReplicated |	notReplicated := sourcePundleIdentifiers select: 	[:eachFromPkg |					(targetPundleIdentifiers						anySatisfy: [:eachToPkg | 							(eachFromPkg at: 2) = (eachToPkg at: 2) and: [								(eachFromPkg at: 3) = (eachToPkg at: 3)]]) not].	^notReplicated</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>api</category><body package="StoreForGlorpReplication">hasIndexes	^hasIndexes</body><body package="StoreForGlorpReplication">hasIndexes: aBoolean	"Set whether this database has indexes or not, which will govern some of our tweaks for performance"	hasIndexes := aBoolean.</body><body package="StoreForGlorpReplication">replicateBundleNamed: aPackageName	isBundle := true.	self replicatePundleNamed: aPackageName.</body><body package="StoreForGlorpReplication">replicateBundleNamed: aPackageName version: versionString	| |	isBundle := true.	self replicatePundleNamed: aPackageName version: versionString.</body><body package="StoreForGlorpReplication">replicatePackageNamed: aPackageName	isBundle := false.	^self replicatePundleNamed: aPackageName.</body><body package="StoreForGlorpReplication">replicatePackageNamed: aPackageName version: versionString	| |	isBundle := false.	self replicatePundleNamed: aPackageName version: versionString.</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>logging</category><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration	self replicationLog finishedReplicationOf: aPundle time: endTime duration: duration depth: self depth.</body><body package="StoreForGlorpReplication">invalidPundle: aPundle	self replicationLog invalidPundle: aPundle</body><body package="StoreForGlorpReplication">log: aString for: aBlock	| ms |	self replicationLog startingActivity: aString.	ms := Time millisecondsToRun: aBlock.	self replicationLog finishingActivity: aString duration: ms</body><body package="StoreForGlorpReplication">patchingParentFor: targetPundle	self replicationLog patchingParentFor: targetPundle</body><body package="StoreForGlorpReplication">reconcilingPundle: aPundle	self replicationLog reconcilingPundle: aPundle</body><body package="StoreForGlorpReplication">skipping: aPundle time: aTime	self replicationLog skipping: aPundle time: aTime</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime	self replicationLog startingReplicationOf: aPundle time: aTime depth: self depth.</body><body package="StoreForGlorpReplication">updatingBlessingsFor: targetPundle	self replicationLog updatingBlessingsFor: targetPundle</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>weird hacks</category><body package="StoreForGlorpReplication">setupSessionForSQLServer: session	"I wish I knew what was going on here"	| blobTable binaryBlobTable |	(session system platform class == SQLServerPlatform) ifTrue: [		blobTable := session system tableNamed: 'TW_Blob'.		binaryBlobTable := session system tableNamed: 'TW_BinaryBlob'.		(Array with: blobTable with: binaryBlobTable) do: [:each | 		(each schema isNil or: [each schema isEmpty]) 			ifTrue: [each schema: 'NEWBERN1']			ifFalse: [each schema: 'NEWBERN1.', each schema]].		session system allTables do: [:each |			(each ~~ blobTable and: [each ~~ binaryBlobTable])				ifTrue: [						(each schema isNil or: [each schema isEmpty]) 					ifTrue: [each schema: 'NEWBERN2']					ifFalse: [each schema: 'NEWBERN2.', each schema]]]].</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>initializing</category><body package="StoreForGlorpReplication">defaultMaximumRetries	^100.</body><body package="StoreForGlorpReplication">initialize	isBundle := false.	retries := 0.	maximumRetries := self defaultMaximumRetries.	knownInvalid := OrderedCollection new.	hasIndexes := false.	skipOldVersions := StoreAutoReplicator hasDefault ifTrue: [StoreAutoReplicator default skipOldVersions] ifFalse: [true].	shouldFixExistingVersions := false.	replicateOnlyOriginalVersions := false.	depth := 0.	self resetAlreadyChecked.</body><body package="StoreForGlorpReplication">postCopy	super postCopy.	oldestMatchingVersion := nil.	knownInvalid := nil.	depth := self depth + 1.</body><body package="StoreForGlorpReplication">resetAlreadyChecked	alreadyCheckedBundles := Set new: 100.	alreadyCheckedPackages := Set new: 100.</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>performance</category><body package="StoreForGlorpReplication">packageAttributesToPreread	"Return a list of package attributes that we wnat to use a filtered read on, so that we get all the elements of a bundle at once. We don't seem to be able to do this effectively for shared variables or for classes, as the optimizers seem to get very confused. Also, if the database doesn't have indexes this is probably not worthwhile"	^hasIndexes ifTrue: [#(#methods #nameSpaces)] ifFalse: [#()].</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>settings</category><body package="StoreForGlorpReplication">cutOffDate	^StoreAutoReplicator default cutOffDate.</body></methods><methods><class-id>Store.Glorp.StoreReplicator</class-id> <category>accessing-classes</category><body package="StoreForGlorpReplication">pundleWriterClass	^ReplicatorPundleWriter</body></methods><methods><class-id>Store.Glorp.StoreReplicator class</class-id> <category>accessing</category><body package="StoreForGlorpReplication">defaultReplicationLog	^FullTranscriptLog new</body><body package="StoreForGlorpReplication">replicationLog	^replicationLog ifNil: [ replicationLog := self defaultReplicationLog ]</body><body package="StoreForGlorpReplication">replicationLog: aReplicationLog	replicationLog := aReplicationLog</body></methods><methods><class-id>Store.Glorp.StoreReplicator class</class-id> <category>instance creation</category><body package="StoreForGlorpReplication">new	^super new initialize.</body></methods><methods><class-id>Store.Glorp.RenamingRule</class-id> <category>accessing</category><body package="StoreForGlorpReplication">parentVersion	^parentVersion</body><body package="StoreForGlorpReplication">parentVersion: anObject	parentVersion := anObject</body><body package="StoreForGlorpReplication">sourceVersion	^sourceVersion</body><body package="StoreForGlorpReplication">sourceVersion: aString	sourceVersion := aString</body><body package="StoreForGlorpReplication">targetVersion	^targetVersion</body><body package="StoreForGlorpReplication">targetVersion: aString	targetVersion := aString</body></methods><methods><class-id>Store.Glorp.RenamingRule</class-id> <category>replicating</category><body package="StoreForGlorpReplication">replicateIndividualTo: aRepositoryName in: aStoreAutoReplicator	"Replicate a package or bundle between two databases"		aStoreAutoReplicator replicatePundleNamed: name changingVersionNameFrom:			sourceVersion to: targetVersion withParentNamed: parentVersion		fromRepository: primary to: aRepositoryName bundle: isBundle.	"I'm not sure this won't be happening anyway, but let's do it just for good measure."	aStoreAutoReplicator replicator targetSession reset.	aStoreAutoReplicator replicator sourceSession reset.</body></methods><methods><class-id>Store.Glorp.RenamingRule class</class-id> <category>examples</category><body package="StoreForGlorpReplication">example1	"self example1 replicateIn: StoreAutoReplicator new"	^self new		name: 'Base VisualWorks';		isBundle: true;		primary: 'localPostgres';		sourceVersion: '7.5.1 feb08.2 - 1.2';		targetVersion: '7.6';		secondary: 'very local postgres'.</body><body package="StoreForGlorpReplication">example75	"self example75 replicateIn: StoreAutoReplicator new"	^self new		name: 'Base VisualWorks';		isBundle: true;		primary: 'localPostgres';		sourceVersion: '7.5 apr07.2 - 1.0';		targetVersion: '7.5';		secondary: 'very local postgres'.</body><body package="StoreForGlorpReplication">example76	"self example76 replicateIn: StoreAutoReplicator new"	^self new		name: 'Base VisualWorks';		isBundle: true;		primary: 'localPostgres';		sourceVersion: '7.5.1 feb08.2 - 1.2';		targetVersion: '7.6';		parentVersion: '7.5';		secondary: 'very local postgres'.</body><body package="StoreForGlorpReplication">hardCodedRulesFor75	"There are things not in the spec files for 75 that we hard-code here."	^#(		('Base VisualWorks' bundle '7.5 apr07.2 - 1.0')		('StoreBase' bundle '7.5 - 1.52')		('Tools-IDE' bundle '7.5 - 1.34')		('LoggingTool' package '7.2 3')		('Windows ColorDepth Workaround' package '0.9')		('OldBrowsers' package '7.5 - 1.3')		('Lens-Namespace' package '5i.4  -  1.3')		('LDM-Framework' package '7.1 - 1.1')		('BOSS' package '5i.4 - 1.23')		('Database' package '7.5 - 1.3')		('Database-Namespace' package '5i 1.8')		('OracleEXDI' package '7.5 -  4.6')		('StoreForOracle' package '7.3 - 1.1')		('StoreOracle' package '7.4 - 1.1')		('URISupport' package '75 1')		('StoreBase' bundle '7.5 - 1.52')		('FixedPaletteFixes' package '1')		('DB2EXDI' package '1.0')		('DB2ThapiEXDI' package '1.0')		)		collect: [:each | 		RenamingRule new 			name: each first;		isBundle: ((each at: 2) = #bundle);		sourceVersion: each last;		targetVersion: '7.5'].</body><body package="StoreForGlorpReplication">hardCodedRulesFor76	"There are things not in the spec files for 76 that we hard-code here."	^#(		('Base VisualWorks' bundle '7.5.1 mar08.1 - 1.0')		('Tools-IDE' bundle '7.6 jan08.4 - 1')		)		collect: [:each | 		RenamingRule new 			name: each first;		isBundle: ((each at: 2) = #bundle);		sourceVersion: each last;		targetVersion: '7.5'].</body><body package="StoreForGlorpReplication">replicateAs75	"Replicate everything from VW 7.5 into the the vw-dev repository. Relies on being able to be connected to Cincom's internal repository, and running in the appropriate build. Also assumes that you've copied over the 75 spec files into a directory called specs1.75. In other words, it's a completely fragile one-off."	"RenamingRule replicateAs75"		| rules replicator source target |	source := 'localPostgres'.	target := 'very local postgres'.	Tools.BuildingSpace.AbstractParcelSpecification defaultSpecsDirectoryName: 'specs1.75'.	rules := Tools.BuildingSpace.AbstractParcelSpecification allSpecificationsFromBearToBeShipped		collect: [:each | 			(RenamingRule new)				name: each dbName;				isBundle: each representsBundle;				primary: source;				sourceVersion: each databasePundleEntity version;				targetVersion: '7.5';				secondary: target ].	rules addAll: (self hardCodedRulesFor75 do: [:each | each primary: source; secondary: target]).	replicator := StoreAutoReplicator new.	rules do: [:each | each replicateIn: replicator].</body><body package="StoreForGlorpReplication">replicateAs76	"Replicate everything from VW 7.6 into the the vw-dev repository. Relies on being able to be connected to Cincom's internal repository, and running in the appropriate build."	"RenamingRule replicateAs76"		| rules replicator source target |	source := 'localPostgres'.	target := 'very local postgres'.	Tools.BuildingSpace.AbstractParcelSpecification defaultSpecsDirectoryName: nil.	rules := Tools.BuildingSpace.AbstractParcelSpecification allSpecificationsFromBearToBeShipped		collect: [:each | 			(RenamingRule new)				name: each dbName;				isBundle: each representsBundle;				primary: source;				sourceVersion: each databasePundleEntity version;				targetVersion: '7.6';				parentVersion: '7.5';				secondary: target].	rules addAll: (self hardCodedRulesFor76 do: [:each | each primary: source; secondary: target]).	replicator := StoreAutoReplicator new.	rules do: [:each | each replicateIn: replicator].</body></methods><methods><class-id>Store.Glorp.RenamingRule class</class-id> <category>instance creation</category><body package="StoreForGlorpReplication">readFrom: aStream	| result line tokens |	result := self new.	line := aStream upTo: Character cr.	tokens := line tokensBasedOn: $,.	result isBundle: tokens first = 'B'.	result name: (tokens at: 2).	result sourceVersion: (tokens at: 3).	result targetVersion: (tokens at: 4).	result primary: (tokens at: 5).	result addSecondary: (tokens at: 6) trimBlanks.	^result.</body></methods><methods><class-id>Store.Glorp.GlorpReplicationDontBotherToDoThisQuery class</class-id> <category>testing</category><body package="StoreForGlorpReplication">mayResume	^true.</body></methods><methods><class-id>Store.Glorp.FullTranscriptLog</class-id> <category>events-individual pundle replicator</category><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration 	Transcript cr;		show: ' Done ' , aPundle displayString;		show: ' at ' , endTime printString;		show: ' (' , duration printString, ' seconds)'</body><body package="StoreForGlorpReplication">finishedReplicationOf: aPundle time: endTime duration: duration depth: anInteger 	Transcript cr.	anInteger timesRepeat: [Transcript nextPut: $ ].	Transcript		show: ' Done ' , aPundle displayString;		show: ' at ' , endTime printString;		show: ' (' , duration printString, ' seconds)'</body><body package="StoreForGlorpReplication">invalidPundle: aPundle	 Transcript cr; show: 'Invalid ' , aPundle printString</body><body package="StoreForGlorpReplication">patchingParentFor: targetPundle	 Transcript cr; show: 'Patching parent for ', targetPundle printString</body><body package="StoreForGlorpReplication">reconcilingPundle: aPundle	 Transcript cr; show: '  Reconciling ', aPundle displayString</body><body package="StoreForGlorpReplication">skipping: aPundle time: aTime	Transcript cr; show: 'SKIPPING ' , aPundle displayString.</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime	Transcript cr; show: operation, ' ' , aPundle displayString.	Transcript show: ' starting at '; print: aTime.</body><body package="StoreForGlorpReplication">startingReplicationOf: aPundle time: aTime depth: anInteger	Transcript cr.	anInteger timesRepeat: [Transcript nextPut: $ ].	Transcript show: operation, ' ', aPundle displayString.	Transcript show: ' starting at '; print: aTime.</body><body package="StoreForGlorpReplication">updatingBlessingsFor: targetPundle	 Transcript cr; show: 'Updating blessings for ', targetPundle printString</body></methods><methods><class-id>Store.Glorp.FullTranscriptLog</class-id> <category>events-auto replicator</category><body package="StoreForGlorpReplication">autoReplicateLoginError: anException	Transcript show: '---------UNABLE TO LOG IN. SKIPPING --------------';cr.</body><body package="StoreForGlorpReplication">autoReplicateLoginError: anException from: sourceName to: targetName	| |	Transcript cr;show: '---------UNABLE TO LOG IN. SKIPPING --------------'.	Transcript cr; show: anException description asString.	Dialect isVisualWorks ifFalse: [^self].	self dumpHeadlessErrorLog.</body><body package="StoreForGlorpReplication">autoReplicating: aPundleName from: sourceName to: targetName	Transcript cr; show: 'Auto-replicating ', aPundleName, ' from ', sourceName, ' to ', targetName.</body><body package="StoreForGlorpReplication">autoReplicatingFrom: sourceName to: targetName	Transcript cr; show: 'Auto-replicating from ', sourceName, ' to ', targetName</body><body package="StoreForGlorpReplication">finishedAutoReplicationAt: aTime	Transcript cr; show: 'Finished auto-replication at ', aTime printString.</body><body package="StoreForGlorpReplication">startingAutoReplicationAt: aTime	Transcript cr; show: operation, ' at ', aTime printString.</body></methods><methods><class-id>Store.Glorp.FullTranscriptLog</class-id> <category>events-replicator</category><body package="StoreForGlorpReplication">checkingInformationInOldVersionsFor: aPundleName	Transcript cr; show: 'Checking information in old versions for ', aPundleName.</body><body package="StoreForGlorpReplication">disconnected	Transcript cr; show: 'Disconnected...'</body><body package="StoreForGlorpReplication">examining: aPundleName	Transcript cr; show: 'Examining ', aPundleName</body><body package="StoreForGlorpReplication">examining: aPundleName depth: anInteger	Transcript cr.	anInteger timesRepeat: [Transcript nextPut: $ ].	Transcript show: 'Examining ', aPundleName</body><body package="StoreForGlorpReplication">givingUpAfterTooManyFailures	Transcript cr; show: 'Too many retries. Replication failed.'</body><body package="StoreForGlorpReplication">reconnectingTo: aString	Transcript cr; show: 'Reconnecting to ', aString, ' database'.</body><body package="StoreForGlorpReplication">replicating: aNumber versionsOf: aPundleName from: sourceSession to: targetSession depth: anInteger	Transcript cr.	anInteger timesRepeat: [Transcript nextPut: $ ].	Transcript show: aNumber printString , ' version(s) need replicating.'.</body><body package="StoreForGlorpReplication">replicatingAllVersionsOf: aPundleName from: sourceSession to: targetSession	Transcript		cr; show: ('*******WARNING: Replicating *ALL* versions of &lt;1s&gt; from &lt;2s&gt; to &lt;3s&gt;!'					expandMacrosWith: aPundleName					with: sourceSession accessor currentLogin name asString					with: targetSession accessor currentLogin name asString);		show: ' The "Skip Old Versions" flag is ON, but there isn''t any shared version between the two repositories.'</body><body package="StoreForGlorpReplication">skipping: aPundleName depth: anInteger	"Transcript cr.	anInteger timesRepeat: [Transcript nextPut: $ ].	Transcript show: 'Skipping ', aPundleName, ' - already checked in this run'"</body></methods><methods><class-id>Store.Glorp.FullTranscriptLog</class-id> <category>events</category><body package="StoreForGlorpReplication">finishingActivity: aString duration: ms	Transcript show: (ms / 1000.0) printString, 's'.</body><body package="StoreForGlorpReplication">startingActivity: aString	Transcript cr; show: aString</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>enumerating</category><body package="StoreForGlorpReplication">componentsCollect: aBlock	"This updates each subpundle in place in my dictionaries' associations.  (So any shallow copy of me - e.g. my memento in an undoMap if I'm registered - will be updated in synch.  Do not call me unless that is the desired effect and/or I am newly-created and can have no copies.)"	bundles associationsDo: [:each | each value: (aBlock value: each value)].	packages associationsDo: [:each | each value: (aBlock value: each value)].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>fixups</category><body package="StoreForGlorpReplication">blessWithReplicationNoticeIn: aPundleWriter	| now replicationBlessing commentString blessingSession |	blessingSession := self session isNil ifTrue: [aPundleWriter targetSession] ifFalse: [self session].	now := Dialect storeTimestampIn: blessingSession.	replicationBlessing := StoreBlessing new.	replicationBlessing blessingLevel: self replicationNoticeBlessing.	commentString := 'Replicated by: ' , aPundleWriter targetUsername , ' from: '		, aPundleWriter sourceDatabaseIdentifier , ' to: ' , aPundleWriter targetDatabaseIdentifier.	replicationBlessing comment: commentString.	replicationBlessing timestamp: now.	replicationBlessing username: aPundleWriter targetUsername.	self blessings add: replicationBlessing.	self newComponentsDo: [:each | each blessWithReplicationNoticeIn: aPundleWriter].</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GlorpError</name><environment>Glorp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><class><name>StorePundleWriter</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle newPundle previousVersionInTargetDatabase targetSession preWriteAction splitPundles notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>Store-Database Model</package></attributes></class><class><name>StorePundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment properties propertiesBlob propertiesRecordDictionary version blessings currentBlessingLevel storeModel session versionless fullClasses </inst-vars><class-inst-vars>cache </class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Database Model</package></attributes></class><class><name>StoreBundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundles packages files </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class></st-source>