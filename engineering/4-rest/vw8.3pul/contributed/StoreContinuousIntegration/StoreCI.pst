<?xml version="1.0"?><st-source><!-- Name: StoreCINotice: The MIT LicenseCopyright (c) 2012 - 2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.BundleName: StoreCIBundleStructure: a Store.BundleForParcelComment: # StoreCIIntegrate Cincom Visualworks Smalltalk with a Continuous Integration server.StoreCI is licensed under the MIT license.  See the Copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.StoreCI's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).  Check there for the latest version.  It is also on [GitHub](https://github.com/randycoulman/StoreCI).StoreCI was developed in VW 7.9.1, but is compatible with VW 7.7 and later.  It uses the newer Glorp-based Store implementation, so will not work in 7.6 or earlier.  If you find any incompatibilities with VW 7.7 or later, let me know (see below for contact information) or file an issue on GitHub.# IntroductionStoreCI consists of the following components.  These components are designed to work together, but can be used independently if desired.  See the individual package comments for more details about each component.* StoreCI-Polling is a bridge between a Continuous Integration (CI) server and Visualworks Store.  It has been tested against Jenkins 1.466 and later using the [visualworks-store-plugin](https://wiki.jenkins-ci.org/display/JENKINS/Visualworks+Smalltalk+Store+Plugin).* StoreCI-Building loads a set of pundles from a Store repository into an image, and optionally deploys them as parcels.  It is intended to be used as part of an automated build, perhaps driven from a Continuous Integration system such as Jenkins or CruiseControl.* StoreCI-Testing runs a set of SUnitToo test cases and outputs the results in a JUnit-compatible XML format.  It is intended to be used as part of an automated build, perhaps driven from a Continuous Integration system such as Jenkins or CruiseControl.A common workflow is to use StoreCI-Polling to watch a Store repository for changes of interest, having it generate a "load-order" file.  Then, StoreCI-Building reads the load-order file, loads the parcels into an image, and then either saves the image or deploys parcels.  Finally, StoreCI-Testing runs all of the SUnitToo tests in the image or deployed parcels.# ContributingI'm happy to receive bug fixes and improvements to this package.  If you'd like to contribute, please publish your changes as a "branch" (non-integer) version in the Public Store Repository and contact me as outlined below to let me know.  I will merge your changes back into the "trunk" as soon as I can review them.# Contact InformationIf you have any questions about StoreCI and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Collections-Collation' '') #(#any 'Glorp' '') #(#any 'ParcelDeployment' '') #(#any 'StoreBase' '') #(#any 'SUnitToo' ''))Parcel: nilParcelName: StoreCIPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Collections-Collation' #componentType #package) #(#name 'Glorp' #componentType #bundle) #(#name 'ParcelDeployment' #componentType #package) #(#name 'StoreBase' #componentType #bundle) #(#name 'SUnitToo' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Collections-Collation' '') #('Glorp' '') #('ParcelDeployment' '') #('StoreBase' '') #('SUnitToo' '') #('Base VisualWorks' '') #('StoreBase' '') #('Glorp' '') #('Regex11' '') #('ParcelDeployment' '') #('SUnitToo' ''))Version: 55Date: 1:42:28 PM June 17, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.3) of June 17, 2016 on June 17, 2016 at 1:42:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>StoreCI</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>StoreCI-Support</package></attributes></name-space><name-space><name>Testing</name><environment>StoreCI</environment><private>false</private><imports>			private Smalltalk.*			private SUnit.*			private XML.*			</imports><category></category><attributes><package>StoreCI-Testing</package></attributes></name-space><name-space><name>Polling</name><environment>StoreCI</environment><private>false</private><imports>			private Smalltalk.*			private XML.*			private StoreCI.Support.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreCI-Polling</package></attributes></name-space><name-space><name>Building</name><environment>StoreCI</environment><private>false</private><imports>			private Smalltalk.*			private StoreCI.Support.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreCI-Building</package></attributes></name-space><name-space><name>Support</name><environment>StoreCI</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>StoreCI-Support</package></attributes></name-space><class><name>PundleSpec</name><environment>StoreCI.Support</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleType name version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-StoreSupport</package></attributes></class><comment><class-id>StoreCI.Support.PundleSpec</class-id><body>A simple token representing a Store Pundle.A PundleSpec knows how to persist and recover itself from a simple text-based format:PundleClassName&lt;tab&gt;"Name in Double Quotes"&lt;tab&gt;VersionThe Version field may be absent when dealing with "versionless" pundles.See #allFrom: and #parse: on the class side, and #writeOn: on the instance side.Instance Variables	name	&lt;String&gt;	The name of the pundle.	pundleType	&lt;StorePundle subclass&gt;	The class of the represented pundle (either StoreBundle or StorePackage).	version &lt;String or nil&gt; The version of the pundle, or nil if versionless.</body></comment><class><name>Skip</name><environment>StoreCI.Testing</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.Skip</class-id><body>An SUnit.Result representing a test case that was skipped.</body></comment><class><name>SuiteBuilder</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>includedClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.SuiteBuilder</class-id><body>SuiteBuilder creates a TestSuite containing a possibly filtered list all of the SUnitToo tests in the image.Instance Variables	includedClasses	&lt;Set&gt;	The TestCase classes to include, or nil if no filtering should be done.</body></comment><class><name>StoreInterface</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session minimumBlessingLevel versionMatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.StoreInterface</class-id><body>StoreInterface is StoreCI's interface to the Store repository.  It is responsible for performing the actual queries needed by StoreSCM.Instance Variables	minimumBlessingLevel	&lt;SmallInteger&gt;	Only pundles with this blessing level or higher are considered.	session	&lt;GlorpSession&gt;	The database session to use for queries.	versionMatcher	&lt;RxMatcher&gt;	Only pundle versions that match this regular expression matcher are considered.</body></comment><class><name>Changelog</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>knownPundles pundles deletedPundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.Changelog</class-id><body>Changelog tracks the changed versions of all relevant pundles and writes the changelog file used by the CI system.It uses a KnownPundleCache to determine if a pundle is new or just modified.The changelog is assembled by sends of #addPundles:, #noteDeletedPundles:, and #noteHeadRevision:.  Head revisions are only included in the changelog for pundles not in the KnownPundleCache.  This happens when a pundle gets a new prerequisite, for example.The changelog is written as XML.&lt;log&gt;	&lt;package name="Name" version="Version" action="{added | modified | deleted}"&gt;		&lt;blessing user="Username" timestamp="C-Locale format timestamp"&gt;			Blessing comment.		&lt;/blessing&gt;	&lt;/package&gt;	&lt;bundle ...same as for package...&gt;	...&lt;/log&gt;The blessings are listed in order from newest to oldest.  Note that deleted pundles (those with action="deleted") will not have a version attribute or any nested blessing elements.Instance Variables	deletedPundles	&lt;(Collection of: PundleSpec)&gt;	Pundles which are no longer used since the previous build.	knownPundles	&lt;KnownPundleCache&gt;	Cache of pundles from the previous build.	pundles	&lt;Collection of: StorePundle&gt;	Pundles which are new or changed since the previous build.</body></comment><class><name>StoreCISubsystem</name><environment>StoreCI.Support</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debug errorStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Support</package></attributes></class><comment><class-id>StoreCI.Support.StoreCISubsystem</class-id><body>StoreCISubsystem contains the common framework of all of the command-line interfaces in StoreCI.  It provides the -debug command-line option, as well as common error-handling and other behavior.Subclasses must implement the following messages:	private		run	private-testing		isReadyToRunInstance Variables	debug	&lt;Boolean&gt;	When true, exceptions are raised (not just logged), and the image doesn't exit upon completion.	errorStream	&lt;Stream&gt;	The stream to use when reporting errors.</body></comment><class><name>PollingSubsystem</name><environment>StoreCI.Polling</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootPundles versionMatcher minimumBlessingLevel repository parcelBuilderInputFile outputStream lastBuildTime currentTime changelogFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.PollingSubsystem</class-id><body>PollingSubsystem is the main command-line entry point for StoreCI-Polling.  See the package comment for details on usage and command-line options.PollingSubsystem is designed to be inert unless it is given a repository name and at least one root pundle.  If those are provided, then it checks for the presence of the changelog filename and build times.  If any of those three arguments are provided, it assumes that it needs to compute a changelog, but if not all of the three are provided, it raises a ValidationError.  The idea is that, if any of the three arguments are provided, the user is trying to compute a changelog, but may not have got the parameter usage correct, so we tell them about it rather than just assuming that they wanted the revision state.Once PollingSubsystem determines which operation to perform, it configures an instance of StoreSCM and invokes the desired operation.Instance Variables	changelogFile	&lt;Filename&gt;	The name of the file to which the changelog should be written.  See Changelog for details.	currentTime	&lt;Timestamp&gt;	The time of the current build.  Changes from after this timestamp will be ignored until the next build cycle.	debug	&lt;Boolean&gt;	When set, exceptions will not be trapped, and the image will not exit automatically upon completion.  Default: false.	errorStream	&lt;WriteStream&gt;	A stream on which to write information about any errors that occur.  Default: Stderr.	lastBuildTime	&lt;Timestamp&gt;	The time of the previous build.  Changes from before this timestamp will be ignored.  They were part of a previous build cycle.	minimumBlessingLevel	&lt;Integer&gt;	The minimum blessing level to consider.  Pundle versions with a lower level are ignored.  Default: 20 (Development).	outputStream	&lt;WriteStream&gt;	A stream on which to write the revision state.  See RevisionState for details. Default: Stdout.	parcelBuilderInputFile	&lt;Filename or nil&gt;	The name of a file in which to write the pundle load order.  See LoadOrder for details.  Default: nil (Don't write a file).	repository	&lt;Store.ConnectionProfile&gt;	The Store connection profile for the repository to monitor.	rootPundles	&lt;OrderedCollection of PundleSpec&gt;	The list of root pundles to monitor.	versionMatcher	&lt;Regex11.RxMatcher&gt;	Used to match pundle versions to determine if they should be considered or not.</body></comment><class><name>SuiteRunner</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results observers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.SuiteRunner</class-id><body>SuiteRunner runs a test suite, informing its observers (including a SuiteResults) of progress and results.Instance Variables	observers	&lt;(Collection of: ResultObserver)&gt;	Observers that are interested in test progress and results.	results	&lt;SuiteResults&gt;	The overall results of running the suite.</body></comment><class><name>ValidationError</name><environment>StoreCI.Polling</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.ValidationError</class-id><body>Raised when an incomplete or inconsistent set of command-line arguments are provided.</body></comment><class><name>KnownPundleCache</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename knownPundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.KnownPundleCache</class-id><body>KnownPundleCache represents a list of pundles from a previous build.  The cache is backed by a file on disk that persists between builds.  KnownPundleCache works with PundleSpecs.Instance Variables	filename	&lt;Filename&gt;	The file that backs the cache.	knownPundles	&lt;Set&gt;	The PundleSpecs from the previous build.</body></comment><class><name>BuildingSubsystem</name><environment>StoreCI.Building</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetDirectory repository inputFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ParcelBuilder</category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.BuildingSubsystem</class-id><body>BuildingSubsystem is the main command-line entry point for StoreCI-Building.  See the package comment for details on usage and command-line options.BuildingSubsystem is designed to be inert unless it is given a repository name and an input file name.  When those arguments are provided, it configures an instance of PundleLoader to load the desired pundles and, if required, an instance of ParcelWriter to write them out as parcels.Instance Variables	inputFilename	&lt;Filename&gt;	The name of the file containing the list of pundles to load.	repository	&lt;Store.ConnectionProfile&gt;	The repository from which to load pundles.	targetDirectory	&lt;Filename&gt;	The directory to which parcels will be written.</body></comment><class><name>ResultObserver</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.ResultObserver</class-id><body>ResultObserver is the base class of all classes that are interested in test and test suite results.It observes TestCase and sends itself #testStarted: and #testFinished: in response to the announcements it receives.  It also expects its owner to call #setUp/#tearDown and #suiteStarted/#suiteFinished: appropriately.</body></comment><class><name>ParcelWriteFailure</name><environment>StoreCI.Building</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.ParcelWriteFailure</class-id><body>ParcelWriteFailure is raised if a stock parcel cannot be copied into the target directory for some reason.</body></comment><class><name>StoreSCM</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcelBuilderInputFile storeInterface knownPundles revisionState changelog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.StoreSCM</class-id><body>StoreSCM is the main domain class for StoreCI.  An instance of StoreSCM is configured by StoreCISystem and then invoked using one of its two actions:* #writeRevisionStateTo:* #writeChangesFrom:to:toFile:revisionStateTo:StoreSCM coordinates the necessary activity amongst its collaborators and is responsible for very little of the work itself.Instance Variables	changelog	&lt;Changelog&gt;	Changelog computes and writes the list of changed pundle versions; unused when just computing revision state.	knownPundles	&lt;KnownPundleCache&gt;	The list of pundles seen during the previous build; unused when just computing revision state.  This information is read from a file in the .store subdirectory of the working directory.	parcelBuilderInputFile	&lt;Filename&gt;	The file to write the pundle load order to.  If nil, don't write the load order.  See LoadOrder for details.	revisionState	&lt;RevisionState&gt;	The list of "head" versions of all of the pundles.  This list includes bundles and their components.	storeInterface	&lt;StoreInterface&gt;	The object that performs Store queries on our behalf.</body></comment><class><name>TestingSubsystem</name><environment>StoreCI.Testing</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputFile suiteBuilder suiteRunner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TestLogger</category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.TestingSubsystem</class-id><body>TestingSubsystem is the main command-line entry point for StoreCI-Testing.  See the package comment for details on usage and command-line options.TestingSubsystem is designed to be inert unless it is given an output file.  If that is provided, it uses SuiteBuilder to build a test suite containing an optionally filtered list of all of the tests in the image.  It then uses SuiteRunner to run the tests, and XMLResultWriter to write out the SuiteResults in JUnit XML format.[This answer on StackOverflow](http://stackoverflow.com/a/9691131/667070) provides the best reference I've found for this format.Instance Variables	outputFile	&lt;Filename&gt;	The file to which XML results will be written.	suiteBuilder	&lt;SuiteBuilder&gt;	Used to build a suite containing a possibly filtered list of all of the tests in the curent Image.	suiteRunner	&lt;SuiteRunner&gt;	Runs the test suite, collecting the results.</body></comment><class><name>XMLResultWriter</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.XMLResultWriter</class-id><body>XMLResultWriter writes the suite results to a file in JUnit XML format.Instance Variables	filename	&lt;Filename&gt;	The name of the file to write to.</body></comment><class><name>ParcelWriter</name><environment>StoreCI.Building</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.ParcelWriter</class-id><body>ParcelWriter parcels out a list of pundles along with any "stock" parcels that are depended on by the pundles.Instance Variables	directory	&lt;Filename&gt;	The directory where the parcels will be written.  Will be created if it does not already exist.</body></comment><class><name>RevisionState</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>roots visited revisions bundleRevisions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.RevisionState</class-id><body>RevisionState computes and remembers the latest applicable version of each pundle of interest.To compute the revision state, it starts from a list of root pundles and traverses their pre-reqs and bundle contents until it hits leaf pundles or pundles not in the repository.  It relies on the block passed into #computeWith: to actually find the desired pundle versions.  RevisionState also creates a LoadOrder when asked.  LoadOrder requires the full list of revisions in the RevisionState, but also needs a dictionary that maps bundles to their subset of the RevisionState (that is, all pundles reachable from that bundle).  Note that these bundleRevisions only include pundles that were encountered for the first time when processing that bundle; pundles that were visited earlier in the enumeration are not included.  This limitation meets LoadOrder's needs, but may potentially surprise other future clients.The RevisionState can also be written to a stream.  Each Pundle is written to the stream, one per line, in the following format:PundleClassName&lt;tab&gt;"Name in Double Quotes"&lt;tab&gt;PundleVersionInstance Variables	bundleRevisions	&lt;Dictionary&gt;	Map of Bundles to a collection of Pundles first encountered when traversing from that Bundle.	revisions	&lt;(Collection of: StorePundle)&gt;	The "head" version of every Pundle reachable from roots via pre-requisites or bundle contents.	roots	&lt;Collection of: PundleSpec)&gt;	PundleSpecs representing the top-most pundles of interest.	visited	&lt;Set of: PundleSpec&gt;	All PundleSpecs seen during traversal; this keeps us from processing the same pundles over and over.</body></comment><class><name>SuiteResults</name><environment>StoreCI.Testing</environment><super>StoreCI.Testing.ResultObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results suiteTimer testTimer testElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.SuiteResults</class-id><body>SuiteResults contains the full set of results of running a test suite.  In addition to the basic SUnit.Results, it keeps track of test and suite runtimes.  It also builds up the XML Elements representing each test case as it goes so that it can capture exception descriptions and stack traces.  Otherwise, that information is lost before the end of the test run.Instance Variables	results	&lt;ResultsWithSkips&gt;	The basic SUnitToo results of the test run.	suiteTimer	&lt;TestTimer&gt;	A timer for tracking overall suite runtime.	testElements	&lt;Dictionary&gt;	XML Elements representing the results of each test case.	testTimer	&lt;TestTimer&gt;	A timer for tracking individual test runtimes.</body></comment><class><name>RepositoryNotFound</name><environment>StoreCI.Support</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-StoreSupport</package></attributes></class><comment><class-id>StoreCI.Support.RepositoryNotFound</class-id><body>Raised when the Store repository name specified on the command-line could not be found in the RepositoryManager.</body></comment><class><name>ResultsWithSkips</name><environment>StoreCI.Testing</environment><super>SUnit.Results</super><private>false</private><indexed-type>none</indexed-type><inst-vars>skipped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.ResultsWithSkips</class-id><body>ResultsWithSkips is a SUnit.Results subclass that keeps track of any tests that were skipped.Instance Variables	skipped	&lt;Collection&gt;	The set of skipped test cases.</body></comment><class><name>PundleLoader</name><environment>StoreCI.Building</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleSpecs session imagePundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.PundleLoader</class-id><body>Given a Store repository and an input file, ParcelLoader loads all of the pundles listed in the file from the repository, keeping track of the loaded pundles..Instance Variables	imagePundles	&lt;Collection&gt;	The in-image loaded pundles.	pundleSpecs	&lt;(Collection of: PundleSpec)&gt;	The specifications of which versions of which pundles to load.	session	&lt;GlorpSession&gt;	The active Glorp session.</body></comment><class><name>BlessingNotFound</name><environment>StoreCI.Polling</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.BlessingNotFound</class-id><body>Raised when the blessing name specified on the command-line could not be found in the current blessing policy's list of known blessings.</body></comment><class><name>Trace</name><environment>StoreCI.Testing</environment><super>StoreCI.Testing.ResultObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.Trace</class-id><body>Trace writes test start and finish events to an output stream.  This is useful for debugging hanging tests or random test failures caused by test ordering issues.Instance Variables	filename	&lt;Filename&gt;	The name of the file to write the trace information to.	stream	&lt;Stream&gt;	A writeStream on the file; kept open while the tests are running.</body></comment><class><name>ImportRepositoriesSubsystem</name><environment>StoreCI.Support</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-StoreSupport</package></attributes></class><comment><class-id>StoreCI.Support.ImportRepositoriesSubsystem</class-id><body>ImportRepositoriesSubsystem is a utility subsystem that allows Store repository definitions to be imported from a properly-formatted XML file.Using this subsystem, it is possible to run StoreCI using an image that doesn't already include the necessary repository definitions.  An XML file of the proper format can be created by exporting repository definitions from the Store repository manager. ImportRepositoriesSubsystem accepts a single command-line argument, -repositoriesFrom, that takes the filename of the repository definition file.  -repositoryFrom, -reposFrom, and -repoFrom are aliases.</body></comment><class><name>TestTimer</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startTime elapsed clock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.TestTimer</class-id><body>A simple Timer used to keep track of test and suite runtimes.Instance Variables	clock	&lt;StubClock | Time&gt;	The clock to use when keeping track of time.	elapsed	&lt;Duration&gt;	The amount of time the timer was running.	startTime	&lt;LargeInteger&gt;	The microsecond clock value when the timer was started.</body></comment><class><name>StockParcels</name><environment>StoreCI.Building</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storePundles stockParcels </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.StockParcels</class-id><body>StockParcels computes a list of "stock" parcels that are depended upon by a set of pundles.  Stock parcels are those that aren't in the given Store repository, but ship with Visualworks instead.Working in reverse load-order, so that a pundle is processed before any of its prerequisites, we add each pundle and all of its deployment prerequisites to the list of stock parcels.  We then remove the pundle (and any of its components if it is a bundle) from the list.  Once this is done, the only pundles remaining in the list are stock parcels.Instance Variables	stockParcels	&lt;Collection&gt;	The stock parcels that were computed.	storePundles	&lt;Collection&gt;	The list of pundles being parceled out.</body></comment><class><name>LoadOrder</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>revisions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.LoadOrder</class-id><body>LoadOrder represents the current list of pundle versions in "load order" - that is, the order they should be loaded into a new image such that we don't rely on Store to do prerequisite resolution for us.In the absence of bundles, LoadOrder's revisions and RevisionState's revisions are identical.  However, with bundles, RevisionState contains all of the pundles, including bundle components, but LoadOrder does not; it contains only the containing bundle.A LoadOrder is typically constructed by a RevisionState with the full list of revisions, plus a Dictionary that maps bundles to their reachable subset of the revisions.  LoadOrder computes its revisions from those two pieces of information at construction time.  To compute the load order, it is not sufficient to just remove all bundle components from the full list of revisions, because it is possible for a pundle earlier in the list to depend on one of the bundle components that was just removed.  Thus, it is also necessary to move the bundle forward in the list to the position of its earliest component.  For this to work, it is also necessary to move all of that bundle's prerequisites forward in the list with it.  The bundleRevisions Dictionary is what contains the information that allows this to happen.The LoadOrder can be written to a stream.  Each Pundle is written to the stream, one per line, in the following format:PundleClassName&lt;tab&gt;"Name in Double Quotes"&lt;tab&gt;PundleVersionInstance Variables	revisions	&lt;OrderedCollection&gt;	The list of current revisions, in the order they should be loaded.</body></comment><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>accessing</category><body package="StoreCI-StoreSupport">componentType	^pundleType == Store.Glorp.StorePackage		ifTrue: [#package]		ifFalse: [#bundle]</body><body package="StoreCI-StoreSupport">name	^name</body><body package="StoreCI-StoreSupport">pundleType	^pundleType</body><body package="StoreCI-StoreSupport">version	^version</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>printing</category><body package="StoreCI-StoreSupport">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self name ifNil: ['']);		nextPut: $)</body><body package="StoreCI-StoreSupport">writeOn: aStream	aStream		nextPutAll: pundleType name;		tab;		nextPut: $";		nextPutAll: name;		nextPut: $".	version		ifNotNil: 			[aStream				tab;				nextPutAll: version]</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>comparing</category><body package="StoreCI-StoreSupport">= aPundleSpec	^name = aPundleSpec name and: 			[pundleType == aPundleSpec pundleType and: [version = aPundleSpec version]]</body><body package="StoreCI-StoreSupport">hash	^(name hash hashMultiply bitXor: pundleType hash) hashMultiply		bitXor: version hash</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>initialize-release</category><body package="StoreCI-StoreSupport">initializeType: aClass name: nameString version: versionString	pundleType := aClass.	name := nameString.	version := versionString</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>converting</category><body package="StoreCI-StoreSupport">versionless	"Answer a versionless instance represnting the same pundle as me"	^version ifNil: [self] ifNotNil: [self class named: name type: pundleType]</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>private</category><body package="StoreCI-Building">storePundleIn: aGlorpSession	^pundleType pundleWithName: name version: version in: aGlorpSession</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>loading</category><body package="StoreCI-Building">loadIn: aGlorpSession	"Load the pundle I specify, using an existing Glorp session."	^(self storePundleIn: aGlorpSession) loadSource</body></methods><methods><class-id>StoreCI.Support.PundleSpec class</class-id> <category>instance creation</category><body package="StoreCI-StoreSupport">forBundle: aString	^self forBundle: aString version: nil</body><body package="StoreCI-StoreSupport">forBundle: nameString version: versionString	^self named: nameString type: Store.Glorp.StoreBundle version: versionString</body><body package="StoreCI-StoreSupport">forPackage: aString	^self forPackage: aString version: nil</body><body package="StoreCI-StoreSupport">forPackage: nameString version: versionString	^self		named: nameString		type: Store.Glorp.StorePackage		version: versionString</body><body package="StoreCI-StoreSupport">named: aString type: aPundleClass	^self named: aString type: aPundleClass version: nil</body><body package="StoreCI-StoreSupport">named: nameString type: aPundleClass version: versionString	^self new initializeType: aPundleClass name: nameString version: versionString</body><body package="StoreCI-StoreSupport">parse: aString	| rs firstToken pundleType pundleName version |	rs := aString readStream.	rs skipSeparators.	firstToken := (rs upTo: Character tab) trimBlanks.	(#('StorePackage' 'StoreBundle') includes: firstToken)		ifTrue: 			[pundleType := Store.Glorp at: firstToken.			rs skipSeparators.			pundleName := (rs upTo: Character tab) trimBlanks]		ifFalse: 			[pundleType := Store.Glorp.StorePackage.			pundleName := firstToken].	pundleName first = $"		ifTrue: [pundleName := pundleName copyFrom: 2 to: pundleName size - 1].	rs skipSeparators.	version := rs upToEnd trimBlanks.	^version isEmpty		ifTrue: [self named: pundleName type: pundleType]		ifFalse: [self named: pundleName type: pundleType version: version]</body></methods><methods><class-id>StoreCI.Support.PundleSpec class</class-id> <category>loading</category><body package="StoreCI-StoreSupport">allFrom: aStream	| specs |	specs := OrderedCollection new.	[aStream atEnd] whileFalse: 			[| line |			line := aStream upTo: Character cr.			line isEmpty ifFalse: [specs add: (self parse: line)]].	^specs</body></methods><methods><class-id>StoreCI.Support.PundleSpec class</class-id> <category>saving</category><body package="StoreCI-StoreSupport">writeAll: aCollection to: aStream	aCollection do: 			[:each |			each writeOn: aStream.			aStream cr]</body></methods><methods><class-id>StoreCI.Testing.Skip</class-id> <category>converting</category><body package="StoreCI-Testing">asTestLoggerXML	^(super asTestLoggerXML)		addNode: (Element tag: 'skipped');		yourself</body></methods><methods><class-id>StoreCI.Testing.Skip</class-id> <category>accessing</category><body package="StoreCI-Testing">addTo: aResults	"There may be multiple SUnit.Results instances listening, but only some know about skipped tests."	(aResults respondsTo: #addSkip:) ifFalse: [^self].	aResults addSkip: self</body></methods><methods><class-id>StoreCI.Testing.Skip class</class-id> <category>instance creation</category><body package="StoreCI-Testing">definition: aMethodDefinition	^self new definition: aMethodDefinition</body></methods><methods><class-id>StoreCI.Testing.SuiteBuilder</class-id> <category>private</category><body package="StoreCI-Testing">includedClasses	"Lazy initialize only when needed.  If nil, we don't want to filter the list of tests."	^includedClasses ifNil: [includedClasses := Set new]</body></methods><methods><class-id>StoreCI.Testing.SuiteBuilder</class-id> <category>accessing</category><body package="StoreCI-Testing">suite	| suite classes |	classes := includedClasses ifNil: [TestCase withAllSubclasses].	suite := TestSuite new.	(classes reject: #isAbstract) do: 			[:eachClass |			eachClass				testSelectorsDo: [:eachSelector | suite addTest: (eachClass selector: eachSelector)]].	^suite</body></methods><methods><class-id>StoreCI.Testing.SuiteBuilder</class-id> <category>filtering</category><body package="StoreCI-Testing">includeClasses: aCollection	"Include all of the test classes in aCollection in the list of tests to run."	self includedClasses addAll: aCollection</body><body package="StoreCI-Testing">includePundles: aCollection	"Include any TestCase classes defined in the pundles in aCollection in the list of tests to run."	aCollection do: 			[:each |			self includedClasses addAll: (each definedClasses						select: [:eachClass | eachClass isTestCase and: [eachClass isAbstract not]])]</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>private</category><body package="StoreCI-Polling">isVersionOfInterest: aString	"If no version matcher was provided, then match all versions."	^versionMatcher isNil or: [versionMatcher matches: aString]</body><body package="StoreCI-Polling">pundleNotFound: aPundleSpec	^nil</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>queries</category><body package="StoreCI-Polling">allChangedVersionsOf: aPundleSpec from: fromTimestamp to: toTimestamp	"Find all versions of the pundle represented by aPundleSpec 	that changed between fromTimestamp and toTimestamp.	Ignore pundles with too low a blessing level, and those whose versions don't match our versionMatcher.	Include pundles whose only relevant change was a blessing change."	| query results |	query := Glorp.Query readManyOf: aPundleSpec pundleType				where: 					[:each |					each name = aPundleSpec name						AND: each currentBlessingLevel &gt;= minimumBlessingLevel].	query alsoFetch: [:each | each blessings].	query orderBy: [:each | each timestamp descending].	results := session execute: query.	^results select: 			[:each |			(self isVersionOfInterest: each version) and: 					[(each timestamp between: fromTimestamp and: toTimestamp) or: 							[each blessings								anySatisfy: [:eachBlessing | eachBlessing timestamp between: fromTimestamp and: toTimestamp]]]]</body><body package="StoreCI-Polling">findHeadVersionOf: aPundleSpec	^self findHeadVersionOf: aPundleSpec asOf: Timestamp nowUTC</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeProfile: aConnectionProfile minimumBlessingLevel: aBlessingLevel	session := StoreLoginFactory sessionForStoreLogin: aConnectionProfile.	minimumBlessingLevel := aBlessingLevel</body><body package="StoreCI-Polling">versionMatcher: anRxMatcher	versionMatcher := anRxMatcher</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>private-queries</category><body package="StoreCI-Polling">findHeadVersionOf: aPundleSpec asOf: aTimestamp	"Find the latest version of the pundle represented by aPundleSpec as of aTimestamp.	Ignore pundles with too low a blessing level and those whose version doesn't match our version matcher."	| query result matching |	query := Glorp.Query readManyOf: aPundleSpec pundleType				where: [:each | each name = aPundleSpec name].	query orderBy: [:each | each timestamp descending].	query retrieve: [:each | each currentBlessingLevel].	query retrieve: [:each | each version].	query retrieve: [:each | each timestamp].	result := session execute: query.	matching := result detect: 					[:each |					each first &gt;= minimumBlessingLevel						and: [(self isVersionOfInterest: (each at: 2)) and: [each last &lt;= aTimestamp]]]				ifNone: [^self pundleNotFound: aPundleSpec].	query := Glorp.Query readOneOf: aPundleSpec pundleType				where: 					[:each |					each name = aPundleSpec name						AND: each version = (matching at: 2)						AND: each currentBlessingLevel = matching first						AND: each timestamp = matching last].	^session execute: query</body></methods><methods><class-id>StoreCI.Polling.StoreInterface class</class-id> <category>instance creation</category><body package="StoreCI-Polling">connectionProfile: aConnectionProfile minimumBlessingLevel: aBlessingLevel	^self new initializeProfile: aConnectionProfile		minimumBlessingLevel: aBlessingLevel</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>accessing</category><body package="StoreCI-Polling">size	^pundles size</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>adding</category><body package="StoreCI-Polling">addPundles: aCollection	aCollection do: [:each | self addPundle: each]</body><body package="StoreCI-Polling">noteDeletedPundles: aCollection	aCollection do: [:each | self noteDeletedPundle: each]</body><body package="StoreCI-Polling">noteHeadRevision: aStorePundle	"Head revisions are only interesting for pundles that are new since the previous build."	aStorePundle ifNil: [^self].	(self isNewPundle: aStorePundle) ifFalse: [^self].	self addPundle: aStorePundle</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>private - test support</category><body package="StoreCI-Polling">addPundle: aStorePundle	pundles add: aStorePundle</body><body package="StoreCI-Polling">includes: aStorePundle	^pundles includes: aStorePundle</body><body package="StoreCI-Polling">isEmpty	^pundles isEmpty and: [deletedPundles isEmpty]</body><body package="StoreCI-Polling">noteDeletedPundle: aPundleSpec	deletedPundles add: aPundleSpec</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>writing</category><body package="StoreCI-Polling">writeToFile: aFilename	| ws |	ws := aFilename writeStream.	[self writeToStream: ws] ensure: [ws close]</body><body package="StoreCI-Polling">writeToStream: aStream	aStream		nextPutAll: '&lt;?xml version="1.0"?&gt;';		cr.	self asXML printOn: aStream.	aStream flush</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>private</category><body package="StoreCI-Polling">actionForPundle: aStorePundle	(self isDeletedPundle: aStorePundle) ifTrue: [^'deleted'].	(self isNewPundle: aStorePundle) ifTrue: [^'added'].	^'modified'</body><body package="StoreCI-Polling">asXML	| root |	root := Element tag: 'log'.	(pundles asSortedCollection: [:a :b | a timestamp &gt;= b timestamp])		do: [:each | root addNode: (self xmlElementForPundle: each)].	deletedPundles		do: [:each | root addNode: (self xmlElementForPundle: each)].	^(XML.Document new)		addNode: root;		yourself</body><body package="StoreCI-Polling">isDeletedPundle: aPundleSpec	^deletedPundles includes: aPundleSpec</body><body package="StoreCI-Polling">isNewPundle: aStorePundle	^(knownPundles includes: aStorePundle asStoreCIPundleSpec) not</body><body package="StoreCI-Polling">xmlElementForPundle: aStorePundleOrSpec	| action |	action := self actionForPundle: aStorePundleOrSpec.	^(aStorePundleOrSpec asXMLElementForStoreCI)		addAttribute: (Attribute name: 'action' value: action);		yourself</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeKnownPundles: aKnownPundles	knownPundles := aKnownPundles.	pundles := OrderedSet new.	deletedPundles := OrderedSet new</body></methods><methods><class-id>StoreCI.Polling.Changelog class</class-id> <category>instance creation</category><body package="StoreCI-Polling">knownPundles: aKnownPundles	^self new initializeKnownPundles: aKnownPundles</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>prerequisites</category><body package="StoreCI-Support">prerequisiteSystems	^Array with: RuntimeSystem</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>private</category><body package="StoreCI-Support">exitCleanly	debug ifTrue: [^self].	self exitWithCode: 0</body><body package="StoreCI-Support">exitWithCode: anInteger	^ObjectMemory quitWithError: anInteger</body><body package="StoreCI-Support">run	^self subclassResponsibility</body><body package="StoreCI-Support">validateArguments	"Do nothing by default"</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Support">clearCachedState	"Subsystem instances live forever in an image, so we need a way to reset the state when loading the image"	debug := false</body><body package="StoreCI-Support">errorStream: aWriteStream	errorStream := aWriteStream</body><body package="StoreCI-Support">initialize	super initialize.	errorStream := Stderr.	self clearCachedState</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>default actions</category><body package="StoreCI-Support">setUp	self isReadyToRun ifFalse: [^self].	self validateArguments.	self run.	self exitCleanly</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>private-activate/deactivate</category><body package="StoreCI-Support">runActivationActions	self clearCachedState.	[super runActivationActions] on: Error		do: 			[:ex |			errorStream				nextPutAll: ex errorString;				cr.			debug ifTrue: [^ex pass].			^self exitWithCode: 1]</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>private-testing</category><body package="StoreCI-Support">isReadyToRun	^self subclassResponsibility</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>accessing</category><body package="StoreCI-Support">canActivate	"Don't activate the abstract base class"	^self class ~~ StoreCISubsystem</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>private</category><body package="StoreCI-Polling">configuredSCM	| scm |	scm := StoreSCM				repository: repository				rootPundles: rootPundles				minimumBlessingLevel: minimumBlessingLevel.	scm		versionMatcher: versionMatcher;		parcelBuilderInputFile: parcelBuilderInputFile.	^scm</body><body package="StoreCI-Polling">repositoryNamed: aString	^Store.RepositoryManager repositories		detect: [:each | each name = aString]		ifNone: [RepositoryNotFound raiseWith: aString]</body><body package="StoreCI-Polling">required: anObject option: aString	anObject ifNotNil: [^self].	^ValidationError		raiseErrorString: 'No ' , aString , ' option was specified'</body><body package="StoreCI-Polling">run	| scm |	scm := self configuredSCM.	self shouldComputeChangelog		ifTrue: 			[scm				writeChangesFrom: lastBuildTime				to: currentTime				toFile: changelogFile				revisionStateTo: outputStream]		ifFalse: [scm writeRevisionStateTo: outputStream]</body><body package="StoreCI-Polling">shouldComputeChangelog	^lastBuildTime notNil or: [currentTime notNil or: [changelogFile notNil]]</body><body package="StoreCI-Polling">validateArguments	self shouldComputeChangelog ifFalse: [^self].	self		required: lastBuildTime option: '-since';		required: currentTime option: '-now';		required: changelogFile option: '-changelog'</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>prerequisites</category><body package="StoreCI-Polling">prerequisiteSystems	^super prerequisiteSystems copyWith: ImportRepositoriesSubsystem</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Polling">clearCachedState	"Subsystem instances live forever in an image, so we need a way to reset the state when loading the image"	super clearCachedState.	repository := nil.	rootPundles := OrderedCollection new.	minimumBlessingLevel := Store.Policies blessingPolicy defaultBlessing.	outputStream := Stdout.	parcelBuilderInputFile := nil.	versionMatcher := nil.	lastBuildTime := nil.	currentTime := nil.	changelogFile := nil</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>private - test support</category><body package="StoreCI-Polling">minimumBlessingLevel	^minimumBlessingLevel</body><body package="StoreCI-Polling">pundles	^rootPundles</body><body package="StoreCI-Polling">versionMatcher	^versionMatcher</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>testing</category><body package="StoreCI-Polling">isReadyToRun	^repository notNil and: [rootPundles notEmpty]</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>accessing</category><body package="StoreCI-Polling">outputStream: aWriteStream	outputStream := aWriteStream</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>testing</category><body package="StoreCI-Testing">hasPassed	^results hasPassed</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	observers := OrderedCollection new.	results := SuiteResults new.	self addObserver: results</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>private</category><body package="StoreCI-Testing">basicRunSuite: aTestSuite	"TestSuite doesn't allow injection of a results class, so we wrap our suite run in an outer #collectWhile:.	This is redundant, but allows us to collect tests that are skipped due to resource unavailability."	^ResultsWithSkips collectWhile: 			[[aTestSuite run] on: TestResourceUnavailable				do: 					[:ex |					(aTestSuite definitionsForResources: ex parameter)						do: [:each | TestCase announce: (Skip definition: each)].					ex resume]]</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>accessing</category><body package="StoreCI-Testing">addObserver: aResultObserver	observers add: aResultObserver</body><body package="StoreCI-Testing">results	^results</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>running</category><body package="StoreCI-Testing">runSuite: aTestSuite	"Run aTestSuite, informing my observers of progress and results."	observers do: #setUp.		[| sunitResults |	observers do: #suiteStarted.	sunitResults := self basicRunSuite: aTestSuite.	observers do: [:each | each suiteFinished: sunitResults]]			ensure: [observers do: #tearDown]</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner class</class-id> <category>instance creation</category><body package="StoreCI-Testing">new	^super new initialize</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeCache: aCollection	knownPundles := Set withAll: aCollection</body><body package="StoreCI-Polling">initializeFilename: aFilename	filename := aFilename.	knownPundles := Set new</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>testing</category><body package="StoreCI-Polling">includes: aPundleSpec	^knownPundles includes: aPundleSpec versionless</body><body package="StoreCI-Polling">isEmpty	^knownPundles isEmpty</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>accessing</category><body package="StoreCI-Polling">pundlesMissingFrom: aCollection	"Return any cached pundles that are not in aCollection."	^(knownPundles - aCollection) asSet</body><body package="StoreCI-Polling">size	^knownPundles size</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>private</category><body package="StoreCI-Polling">writeCacheWith: aCollection	| ws |	filename directory ensureDirectory.	ws := filename writeStream.	[PundleSpec writeAll: aCollection to: ws] ensure: [ws close]</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>loading-saving</category><body package="StoreCI-Polling">load	"Load the cache from disk."	| rs |	filename exists ifFalse: [^self].	rs := filename readStream.	[knownPundles addAll: (PundleSpec allFrom: rs)] ensure: [rs close]</body><body package="StoreCI-Polling">updateWithPundles: aCollection	"Update our list of known pundles and write them to our disk store."	knownPundles := Set withAll: aCollection.	self writeCacheWith: aCollection</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache class</class-id> <category>instance creation</category><body package="StoreCI-Polling">filename: aFilename	^self new initializeFilename: aFilename asFilename</body><body package="StoreCI-Polling">withAll: aCollection	^self new initializeCache: aCollection</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>private</category><body package="StoreCI-Building">configuredLoader	^PundleLoader repository: repository inputFile: inputFilename</body><body package="StoreCI-Building">configuredWriter	^ParcelWriter directory: targetDirectory</body><body package="StoreCI-Building">repositoryNamed: aString	^Store.RepositoryManager repositories		detect: [:each | each name = aString]		ifNone: [RepositoryNotFound raiseWith: aString]</body><body package="StoreCI-Building">run	| loader |	loader := self configuredLoader.	self withOverlayFeedbackDo: 			[loader loadPundles.			targetDirectory				ifNotNil: [self configuredWriter writeParcels: loader imagePundles]]</body><body package="StoreCI-Building">withOverlayFeedbackDo: aBlock	"If StoreProgressOverlay is available in the image, use it on the active VisualLauncher window."	#{Store.StoreProgressOverlay} ifDefinedDo: 			[:cls |			| activeLauncher |			activeLauncher := VisualLauncher allInstances						detect: [:each | each mainWindow isOpen].			cls subsume: activeLauncher mainWindow while: aBlock]		elseDo: aBlock</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>testing</category><body package="StoreCI-Building">isReadyToRun	^repository notNil and: [inputFilename notNil]</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>prerequisites</category><body package="StoreCI-Building">prerequisiteSystems	^super prerequisiteSystems copyWith: ImportRepositoriesSubsystem</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Building">clearCachedState	"Subsystem instances live forever in an image, so we need a way to reset the state when loading the image"	super clearCachedState.	repository := nil.	inputFilename := nil</body></methods><methods><class-id>StoreCI.Testing.ResultObserver</class-id> <category>private - test events</category><body package="StoreCI-Testing">testFinished: aTestResult	"Do nothing by default"</body><body package="StoreCI-Testing">testStarted: aTestStarted	"Do nothing by default"</body></methods><methods><class-id>StoreCI.Testing.ResultObserver</class-id> <category>test events</category><body package="StoreCI-Testing">suiteFinished: aResults	"Do nothing by default"</body><body package="StoreCI-Testing">suiteStarted	"Do nothing by default"</body></methods><methods><class-id>StoreCI.Testing.ResultObserver</class-id> <category>life cycle</category><body package="StoreCI-Testing">setUp	TestCase when: Started send: #testStarted: to: self.	TestCase when: Result send: #testFinished: to: self</body><body package="StoreCI-Testing">tearDown	TestCase unsubscribe: self</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>actions</category><body package="StoreCI-Polling">writeChangesFrom: aFromTimestamp to: aToTimestamp toFile: aFilename revisionStateTo: aStream	knownPundles load.	revisionState		computeWith: [:each | self findChangesIn: each from: aFromTimestamp to: aToTimestamp].	changelog noteDeletedPundles: self deletedPundles.	changelog writeToFile: aFilename.	self writeParcelBuilderInputFile.	revisionState writeOn: aStream.	knownPundles updateWithPundles: revisionState specs</body><body package="StoreCI-Polling">writeRevisionStateTo: aStream	revisionState computeWith: [:each | storeInterface findHeadVersionOf: each].	self writeParcelBuilderInputFile.	revisionState writeOn: aStream</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>private-changelog</category><body package="StoreCI-Polling">deletedPundles	^knownPundles pundlesMissingFrom: revisionState specs</body><body package="StoreCI-Polling">findChangesIn: aPundleSpec from: fromTimestamp to: toTimestamp	"RevisionState&gt;&gt;computeWith: needs the latest applicable version (head version) of every pundle.	If we find changes, then the most recent version is the head version.  Otherwise, we need to go look	up the head version in the repository."	| changedVersions headRevision |	changedVersions := storeInterface				allChangedVersionsOf: aPundleSpec				from: fromTimestamp				to: toTimestamp.	changelog addPundles: changedVersions.	headRevision := changedVersions isEmpty				ifTrue: [storeInterface findHeadVersionOf: aPundleSpec asOf: toTimestamp]				ifFalse: [changedVersions first].	changelog noteHeadRevision: headRevision.	^headRevision</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeRepository: aConnectionProfile rootPundles: aCollection minimumBlessingLevel: anInteger	| cacheFilename |	storeInterface := StoreInterface connectionProfile: aConnectionProfile				minimumBlessingLevel: anInteger.	revisionState := RevisionState roots: aCollection.	cacheFilename := '.store' asFilename				/ ('previousPackages.' , aConnectionProfile name).	knownPundles := KnownPundleCache filename: cacheFilename.	changelog := Changelog knownPundles: knownPundles</body><body package="StoreCI-Polling">parcelBuilderInputFile: aFilenameOrNil	parcelBuilderInputFile := aFilenameOrNil</body><body package="StoreCI-Polling">versionMatcher: anRxMatcher	storeInterface versionMatcher: anRxMatcher</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>private</category><body package="StoreCI-Polling">writeParcelBuilderInputFile	| ws |	parcelBuilderInputFile ifNil: [^self].	ws := parcelBuilderInputFile writeStream.	[revisionState loadOrder writeOn: ws] ensure: [ws close]</body></methods><methods><class-id>StoreCI.Polling.StoreSCM class</class-id> <category>instance creation</category><body package="StoreCI-Polling">repository: aConnectionProfile rootPundles: aCollection minimumBlessingLevel: anInteger	^self new		initializeRepository: aConnectionProfile		rootPundles: aCollection		minimumBlessingLevel: anInteger</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>private</category><body package="StoreCI-Testing">basicRun	suiteRunner runSuite: suiteBuilder suite.	self writeResults: suiteRunner results.	^suiteRunner hasPassed</body><body package="StoreCI-Testing">run	self basicRun ifFalse: [^self error: 'Tests failed']</body><body package="StoreCI-Testing">writeResults: aSuiteResults	| writer |	writer := XMLResultWriter onFile: outputFile.	writer write: aSuiteResults</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>private-testing</category><body package="StoreCI-Testing">isReadyToRun	^outputFile notNil</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Testing">clearCachedState	super clearCachedState.	outputFile := nil.	suiteBuilder := self makeSuiteBuilder.	suiteRunner := SuiteRunner new</body><body package="StoreCI-Testing">makeSuiteBuilder	^SuiteBuilder new</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter</class-id> <category>writing</category><body package="StoreCI-Testing">write: aResults	| ws |	ws := filename writeStream.	[self writeResults: aResults to: ws] ensure: [ws close]</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initializeFilename: aFilename	filename := aFilename</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter</class-id> <category>private</category><body package="StoreCI-Testing">writeResults: aSuiteResults to: aStream	| xml |	aStream		nextPutAll: '&lt;?xml version="1.0"?&gt;';		cr.	xml := aSuiteResults asXML.	xml saxDo: (SAXWriter new output: aStream).	aStream flush</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter class</class-id> <category>instance creation</category><body package="StoreCI-Testing">onFile: aFilename	^self new initializeFilename: aFilename</body></methods><methods><class-id>StoreCI.Building.ParcelWriter</class-id> <category>private</category><body package="StoreCI-Building">copy: aFilename to: aDirectory	| target |	target := aDirectory / aFilename tail.	aFilename copyTo: target.	target makeWritable</body><body package="StoreCI-Building">copyStockParcel: aPundleModel	| parcelFilename |	parcelFilename := (self parcelFilenameFor: aPundleModel)				ifNil: 					[^ParcelWriteFailure						raiseErrorString: 'Could not deploy ' , aPundleModel printString].	self copyStockParcelFrom: parcelFilename asAbsoluteFilename</body><body package="StoreCI-Building">copyStockParcelFrom: aFilename	| sourceFilename |	aFilename directory = directory asAbsoluteFilename ifTrue: [^self].	sourceFilename := aFilename constructWithExtension: Parcel sourceExtension.	self		copy: aFilename to: directory;		copy: sourceFilename to: directory</body><body package="StoreCI-Building">copyStockParcels: aCollection	aCollection do: [:each | self copyStockParcel: each]</body><body package="StoreCI-Building">parcelFilenameFor: aPundleModel	^aPundleModel parcelFilename		ifNil: [(Parcel parcelNamed: aPundleModel name) ifNotNil: #parcelFilename]</body><body package="StoreCI-Building">writeStoreParcel: aPundleModel	(ParcelDeployment pundle: aPundleModel directory: directory) deploy</body><body package="StoreCI-Building">writeStoreParcels: aCollection	aCollection do: [:each | self writeStoreParcel: each]</body></methods><methods><class-id>StoreCI.Building.ParcelWriter</class-id> <category>initialize-release</category><body package="StoreCI-Building">initializeDirectory: aFilename	directory := aFilename</body></methods><methods><class-id>StoreCI.Building.ParcelWriter</class-id> <category>writing</category><body package="StoreCI-Building">writeParcels: aCollection	"Parcel out all of the pundles in aCollection.  Also, copy over any 'stock' parcels depended on by the pundes."	self		writeStoreParcels: aCollection;		copyStockParcels: (StockParcels from: aCollection)</body></methods><methods><class-id>StoreCI.Building.ParcelWriter class</class-id> <category>instance creation</category><body package="StoreCI-Building">directory: aFilename	^self new initializeDirectory: aFilename</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeRoots: aCollection	roots := aCollection.	revisions := OrderedCollection new.	bundleRevisions := Dictionary new</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>private</category><body package="StoreCI-Polling">enumerateFromBundleComponent: aStorePundle with: aBlock into: aCollection	^self		enumerateFromPundleSpec: aStorePundle asStoreCIPundleSpec versionless		with: aBlock		into: aCollection</body><body package="StoreCI-Polling">enumerateFromPrerequisite: aPrerequisiteDescription with: aBlock into: aCollection	aPrerequisiteDescription canResolveUsingStore ifFalse: [^self].	self		enumerateFromPundleSpec: aPrerequisiteDescription asStoreCIPundleSpec		with: aBlock		into: aCollection</body><body package="StoreCI-Polling">enumerateFromPundleSpec: aPundleSpec with: aBlock into: aCollection	"This is the core of the enumeration algorithm. 	visited is a cache of all pundles already seen; if aPundleSpec has been seen, we can safely skip it.	aBlock is responsible for finding the 'head' version of each pundle.	We first accumulate all prerequisites and bundle components into localRevisions, then add those 	to aCollection at the end.  For bundles, we map the bundle to its localRevisions in bundleRevisions for	later creation of a LoadOrder.	It doesn't much matter if we iterate prerequisites or bundle components first.	However, it is important that each pundle gets added to aCollection after every pundle reachable from it.	That way, aCollection represents an initial cut of a LoadOrder that can be used to safely load all of the 	pundles into a new image without relying on Store to do prerequisite resolution."	| pundle localRevisions |	(visited includes: aPundleSpec) ifTrue: [^self].	visited add: aPundleSpec.	pundle := (aBlock value: aPundleSpec) ifNil: [^self].	localRevisions := OrderedCollection new.	pundle prerequisiteDescriptions		do: [:each | self enumerateFromPrerequisite: each with: aBlock into: localRevisions].	pundle containedItems do: 			[:each |			self enumerateFromBundleComponent: each with: aBlock into: localRevisions].	localRevisions add: pundle.	pundle isBundle ifTrue: [bundleRevisions at: pundle put: localRevisions].	aCollection addAll: localRevisions</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>accessing</category><body package="StoreCI-Polling">computeWith: aBlock	"Using aBlock to find the 'head' version of each pundle reachable from roots, compute the current revision state of the repository.	Along the way, keep track of all not-yet-seen pundles reachable from each bundle."	visited := Set new.	bundleRevisions := Dictionary new.	revisions := roots inject: OrderedCollection new				into: 					[:result :each |					self enumerateFromPundleSpec: each with: aBlock into: result.					result]</body><body package="StoreCI-Polling">loadOrder	"Create a LoadOrder with the information we cached while traversing the pundles."	^LoadOrder allRevisions: revisions copy bundleRevisions: bundleRevisions</body><body package="StoreCI-Polling">specs	"Return a set of PundleSpecs representing the current revision state."	^revisions collect: [:each | each asStoreCIPundleSpec versionless]</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>writing</category><body package="StoreCI-Polling">writeOn: aStream	PundleSpec writeAll: (revisions collect: #asStoreCIPundleSpec) to: aStream</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>private - testing support</category><body package="StoreCI-Polling">bundleRevisions	^bundleRevisions</body></methods><methods><class-id>StoreCI.Polling.RevisionState class</class-id> <category>enumerating</category><body package="StoreCI-Polling">roots: aCollection	^self new initializeRoots: aCollection</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	suiteTimer := TestTimer new.	testTimer := TestTimer new.	testElements := Dictionary new.	results := ResultsWithSkips new</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>test events</category><body package="StoreCI-Testing">suiteFinished: aResults	suiteTimer stop.	results := aResults</body><body package="StoreCI-Testing">suiteStarted	suiteTimer start</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>testing</category><body package="StoreCI-Testing">hasPassed	^results allPassed</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>private - xml</category><body package="StoreCI-Testing">addTestCaseElementsTo: anElement	self sortedResults do: [:each | anElement addNode: each]</body><body package="StoreCI-Testing">addTime: aDuration toElement: anElement	| formattedTime |	formattedTime := aDuration asSeconds printFormat: '0.000'.	anElement addAttribute: (Attribute name: 'time' value: formattedTime)</body><body package="StoreCI-Testing">sortedResults	| sortedKeys |	sortedKeys := testElements keys				asSortedCollection: [:a :b | a definition &lt; b definition].	^sortedKeys collect: [:each | testElements at: each]</body><body package="StoreCI-Testing">suiteElement	| root |	root := Element tag: 'testsuite'.	root addAttribute: (Attribute name: 'name' value: 'allTests').	results addSummaryAttributesTo: root.	self addTime: suiteTimer elapsed toElement: root.	^root</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>accessing</category><body package="StoreCI-Testing">asXML	"Answer an XML Document representing the test results in JUnit format."	| root |	root := self suiteElement.	self addTestCaseElementsTo: root.	^XML.Document new addNode: root</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>private - test events</category><body package="StoreCI-Testing">testFinished: aResult	| element |	testTimer stop.	element := aResult asTestLoggerXML.	self addTime: testTimer elapsed toElement: element.	testElements at: aResult put: element</body><body package="StoreCI-Testing">testStarted: aStarted	testTimer start</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>private - test support</category><body package="StoreCI-Testing">injectClock: aClock	suiteTimer injectClock: aClock.	testTimer injectClock: aClock</body></methods><methods><class-id>StoreCI.Testing.SuiteResults class</class-id> <category>instance creation</category><body package="StoreCI-Testing">new	^super new initialize</body></methods><methods><class-id>StoreCI.Support.RepositoryNotFound</class-id> <category>printing</category><body package="StoreCI-StoreSupport">description	parameter ifNil: [^super description].	^'Could not find a repository named "&lt;1s&gt;"' expandMacrosWith: parameter</body></methods><methods><class-id>StoreCI.Testing.ResultsWithSkips</class-id> <category>accessing</category><body package="StoreCI-Testing">addSkip: aSkip	skipped add: aSkip</body><body package="StoreCI-Testing">addSummaryAttributesTo: anElement	anElement		addAttribute: (Attribute name: 'tests' value: self runCount printString);		addAttribute: (Attribute name: 'failures'					value: self failureCount printString);		addAttribute: (Attribute name: 'errors' value: self errorCount printString);		addAttribute: (Attribute name: 'skipped'					value: self skippedCount printString)</body><body package="StoreCI-Testing">ranCount	^super ranCount + self skippedCount</body><body package="StoreCI-Testing">skippedCount	^skipped size</body></methods><methods><class-id>StoreCI.Testing.ResultsWithSkips</class-id> <category>printing</category><body package="StoreCI-Testing">countSelectors	^super countSelectors copyWith: #skippedCount</body></methods><methods><class-id>StoreCI.Testing.ResultsWithSkips</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	skipped := Set new</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>accessing</category><body package="StoreCI-Building">imagePundles	"Answer the loaded (in-image) version of the pundles that were loaded."	^imagePundles</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>private</category><body package="StoreCI-Building">readPundleSpecs: aFilename	| rs |	rs := aFilename readStream.	^[PundleSpec allFrom: rs] ensure: [rs close]</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>loading</category><body package="StoreCI-Building">loadPundles	"Load each specified pundle, keeping track of the loaded (in-image) version."	imagePundles := pundleSpecs collect: [:each | each loadIn: session]</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>initialize-release</category><body package="StoreCI-Building">initializeRepository: aConnectionProfile inputFile: aFilename	session := StoreLoginFactory sessionForStoreLogin: aConnectionProfile.	pundleSpecs := self readPundleSpecs: aFilename</body></methods><methods><class-id>StoreCI.Building.PundleLoader class</class-id> <category>instance creation</category><body package="StoreCI-Building">repository: aConnectionProfile inputFile: aFilename	^self new initializeRepository: aConnectionProfile inputFile: aFilename</body></methods><methods><class-id>StoreCI.Polling.BlessingNotFound</class-id> <category>printing</category><body package="StoreCI-Polling">description	parameter ifNil: [^super description].	^'Could not find a blessing level named "&lt;1s&gt;"'		expandMacrosWith: parameter</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>private</category><body package="StoreCI-Testing">log: aTestCaseAnnouncement	stream		nextPutAll: aTestCaseAnnouncement definition printString;		space;		nextPutAll: aTestCaseAnnouncement class name;		cr;		flush</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>test events</category><body package="StoreCI-Testing">testFinished: aResult	self log: aResult</body><body package="StoreCI-Testing">testStarted: aStarted	self log: aStarted</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initializeFilename: aFilename	filename := aFilename</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>life cycle</category><body package="StoreCI-Testing">setUp	super setUp.	stream := filename writeStream</body><body package="StoreCI-Testing">tearDown	stream close.	super tearDown</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>private - test support</category><body package="StoreCI-Testing">injectStream: aStream	stream := aStream</body></methods><methods><class-id>StoreCI.Testing.Trace class</class-id> <category>instance creation</category><body package="StoreCI-Testing">onFile: aFilename	^self new initializeFilename: aFilename</body></methods><methods><class-id>StoreCI.Support.ImportRepositoriesSubsystem</class-id> <category>prerequisites</category><body package="StoreCI-StoreSupport">prerequisiteSystems	^Array with: RuntimeSystem</body></methods><methods><class-id>StoreCI.Testing.TestTimer</class-id> <category>accessing</category><body package="StoreCI-Testing">elapsed	^elapsed</body><body package="StoreCI-Testing">start	startTime := clock microsecondClock</body><body package="StoreCI-Testing">stop	elapsed := startTime				ifNil: [0 microseconds]				ifNotNil: [(clock microsecondClock - startTime) microseconds]</body></methods><methods><class-id>StoreCI.Testing.TestTimer</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	clock := Time.	elapsed := 0 microseconds</body><body package="StoreCI-Testing">injectClock: aClock	clock := aClock</body></methods><methods><class-id>StoreCI.Testing.TestTimer class</class-id> <category>instance creation</category><body package="StoreCI-Testing">new	^super new initialize</body></methods><methods><class-id>StoreCI.Building.StockParcels</class-id> <category>accessing</category><body package="StoreCI-Building">stockParcels	^stockParcels</body></methods><methods><class-id>StoreCI.Building.StockParcels</class-id> <category>initialize-release</category><body package="StoreCI-Building">initializeStorePundles: aCollection	storePundles := aCollection.	stockParcels := Set new.	self compute</body></methods><methods><class-id>StoreCI.Building.StockParcels</class-id> <category>private</category><body package="StoreCI-Building">compute	"Compute the set of stock parcels, resolving them to their functional components (so we get containing bundles where appropriate).	Base VisualWorks does not come in its own parcel, and we can safely assume that it is already loaded into any image we might use,	so we omit it here."	storePundles reverseDo: [:each | self computeFrom: each].	stockParcels := stockParcels collect: #functionalComponent.	stockParcels remove: (Store.Registry bundleNamed: 'Base VisualWorks')		ifAbsent: []</body><body package="StoreCI-Building">computeFrom: aPundleModel	(stockParcels includes: aPundleModel)		ifFalse: [stockParcels addAll: aPundleModel withAllDeploymentPrerequisites].	aPundleModel withAllContainedItems		do: [:each | stockParcels remove: each ifAbsent: []]</body></methods><methods><class-id>StoreCI.Building.StockParcels class</class-id> <category>instance creation</category><body package="StoreCI-Building">from: aCollection	| inst |	inst := self new initializeStorePundles: aCollection.	^inst stockParcels</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>writing</category><body package="StoreCI-Polling">writeOn: aStream	PundleSpec writeAll: (revisions collect: #asStoreCIPundleSpec) to: aStream</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeAllRevisions: aCollection bundleRevisions: aDictionary	"Compute the revisions in load order by adjusting all of the bundles in aCollection using the information in aDictionary."	revisions := (aCollection select: #isBundle)				inject: (OrderedCollection withAll: aCollection)				into: 					[:adjusted :each |					self						adjustRevisions: adjusted						forBundle: each						bundleRevisions: (aDictionary at: each ifAbsent: [OrderedCollection new])]</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>private</category><body package="StoreCI-Polling">adjustRevisions: revisionsCollection forBundle: aStoreBundle bundleRevisions: bundleRevisionCollection	"Remove all of aStoreBundle's components from revisionsCollection in a way that preserves the correctness of the load order.	This is done by moving aStoreBundle and its recursive prerequisites (found in bundleRevisionCollection) forward in the list to	the position of the earliest of its components (called 'pivot' in the code)."	| bundleComponents pivot first rest replacements |	bundleComponents := aStoreBundle containedItems.	pivot := revisionsCollection				findFirst: [:each | bundleComponents includes: each].	pivot isZero ifTrue: [^self].	first := revisionsCollection copyFrom: 1 to: pivot - 1.	replacements := self removeAll: first from: bundleRevisionCollection.	rest := self removeAll: replacements				from: (revisionsCollection copyFrom: pivot + 1 to: revisionsCollection size).	^self removeAll: bundleComponents from: first , replacements , rest</body><body package="StoreCI-Polling">removeAll: toRemoveCollection from: mainCollection	^mainCollection		reject: [:each | toRemoveCollection includes: each]</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>private - testing support</category><body package="StoreCI-Polling">revisions	^revisions</body></methods><methods><class-id>StoreCI.Polling.LoadOrder class</class-id> <category>instance creation</category><body package="StoreCI-Polling">allRevisions: aCollection bundleRevisions: aDictionary	^self new initializeAllRevisions: aCollection bundleRevisions: aDictionary</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>private</category><body package="StoreCI-Polling">asXMLElementForStoreCI	| element |	element := Element tag: pundleType storeCIElementTag.	element addAttribute: (Attribute name: 'name' value: self name).	^element</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystem</class-id> <category>command line</category><body package="StoreCI-Support">enableDebugging	&lt;option: '-debug' sequence: -100&gt;	debug := true</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>command line</category><body package="StoreCI-Polling">bundles: aStream	&lt;option: '-bundle'&gt;	&lt;option: '-bundles'&gt;	rootPundles addAll: ((CommandLineInterest argumentsFrom: aStream)				collect: [:each | PundleSpec forBundle: each])</body><body package="StoreCI-Polling">changelogFile: aStream	&lt;option: '-changelog'&gt;	changelogFile := aStream next asFilename</body><body package="StoreCI-Polling">currentTime: aStream	&lt;option: '-now'&gt;	currentTime := Timestamp readFrom: aStream next readStream</body><body package="StoreCI-Polling">lastBuildTime: aStream	&lt;option: '-since'&gt;	lastBuildTime := Timestamp readFrom: aStream next readStream</body><body package="StoreCI-Polling">minimumBlessingLevel: aStream	&lt;option: '-blessedAtLeast'&gt;	| blessing |	blessing := aStream next.	minimumBlessingLevel := (Store.Policies blessingPolicy blessingNumber: blessing)				ifNil: [^BlessingNotFound raiseWith: blessing]</body><body package="StoreCI-Polling">packages: aStream	&lt;option: '-package'&gt;	&lt;option: '-packages'&gt;	rootPundles addAll: ((CommandLineInterest argumentsFrom: aStream)				collect: [:each | PundleSpec forPackage: each])</body><body package="StoreCI-Polling">parcelBuilderInputFile: aStream	&lt;option: '-parcelBuilderFile'&gt;	parcelBuilderInputFile := aStream next asFilename</body><body package="StoreCI-Polling">repository: aStream	&lt;option: '-repository'&gt;	repository := self repositoryNamed: aStream next</body><body package="StoreCI-Polling">versionRegex: aStream	&lt;option: '-versionRegex'&gt;	versionMatcher := aStream next asRegex</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>command line</category><body package="StoreCI-Building">inputFile: aStream	&lt;option: '-loadPundlesIn'&gt;	inputFilename := aStream next asFilename</body><body package="StoreCI-Building">repository: aStream	&lt;option: '-repository'&gt;	repository := self repositoryNamed: aStream next</body><body package="StoreCI-Building">targetDirectory: aStream	&lt;option: '-writeParcelsTo'&gt;	targetDirectory := aStream next asFilename</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>command-line</category><body package="StoreCI-Testing">testBundles: aStream	&lt;option: '-testBundles'&gt;	| bundles |	bundles := (CommandLineInterest argumentsFrom: aStream)				collect: [:each | Store.Registry bundleNamed: each].	suiteBuilder includePundles: bundles</body><body package="StoreCI-Testing">testClasses: aStream	&lt;option: '-testClasses'&gt;	| classes |	classes := (CommandLineInterest argumentsFrom: aStream)				collect: [:each | each asQualifiedReference value].	suiteBuilder includeClasses: classes</body><body package="StoreCI-Testing">testPackages: aStream	&lt;option: '-testPackages'&gt;	| packages |	packages := (CommandLineInterest argumentsFrom: aStream)				collect: [:each | Store.Registry packageNamed: each].	suiteBuilder includePundles: packages</body><body package="StoreCI-Testing">testResultsFile: aStream	&lt;option: '-testResultsFile'&gt;	outputFile := aStream next asFilename</body><body package="StoreCI-Testing">traceFile: aStream	&lt;option: '-traceFile'&gt;	suiteRunner addObserver: (Trace onFile: aStream next asFilename)</body></methods><methods><class-id>StoreCI.Support.ImportRepositoriesSubsystem</class-id> <category>command-line</category><body package="StoreCI-StoreSupport">importRepositoryDefinitions: aStream	&lt;option: '-repositoriesFrom' sequence: -50&gt;	&lt;option: '-repositoryFrom' sequence: -50&gt;	&lt;option: '-reposFrom' sequence: -50&gt;	&lt;option: '-repoFrom' sequence: -50&gt;	| filename rs |	filename := aStream next asFilename.	rs := filename readStream.	[Store.RepositoryManager importRepositoriesFromStream: rs]		ensure: [rs close]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>converting</category><body package="StoreCI-StoreSupport">asStoreCIPundleSpec	^PundleSpec		named: self name		type: self class		version: self version</body></methods><methods><class-id>Kernel.PrerequisiteDescription</class-id> <category>converting</category><body package="StoreCI-StoreSupport">asStoreCIPundleSpec	^self componentType == #bundle		ifTrue: [PundleSpec forBundle: self name]		ifFalse: [PundleSpec forPackage: self name]</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>accessing</category><body package="StoreCI-Polling">storeCIElementTag	^'bundle'</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>accessing</category><body package="StoreCI-Polling">storeCIElementTag	^'package'</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>accessing</category><body package="StoreCI-Polling">storeCIElementTag	^self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>converting</category><body package="StoreCI-Polling">asXMLElementForStoreCI	| element |	element := (Element tag: self class storeCIElementTag)				addAttribute: (Attribute name: 'name' value: self name);				addAttribute: (Attribute name: 'version' value: self version);				yourself.	(self blessings asSortedCollection: [:a :b | a timestamp &gt;= b timestamp])		do: [:each | element addNode: each asXMLElementForStoreCI].	^element</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>converting</category><body package="StoreCI-Polling">asXMLElementForStoreCI	| formattedTimestamp |	formattedTimestamp := ((Locale named: #C) printAsTime: self timestamp				policyNamed: #editing) asString.	^(Element tag: 'blessing')		addAttribute: (Attribute name: 'user' value: self username);		addAttribute: (Attribute name: 'timestamp' value: formattedTimestamp);		addNode: (XML.Text text: self comment);		yourself</body></methods><methods><class-id>SUnit.ExceptionalResult</class-id> <category>converting</category><body package="StoreCI-Testing">asTestLoggerXML	| element |	element := Element				tag: self testLoggerXMLTag				attributes: (Array						with: (Attribute name: 'message' value: exception errorString)						with: (Attribute name: 'type' value: exception class name asString))				elements: (Array with: (XML.Text text: self testLoggerXMLDetails)).	^(super asTestLoggerXML)		addNode: element;		yourself</body><body package="StoreCI-Testing">testLoggerXMLDetails	^((String new: 100) writeStream)		nextPutAll: exception description;		cr;		nextPutAll: exception initialContext printStack;		contents</body><body package="StoreCI-Testing">testLoggerXMLTag	^self subclassResponsibility</body></methods><methods><class-id>SUnit.Result</class-id> <category>converting</category><body package="StoreCI-Testing">asTestLoggerXML	^Element		tag: 'testcase'		attributes: (Array				with: (Attribute new name: 'name' value: self definition printString))		elements: nil</body></methods><methods><class-id>SUnit.Failure</class-id> <category>converting</category><body package="StoreCI-Testing">testLoggerXMLTag	^'failure'</body></methods><methods><class-id>SUnit.SomeError</class-id> <category>converting</category><body package="StoreCI-Testing">testLoggerXMLTag	^'error'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>StoreBlessing</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp username comment blessingLevel trace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><class><name>StorePundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment properties propertiesBlob propertiesRecordDictionary version blessings currentBlessingLevel storeModel session versionless fullClasses </inst-vars><class-inst-vars>cache </class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Database Model</package></attributes></class><class><name>PrerequisiteDescription</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>System-Code Components</package></attributes></class><class><name>Result</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>ExceptionalResult</name><environment>SUnit</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>SomeError</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>Results</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errors passes failures </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Failure</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>