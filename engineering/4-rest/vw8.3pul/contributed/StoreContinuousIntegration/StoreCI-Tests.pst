<?xml version="1.0"?><st-source><!-- Name: StoreCI-TestsNotice: The MIT LicenseCopyright (c) 2012 - 2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.BundleName: StoreCI-TestsBundleStructure: a Store.BundleForParcelComment: StoreCI is licensed under the MIT license.  See the Copyright tab in the RB, or the 'notice' property of this package.This package contains the unit tests for the StoreCI bundle.  See that bundle's comment for more information.DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Regex11' '') #(#any 'StoreBase' '') #(#any 'StoreCI-Support' '') #(#any 'StoreCI-StoreSupport' '') #(#any 'StoreCI-Building' '') #(#any 'StoreCI-Polling' '') #(#any 'StoreCI-Testing' '') #(#any 'SUnitToo' ''))Parcel: nilParcelName: StoreCI-TestsPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Regex11' #componentType #package) #(#name 'StoreBase' #componentType #bundle) #(#name 'StoreCI-Support' #componentType #package) #(#name 'StoreCI-StoreSupport' #componentType #package) #(#name 'StoreCI-Building' #componentType #package) #(#name 'StoreCI-Polling' #componentType #package) #(#name 'StoreCI-Testing' #componentType #package) #(#name 'SUnitToo' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Regex11' '') #('StoreBase' '') #('StoreCI-Support' '') #('StoreCI-StoreSupport' '') #('StoreCI-Building' '') #('StoreCI-Polling' '') #('StoreCI-Testing' '') #('SUnitToo' '') #('Base VisualWorks' '') #('StoreCI-Support' '') #('SUnitToo' '') #('Regex11' '') #('StoreBase' '') #('StoreCI-Polling' '') #('StoreCI-StoreSupport' '') #('StoreCI-Building' '') #('StoreCI-Testing' ''))Version: 38Date: 1:42:28 PM June 17, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.3) of June 17, 2016 on June 17, 2016 at 1:42:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StubPundle</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name prerequisites timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>TraceTest</name><environment>StoreCI.Testing</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream trace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>StubPollingSubsystem</name><environment>StoreCI.Polling</environment><super>StoreCI.Polling.PollingSubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runBlock exitCode commandLineTokens wroteRevisionState wroteChangelog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubClock</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>UnavailableResource</name><environment>StoreCI.Testing</environment><super>SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>RevisionStateTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StoreCISubsystemTest</name><environment>StoreCI.Support</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorStream system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Support-Tests</package></attributes></class><class><name>BuildingSubsystemTest</name><environment>StoreCI.Building</environment><super>StoreCI.Support.StoreCISubsystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building-Tests</package></attributes></class><class><name>StubBuildingSubsystem</name><environment>StoreCI.Building</environment><super>StoreCI.Building.BuildingSubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runBlock commandLineTokens exitCode loadedPundles parcelsWritten imagePundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building-Tests</package></attributes></class><class><name>StubClockTest</name><environment>StoreCI.Testing</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>ChangelogTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changelog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubPackage</name><environment>StoreCI.Polling</environment><super>StoreCI.Polling.StubPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>SampleTestCase</name><environment>StoreCI.Testing</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>LoadOrderTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>KnownPundleCacheTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cacheFile cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubPackageTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>XMLResultWriterTest</name><environment>StoreCI.Testing</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>PundleSpecTest</name><environment>StoreCI.Support</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-StoreSupport-Tests</package></attributes></class><class><name>TestingSubsystemTest</name><environment>StoreCI.Testing</environment><super>StoreCI.Support.StoreCISubsystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>StubTestingSubsystem</name><environment>StoreCI.Testing</environment><super>StoreCI.Testing.TestingSubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>commandLineTokens exitCode runBlock testResult filteredClasses filteredPundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>SuiteResultsTest</name><environment>StoreCI.Testing</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clock suiteResults </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>BlessingNotFoundTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubBundle</name><environment>StoreCI.Polling</environment><super>StoreCI.Polling.StubPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>SampleSuiteBuilder</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing-Tests</package></attributes></class><class><name>StubBundleTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>PollingSubsystemTest</name><environment>StoreCI.Polling</environment><super>StoreCI.Support.StoreCISubsystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>RepositoryNotFoundTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><shared-variable><name>Current</name><environment>StoreCI.Testing.StubClock</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>StoreCI-Testing-Tests</package></attributes></shared-variable><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">containedItems	^self subclassResponsibility</body><body package="StoreCI-Polling-Tests">name	^name</body><body package="StoreCI-Polling-Tests">prerequisiteDescriptions	^prerequisites</body><body package="StoreCI-Polling-Tests">timestamp	^timestamp</body><body package="StoreCI-Polling-Tests">timestamp: aTimestamp	timestamp := aTimestamp</body><body package="StoreCI-Polling-Tests">version	^'42'</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>private</category><body package="StoreCI-Polling-Tests">elementTag	^self subclassResponsibility</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>converting</category><body package="StoreCI-Polling-Tests">asStoreCIPundleSpec	^self subclassResponsibility</body><body package="StoreCI-Polling-Tests">asXMLElementForStoreCI	^(Element tag: self elementTag)		addAttribute: (Attribute name: 'name' value: name) yourself</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">initializeName: aString prerequisites: aCollection	name := aString.	prerequisites := aCollection collect: 					[:each |					(PrerequisiteDescription new)						name: each name;						componentType: each componentType]</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">isBundle	^self subclassResponsibility</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>printing</category><body package="StoreCI-Polling-Tests">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self name ifNil: ['']);		nextPut: $)</body></methods><methods><class-id>StoreCI.Polling.StubPundle class</class-id> <category>instance creation</category><body package="StoreCI-Polling-Tests">named: aString	^self named: aString prerequisites: #()</body><body package="StoreCI-Polling-Tests">named: aString prerequisites: aCollection	^self new initializeName: aString prerequisites: aCollection</body></methods><methods><class-id>StoreCI.Testing.TraceTest</class-id> <category>initialize-release</category><body package="StoreCI-Testing-Tests">setUp	stream := String new writeStream.	trace := Trace new injectStream: stream</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">exitCode	^exitCode</body><body package="StoreCI-Polling-Tests">runUsing: aBlock	runBlock := aBlock.	self runActivationActions</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>private</category><body package="StoreCI-Polling-Tests">configuredSCM	^self</body><body package="StoreCI-Polling-Tests">exitWithCode: anInteger	exitCode := anInteger</body><body package="StoreCI-Polling-Tests">run	runBlock ifNil: [super run] ifNotNil: #value</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">wroteChangelog	^wroteChangelog</body><body package="StoreCI-Polling-Tests">wroteRevisionState	^wroteRevisionState</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>private-activate/deactivate</category><body package="StoreCI-Polling-Tests">commandLine	^commandLineTokens</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>self shunt</category><body package="StoreCI-Polling-Tests">writeChangesFrom: aFromTimestamp to: aToTimestamp toFile: aFilename revisionStateTo: aStream	wroteChangelog := true</body><body package="StoreCI-Polling-Tests">writeRevisionStateTo: aStream	wroteRevisionState := true</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Polling-Tests">initialize	super initialize.	commandLineTokens := OrderedCollection with: '/path/to/virtualMachine'				with: ObjectMemory imageName.	wroteRevisionState := false.	wroteChangelog := false</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>adding</category><body package="StoreCI-Polling-Tests">addTokens: anArray	commandLineTokens addAll: anArray</body></methods><methods><class-id>StoreCI.Testing.StubClock</class-id> <category>initialize-release</category><body package="StoreCI-Testing-Tests">initialize	super initialize.	currentTime := 0</body></methods><methods><class-id>StoreCI.Testing.StubClock</class-id> <category>accessing</category><body package="StoreCI-Testing-Tests">microsecondClock	^currentTime</body><body package="StoreCI-Testing-Tests">timePasses: aDuration	currentTime := currentTime + aDuration asMicroseconds</body></methods><methods><class-id>StoreCI.Testing.StubClock class</class-id> <category>singleton</category><body package="StoreCI-Testing-Tests">current	^Current ifNil: [Current := self new]</body><body package="StoreCI-Testing-Tests">reset	Current := nil</body></methods><methods><class-id>StoreCI.Testing.StubClock class</class-id> <category>instance creation</category><body package="StoreCI-Testing-Tests">new	^super new initialize</body></methods><methods><class-id>StoreCI.Testing.UnavailableResource</class-id> <category>Testing</category><body package="StoreCI-Testing-Tests">isAvailable	^false</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">assertBundleRevisionsFor: aPundleSpec in: aDictionary match: anArray	| revisions |	revisions := aDictionary at: (registry at: aPundleSpec).	self assert: (revisions asArray collect: #name) = anArray</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>private</category><body package="StoreCI-Polling-Tests">revisionStateFrom: aCollection	^(RevisionState roots: aCollection)		computeWith: [:each | registry at: each  ifAbsent: [nil]];		yourself</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">addChild: childPundleSpec toBundle: bundleSpec	(registry at: bundleSpec) addChild: (registry at: childPundleSpec)</body><body package="StoreCI-Polling-Tests">setUp	registry := Dictionary new</body><body package="StoreCI-Polling-Tests">setUpPundle: aPundleSpec	self setUpPundle: aPundleSpec withPrerequisites: #()</body><body package="StoreCI-Polling-Tests">setUpPundle: parentPundleSpec withPrerequisite: childPundleSpec	self setUpPundle: parentPundleSpec		withPrerequisites: (Array with: childPundleSpec)</body><body package="StoreCI-Polling-Tests">setUpPundle: aPundleSpec withPrerequisites: aCollection	| stubClass |	stubClass := aPundleSpec pundleType == StoreBundle				ifTrue: [StubBundle]				ifFalse: [StubPackage].	registry at: aPundleSpec		put: (stubClass named: aPundleSpec name prerequisites: aCollection)</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystemTest</class-id> <category>private</category><body package="StoreCI-Support-Tests">assertNotRun	system runUsing: [self assert: false description: 'Shouldn''t have run']</body><body package="StoreCI-Support-Tests">ignoreErrorsDuring: aBlock	^aBlock on: Error do: [:ex | ex return: nil]</body><body package="StoreCI-Support-Tests">runWithError	system runUsing: [self error: 'Expected']</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystemTest</class-id> <category>initialize-release</category><body package="StoreCI-Support-Tests">enableDebugging	system addTokens: #('-debug')</body><body package="StoreCI-Support-Tests">newSystem	errorStream := String new writeStream.	^self subsystemClass new errorStream: errorStream</body><body package="StoreCI-Support-Tests">setUp	system := self newSystem</body><body package="StoreCI-Support-Tests">subsystemClass	^self subclassResponsibility</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystemTest</class-id> <category>initialize-release</category><body package="StoreCI-Building-Tests">setUp	super setUp.	self		setUpValidRepository;		setUpValidInputFile</body><body package="StoreCI-Building-Tests">setUpValidInputFile	system addTokens: (Array with: '-loadPundlesIn' with: 'parcelList')</body><body package="StoreCI-Building-Tests">setUpValidRepository	| repositoryName |	repositoryName := Store.RepositoryManager repositories any name.	system addTokens: (Array with: '-repository' with: repositoryName)</body><body package="StoreCI-Building-Tests">subsystemClass	^StubBuildingSubsystem</body></methods><methods><class-id>StoreCI.Building.StubBuildingSubsystem</class-id> <category>private</category><body package="StoreCI-Building-Tests">configuredLoader	^self</body><body package="StoreCI-Building-Tests">configuredWriter	^self</body><body package="StoreCI-Building-Tests">exitWithCode: anInteger	exitCode := anInteger</body></methods><methods><class-id>StoreCI.Building.StubBuildingSubsystem</class-id> <category>self shunt</category><body package="StoreCI-Building-Tests">imagePundles	^imagePundles</body><body package="StoreCI-Building-Tests">loadPundles	imagePundles := Object new.	loadedPundles := true</body><body package="StoreCI-Building-Tests">writeParcels: aCollection	parcelsWritten := aCollection</body></methods><methods><class-id>StoreCI.Building.StubBuildingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Building-Tests">initialize	super initialize.	commandLineTokens := OrderedCollection with: '/path/to/virtualMachine'				with: ObjectMemory imageName.	loadedPundles := false</body></methods><methods><class-id>StoreCI.Building.StubBuildingSubsystem</class-id> <category>accessing</category><body package="StoreCI-Building-Tests">exitCode	^exitCode</body><body package="StoreCI-Building-Tests">loadedPundles	^loadedPundles</body><body package="StoreCI-Building-Tests">parcelsWritten	^parcelsWritten</body><body package="StoreCI-Building-Tests">run	runBlock ifNil: [super run] ifNotNil: #value</body><body package="StoreCI-Building-Tests">runUsing: aBlock	runBlock := aBlock.	self runActivationActions</body></methods><methods><class-id>StoreCI.Building.StubBuildingSubsystem</class-id> <category>private-activate/deactivate</category><body package="StoreCI-Building-Tests">commandLine	^commandLineTokens</body></methods><methods><class-id>StoreCI.Building.StubBuildingSubsystem</class-id> <category>adding</category><body package="StoreCI-Building-Tests">addTokens: anArray	commandLineTokens addAll: anArray</body></methods><methods><class-id>StoreCI.Polling.ChangelogTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">setUp	changelog := Changelog knownPundles: (KnownPundleCache withAll: #())</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">containedItems	^#()</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">isBundle	^false</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>private</category><body package="StoreCI-Polling-Tests">elementTag	^StorePackage storeCIElementTag</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>converting</category><body package="StoreCI-Polling-Tests">asStoreCIPundleSpec	^PundleSpec forPackage: name version: self version</body></methods><methods><class-id>StoreCI.Testing.SampleTestCase</class-id> <category>tests</category><body package="StoreCI-Testing-Tests">error	"Not marked as a test; only run as part of SuiteResultsTest"	self error: 'Expected'</body><body package="StoreCI-Testing-Tests">fail	"Not marked as a test; only run as part of SuiteResultsTest"	self assert: false</body><body package="StoreCI-Testing-Tests">pass	"Not marked as a test; only run as part of SuiteResultsTest"	self assert: true</body><body package="StoreCI-Testing-Tests">timed	"Not marked as a test; only run as part of SuiteResultsTest"	StubClock current timePasses: 42 milliseconds.	self assert: true</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCacheTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">setUp	cacheFile := 'test.KnownPundleCache' asFilename.	cache := KnownPundleCache filename: cacheFile</body><body package="StoreCI-Polling-Tests">tearDown	cacheFile exists ifTrue: [cacheFile delete]</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCacheTest</class-id> <category>private</category><body package="StoreCI-Polling-Tests">writeExampleCacheWith: aCollection	cache writeCacheWith: aCollection</body><body package="StoreCI-Polling-Tests">writeLegacyExampleCacheWith: aCollection	| ws |	ws := cacheFile writeStream.	[aCollection do: 			[:each |			ws				nextPutAll: each name;				cr]]		ensure: [ws close]</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriterTest</class-id> <category>private</category><body package="StoreCI-Testing-Tests">rawResults	| writer ws |	writer := XMLResultWriter new.	ws := String new writeStream.	writer writeResults: SuiteResults new to: ws.	^ws contents</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystemTest</class-id> <category>initialize-release</category><body package="StoreCI-Testing-Tests">setUp	super setUp.	self setUpValidOutputFile</body><body package="StoreCI-Testing-Tests">setUpValidOutputFile	system addTokens: (Array with: '-testResultsFile' with: 'results.xml')</body><body package="StoreCI-Testing-Tests">subsystemClass	^StubTestingSubsystem</body></methods><methods><class-id>StoreCI.Testing.StubTestingSubsystem</class-id> <category>accessing</category><body package="StoreCI-Testing-Tests">exitCode	^exitCode</body><body package="StoreCI-Testing-Tests">failTheTests	testResult := false</body><body package="StoreCI-Testing-Tests">filteredClasses	^filteredClasses</body><body package="StoreCI-Testing-Tests">filteredPundles	^filteredPundles</body><body package="StoreCI-Testing-Tests">runUsing: aBlock	runBlock := aBlock.	self runActivationActions</body></methods><methods><class-id>StoreCI.Testing.StubTestingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Testing-Tests">initialize	super initialize.	commandLineTokens := OrderedCollection with: '/path/to/virtualMachine'				with: ObjectMemory imageName.	testResult := true.	filteredClasses := OrderedCollection new.	filteredPundles := OrderedCollection new</body></methods><methods><class-id>StoreCI.Testing.StubTestingSubsystem</class-id> <category>private-activate/deactivate</category><body package="StoreCI-Testing-Tests">commandLine	^commandLineTokens</body></methods><methods><class-id>StoreCI.Testing.StubTestingSubsystem</class-id> <category>adding</category><body package="StoreCI-Testing-Tests">addTokens: anArray	commandLineTokens addAll: anArray</body></methods><methods><class-id>StoreCI.Testing.StubTestingSubsystem</class-id> <category>private</category><body package="StoreCI-Testing-Tests">basicRun	^testResult</body><body package="StoreCI-Testing-Tests">exitWithCode: anInteger	exitCode := anInteger</body><body package="StoreCI-Testing-Tests">run	runBlock ifNil: [super run] ifNotNil: #value</body></methods><methods><class-id>StoreCI.Testing.StubTestingSubsystem</class-id> <category>self shunt</category><body package="StoreCI-Testing-Tests">includeClasses: aCollection	filteredClasses addAll: aCollection</body><body package="StoreCI-Testing-Tests">includePundles: aCollection	filteredPundles addAll: aCollection</body><body package="StoreCI-Testing-Tests">makeSuiteBuilder	^self</body></methods><methods><class-id>StoreCI.Testing.SuiteResultsTest</class-id> <category>private</category><body package="StoreCI-Testing-Tests">assertAttribute: nameString equals: expectedString	self		assertAttribute: nameString		of: self xmlResults		equals: expectedString</body><body package="StoreCI-Testing-Tests">assertAttribute: nameString of: anElement equals: expectedString	self assert: (self attribute: nameString of: anElement) = expectedString</body><body package="StoreCI-Testing-Tests">attribute: aString of: anElement	^anElement valueOfAttribute: aString ifAbsent: [nil]</body><body package="StoreCI-Testing-Tests">buildSuite: aBlock	| builder |	builder := SampleSuiteBuilder new.	aBlock value: builder.	^builder suite</body><body package="StoreCI-Testing-Tests">runSampleSuite: aBlock	| runner |	TestCase noResultsWhile: 			[runner := SuiteRunner new.			suiteResults := runner results.			suiteResults injectClock: clock.			runner runSuite: (self buildSuite: aBlock)]</body><body package="StoreCI-Testing-Tests">xmlResults	^suiteResults asXML root</body></methods><methods><class-id>StoreCI.Testing.SuiteResultsTest</class-id> <category>initialize-release</category><body package="StoreCI-Testing-Tests">setUp	clock := StubClock current.	suiteResults := SuiteResults new</body><body package="StoreCI-Testing-Tests">tearDown	StubClock reset</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">containedItems	^children</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">isBundle	^true</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>adding</category><body package="StoreCI-Polling-Tests">addChild: aStubPundle	children add: aStubPundle</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>private</category><body package="StoreCI-Polling-Tests">elementTag	^StoreBundle storeCIElementTag</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>converting</category><body package="StoreCI-Polling-Tests">asStoreCIPundleSpec	^PundleSpec forBundle: name version: self version</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">initializeName: aString prerequisites: aCollection	super initializeName: aString prerequisites: aCollection.	children := OrderedCollection new</body></methods><methods><class-id>StoreCI.Testing.SampleSuiteBuilder</class-id> <category>buiding</category><body package="StoreCI-Testing-Tests">error	suite addTest: (SampleTestCase selector: #error)</body><body package="StoreCI-Testing-Tests">fail	suite addTest: (SampleTestCase selector: #fail)</body><body package="StoreCI-Testing-Tests">pass	suite addTest: (SampleTestCase selector: #pass)</body><body package="StoreCI-Testing-Tests">skip	suite addTest: (SampleTestCase selector: #skip)</body><body package="StoreCI-Testing-Tests">timed	suite addTest: (SampleTestCase selector: #timed)</body></methods><methods><class-id>StoreCI.Testing.SampleSuiteBuilder</class-id> <category>initialize-release</category><body package="StoreCI-Testing-Tests">initialize	super initialize.	suite := TestSuite new</body></methods><methods><class-id>StoreCI.Testing.SampleSuiteBuilder</class-id> <category>accessing</category><body package="StoreCI-Testing-Tests">suite	^suite</body></methods><methods><class-id>StoreCI.Testing.SampleSuiteBuilder class</class-id> <category>instance creation</category><body package="StoreCI-Testing-Tests">new	^super new initialize</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystemTest</class-id> <category>private</category><body package="StoreCI-Polling-Tests">assertBundles: aCollection	self		assertPundles: (aCollection collect: [:each | PundleSpec forBundle: each])</body><body package="StoreCI-Polling-Tests">assertPackages: aCollection	self		assertPundles: (aCollection collect: [:each | PundleSpec forPackage: each])</body><body package="StoreCI-Polling-Tests">assertPundles: aCollection	self assert: (system pundles isSameSequenceAs: aCollection)</body><body package="StoreCI-Polling-Tests">should: aBlock raiseValidationErrorWithMessage: aString		[aBlock value.	self assert: false] on: ValidationError			do: [:ex | self assert: ex errorString = aString]</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystemTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">setUp	super setUp.	self		setUpValidRepository;		setUpValidPackages</body><body package="StoreCI-Polling-Tests">setUpValidPackages	system addTokens: #('-packages' 'MyPackage' 'YourPackage')</body><body package="StoreCI-Polling-Tests">setUpValidRepository	| repositoryName |	repositoryName := Store.RepositoryManager repositories any name.	system addTokens: (Array with: '-repository' with: repositoryName)</body><body package="StoreCI-Polling-Tests">subsystemClass	^StubPollingSubsystem</body></methods><methods><class-id>StoreCI.Testing.TraceTest</class-id> <category>tests</category><body package="StoreCI-Testing-Tests">logsFailures	&lt;test&gt;	| testCase expected |	testCase := self class selector: thisContext selector.	trace testFinished: (Failure testCase: testCase).	expected := '&lt;1p&gt; Failure&lt;n&gt;' expandMacrosWith: testCase asDefinition.	self assert: stream contents = expected</body><body package="StoreCI-Testing-Tests">logsPasses	&lt;test&gt;	| testCase expected |	testCase := self class selector: thisContext selector.	trace testFinished: (Pass testCase: testCase).	expected := '&lt;1p&gt; Pass&lt;n&gt;' expandMacrosWith: testCase asDefinition.	self assert: stream contents = expected</body><body package="StoreCI-Testing-Tests">logsTestStarts	&lt;test&gt;	| testCase expected |	testCase := self class selector: thisContext selector.	trace testStarted: (Started testCase: testCase).	expected := '&lt;1p&gt; Started&lt;n&gt;' expandMacrosWith: testCase asDefinition.	self assert: stream contents = expected</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">findsBundleAndComponentWithPrerequisites	&lt;test&gt;	| state packageDependency bundleDependency shared package bundle expected |	packageDependency := PundleSpec forPackage: 'PackageDependency'.	bundleDependency := PundleSpec forPackage: 'BundleDependency'.	shared := PundleSpec forPackage: 'SharedDependeny'.	package := PundleSpec forPackage: 'Package'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: packageDependency;		setUpPundle: bundleDependency;		setUpPundle: shared;		setUpPundle: package			withPrerequisites: (Array with: packageDependency with: shared);		setUpPundle: bundle			withPrerequisites: (Array with: shared with: bundleDependency);		addChild: package toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	expected := (OrderedCollection new)				add: shared;				add: bundleDependency;				add: packageDependency;				add: package;				add: bundle;				yourself.	self assert: state specs asArray = expected asArray</body><body package="StoreCI-Polling-Tests">findsEmptyBundleWithNoPrerequisites	&lt;test&gt;	| state pundle |	pundle := PundleSpec forBundle: 'EmptyBundle'.	self setUpPundle: pundle.	state := self revisionStateFrom: (Array with: pundle).	self assert: state specs asArray = (Array with: pundle)</body><body package="StoreCI-Polling-Tests">findsMultiplePackagesWithNoPrerequisites	&lt;test&gt;	| state roots |	roots := #('LonelyPackageA' 'LonelyPackageB')				collect: [:each | PundleSpec forPackage: each].	roots do: [:each1 | self setUpPundle: each1].	state := self revisionStateFrom: roots.	self assert: state specs asArray = roots</body><body package="StoreCI-Polling-Tests">findsNestedBundleWithNoPrerequisites	&lt;test&gt;	| state outer package inner |	package := PundleSpec forPackage: 'Package'.	inner := PundleSpec forBundle: 'Inner'.	outer := PundleSpec forBundle: 'Outer'.	self		setUpPundle: package;		setUpPundle: inner;		setUpPundle: outer.	self addChild: package toBundle: inner.	self addChild: inner toBundle: outer.	state := self revisionStateFrom: (Array with: outer).	self		assert: state specs asArray = (Array with: package with: inner with: outer)</body><body package="StoreCI-Polling-Tests">findsPackageThatDependsOnABundle	&lt;test&gt;	| state package bundle |	package := PundleSpec forPackage: 'Package'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: bundle;		setUpPundle: package withPrerequisite: bundle.	state := self revisionStateFrom: (Array with: package).	self assert: state specs asArray = (Array with: bundle with: package)</body><body package="StoreCI-Polling-Tests">findsPackageThatDependsOnBundleComponent	&lt;test&gt;	| state package bundle component |	package := PundleSpec forPackage: 'Package'.	component := PundleSpec forPackage: 'Component'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: component;		setUpPundle: package withPrerequisite: component;		setUpPundle: bundle;		addChild: component toBundle: bundle.	state := self revisionStateFrom: (Array with: package with: bundle).	self assert: state specs asArray				= (Array with: component with: package with: bundle)</body><body package="StoreCI-Polling-Tests">findsPackageWithOnePrerequisite	&lt;test&gt;	| state dependency root |	dependency := PundleSpec forPackage: 'Dependency'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: dependency;		setUpPundle: root withPrerequisite: dependency.	state := self revisionStateFrom: (Array with: root).	self assert: state specs asArray = (Array with: dependency with: root)</body><body package="StoreCI-Polling-Tests">findsPackageWithSeveralPrerequisites	&lt;test&gt;	| state child1 child2 root |	child1 := PundleSpec forPackage: 'Child1'.	child2 := PundleSpec forPackage: 'Child2'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: child1;		setUpPundle: child2;		setUpPundle: root withPrerequisites: (Array with: child1 with: child2).	state := self revisionStateFrom: (Array with: root).	self		assert: state specs asArray = (Array with: child1 with: child2 with: root)</body><body package="StoreCI-Polling-Tests">findsPrerequisiteChain	&lt;test&gt;	| state child parent grandparent |	child := PundleSpec forPackage: 'Child'.	parent := PundleSpec forPackage: 'Parent'.	grandparent := PundleSpec forPackage: 'Grandparent'.	self		setUpPundle: child;		setUpPundle: parent withPrerequisite: child;		setUpPundle: grandparent withPrerequisite: parent.	state := self revisionStateFrom: (Array with: grandparent).	self assert: state specs asArray				= (Array with: child with: parent with: grandparent)</body><body package="StoreCI-Polling-Tests">findsSimpleBundleWithNoPrerequisites	&lt;test&gt;	| state bundle package |	package := PundleSpec forPackage: 'Package'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: package;		setUpPundle: bundle.	self addChild: package toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	self assert: state specs asArray = (Array with: package with: bundle)</body><body package="StoreCI-Polling-Tests">findsSimpleBundleWithOnePrerequisite	&lt;test&gt;	| state dependency component bundle |	dependency := PundleSpec forPackage: 'Dependency'.	component := PundleSpec forPackage: 'Component'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: dependency;		setUpPundle: component;		setUpPundle: bundle withPrerequisite: dependency;		addChild: component toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	self assert: state specs asArray				= (Array with: dependency with: component with: bundle)</body><body package="StoreCI-Polling-Tests">findsSinglePackageWithNoPrerequisites	&lt;test&gt;	| state pundle |	pundle := PundleSpec forPackage: 'LonelyPackage'.	self setUpPundle: pundle.	state := self revisionStateFrom: (Array with: pundle).	self assert: state specs asArray = (Array with: pundle)</body><body package="StoreCI-Polling-Tests">handlesCycles	&lt;test&gt;	| state root child |	root := PundleSpec forPackage: 'Root'.	child := PundleSpec forPackage: 'Child'.	self		setUpPundle: root withPrerequisite: child;		setUpPundle: child withPrerequisite: root.	state := self revisionStateFrom: (Array with: root).	self assert: state specs asArray = (Array with: child with: root)</body><body package="StoreCI-Polling-Tests">hasNoSpecsUntilComputed	&lt;test&gt;	| state |	state := RevisionState				roots: (Array with: (PundleSpec forPackage: 'Root')).	self assert: state specs isEmpty</body><body package="StoreCI-Polling-Tests">ignoresDuplicates	&lt;test&gt;	| state pundle |	pundle := PundleSpec forPackage: 'LonelyPackage'.	self setUpPundle: pundle.	state := self revisionStateFrom: (Array with: pundle with: pundle copy).	self assert: state specs size = 1</body><body package="StoreCI-Polling-Tests">ignoresMissingPundles	&lt;test&gt;	| state |	state := self				revisionStateFrom: (Array with: (PundleSpec forPackage: 'NoSuchPundle')).	self assert: state specs isEmpty</body><body package="StoreCI-Polling-Tests">includesSharedPrerequisiteOnlyOnce	&lt;test&gt;	| state shared root1 root2 |	shared := PundleSpec forPackage: 'Shared'.	root1 := PundleSpec forPackage: 'Root1'.	root2 := PundleSpec forPackage: 'Root2'.	self		setUpPundle: shared;		setUpPundle: root1 withPrerequisite: shared;		setUpPundle: root2 withPrerequisite: shared.	state := self revisionStateFrom: (Array with: root1 with: root2).	self		assert: state specs asArray = (Array with: shared with: root1 with: root2)</body><body package="StoreCI-Polling-Tests">remembersBundlePrerequisites	&lt;test&gt;	| bundle nestedBundle child1 child2 package1 package2 state bundleRevisions |	bundle := PundleSpec forBundle: 'Bundle'.	nestedBundle := PundleSpec forBundle: 'NestedBundle'.	child1 := PundleSpec forPackage: 'Child1'.	child2 := PundleSpec forPackage: 'Child2'.	package1 := PundleSpec forPackage: 'Package1'.	package2 := PundleSpec forPackage: 'Package2'.	self		setUpPundle: child1;		setUpPundle: child2;		setUpPundle: package1;		setUpPundle: package2;		setUpPundle: nestedBundle withPrerequisite: package2;		setUpPundle: bundle withPrerequisite: package1;		addChild: child2 toBundle: nestedBundle;		addChild: child1 toBundle: bundle;		addChild: nestedBundle toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	bundleRevisions := state bundleRevisions.	self assert: bundleRevisions size = 2.	self		assertBundleRevisionsFor: nestedBundle			in: bundleRevisions			match: #('Package2' 'Child2' 'NestedBundle');		assertBundleRevisionsFor: bundle			in: bundleRevisions			match: #('Package1' 'Child1' 'Package2' 'Child2' 'NestedBundle' 'Bundle')</body><body package="StoreCI-Polling-Tests">skipsParcelOnlyPrerequisites	&lt;test&gt;	| state dependency root |	dependency := PundleSpec forPackage: 'Dependency'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: dependency;		setUpPundle: root withPrerequisite: dependency.	(registry at: root) prerequisiteDescriptions first loadResolution: #parcel.	state := self revisionStateFrom: (Array with: root).	self assert: state specs asArray = (Array with: root)</body><body package="StoreCI-Polling-Tests">writesToStream	&lt;test&gt;	| state ws expectedContents dependency root |	dependency := PundleSpec forPackage: 'Dependency'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: dependency;		setUpPundle: root withPrerequisite: dependency.	state := self revisionStateFrom: (Array with: root).	ws := String new writeStream.	state writeOn: ws.	expectedContents := 'StorePackage&lt;t&gt;"Dependency"&lt;t&gt;42StorePackage&lt;t&gt;"Root"&lt;t&gt;42'				expandMacros.	self assert: ws contents = expectedContents</body></methods><methods><class-id>StoreCI.Support.StoreCISubsystemTest</class-id> <category>tests</category><body package="StoreCI-Support-Tests">doesntExitIfAnyRequiredArgumentIsMissing	&lt;test&gt;	system := self newSystem.	system runActivationActions.	self assert: system exitCode isNil</body><body package="StoreCI-Support-Tests">doesntExitOnErrorWhenDebugging	&lt;test&gt;	self enableDebugging.	self ignoreErrorsDuring: [self runWithError].	self assert: system exitCode isNil</body><body package="StoreCI-Support-Tests">doesntExitOnSuccessWhenDebugging	&lt;test&gt;	self enableDebugging.	system runActivationActions.	self assert: system exitCode isNil</body><body package="StoreCI-Support-Tests">exitsWithNonZeroOnError	&lt;test&gt;	self runWithError.	self deny: system exitCode isZero</body><body package="StoreCI-Support-Tests">exitsWithZeroIfNoErrors	&lt;test&gt;	system runActivationActions.	self assert: system exitCode isZero</body><body package="StoreCI-Support-Tests">reportsErrors	&lt;test&gt;	self runWithError.	self assert: errorStream contents = 'Expected\' withCRs</body><body package="StoreCI-Support-Tests">reportsErrorsWhenDebugging	&lt;test&gt;	self enableDebugging.	self ignoreErrorsDuring: [self runWithError].	self assert: errorStream contents = 'Expected\' withCRs</body><body package="StoreCI-Support-Tests">reportsNoErrorsOnSuccess	&lt;test&gt;	system runActivationActions.	self assert: errorStream contents isEmpty</body><body package="StoreCI-Support-Tests">reraisesErrorsWhenDebugging	&lt;test&gt;	self enableDebugging.	self should: [self runWithError] raise: Error</body><body package="StoreCI-Support-Tests">runsWhenFullyConfigured	&lt;test&gt;	| runWasSent |	runWasSent := false.	system runUsing: [runWasSent := true].	self assert: runWasSent</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystemTest</class-id> <category>tests</category><body package="StoreCI-Building-Tests">doesntRunIfNoInputFile	&lt;test&gt;	system := self newSystem.	self setUpValidRepository.	self assertNotRun</body><body package="StoreCI-Building-Tests">doesntRunIfNoRepository	&lt;test&gt;	system := self newSystem.	self setUpValidInputFile.	self assertNotRun</body><body package="StoreCI-Building-Tests">doesntWriteParcelsIfNoTargetDirectory	&lt;test&gt;	system runActivationActions.	self assert: system parcelsWritten isNil</body><body package="StoreCI-Building-Tests">loadsPundles	&lt;test&gt;	system runActivationActions.	self assert: system loadedPundles</body><body package="StoreCI-Building-Tests">raisesAnErrorWhenRepositoryNotFound	&lt;test&gt;	system := self newSystem.	self enableDebugging.	system addTokens: #('-repository' 'No Such Repository').	self should: [system runActivationActions] raise: RepositoryNotFound</body><body package="StoreCI-Building-Tests">setsDebugFlagBeforeProcessingOtherArguments	&lt;test&gt;	system addTokens: #('-repository' 'NoSuchRepository' '-debug').	self should: [system runActivationActions] raise: RepositoryNotFound</body><body package="StoreCI-Building-Tests">writesParcels	&lt;test&gt;	system addTokens: #('-writeParcelsTo' 'targetDirectory').	system runActivationActions.	self assert: system parcelsWritten == system imagePundles</body></methods><methods><class-id>StoreCI.Testing.StubClockTest</class-id> <category>tests</category><body package="StoreCI-Testing-Tests">matchesProtocol	&lt;test&gt;	self		assert: (StubClock canUnderstand: #microsecondClock);		assert: (Time class canUnderstand: #microsecondClock)</body></methods><methods><class-id>StoreCI.Polling.ChangelogTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">generatesDeletedPundlesLast	&lt;test&gt;	| xml elements |	changelog		addPundle: (StubPackage named: 'Package');		noteDeletedPundle: (PundleSpec forPackage: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 2;		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Package';		assert: (elements last valueOfAttribute: 'name' ifAbsent: ['']) = 'Deleted'</body><body package="StoreCI-Polling-Tests">generatesEmptyLogWhenNoChanges	&lt;test&gt;	| xml |	xml := changelog asXML.	self assert: xml root isEmpty</body><body package="StoreCI-Polling-Tests">generatesEntryForDeletedBundle	&lt;test&gt;	| xml elements |	changelog noteDeletedPundle: (PundleSpec forBundle: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'bundle';		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Deleted'</body><body package="StoreCI-Polling-Tests">generatesEntryForDeletedPackage	&lt;test&gt;	| xml elements |	changelog noteDeletedPundle: (PundleSpec forPackage: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'package';		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Deleted'</body><body package="StoreCI-Polling-Tests">generatesEntryForSingleBundle	&lt;test&gt;	| xml elements |	changelog addPundle: (StubBundle named: 'Bundle').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'bundle';		assert: (elements first valueOfAttribute: 'name' ifAbsent: ['']) = 'Bundle'</body><body package="StoreCI-Polling-Tests">generatesEntryForSinglePackage	&lt;test&gt;	| xml elements |	changelog addPundle: (StubPackage named: 'Package').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'package';		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Package'</body><body package="StoreCI-Polling-Tests">generatesNewestPundlesFirst	&lt;test&gt;	| xml elements older now newer |	now := Timestamp now.	older := StubPackage named: 'Older'.	older timestamp: now - 1 hours.	newer := StubBundle named: 'Newer'.	newer timestamp: now.	changelog		addPundle: older;		addPundle: newer.	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 2;		assert: (elements first valueOfAttribute: 'name' ifAbsent: ['']) = 'Newer';		assert: (elements last valueOfAttribute: 'name' ifAbsent: ['']) = 'Older'</body><body package="StoreCI-Polling-Tests">generatesRootXMLElement	&lt;test&gt;	| xml |	xml := changelog asXML.	self assert: xml root expandedName = 'log'</body><body package="StoreCI-Polling-Tests">ignoresHeadRevisionIfAlreadyAdded	&lt;test&gt;	| head |	head := StubPackage named: 'Package'.	changelog addPundle: head.	changelog noteHeadRevision: head.	self assert: changelog size = 1</body><body package="StoreCI-Polling-Tests">ignoresHeadRevisionIfNil	&lt;test&gt;	changelog noteHeadRevision: nil.	self assert: changelog isEmpty</body><body package="StoreCI-Polling-Tests">ignoresHeadRevisionOfKnownPundle	&lt;test&gt;	| head |	changelog := Changelog knownPundles: (KnownPundleCache						withAll: (Array with: (PundleSpec forBundle: 'Bundle'))).	head := StubBundle named: 'Bundle'.	changelog noteHeadRevision: head.	self assert: changelog isEmpty</body><body package="StoreCI-Polling-Tests">marksDeletedPundlesAsDeleted	&lt;test&gt;	| xml elements |	changelog noteDeletedPundle: (PundleSpec forBundle: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self assert: (elements first valueOfAttribute: 'action' ifAbsent: [''])				= 'deleted'</body><body package="StoreCI-Polling-Tests">marksKnownPundlesAsModified	&lt;test&gt;	| xml elements |	changelog := Changelog knownPundles: (KnownPundleCache						withAll: (Array with: (PundleSpec forPackage: 'Package'))).	changelog addPundle: (StubPackage named: 'Package').	xml := changelog asXML.	elements := xml root elements.	self assert: (elements first valueOfAttribute: 'action' ifAbsent: [''])				= 'modified'</body><body package="StoreCI-Polling-Tests">marksNewPundlesAsAdded	&lt;test&gt;	| xml elements |	changelog addPundle: (StubBundle named: 'Bundle').	xml := changelog asXML.	elements := xml root elements.	self assert: (elements first valueOfAttribute: 'action' ifAbsent: [''])				= 'added'</body><body package="StoreCI-Polling-Tests">preservesOrderOfSimultaneousPundles	&lt;test&gt;	| xml elements first now second |	now := Timestamp now.	first := StubPackage named: 'First'.	first timestamp: now.	second := StubBundle named: 'Second'.	second timestamp: now.	changelog		addPundle: first;		addPundle: second.	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 2;		assert: (elements first valueOfAttribute: 'name' ifAbsent: ['']) = 'First';		assert: (elements last valueOfAttribute: 'name' ifAbsent: ['']) = 'Second'</body><body package="StoreCI-Polling-Tests">remembersHeadRevision	&lt;test&gt;	| head |	head := StubPackage named: 'Package'.	changelog noteHeadRevision: head.	self assert: (changelog includes: head)</body><body package="StoreCI-Polling-Tests">writesXMLHeader	&lt;test&gt;	| expected ws |	expected := '&lt;?xml version="1.0"?&gt;'.	ws := String new writeStream.	changelog writeToStream: ws.	self assert: (ws contents first: expected size) = expected</body></methods><methods><class-id>StoreCI.Testing.SampleTestCase</class-id> <category>tests</category><body package="StoreCI-Testing-Tests">skip	"Not marked as a test; only run as part of SuiteResultsTest"	&lt;uses: #UnavailableResource&gt;	self assert: false description: 'Should never get here'</body></methods><methods><class-id>StoreCI.Polling.LoadOrderTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">doesntMoveBundlePrereqBackwards	&lt;test&gt;	| package bundle loadOrder dependent prereq other revisions |	prereq := StubPackage named: 'Prereq'.	other := StubPackage named: 'Other'.	package := StubPackage named: 'Package'.	dependent := StubPackage named: 'Dependent'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	revisions := (OrderedCollection new)				add: other;				add: prereq;				add: package;				add: dependent;				add: bundle;				yourself.	loadOrder := LoadOrder allRevisions: revisions				bundleRevisions: (Dictionary						with: bundle -&gt; (Array with: prereq with: other with: bundle)).	self		assert: loadOrder revisions asArray = (Array						with: other						with: prereq						with: bundle						with: dependent)</body><body package="StoreCI-Polling-Tests">loadsPackagesInGivenOrder	&lt;test&gt;	| packages loadOrder |	packages := Array with: (StubPackage named: 'A')				with: (StubPackage named: 'B').	loadOrder := LoadOrder allRevisions: packages bundleRevisions: Dictionary new.	self assert: loadOrder revisions asArray  = packages</body><body package="StoreCI-Polling-Tests">movesBundleForwardInLoadOrderWhenNecessary	&lt;test&gt;	| package bundle loadOrder dependent |	package := StubPackage named: 'Package'.	dependent := StubPackage named: 'Dependent'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	loadOrder := LoadOrder				allRevisions: (Array with: package with: dependent with: bundle)				bundleRevisions: (Dictionary with: bundle -&gt; (Array with: bundle)).	self		assert: loadOrder revisions asArray = (Array with: bundle with: dependent)</body><body package="StoreCI-Polling-Tests">movesBundlePrereqsForwardWithBundle	&lt;test&gt;	| package bundle loadOrder dependent prereq |	package := StubPackage named: 'Package'.	dependent := StubPackage named: 'Dependent'.	prereq := StubPackage named: 'Prereq'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	loadOrder := LoadOrder allRevisions: (Array						with: package						with: dependent						with: prereq						with: bundle)				bundleRevisions: (Dictionary						with: bundle -&gt; (Array with: prereq with: bundle)).	self assert: loadOrder revisions asArray				= (Array with: prereq with: bundle with: dependent)</body><body package="StoreCI-Polling-Tests">removesPackagesContainedInBundles	&lt;test&gt;	| package bundle loadOrder |	package := StubPackage named: 'Package'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	loadOrder := LoadOrder allRevisions: (Array with: package with: bundle)				bundleRevisions: (Dictionary with: bundle -&gt; (Array with: bundle)).	self assert: loadOrder revisions asArray = (Array with: bundle)</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCacheTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">cachesNewPundles	&lt;test&gt;	| expectedContents specs |	specs := Array				with: (PundleSpec forBundle: 'NewA')				with: (PundleSpec forPackage: 'NewB')				with: (PundleSpec forBundle: 'NewC').	cache updateWithPundles: specs.	expectedContents := 'StoreBundle	"NewA"StorePackage	"NewB"StoreBundle	"NewC"'.	self assert: cacheFile contentsOfEntireFile = expectedContents</body><body package="StoreCI-Polling-Tests">canIncludeVersionedPundle	&lt;test&gt;	cache := KnownPundleCache				withAll: (Array with: (PundleSpec forPackage: 'Package')).	self		assert: (cache includes: (PundleSpec forPackage: 'Package' version: '42'))</body><body package="StoreCI-Polling-Tests">computesMissingPundles	&lt;test&gt;	| deleted a b c |	a := PundleSpec forBundle: 'BundleA'.	b := PundleSpec forPackage: 'PackageB'.	c := PundleSpec forPackage: 'PackageC'.	cache := KnownPundleCache withAll: (Array with: a with: b with: c).	deleted := cache pundlesMissingFrom: (Array with: b).	self assert: deleted = (Set with: a with: c)</body><body package="StoreCI-Polling-Tests">isEmptyIfCacheFileDoesntExist	&lt;test&gt;	cache load.	self assert: cache isEmpty</body><body package="StoreCI-Polling-Tests">loadsCache	&lt;test&gt;	| specs |	specs := Array with: (PundleSpec forPackage: 'Package')				with: (PundleSpec forBundle: 'Bundle').	self writeExampleCacheWith: specs.	cache load.	self assert: cache size = specs size.	specs do: [:each | self assert: (cache includes: each)]</body><body package="StoreCI-Polling-Tests">loadsOldFormatCache	&lt;test&gt;	| specs |	specs := #('PackageA' 'PackageB')				collect: [:each | PundleSpec forPackage: each].	self writeLegacyExampleCacheWith: specs.	cache load.	self assert: cache size = specs size.	specs do: [:each | self assert: (cache includes: each)]</body></methods><methods><class-id>StoreCI.Polling.StubPackageTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">protocolMatchesRealClass	&lt;test&gt;	#(#asStoreCIPundleSpec #asXMLElementForStoreCI #name #prerequisiteDescriptions #timestamp #version #containedItems #isBundle)		do: 			[:each |			self				assert: (StorePackage canUnderstand: each)					description: 'StorePackage doesn''t understand ' , each printString;				assert: (StubPackage canUnderstand: each)					description: 'StubPackage doesn''t understand ' , each printString]</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriterTest</class-id> <category>tests</category><body package="StoreCI-Testing-Tests">includesSuiteResultsXML	&lt;test&gt;	| results |	results := self rawResults.	self assert: ('*&lt;testsuite*' match: results)</body><body package="StoreCI-Testing-Tests">includesXMLHeader	&lt;test&gt;	| expected results |	expected := '&lt;?xml version="1.0"?&gt;'.	results := self rawResults.	self assert: (results first: expected size) = expected</body></methods><methods><class-id>StoreCI.Support.PundleSpecTest</class-id> <category>tests</category><body package="StoreCI-StoreSupport-Tests">convertingToVersionlessCreatesNewInstance	&lt;test&gt;	| spec |	spec := PundleSpec forPackage: 'Package' version: '42'.	self deny: spec versionless == spec</body><body package="StoreCI-StoreSupport-Tests">convertsVersionedToVersionless	&lt;test&gt;	| spec |	spec := PundleSpec forPackage: 'Package' version: '42'.	self assert: spec versionless = (PundleSpec forPackage: 'Package')</body><body package="StoreCI-StoreSupport-Tests">convertsVersionlessToVersionless	&lt;test&gt;	| spec |	spec := PundleSpec forPackage: 'Package'.	self assert: spec versionless == spec</body><body package="StoreCI-StoreSupport-Tests">ignoresWhitespaceInVersionedLegacyFormat	&lt;test&gt;	| spec |	spec := PundleSpec parse: '    PackageName	42    '.	self assert: spec = (PundleSpec forPackage: 'PackageName' version: '42')</body><body package="StoreCI-StoreSupport-Tests">ignoresWhitespaceInVersionlessLegacyFormat	&lt;test&gt;	| spec |	spec := PundleSpec parse: '    PackageName     '.	self assert: spec = (PundleSpec forPackage: 'PackageName')</body><body package="StoreCI-StoreSupport-Tests">isEqualIfEverythingMatches	&lt;test&gt;	| spec1 spec2 |	spec1 := PundleSpec forPackage: 'Package' version: '42'.	spec2 := PundleSpec forPackage: 'Package' version: '42'.	self assert: spec1 = spec2</body><body package="StoreCI-StoreSupport-Tests">isEqualIfNamesAndTypesMatch	&lt;test&gt;	| spec1 spec2 |	spec1 := PundleSpec forPackage: 'Package'.	spec2 := PundleSpec forPackage: 'Package'.	self assert: spec1 = spec2</body><body package="StoreCI-StoreSupport-Tests">isEqualIfVersionlessNamesAndTypesMatch	&lt;test&gt;	| spec1 spec2 |	spec1 := PundleSpec forPackage: 'Package'.	spec2 := PundleSpec forPackage: 'Package'.	self assert: spec1 = spec2</body><body package="StoreCI-StoreSupport-Tests">isNotEqualIfNameDiffers	&lt;test&gt;	| spec1 spec2 |	spec1 := PundleSpec forPackage: 'Package'.	spec2 := PundleSpec forPackage: 'DifferentName'.	self deny: spec1 = spec2</body><body package="StoreCI-StoreSupport-Tests">isNotEqualIfOneIsVersionless	&lt;test&gt;	| spec1 spec2 |	spec1 := PundleSpec forPackage: 'Pundle' version: '42'.	spec2 := PundleSpec forPackage: 'Pundle'.	self deny: spec1 = spec2</body><body package="StoreCI-StoreSupport-Tests">isNotEqualIfTypeDiffers	&lt;test&gt;	| spec1 spec2 |	spec1 := PundleSpec forPackage: 'Pundle'.	spec2 := PundleSpec forBundle: 'Pundle'.	self deny: spec1 = spec2</body><body package="StoreCI-StoreSupport-Tests">isNotEqualIfVersionDiffers	&lt;test&gt;	| spec1 spec2 |	spec1 := PundleSpec forPackage: 'Pundle' version: '42'.	spec2 := PundleSpec forPackage: 'Pundle' version: '58'.	self deny: spec1 = spec2</body><body package="StoreCI-StoreSupport-Tests">knowsBundleComponentType	&lt;test&gt;	self assert: (PundleSpec forBundle: 'Bundle') componentType == #bundle</body><body package="StoreCI-StoreSupport-Tests">knowsPackageComponentType	&lt;test&gt;	self assert: (PundleSpec forPackage: 'Package') componentType == #package</body><body package="StoreCI-StoreSupport-Tests">parsesAllVersionedFromAStream	&lt;test&gt;	| contents specs |	contents := 'StorePackage	"PackageName"	42StoreBundle	"BundleName"	58'.	specs := PundleSpec allFrom: contents readStream.	self assert: specs asArray				= (Array with: (PundleSpec forPackage: 'PackageName' version: '42')						with: (PundleSpec forBundle: 'BundleName' version: '58'))</body><body package="StoreCI-StoreSupport-Tests">parsesAllVersionlessFromAStream	&lt;test&gt;	| contents specs |	contents := 'StorePackage	"PackageName"StoreBundle	"BundleName"'.	specs := PundleSpec allFrom: contents readStream.	self		assert: specs asArray = (Array with: (PundleSpec forPackage: 'PackageName')						with: (PundleSpec forBundle: 'BundleName'))</body><body package="StoreCI-StoreSupport-Tests">parsesVersionedBundleSpec	&lt;test&gt;	| spec |	spec := PundleSpec parse: 'StoreBundle	"BundleName"	42'.	self assert: spec = (PundleSpec forBundle: 'BundleName' version: '42')</body><body package="StoreCI-StoreSupport-Tests">parsesVersionedLegacyFormat	&lt;test&gt;	| spec |	spec := PundleSpec parse: 'PackageName	42'.	self assert: spec = (PundleSpec forPackage: 'PackageName' version: '42')</body><body package="StoreCI-StoreSupport-Tests">parsesVersionedPackageSpec	&lt;test&gt;	| spec |	spec := PundleSpec parse: 'StorePackage	"PackageName"	42'.	self assert: spec = (PundleSpec forPackage: 'PackageName' version: '42')</body><body package="StoreCI-StoreSupport-Tests">parsesVersionlessBundleSpec	&lt;test&gt;	| spec |	spec := PundleSpec parse: 'StoreBundle	"BundleName"'.	self assert: spec = (PundleSpec forBundle: 'BundleName')</body><body package="StoreCI-StoreSupport-Tests">parsesVersionlessLegacyFormat	&lt;test&gt;	| spec |	spec := PundleSpec parse: 'PackageName'.	self assert: spec = (PundleSpec forPackage: 'PackageName')</body><body package="StoreCI-StoreSupport-Tests">parsesVersionlessPackageSpec	&lt;test&gt;	| spec |	spec := PundleSpec parse: 'StorePackage	"PackageName"'.	self assert: spec = (PundleSpec forPackage: 'PackageName')</body><body package="StoreCI-StoreSupport-Tests">writesAllToAStream	&lt;test&gt;	| ws expected |	ws := String new writeStream.	PundleSpec writeAll: (Array with: (PundleSpec forPackage: 'PackageName')				with: (PundleSpec forBundle: 'BundleName'))		to: ws.	expected := 'StorePackage	"PackageName"StoreBundle	"BundleName"'.	self assert: ws contents = expected</body><body package="StoreCI-StoreSupport-Tests">writesVersionedToStream	&lt;test&gt;	| spec ws |	spec := PundleSpec forBundle: 'Name With Spaces' version: '42'.	ws := String new writeStream.	spec writeOn: ws.	self assert: ws contents = 'StoreBundle	"Name With Spaces"	42'</body><body package="StoreCI-StoreSupport-Tests">writesVersionlessToStream	&lt;test&gt;	| spec ws |	spec := PundleSpec forPackage: 'Name With Spaces'.	ws := String new writeStream.	spec writeOn: ws.	self assert: ws contents = 'StorePackage	"Name With Spaces"'</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystemTest</class-id> <category>tests</category><body package="StoreCI-Testing-Tests">doesntFilterClassesByDefault	&lt;test&gt;	self assert: system filteredClasses isEmpty</body><body package="StoreCI-Testing-Tests">doesntFilterPackagesByDefault	&lt;test&gt;	self assert: system filteredPundles isEmpty</body><body package="StoreCI-Testing-Tests">doesntRunIfNoOutputFile	&lt;test&gt;	system := self newSystem.	self assertNotRun</body><body package="StoreCI-Testing-Tests">exitsWithNonZeroOnTestFailure	&lt;test&gt;	system failTheTests.	system runActivationActions.	self deny: system exitCode isZero</body><body package="StoreCI-Testing-Tests">filtersASingleBundle	&lt;test&gt;	| bundle |	bundle := Store.Registry bundleNamed: 'Base VisualWorks'.	system addTokens: (Array with: '-testBundles' with: bundle name).	system runActivationActions.	self assert: system filteredPundles asArray = (Array with: bundle)</body><body package="StoreCI-Testing-Tests">filtersASingleClass	&lt;test&gt;	system addTokens: (Array with: '-testClasses' with: self class fullName).	system runActivationActions.	self assert: system filteredClasses asArray = (Array with: self class)</body><body package="StoreCI-Testing-Tests">filtersASinglePackage	&lt;test&gt;	| package |	package := Store.Registry packageNamed: 'StoreCI-Testing-Tests'.	system addTokens: (Array with: '-testPackages' with: package name).	system runActivationActions.	self assert: system filteredPundles asArray = (Array with: package)</body><body package="StoreCI-Testing-Tests">filtersMultipleBundles	&lt;test&gt;	| bundles |	bundles := #('System' 'Collections')				collect: [:each | Store.Registry bundleNamed: each].	system addTokens: #('-testBundles') , (bundles collect: #name).	system runActivationActions.	self assert: system filteredPundles asArray = bundles</body><body package="StoreCI-Testing-Tests">filtersMultipleClasses	&lt;test&gt;	system addTokens: (Array				with: '-testClasses'				with: self class fullName				with: self class superclass fullName).	system runActivationActions.	self assert: system filteredClasses asArray				= (Array with: self class with: self class superclass)</body><body package="StoreCI-Testing-Tests">filtersMultiplePackages	&lt;test&gt;	| packages |	packages := #('StoreCI-Testing' 'StoreCI-Testing-Tests')				collect: [:each | Store.Registry packageNamed: each].	system addTokens: #('-testPackages') , (packages collect: #name).	system runActivationActions.	self assert: system filteredPundles asArray = packages</body></methods><methods><class-id>StoreCI.Testing.SuiteResultsTest</class-id> <category>tests</category><body package="StoreCI-Testing-Tests">includesErrorStackTrace	&lt;test&gt;	| element textElement |	self runSampleSuite: [:builder | builder error].	element := (self xmlResults elementNamed: 'testcase')				elementNamed: 'error'.	textElement := element children first.	self assert: ('Expected*' match: textElement text)</body><body package="StoreCI-Testing-Tests">includesFailureStackTrace	&lt;test&gt;	| element textElement |	self runSampleSuite: [:builder | builder fail].	element := (self xmlResults elementNamed: 'testcase')				elementNamed: 'failure'.	textElement := element children first.	self assert: ('Assertion failed*' match: textElement text)</body><body package="StoreCI-Testing-Tests">includesNestedSkipElement	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder skip].	element := (self xmlResults elementNamed: 'testcase')				elementNamed: 'skipped'.	self assert: element notNil</body><body package="StoreCI-Testing-Tests">reportsErrorCount	&lt;test&gt;	self runSampleSuite: [:builder | builder error].	self assertAttribute: 'errors' equals: '1'</body><body package="StoreCI-Testing-Tests">reportsErrorMessage	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder error].	element := (self xmlResults elementNamed: 'testcase')				elementNamed: 'error'.	self assertAttribute: 'message' of: element equals: 'Expected'</body><body package="StoreCI-Testing-Tests">reportsErrorType	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder error].	element := (self xmlResults elementNamed: 'testcase')				elementNamed: 'error'.	self assertAttribute: 'type' of: element equals: 'Error'</body><body package="StoreCI-Testing-Tests">reportsFailingTests	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder fail].	element := self xmlResults elementNamed: 'testcase'.	self		assertAttribute: 'name'		of: element		equals: 'StoreCI.Testing.SampleTestCase&gt;&gt;#fail'</body><body package="StoreCI-Testing-Tests">reportsFailureCount	&lt;test&gt;	self runSampleSuite: [:builder | builder fail].	self assertAttribute: 'failures' equals: '1'</body><body package="StoreCI-Testing-Tests">reportsFailureMessage	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder fail].	element := (self xmlResults elementNamed: 'testcase')				elementNamed: 'failure'.	self assertAttribute: 'message' of: element equals: 'Assertion failed'</body><body package="StoreCI-Testing-Tests">reportsFailureType	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder fail].	element := (self xmlResults elementNamed: 'testcase')				elementNamed: 'failure'.	self assertAttribute: 'type' of: element equals: 'FailedAssertion'</body><body package="StoreCI-Testing-Tests">reportsPassingTests	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder pass].	element := self xmlResults elementNamed: 'testcase'.	self		assertAttribute: 'name'		of: element		equals: 'StoreCI.Testing.SampleTestCase&gt;&gt;#pass'</body><body package="StoreCI-Testing-Tests">reportsSkipCount	&lt;test&gt;	self runSampleSuite: [:builder | builder skip].	self assertAttribute: 'skipped' equals: '1'</body><body package="StoreCI-Testing-Tests">reportsSkippedTests	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder skip].	element := self xmlResults elementNamed: 'testcase'.	self		assertAttribute: 'name'		of: element		equals: 'StoreCI.Testing.SampleTestCase&gt;&gt;#skip'</body><body package="StoreCI-Testing-Tests">reportsSuiteRunTime	&lt;test&gt;	self runSampleSuite: [:builder | builder timed].	self assertAttribute: 'time' equals: '0.042'</body><body package="StoreCI-Testing-Tests">reportsTestCount	&lt;test&gt;	self runSampleSuite: 			[:builder |			builder				pass;				fail;				error].	self assertAttribute: 'tests' equals: '3'</body><body package="StoreCI-Testing-Tests">reportsTestRunTime	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder timed].	element := self xmlResults elementNamed: 'testcase'.	self assertAttribute: 'time' of: element equals: '0.042'</body><body package="StoreCI-Testing-Tests">reportsTestsWithErrors	&lt;test&gt;	| element |	self runSampleSuite: [:builder | builder error].	element := self xmlResults elementNamed: 'testcase'.	self		assertAttribute: 'name'		of: element		equals: 'StoreCI.Testing.SampleTestCase&gt;&gt;#error'</body><body package="StoreCI-Testing-Tests">sortsTests	&lt;test&gt;	| elements |	self runSampleSuite: 			[:builder |			builder				pass;				error;				fail].	elements := self xmlResults anyElementsNamed: 'testcase'.	self		assert: (elements collect: [:each | self attribute: 'name' of: each])				asArray					= #('StoreCI.Testing.SampleTestCase&gt;&gt;#error' 'StoreCI.Testing.SampleTestCase&gt;&gt;#fail' 'StoreCI.Testing.SampleTestCase&gt;&gt;#pass')</body></methods><methods><class-id>StoreCI.Polling.BlessingNotFoundTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">hasCorrectErrorMessage	&lt;test&gt;	| expected |	expected := 'Could not find a blessing level named "NoSuchBlessing"'.	[BlessingNotFound raiseWith: 'NoSuchBlessing'] on: BlessingNotFound		do: [:ex | self assert: ex errorString = expected]</body></methods><methods><class-id>StoreCI.Polling.StubBundleTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">protocolMatchesRealClass	&lt;test&gt;	#(#asStoreCIPundleSpec #asXMLElementForStoreCI #name #prerequisiteDescriptions #timestamp #version #containedItems #isBundle)		do: 			[:each |			self				assert: (StoreBundle canUnderstand: each)					description: 'StoreBundle doesn''t understand ' , each printString;				assert: (StubBundle canUnderstand: each)					description: 'StubBundle doesn''t understand ' , each printString]</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystemTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">convertsVersionRegexStringToRegex	&lt;test&gt;	system addTokens: #('-versionRegex' '\d+').	system runActivationActions.	self assert: (system versionMatcher isKindOf: RxMatcher)</body><body package="StoreCI-Polling-Tests">doesntRunIfNoPackages	&lt;test&gt;	system := self newSystem.	self setUpValidRepository.	self assertNotRun</body><body package="StoreCI-Polling-Tests">doesntRunIfNoRepository	&lt;test&gt;	system := self newSystem.	self setUpValidPackages.	self assertNotRun</body><body package="StoreCI-Polling-Tests">hasDefaultMinimumBlessingLevel	&lt;test&gt;	self assert: system minimumBlessingLevel				= Store.Policies blessingPolicy developmentBlessing</body><body package="StoreCI-Polling-Tests">looksUpBlessingName	&lt;test&gt;	system addTokens: #('-blessedAtLeast' 'Tested').	system runActivationActions.	self		assert: system minimumBlessingLevel = Store.Policies blessingPolicy testedBlessing</body><body package="StoreCI-Polling-Tests">raisesAnErrorWhenBlessingNotFound	&lt;test&gt;	self enableDebugging.	system addTokens: #('-blessedAtLeast' 'NoSuchBlessing').	self should: [system runActivationActions] raise: BlessingNotFound</body><body package="StoreCI-Polling-Tests">raisesAnErrorWhenRepositoryNotFound	&lt;test&gt;	system := self newSystem.	self enableDebugging.	system addTokens: #('-repository' 'No Such Repository').	self should: [system runActivationActions] raise: RepositoryNotFound</body><body package="StoreCI-Polling-Tests">raisesErrorOnImproperlyFormattedTimestamp	&lt;test&gt;	self enableDebugging.	system addTokens: #('-since' '06/31/2012 25:69:81.999').	self should: [system runActivationActions] raise: Error</body><body package="StoreCI-Polling-Tests">requiresChangelogFileForComputingChangelog	&lt;test&gt;	self enableDebugging.	system		addTokens: #('-since' '06/27/2012 09:58:42.654' '-now' '06/27/2012 10:30:03.123').	self should: [system runActivationActions]		raiseValidationErrorWithMessage: 'No -changelog option was specified'</body><body package="StoreCI-Polling-Tests">requiresCurrentTimeForComputingChangelog	&lt;test&gt;	self enableDebugging.	system		addTokens: #('-since' '06/27/2012 10:30:03.123' '-changelog' 'changelog.xml').	self should: [system runActivationActions]		raiseValidationErrorWithMessage: 'No -now option was specified'</body><body package="StoreCI-Polling-Tests">requiresLastBuildTimeForComputingChangelog	&lt;test&gt;	self enableDebugging.	system		addTokens: #('-now' '06/27/2012 10:30:03.123' '-changelog' 'changelog.xml').	self should: [system runActivationActions]		raiseValidationErrorWithMessage: 'No -since option was specified'</body><body package="StoreCI-Polling-Tests">setsDebugFlagBeforeProcessingOtherArguments	&lt;test&gt;	system addTokens: #('-blessedAtLeast' 'NoSuchBlessing' '-debug').	self should: [system runActivationActions] raise: BlessingNotFound</body><body package="StoreCI-Polling-Tests">takesListOfBundles	&lt;test&gt;	system := self newSystem.	system addTokens: #('-bundles' 'BundleA' 'BundleB' 'BundleC').	system runActivationActions.	self assertBundles: #('BundleA' 'BundleB' 'BundleC')</body><body package="StoreCI-Polling-Tests">takesListOfPackages	&lt;test&gt;	system := self newSystem.	system addTokens: #('-packages' 'PackageA' 'PackageB' 'PackageC').	system runActivationActions.	self assertPackages: #('PackageA' 'PackageB' 'PackageC')</body><body package="StoreCI-Polling-Tests">takesMixOfPackagesAndBundles	&lt;test&gt;	system := self newSystem.	system addTokens: #('-bundle' 'Bundle' '-package' 'Package').	system runActivationActions.	self assertPundles: (Array with: (PundleSpec forBundle: 'Bundle')				with: (PundleSpec forPackage: 'Package'))</body><body package="StoreCI-Polling-Tests">takesMultipleBundleOptions	&lt;test&gt;	system := self newSystem.	system		addTokens: #('-bundle' 'BundleA' '-bundle' 'BundleB' '-bundle' 'BundleC').	system runActivationActions.	self assertBundles: #('BundleA' 'BundleB' 'BundleC')</body><body package="StoreCI-Polling-Tests">takesMultiplePackageOptions	&lt;test&gt;	system := self newSystem.	system		addTokens: #('-package' 'PackageA' '-package' 'PackageB' '-package' 'PackageC').	system runActivationActions.	self assertPackages: #('PackageA' 'PackageB' 'PackageC')</body><body package="StoreCI-Polling-Tests">trapsArgumentValidationErrors	&lt;test&gt;	system addTokens: #('-blessedAtLeast' 'NoSuchBlessing').	system runActivationActions.	self		assert: errorStream contents notEmpty;		deny: system exitCode isZero</body><body package="StoreCI-Polling-Tests">writesChangelog	&lt;test&gt;	system		addTokens: #('-since' '06/27/2012 09:58:42.654' '-now' '06/27/2012 10:30:03.123' '-changelog' 'changelog.xml').	system runActivationActions.	self assert: system wroteChangelog</body><body package="StoreCI-Polling-Tests">writesRevisionState	&lt;test&gt;	system runActivationActions.	self assert: system wroteRevisionState</body></methods><methods><class-id>StoreCI.Polling.RepositoryNotFoundTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">hasCorrectErrorMessage	&lt;test&gt;	| expected |	expected := 'Could not find a repository named "No Such Repository"'.	[RepositoryNotFound raiseWith: 'No Such Repository']		on: RepositoryNotFound		do: [:ex | self assert: ex errorString = expected]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BuildingSubsystem</name><environment>StoreCI.Building</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetDirectory repository inputFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ParcelBuilder</category><attributes><package>StoreCI-Building</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>TestingSubsystem</name><environment>StoreCI.Testing</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputFile suiteBuilder suiteRunner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TestLogger</category><attributes><package>StoreCI-Testing</package></attributes></class><class><name>PollingSubsystem</name><environment>StoreCI.Polling</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootPundles versionMatcher minimumBlessingLevel repository parcelBuilderInputFile outputStream lastBuildTime currentTime changelogFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><class><name>TestResource</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>