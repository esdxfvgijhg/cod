<?xml version="1.0"?><st-source><!-- Name: ProgressModelNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This package encapsulates the calculations involved in efficiently updating a progress bar view to reduce code clutter in the application, while providing the ability to limit unnecessary graphical updates of a progress bar. DbIdentifier: bear73DbTrace: 55008PackageName: ProgressModelParcel: #('ProgressModel')ParcelName: ProgressModelPrintStringCache: (7.4.0.2,daves)Version: 7.4.0.2Date: 7:51:23 AM August 5, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 7:51:23 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ProgressModel</name><environment>Smalltalk</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aspectComplete aspectIncrement aspectInitialize count lastProgress maxCount minUpdateIncrement minUpdatePercentage model tempCount updateInSeparateProcess updatePolicy updateWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ProgressModel</category><attributes><package>ProgressModel</package></attributes></class><comment><class-id>ProgressModel</class-id><body>This class encapsulates the calculations involved in efficiently updating a progress bar view to reduce code clutter in the application, while providing the ability to limit unnecessary graphical updates of the progress bar. An instance is made a dependent of the object(s) that sends out raw progress updates for the progress operation. It responds to updates of up to three configurable aspects (aspectComplete, aspectIncrement, and aspectInitialize), and updates its model based on configurable threshold settings. Frequency of updates can be limited by setting either minUpdateIncrement, minUpdatePercentage, or both. For progress updates that are sent from a process other than the application's UI process, setting updateInSeparateProcess to true and updateWindow to the application's main window will ensure that updates are properly made in the appropriate process, via #uiEventFor:.Instance Variables:	aspectComplete	&lt;Object&gt;	Typically a Symbol, this is the aspect which represents that progress is complete.	aspectIncrement	&lt;Object&gt;	Typically a Symbol, this is the aspect which represents that some increment of progress was made.	aspectInitialize	&lt;Object&gt;	Typically a Symbol, this is the aspect which represents that progress is about to begin.	count	&lt;Integer&gt;	Sum of increments that have met or exceeded minUpdateIncrement.	lastProgress	&lt;SmallInteger&gt;	The value to which the progress model was previously set, used for determining whether minUpdatePercentage has been met.	maxCount	&lt;Integer&gt;	Total increments expected for current progress operation.	minUpdateIncrement	&lt;Integer&gt;	Minimum increment threshold for updating the progress model.	minUpdatePercentage	&lt;Number&gt;	Minimum progress threshold for updating the progress model.	model	&lt;ValueModel&gt;	The actual progress valueModel, which gets updated to make the progress bar move.	tempCount	&lt;Integer&gt;	Sum of increments that does not yet total the value of minUpdateIncrement.	updateInSeparateProcess	&lt;Boolean&gt;	Whether updates to the progress model should be made in a separate process.	updatePolicy	&lt;ByteSymbol&gt;	#smooth updates the progress model in response to aspectIncrement, aspectInitialize and aspectComplete, while #minimal updates only in response to aspectIncrement.	updateWindow	&lt;Window&gt;	The window to use as the argument to #uiEventFor:, when 'updateInSeparateProcess' is true.</body></comment><methods><class-id>ProgressModel</class-id> <category>accessing</category><body package="ProgressModel" selector="aspectComplete">aspectComplete	^aspectComplete</body><body package="ProgressModel" selector="aspectIncrement">aspectIncrement	^aspectIncrement</body><body package="ProgressModel" selector="aspectInitialize">aspectInitialize	^aspectInitialize</body><body package="ProgressModel" selector="count">count	^count isNil ifTrue: [count := 0] ifFalse: [count]</body><body package="ProgressModel" selector="lastProgress">lastProgress	^lastProgress isNil ifTrue: [lastProgress := 0] ifFalse: [lastProgress]</body><body package="ProgressModel" selector="maxCount">maxCount	^maxCount isNil ifTrue: [maxCount := 1] ifFalse: [maxCount]</body><body package="ProgressModel" selector="maxCount:">maxCount: anInteger 	maxCount := anInteger</body><body package="ProgressModel" selector="minUpdateIncrement">minUpdateIncrement	^minUpdateIncrement isNil 		ifTrue: [minUpdateIncrement := 1]		ifFalse: [minUpdateIncrement]</body><body package="ProgressModel" selector="minUpdatePercentage">minUpdatePercentage	^minUpdatePercentage isNil 		ifTrue: [minUpdatePercentage := 0.01]		ifFalse: [minUpdatePercentage]</body><body package="ProgressModel" selector="rawProgress">rawProgress	^self maxCount isZero 		ifTrue: [0]		ifFalse: [(self count + self tempCount) / self maxCount]</body><body package="ProgressModel" selector="tempCount">tempCount	^tempCount isNil ifTrue: [tempCount := 0] ifFalse: [tempCount]</body><body package="ProgressModel" selector="updateInSeparateProcess">updateInSeparateProcess	^updateInSeparateProcess isNil 		ifTrue: [updateInSeparateProcess := false]		ifFalse: [updateInSeparateProcess]</body><body package="ProgressModel" selector="updatePolicy">updatePolicy	^updatePolicy isNil 		ifTrue: [self setSmoothUpdatePolicy]		ifFalse: [updatePolicy]</body><body package="ProgressModel" selector="value:">value: aNumber 	| updateBlock |	updateBlock := [super value: aNumber].	self updateInSeparateProcess 		ifTrue: 			[updateWindow isNil 				ifTrue: [updateBlock uiEvent]				ifFalse: [updateBlock uiEventFor: updateWindow]]		ifFalse: updateBlock</body></methods><methods><class-id>ProgressModel</class-id> <category>initialize-release</category><body package="ProgressModel" selector="aspectComplete:">aspectComplete: anObject	aspectComplete := anObject</body><body package="ProgressModel" selector="aspectIncrement:">aspectIncrement: anObject	aspectIncrement := anObject</body><body package="ProgressModel" selector="aspectInitialize:">aspectInitialize: anObject	aspectInitialize := anObject</body><body package="ProgressModel" selector="forAspect:">forAspect: aSymbol 	self		aspectComplete: (aSymbol , 'Complete') asSymbol;		aspectIncrement: (aSymbol , 'Increment') asSymbol;		aspectInitialize: (aSymbol , 'Initialize') asSymbol</body><body package="ProgressModel" selector="forDefaultAspects">forDefaultAspects	self		aspectComplete: #complete;		aspectIncrement: #increment;		aspectInitialize: #initialize</body><body package="ProgressModel" selector="forkUpdatesFor:">forkUpdatesFor: aWindow 	self		updateInSeparateProcess: true;		updateWindow: aWindow</body><body package="ProgressModel" selector="setCount:">setCount: anInteger 	tempCount := 0.	count := anInteger</body><body package="ProgressModel" selector="updateInSeparateProcess:">updateInSeparateProcess: aBoolean	updateInSeparateProcess := aBoolean</body><body package="ProgressModel" selector="updateWindow:">updateWindow: aWindow	updateWindow := aWindow</body></methods><methods><class-id>ProgressModel</class-id> <category>tuning</category><body package="ProgressModel" selector="minUpdateIncrement:">minUpdateIncrement: anInteger	minUpdateIncrement := anInteger</body><body package="ProgressModel" selector="minUpdatePercentage:">minUpdatePercentage: aNumber 	"aNumber should be between 0.01 and 1, inclusive."	minUpdatePercentage := ((aNumber min: 1) max: 0.01) roundTo: 0.01</body><body package="ProgressModel" selector="setMinimalUpdatePolicy">setMinimalUpdatePolicy	^updatePolicy := #minimal</body><body package="ProgressModel" selector="setSmoothUpdatePolicy">setSmoothUpdatePolicy	^updatePolicy := #smooth</body></methods><methods><class-id>ProgressModel</class-id> <category>updating</category><body package="ProgressModel" selector="completeValue">completeValue	self setCount: self maxCount.	lastProgress := 1.	self updatePolicy == #smooth ifTrue: [self value: 1]</body><body package="ProgressModel" selector="flush">flush	"Show progress so far, ignoring increment and percentage limits."	| newProgress |	self setCount: self count + tempCount.	newProgress := self count / self maxCount truncateTo: 0.01.	self lastProgress &lt; newProgress ifFalse: [^self].	self value: newProgress.	lastProgress := newProgress</body><body package="ProgressModel" selector="incrementCountBy:">incrementCountBy: anInteger 	| newProgress |	tempCount := self tempCount + anInteger.	self minUpdateIncrement &lt;= tempCount ifFalse: [^self].	self setCount: self count + tempCount.	tempCount := 0.	newProgress := self count / self maxCount truncateTo: 0.01.	(self lastProgress &lt;= newProgress 		or: [self minUpdatePercentage &lt;= (newProgress - lastProgress)]) 			ifFalse: [^self].	self value: newProgress.	lastProgress := newProgress</body><body package="ProgressModel" selector="initializeValueWith:">initializeValueWith: anInteger 	self setCount: 0.	self maxCount: anInteger.	self updatePolicy == #minimal ifTrue: [^self].	self value: 0.	lastProgress := 0</body><body package="ProgressModel" selector="update:with:from:">update: anAspect with: aParameter from: anObject 	anAspect = self aspectIncrement 		ifTrue: [^self incrementCountBy: aParameter].	anAspect = self aspectInitialize 		ifTrue: [^self initializeValueWith: aParameter].	anAspect = self aspectComplete ifTrue: [^self completeValue]</body></methods><methods><class-id>ProgressModel</class-id> <category>inquiries</category><body package="ProgressModel" selector="totalCount">totalCount	^self count + self tempCount</body></methods><methods><class-id>ProgressModel class</class-id> <category>instance creation</category><body package="ProgressModel" selector="forAspect:">forAspect: aSymbol 	^(self new)		forAspect: aSymbol;		yourself</body><body package="ProgressModel" selector="forAspect:forkUpdatesFor:">forAspect: aSymbol forkUpdatesFor: aWindowOrNil 	^(self forAspect: aSymbol)		forkUpdatesFor: aWindowOrNil;		yourself</body><body package="ProgressModel" selector="forkUpdatesFor:">forkUpdatesFor: aWindowOrNil 	^(self new)		forkUpdatesFor: aWindowOrNil;		yourself</body><body package="ProgressModel" selector="new">new	"Answer a new instance initialized to zero. "	^super new setValue: 0</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class></st-source>