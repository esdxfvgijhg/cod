<?xml version="1.0"?><st-source><!-- Name: SocketServerNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: this package implements a simple example client/server setup using socketsPackageName: SocketServerParcel: #('SocketServer')ParcelName: SocketServerVersion: 7Date: 10:25:15 AM November 19, 2015 --><time-stamp>From VisualWorks®, 8.1 of July 17, 2015 on November 19, 2015 at 10:25:15 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>STServer</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listeningSocket port serverProcess isRunning serviceHandler </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>SocketServer</package></attributes></class><class><name>STClient</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket port host answer stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>SocketServer</package></attributes></class><class><name>STServiceHandler</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>SocketServer</package></attributes></class><class><name>ExampleHandler</name><environment>Smalltalk</environment><super>STServiceHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>SocketServer</package></attributes></class><methods><class-id>STServer</class-id> <category>private</category><body package="SocketServer">cleanup</body></methods><methods><class-id>STServer</class-id> <category>accessing</category><body package="SocketServer">defaultPriority^Processor userInterruptPriority - 2</body><body package="SocketServer">defaultServiceHandler	^ExampleHandler</body><body package="SocketServer">isRunning	^isRunning</body><body package="SocketServer">isRunning: aValue	isRunning := aValue</body><body package="SocketServer">listeningSocket	^listeningSocket</body><body package="SocketServer">listeningSocket: aValue	listeningSocket := aValue</body><body package="SocketServer">port	^port</body><body package="SocketServer">port: aValue	port := aValue</body><body package="SocketServer">serverProcess	^serverProcess</body><body package="SocketServer">serverProcess: aValue	serverProcess := aValue</body><body package="SocketServer">serviceHandler	^serviceHandler</body><body package="SocketServer">serviceHandler: aValue	serviceHandler := aValue</body></methods><methods><class-id>STServer</class-id> <category>server</category><body package="SocketServer">handleConnection: aSocket 	"fork off the service handler so that the listener doesn't tie up 	further processing"	[ 	[aSocket readWait.	self serviceHandler serve: aSocket]		valueOnUnwindDo: [aSocket close]] fork</body><body package="SocketServer">serverLoop"Server will continue to listen while socket is active.   When a connection is made, the ServiceHandler handles the connection"	[listeningSocket isActive]  		whileTrue: [self handleConnection: listeningSocket accept.					Processor activeProcess yield]</body></methods><methods><class-id>STServer</class-id> <category>initialize-release</category><body package="SocketServer">initialize	self port: self class defaultPort.	self isRunning: false.	self serviceHandler: self defaultServiceHandler new</body></methods><methods><class-id>STServer</class-id> <category>api</category><body package="SocketServer">shutdown	self listeningSocket close.	self listeningSocket: nil.	self isRunning: false.	Transcript show: 'STServer stopped on port: ', self port printString; cr</body><body package="SocketServer">start	self isRunning ifTrue: [^self].	Transcript show: 'Starting STServer on port: ' , self port printString; cr.	self listeningSocket: (SocketAccessor newTCPserverAtPort: self port).	listeningSocket listenFor: 5.	self isRunning: true.	self serverProcess: ([[self serverLoop]			valueOnUnwindDo: [self cleanup]]			forkAt: Processor userInterruptPriority)</body><body package="SocketServer">startOn: aPort	self port: aPort.	self start</body></methods><methods><class-id>STServer class</class-id> <category>accessing</category><body package="SocketServer">default	^default</body><body package="SocketServer">default: aValue	default := aValue</body></methods><methods><class-id>STServer class</class-id> <category>defaults</category><body package="SocketServer">defaultPort	^6008</body></methods><methods><class-id>STServer class</class-id> <category>api</category><body package="SocketServer">doStartup	| commandLine port |	commandLine := CEnvironment commandLine.	commandLine &lt; 3		ifTrue: [port := self defaultPort]		ifFalse: [port := (commandLine at: 3) asNumber max: self defaultPort].	self default: (self startOn: port)</body><body package="SocketServer">start	^self new start</body><body package="SocketServer">startOn: aPort	^self new startOn: aPort</body></methods><methods><class-id>STServer class</class-id> <category>instance creation</category><body package="SocketServer">new	^super new initialize</body></methods><methods><class-id>STServer class</class-id> <category>setup</category><body package="SocketServer">setup	ObjectMemory addDependent: self.</body></methods><methods><class-id>STServer class</class-id> <category>events</category><body package="SocketServer">update: anAspect with: aValue from: aModel	anAspect == #returnFromSnapshot		ifTrue: [self doStartup]</body></methods><methods><class-id>STClient</class-id> <category>accessing</category><body package="SocketServer">answer	^answer</body><body package="SocketServer">answer: aValue	answer := aValue</body><body package="SocketServer">host	^host</body><body package="SocketServer">host: aValue	host := aValue</body><body package="SocketServer">port	^port</body><body package="SocketServer">port: aValue	port := aValue</body><body package="SocketServer">socket	^socket</body><body package="SocketServer">socket: aValue	socket := aValue</body></methods><methods><class-id>STClient</class-id> <category>api</category><body package="SocketServer">close	stream close</body><body package="SocketServer">sendMessage: aMessage	stream nextPutAll: aMessage.	stream nextPut: $^.	self answer: (stream upTo: $^).</body><body package="SocketServer">setup	self socket: (SocketAccessor newTCPclientToHost: self host port: self port).	stream := self getSocketStream.</body></methods><methods><class-id>STClient</class-id> <category>private</category><body package="SocketServer">getSocketStream	| conn |	conn := ExternalConnection new				input: self socket;				output: self socket.	^conn readAppendStream.</body></methods><methods><class-id>STClient</class-id> <category>initialize-release</category><body package="SocketServer">sendMessage: aMessage to: aHost on: aPort	self host: aHost.	self port: aPort.	self socket: (SocketAccessor newTCPclientToHost: host port: self port).	stream := self getSocketStream.	stream nextPutAll: aMessage.	stream nextPut: $^.	self answer: (stream upTo: $^).	stream close</body></methods><methods><class-id>STClient class</class-id> <category>defaults</category><body package="SocketServer">defaultPort	^6008</body></methods><methods><class-id>STClient class</class-id> <category>examples</category><body package="SocketServer">exampleMessageToHost	"STClient exampleMessageToHost"	| answer client |	client := self sendMessage: 'This is a short message from the client'  to: 'victoria'.	answer := client answer.	Transcript show: 'Answer: &lt;', answer, '&gt;'; cr</body></methods><methods><class-id>STClient class</class-id> <category>instance creation</category><body package="SocketServer">sendMessage: aMessage to: host	^self new sendMessage: aMessage to: host on: self defaultPort</body><body package="SocketServer">sendMessage: aMessage to: host on: port	^self new sendMessage: aMessage to: host on: port</body><body package="SocketServer">setupOn: port forServer: server	| client |	client := self new		host: server;		port: port.	^client setup.</body></methods><methods><class-id>STServiceHandler</class-id> <category>required-api</category><body package="SocketServer">processInput: aStream	"subclasses must override this method in order to handle requests from	clients"	^self subclassResponsibility</body></methods><methods><class-id>STServiceHandler</class-id> <category>private-comms</category><body package="SocketServer">returnResults: reply on: stream	"default is to merely slap back the result of #processInput"	stream nextPutAll: reply.	stream commit</body><body package="SocketServer">setupStreamOn: aSocket	| connection stream |	connection := ExternalConnection new		input: aSocket;		output: aSocket.	stream := connection readAppendStream.	"Since the server and client might be on different	operating systems, choose a neutral line end convention."	stream lineEndTransparent.	^stream</body></methods><methods><class-id>STServiceHandler</class-id> <category>api</category><body package="SocketServer">serve: aSocket	| stream reply |	stream := self setupStreamOn: aSocket.	"yield so that other processes at this level can get a chance	at the processor"	Processor activeProcess yield.	reply := self processInput: stream.	self returnResults: reply on: stream</body></methods><methods><class-id>ExampleHandler</class-id> <category>required-api</category><body package="SocketServer">processInput: aStream	| reply |	reply := aStream upTo: $^.	"Transcript show: reply; cr."	^'Reply From Server^'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>