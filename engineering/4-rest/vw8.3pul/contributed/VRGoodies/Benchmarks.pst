<?xml version="1.0"?><st-source><!-- Name: BenchmarksNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains the benchmark suite and all the ancillary classes that define actual testsDevelopmentPrerequisites: #(#(#any 'VRUIPainter' '') #(#any 'DST_Core' '') #(#any 'DST_Repository' '') #(#any 'Opentalk-STST' '') #(#any 'Bench-Support' ''))PackageName: BenchmarksParcel: #('Benchmarks')ParcelName: BenchmarksPrerequisiteParcels: #(#('VRUIPainter' '') #('DST_Core' '') #('DST_Repository' '') #('Opentalk-STST' '') #('Bench-Support' 'Bench-Support'))Version: 7Date: 10:24:45 AM November 19, 2015 --><time-stamp>From VisualWorks®, 8.1 of July 17, 2015 on November 19, 2015 at 10:24:45 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DBIfc</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user pass env results connection session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><class><name>SimpleHanoi</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><comment><class-id>SimpleHanoi</class-id><body>SimpleHanoi Test for benchmarksInstance Variables:</body></comment><class><name>OtORBClient</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>emp server broker port oid type remoteServer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><class><name>ORBClient</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>emp server </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><class><name>SpeedTester</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sockServer dstServer logs isServer port server dbEnv otPort otOID otType otServer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><comment><class-id>SpeedTester</class-id><body>This is the basic interface to running tests using this suiteInstance Variables:</body></comment><class><name>BenchOptDialog</name><environment>Smalltalk</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socketHost socketPort dbEnvironment otPort otOID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><class><name>BenchmarkTestRunner</name><environment>Smalltalk</environment><super>UI.CommonApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testList tester </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><class><name>OtORBServer</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>port type broker myOID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><class><name>ORBServer</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Benchmarks</category><attributes><package>Benchmarks</package></attributes></class><methods><class-id>BenchOptDialog class</class-id> <category>interface specs</category><body package="Benchmarks">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 'Socket Options' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1280 1024 ) 			#bounds: #(#{Graphics.Rectangle} 621 324 971 704 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 28 ) 					#name: #socketPortLabel 					#label: 'Socket Port' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 116 ) 					#name: #socketHostLabel 					#label: 'Server Host' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 154 26 328 50 ) 					#name: #socketPort 					#model: #socketPort 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 154 114 328 138 ) 					#name: #socketHost 					#model: #socketHost ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 103 357 ) 					#name: #accept 					#model: #accept 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 204 ) 					#name: #Label1 					#label: 'DB Environment' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 154 202 328 226 ) 					#name: #dbEnvironment 					#model: #dbEnvironment ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 104 321 ) 					#name: #Label2 					#label: 'This will NOT reset DST.  Use the DST ' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 104 340 ) 					#name: #Label3 					#label: 'Console for that' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 72 ) 					#name: #Label4 					#label: 'Opentalk Port' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 154 70 328 94 ) 					#name: #InputField1 					#model: #otPort 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 160 ) 					#name: #Label5 					#label: 'Opentalk OID' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 154 158 328 182 ) 					#name: #InputField2 					#model: #otOID 					#type: #number ) ) ) )</body></methods><methods><class-id>BenchmarkTestRunner class</class-id> <category>resources</category><body package="Benchmarks">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Server Options...' 				#nameKey: #serverOptions 				#value: #serverOptions ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>BenchmarkTestRunner class</class-id> <category>interface specs</category><body package="Benchmarks">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Benchmark Test Runner' 			#bounds: #(#{Graphics.Rectangle} 640 512 1090 785 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00222222 0 0.846154 0 0.253333 0 1.00366 ) 					#name: #startServer 					#model: #startServer 					#helpText: 'Start Server Components' 					#label: 'Start Server' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.246667 0 0.846154 0 0.502222 0 1.00366 ) 					#name: #shutdownServer 					#flags: 40 					#model: #shutdownServer 					#helpText: 'Shutdown Server Components' 					#label: 'Shutdown Server' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.495556 0 0.846154 0 0.751111 0 1.00366 ) 					#name: #runTests 					#model: #runTests 					#helpText: 'Run the tests' 					#label: 'Run Tests' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00222222 0 0.040293 0 0.744444 0 0.831502 ) 					#name: #testList 					#model: #testList 					#helpText: 'Possible Tests' 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.744444 0 0.040293 0 1.0 0 0.197802 ) 					#name: #serverOptions 					#model: #serverOptions 					#helpText: 'Server Options' 					#label: 'Server Options...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.744444 0 0.190476 0 1.0 0 0.347985 ) 					#name: #ActionButton1 					#model: #selectAll 					#helpText: 'Select All Tests' 					#label: 'Select All' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.744444 0 0.351648 0 1.0 0 0.509157 ) 					#name: #startORBOnly 					#model: #startORBOnly 					#helpText: 'Start ORB' 					#label: 'Start ORB Only' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.744444 0 0.509157 0 1.0 0 0.666667 ) 					#name: #stopOrb 					#flags: 40 					#model: #stopOrb 					#helpText: 'Stop ORB' 					#label: 'Stop ORB Only' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>tool menu</category><body package="Benchmarks">openBenchmarkTool	&lt;menuItem: '&amp;VR Benchmark Tool'		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 10.035&gt;	BenchmarkTestRunner open</body></methods><methods><class-id>DBIfc</class-id> <category>db</category><body package="Benchmarks">cleanup	| answer |	self prepareSessionForCleanup.	self session execute.	answer := self session answer.	^answer</body><body package="Benchmarks">connect	self connection: OracleConnection new.	connection		username: self user;		password: self pass;		environment: self env.	self connection connect.</body><body package="Benchmarks">disconnect	self session disconnect.	self connection disconnect</body><body package="Benchmarks">executeInsert: emp	self session bindInput: emp.	self session execute.	^self session answer</body><body package="Benchmarks">executeQuery	| answer |	self session execute.	answer := self session answer.	^answer upToEnd</body><body package="Benchmarks">prepareSessionForCleanup	self session: self connection getSession.	self session prepare: 'delete from emp where empno &lt; 7000'.</body><body package="Benchmarks">prepareSessionForInsert	self session: self connection getSession.	self session prepare: 'INSERT INTO EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES (:empno, :ename, :job, :mgr, :hiredate, :sal, :comm, :deptno)'.</body><body package="Benchmarks">prepareSessionForQuery	self session: self connection getSession.	self session prepare: 'SELECT * FROM EMP'.	self session bindOutput: Emp new.</body></methods><methods><class-id>DBIfc</class-id> <category>accessing</category><body package="Benchmarks">connection	^connection</body><body package="Benchmarks">connection: aValue	connection := aValue</body><body package="Benchmarks">env	^env</body><body package="Benchmarks">env: aValue	env := aValue</body><body package="Benchmarks">pass	^pass</body><body package="Benchmarks">pass: aValue	pass := aValue</body><body package="Benchmarks">results	^results</body><body package="Benchmarks">results: aValue	results := aValue</body><body package="Benchmarks">session	^session</body><body package="Benchmarks">session: aValue	session := aValue</body><body package="Benchmarks">user	^user</body><body package="Benchmarks">user: aValue	user := aValue</body></methods><methods><class-id>DBIfc</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	self user: 'scott'.	self pass: 'tiger'.	self env: 'victoria'.</body></methods><methods><class-id>DBIfc class</class-id> <category>instance creation</category><body package="Benchmarks">new	^super new initialize</body></methods><methods><class-id>SimpleHanoi</class-id> <category>processing</category><body package="Benchmarks">hanoi        "SimpleHanoi new hanoi"        ^(Time millisecondsToRun:                [self move: 22 from: 1 to: 2 temp: 3]) / 1000.0</body><body package="Benchmarks">move: numberOfDisks from: source to: dest temp: temp        numberOfDisks == 1 ifTrue: [^self].        self                move: numberOfDisks-1 from: source to: temp temp: dest;                move: numberOfDisks-1 from: temp to: dest temp: source</body></methods><methods><class-id>OtORBClient</class-id> <category>accessing</category><body package="Benchmarks">broker	^broker</body><body package="Benchmarks">broker: aValue	broker := aValue</body><body package="Benchmarks">emp	^emp</body><body package="Benchmarks">emp: aValue	emp := aValue</body><body package="Benchmarks">oid	^oid</body><body package="Benchmarks">oid: aValue	oid := aValue</body><body package="Benchmarks">port	^port</body><body package="Benchmarks">port: aValue	port := aValue</body><body package="Benchmarks">remoteServer	^remoteServer</body><body package="Benchmarks">remoteServer: aValue	remoteServer := aValue</body><body package="Benchmarks">server	^server</body><body package="Benchmarks">server: aValue	server := aValue</body><body package="Benchmarks">tcp	^#newStstTcpAt:</body><body package="Benchmarks">type	^type</body><body package="Benchmarks">type: aValue	type := aValue</body><body package="Benchmarks">udp	^#newStstUdpAt:</body></methods><methods><class-id>OtORBClient</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	self port: 6009.	self server: 'victoria'.	self oid: 10011001.	self type: #tcp</body></methods><methods><class-id>OtORBClient</class-id> <category>start/stop</category><body package="Benchmarks">start	| message ip remote |	message := self perform: self type.	ip := IPSocketAddress thisHostAnyPort.	self broker: (Opentalk.RequestBroker perform: message with: ip).	self broker start.	remote := IPSocketAddress				hostName: self server				port: self port.	self remoteServer: (self broker remoteObjectOn: remote oid: self oid)</body><body package="Benchmarks">stop	self broker stop.	self remoteServer: nil</body></methods><methods><class-id>OtORBClient</class-id> <category>printing</category><body package="Benchmarks">printOn: stream	super printOn: stream.	stream nextPutAll: ' &lt;OT Bench Client&gt;'</body></methods><methods><class-id>OtORBClient</class-id> <category>api</category><body package="Benchmarks">sendEmployee	self remoteServer save: Employee example</body></methods><methods><class-id>OtORBClient class</class-id> <category>instance creation</category><body package="Benchmarks">new	^super new initialize</body></methods><methods><class-id>ORBClient</class-id> <category>accessing</category><body package="Benchmarks">emp	^emp</body><body package="Benchmarks">emp: aValue	emp := aValue</body><body package="Benchmarks">server	^server</body><body package="Benchmarks">server: aValue	server := aValue</body></methods><methods><class-id>ORBClient</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	| ns |	ns := ORBObject namingService.	self server: (ns contextResolve: 'bench_service' asDSTName).	self emp: Employee example.</body><body package="Benchmarks">release	self server: nil</body></methods><methods><class-id>ORBClient</class-id> <category>api</category><body package="Benchmarks">sendEmployee	self server save: self emp</body></methods><methods><class-id>ORBClient class</class-id> <category>instance creation</category><body package="Benchmarks">new	^super new initialize</body></methods><methods><class-id>SpeedTester</class-id> <category>tests</category><body package="Benchmarks">allocSpeedTest	"SpeedTester new allocSpeedTest"	| log |	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'Alloc Test'.	log testResult: (Time			millisecondsToRun: 				[100000 timesRepeat: [Array new: 10; new: 10; new: 10; new: 10; new: 10; new: 10; new: 10; new: 10; new: 10; new: 10].				ObjectMemory doOrFinishIncrementalGC]).	^log</body><body package="Benchmarks">arrayWriteSpeedTest	"SpeedTester new arrayWriteSpeedTest"	| array junk log |	junk := Object new.	array := Array new: 10.	log := BenchLogger new.	log testName: 'Array Write Test'.	log testResult: (Time millisecondsToRun: [1000000 timesRepeat: [array at: 1 put: junk; at: 2 put: junk; at: 3 put: junk; at: 4 put: junk; at: 5 put: junk; at: 6 put: junk; at: 7 put: junk; at: 8 put: junk; at: 9 put: junk; at: 10 put: junk]]).	^log</body><body package="Benchmarks">dbGetSpeedTest	"SpeedTester new dbGetSpeedTest"	| db log |	ObjectMemory doOrFinishIncrementalGC.	db := DBIfc new.	db env: self dbEnv.	db connect.	db prepareSessionForQuery.	log := BenchLogger new.	log testName: 'DB Get Test'.	log testResult: (Time		millisecondsToRun: 			[100 timesRepeat: [db executeQuery]]).	db disconnect.	^log.</body><body package="Benchmarks">dbInsertSpeedTest	"SpeedTester new dbInsertSpeedTest"	| db log |	ObjectMemory doOrFinishIncrementalGC.	db := DBIfc new.	db env: self dbEnv.	db connect.	db prepareSessionForInsert.	log := BenchLogger new.	log testName: 'DB Insert Test'.	log testResult: (Time millisecondsToRun: [100				timesRepeat: 					[| emp |					emp := Emp example.					db executeInsert: emp]]).	db cleanup.	db disconnect.	^log</body><body package="Benchmarks">dictionaryWriteSpeedTest	"SpeedTester new dictionaryWriteSpeedTest"	| dict junk key1 key2 key3 key4 key5 key6 key7 key8 key9 key10 log |	junk := Object new.	key1 := Object new.	key2 := Object new.	key3 := Object new.	key4 := Object new.	key5 := Object new.	key6 := Object new.	key7 := Object new.	key8 := Object new.	key9 := Object new.	key10 := Object new.	log := BenchLogger new.	log testName: 'Dictionary Write Test'.	log testResult: (Time millisecondsToRun: [10000				timesRepeat: 					[dict := IdentityDictionary new: 20.					dict at: key1 put: junk; at: key2 put: junk; at: key3 put: junk; at: key4 put: junk; at: key5 put: junk; at: key6 put: junk; at: key7 put: junk; at: key8 put: junk; at: key9 put: junk; at: key10 put: junk]]).	^log</body><body package="Benchmarks">dnuSpeedTest	"SpeedTester new dnuSpeedTest"	| log |	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'DNU Get Test'.	log testResult: (Time millisecondsToRun: [100000 timesRepeat: [SimpleProxy new acceptString]]).	^log</body><body package="Benchmarks">dstSpeedTest	"SpeedTester new dstSpeedTest"	| client log |	client := ORBClient new.	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'DST  Test'.	log testResult: (Time		millisecondsToRun: 			[1000 timesRepeat: [client sendEmployee]]).	^log</body><body package="Benchmarks">fixedPointMathSpeedTest	"SpeedTester new fixedPointMathSpeedTest"	| a b c d e log |	a := 87.0 asFixedPoint: 2.	b := 53.0 asFixedPoint: 2.	c := -87.0 asFixedPoint: 2.	d := 42461.0 asFixedPoint: 2.	e := 5.0 asFixedPoint: 2.	log := BenchLogger new.	log testName: 'Fixed Point Math Test'.	log testResult: (Time millisecondsToRun: [300000				timesRepeat: 					[e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d]]).	^log</body><body package="Benchmarks">floatMathSpeedTest	"SpeedTester new floatMathSpeedTest"	| a b c d e log |	a := 87.0.	b := 53.0.	c := -87.0.	d := 42461.0.	e := 5.0.	log := BenchLogger new.	log testName: 'Float Math Test'.	log testResult: (Time millisecondsToRun: [300000				timesRepeat: 					[e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d.					e := e * a + b * c + d]]).	^log</body><body package="Benchmarks">hanoiSpeedTest	| log |	log := BenchLogger new.	log testName: 'Hanoi Speed Test'.	log testResult: (Time millisecondsToRun: [SimpleHanoi new hanoi]).	^log</body><body package="Benchmarks">integerMathSpeedTest        "SpeedTester new integerMathSpeedTest"        | a b c d e log |        a := 87.        b := 53.        c := -87.        d := 42461.        e := 5.	log := BenchLogger new.	log testName: 'Integer Math Test'.	log testResult: (Time millisecondsToRun: [                300000 timesRepeat: [                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d.                        e := (e * a + b) * c + d]]).	^log</body><body package="Benchmarks">orderedCollectionIterateSpeedTest	"SpeedTester new orderedCollectionIterateSpeedTest"	| oc junk log |	junk := Object new.	oc := OrderedCollection new: 20.	oc add: junk; add: junk; add: junk; add: junk; add: junk; add: junk; add: junk; add: junk; add: junk; add: junk.	log := BenchLogger new.	log testName: 'Ordered Collection Iterate Test'.	log testResult: (Time millisecondsToRun: [100000				timesRepeat: 					[oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ].					oc do: [:element | ]]]).	^log</body><body package="Benchmarks">orderedCollectionWriteSpeedTest	"SpeedTester new orderedCollectionWriteSpeedTest"	| oc junk log |	junk := Object new.	log := BenchLogger new.	log testName: 'Ordered Collection Write Test'.	log testResult: (Time millisecondsToRun: [100000				timesRepeat: 					[oc := OrderedCollection new: 20.					oc addLast: junk; addLast: junk; addLast: junk; addLast: junk; addLast: junk; addLast: junk; addLast: junk; addLast: junk; addLast: junk; addLast: junk]]).	^log</body><body package="Benchmarks">otSpeedTest	"SpeedTester new otSpeedTest"	| client log |	client := OtORBClient new.	client server: self server.	client port: self otPort.	client type: self otType.	client oid: self otOID.	client start.	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'Opentalk  Test'.	log testResult: (Time		millisecondsToRun: 			[1000 timesRepeat: [client sendEmployee]]).	client stop.	^log</body><body package="Benchmarks">polymorphismSpeedTest	"SpeedTester new polymorphismSpeedTest"	| log list |	ObjectMemory doOrFinishIncrementalGC.	list := OrderedCollection new: 600.	100 timesRepeat: [list add: Instrument1 new].	100 timesRepeat: [list add: Instrument2 new].	100 timesRepeat: [list add: Instrument3 new].	100 timesRepeat: [list add: Instrument4 new].	100 timesRepeat: [list add: Instrument5 new].	log := BenchLogger new.	log testName: 'Polymorphism Speed Test'.	log testResult: (Time millisecondsToRun: [10000 timesRepeat: [list do: [:each | each value]]]).	^log</body><body package="Benchmarks">proxySpeedTest	"SpeedTester new proxySpeedTest"	| initial log |	initial := OrderedCollection new: 100.	100 timesRepeat: [initial add: 'test'].	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'Proxy Speed Test'.	log testResult: (Time millisecondsToRun: [100000 timesRepeat: [initial become: (OrderedCollection new: 1000)]]).	^log</body><body package="Benchmarks">socketSpeedTest	"SpeedTester new socketSpeedTest"	| message log |	message := 'this is the simple message from the client.  It is not too long, but long enough to involve a few bytes running across the wire'.	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'Socket Speed Test'.	log testResult: (Time millisecondsToRun: [1000 timesRepeat: [STClient sendMessage: message to: self server on: self port]]).	^log</body><body package="Benchmarks">streamReadSpeedTest	"SpeedTester new streamReadSpeedTest"	| stream long log |	long := 'This is the long string for insertion into the stream.  It will go in first, followed by a few cr''s, then a short string and some other stuff.  This is the long string for insertion into the stream.  It will go in first, followed by a few cr''s, then a short string and some other stuff.  This is the long string for insertion into the stream.  It will go in first, followed by a few cr''s, then a short string and some other stuff'.	stream := long readStream.	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'Stream Read Test'.	log testResult: (Time millisecondsToRun: [100000				timesRepeat: 					[stream upToAll: 'short'.					stream upTo: Character cr.					stream upToAll: 'short'.					stream upTo: Character cr.					stream upToEnd]]).	^log</body><body package="Benchmarks">streamWriteSpeedTest	"SpeedTester new streamWriteSpeedTest"	| stream long short log |	stream := WriteStream on: (String new: 100).	long := 'This is the long string for insertion into the stream.  It will go in first, followed by a few cr''s, then a short string and some other stuff.  This is the long string for insertion into the stream.  It will go in first, followed by a few cr''s, then a short string and some other stuff.  This is the long string for insertion into the stream.  It will go in first, followed by a few cr''s, then a short string and some other stuff'.	short := 'This is the short string'.	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'Stream Write Test'.	log testResult: (Time millisecondsToRun: [100000				timesRepeat: 					[stream nextPutAll: long.					stream cr; cr.					stream nextPutAll: short.					stream cr; cr.					stream reset]]).	^log</body><body package="Benchmarks">stringCompareSpeedTest	"SpeedTester new stringCompareSpeedTest"	| log |	log := BenchLogger new.	log testName: 'String Compare Test'.	log testResult: (Time millisecondsToRun: [100000				timesRepeat: 					['this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings'.					'this is a test of a string compare of two long strings' trueCompare: 'this is a test of a string compare of two long strings']]).	^log</body><body package="Benchmarks">uiOpenSpeedTest	"SpeedTester new uiOpenSpeedTest"	| log |	ObjectMemory doOrFinishIncrementalGC.	log := BenchLogger new.	log testName: 'UI Navigation Test'.	log testResult: (Time millisecondsToRun: [10				timesRepeat: 					[| bldr ctrlr |					bldr := UINavTester open.					ctrlr := (bldr componentAt: #ActionButton1) widget controller.					ctrlr simulateMousePress.					ctrlr := (bldr componentAt: #ActionButton2) widget controller.					ctrlr simulateMousePress.					ctrlr := (bldr componentAt: #ActionButton3) widget controller.					ctrlr simulateMousePress.					ctrlr := (bldr componentAt: #ActionButton4) widget controller.					ctrlr simulateMousePress.					bldr source closeRequest]]).	^log</body></methods><methods><class-id>SpeedTester</class-id> <category>api-tests</category><body package="Benchmarks">clearLog	self logs: List new</body><body package="Benchmarks">executeTests	Cursor wait showWhile: [	self logs: List new.	self logs add: self hanoiSpeedTest.	Transcript show: 'Did Hanoi Test...'; cr.	self logs add: self allocSpeedTest.	Transcript show: 'Did Alloc Speed Test...'; cr.	self logs add: self arrayWriteSpeedTest.	Transcript show: 'Did Array Write Speed Test...'; cr.	self logs add: self dictionaryWriteSpeedTest.	Transcript show: 'Did Dictionary Write Speed Test...'; cr.	self logs add: self floatMathSpeedTest.	Transcript show: 'Did Float Math Speed Test...'; cr.	self logs add: self integerMathSpeedTest.	Transcript show: 'Did Integer Math Speed Test...'; cr.	self logs add: self orderedCollectionIterateSpeedTest.		Transcript show: 'Did Ordered Collection Speed Test...'; cr.	self logs add: self orderedCollectionWriteSpeedTest.	Transcript show: 'Did OrderedCollection Write Speed Test...'; cr.	self logs add: self stringCompareSpeedTest.	Transcript show: 'Did String Compare Speed Test...'; cr.	self logs add: self proxySpeedTest.	Transcript show: 'Did Proxy Speed Test...'; cr.	self logs add: self socketSpeedTest.	Transcript show: 'Did Socket Speed Test...'; cr.	self logs add: self dnuSpeedTest.	Transcript show: 'Did DNU Speed Test...'; cr.	self logs add: self streamReadSpeedTest.	Transcript show: 'Did Stream Read Speed Test...'; cr.	self logs add: self streamWriteSpeedTest.	Transcript show: 'Did Stream Write Speed Test...'; cr.	self logs add: self dbGetSpeedTest.	Transcript show: 'Did db get Speed Test...'; cr.	self logs add: self dbInsertSpeedTest.	Transcript show: 'Did db insert Speed Test...'; cr.	self logs add: self dstSpeedTest.	Transcript show: 'Did DST Speed Test...'; cr.	self logs add: self uiOpenSpeedTest.	Transcript show: 'Did ui Open Speed Test...'; cr.	Transcript show: 'Done'; cr.].	^logs</body><body package="Benchmarks">report	(BenchLoggerTableForm on: self logs detailForm: #BenchLoggerForm) open</body><body package="Benchmarks">runTest: aTestName	"SpeedTester new runTests"	self logs add: ([self perform: aTestName]		on: MessageNotUnderstood		do: [:ex | Transcript show: 'bad test name: ', aTestName; cr.			ex proceed])</body><body package="Benchmarks">runTests	"SpeedTester new runTests"	self executeTests.	self report</body></methods><methods><class-id>SpeedTester</class-id> <category>accessing</category><body package="Benchmarks">dbEnv	^dbEnv</body><body package="Benchmarks">dbEnv: aValue	dbEnv := aValue</body><body package="Benchmarks">dstServer	^dstServer</body><body package="Benchmarks">dstServer: aValue	dstServer := aValue</body><body package="Benchmarks">isServer	isServer isNil		ifTrue: [isServer := false].	^isServer</body><body package="Benchmarks">isServer: aValue	isServer := aValue</body><body package="Benchmarks">logs	^logs</body><body package="Benchmarks">logs: aValue	logs := aValue</body><body package="Benchmarks">otOID	^otOID</body><body package="Benchmarks">otOID: aValue	otOID := aValue</body><body package="Benchmarks">otPort	^otPort</body><body package="Benchmarks">otPort: aValue	otPort := aValue</body><body package="Benchmarks">otServer	^otServer</body><body package="Benchmarks">otServer: aValue	otServer := aValue</body><body package="Benchmarks">otType	^otType</body><body package="Benchmarks">otType: aValue	otType := aValue</body><body package="Benchmarks">port	^port</body><body package="Benchmarks">port: aValue	port := aValue</body><body package="Benchmarks">server	^server</body><body package="Benchmarks">server: aValue	server := aValue</body><body package="Benchmarks">sockServer	^sockServer</body><body package="Benchmarks">sockServer: aValue	sockServer := aValue</body></methods><methods><class-id>SpeedTester</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	self logs: List new.	self port: 6008.	self server: 'victoria'.	self otType: #tcp.	self otPort: 6009.	self otOID: 10011001.	self isServer		ifTrue: [self setup]</body><body package="Benchmarks">release	self isServer		ifTrue: [self teardown]</body></methods><methods><class-id>SpeedTester</class-id> <category>setup</category><body package="Benchmarks">setup	" this should be run on the server in order to set up a socket server and 	DST server for those tests."	self sockServer: (STServer startOn: self port).	self dstServer: ORBServer new.	self otServer: 		(OtORBServer startOn: self otPort type: self otType oid: self otOID)</body><body package="Benchmarks">teardown	" this should be run on the server in order to clean up "	self sockServer shutdown.	self dstServer release.	self sockServer: nil.	self dstServer: nil.	self otServer stop.	self otServer: nil</body></methods><methods><class-id>SpeedTester class</class-id> <category>instance creation</category><body package="Benchmarks">new	^super new initialize</body><body package="Benchmarks">startClient	^self new</body><body package="Benchmarks">startServer	| inst |	inst := self basicNew.	inst isServer: true.	^inst initialize.</body></methods><methods><class-id>BenchOptDialog</class-id> <category>aspects</category><body package="Benchmarks">dbEnvironment	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dbEnvironment isNil		ifTrue:			[dbEnvironment := String new asValue]		ifFalse:			[dbEnvironment]</body><body package="Benchmarks">otOID	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^otOID isNil		ifTrue:			[otOID := 0 asValue]		ifFalse:			[otOID]</body><body package="Benchmarks">otPort	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^otPort isNil		ifTrue:			[otPort := 0 asValue]		ifFalse:			[otPort]</body><body package="Benchmarks">socketHost	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^socketHost isNil		ifTrue:			[socketHost := String new asValue]		ifFalse:			[socketHost]</body><body package="Benchmarks">socketPort	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^socketPort isNil		ifTrue:			[socketPort := 0 asValue]		ifFalse:			[socketPort]</body></methods><methods><class-id>BenchOptDialog</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	super initialize.	self socketPort value: 6008.	self otPort value: 6009.	self otOID value: 10011001.	self socketHost value: 'victoria'.	self dbEnvironment value: 'victoria'</body></methods><methods><class-id>BenchmarkTestRunner</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	| list |	super initialize.	list := self testList list.	list addAll: (SpeedTester organization listAtCategoryNamed: #tests).	self tester: SpeedTester new</body></methods><methods><class-id>BenchmarkTestRunner</class-id> <category>dst</category><body package="Benchmarks">initializeORB	| host node ar |	[host := SocketAccessor getHostname.	host := host copyFrom: 1 to: host size.	node := IPSocketAddress hostAddressByNameOrAddressString: host.	ar := Array with: host with: node]		on: Object errorSignal		do: [:ex | Transcript show: 'Could not get the hostname !'.			Transcript cr.			ex return].	ORBObject initializeORBAtHost: ar first nodeId: ar last.	ORBObject initializeFactories.	ORBObject initializeRepository.	ORBObject checkRepository.</body><body package="Benchmarks">startOrb	| started port enoughTries maxRetries config transportMgr coordinator |	config := ORBDaemon configurationManager.	coordinator := ORBDaemon startUpCoordinator.	transportMgr := config chosenTransports at: #IIOP.	started := false.	maxRetries := 5.	maxRetries isNil ifTrue: [maxRetries := 5].	enoughTries := 1.	port := transportMgr settingFor: #configuredPortNumber.		[(Delay forSeconds: 3) wait.	[started and: [enoughTries &lt;= maxRetries]]		whileFalse: 			[coordinator startRequestBroker.			coordinator state value == #started				ifTrue: [started := true]				ifFalse: 					[port := port + 1.					enoughTries := enoughTries + 1.					transportMgr settingFor: #configuredPortNumber put: port]].	coordinator state value == #stopped ifTrue: [Transcript show: 'Could not find an available port'; cr]]		forkAt: Processor userSchedulingPriority + 5</body><body package="Benchmarks">startORBOnly	"This stub method was generated by UIDefiner"	Cursor wait showWhile: [self startOrb.	self disable: #startServer.	self disable: #startORBOnly.	self enable: #stopOrb]</body><body package="Benchmarks">stopOrb	| coordinator |	Cursor wait showWhile: [coordinator := ORBDaemon startUpCoordinator.	coordinator shutDownRequestBroker.	self enable: #startORBOnly]</body></methods><methods><class-id>BenchmarkTestRunner</class-id> <category>actions</category><body package="Benchmarks">runTests	"This stub method was generated by UIDefiner"	| selections |	Cursor wait showWhile: [selections := self testList selections.	self tester clearLog.	selections do: [:each |		self tester runTest: each].	self tester report]</body><body package="Benchmarks">selectAll	"This stub method was generated by UIDefiner"	self testList selectAll</body><body package="Benchmarks">serverOptions	| dlg port server db otPort otOID |	dlg := BenchOptDialog new.	dlg open		ifTrue: [port := dlg socketPort value.				server := dlg socketHost value.				db := dlg dbEnvironment value.				otPort := dlg otPort value.				otOID := dlg otOID value].	self tester port: port.	self tester server: server.	self tester dbEnv: db.	self tester otPort: otPort.	self tester otOID: otOID</body><body package="Benchmarks">shutdownServer	"This stub method was generated by UIDefiner"	Cursor wait showWhile: [self tester teardown.	self stopOrb.	self enable: #startServer.	self disable: #shutdownServer.	self enable: #runTests.	self disable: #stopOrb]</body><body package="Benchmarks">startServer	"This stub method was generated by UIDefiner"	self tester isServer: true.	Cursor wait showWhile: [self initializeORB.	self startOrb.	self tester setup.	self disable: #startServer.	self enable: #shutdownServer.	self disable: #runTests.	self disable: #startORBOnly]</body></methods><methods><class-id>BenchmarkTestRunner</class-id> <category>accessing</category><body package="Benchmarks">tester	^tester</body><body package="Benchmarks">tester: aValue	tester := aValue</body></methods><methods><class-id>BenchmarkTestRunner</class-id> <category>aspects</category><body package="Benchmarks">testList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^testList isNil		ifTrue:			[testList := MultiSelectionInList new]		ifFalse:			[testList]</body></methods><methods><class-id>OtORBServer</class-id> <category>accessing</category><body package="Benchmarks">broker	^broker</body><body package="Benchmarks">broker: aValue	broker := aValue</body><body package="Benchmarks">myOID	^myOID</body><body package="Benchmarks">myOID: aValue	myOID := aValue</body><body package="Benchmarks">port	^port</body><body package="Benchmarks">port: aValue	port := aValue</body><body package="Benchmarks">tcp	^#newStstTcpAtPort:</body><body package="Benchmarks">type	^type</body><body package="Benchmarks">type: aValue	type := aValue</body><body package="Benchmarks">udp	^#newStstUdpAtPort:</body></methods><methods><class-id>OtORBServer</class-id> <category>start/stop</category><body package="Benchmarks">setAllowableAPI	| sels |	sels := self broker openSelectors asOrderedCollection.	sels add: #save:.	self broker openSelectors: sels</body><body package="Benchmarks">start	| message |	message := self perform: self type.	self broker: (Opentalk.RequestBroker perform: message with: self port).	self broker start.	self broker objectAdaptor export: self oid: self myOID.	self setAllowableAPI</body><body package="Benchmarks">stop	self broker stop</body></methods><methods><class-id>OtORBServer</class-id> <category>api</category><body package="Benchmarks">save: anEmployee	" as with the DST test, just answer a boolean "	^true</body><body package="Benchmarks">startOn: aPort type: aType oid: anOid	self port: aPort.	self type: aType.	self myOID: anOid.	self start</body></methods><methods><class-id>OtORBServer</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	self port: 6009.	self type: #tcp.	self myOID: 10011001</body></methods><methods><class-id>OtORBServer class</class-id> <category>instance creation</category><body package="Benchmarks">new	^super new initialize</body><body package="Benchmarks">startOn: port type: aType oid: oid	^self new		startOn: port 		type: aType 		oid: oid</body></methods><methods><class-id>ORBServer</class-id> <category>repository</category><body package="Benchmarks">abstractClassId	"return the abstract class Id of the receiver"	^'9d36e46e-8b8e-0000-0218-f9e987000000' asUUID</body><body package="Benchmarks">CORBAName	"return the name of my CORBA interface in the repository"	^#'::benchmarkModule::ORBServerInterface'</body></methods><methods><class-id>ORBServer</class-id> <category>initialize-release</category><body package="Benchmarks">initialize	| ns |	ns := ORBObject namingService.	ns contextReBind: 'bench_service' asDSTName to: self.</body><body package="Benchmarks">release	| ns |	ns := ORBObject namingService.	ns contextUnBind: 'bench_service' asDSTName</body></methods><methods><class-id>ORBServer</class-id> <category>api</category><body package="Benchmarks">save: employee	"just respond back - no real operation"		^true</body></methods><methods><class-id>ORBServer class</class-id> <category>instance creation</category><body package="Benchmarks">new	^super new initialize</body></methods><methods><class-id>DST.DSTRepository</class-id> <category>GENERATED</category><body package="Benchmarks">// benchmarkModule// This module defines the types and interfaces which form the benchmarkModule// protocol or service.// module benchmarkModule  {	// 	interface ORBServerInterface {		#pragma  class Employee Employee		struct  Employee {string name; long empNo; string address;  boolean citizen; };		// just respond back - no real operation		boolean save (in Employee employee);	};};</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CommonApplicationModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-Base</category><attributes><package>VRForms</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>DSTRepository</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Repository</category><attributes><package>DST_Repository</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>