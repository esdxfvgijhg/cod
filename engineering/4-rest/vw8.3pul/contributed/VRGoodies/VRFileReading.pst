<?xml version="1.0"?><st-source><!-- Name: VRFileReadingComment: This package contains a simple text file parser.  It is built to handle files that have fixed delimiters - commas and CRs, for instance, and a fixed structure - field separators and record separators.  The class to examine is VRFileReader.  You can supply 'type' information by placing a class side method  - #typeDef - into the class that you are parsing the file into.  Usage:VRFileReader read: 'someFile.txt' into: MyModel.The contents will be parsed into a collection of MyModel objects.  DbIdentifier: psql_public_cst_2007DbTrace: 66041PackageName: VRFileReadingParcel: #('VRFileReading')ParcelName: VRFileReadingPrintStringCache: (7.1,jamesr)Version: 7.1Date: 7:04:34 PM October 20, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (oct09.3) of October 16, 2009 on October 20, 2009 at 7:04:34 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>VRFileCleaner</name><environment>Core</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>characterToEliminate in out </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Generic-File-Reader</category><attributes><package>VRFileReading</package></attributes></class><comment><class-id>Core.VRFileCleaner</class-id><body>This object scans and 'cleans up' a file for processing by the tools in this package.  It can eliminate characters that should not remain.Instance Variables:	characterToEliminate	&lt;Character&gt;	 Character to be removed	in	&lt;String&gt;	 input file	out	&lt;String&gt; output file</body></comment><class><name>VRFileReader</name><environment>Core</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSeparator recordSeparator model modelCollection typeCollection defaultCategory dataModelDefiner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Generic-File-Reader</category><attributes><package>VRFileReading</package></attributes></class><comment><class-id>Core.VRFileReader</class-id><body>This is the heart of the file reading tools in this package.  It can read formatted files and return a collection of objects.  It assumes that such files are in field/record format, with some kind of character representing a field separator, and a different character representing record separator.  The default is for comma to separate fields, and CR to separate records.  Lines that start with a # are comments.Instance Variables:	fieldSeparator	&lt;Character&gt;	 attribute separator	recordSeparator	&lt;Character&gt;	 Object separator	model	&lt;Class&gt;	 kind of object to create	modelCollection	&lt;Collection&gt;	 The collection of objects created	typeCollection	&lt;Collection&gt;	 Types that can be decoded	defaultCategory	&lt;Symbol&gt;	If cannot guess, what kind of object to use	dataModelDefiner	&lt;VRDataModelDefiner&gt;	Can be used to build data models from files</body></comment><class><name>VRTypeConverter</name><environment>Core</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeConverterDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Generic-File-Reader</category><attributes><package>VRFileReading</package></attributes></class><comment><class-id>Core.VRTypeConverter</class-id><body>This class is coupled with the File Reader.  It is used to convert strings into the appropriate objectsInstance Variables:	typeConverterDict	&lt;Dictionary&gt; keys are object types, values are methods used for conversion</body></comment><class><name>IniFileReader</name><environment>Core</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Deployment</category><attributes><package>VRFileReading</package></attributes></class><comment><class-id>Core.IniFileReader</class-id><body>This class reads ini files (key=value files) similar to (but not exactly) the way such files are read in windows.  This class assumes that headings are the name of a class, and that keys will be the attributes of said class (with the values being their values).  If the same heading is met more than once, then the dictionary returned from this reader will have a collection of those objectsInstance Variables:	dictionary	&lt;Dictionary&gt;	 holds key/value pairs	source	&lt;String&gt;	 The file being read</body></comment><class><name>VRTypeGuesser</name><environment>Core</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types baseCollection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Generic-File-Reader</category><attributes><package>VRFileReading</package></attributes></class><comment><class-id>Core.VRTypeGuesser</class-id><body>This object is coupled with the file reader.  It is used to guess types based on hints in the fileInstance Variables:	types	&lt;Collection&gt;	 Collection of object types	baseCollection	&lt;Collection&gt;	 Collection of object types</body></comment><methods><class-id>Core.VRFileCleaner</class-id> <category>accessing</category><body package="VRFileReading" selector="characterToEliminate">characterToEliminate	^characterToEliminate</body><body package="VRFileReading" selector="characterToEliminate:">characterToEliminate: aValue	characterToEliminate := aValue</body><body package="VRFileReading" selector="in">in	^in</body><body package="VRFileReading" selector="in:">in: aValue	in := aValue</body><body package="VRFileReading" selector="out">out	^out</body><body package="VRFileReading" selector="out:">out: aValue	out := aValue</body></methods><methods><class-id>Core.VRFileCleaner</class-id> <category>processing</category><body package="VRFileReading" selector="transform">transform	|  stream  data outStream |	stream := self in contentsOfEntireFile readStream.	outStream := self out writeStream.	[stream atEnd]		whileFalse: [data := stream upTo: self characterToEliminate.					outStream nextPutAll: data].	outStream close.</body></methods><methods><class-id>Core.VRFileCleaner class</class-id> <category>As yet unclassified</category><body package="VRFileReading" selector="ridFile:of:to:">ridFile: inFile of: badChar to: outFile	| inst |	inst := self new.	inst characterToEliminate: badChar.	inst in: inFile asFilename.	inst out: outFile asFilename.	^inst transform</body></methods><methods><class-id>Core.VRFileReader</class-id> <category>accessing</category><body package="VRFileReading" selector="dataModelDefiner">dataModelDefiner	^dataModelDefiner</body><body package="VRFileReading" selector="dataModelDefiner:">dataModelDefiner: aValue	dataModelDefiner := aValue</body><body package="VRFileReading" selector="defaultCategory">defaultCategory	^defaultCategory</body><body package="VRFileReading" selector="defaultCategory:">defaultCategory: aValue	defaultCategory := aValue</body><body package="VRFileReading" selector="fieldSeparator">fieldSeparator	^fieldSeparator</body><body package="VRFileReading" selector="fieldSeparator:">fieldSeparator: aValue	fieldSeparator := aValue</body><body package="VRFileReading" selector="model">model	^model</body><body package="VRFileReading" selector="model:">model: aValue	model := aValue</body><body package="VRFileReading" selector="modelCollection">modelCollection	^modelCollection</body><body package="VRFileReading" selector="modelCollection:">modelCollection: aValue	modelCollection := aValue</body><body package="VRFileReading" selector="recordSeparator">recordSeparator	^recordSeparator</body><body package="VRFileReading" selector="recordSeparator:">recordSeparator: aValue	recordSeparator := aValue</body><body package="VRFileReading" selector="typeCollection">typeCollection	^typeCollection</body><body package="VRFileReading" selector="typeCollection:">typeCollection: aValue	typeCollection := aValue</body></methods><methods><class-id>Core.VRFileReader</class-id> <category>private</category><body package="VRFileReading" selector="guessTypes">guessTypes	"try to guess the types of the fields.  For this API, we are going to assume that the	collection holds arrays of strings.  Sets an internal type collection up"	| guesser |	guesser := VRTypeGuesser new.	self typeCollection: (guesser guessTypesFrom: (self modelCollection at: 1))</body><body package="VRFileReading" selector="prepCollection:from:">prepCollection: collectionObject from: aStream	"make sure collection is proper size"	| count | 	count := 0. 	[aStream atEnd] whileFalse: [ 		aStream upTo: self fieldSeparator.		count := count + 1].  	^collectionObject class new: count</body><body package="VRFileReading" selector="typeConvert:">typeConvert: aDomainObject	| converter typeArray start |	converter := VRTypeConverter new.	typeArray := aDomainObject class typeDef.	(aDomainObject class allInstVarNames includes: 'dependents')		ifTrue: [start := 2]		ifFalse: [start := 1].	typeArray do: [:each |		aDomainObject 			instVarAt: start 			put: (self doConversionOf: aDomainObject with: converter position: start with: each).		start := start +1]</body></methods><methods><class-id>Core.VRFileReader</class-id> <category>initialize-release</category><body package="VRFileReading" selector="initialize">initialize	self modelCollection: OrderedCollection new.	self recordSeparator: Character cr.	self fieldSeparator: $,.	self defaultCategory: 'New-DataModel'.</body></methods><methods><class-id>Core.VRFileReader</class-id> <category>converting</category><body package="VRFileReading" selector="doConversionOf:with:position:with:">doConversionOf: aDomainObject with: converter position: start with: aSymbol	"handle tossing of exceptions by keeping in current form"	Object errorSignal		handle: [:ex | 			^converter				convert: (aDomainObject instVarAt: start)				with: #String]		do: [^converter 				convert: (aDomainObject instVarAt: start) 				with: aSymbol].</body><body package="VRFileReading" selector="read:into:">read: aFile into: aModel	self model: aModel.	self readFile: aFile</body><body package="VRFileReading" selector="readFieldsFrom:into:">readFieldsFrom: iStream into: domainObject	| start |	(domainObject class allInstVarNames includes: 'dependents') 		ifTrue: [start := 2]		ifFalse: [start := 1].	[iStream atEnd] whileFalse: [ | nextRec |		nextRec := iStream upTo: self fieldSeparator.		domainObject isSequenceable			ifTrue: [domainObject at: start put: nextRec]			ifFalse: [domainObject instVarAt: start put: nextRec].		start := start + 1]</body><body package="VRFileReading" selector="readFile:">readFile: aFile	"read the file"	| fileStream |	[fileStream := aFile asFilename readStream.	[fileStream atEnd] whileFalse: [self readRecordFrom: fileStream]]		valueNowOrOnUnwindDo: [fileStream notNil ifTrue: [fileStream close]]</body><body package="VRFileReading" selector="readRecordFrom:">readRecordFrom: aStream	| domainObject iStream  |	iStream := (aStream upTo: self recordSeparator) readStream.	iStream peek = $# ifTrue: [^self].	domainObject := self model new.	domainObject isSequenceable		ifTrue: [domainObject := self prepCollection: domainObject from: iStream copy].	self modelCollection add: domainObject.	self readFieldsFrom: iStream into: domainObject.	(domainObject class respondsTo: #typeDef)		ifTrue: [self typeConvert: domainObject].</body></methods><methods><class-id>Core.VRFileReader class</class-id> <category>instance creation</category><body package="VRFileReading" selector="new">new	^super new initialize</body><body package="VRFileReading" selector="read:into:">read: aFile into: aModel	^self new read: aFile into: aModel</body></methods><methods><class-id>Core.VRTypeConverter</class-id> <category>converting</category><body package="VRFileReading" selector="convert:with:">convert: aString with: aSymbol	^self perform: (self typeConverterDict at: aSymbol ifAbsent: [#toString:]) with: aString</body><body package="VRFileReading" selector="toBoolean:">toBoolean: aString	| newString |	newString := aString asLowercase.	(newString includes: $t)		ifTrue: [^true]		ifFalse: [^false]</body><body package="VRFileReading" selector="toDate:">toDate: aString	^Date readFrom: aString readStream</body><body package="VRFileReading" selector="toDouble:">toDouble: aString	^aString asNumber asDouble</body><body package="VRFileReading" selector="toFixedPoint:">toFixedPoint: aString	^aString asNumber asFixedPoint: 2</body><body package="VRFileReading" selector="toFloat:">toFloat: aString	^aString asNumber asFloat</body><body package="VRFileReading" selector="toInteger:">toInteger: aString	^aString asNumber</body><body package="VRFileReading" selector="toPoint:">toPoint: aString	| stream x y |	stream := aString readStream.	x := (stream upTo: $@) asNumber.	y := stream upToEnd asNumber.	^x@y</body><body package="VRFileReading" selector="toString:">toString: aString	^aString</body><body package="VRFileReading" selector="toSymbol:">toSymbol: aString	^aString asSymbol</body><body package="VRFileReading" selector="toTime:">toTime: aString	^Time readFrom: aString readStream</body><body package="VRFileReading" selector="toTimestamp:">toTimestamp: aString	^Timestamp readFrom: aString readStream</body></methods><methods><class-id>Core.VRTypeConverter</class-id> <category>accessing</category><body package="VRFileReading" selector="typeConverterDict">typeConverterDict	^typeConverterDict</body><body package="VRFileReading" selector="typeConverterDict:">typeConverterDict: aValue	typeConverterDict := aValue</body></methods><methods><class-id>Core.VRTypeConverter</class-id> <category>initialize-release</category><body package="VRFileReading" selector="initialize">initialize	self typeConverterDict: IdentityDictionary new.	self typeConverterDict at: #String put: #toString:.	self typeConverterDict at: #Integer put: #toInteger:.	self typeConverterDict at: #Date put: #toDate:.	self typeConverterDict at: #Time put: #toTime:.	self typeConverterDict at: #Timestamp put: #toTimestamp:.	self typeConverterDict at: #Float put: #toFloat:.	self typeConverterDict at: #FixedPoint put: #toFixedPoint:.	self typeConverterDict at: #Double put: #toDouble:.	self typeConverterDict at: #Boolean put: #toBoolean:.	self typeConverterDict at: #Symbol put: #toSymbol:.	self typeConverterDict at: #Point put: #toPoint</body></methods><methods><class-id>Core.VRTypeConverter class</class-id> <category>instance creation</category><body package="VRFileReading" selector="new">new	^super new initialize</body></methods><methods><class-id>Core.IniFileReader</class-id> <category>accessing</category><body package="VRFileReading" selector="dictionary">dictionary	^dictionary</body><body package="VRFileReading" selector="dictionary:">dictionary: aValue	dictionary := aValue.	self changed: #dictionary with: aValue.</body><body package="VRFileReading" selector="source">source	^source</body><body package="VRFileReading" selector="source:">source: aValue	source := aValue.	self changed: #source with: aValue.</body></methods><methods><class-id>Core.IniFileReader</class-id> <category>reading</category><body package="VRFileReading" selector="addData:">addData: stream	"get key value pair from dictionary"	| key value |	key := (stream upTo: $=) asSymbol.	value := stream upTo: Character cr.	self dictionary at: key put: value</body><body package="VRFileReading" selector="processFile">processFile	"read the file, create dictionary"	| stream |	stream := self source asFilename readStream.	[[stream atEnd]		whileFalse: [self addData: stream]]			valueNowOrOnUnwindDo: [stream close].	^self dictionary</body></methods><methods><class-id>Core.IniFileReader</class-id> <category>initialized-release</category><body package="VRFileReading" selector="initialize">initialize	"set up initial dictionary"	self dictionary: IdentityDictionary new</body></methods><methods><class-id>Core.IniFileReader class</class-id> <category>instance creation</category><body package="VRFileReading" selector="new">new	^super new initialize</body><body package="VRFileReading" selector="on:">on: aFileString	"create on a particular file"	| inst |	inst := self new.	inst source: aFileString.	^inst processFile</body></methods><methods><class-id>Core.VRTypeGuesser</class-id> <category>accessing</category><body package="VRFileReading" selector="baseCollection">baseCollection	^baseCollection</body><body package="VRFileReading" selector="baseCollection:">baseCollection: aValue	baseCollection := aValue</body><body package="VRFileReading" selector="types">types	^types</body><body package="VRFileReading" selector="types:">types: aValue	types := aValue</body></methods><methods><class-id>Core.VRTypeGuesser</class-id> <category>converting</category><body package="VRFileReading" selector="guess">guess	"guess the types of the variables"	self baseCollection do: [:each | | type |		type := self guessTypeForField: each.		self types add: type]</body><body package="VRFileReading" selector="guessTypeForField:">guessTypeForField: aString	(self isFloat: aString) ifTrue: [^#Fixedpoint].	(self isInteger: aString) ifTrue: [^#Integer].	(self isBoolean: aString) ifTrue: [^#Boolean].	(self isDate: aString) ifTrue: [^#Date].	(self isTime: aString) ifTrue: [^#Time].	(self isTimestamp: aString) ifTrue: [^#Timestamp].	^#String</body><body package="VRFileReading" selector="guessTypesFrom:">guessTypesFrom: anArray	self baseCollection: anArray.	self guess.	^self types</body></methods><methods><class-id>Core.VRTypeGuesser</class-id> <category>testing</category><body package="VRFileReading" selector="isBoolean:">isBoolean: aString	"string is 'yes', 'y', 'n', 'no', 'true', 'false', 't', or 'f' "	(aString = 'yes') ifTrue: [^true].	(aString = 'y') ifTrue: [^true].	(aString = 'n') ifTrue: [^true].	(aString = 'no') ifTrue: [^true].	(aString = 'true') ifTrue: [^true].	(aString = 'false') ifTrue: [^true].	(aString = 't') ifTrue: [^true].	(aString = 'f') ifTrue: [^true].	^false</body><body package="VRFileReading" selector="isDate:">isDate: aString	| ans |	self class errorSignal		handle: [:ex | ans := false.				ex return]		do: [Date readFrom: aString readStream.			ans := true].	^ans</body><body package="VRFileReading" selector="isFloat:">isFloat: aString	| num |	num := aString asNumber.	^num class name == #Float</body><body package="VRFileReading" selector="isInteger:">isInteger: aString	| num |	num := aString asNumber.	num = 0		ifTrue: [(aString size &gt; 0)					ifTrue: [^false]					ifFalse: [^(aString size = 0) not]].	(self isDate: aString)		ifTrue: [^false].	(self isTime: aString)		ifTrue: [^false].	(self isTimestamp: aString)		ifTrue: [^false].	^true</body><body package="VRFileReading" selector="isTime:">isTime: aString	| ans | 	self class errorSignal		handle: [:ex | ans := false.				ex return]		do: [Time readFrom: aString readStream.			ans := true].	ans ifTrue:		[(aString includes: $:)			ifTrue: [ans := true]			ifFalse: [ans := false]].			^ans</body><body package="VRFileReading" selector="isTimestamp:">isTimestamp: aString	| ans |	self class errorSignal		handle: [:ex | ans := false.				ex return]		do: [Timestamp readFrom: aString readStream.			ans := true].	^ans</body></methods><methods><class-id>Core.VRTypeGuesser</class-id> <category>initialize-release</category><body package="VRFileReading" selector="initialize">initialize	self types: OrderedCollection new.</body></methods><methods><class-id>Core.VRTypeGuesser class</class-id> <category>instance creation</category><body package="VRFileReading" selector="new">new	^super new initialize</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>