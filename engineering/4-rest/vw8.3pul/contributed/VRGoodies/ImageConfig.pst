<?xml version="1.0"?><st-source><!-- Name: ImageConfigComment: This package adds a file parser for reading dictionary type files.  The structure should look like an ini file:[ClassName]id=1value='foo'The name in braces will be taken as a class name; fields below it are attributes.  Attributes in quotes will be parsed as strings; you can put in true or false and get booleans.  The DictionaryFileReader is a nice tool for parsing settings files.  It answers a Dictionary, where the keys are the class names, and the fields are collections of all the instances parsedPackageName: ImageConfigParcel: #('ImageConfig')ParcelName: ImageConfigVersion: 7Date: 10:27:21 AM November 19, 2015 --><time-stamp>From VisualWorksÂ®, 8.1 of July 17, 2015 on November 19, 2015 at 10:27:21 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DictionaryFileReader</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceFile dictionary isReadingSection currentObject evalNS </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DSTOrbConfig</category><attributes><package>ImageConfig</package></attributes></class><comment><class-id>DictionaryFileReader</class-id><body>This class implements a simple ini file reader.  It reads key/value pairs, and handles sections.  Section handling is different than in 'standard' windows.  If there are multiple sections named the same, a collection with all the sections will be created under that dictionary entry.  Underneath a single entry, the keys will be asumed to map to instance variable names, with the values mapping to their values.  The section titles will be assumed to be class names in the image.  A collection of instances of that class will be entered under that dictionary entry.Instance Variables:sourceFile	&lt;String&gt;	Name of the dictionary filedictionary	&lt;IdentityDictionary&gt; Dictionary of settings.  Keys will be symbolsConfig files should look like what is below.  The rules are as follows:-- anything that starts with a # is a comment line-- lines are CR delimited-- section titles will become symbols, and be mapped to the entries in the dictionary.  They will also be the names of the class to use as mappings for the section in question.-- lines are made up of key/value pairs, with an = between them (no white space)-- anything in quotes (single) will be seen as a string-- anything starting with a digit will be seen as a number-- anything starting with text will be resolved as a symbol, unless it is true --&gt; becomes Boolean truefalse --&gt; becomes Boolean false#System Settings[MySystemConfigurator]configFile='settings.ini'startup=trueport=9000The above settings would create a dictionary with one entry: #MySystemConfigurator.  Underneath that would be a collection with one element, and instance of MySystemConfigurator.  This instance would have the three named variables set as per the rules above.</body></comment><class><name>IniFileReader</name><environment>Smalltalk</environment><super>DictionaryFileReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DSTOrbConfig</category><attributes><package>ImageConfig</package></attributes></class><comment><class-id>IniFileReader</class-id><body>IniFileReader is a dumbed down version of the DictionaryFileReader. The DictionaryFileReader builds objects from a key-value pair stream where as the IniFileReader just builds a dictionary of dictionaries.(IniFileReader on: 'someinifile.ini') dictionary keys - returns the sections</body></comment><methods><class-id>DictionaryFileReader</class-id> <category>accessing</category><body package="ImageConfig">currentObject	^currentObject</body><body package="ImageConfig">currentObject: aValue	currentObject := aValue</body><body package="ImageConfig">dictionary	^dictionary</body><body package="ImageConfig">dictionary: aValue	dictionary := aValue</body><body package="ImageConfig">evalNS	^evalNS isNil		ifTrue: [evalNS := Smalltalk]		ifFalse: [evalNS]</body><body package="ImageConfig">evalNS: anObject	evalNS := anObject</body><body package="ImageConfig">isReadingSection	^isReadingSection</body><body package="ImageConfig">isReadingSection: aValue	isReadingSection := aValue</body><body package="ImageConfig">sourceFile	^sourceFile</body><body package="ImageConfig">sourceFile: aValue	sourceFile := aValue</body></methods><methods><class-id>DictionaryFileReader</class-id> <category>private</category><body package="ImageConfig">endSection	self isReadingSection: false</body><body package="ImageConfig">startNewObject: aString	| match key coll cls | 	cls := aString copyFrom: 2 to: aString size - 1.	match := self evalNS at: cls asSymbol.	key := cls asSymbol.	coll := self dictionary at: key ifAbsent: [| tmp |										tmp := OrderedCollection new.										self dictionary at: key put: tmp.										tmp].	self currentObject: match new.	coll add: self currentObject</body><body package="ImageConfig">startSection: aString	self isReadingSection: true.	self startNewObject: aString.</body><body package="ImageConfig">stuffObjectWithKey: instVarName andValue: aValue	| setter |	setter := (instVarName asString, ':') asSymbol.	self currentObject perform: setter with: aValue</body></methods><methods><class-id>DictionaryFileReader</class-id> <category>initialize-release</category><body package="ImageConfig">initialize	self isReadingSection: false.	self dictionary: IdentityDictionary new.</body></methods><methods><class-id>DictionaryFileReader</class-id> <category>parsing</category><body package="ImageConfig">figureOut: aString	aString isEmpty		ifTrue: [^nil].	aString first = $'		ifTrue: [^self getStringFrom: aString].	aString first isDigit		ifTrue: [^self getNumberFrom: aString].	aString first = $#		ifTrue: [^self getSymbolFrom: aString].	^self getSymbolOrBooleanFrom: aString</body><body package="ImageConfig">getNumberFrom: aString	^aString asNumber</body><body package="ImageConfig">getStringFrom: aString	| stream out |	stream := aString readStream.	out := WriteStream on: (String new).	stream skip: 1.	[stream atEnd]		whileFalse: [| next peek |			next := stream upTo: $'.			out nextPutAll: next.			stream atEnd				ifFalse: [peek := stream peek.						peek = $'							ifTrue: [stream skip: 1.									out nextPut: $']]].	^out contents</body><body package="ImageConfig">getSymbolFrom: aString	^(aString copyFrom: 2 to: aString size) asSymbol</body><body package="ImageConfig">getSymbolOrBooleanFrom: aString	aString asLowercase = 'nil'		ifTrue: [^nil].	aString asLowercase = 'true'		ifTrue: [^true].	aString asLowercase = 'false'		ifTrue: [^false].	^aString asSymbol</body><body package="ImageConfig">parseLine: aString	aString isEmpty ifFalse:[	(self isCommentLine: aString)		ifTrue: [^self].	(self isSectionHeader: aString)		ifTrue: [^self startSection: aString].	(self isSectionEnd: aString)		ifTrue: [^self endSection].	self processLine: aString]</body><body package="ImageConfig">parseStream: stream"	commented out 1/29/03 - caused problems.... ""	stream adoptContentsLineEndConvention. "	[stream atEnd]		whileFalse: [| line |					line := stream upTo: Character cr.					self parseLine: line]</body><body package="ImageConfig">processLine: aString	| stream key value actualValue |	stream := aString readStream.	key := (stream upTo: $=) asSymbol.	value := stream upToEnd.	actualValue := self figureOut: value.	self isReadingSection		ifTrue: [self stuffObjectWithKey: key andValue: actualValue]		ifFalse: [	self dictionary at: key put: actualValue]</body></methods><methods><class-id>DictionaryFileReader</class-id> <category>testing</category><body package="ImageConfig">isCommentLine: aString	^aString first = $#</body><body package="ImageConfig">isSectionEnd: aString	| answer |	(aString first = $[)		ifTrue: [| str |				str := aString copyFrom: 2 to: aString size - 1.				str asLowercase = 'end'					ifTrue: [answer := true]					ifFalse: [answer := false]]		ifFalse: [answer := false].	^answer</body><body package="ImageConfig">isSectionHeader: aString	| sectionName |	sectionName := (aString copyFrom: 2 to: aString size -1) asLowercase.	^(aString first = $[ and: [sectionName ~= 'end']).</body></methods><methods><class-id>DictionaryFileReader</class-id> <category>reading</category><body package="ImageConfig">parseToDictionary	| source stream |	source := self sourceFile asFilename.	source definitelyExists		ifFalse: [self error: 'No Config File'].	[stream := source readStream.		self parseStream: stream]		ensure: [stream notNil					ifTrue: [stream close]]</body><body package="ImageConfig">readFile: aFilename	self sourceFile: aFilename.	self dictionary: IdentityDictionary new.	self parseToDictionary</body></methods><methods><class-id>DictionaryFileReader class</class-id> <category>testing</category><body package="ImageConfig">doTest	"DictionaryFileReader doTest"	^self on: 'set_test.cfg'</body></methods><methods><class-id>DictionaryFileReader class</class-id> <category>instance creation</category><body package="ImageConfig">for: aNamespace	"evaluate section headers in aNamespace"	^self new evalNS: aNamespace</body><body package="ImageConfig">for: aNamespace on: aSourceFile	"evaluate section headers in aNamespace"	^(self new evalNS: aNamespace) readFile: aSourceFile</body><body package="ImageConfig">getSettingsFrom: file in: namespace forName: settingsName	"simple API to get the first entry"	^((self for: namespace on: file) dictionary at: settingsName) first</body><body package="ImageConfig">new	^super new initialize</body><body package="ImageConfig">on: aSourceFile	^self new readFile: aSourceFile</body></methods><methods><class-id>DictionaryFileReader class</class-id> <category>convenience</category><body package="ImageConfig">getConfigFileFromBase: aString	| dir |	dir := CEnvironment getenv: 'VWCONFIG'.	dir isEmpty		ifTrue: [dir := 'config' asFilename.				dir exists					ifFalse: [dir  := 'app' asFilename]].	dir := dir asFilename.	^(dir construct: aString) asString</body></methods><methods><class-id>IniFileReader</class-id> <category>parsing</category><body package="ImageConfig">processLine: aString	| stream key value |	stream := aString readStream.	key := (stream upTo: $=) trimBlanks.	value := stream upToEnd trimBlanks.	self currentObject at: key put: value</body></methods><methods><class-id>IniFileReader</class-id> <category>private</category><body package="ImageConfig">startNewObject: aString	| key | 	key := aString copyFrom: 2 to: aString size - 1.	self currentObject: (self dictionary at: key ifAbsentPut: [Dictionary new])</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>