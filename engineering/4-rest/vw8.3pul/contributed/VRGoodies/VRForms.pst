<?xml version="1.0"?><st-source><!-- Name: VRFormsNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains the VR UI Framework.  In particular, examine VRDetailForm, VRTableForm, VRListForm, and VRPagingForm.  These are the most useful classes for creating simple interfaces in a hurry.  The GUI Building extensions in VRUIPainter rely on these classes.  Also in this package are some Common dialog classes that were originally harvested out of Jigsaw.DevelopmentPrerequisites: #(#(#any 'VRUIPainterPreReq2' ''))PackageName: VRFormsParcel: #('VRForms')ParcelName: VRFormsPrerequisiteParcels: #(#('VRUIPainterPreReq2' ''))Version: 7Post-Load Block: 	[ :pkg |  VRTableViewer initialize]Date: 10:23:50 AM November 19, 2015 --><time-stamp>From VisualWorks®, 8.1 of July 17, 2015 on November 19, 2015 at 10:23:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CommonMessageDialog</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title button message iconStyle buttonStyle </inst-vars><class-inst-vars>buttonLabelList iconStyleList </class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.CommonMessageDialog</class-id><body>This class is a more sophisticated common 'Warning' dialog.  See the class side protocol for example usageInstance Variables:	title	&lt;String&gt;	 Window title	button	&lt;Number&gt;	Controls the number of buttons to use	message	&lt;String&gt;	 Prompter message	iconStyle	&lt;Symbol&gt;	Name of icon to use	buttonStyle	&lt;Symbol&gt;	Image (if any) to use on button(s)</body></comment><class><name>ExtendedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-Base</category><attributes><package>VRForms</package></attributes></class><comment><class-id>Core.ExtendedObject</class-id><body>This is a subclass of Object that will always have #initialize sentInstance Variables:</body></comment><class><name>CommonApplicationModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-Base</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.CommonApplicationModel</class-id><body>This class contains a wide variety of convenience protocol that makes it easier to do common UI actions such as enablement, disablement, etc.</body></comment><class><name>JARApplicationModel</name><environment>UI</environment><super>UI.CommonApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model trigger dialogBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-Base</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.JARApplicationModel</class-id><body>This is an ApplicationModel subclass that adds further convenience protocol for application UI's.  Specifically, it is oriented towards holding model and buffering behavior.Instance Variablesmodel &lt;Object&gt; The domain model for this UItrigger &lt;ValueModel&gt; presumed to be on a Boolean.  For use with BufferedValue ModeldialogBuilder &lt;Builder&gt; Holds the builder for dialog boxes that get opened</body></comment><class><name>ServiceApplicationModel</name><environment>UI</environment><super>UI.JARApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extChildren extOwner shouldPrint printStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-Base</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.ServiceApplicationModel</class-id><body>This class extends the VR Application framework.  It is an ApplicationModel subclass that adds-- parent/child application relationships-- a simple printing frameworkInstance VariablesextChildren &lt;Collection&gt; A collection of child applicationsextOwner &lt;Class&gt; The owner of the applicationshouldPrint &lt;Boolean&gt; If true, print to printer instead of fileprintStream &lt;Stream&gt; The stream to use for collecting text to be printed</body></comment><class><name>VRApplicationModel</name><environment>UI</environment><super>UI.ServiceApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry creationFlag shouldCache errorText enclosingFrameset selectorsEligibleFromHyperlinks customizationBlock customizationArgument </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-VRDB</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRApplicationModel</class-id><body>This class represents the bottom of the VR framework for ApplicationModels.  It adds a variety of features to make form based application development easier.  The registry was originally designed as an optimization for VisualWave caching; it has been (mostly) superceded by optimizations added to VisualWaveInstance Variablesregistry &lt;Dictionary&gt; Dictionary of application models and their namescreationFlag &lt;Symbol&gt; Used for keeping track of how the form was createdshouldCache &lt;Boolean&gt; If true, use registryerrorText  &lt;String&gt; A cache for error messagesenclosingFrameset &lt;Class&gt; Used by VR Wave add onselectorsEligibleFromHyperlinks &lt;Collection&gt; Used by VR Wave add oncustomizationBlock &lt;BlockClosure&gt; Used to customize embedded forms when loadingcustomizationArgument &lt;Object&gt; an argument to the customization block</body></comment><class><name>VRDBApplicationModel</name><environment>UI</environment><super>UI.VRApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-VRDB</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRDBApplicationModel</class-id><body>This class serves as the VR ApplicationModel to be used in ObjectLens GUI apps that do not use the standard forms interfaces.  See the instance side &lt;api&gt; protocol for example behaviorInstance VariablesdataModel &lt;LensDataModel&gt; The datamodel in use</body></comment><class><name>VRListForm</name><environment>UI</environment><super>UI.VRDBApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataList domainFormClass offList windowLabel printHeader isMultiSelect printType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Form-Deployment</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRListForm</class-id><body>This class is used to create 'standard' list forms, typically using the class side protocol which is common toVRListFormVRTableFormVRPagingFormIn order to use this class, the objects being displayed must be editable as instances of VRDetailForm.  Instance VariablesdataList &lt;List&gt; The collection of objects being displayeddomainFormClass &lt;Symbol&gt; The class to use for editing a selectionoffList &lt;Collection&gt; Collection of symbols of UI elements on this form to disablewindowLabel &lt;String&gt; Label for the windowprintHeader &lt;Boolean&gt; Unused - intended for use in simple printing frameworkisMultiSelect &lt;Boolean&gt; If true, list is multi-selectprintType &lt;Symbol&gt; Determines whether printing is normal or landscape</body></comment><class><name>TopDBVRApplicationModel</name><environment>UI</environment><super>UI.VRDBApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-VRDB</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.TopDBVRApplicationModel</class-id><body>This class adds guaranteed release behavior to the VR DB Framework.</body></comment><class><name>CommonListChooser</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title message multipleSelect list initialSelection printSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.CommonListChooser</class-id><body>This class is a common (cross platform) list picker.  See the class side protocol for example usageInstance Variablestitle &lt;String&gt; Title for the windowmessage &lt;String&gt; Prompter messagemultipleSelect &lt;Boolean&gt; If true, allow multi-selectlist &lt;Collection&gt; The list of objects to choose frominitialSelection &lt;Number&gt; Index of initial selectionprintSelector &lt;Symbol&gt; Unused</body></comment><class><name>ExtendedModel</name><environment>Core</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-Base</category><attributes><package>VRForms</package></attributes></class><comment><class-id>Core.ExtendedModel</class-id><body>This is a subclass of Model which will always have #initialize sentInstance Variables:</body></comment><class><name>CommonFileFilter</name><environment>UI</environment><super>Core.ExtendedModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.CommonFileFilter</class-id><body>This class holds filters used by the file dialog to filter current directory contentsInstance Variables:	filter	&lt;Association&gt;	 A filter used to filter contents	description	&lt;String&gt;	 name of filter (Word Doc, Parcel, etc)</body></comment><class><name>TableAdaptorForList</name><environment>UI</environment><super>UI.TableAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VR-Tables</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.TableAdaptorForList</class-id><body>This class adapts collections to tabular displays</body></comment><class><name>CommonDirectorySelectionDialog</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryName title volumeName volumeNames directoryNames subDirectoryName directoryMustExist openedDialog directoryLabel path partMoveBy rememberedPaths oldVolume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.CommonDirectorySelectionDialog</class-id><body>This class is the superclass for a common file dialog that works across platforms.  The sole subclass should actually be used.  This class handles directory accessInstance VariablesdirectoryName &lt;String&gt; Name of the current directorytitle &lt;String&gt;  Title for the windowvolumeName &lt;String&gt; Name of the current volume (Windows Specific)volumeNames &lt;Collection&gt; All volumes present on this system (Windows Specific)directoryNames &lt;Collection&gt; Recently visitedsubDirectoryName &lt;String&gt; Name of subdirectory visiteddirectoryMustExist &lt;Boolean&gt; If true, cannot create new directoriesopenedDialog &lt;Boolean&gt; If true, we are in dialog modedirectoryLabel &lt;String&gt; Name of directorypath &lt;String&gt; Current pathpartMoveBy rememberedPaths &lt;Collection&gt; Recently visited directoriesoldVolume &lt;String&gt; Last volume visited</body></comment><class><name>FormattingStream</name><environment>Core</environment><super>Core.TextStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width constants </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Deployment</category><attributes><package>VRForms</package></attributes></class><comment><class-id>Core.FormattingStream</class-id><body>This is a stream subclass that handles indentation style formats.  Instance Variableswidth &lt;Number&gt; amount to indent byconstants &lt;Dictionary&gt; UnusedShared VariablesDefaultWidth &lt;Number&gt; The default indentation amount</body></comment><class><name>VRTableCanvas</name><environment>UI</environment><super>UI.JARApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VR-Tables</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRTableCanvas</class-id><body>THis is the internal table holder used by VRTableViewer (which in turn is used by VRTableForm) to hide the complexity of VW TablesInstance Variablestable &lt;SelectionInTable&gt; The table object</body></comment><class><name>VRExceptionDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent errorDescription dataList modal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Development</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRExceptionDialog</class-id><body>This class may be used to report exceptional siuations in the VR Framework.  See the class side protocol for example usageInstance Variablesparent &lt;ApplicationModel&gt; Owning UIerrorDescription &lt;String&gt; String error descriptiondataList &lt;Collection&gt; Collection of multiple errorsmodal &lt;Boolean&gt; If true, show modal</body></comment><class><name>CommonPrompter</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message initialAnswer title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.CommonPrompter</class-id><body>This class represents a common (Cross Platform) prompter for input.  See the class side protocol for example usageInstance Variablesmessage &lt;String&gt; The prompter messageinitialAnswer &lt;String&gt; Default inputtitle &lt;String&gt; Window title</body></comment><class><name>VRPagingForm</name><environment>UI</environment><super>UI.VRDBApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataView newLabel constantData showCloseButton bindings windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-WebDB</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRPagingForm</class-id><body>This class is used to create 'standard' paging view forms, typically using the class side protocol which is common toVRListFormVRTableFormVRPagingFormIn order to use this class, the objects being displayed must be editable as instances of VRDetailForm.  modelSL (inherited from the superclass) holds the collection of objects to be displayedInstance VariablesdataView &lt;VRDetailForm&gt; The class to use for showing the current pagenewLabel &lt;String&gt; Label to use for windowconstantData &lt;Object&gt; An object to be used on each page.  See #changedViewshowCloseButton &lt;Boolean&gt; If true, display a close buttonbindings &lt;Dictionary&gt; Cache for builder bindingswindowLabel &lt;String&gt; Label for the windowprintHeader &lt;Boolean&gt; Unused - intended for use in simple printing frameworkisMultiSelect &lt;Boolean&gt; If true, list is multi-selectprintType &lt;Symbol&gt; Determines whether printing is normal or landscape</body></comment><class><name>ProcessWatcher</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>proc priority type message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Deployment</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.ProcessWatcher</class-id><body>This class may be used to monitor processes that the developer may wish to terminate later.  In particular, the VR Application framework uses this class to allow dialogs to control a forked processInstance Variables:	proc	&lt;Process&gt;	A Process being monitored	priority	&lt;Number&gt;	The priority of the monitored process	type	&lt;Symbol&gt;	Type of dialog to monitor with	message	&lt;String&gt;	 Prompt in dialog</body></comment><class><name>AbstractVRLoginForm</name><environment>UI</environment><super>UI.VRDBApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pass user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-VRDB</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.AbstractVRLoginForm</class-id><body>This class is an abstract login form.  It gathers username and passwordInstance Variablespass &lt;String&gt; The passworduser &lt;String&gt; The username</body></comment><class><name>CommonFileSelectionDialog</name><environment>UI</environment><super>UI.CommonDirectorySelectionDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filters filter fileNames fileName fileMustExist promptForOverwrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.CommonFileSelectionDialog</class-id><body>This is a cross platform file selection dialog.  See the class side protocol for example usage, including adding of filtersInstance Variablesfilters &lt;Collection&gt; Collection of all filters availablefilter &lt;CommonFileFilter&gt; The filter being usedfileNames &lt;Collection&gt; All files in the current directoryfileName &lt;String&gt; Selected file namefileMustExist  &lt;Boolean&gt; For file being entered - if true, it must exist alreadypromptForOverwrite &lt;Boolean&gt; If true, prompt user before saving to an existing file</body></comment><class><name>VRDetailForm</name><environment>UI</environment><super>UI.VRDBApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editMode parent owner windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Form-Deployment</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRDetailForm</class-id><body>This is the 'leaf class' for the VR ApplicationModel frameworkOther parts of the framework (in particular, VRListForm and VRPagingForm) assume that their embedded forms will be descended from this class.  Instance Variables:	editMode	&lt;Symbol&gt;	current editing mode; controls which buttons to be shown	parent	&lt;Class&gt;	 parent in child/parent apps	owner	&lt;Class&gt;	 Owner for Master/Slave relationships	windowLabel	&lt;String&gt;	 Window title</body></comment><class><name>VRLoginForm</name><environment>UI</environment><super>UI.AbstractVRLoginForm</super><private>false</private><indexed-type>none</indexed-type><inst-vars>usesTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Form-Deployment</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRLoginForm</class-id><body>This is a stock login form that can be used in the VR FrameworkInstance Variables:	usesTable	&lt;Boolean&gt;	If true, follow on form is tabular</body></comment><class><name>VRTableViewer</name><environment>UI</environment><super>UI.JARApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index dataList pageAmount tableSubCanvas aspects rowLabelsBlock columnLabels widths table fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VR-Tables</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRTableViewer</class-id><body>This class holds a table and associated 'common' controls for VRFormTable.  It can be used independently, but makes assumptions about being embeddedInstance Variablesindex  &lt;Number&gt; The index of the current (row) selectiondataList &lt;List&gt; The list of objects being displayedpageAmount &lt;Number&gt; How far to page tableSubCanvas &lt;VRTableCanvas&gt; The table itself being heldaspects &lt;Collection&gt; The sttributes of the object being wrappedrowLabelsBlock &lt;BlockClosure&gt; A block to alter row labels (if necessary) after pagingcolumnLabels &lt;Collection&gt; Collection of column labels to usewidths &lt;Collection&gt; How wide to make each columntable &lt;VRTableCanvas&gt; Same as tableSubCanvasfields &lt;Collection&gt; Same as aspects</body></comment><class><name>VRTableForm</name><environment>UI</environment><super>UI.VRDBApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>webTable windowLabel domainFormClass printHeader printType tableSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Form-Deployment</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.VRTableForm</class-id><body>This class is used to create 'standard' tabular view forms, typically using the class side protocol which is common toVRListFormVRTableFormVRPagingFormIn order to use this class, the objects being displayed must be editable as instances of VRDetailForm.  Instance Variablestable &lt;VRTableViewer&gt; holds the table and associated controls</body></comment><class><name>TopVRApplicationModel</name><environment>UI</environment><super>UI.VRApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Abstract-Models-VRDB</category><attributes><package>VRForms</package></attributes></class><comment><class-id>UI.TopVRApplicationModel</class-id><body>This class adds guaranteed release behavior to the VR Application Model framework</body></comment><shared-variable><name>DefaultTableLength</name><environment>UI.VRTableViewer</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>VRForms</package></attributes></shared-variable><methods><class-id>UI.CommonMessageDialog</class-id> <category>accessing</category><body package="VRForms">button	"return default button value"	^button</body><body package="VRForms">button: aButton	"Assign the default button to have focus.  Valid values are true, false and nil"	button := aButton</body><body package="VRForms">buttonStyle	"valid styles symbols are #ok, #okCancel, #yesNo, #yesNoCancel, #retryCancel, #abortRetryIgnore"	^buttonStyle</body><body package="VRForms">buttonStyle: aButtonStyle	"valid styles symbols are #ok, #okCancel, #yesNo, #yesNoCancel, #retryCancel, #abortRetryIgnore"	(self class escapeIsCancelList includes: aButtonStyle)		ifTrue: [self escapeIsCancel: true]		ifFalse: [self escapeIsCancel: false].	buttonStyle := aButtonStyle</body><body package="VRForms">criticalIcon	"Private"	^OpaqueImage		figure: self class criticalImage		shape: self class criticalMask</body><body package="VRForms">iconStyle	"Returns one of the following symbols: #information, #warning, #question, #critical"	^iconStyle</body><body package="VRForms">iconStyle: styleSymbol	"valid symbols are #information, #warning, #question, #critical"	iconStyle := styleSymbol.</body><body package="VRForms">informationIcon	"Private"	^OpaqueImage		figure: self class informationImage		shape: self class informationMask</body><body package="VRForms">message	"The string to be displayed within the message box"	^message</body><body package="VRForms">message: aString	"The string to be displayed within the message box"	message value: aString asString.</body><body package="VRForms">questionIcon	"Private"	^OpaqueImage		figure: self class questionImage		shape: self class questionMask</body><body package="VRForms">title	"Returns the text to be displayed on the dialog windows title bar"	^title</body><body package="VRForms">title: aString	"Assigns the text string to be displayed on the dialog windows title bar"	title := aString</body><body package="VRForms">warningIcon	"Private"	^OpaqueImage		figure: self class warningImage		shape: self class warningMask</body></methods><methods><class-id>UI.CommonMessageDialog</class-id> <category>initialize-release</category><body package="VRForms">initialize	"Private"	super initialize.	self title: ''.	message := '' asValue.	self button: 1.	self escapeIsCancel: false.	self iconStyle: #none</body></methods><methods><class-id>UI.CommonMessageDialog</class-id> <category>actions</category><body package="VRForms">open	"open method for MessageDialog, has new text placement"	| result spec valueList labelList layout textHeight textWidth 	windowWidth composedMessage defaultButton |	self buttonStyle isNil		ifTrue: [ labelList := self class buttonLabelList at: #ok ]		ifFalse: [ labelList := self class buttonLabelList at: self buttonStyle ].	valueList := self class buttonValueList at: labelList size.	( self button &gt; valueList size ) ifTrue: [ self button: 1 ].	defaultButton := valueList at: self button.	result := ValueHolder new.	spec := self class interfaceSpecFor: #windowSpec.	self allButOpenFrom:spec.	composedMessage := self message value asComposedText.	layout := ( self builder componentAt: #messageArea ) layout.	textWidth := composedMessage width + 20.	textWidth &gt; ( Screen default bounds width  / 2 )		ifTrue: [ textWidth := ( Screen default bounds right  / 2).			composedMessage compositionWidth: textWidth ].	textHeight :=composedMessage height + composedMessage lineGrid.	self setInitialGap.	self addGap: layout top + textHeight.	self addLabels: labelList		values: valueList		default: defaultButton		storeInto: result		takeKeyboard: true		equalize: true.	self addGap: 10.	windowWidth := textWidth + 20.	self iconStyle = #none		ifFalse: [ ( self builder componentAt: #iconLabel )			label: ( self perform: (self class iconStyleList at: self iconStyle ) ).			windowWidth := windowWidth + ( self builder componentAt: #iconLabel ) bounds right + 20.					( windowWidth &lt; self builder window displayBox extent x ) 						ifTrue: [ windowWidth := self builder window displayBox extent x.							layout left: ( self builder componentAt: #iconLabel ) bounds right + 20 ]						ifFalse:[ layout left: ( ( self builder componentAt: #iconLabel ) bounds right + 15 ) ] ]		ifTrue:[ ( windowWidth &lt; self builder window displayBox extent x ) 					ifTrue: [ windowWidth := self builder window displayBox extent x ].				layout left: 15 ].	layout right: layout left + textWidth.	layout bottom: layout top + textHeight.	( self builder componentAt: #messageArea ) layout: layout.	self builder window label: self title.	self builder openDialogWithExtent: windowWidth @ 		self builder window displayBox extent y.		cancel value		ifTrue:[ ^( valueList at: ( labelList indexOf: 'Cancel' ) ) ]		ifFalse:[ ^result value ]</body></methods><methods><class-id>UI.CommonMessageDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">buttonLabelList	"Private - Initialize a dictionary that associates a user supplied symbol with the label value"	buttonLabelList isNil		ifTrue:[			buttonLabelList := Dictionary new.			buttonLabelList at: #ok put: #('OK');				at: #okCancel put: #('OK' 'Cancel');				at: #yesNo put: #('Yes' 'No');				at: #retryCancel put: #('Retry' 'Cancel');				at: #yesNoCancel put: #('Yes' 'No' 'Cancel');				at: #abortRetryIgnore put: #('Abort' 'Retry' 'Ignore')].		^buttonLabelList</body><body package="VRForms">buttonValueList	"Private - list of possible return values for button action"	^#(#(true) #(true false) #(true false nil)).</body><body package="VRForms">escapeIsCancelList	"Private - A list of button styles which equates the escape key with cancel"	^#(#yesNoCancel #okCancel #retryCancel)</body><body package="VRForms">iconStyleList	"Private - Initialize a dictionary that associates a icon symbol to the method which returns the image"	iconStyleList isNil		ifTrue:[			iconStyleList := Dictionary new.			iconStyleList at: #information put: #informationIcon;				at: #critical put: #criticalIcon;				at: #warning put: #warningIcon;				at: #question put: #questionIcon].		^iconStyleList</body><body package="VRForms">initialize	"CommonMessageDialog initialize"	self buttonLabelList.	self buttonValueList.	self iconStyleList</body><body package="VRForms">open: iconSymbol message: aMessageString title: aTitleString	| inst |	inst := self new.	inst message: aMessageString.	inst iconStyle: iconSymbol.	^inst open</body><body package="VRForms">openCritical: aMessage	^self 		open: #critical		message: aMessage		title: 'Critical Warning !'</body><body package="VRForms">openInformation: aMessage	^self 		open: #information		message: aMessage		title: 'Information'</body><body package="VRForms">openQuestion: aMessage	^self 		open: #question		message: aMessage		title: 'Question'</body><body package="VRForms">openWarning: aMessage	^self 		open: #warning		message: aMessage		title: 'Warning !'</body></methods><methods><class-id>Core.ExtendedObject</class-id> <category>printing</category><body package="VRForms">getPrintStream	"answer the stream appropriate for this object"</body><body package="VRForms">printString: aString onStream: aStream withWidth: aWidth	"print the string to the given width in chars"	| pads |	pads := aWidth - aString size.	pads &gt; 0		ifTrue: [aStream nextPutAll: aString.				pads timesRepeat: [aStream nextPut: Character space]].	pads &lt;= 0		ifTrue: [aStream nextPutAll: aString]</body></methods><methods><class-id>Core.ExtendedObject</class-id> <category>initialize-release</category><body package="VRForms">initialize	"stub for initialize behaviors"</body><body package="VRForms">release	"stub for release behaviors - by default, release dependencies"	self myDependents isNil		ifTrue: [ ^self ].	self myDependents do: [:each | self removeDependent: each].	super release</body></methods><methods><class-id>Core.ExtendedObject</class-id> <category>As yet unclassified</category><body package="VRForms">save	"prepare a copy of this object that breaks all dependencies"	| copy |	copy := self copy breakDependents.	copy storePersistently</body><body package="VRForms">storePersistently	"do the right thng for this object"	^self subclassResponsibility</body></methods><methods><class-id>Core.ExtendedObject class</class-id> <category>As yet unclassified</category><body package="VRForms">new	"return a new initialized instance"	^super new initialize</body></methods><methods><class-id>UI.CommonApplicationModel</class-id> <category>convenience</category><body package="VRForms">adapt: anObject using: aSymbol	"assumes you want updates"	^(AspectAdaptor subjectChannel: anObject					sendsUpdates: true)		forAspect: aSymbol</body><body package="VRForms">aspectAdaptorFor: anAspect 	^(AspectAdaptor subjectChannel: self model sendsUpdates: true)		forAspect: anAspect</body><body package="VRForms">autoAccept: aSymbol	"turn on auto accept"	(self controller: aSymbol) continuousAccept: true</body><body package="VRForms">autoAcceptAll: anArray	"turn on auto accept"	anArray do: [:each | self autoAccept: each]</body><body package="VRForms">autoAcceptOff: aSymbol	"turn on auto accept"	(self controller: aSymbol) continuousAccept: false</body><body package="VRForms">backgroundAll: anArray to: aColorValue 	"change the background colors"	anArray do: [:widgetSymbol | self backgroundColor: widgetSymbol to: aColorValue]</body><body package="VRForms">backgroundColor: aSymbol to: aColorValue 	"set the color"	| lookPref comp |	comp := self component: aSymbol.	lookPref := comp lookPreferences backgroundColor: aColorValue.	comp lookPreferences: lookPref</body><body package="VRForms">beInvisible: aSymbol 	"invisible the widget"	(self component: aSymbol) beInvisible</body><body package="VRForms">beInvisibleAll: anArray 	"beInvisible the object(s)"	anArray do: [:widgetSymbol | self beInvisible: widgetSymbol]</body><body package="VRForms">beVisible: aSymbol 	"invisible the widget"	(self component: aSymbol) beVisible</body><body package="VRForms">beVisibleAll: anArray 	"make all visible"	anArray do: [:widgetSymbol | self beVisible: widgetSymbol]</body><body package="VRForms">bufferedValueHolderOn: aModel 	^BufferedValueHolder subject: aModel triggerChannel: self trigger</body><body package="VRForms">bufferedValueModelIds	"By default, the application does no buffering of data. Subclasses may wish to override this by 	returning an array of widget ids that are buffering user input."	^#()</body><body package="VRForms">bufferForAspect: aSymbol trigger: aValueModel	"assumes you get updates"	^BufferedValueHolder 		subject: 			((AspectAdaptor subjectChannel: self model						sendsUpdates: true)				forAspect: aSymbol)		triggerChannel: aValueModel</body><body package="VRForms">bufferNoUpdateForAspect: aSymbol trigger: aValueModel	"assumes you don't get updates"	^BufferedValueHolder 		subject: 			((AspectAdaptor subjectChannel: self model						sendsUpdates: false)				forAspect: aSymbol)		triggerChannel: aValueModel</body><body package="VRForms">bvhWithAspectAdaptorForAspect: anAspect 	self bufferedValueHolderOn: (self aspectAdaptorFor: anAspect)</body><body package="VRForms">changeListFont: aSymbol	"Change the font of a listView object"	| fontName  |	fontName := (Smalltalk at:#FontDialog) selectFont.	fontName notNil	ifTrue: [self changeListFont: aSymbol to: fontName]</body><body package="VRForms">changeListFont: aSymbol to: aFontName	"Change the font of a listView object"	| listView |	listView := (self builder componentAt: aSymbol) widget.	listView textStyle: (TextAttributes styleNamed: aFontName)</body><body package="VRForms">component: aSymbol 	"return the wrapper"	^self builder componentAt: aSymbol</body><body package="VRForms">controller: aSymbol 	"return the controller of the widget"	^(self widget: aSymbol) controller</body><body package="VRForms">disable: aSymbol 	"disable the widget"	(self component: aSymbol) disable</body><body package="VRForms">disableAll: anArray 	"disable the object(s)"	anArray do: [:widgetSymbol | self disable: widgetSymbol]</body><body package="VRForms">doFileOpen: aFileString	"subclass responsibility"	^self subclassResponsibility</body><body package="VRForms">doFileSave: aFileString	"subclass responsibility"	^self subclassResponsibility</body><body package="VRForms">enable: aSymbol 	"enable the widget"	(self component: aSymbol) enable</body><body package="VRForms">enableAll: anArray 	"enable the object(s)"	anArray do: [:widgetSymbol | self enable: widgetSymbol]</body><body package="VRForms">foregroundAll: anArray to: aColorValue 	"change the foreground colors"	anArray do: [:widgetSymbol | self foregroundColor: widgetSymbol to: aColorValue]</body><body package="VRForms">foregroundColor: aSymbol to: aColorValue 	"set the color"	| lookPref comp |	comp := self component: aSymbol.	lookPref := comp lookPreferences foregroundColor: aColorValue.	comp lookPreferences: lookPref</body><body package="VRForms">hide: aSymbol 	"disable, make invisible the widget"	self disable: aSymbol.	self beInvisible: aSymbol</body><body package="VRForms">hideAll: anArray 	"hide the object(s)"	anArray do: [:widgetSymbol | self hide: widgetSymbol]</body><body package="VRForms">inputLimit: aSymbol 	"return the input limit"	^(self component: aSymbol) spec numChars</body><body package="VRForms">isScrollingCharacter: event	"answer true if character is arrow key or paging key."	| included |	included := #(#Right #Left #Up #Down #PageUp #PageDown #Home #End).	^(included includes: event keyValue)</body><body package="VRForms">isValueModel: aModel	^aModel respondsTo: #value</body><body package="VRForms">keyboardHook	"Return the main keyboard hook."	^self keyboardProcessor keyboardHook</body><body package="VRForms">keyboardHook: aBlock 	"install a new keyboard hook, return the old one"	| oldHook |	oldHook := self keyboardHook.	self keyboardProcessor keyboardHook: aBlock.	^oldHook</body><body package="VRForms">keyboardProcessor	"Return the keyboard processor of the window."	^self builder keyboardProcessor</body><body package="VRForms">label: aSymbol	"answer the current label as a string"	| widget |	widget := self widget: aSymbol.	^widget label text string</body><body package="VRForms">label: aSymbol with: aComposedText	"label a widget - assume input is ready"	| widget |	widget := self widget: aSymbol.	widget label: aComposedText</body><body package="VRForms">label: aSymbol withImage: anImage 	"label a widget - assume an image"	| widget |	widget := self widget: aSymbol.	widget label: anImage</body><body package="VRForms">label: aSymbol withString: aString 	"label a widget - assume all bold - if multiline, auto expands"	| widget text |	text := aString asText allBold asComposedText.	widget := self widget: aSymbol.	widget label: text</body><body package="VRForms">labelAll: anArray withImage: anImage 	"label all with same image"	anArray do: [:each | self label: each withImage: anImage]</body><body package="VRForms">labelAll: anArray withString: anImage 	"label all with same string"	anArray do: [:each | self label: each withString: anImage]</body><body package="VRForms">labelWidget: aSymbol withImage: anImage	"label a widget - assume an image"	| widget  |	widget := self widget: aSymbol.	widget label: anImage</body><body package="VRForms">labelWidget: aSymbol withString: aString	"label a widget - assume all bold - if multiline, auto expands"	| widget text |	text := aString asText allBold asComposedText.	widget := self widget: aSymbol.	widget label: text</body><body package="VRForms">modelFor: widgetId 	| foundWrapper |	^(foundWrapper := self component: widgetId) notNil		ifTrue: [foundWrapper widget model]		ifFalse: [nil]</body><body package="VRForms">modelForAspect: aSymbol	"assumes you want updates"	^(AspectAdaptor subjectChannel: self model					sendsUpdates: true)		forAspect: aSymbol</body><body package="VRForms">modelNoUpdateForAspect: aSymbol	"assumes you don't get updates"	^(AspectAdaptor subjectChannel: self model					sendsUpdates: false)		forAspect: aSymbol</body><body package="VRForms">modelValue	(self isValueModel: self model)		ifTrue: [^self model value]		ifFalse: [^self model]</body><body package="VRForms">move: aSymbol by: anOffset 	"move widget by an offset"	(self component: aSymbol)		moveBy: anOffset</body><body package="VRForms">move: aSymbol to: aPoint 	"move widget to a point"	(self component: aSymbol)		moveTo: aPoint</body><body package="VRForms">moveAll: anArray by: aPoint 	"offset all the object(s)"	anArray do: [:widgetSymbol | self moveAll: widgetSymbol by: aPoint]</body><body package="VRForms">openAt: aPoint with: aSymbol in: aRectangle 	"open the interface at a particular location - assume a main window"	self openAt: aPoint with: aSymbol in: aRectangle ofType: #normal</body><body package="VRForms">openAt: aPoint with: aSymbol in: aRectangle ofType: aType	"open the interface at a particular location"	| bldr aRect |	"use passed in rectangle, or min window size"	bldr := self allButOpenInterface: aSymbol.	aRectangle isNil		ifTrue: 			[| min |			min := bldr window minimumSize.			aRect := Rectangle origin: aPoint corner: aPoint x + min x @ (aPoint y + min y)]		ifFalse: [aRect := aRectangle].		"give user an option to intervene; perhaps to scale the rectangle"	aRect := self scaleRect: aRect.	self  finallyOpenIn: aRect withType: aType.</body><body package="VRForms">registerModel: aClass 	"register self with domain."	self registerModel: aClass asDependent: true</body><body package="VRForms">registerModel: aClass asDependent: aBoolean 	"register self with domain. "	self model value: aClass new.	aBoolean ifTrue: [self model value addDependent: self]</body><body package="VRForms">replaceControllerOf: aSymbol with: aController 	"Replace the controller for widget belonging to the componnet whose id is aSymbol with 	aController. Make sure the new controller has the old controller's menu and performer. Also make 	sure the new controller references the keyboard processor."	"get old controller, kbd processor"	| oldController |	oldController := self controller: aSymbol.	aController keyboardProcessor: self keyboardProcessor.	(aController isKindOf: oldController class)		ifTrue: ["for subclass case, copy vars down"			self copyVarsFrom: oldController to: aController].	((oldController isKindOf: ControllerWithMenu)		and: ["transfer menu if necessary"			aController isKindOf: ControllerWithMenu])		ifTrue: [aController menuHolder notNil				ifTrue: 					[aController menuHolder value: oldController menu.					aController performer: oldController performer]].	(self widget: aSymbol)		controller: aController</body><body package="VRForms">replaceWidgetOf: aSymbol with: aWidget 	"replace the widget"	"get old widget, controller"	| oldWidget oldController |	oldWidget := self widget: aSymbol.	oldController := self controller: aSymbol.	(aWidget isKindOf: oldWidget class)		ifTrue: ["for subclass case, copy vars down"			self copyVarsFrom: oldWidget to: aWidget]		ifFalse: 			[aWidget controller: oldController.			aWidget model: oldController model].	"replace it"	(self component: aSymbol)		widget: aWidget</body><body package="VRForms">scaleRect: aRect 	"stub - user may intervene to scale rectangle, perhaps based on screen size"	^aRect</body><body package="VRForms">selectDirectory	^CommonDirectorySelectionDialog new open</body><body package="VRForms">selectFromList: aList	^CommonListChooser openWith: aList</body><body package="VRForms">selectionBackgroundColor: aSymbol to: aColorValue 	"set the color"	| lookPref comp |	comp := self component: aSymbol.	lookPref := comp lookPreferences setSelectionBackgroundColor: aColorValue.	comp lookPreferences: lookPref</body><body package="VRForms">selectionBackgroundColorAll: anArray to: aColorValue 	"change the foreground colors"	anArray do: [:widgetSymbol | self selectionBackgroundColor: widgetSymbol to: aColorValue]</body><body package="VRForms">selectionForegroundColor: aSymbol to: aColorValue 	"set the color"	| lookPref comp |	comp := self component: aSymbol.	lookPref := comp lookPreferences setSelectionForegroundColor: aColorValue.	comp lookPreferences: lookPref</body><body package="VRForms">selectionForegroundColorAll: anArray to: aColorValue 	"change the foreground color"	anArray do: [:widgetSymbol | self selectionForegroundColor: widgetSymbol to: aColorValue]</body><body package="VRForms">selectionsFromList: aList	^CommonListChooser openMultiWith: aList</body><body package="VRForms">setModel: aModel	"assume the use of 2.0 aspect paths:  so, model is a ValueModel"	self model value: aModel</body><body package="VRForms">setTextFieldReadOnly: aSymbol	"set a text field to a more realistic read only - scrolling works, menu access is curtailed"	| textController textBlock |	textController := self controller: aSymbol.	textBlock := [:event : controller |		event isKeyboard			ifTrue: [(self isScrollingCharacter: event)					ifTrue: [event]					ifFalse: [nil]]			ifFalse:  [event]].	textController keyboardHook: textBlock.	self setTextMenu: textController</body><body package="VRForms">setTextFieldsToReadOnly: anArray	"set a bunch of text fields to read only"	anArray do: [:each |		self setTextFieldReadOnly: each]</body><body package="VRForms">setTextMenu: textController	"reset the menu in the controller so that only find and copy are possible.	The idea is to reuse existing functionality, merely blocking access to	functions that can modify the text"	| mb |	mb := MenuBuilder new.	mb add: 'find...'-&gt;#find.	mb add: 'copy'-&gt;#copy.	textController menuHolder value: mb menu</body><body package="VRForms">show: aSymbol 	"enable, make visible the widget"	self enable: aSymbol.	self beVisible: aSymbol</body><body package="VRForms">showAll: anArray 	"show the object(s)"	anArray do: [:widgetSymbol | self show: widgetSymbol]</body><body package="VRForms">takeFocus: aSymbol 	"have component grab focus"	(self builder componentAt: aSymbol) takeKeyboardFocus</body><body package="VRForms">turnOff: aSymbol 	"turn off the widget"	| comp |	comp := self widget: aSymbol.	comp controller: NoController new</body><body package="VRForms">turnOffAll: anArray 	"turnOff the object(s)"	anArray do: [:widgetSymbol | self turnOff: widgetSymbol]</body><body package="VRForms">turnOn: aSymbol 	"turn on the widget"	| comp cont |	comp := self widget: aSymbol.	cont := comp defaultController.	comp controller: cont</body><body package="VRForms">turnOnAll: anArray 	"turnOn the object(s)"	anArray do: [:widgetSymbol | self turnOn: widgetSymbol]</body><body package="VRForms">widget: aSymbol 	"return the widget"	^(self builder componentAt: aSymbol) widget</body></methods><methods><class-id>UI.CommonApplicationModel</class-id> <category>dialogs</category><body package="VRForms">openFile	| file |	file := CommonFileSelectionDialog openFile.	self doFileOpen: file</body><body package="VRForms">saveFile	| file |	file := CommonFileSelectionDialog saveFile.	self doFileSave: file</body><body package="VRForms">warnCritical: aMessage	^CommonMessageDialog openCritical: aMessage</body><body package="VRForms">warnInformative: aMessage	^CommonMessageDialog openInformation: aMessage</body><body package="VRForms">warnNormal: aMessage	^CommonMessageDialog openWarning: aMessage</body><body package="VRForms">warnQuery: aMessage	^CommonMessageDialog openQuestion: aMessage</body></methods><methods><class-id>UI.JARApplicationModel</class-id> <category>api</category><body package="VRForms">accept	self trigger value: true</body><body package="VRForms">cancel	self trigger value: false</body><body package="VRForms">captureScreen	"capture and return the current window as an image"	| view box box2 overallScreenRect interSect |	view := Window currentWindow controller view.	box := view getDisplayBox.	box2 := Rectangle origin: (box origin - (2@22))						corner: (box corner+3).	overallScreenRect := Screen default bounds.	interSect := box2 intersect: overallScreenRect.	^Image fromRectangle: interSect.</body><body package="VRForms">customizeBuiltSpec: aSpec	"make any mods to the spec here"	^aSpec</body><body package="VRForms">customizeSpec: aSpec	"make any mods to the spec here"	^aSpec</body><body package="VRForms">executeWithCancel: aBlock	"execute a block with cancel protection"	self executeWithCancel: aBlock with: 'Executing... Please Wait'</body><body package="VRForms">executeWithCancel: aBlock with: aMessage	"execute a block with cancel protection"	self executeWithCancel: aBlock with: 'Executing... Please Wait' at: Processor userBackgroundPriority</body><body package="VRForms">executeWithCancel: aBlock with: aMessage at: aPriority	"execute a block with cancel protection"	ProcessWatcher fork: aBlock with: aMessage at: aPriority type: #cancelSpec</body><body package="VRForms">executeWithWait: aBlock	"execute a block with wait dialog"	self executeWithWait: aBlock with: 'Executing... Please Wait'</body><body package="VRForms">executeWithWait: aBlock with: aMessage	"execute a block with cancel protection"	self executeWithWait: aBlock with: 'Executing... Please Wait' at: Processor userBackgroundPriority</body><body package="VRForms">executeWithWait: aBlock with: aMessage at: aPriority	"execute a block with cancel protection"	ProcessWatcher fork: aBlock with: aMessage at: aPriority</body><body package="VRForms">expandWindow	"deiconify window"	self window expand</body><body package="VRForms">hideWindow	"unmap the window"	self window unmap</body><body package="VRForms">iconifyWindow	"iconify window"	self window collapse</body><body package="VRForms">messageFor: exception	^exception errorString</body><body package="VRForms">platform	"return the platform name"	^Screen default platformName</body><body package="VRForms">printScreen	"Print the active window - rely on Host OS for error message"	| document |	Object errorSignal		handle: [:ex | ex restartDo: [self]]		do: [Cursor wait			showWhile: 				[document := Document new.				document setLandscape.				document addImage: self captureScreen.				document close.				document toPrinter]]</body><body package="VRForms">release	"include a default release behavior that will forward release to model"	self model notNil		ifTrue: [self release: (Array with: self model)].	super release</body><body package="VRForms">release: aCollection	"assume that we want to release a lot of objects"	aCollection do: [:each | each release]</body><body package="VRForms">reportError: exception	"subclasses might wish to override"	| aString |	aString := self messageFor: exception.	Dialog warn: aString for: self builder window</body><body package="VRForms">screenSize	"return a point, where x is the width, y is the height"	^Screen default bounds corner</body><body package="VRForms">screenToClipboard	"copy the current window to the system clipboard"	Cursor wait showWhile: 		[self captureScreen asRetainedMedium toClipboard]</body><body package="VRForms">showWindow	"map the window"	self window map</body><body package="VRForms">shutdown	"discard any buffered values and close"	self cancel.	self closeRequest</body><body package="VRForms">simpleDialog	"in addition to normal stuff, cache the dialog's builder so main app's	can access it easily"	| sd |	sd := super simpleDialog.	self dialogBuilder: sd builder.	^sd</body><body package="VRForms">startDrag: dragEvent with: dragDictionary for: aController	"set up the drag drop event"	| ds dm data |	data := DragDropData new.	data key: dragEvent.	data contextWindow: self builder window.	data contextWidget: aController view.	data contextApplication: self.	data clientData: dragDictionary.	ds := DropSource new.	dm := DragDropManager withDropSource: ds withData: data.	dm doDragDrop.</body><body package="VRForms">trigger	^trigger</body><body package="VRForms">trigger: aValue	trigger := aValue</body><body package="VRForms">window	"return the window"	self builder isNil ifTrue: [ ^self ].	^self builder window</body></methods><methods><class-id>UI.JARApplicationModel</class-id> <category>private</category><body package="VRForms">copyVarsFrom: oldObject to: newObject 	"copy contents of inst vars where they match"	| oldVars |	oldVars := oldObject class instVarNames.	oldVars do: [:var | "now copy contents"		newObject perform: (var , ':') asSymbol with: (oldObject perform: var asSymbol)]</body><body package="VRForms">getElementIndexOfTarget: mousePoint for: targetController	"given context, controller, grab the element that was dropped on"	^targetController findElementFor:  mousePoint.</body></methods><methods><class-id>UI.JARApplicationModel</class-id> <category>accessing</category><body package="VRForms">dialogBuilder	^dialogBuilder</body><body package="VRForms">dialogBuilder: aValue	dialogBuilder := aValue</body><body package="VRForms">model	^model</body><body package="VRForms">model: aValue 	model := aValue</body></methods><methods><class-id>UI.JARApplicationModel</class-id> <category>interface control</category><body package="VRForms">noticeOfWindowClose: aWindow	"if my window is closing, invoke my release behavior, which will also release	model"	aWindow == self window		ifTrue: [self release]</body><body package="VRForms">openInterface: aSymbol withPolicy: aPolicy inSession: anApplicationContext	"Open the ApplicationModel's user interface, using the specification 	named and the given look policy and application context."	| spec |	builder := aPolicy newBuilder.	uiSession := anApplicationContext.	builder source: self.	"this method can change the spec !!" 	spec := self customizeSpec: (self class perform: aSymbol). 	"replace stock method so that the modified spec is used"	spec := FullSpec from: spec."	spec := self class interfaceSpecFor: aSymbol."	"this method can change the spec object"	spec := self customizeBuiltSpec: spec.	self preBuildWith: builder.	self hookUpWindow: self defaultWindowClassOrNil spec: spec builder: builder.	builder add: spec.	builder isForWeb ifTrue: 		[builder composite htmlEntity components do: 			[:each | each adjustJSNames: builder namedComponents].		builder window htmlEntity adjustJSNames: builder namedComponents].	builder adjustForWeb.	self postBuildWith: builder.	builder window model: self.	builder openWithExtent: spec window bounds extent.	"Get the window initially built before letting the application model	alter the state of things. Otherwise, we could get multiple, unnecessary	redisplay events."	builder window displayPendingInvalidation.	self postOpenWith: builder.	^builder</body><body package="VRForms">postBuildWith: bldr 	"register to grab window events. May be freely overridden if child management is	not an issue"	super postBuildWith: bldr.	self window application: self.	self window sendWindowEvents: #(#close #collapse #expand)</body></methods><methods><class-id>UI.JARApplicationModel class</class-id> <category>As yet unclassified</category><body package="VRForms">openAt: aPoint 	"aPoint is the left top corner to open the window at"	^self openAt: aPoint with: #windowSpec</body><body package="VRForms">openAt: aPoint with: aSymbol 	"aPoint is the left top corner to open the window at"	^self openAt: aPoint 	with: aSymbol in: nil</body><body package="VRForms">openAt: aPoint with: aSymbol in: aRect 	"aPoint is the left top corner to open the window at"	^self openAt: aPoint with: aSymbol in: aRect ofType: #normal</body><body package="VRForms">openAt: aPoint with: aSymbol in: aRect ofType: aType	"aPoint is the left top corner to open the window at"	| inst |	inst := self new.	inst		openAt: aPoint		with: aSymbol		in: aRect		ofType: aType.	^inst</body></methods><methods><class-id>UI.ServiceApplicationModel</class-id> <category>printing support</category><body package="VRForms">actuallyPrint: aStream	"print the contents of the stream- create a document, send to 	printer.  Due to win32s bug, default choice (landscape) should	match choice in Windows print setup.  subclasses should override	for custom behavior"	| document header footer |	document := self documentClass new.	header := self getHeader.	footer := self getFooter.	header notNil		ifTrue: [document addItalicHeader: header pixelSize: self headerSize].	footer notNil		ifTrue: [document doFooter: true				footerString: footer				doPageNumbers: true].	document setLeftMargin: 0.5.	document setRightMargin: 0.5.	document startParagraph.	self documentType == #landscape		ifTrue: [document setLandscape].	document addText: aStream contents under: (TextAttributes styleNamed: self styleType).	document close.	"if the print fails, we want to gracefully ignore the exception, since	windows will display an error for us"	Object errorSignal		handle: [:ex | ex return]		do: [document toPrinter].</body><body package="VRForms">actuallySave: aStream on: aString	"subclasses may override for custom behavior"	| out |	out := aString asFilename writeStream.	[out nextPutAll: aStream contents]		valueNowOrOnUnwindDo: [out close]</body><body package="VRForms">canPrint	"application specific test"	^true</body><body package="VRForms">getFooter	"answer an empty footer - subclasses may override to do something special"	^nil</body><body package="VRForms">getHeader	"answer an empty footer - subclasses may override to do something special"	^nil</body><body package="VRForms">headerSize	"answer the pixel size for the header"	^16</body><body package="VRForms">print: aStream to: aStringOrNil	"default printing.  subclasses should override #producePrintStream: "	self producePrintStream: aStream.	shouldPrint		ifTrue: [self actuallyPrint: aStream]		ifFalse: [self actuallySave: aStream on: aStringOrNil]</body><body package="VRForms">printStream	printStream isNil		ifTrue: [printStream := FormattingStream on: (String new: 100)].	^printStream</body><body package="VRForms">printStream: aValue	printStream := aValue</body><body package="VRForms">printToFile	"print to a file determined by the dialog"	| file |	file := Dialog request: 'Export File ?'.	file isEmpty		ifTrue: [ ^self ].	self printToFile: file.</body><body package="VRForms">printToFile: aFileString	"print to a stream- answer the stream"	shouldPrint := false.	self print: self printStream reset to: aFileString.</body><body package="VRForms">printToPrinter	"print the stream"	shouldPrint := self canPrint.	shouldPrint ifTrue: [self print: self printStream reset to: nil].</body><body package="VRForms">producePrintStream: aStream	"subclasses should override"	^self subclassResponsibility</body><body package="VRForms">shouldPrint	^shouldPrint</body><body package="VRForms">shouldPrint: aValue	shouldPrint := aValue</body><body package="VRForms">styleType	"answer a known font: #fixed is our default"	^#fixed</body></methods><methods><class-id>UI.ServiceApplicationModel</class-id> <category>child window</category><body package="VRForms">addChildModel: anAppModel 	"add an app model to our list"	self extChildren add: anAppModel.	anAppModel extOwner: self</body><body package="VRForms">extChildren	^extChildren</body><body package="VRForms">extChildren: aValue	extChildren := aValue.	self changed: #extChildren</body><body package="VRForms">extOwner	^extOwner</body><body package="VRForms">extOwner: aValue	extOwner := aValue.	self changed: #extOwner</body><body package="VRForms">hasChildren	^self extChildren isEmpty not</body><body package="VRForms">hasParent	^self extOwner notNil</body><body package="VRForms">removeChildModel: anAppModel 	"remove an app model to our list"	self extChildren remove: anAppModel ifAbsent: [^self]</body></methods><methods><class-id>UI.ServiceApplicationModel</class-id> <category>api</category><body package="VRForms">bufferedValueModelIds	"By default, the application does no buffering of data. Subclasses may wish to override this by 	returning an array of widget ids that are buffering user input."	^#()</body><body package="VRForms">characterWidth: aStyleName	"answer the width of a character, in case user wishes to format"	^((TextAttributes styleNamed: aStyleName) characterAttributes defaultQueryFor: nil) setWidth</body><body package="VRForms">documentClass	"if on windows, answer VRDocument (native dialog support).  Else answer Document"	(('*Win*' match: self platform) or: [ '*nt*' match: self platform])		ifTrue: [^VRDocument]		ifFalse: [^Document]</body><body package="VRForms">documentType	"answer #landscape or #portrait"	^#portrait</body><body package="VRForms">okToChangeModel	self isEditing		ifTrue: 			[self reportError: 'You have edits pending! Aborting.'.			^false].	^true</body></methods><methods><class-id>UI.ServiceApplicationModel</class-id> <category>initialize-release</category><body package="VRForms">initialize	"just invoke superclass behavior"	super initialize.	shouldPrint := true.	self extChildren: Set new.</body></methods><methods><class-id>UI.ServiceApplicationModel</class-id> <category>testing</category><body package="VRForms">isEditing	self bufferedValueModelIds		do: 			[:bvmid | 			| foundModel |			foundModel := self modelFor: bvmid.			foundModel notNil ifTrue: [foundModel isBuffering ifTrue: [^true]]].	^false</body></methods><methods><class-id>UI.ServiceApplicationModel</class-id> <category>interface control</category><body package="VRForms">noticeOfChildWindowClose: anAppModel 	self removeChildModel: anAppModel</body><body package="VRForms">noticeOfWindowClose: aWindow 	self extOwner notNil ifTrue: [self extOwner noticeOfChildWindowClose: aWindow].	super noticeOfWindowClose: aWindow</body><body package="VRForms">requestForWindowClose	super requestForWindowClose ifFalse: [^false].	self isEditing		ifTrue: 			[self reportError: 'You have edits pending.  Close aborted.'.			^false].	self hasChildren ifTrue: [self extChildren do: [:child | child isEditing				ifTrue: 					[self reportError: 'Another window has edits that are pending.  Close aborted.'.					^false]]].	^true</body></methods><methods><class-id>UI.VRApplicationModel</class-id> <category>registry support</category><body package="VRForms">answerFromRegistry: aSymbol	"assume the symbol to be a class name, make sure to pass on the registry"	| inst |	inst := self registry at: aSymbol ifAbsent: [nil].	inst isNil		ifTrue: [inst := self insertToRegistry: aSymbol.				creationFlag := #openNew:spec:]		ifFalse: [creationFlag := #openOld:spec:].	(inst isDBAppModel not and: [self creationFlag == #openNew:spec:])		ifTrue: [inst initialize]		ifFalse: [inst registry isNil ifTrue: [inst registry: self registry]].	^inst</body><body package="VRForms">classFromSymbol: aSymbol		^Root allClasses detect: [:each | each name = aSymbol] ifNone: [nil].</body><body package="VRForms">clearRegistry	"clear the registry"	self registry: IdentityDictionary new</body><body package="VRForms">findAppInRegistry: appModel 	"return the instance of the app model found in the registry - nil if none found"	| key |	key := appModel class name.	^(self registry includesKey: key)		ifTrue: [self registry at: key ifAbsent: [nil]]		ifFalse: [nil]</body><body package="VRForms">findAppInRegistryByKey: aSymbol 	"return the instance of the app model found in the registry - nil if none found"	^(self registry includesKey: aSymbol)		ifTrue: [self registry at: aSymbol ifAbsent: [nil]]		ifFalse: [nil]</body><body package="VRForms">initRegistry	self registry isNil		ifTrue: [self registry: IdentityDictionary new.				self registry at: self class name put: self]</body><body package="VRForms">insertToRegistry: aSymbolOrClass	"create a new instance, with the same registry"	| inst cls |	aSymbolOrClass isBehavior		ifTrue: [cls := aSymbolOrClass]		ifFalse: [cls := self classFromSymbol: aSymbolOrClass].	inst := cls isNil		ifTrue: [self error: 'Not Found']		ifFalse: [cls new].	inst isDataModel		ifFalse: [inst registry: self registry].	self shouldCache ifTrue: [self registry at: aSymbolOrClass put: inst].	^inst</body><body package="VRForms">openFromRegistry: aSymbol	"assume the symbol to be a class name"	^self openFromRegistry: aSymbol using: #windowSpec</body><body package="VRForms">openFromRegistry: aSymbol using: aSpecName	"assume the symbol to be a class name"	| appModel | 	appModel := self answerFromRegistry: aSymbol.	self perform: self creationFlag with: appModel with: aSpecName.	^appModel</body><body package="VRForms">openNew: appModel spec: spec	self open: appModel interface: spec</body><body package="VRForms">openOld: appModel spec: spec	appModel builder window raise</body><body package="VRForms">registry	"answer the registry object"	registry isNil		ifTrue: [registry := IdentityDictionary new.				self registry at: self class name put: self].	^registry</body><body package="VRForms">registry: aValue	"set the registry object"	registry := aValue</body><body package="VRForms">releaseRegistry	"release the registry.  top level appModel should do this"	self registry: nil</body><body package="VRForms">removeFromRegistry: appModel	"remove appModel from registry"	(self registry includesKey: appModel class name)	ifTrue: [self registry removeKey: appModel class name]</body><body package="VRForms">removeFromRegistryByKey: aSymbol	"remove appModel from registry"	self registry removeKey: aSymbol ifAbsent: []</body><body package="VRForms">selectorsEligibleFromHyperlinks	^selectorsEligibleFromHyperlinks</body><body package="VRForms">selectorsEligibleFromHyperlinks: aValue	selectorsEligibleFromHyperlinks := aValue</body></methods><methods><class-id>UI.VRApplicationModel</class-id> <category>accessing</category><body package="VRForms">creationFlag	^creationFlag</body><body package="VRForms">customizationArgument	^customizationArgument</body><body package="VRForms">customizationArgument: aValue	customizationArgument := aValue</body><body package="VRForms">customizationBlock	^customizationBlock</body><body package="VRForms">customizationBlock: aBlock	customizationBlock := aBlock</body><body package="VRForms">enclosingFrameset 	^enclosingFrameset</body><body package="VRForms">enclosingFrameset: aValue	enclosingFrameset := aValue</body><body package="VRForms">errorText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^errorText isNil		ifTrue:			[errorText := String new asValue]		ifFalse:			[errorText]</body><body package="VRForms">shouldCache	shouldCache isNil		ifTrue: [shouldCache := true].	^shouldCache</body><body package="VRForms">shouldCache: aValue	shouldCache := aValue</body></methods><methods><class-id>UI.VRApplicationModel</class-id> <category>api</category><body package="VRForms">dialogWarn: aString	"dialogs for pre 2.0 Wave apps"	self errorText value: aString.	self openDialogInterface: #errorDialogSpec</body><body package="VRForms">home	"answer the 'top' page of the registry - subclasses must	implement if they expect this to work"	^self subclassResponsibility</body><body package="VRForms">reportDBError: aString 	"report the db error"	| dlg |	dlg := VRExceptionDialog new: aString parent: self.	dlg openDBError</body><body package="VRForms">reportError: aString 	"report the error"	| dlg |	dlg := VRExceptionDialog new: aString parent: self.	dlg openError</body><body package="VRForms">reportListError: aString onList: aList 	"report the list of errors"	| dlg |	dlg := VRExceptionDialog new: aString parent: self.	dlg dataList: aList.	dlg openListError</body><body package="VRForms">reportNonModalDBError: aString 	"report the db error, modally"	| dlg |	dlg := VRExceptionDialog new: aString parent: self.	dlg modal: false.	dlg openDBError</body><body package="VRForms">reportNonModalError: aString 	"report the error, modally"	| dlg |	dlg := VRExceptionDialog new: aString parent: self.	dlg modal: false.	dlg openError</body><body package="VRForms">reportNonModalListError: aString onList: aList 	"report the list of errors, modally"	| dlg |	dlg := VRExceptionDialog new: aString parent: self.	dlg dataList: aList.	dlg modal: false.	dlg openListError</body><body package="VRForms">submit	"convenience method"</body></methods><methods><class-id>UI.VRApplicationModel</class-id> <category>testing</category><body package="VRForms">isDataModel	^false</body><body package="VRForms">isDBAppModel	^false</body></methods><methods><class-id>UI.VRApplicationModel</class-id> <category>interface control</category><body package="VRForms">postBuildWith: bldr	super postBuildWith: bldr.	self customizationBlock notNil		ifTrue: [self customizationBlock value: self value: self customizationArgument]</body></methods><methods><class-id>UI.VRApplicationModel</class-id> <category>initialize-release</category><body package="VRForms">release	super release.	self registry notNil		ifTrue: [self removeFromRegistry: self]</body></methods><methods><class-id>UI.VRApplicationModel class</class-id> <category>As yet unclassified</category><body package="VRForms">ppdLogo	^Image parcPlaceDigitalkLogo</body></methods><methods><class-id>UI.VRDBApplicationModel</class-id> <category>api</category><body package="VRForms">answerFromRegistry: aSymbol	"assume the symbol to be a class name, make sure to pass on the registry"	| inst | 	inst := super answerFromRegistry: aSymbol.	(inst respondsTo: #dataModel:)		ifTrue: [inst dataModel: self dataModel].	"created via basicNew, so initialize now that all necessary info	has been shoved in"	self creationFlag == #openNew:spec:		ifTrue: [inst initialize]		ifFalse: [inst registry isNil ifTrue: [inst registry: self registry]].	^inst</body><body package="VRForms">dataModel	^dataModel</body><body package="VRForms">dataModel: aValue	dataModel := aValue</body><body package="VRForms">isDBAppModel	^true</body><body package="VRForms">logout	"logout of the database, releasing sessions as well"	self dataModel session disconnect.	self dataModel databaseLogout.</body><body package="VRForms">releaseDataModel	"This should be called by the top level appModel in the chain."	self dataModel notNil		ifTrue: [self dataModel databaseLogout.				self dataModel release].</body></methods><methods><class-id>UI.VRListForm</class-id> <category>api</category><body package="VRForms">add	"add a new entity by popping a detail form"	| detail |	detail := (Smalltalk at: self domainFormClass) new.	detail editMode: #add.	detail parent: self.	detail windowLabel: self windowLabel.	self open: detail interface: #windowSpec.</body><body package="VRForms">addDomainObject: anObject	"add an object to the list"	self dataList add: anObject</body><body package="VRForms">changeToMultiSelect: aSpec	"modify spec to be multi-select"	| listComponent list |	listComponent := (aSpec component collection select: [:each | each name == #dataList]) at: 1.	listComponent multipleSelections: true.	list := self dataList list.	dataList := MultiSelectionInList with: list.</body><body package="VRForms">edit	"Edit selected object"	| detail domainObject |	self isMultiSelect		ifTrue: [^self multiEdit].	domainObject := self dataList selection.	domainObject isNil		ifTrue: [^self].  	detail := self answerFromRegistry: self domainFormClass.	detail model value: domainObject.	detail editMode: #edit.	detail parent: self.	detail windowLabel: self windowLabel.	self open: detail interface: #windowSpec.</body><body package="VRForms">editAll	"bring up a paging form on the list"	| form | 	self dataList list isEmpty		ifTrue: [^self].	form := VRPagingForm 				initWith: self dataList list 				on: (Smalltalk at: self domainFormClass) new.	form windowLabel: self windowLabel.	self open: form interface: #windowSpec</body><body package="VRForms">multiEdit	"Edit selected object"	| detail domainObjects pageForm |	domainObjects := self dataList selections asList.	domainObjects isEmpty		ifTrue: [^self].  	detail := self answerFromRegistry: self domainFormClass.	pageForm := VRPagingForm initWith: domainObjects on: detail.	self open: pageForm interface: #windowSpec.</body><body package="VRForms">multiRemove	"remove selected entities from the list"	|  domainObjects |	domainObjects := self dataList selections.	domainObjects isEmpty		ifTrue: [^self].	self dataList list removeAll: domainObjects</body><body package="VRForms">remove	"remove selected entity from the list"	|  domainObject |	self isMultiSelect		ifTrue: [^self multiRemove].	domainObject := self dataList selection.	domainObject isNil		ifTrue: [^self].	self dataList list remove: domainObject</body><body package="VRForms">save	"save to a formatted file.  NOTE:  Objects in collection must	respond to the #printOntoStream: message"	self class messageNotUnderstoodSignal		handle: [:ex | Dialog 						warn: 'No API defined for Saving this object'						for: self builder window.					ex return]		do: [self printToFile]</body></methods><methods><class-id>UI.VRListForm</class-id> <category>interface control</category><body package="VRForms">customizeBuiltSpec: aSpec	super customizeBuiltSpec: aSpec.	self isMultiSelect		ifTrue: [self changeToMultiSelect: aSpec].	^aSpec</body><body package="VRForms">on: aList  detailForm: detailClass	"initialize the form"	self dataList list: aList.	self domainFormClass: detailClass</body><body package="VRForms">postBuildWith: bldr	super postBuildWith: bldr.	self disableAll: self offList.	self windowLabel isNil		ifTrue: [self builder window label: 'List Display Form on: ', self dataList list  size printString, ' elements']		ifFalse: [self builder window label: self windowLabel]</body><body package="VRForms">turnOff: aList	offList := aList</body><body package="VRForms">turnOn: aList	self enableAll: aList</body></methods><methods><class-id>UI.VRListForm</class-id> <category>accessing</category><body package="VRForms">dataList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dataList isNil		ifTrue:			[dataList := SelectionInList new]		ifFalse:			[dataList]</body><body package="VRForms">dataList: aValue	dataList := aValue</body><body package="VRForms">detailForm: aFormClassSymbol	self domainFormClass: aFormClassSymbol</body><body package="VRForms">domainFormClass	^domainFormClass</body><body package="VRForms">domainFormClass: aValue	domainFormClass := aValue</body><body package="VRForms">isMultiSelect	^isMultiSelect</body><body package="VRForms">isMultiSelect: aValue	isMultiSelect := aValue</body><body package="VRForms">offList	^offList</body><body package="VRForms">printHeader	^printHeader</body><body package="VRForms">printHeader: aValue	printHeader := aValue</body><body package="VRForms">printType	^printType</body><body package="VRForms">printType: aValue	printType := aValue</body><body package="VRForms">windowLabel	^windowLabel</body><body package="VRForms">windowLabel: aValue	windowLabel := aValue</body></methods><methods><class-id>UI.VRListForm</class-id> <category>print support</category><body package="VRForms">flatPrintStream: aStream	"use standard print api"	|  count sels toPrintList sel |	self isMultiSelect		ifTrue: [sels := self selections.				sels isEmpty					ifTrue: [toPrintList := self dataList]					ifFalse: [toPrintList := sels]]		ifFalse: [sel := self selection.				sel isNil					ifTrue: [toPrintList := (Array with: sel)]					ifFalse: [toPrintList := self dataList]].	count := 1.	toPrintList do: [:each |		each printFlatOntoStream: aStream forRecord: count]</body><body package="VRForms">print	"print the objects, with a form feed between each.	NOTE:  Objects in collection must	respond to the #printOntoStream: message"	self class messageNotUnderstoodSignal		handle: [:ex | Dialog 						warn: 'No API defined for Printing this object'						for: self builder window.					ex return]		do: [self printToPrinter]</body><body package="VRForms">producePrintStream: aStream	"do either a flat or report print"	self perform: (self printType, 'PrintStream:') asSymbol with: aStream.</body><body package="VRForms">reportPrintStream: aStream	"use standard print api"	|  count sels toPrintList sel |	self isMultiSelect		ifTrue: [sels := self dataList selections.				sels isEmpty					ifTrue: [toPrintList := self dataList list]					ifFalse: [toPrintList := sels]]		ifFalse: [sel := self dataList selection.				sel isNil					ifTrue: [toPrintList := self dataList list]					ifFalse: [Array with: sel]].	count := 1.	toPrintList do: [:each |		each printOntoStream: aStream forRecord: count]</body></methods><methods><class-id>UI.VRListForm</class-id> <category>private</category><body package="VRForms">getSelectedCollection	"answer a collection of all selections or an empty array"	| selections |	self isMultiSelect		ifTrue: [selections := self dataList selections]		ifFalse: [|sel |				sel  := self dataList selection.				sel isNil 					ifTrue: [selections := self dataList list]					ifFalse: [selections := (Array with: sel)]].	^selections</body></methods><methods><class-id>UI.VRListForm</class-id> <category>initialize-release</category><body package="VRForms">initialize	super initialize.	offList := #().	self printHeader: 'List Report'.	self isMultiSelect: false.	self printType: 'report'</body><body package="VRForms">initializeTable: data	"makes it easy to sub a list form for a table form"	self dataList list: data</body></methods><methods><class-id>UI.VRListForm class</class-id> <category>instance creation</category><body package="VRForms">detailForm: detailClass	"create a new instance"	| inst |	inst := self new.	^inst domainFormClass: detailClass</body><body package="VRForms">on: aList detailForm: detailClass	"create a new instance"	| inst |	inst := self new.	^inst on: aList detailForm: detailClass</body><body package="VRForms">open: aSymbol withPolicy: aPolicy inSession: anApplicationContext	"Open the ApplicationModel's user interface, using the specification 	named and the given look policy and application context."	| spec |	"if web, sub the spec"	self executeForWebOnly: [spec := #webSpec].	spec := aSymbol isSymbol not ifTrue: [ #windowSpec ] ifFalse: [ aSymbol ].	^self new openInterface: spec withPolicy: aPolicy inSession: anApplicationContext</body></methods><methods><class-id>UI.TopDBVRApplicationModel</class-id> <category>initialize-release</category><body package="VRForms">release	super release.	self releaseDataModel</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>private</category><body package="VRForms">adjustLayout	"Private -  adjust the layout of the message label to span multiple lines and list widget	to calculated list box height depending on the number of elements." 		| composedMessage layout textWidth textHeight listHeight wrapper listWidth index pad |	composedMessage := self message value asComposedText.	wrapper := self builder componentAt: #messageArea.	layout := wrapper layout.	textWidth := composedMessage width.	textWidth &gt; layout width		ifTrue: [ textWidth := layout width.			composedMessage compositionWidth: textWidth - 20 ].	textHeight := composedMessage height.	layout right: layout left + textWidth.	layout bottom: layout top + textHeight.	wrapper layout: layout.	wrapper := self builder componentAt: #listWidget.	layout := wrapper layout.	self list list size &lt;= 10		ifTrue: [ wrapper decorator noVerticalScrollBar ].	listWidth := wrapper layout right - wrapper layout left.	index := 0.	pad := layout bottom - layout top.	self list list detect: [ :entry | 		index := index + 1.		( wrapper widget displayStringAt: index ) asComposedText width &gt; listWidth ]		ifNone: [ wrapper decorator noHorizontalScrollBar.			pad := 0 ].	listHeight := ( wrapper widget displayStringAt: index ) asComposedText height * 		( self list list size min: 10 ) .	layout bottom: layout top + listHeight + pad.	wrapper layout: layout.	( self builder componentAt: #okButton ) moveBy: 0@( textHeight + listHeight ).	( self builder componentAt: #cancelButton ) moveBy: 0@( textHeight + listHeight )</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>initialize-release</category><body package="VRForms">initialize	"Private"	super initialize.	list := SelectionInList new.	self title: ''.	self multipleSelect: false.	message := '' asValue.	self printSelector: nil.</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>accessing</category><body package="VRForms">initialSelection	"Accessor for the initial selection"	^initialSelection</body><body package="VRForms">initialSelection: aListItem	"Assign the initial selection"	initialSelection := aListItem</body><body package="VRForms">list	"Accessor for the list of items"	^list</body><body package="VRForms">list: aList	"Assignment for the list of item to be displayed"	list := aList</body><body package="VRForms">message	"Returns the message to be displayed on the list dialog"	^message</body><body package="VRForms">message: aMessage	"Assigns the message string to be displayed on the list dialog"	message value: aMessage</body><body package="VRForms">multipleSelect	"A boolean whether multiple selections are allowed"	^multipleSelect</body><body package="VRForms">multipleSelect: aBoolean	"Assign whether multiple selections are allowed"	multipleSelect := aBoolean</body><body package="VRForms">printSelector	"Returns the symbol of the selector used to obtain the display string for the SequenceView.	If nil, then the SequenceView default will be used"	^printSelector</body><body package="VRForms">printSelector: aSymbol	"Assign the symbol of the selector used to obtain the display string for the SequenceView.	If nil, then the SequenceView default will be used"	printSelector := aSymbol</body><body package="VRForms">title	"Returns the string to be displayed in the dialog window's title bar."	^title</body><body package="VRForms">title: aString	"Returns the string to be displayed in the dialog window's title bar."	title := aString</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>actions</category><body package="VRForms">open	"Open the dialog"	| spec |	self builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self multipleSelect		ifTrue: [ 			self list:( MultiSelectionInList with: self list ).			spec := self class interfaceSpecFor: #windowSpecMultipleSelect ]		ifFalse: [ 			self list: ( SelectionInList with: self list ).			spec := self class interfaceSpecFor: #windowSpec ].	self allButOpenFrom:spec.	( self builder componentAt: #listWidget ) widget displayStringSelector: self printSelector.	self adjustLayout. 	self builder window label: self title.	( self builder componentAt: #listWidget ) widget 		controller setDispatcher: (UIDispatcher new doubleClick: 		[ ( self list selection  = 0 ) ifFalse: [ accept value: true ] ] ).	( self list list includes: self initialSelection )		ifTrue: [ self list selection: self initialSelection ].	"kludgy fix, must move list box after open or it defaults to wrong look policy"	self postOpenBlock: [  :dialog :uiBuilder | | layout | 		layout := ( uiBuilder componentAt: #messageArea ) layout.		(uiBuilder componentAt: #listWidget) moveBy: 0@( layout bottom - layout top) ].	self builder openDialogWithExtent: self builder window width @ 		( ( self builder componentAt: #okButton) layout bottom + 15 ).	( self accept value )		ifFalse: [ ^nil ]		ifTrue: [ self multipleSelect			ifTrue: [ ^self list selections ]			ifFalse:[ ^self list selection ] ]</body></methods><methods><class-id>UI.CommonListChooser class</class-id> <category>As yet unclassified</category><body package="VRForms">openMultiWith: aList	^self openWith: aList multiSelect: true</body><body package="VRForms">openWith: aList	^self openWith: aList multiSelect: false</body><body package="VRForms">openWith: aList multiSelect: aBoolean	| inst | 	inst := self new.	inst list: aList.	inst multipleSelect: aBoolean.	^inst open</body></methods><methods><class-id>Core.ExtendedModel</class-id> <category>printing</category><body package="VRForms">getPrintStream	"answer the stream appropriate for this object"</body><body package="VRForms">printString: aString onStream: aStream withWidth: aWidth	"print the string to the given width in chars"	| pads |	pads := aWidth - aString size.	pads &gt; 0		ifTrue: [aStream nextPutAll: aString.				pads timesRepeat: [aStream nextPut: Character space]].	pads &lt;= 0		ifTrue: [aStream nextPutAll: aString]</body></methods><methods><class-id>Core.ExtendedModel</class-id> <category>initialize-release</category><body package="VRForms">initialize	"stub for subclasses to override"</body><body package="VRForms">release	"default behavior - release all dependents"	self myDependents notNil		ifTrue: [self myDependents isSequenceable				ifTrue: [self myDependents do: [:each | self removeDependent: each]]				ifFalse: [self removeDependent: self myDependents]].	super release</body></methods><methods><class-id>Core.ExtendedModel</class-id> <category>api</category><body package="VRForms">platform	^Screen default platformName</body><body package="VRForms">save	"prepare a copy of this object that breaks all dependencies"	| copy |	copy := self copy breakDependents.	copy storePersistently</body><body package="VRForms">storePersistently	"do the right thng for this object"	^self subclassResponsibility</body></methods><methods><class-id>Core.ExtendedModel class</class-id> <category>instance creation</category><body package="VRForms">new	^super new initialize</body></methods><methods><class-id>UI.CommonFileFilter</class-id> <category>accessing</category><body package="VRForms">description	^description</body><body package="VRForms">description: aValue	description := aValue</body><body package="VRForms">filter	^filter</body><body package="VRForms">filter: aValue	filter := aValue</body></methods><methods><class-id>UI.CommonFileFilter class</class-id> <category>As yet unclassified</category><body package="VRForms">filter: aFilter description: aDescription	^self new filter: aFilter; description: aDescription</body></methods><methods><class-id>UI.TableAdaptorForList</class-id> <category>accessing</category><body package="VRForms">baseCollection: aCollection	super baseCollection: aCollection.	baseCollection addDependent: self</body><body package="VRForms">removeDependent: anObject	super removeDependent: anObject.	baseCollection removeDependent: self</body></methods><methods><class-id>UI.TableAdaptorForList</class-id> <category>events</category><body package="VRForms">update: anAspect with: aValue from: aList	anAspect == #at: ifTrue: [^self changed: #atRow: with: aValue].	anAspect == #add: ifTrue: [^self changed: #addRow with: aList size].	anAspect == #insert: ifTrue: [^self changed: #insertRow with: aValue].	anAspect == #replace: ifTrue: [^self changed: #atRow: with: aValue].	anAspect == #remove: ifTrue: [^self changed: #removeRow with: aValue].	anAspect == #removeFrom:to: ifTrue: [^self changed: #removeRow with: aValue].	anAspect == #insertCollection: ifTrue: [^self changed: #addRow with: aList size].	anAspect == #appendCollection: ifTrue: [^self changed: #addRow with: aList size].</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>file utils</category><body package="VRForms">buildPath: aPathElement	"Private - Answer a path string 'volume:directory\aPathElement'.	This element may be a file name or a subdirectory."	| volumeString |	( ( volumeString := self volumeName value ) last ~= Filename separator )		ifTrue: [ volumeString := volumeString , self separator ].	( aPathElement = '..' )		ifTrue: [ ^self constructPath: volumeString			with: self directoryName asFilename head ]		ifFalse: [ ^self constructPath: ( self constructPath: volumeString with: self directoryName )			with: aPathElement ]</body><body package="VRForms">constructPath: aString1 with: aString2	"Private - Answer a string which combine the path elements into a valid path string."	^self class constructPath: aString1 with: aString2</body><body package="VRForms">directoryPathIsValid: pathString	"Private - check if directory is valid path"	| components index |	index := self getVolumeFromPath: pathString.	( index + 1 &lt;= pathString size )		ifTrue: [			components := Filename components: 				( pathString copyFrom: index + 1 to: pathString size ).			components do: [ :dir |					 dir ~= self separator					ifTrue: [ ( self filenameIsValid: dir ) ifFalse: [ ^false ] ] ] ].	^true</body><body package="VRForms">enteredPath	"Private - Handles input for user specified path."	self builder keyboardProcessor focusIsShifting ifFalse: [ ^self ].	self processEnteredPath</body><body package="VRForms">filenameIsValid: pathString	"Private - Check to make sure the directory does not have illegal chars."	( ( self stringHasWildcard: pathString ) or: 	[ pathString includes: Filename volumeSeparator ] )		ifFalse: [ pathString detect: [ :c | Filename defaultClass isBadCharacter: c ] 			ifNone: [ ^true ] ].	^false</body><body package="VRForms">getVolumeFromPath: pathString	"Private -  take path components to see if the volume exists.  This method is to handle	network path names which Filename components: does not recognize"	( self volumeExists: ( Filename components: pathString ) first ) notNil		ifTrue: [ ^( Filename components: pathString ) first size ]		ifFalse: [ self volumeNames value do: [ :volume | | interval |			interval :=  pathString findString: volume startingAt: 1 ignoreCase: true useWildcards: false.			interval first = 1 ifTrue: [ ^interval last ] ] ].	^0</body><body package="VRForms">parsePath: pathString accountForFilename: filenameExists	"Private - Parse a directory path, including relative path, and paths with the volume specified"	| volume  index directory pathComponents |	index := self getVolumeFromPath: pathString.	index = 0 		ifTrue: [ volume := self volumeName value.			pathComponents := Filename components: pathString.			directory := self directoryName.			( pathComponents first = '.' ) | ( pathComponents first = '..' ) 				ifTrue: [ ( directory isEmpty or: [ ( Filename components: directory ) first = '.' ] )						ifTrue: [ directory := self class currentDirectory.							volume := self class currentVolume ].					( Filename components: directory ) first = '..' 						ifTrue: [ directory := self class currentDirectory asFilename head.							volume := self class currentVolume ] ] ]		ifFalse: [ volume := pathString copyFrom: 1 to: index.			directory := self separator.			pathComponents := OrderedCollection new.			pathString size &gt; index				ifTrue: [  pathComponents := Filename components: 						( pathString copyFrom: index + 1 to: pathString size ) ] ].	pathComponents size &gt; 0 ifTrue: [		1 to: pathComponents size do: [ :currentIndex | | pathElement saveDirectory |			pathElement := pathComponents at: currentIndex.			pathElement = self separator				ifTrue: [ directory := self separator ]				ifFalse: [ pathElement = '..' 					ifTrue:[ directory := directory asFilename head.						directory last ~= Filename separator ifTrue: [ directory := directory , self separator ] ]					ifFalse: [ pathElement = '.'						ifFalse: [ saveDirectory := directory.							directory := self constructPath: 								( self constructPath: directory with: pathElement ) with: self separator.							( ( (self pathExists: (self constructPath: volume with: directory ) )  and: 							[ (self constructPath: volume with: directory ) asFilename isDirectory ] ) and:							[ ( self stringHasWildcard: pathElement ) not ] )								ifFalse: [ filenameExists 									ifTrue: [										directory := self constructPath: saveDirectory with: self separator.										( self pathExists: volume , self separator ) 											ifFalse: [ self setVolumeAsEmpty.												directory := self separator ].										self volumeName retractInterestsFor: self.										self volumeName value: volume.										self volumeName onChangeSend: #changedVolume to: self.										directoryName := directory.										^pathComponents size - ( currentIndex - 1 ) ]									ifFalse: [ ^pathComponents size - ( currentIndex - 1 ) ] ] ] ] ] ] ].	( self pathExists: volume )		ifFalse: [ self setVolumeAsEmpty.			directory := self separator ].	self volumeName retractInterestsFor: self.	self volumeName value: volume.	self volumeName onChangeSend: #changedVolume to: self.	directoryName := directory.	^0</body><body package="VRForms">pathExists: aString"Private - check if path is valid, handle exceptions, and return a boolean"	^self class pathExists: aString</body><body package="VRForms">processEnteredPath	"Private - Handles input for user specified path."	| leftovers pathComponents |	self path value isEmpty not 		ifTrue: [  leftovers := self updatePath: self path value.			self path retractInterestsFor: self.			leftovers = 1					ifTrue: [ 					pathComponents := Filename components: self path value.					( self stringHasWildcard: pathComponents last )						ifFalse: [ self okPressed ] ]."entering input = clicking OK button"			leftovers = 0 "if valid string, clear input field"				ifTrue: [ self okPressed ].			( leftovers &gt; 1 and: [ self directoryMustExist = false ] )				ifTrue: [ self okPressed ].			self path onChangeSend: #enteredPath to: self ]</body><body package="VRForms">stringHasWildcard: aString	"Private - check if string has * or ? chars"	^( ( aString includes: $* ) or: [ aString includes: $? ] )</body><body package="VRForms">updatePath: aPathString	"Private - Handles input for user specified path."	| leftovers pathComponents|  	pathComponents := Filename components: aPathString . 	leftovers := self parsePath: aPathString accountForFilename: self directoryMustExist not.	( leftovers = 1 and: [ self stringHasWildcard: pathComponents last ] )		ifTrue: [ self updateCurrentDirectoryContents: pathComponents last ]		ifFalse: [ self updateCurrentDirectoryContents: nil.			leftovers = 0 ifTrue: [ self path: ( self buildPath: String new ) ] ].	^leftovers</body><body package="VRForms">volumeExists: aVolumeName"Private - check if aVolumeName exists within volumeNames"	| volumeString |	( volumeString := aVolumeName ) last ~= Filename separator		ifTrue: [ volumeString := volumeString , self separator ].	( self stringHasWildcard: volumeString ) ifTrue: [ ^nil ].		^self volumeNames value detect: [ :volume |  		volumeString match: volume ] ifNone: [ 		( volumeString includes: self separator )					ifTrue: [ ( self pathExists: volumeString )				ifTrue: [ ^volumeString ]				ifFalse: [ ^nil ] ] ].</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>events</category><body package="VRForms">changedDirectory	"Private - The selection in the Directory list widget has occurred.  Update	the input field with the revised path. "	( self directoryNames selectionIndex = 0 )	ifFalse: [ ( self directoryNames selection = '..' )		ifTrue: [ self directoryName: '..' ]		ifFalse: [ self directoryName: ( self constructPath: self directoryName 			with: self directoryNames selection ) ] ]</body><body package="VRForms">changedVolume	"Private - The volume has so update the current directory as root."	| newDir | 	self rememberedPaths at: oldVolume put: self directoryName.	newDir := self rememberedPaths at: self volumeName value ifAbsent: [nil].	self oldVolume: self volumeName value.	( self pathExists: self volumeName value )		ifTrue: [ newDir notNil				ifTrue: [self directoryName: newDir]				ifFalse: [self directoryName: self separator ]]		ifFalse: [ "Drive is not valid eg empty floppy so set list as empty"			directoryName := self separator.			self setVolumeAsEmpty.			self setDirectoryLabel ]</body><body package="VRForms">keyboardEvent: ev	"Private - If the event is an escape then do a cancel"	ev keyValue = Character esc		ifTrue: [ self accept value: false.				self closeRequest.				^nil ].	ev keyValue = Character cr		ifTrue: [			( self builder componentAt: #cancelButton ) widget controller =				self builder keyboardProcessor currentConsumer				ifTrue: [ 					self accept value: false.					self closeRequest.					^nil ].			( ( self builder componentAt: #directoryNamesWidget ) widget controller =				self builder keyboardProcessor currentConsumer and: 				[ self directoryNames selectionIndex ~= 0 ] )				ifTrue: [ self changedDirectory.					^nil ]				ifFalse: [					self builder keyboardProcessor forceGlobalAccept.					( self builder componentAt: self getTextInputField ) 						widget controller selectAll.					self processEnteredPath.					^nil ] ].	^ev</body><body package="VRForms">updateCurrentDirectoryContents: filterString"Private  - This method handles the interaction with the filing system when the user navigates through the directory structure. directoryNames, which hold the subdirectories within a particular directory, is updated with new values."	| temp fullList list dList originalCursor entryFullPath |	originalCursor := Cursor currentCursor.	Cursor wait showWhile: [	( self pathExists: self volumeName value )	ifFalse: [ self setVolumeAsEmpty ]	ifTrue:		[ Filename errorReporter errorSignal			handle: [:ex |				directoryNames list: List new.				originalCursor show.				^nil ]			do: [temp := ( self buildPath: String new ) asFilename.					list := temp directoryContents asSortedCollection.					fullList := ( temp filesMatching: '*' ) asSortedCollection].		dList := List new.		list with: fullList do: [ :directoryEntry :directoryEntryPath |				entryFullPath := Filename concreteClass new named: directoryEntryPath.			entryFullPath  isReadable				ifTrue:[ entryFullPath isDirectory					ifTrue: [ filterString isNil						ifTrue:[ dList add: directoryEntry]						ifFalse: [ ( filterString match: directoryEntry )							ifTrue:[ dList add: directoryEntry ] ] ] ] ].		( self directoryName asString match: self directoryName asFilename head ) 			ifFalse: [ dList addFirst: '..' ]. "if not at top of dir hierarchy"		directoryNames list: dList ] ]</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>accessing</category><body package="VRForms">directoryMustExist	"Answer a boolean value whether the dialog can specify a path to a non existent directory."	^directoryMustExist</body><body package="VRForms">directoryMustExist: aBoolean	"Assign aBoolean value whether the dialog can specify a path to a non existent directory."	directoryMustExist := aBoolean</body><body package="VRForms">directoryName	"Answer the directory which the dialog currently is referencing."	^directoryName</body><body package="VRForms">directoryName: aDirectory	"Assign the directory path the dialog box will point to.  The argument should be 	of the format \path where \ is the current OS file separator.  	Do not pass the volume."	| wildcardPattern textInputString val |	openedDialog		ifTrue: [	Object errorSignal					handle: [:ex | ex proceed]					do: [val := aDirectory isEmpty not].					val ifTrue: [ 			textInputString := ( self perform: self getTextInputField ) value.			( ( self stringHasWildcard: textInputString )  and:			[ ( Filename components: textInputString ) size = 1 ] )				ifTrue: [ wildcardPattern := textInputString ]				ifFalse: [ wildcardPattern := String new ].		self updatePath: ( self constructPath: aDirectory with: wildcardPattern ) ] ]		ifFalse: [ directoryName := aDirectory ]</body><body package="VRForms">directoryNames	"Private - List of current subdirectories within current hierarchy"	^directoryNames</body><body package="VRForms">directoryNames: aNamesList	"Private - Assign a list of current subdirectories within current hierarchy"	directoryNames := aNamesList</body><body package="VRForms">getTextInputField	"Private"	^#path</body><body package="VRForms">oldVolume	^oldVolume</body><body package="VRForms">oldVolume: aValue	oldVolume := aValue</body><body package="VRForms">path	"Client supplied fully specified path"	^path</body><body package="VRForms">path: aString	"Client supplied fully specified path"	self path value: aString</body><body package="VRForms">rememberedPaths	^rememberedPaths</body><body package="VRForms">rememberedPaths: aValue	rememberedPaths := aValue</body><body package="VRForms">separator	"OS specific separator as a String"	^self class separator</body><body package="VRForms">setDirectoryLabel	"Private - Update the label which specifies the current path"	| newPath |	self builder notNil		ifTrue: [ 				newPath :=  self buildPath: String new.			newPath ~= self path value				ifTrue: [ self path: newPath ] ]</body><body package="VRForms">title	"Return the string that is to be displayed on the dialog's title bar"	^title</body><body package="VRForms">title: aTitle	"Assign the string that is to be displayed on the dialog's title bar"	title := aTitle</body><body package="VRForms">volumeName	"The current volume value"	^volumeName</body><body package="VRForms">volumeName: aVolume	"Set volume for inital display of dialog.  The argument must be a member of the current	 collection of volumes; otherwise the default volume is used."	openedDialog 		ifTrue: [			aVolume ~= self volumeName value ifTrue: [ 				( self volumeExists: aVolume )					ifTrue: [ self volumeName value: aVolume ]					ifFalse: [ self volumeName value isNil 						ifTrue: [ self volumeName value: self class currentVolume ]						ifFalse: [ ( self volumeExists: self volumeName value ) notNil							ifTrue: [ self volumeName value: self volumeName value ]							ifFalse: [ self volumeName value: self class currentVolume ] ] ] ] ]		ifFalse: [ self volumeName value: aVolume ]</body><body package="VRForms">volumeNames	"Private - current list of volume names which appear in the volumes combo box"	^volumeNames</body><body package="VRForms">volumeNames: aVolumeNameCollection	"Private - Assign the collection of volumes which can be selected in File Dialog."	volumeNames := aVolumeNameCollection asValue</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>initialize-release</category><body package="VRForms">initialize	super initialize.	directoryNames := SelectionInList new.	volumeName := '' asValue.	volumeNames := Filename volumes asList asValue.	path := '' asValue.	directoryName := ''.	directoryMustExist := true.	openedDialog := false.	rememberedPaths := Dictionary new</body><body package="VRForms">initializeNotification	"Private - update dependencies"	self volumeName onChangeSend: #changedVolume to: self.	self path onChangeSend: #enteredPath to: self.	(self builder componentAt: #directoryNamesWidget) widget controller setDispatcher:		(UIDispatcher new doubleClick: [self changedDirectory]).	self builder keyboardProcessor			keyboardHook:  [:ev :ctrl | self keyboardEvent: ev].	self title isNil ifFalse: [ self builder window label: self title ].</body><body package="VRForms">initVolumeAndDirectory	"private - initialize and check the volume and directory values from client."	| tempArray |	self class updateCurrentPath.	self path notNil		ifTrue: [ ( self pathExists: self path value )			ifTrue: [ ^self updatePath: self path value ] ].	tempArray := self setInitialState: self volumeName value directoryName: self directoryName.	self volumeName retractInterestsFor: self.	self volumeName value: ( tempArray at: 1 ).	directoryName := tempArray at: 2.	self oldVolume: self volumeName value.	self rememberedPaths at: self oldVolume put: directoryName.	self volumeName onChangeSend: #changedVolume to: self.	( ( ( Filename components: directoryName ) first = '.' or: 	[ ( Filename components: directoryName ) first = '..' ] )		ifTrue: [ ( self parsePath: directoryName			accountForFilename: false ) ~= 0 ]		ifFalse: [ ( self parsePath: ( self buildPath: String new )			accountForFilename: false ) ~= 0 ] )			ifTrue: [ self volumeName value: self class currentVolume.				directoryName := self class currentDirectory ].	self updatePath: self directoryName</body><body package="VRForms">setInitialState: volume directoryName: directory"Private - setup initial volume and directory depending upon user info provided. This method guarantees that both the volume and directory will have a value, although it does not check for validity."	| tempVolume tempDirectory components |	tempVolume := nil.	tempDirectory := nil.	directory isEmpty		ifTrue: [  volume isEmpty "vol but no dir, so root"			ifFalse: [ tempVolume := volume.				tempDirectory := self separator ] ] 		ifFalse: [ components := Filename components: directory. 			 ( ( components first = '.' or: [ components first = '..' ] ) or: [ volume isEmpty ] )				ifTrue: [ tempVolume := self class currentVolume.					components first = '.' ifTrue: [ tempDirectory := self class currentDirectory ].					components first = '..' ifTrue: [ tempDirectory := self class currentDirectory asFilename head ].					tempDirectory notNil						ifTrue: [ components size &gt; 1							ifTrue: [ 2 to: components size do: [ :anElement | 							tempDirectory := self constructPath: tempDirectory 								with: ( components at: anElement ) ] ] ]						ifFalse: [ tempDirectory := directory ] ]				ifFalse: [ tempVolume := volume.					tempDirectory := directory ] ].	( self pathExists: ( self constructPath: tempVolume with: tempDirectory ) )		ifFalse: [ tempVolume := self class currentVolume.			tempDirectory := self class currentDirectory ].	^Array with: tempVolume with: tempDirectory</body><body package="VRForms">setLabels	"Open the dialog"	| fontDesc charAttr textAttr label |	label := ComposedText new.	fontDesc := (TextAttributes defaultNoCopy characterAttributes defaultQueryFor: nil) copy.	fontDesc pixelSize: ( fontDesc pixelSize min: 16 ).	charAttr := CharacterAttributes newWithDefaultAttributes.	charAttr setDefaultQuery: fontDesc.	textAttr := TextAttributes characterAttributes: charAttr.	self class labels do: [ :component |		label :=  ( self builder componentAt: component ) widget label text string asComposedText.		label textStyle: textAttr.		label compositionWidth: label width.		( self builder componentAt: component ) label: label ]</body><body package="VRForms">setVolumeAsEmpty	"Private - Found a volume that is not valid, eg floppy drive with no floppy.  Set the list of 	directories as empty"	directoryNames list: List new.</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>actions</category><body package="VRForms">okPressed	"Private - Method handler for the open or save button."	(self directoryMustExist)	ifTrue: [ ( self pathExists: self path value )		ifTrue: [ self accept value: true ]		ifFalse: [ Dialog warn: '"' , self path value, '" does not exist.' ] ]	ifFalse: [ 		( self directoryPathIsValid: self path value ) 			ifTrue: [ ^self accept value: true ].		Dialog warn: '"' , self path value , '" is not a valid file path.' ]</body><body package="VRForms">open	"Open a Directory dialog box which allows the selection of a directory path.  	If OK is pressed, then a string indiciating a full path is answered.  	Cancel answers nil."	| spec |	self builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self allButOpenFrom:spec.	self initializeNotification.	self initVolumeAndDirectory.	Filename volumeSeparator isNil		ifTrue: [ ( self builder componentAt: #volumeNamesWidget ) beInvisible.			( self builder componentAt: #volumeLabel ) beInvisible ].	openedDialog := true.	self setLabels.	"kludgy fix, must move part after open or list box defaults to wrong look policy"	self postOpenBlock: [  :dialog :uiBuilder | 		partMoveBy notNil ifTrue: [ ( self builder componentAt: #compPart ) moveBy: partMoveBy ] ].	self builder openDialog.	(self accept value)		ifFalse: [ ^nil ]		ifTrue: [ self saveDialogState.			^(self constructPath: self path value 				with: self separator ) ]</body><body package="VRForms">saveDialogState	"Private - save the state so it can be restored next time the dialog is opened."	self class currentDirectory: self directoryName.	self class currentVolume: self volumeName value</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>private</category><body package="VRForms">widget: aWidget	"Private - Set the widget for the receiver."	^self loadFromWidget: aWidget</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">constructPath: aString1 with: aString2	| newString |	( aString1 isNil or: [ aString1 isEmpty ] )		ifTrue: [ ^ aString2 ]		ifFalse: [ 	( ( newString := aString1 ) last = Filename volumeSeparator )			ifTrue: [ newString := newString , self separator ].			aString2 notNil				ifTrue: [ 					Object errorSignal						handle: [:ex | ^newString last = Filename separator								ifTrue: [ newString , aString2 ]								ifFalse: [ newString, self separator, aString2 ] ]						do: [^newString asFilename constructString: aString2]]				ifFalse: [ ^newString ] ]</body><body package="VRForms">currentDirectory	"Return the directory that the user last accessed from the directory or file selection dialogs. 	This currently gets updated only when the user presses OK"	CurrentDirectory isNil ifTrue: [ CurrentDirectory := self getDefaultDirectoryName ].	^CurrentDirectory</body><body package="VRForms">currentDirectory: aDirectory	"Assign the directory that the user last accessed from the directory or file 	selection dialogs.  This currently gets updated only when the user presses OK"	CurrentDirectory := aDirectory</body><body package="VRForms">currentVolume	"Return the volume that the user last accessed from the directory or file selection dialogs.  	This currently gets updated only when the user presses OK"	( CurrentVolume isNil or: [ CurrentVolume isEmpty ] ) ifTrue: 		[ CurrentVolume := self getDefaultVolumeName ].	^CurrentVolume</body><body package="VRForms">currentVolume: aVolume	"Assign the volume that the user last accessed from the directory or file selection dialogs.  	This currently gets updated only when the user presses OK"	CurrentVolume := aVolume</body><body package="VRForms">getDefaultDirectoryName	"Get the initial volume to the volume specified in the default directory."	|temp dirName|	dirName := ''.	temp := Filename components: Filename defaultDirectory asString.	temp removeFirst.	temp do: [:anElement | dirName := dirName, self separator, anElement].	^dirName, self separator</body><body package="VRForms">getDefaultVolumeName	"Get the initial volume to the volume specified in the default directory."	| volumeString |	volumeString := ( Filename components: Filename defaultDirectory asString ) first.	volumeString last ~= Filename separator 		ifTrue: [ volumeString := volumeString , self separator ].	^self getSystemVolumeNames 		detect: [ :volume | volume match: volumeString ] 		ifNone: [ ^self getSystemVolumeNames first ]</body><body package="VRForms">getSystemVolumeNames	"Get the list of volumes available within the entire system.  This list of volumes is the default"	^Filename volumes</body><body package="VRForms">initialize	"CommonDirectorySelectionDialog initialize"	self currentVolume: nil.	self currentDirectory: nil.</body><body package="VRForms">labels	"Private - IDs for label and button widgets.  Used to pass font information to these static	text widgets"	^OrderedCollection withAll: #( 		#pathLabel		#volumeLabel		#directoryLabel		#okButton		#cancelButton )</body><body package="VRForms">pathExists: aString	"Check if a path string exists.  Return a boolean"	| result pathString components |	( aString isNil or: [ aString isEmpty ] ) ifTrue: [ ^false ].	self separator notNil 		ifTrue: [ ( aString occurrencesOf: Filename volumeSeparator ) &gt; 1			ifTrue: [ ^false ] ].	components := Filename components: aString. 	 ( components first = '.' or: [ components first = '..' ] ) 		ifTrue: [ 			components first = '.' 				ifTrue: [ pathString := self constructPath: self currentVolume 					with: self currentDirectory ].			components first = '..' 				ifTrue: [ pathString := self constructPath: self currentVolume 					with: self currentDirectory asFilename head ].		components size &gt; 1			ifTrue: [ 2 to: components size do: [ :anElement | 				anElement = '.' ifFalse: [					anElement = '..' 						ifTrue: [ pathString := pathString asFilename head ]						ifFalse: [ pathString := self constructPath: pathString with: ( components at: anElement ) ] ] ] ] ]		ifFalse: [ pathString := aString ].	Object errorSignal		handle: [:ex | result := false. ex return]		do: [result := pathString asFilename definitelyExists].	^result</body><body package="VRForms">separator	^String with: Filename separator</body><body package="VRForms">updateCurrentPath	"Check if the CurrentVolume and CurrentDirectory is as valid path.  If not reset"	( self currentVolume isEmpty )		ifTrue: [ ( self pathExists: self currentDirectory )			ifFalse: [ self currentVolume: self getDefaultVolumeName.				self currentDirectory: self getDefaultDirectoryName ] ]		ifFalse: [ ( self pathExists: ( self constructPath: self currentVolume with: self currentDirectory ) )			ifFalse: [ self currentVolume: self getDefaultVolumeName.				self currentDirectory: self getDefaultDirectoryName ] ]</body></methods><methods><class-id>Core.FormattingStream</class-id> <category>stream api</category><body package="VRForms">at: aKey put: aString	"store a constant string"	self constants at: aKey put: aString</body><body package="VRForms">indent	"indent one width in"	self indent: 1</body><body package="VRForms">indent: anInteger	"indent anInteger places"	anInteger timesRepeat: [self nextPut: Character space]</body><body package="VRForms">nextPutAll: aCollection width: anInteger	"dump collection with the default width"	" 0 indicates normal formatting"	anInteger = 0		ifTrue: [self nextPutAll: aCollection].	aCollection size &gt; anInteger		ifTrue: [self nextPutAll: (aCollection copyFrom: 1 to: anInteger)]		ifFalse: [ | diff | 					diff := anInteger - aCollection size.					self nextPutAll: aCollection.					diff timesRepeat: [self nextPut: Character space]].</body><body package="VRForms">nextPutHTML: aCollection width: anInteger	"dump collection with the default width - HTML"	" 0 indicates normal formatting"	anInteger = 0		ifTrue: [self nextPutAll: aCollection].	aCollection size &gt; anInteger		ifTrue: [self nextPutAll: (aCollection copyFrom: 1 to: anInteger)]		ifFalse: [ | diff | 					diff := anInteger - aCollection size.					self nextPutAll: aCollection.					diff timesRepeat: [self nextPut: '&amp;nbsp']].</body><body package="VRForms">restoreFrom: aFile	"restore the dictionary from a boss file"	| bos |	bos := BinaryObjectStorage onOldNoScan: aFile asFilename readStream.	self constants: bos next.	bos close.</body><body package="VRForms">storeTo: aFile	"store the dictionary to a boss file"	| bos |	bos := BinaryObjectStorage onNew: aFile asFilename writeStream.	bos nextPut: self constants.	bos close.</body><body package="VRForms">write: aKey	"write a keyed value"	self write: aKey indented: 0</body><body package="VRForms">write: aKey indented: anInteger	"place the constant (keyed by aKey) at the indented position"	self indent: anInteger.	self nextPutAll: (constants at: aKey)</body></methods><methods><class-id>Core.FormattingStream</class-id> <category>accessing</category><body package="VRForms">constants	"if asked for, user wants to store constant strings"	constants isNil ifTrue: [self constants: IdentityDictionary new].	^constants</body><body package="VRForms">constants: aValue	constants := aValue</body><body package="VRForms">width	"since initialize is not normally sent to streams, need to do this	here"	width isNil		ifTrue: [self width: self class defaultWidth].	^width</body><body package="VRForms">width: aValue	width := aValue</body></methods><methods><class-id>Core.FormattingStream class</class-id> <category>As yet unclassified</category><body package="VRForms">defaultWidth	^DefaultWidth</body><body package="VRForms">defaultWidth: aValue	DefaultWidth := aValue</body><body package="VRForms">initialize	"FormattingStream initialize"	self defaultWidth: 0</body></methods><methods><class-id>UI.VRTableCanvas</class-id> <category>accessing</category><body package="VRForms">columnLabelsArray: anArray	self table columnLabelsArray: anArray</body><body package="VRForms">rowLabelsArray: anArray	self table rowLabelsArray: anArray</body><body package="VRForms">table	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^table isNil		ifTrue:			[table := TableInterface new selectionInTable: SelectionInTable new]		ifFalse:			[table]</body><body package="VRForms">table: aTableAdaptorForList 	self table selectionInTable table: aTableAdaptorForList</body></methods><methods><class-id>UI.VRTableCanvas</class-id> <category>initialize-release</category><body package="VRForms">initializeTable: labels aspects: symbols widths: lengths data: data	"set up the table"	|   rows |	self table selectionInTable: SelectionInTable new.	self table columnLabelsArray: labels.	self table columnWidths: lengths.	rows := RowAdaptor adaptForAspects: symbols.	self table table: (TableAdaptorForList on: data adaptors: rows).</body><body package="VRForms">initializeTableWithRowLabels: rowLabels columnLabels: colLabels aspects: symbols widths: lengths data: data 	"set up the table"	"	self table selectionInTable: SelectionInTable new."	| rows |	(rowLabels notNil and: [rowLabels isEmpty not])		ifTrue: [self table rowLabelsArray: rowLabels].	self table columnLabelsArray: colLabels.	self table columnWidths: lengths.	rows := RowAdaptor adaptForAspects: symbols.	self table table: (TableAdaptorForList on: data adaptors: rows)</body></methods><methods><class-id>UI.VRTableCanvas</class-id> <category>selection</category><body package="VRForms">selection	"answer the selection - assumed to be a row"	self table selectionInTable selectionIndex y = 0 ifTrue: [^nil].	^self table selectionInTable tableHolder value rowAt: self table selectionInTable selectionIndex y</body></methods><methods><class-id>UI.VRTableCanvas class</class-id> <category>As yet unclassified</category><body package="VRForms">on: data fields: fields aspects: aspects widths: widths	"create on a dataset"	^self new 		initializeTable: fields 		aspects: aspects 		widths: widths 		data: data</body><body package="VRForms">on: data rowLabels: rowLabels columnLabels: colLabels aspects: aspects widths: widths 	"create on a table"	^self new		initializeTableWithRowLabels: rowLabels		columnLabels: colLabels		aspects: aspects		widths: widths		data: data</body></methods><methods><class-id>UI.VRExceptionDialog</class-id> <category>accessing</category><body package="VRForms">accept	self parent notNil ifTrue: [self parent builder window raise].	self closeRequest</body><body package="VRForms">dataList	^dataList isNil		ifTrue: [dataList := SelectionInList new]		ifFalse: [dataList]</body><body package="VRForms">dataList: aValue	dataList := aValue.	self changed: #dataList</body><body package="VRForms">errorDescription	^errorDescription isNil		ifTrue: [errorDescription := String new asValue]		ifFalse: [errorDescription]</body><body package="VRForms">errorDescription: aValue	errorDescription := aValue asValue.	self changed: #errorDescription</body><body package="VRForms">modal	^modal</body><body package="VRForms">modal: aBoolean 	modal := aBoolean</body><body package="VRForms">parent	^parent</body><body package="VRForms">parent: aForm 	parent := aForm</body></methods><methods><class-id>UI.VRExceptionDialog</class-id> <category>initialize-release</category><body package="VRForms">initialize	self modal: true</body><body package="VRForms">initialize: errorMessage 	self errorDescription value: errorMessage.	self modal: true</body></methods><methods><class-id>UI.VRExceptionDialog</class-id> <category>api</category><body package="VRForms">open: aSpec 	"open aSpec in non-modal form"	self parent open: self interface: #dbErrorSpec</body><body package="VRForms">openDBError	"open the db error screen"	| theSpec |	theSpec := #dbErrorSpec.	self modal		ifTrue: [self openModal: theSpec]		ifFalse: [self open: theSpec]</body><body package="VRForms">openError	"open the error screen"	| theSpec |	theSpec := #windowSpec.	self modal		ifTrue: [self openModal: theSpec]		ifFalse: [self open: theSpec]</body><body package="VRForms">openListError	"open the listbox error screen"	| theSpec |	theSpec := #listSpec.	self modal		ifTrue: [self openModal: theSpec]		ifFalse: [self open: theSpec]</body><body package="VRForms">openModal: aSpec 	"open aSpec in modal mode"	self parent simpleDialog openFor: self interface: aSpec</body></methods><methods><class-id>UI.VRExceptionDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">from: aParent 	^self new parent: aParent</body><body package="VRForms">new	^super new initialize</body><body package="VRForms">new: errorMessage 	^self new errorDescription: errorMessage</body><body package="VRForms">new: errorMessage parent: anAppModel 	| inst |	inst := self new.	inst errorDescription: errorMessage.	inst parent: anAppModel.	^inst</body></methods><methods><class-id>UI.CommonPrompter</class-id> <category>accessing</category><body package="VRForms">initialAnswer	"Returns the string initially displayed in the text input widget"	^initialAnswer</body><body package="VRForms">initialAnswer: aString	"Assign the string initially displayed in the text input widget"	initialAnswer := aString</body><body package="VRForms">message 	"The string displayed in the message portion of the dialog"	^message</body><body package="VRForms">message: aMessage	"The string displayed in the message portion of the dialog"	message value: aMessage</body><body package="VRForms">title	"Returns the string to be displayed in the window title bar"	^title</body><body package="VRForms">title: aTitle	"Assign the string to be displayed in the window title bar"	title := aTitle</body></methods><methods><class-id>UI.CommonPrompter</class-id> <category>initialize-release</category><body package="VRForms">initialize	"Private"	super initialize.	self title: ''.	message := ''  asValue.	self initialAnswer: ''.</body></methods><methods><class-id>UI.CommonPrompter</class-id> <category>actions</category><body package="VRForms">open	"open the dialog"	| spec string textWidth textHeight composedMessage layout |	string := ValueHolder with: self initialAnswer asString.	spec := (self class interfaceSpecFor: #windowSpec).	self allButOpenFrom:spec.	composedMessage := self message value asComposedText.	layout := (self builder componentAt: #messageArea) layout.	textWidth := composedMessage width + 20.	textWidth &gt; (Screen default bounds width  / 2)		ifTrue: [ textWidth := (Screen default bounds right  / 2).			composedMessage compositionWidth: textWidth ].	textHeight :=composedMessage height.	layout right &lt; ( layout left + textWidth + 20 )		ifTrue: [ layout right: layout left + textWidth + 20 ].	layout bottom: layout top + textHeight.	(self builder componentAt: #messageArea) layout: layout.	self setInitialGap.	self addGap: 15.	self addGap: textHeight + 10.	self addTextLine: string.	self addGap: 10.	self addOK: [true].	self addGap: 20.	self preOpen.	self builder window label: self title.	self builder openDialogWithExtent: 		( ( layout left + layout right ) max: self builder window extent x ) @ 		self builder window displayBox extent y.	^self accept value		ifTrue: [string value]		ifFalse: [nil].</body></methods><methods><class-id>UI.CommonPrompter class</class-id> <category>As yet unclassified</category><body package="VRForms">openPrompter: aString	^self openPrompter: aString initialAnswer: ''</body><body package="VRForms">openPrompter: aString initialAnswer: answer	^self openPrompter: aString initialAnswer: answer title: ''</body><body package="VRForms">openPrompter: aString initialAnswer: answer title: title	| inst |	inst := self new.	inst message: aString.	inst initialAnswer: answer.	inst title: title.	^inst open</body></methods><methods><class-id>UI.VRPagingForm</class-id> <category>api</category><body package="VRForms">addNewItem: anItem	| index |	self modelSL list add: anItem.	index := self modelSL list indexOf: anItem.	self modelSL selectionIndex: index</body><body package="VRForms">customizeBuiltSpec: aSpec	"change the spec to use the actual embedded canvas" 	(aSpec componentSpec collection at: 1) majorKey: (self dataView class name).	^aSpec</body><body package="VRForms">customizeEmbeddedSubcanvas: spec	^self dataView customizeEmbeddedSubcanvas: spec</body></methods><methods><class-id>UI.VRPagingForm</class-id> <category>private</category><body package="VRForms">atBinding: aKey put: aValue	self bindings at: aKey put: aValue</body><body package="VRForms">bindingsFor: aKey	^self bindings at: aKey ifAbsent: [nil]</body><body package="VRForms">hasDynamicBindings	^true</body><body package="VRForms">setCountLabel: aCount	| label |	aCount = 0		ifTrue: [label := 'No Items']		ifFalse: [label := aCount printString,  ' of ', self modelSL list size printString].	self label: #countLabel withString: label</body></methods><methods><class-id>UI.VRPagingForm</class-id> <category>accessing</category><body package="VRForms">bindings	^bindings</body><body package="VRForms">bindings: aValue	bindings := aValue</body><body package="VRForms">constantData	^constantData</body><body package="VRForms">constantData: aValue	constantData := aValue</body><body package="VRForms">dataView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dataView</body><body package="VRForms">dataView: aValue	dataView := aValue</body><body package="VRForms">modelSL	^model</body><body package="VRForms">modelSL: aValue	model isNil		ifTrue: [model := SelectionInList with: aValue]		ifFalse: [model list: aValue]</body><body package="VRForms">newLabel	^newLabel</body><body package="VRForms">newLabel: aValue	newLabel := aValue</body><body package="VRForms">windowLabel	^windowLabel</body><body package="VRForms">windowLabel: aValue	windowLabel := aValue</body></methods><methods><class-id>UI.VRPagingForm</class-id> <category>events</category><body package="VRForms">changedView	"changed the model underneath"	| idx |  	idx := (self modelSL selectionIndex) max: 1.	self dataView model value: (self modelSL list at: idx).	self dataView useConstantData: self constantData.	self dataView customizeClient.	self dataView owner: self.	self setCountLabel: (self modelSL selectionIndex)</body><body package="VRForms">update: anAspect with: aValue from: aModel	self class messageNotUnderstoodSignal		handle: [:ex | ex return]		do: [self perform: anAspect with: aValue]</body></methods><methods><class-id>UI.VRPagingForm</class-id> <category>actions</category><body package="VRForms">firstObject	self modelSL selectionIndex: 1</body><body package="VRForms">lastObject	self modelSL selectionIndex: self modelSL list size</body><body package="VRForms">nextObject	| idx | 	idx := (self modelSL selectionIndex) max: 1.	idx &lt; self modelSL list size ifTrue: [self modelSL selectionIndex: idx + 1]</body><body package="VRForms">prevObject	| idx |	idx := self modelSL selectionIndex.	idx &gt; 1 ifTrue: [self modelSL selectionIndex: idx - 1]</body></methods><methods><class-id>UI.VRPagingForm</class-id> <category>interface control</category><body package="VRForms">hideCloseButton	self beInvisible: #close</body><body package="VRForms">noHideButton	showCloseButton := false</body><body package="VRForms">postBuildWith: bldr	| count |	super postBuildWith: bldr.	self uiSession servesScreen		ifTrue: [bldr window label: self newLabel].	showCloseButton		ifFalse: [self beInvisible: #close].	self dataView customizeClient.	self dataView addDependent: self.	count := self modelSL list size.	count = 0		ifTrue: [self setCountLabel: 0]		ifFalse: [self setCountLabel: 1].	self modelSL selectionIndexHolder onChangeSend: #changedView to: self.	self windowLabel notNil		ifTrue: [self builder window label: self windowLabel]</body></methods><methods><class-id>UI.VRPagingForm</class-id> <category>initialize-release</category><body package="VRForms">initialize	super initialize.	self modelSL: (SelectionInList with: List new).	showCloseButton := true.	self bindings: IdentityDictionary new.</body><body package="VRForms">initWith: aList on: aContainedForm	"set up for the new list"	self modelSL list: aList.	self dataView: (aContainedForm initWith: (aList at: 1)).	self dataView owner: self.	self modelSL selectionIndexHolder onChangeSend: #changedView to: self</body><body package="VRForms">release	"release the dependency"	self modelSL notNil		ifTrue: [self modelSL selectionIndexHolder retractInterestsFor: self ].	self dataView removeDependent: self.	super release</body></methods><methods><class-id>UI.VRPagingForm class</class-id> <category>instance creation</category><body package="VRForms">initWith: aList on: aContainedForm	^self new initWith: aList on: aContainedForm</body><body package="VRForms">on: aList detailForm: aClassName	| form |	form := self getInstanceFrom: aClassName.	^self initWith: aList on: form</body><body package="VRForms">openWith: aList on: aContainedFormClass from: anIfc	^self openWith: aList on: aContainedFormClass from: anIfc withSpec: #windowSpec</body><body package="VRForms">openWith: aList on: aContainedFormClass  from: anIfc withSpec: aSpec	| inst |	inst := self new initWith: aList on: aContainedFormClass.	^anIfc open: inst interface: aSpec</body></methods><methods><class-id>UI.VRPagingForm class</class-id> <category>private</category><body package="VRForms">getInstanceFrom: aSymbolOrClass	| inst cls |	aSymbolOrClass isBehavior		ifTrue: [^aSymbolOrClass new].	cls := Root allClasses detect: [:each | each name = aSymbolOrClass] ifNone: [nil].	inst := cls isNil		ifTrue: [self error: 'Not Found']		ifFalse: [cls new].^inst</body></methods><methods><class-id>UI.ProcessWatcher</class-id> <category>api</category><body package="VRForms">fork: aBlock at: aPriority	" fork a process; save the proc handle so we can terminate it "	| newBlock watcher |	watcher := self.	newBlock := [aBlock value. watcher stop].	priority := (aPriority - 20) min: 100.	proc := newBlock forkAt: aPriority.	Cursor normal showWhile: [self openInterface: self type]</body><body package="VRForms">killProc	"kill the process; restore the cursor to normal"	self cancel value: true.	proc terminate.</body><body package="VRForms">stop	"close the window; the process completed"	self cancel value: true</body></methods><methods><class-id>UI.ProcessWatcher</class-id> <category>initialize-release</category><body package="VRForms">initialize: aBlock with: aPriority	"set up our priority for the interrupt"	priority := aPriority.	self fork: aBlock at: aPriority</body></methods><methods><class-id>UI.ProcessWatcher</class-id> <category>accessing</category><body package="VRForms">message	^message</body><body package="VRForms">message: aValue	message := aValue asValue</body><body package="VRForms">type	^type</body><body package="VRForms">type: aType	type := aType</body></methods><methods><class-id>UI.ProcessWatcher class</class-id> <category>As yet unclassified</category><body package="VRForms">fork: aBlock	"fork a block at the default priority"	self fork: aBlock with: 'Executing... Please Wait'</body><body package="VRForms">fork: aBlock with: aMessage	"fork a block at the default priority"	self fork: aBlock with: aMessage at: Processor userBackgroundPriority</body><body package="VRForms">fork: aBlock with: aMessage at: aPriority	"fork a block at the default priority"	^self fork: aBlock with: aMessage at: aPriority type: #windowSpec</body><body package="VRForms">fork:  aBlock with: aMessage at: aPriority type: aSpec	"fork a block at the default priority"	| inst |	inst := self new.	inst type: aSpec.	inst message: aMessage.	inst initialize: aBlock with: aPriority</body><body package="VRForms">forkCancel: aBlock	"fork a block to cancel at the default priority"	| message aPriority|	aPriority := Processor userBackgroundPriority.	message := 'Press &lt;Cancel&gt; to Terminate'.	self fork: aBlock with: message at: aPriority type: #cancelSpec</body><body package="VRForms">forkCancel: aBlock with: aMessage	"fork a block to cancel at the default priority"	| message aPriority|	aPriority := Processor userBackgroundPriority.	message := (aMessage, '\Press &lt;Cancel&gt; to Terminate') withCRs.	self fork: aBlock with: message at: aPriority type: #cancelSpec</body></methods><methods><class-id>UI.AbstractVRLoginForm</class-id> <category>api</category><body package="VRForms">failed	"answer true if dbModel has reported an exception"	^self dataModel fail</body><body package="VRForms">login	"assume the interface of our abstract dbModel class and try to login"	self dataModel login: self user value password: self pass value.	self failed 		ifTrue: [self reportError: self dataModel reason]		ifFalse: [self enable: #logout.				self disable: #login.				self navigateToNext]</body><body package="VRForms">logout	"log out of the database"	self dataModel databaseLogout.	self enable: #login.	self disable: #logout</body><body package="VRForms">navigateToNext	"navigate to the next interface"	^self subclassResponsibility</body></methods><methods><class-id>UI.AbstractVRLoginForm</class-id> <category>initialize-release</category><body package="VRForms">initialize	"set up defaults"	super initialize.	(self registry includes: self)		ifFalse: [self registry at: self class name put: self].	self dataModel: self class dataModelClass new</body></methods><methods><class-id>UI.AbstractVRLoginForm</class-id> <category>accessing</category><body package="VRForms">pass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pass isNil		ifTrue:			[pass := String new asValue]		ifFalse:			[pass]</body><body package="VRForms">user	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^user isNil		ifTrue:			[user := String new asValue]		ifFalse:			[user]</body></methods><methods><class-id>UI.AbstractVRLoginForm class</class-id> <category>As yet unclassified</category><body package="VRForms">dataModelClass	"answer the class that will be used for  db access"	^self subclassResponsibility</body><body package="VRForms">logo	"answer a logo - by default, the PPD logo"	^Image parcPlaceLogo</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>file utils</category><body package="VRForms">addCommonFilter	self addFilter: '*.pcl' description: 'Parcels'.	self addFilter: '*.st' description: 'ST Source'.	self addFilter: '*.txt' description: 'Text Files'.	self addFilter: '*.*' description: 'All Files'.	self filter: '*.*'</body><body package="VRForms">addFilter: aFilter description: aDescription	"Add an entry into the filters dictionary which becomes the filter list for the dialog box.  The 	description is the text to be displayed.  aFilter is the filter string used for matching 	eg. var addFilter: '*.txt' description: 'Text Files' "	self filters value add: (aFilter-&gt;aDescription).</body><body package="VRForms">addFilters: anArray	"add a set of filters"	anArray do: [:each |		self addFilter: each filter description: each description].	self filter: (anArray at: 1) filter</body><body package="VRForms">filterToString: anAssociation	"Private - convert from a filter to its description"	anAssociation = '' 		ifTrue:[^nil]		ifFalse:[^anAssociation value]</body><body package="VRForms">processEnteredPath	"Private - Handles input for user specified path."	| leftovers pathComponents |		self fileName value isEmpty not 		ifTrue: [  leftovers := self updatePath: self fileName value.			pathComponents := Filename components: self fileName value.			self fileName retractInterestsFor: self. 			leftovers = 1"Filename was given as last element of path"				ifTrue: [ self fileName value: pathComponents last. 					( self stringHasWildcard: pathComponents last ) not						ifTrue: [ self okPressed ] ].			leftovers = 0 "Entered a directory"				ifTrue: [ self fileName value: String new ].			self fileName onChangeSend: #enteredPath to: self ]</body><body package="VRForms">setVolumeAsEmpty	"Private - Found a volume that is not valid, eg floppy drive with no floppy.  Set the list of 	directories and files as empty"	super setVolumeAsEmpty.	fileNames list: List new.</body><body package="VRForms">stringToFilter: aString	"Private - Convert from a filter description to the filter"	filters value do: [ :anElement | aString = anElement value 		ifTrue: [ ^anElement ] ]</body><body package="VRForms">updatePath: aPathString	"Private - Handles input for user specified path."	| leftovers pathComponents|	pathComponents := Filename components: aPathString .	leftovers := self parsePath: aPathString accountForFilename: true.	leftovers &gt; 1		ifTrue: [ Dialog warn: '"' , ( self buildPath: aPathString) , '" is not a valid path.' ]		ifFalse: [ self setDirectoryLabel.			( leftovers = 1 and: [ self stringHasWildcard: pathComponents last ] )				ifTrue: [ self updateCurrentDirectoryContents: pathComponents last ]				ifFalse: [ self updateCurrentDirectoryContents: nil ] ].	^leftovers</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>events</category><body package="VRForms">changedDirectory	"Private - A click in the Directory list widget has occurred and we must update."	super changedDirectory.	self fileNames selection: self fileName value</body><body package="VRForms">changedFile	"Private - Update the file name input field with the file selected in the file List box."	(self fileNames selection = 0 | self fileNames selection isNil)		ifFalse: [ self fileName retractInterestsFor: self.			self fileName: self fileNames selection.			self fileName onChangeSend: #enteredPath to: self ]</body><body package="VRForms">enteredPath	"Private - Handles input for user specified path."		self builder keyboardProcessor focusIsShifting ifFalse: [ ^self ].	self processEnteredPath</body><body package="VRForms">updateCurrentDirectoryContents: filterString	"Private - open the current directory and update directoryNames and fileNames instance variables	 with the contents of the directory"	| temp list fullList dList fList originalCursor filterPattern entryFullPath |	filterString isNil 		ifTrue: [ self filters value isEmpty			ifTrue:[ filterPattern := '' ]			ifFalse: [ filterPattern := self filter value key ] ]		ifFalse: [ filterPattern := filterString ].	originalCursor := Cursor currentCursor.	Cursor wait showWhile: [	( self pathExists: self volumeName value )	ifTrue:		[ Object errorSignal			handle: [:ex | directoryNames list: List new.				fileNames list: List new.				originalCursor show.				^nil ]			do: [temp := ( self buildPath: String new ) asFilename.					list := temp directoryContents asSortedCollection.					fullList := ( temp filesMatching: '*' ) asSortedCollection].		dList := List new.		fList := List new.		list with: fullList do: [ :directoryEntry :directoryEntryPath |			entryFullPath := Filename concreteClass new named: directoryEntryPath.			entryFullPath  isReadable				ifTrue:[ entryFullPath  isDirectory					ifTrue: [ dList add: directoryEntry ]					ifFalse: [ filterPattern isEmpty						ifTrue:[ fList add: directoryEntry ]						ifFalse: [ ( filterPattern match: directoryEntry )							ifTrue:[ fList add: directoryEntry ] ] ] ] ].		( self directoryName asString match: self directoryName asFilename head )			ifFalse: [ dList addFirst: '..' ]. "if not at top of dir hierarchy"		directoryNames list: dList.		fileNames list: fList ] ]</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>accessing</category><body package="VRForms">fileMustExist	"Specifies whether the file name specified must exist within the system in order to accept"	^fileMustExist</body><body package="VRForms">fileMustExist: aBoolean	"Specifies whether the file name specified must exist within the system in order to accept"	fileMustExist := aBoolean</body><body package="VRForms">fileName	"Returns the filename.ext string"	fileName isNil ifTrue: [ fileName := String new asValue ].	^fileName</body><body package="VRForms">fileName: aName	"Assign the filename.ext"	aName ~= self fileName value ifTrue: [ self fileName value: aName ]</body><body package="VRForms">fileNames	"Private - List of filenames within the current subdirectories"	^fileNames</body><body package="VRForms">fileNames: aNameCollection	"Private - assign the list of filenames within the current subdirectories"	fileNames := aNameCollection</body><body package="VRForms">filter	"Returns the current filter in effect"	^filter</body><body package="VRForms">filter: aFilter	"Assign the default filter value for File Dialog. The filter must exist within the list of filters or this 	operation is ignored.  If no filter is provided then all files are displayed."	filter value:  aFilter.</body><body package="VRForms">filters	"Collection of current active filters"	^filters</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>private</category><body package="VRForms">getTextInputField	^#fileName</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>initialize-release</category><body package="VRForms">initialize	"Private - Initialize dialog to have default values."	super initialize.	fileName := String new asValue.	filter := '' asValue.	filters := List new asValue.	title := String new.	fileNames := SelectionInList new.	fileMustExist := false.	promptForOverwrite := false.</body><body package="VRForms">initializeNotification	"Private - update dependencies"	super initializeNotification. 	self filter onChangeSend: #updateCurrentDirectoryContents: to: self.	self fileName onChangeSend: #enteredPath to: self.	fileNames selectionIndexHolder onChangeSend: #changedFile to:self.	(self builder componentAt: #fileNamesList) widget controller setDispatcher:		(UIDispatcher new doubleClick: [self fileName value = '' ifFalse: [accept value: true]]).</body><body package="VRForms">setDirectoryLabel	"Private - Update the label which specifies the current path"	|labelWidgetWrapper|	(labelWidgetWrapper := self builder componentAt: #directoryLabel) isNil		ifFalse: [ labelWidgetWrapper labelString: ( self buildPath: String new ) ]</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>api</category><body package="VRForms">okPressed	"Private - check if path is valid."	( ( self pathExists: ( self buildPath: self fileName value ) ) and:  	[ ( self buildPath: self fileName value ) asFilename isDirectory not] )		ifTrue: [ self promptForOverwrite "valid file exists on the system"			ifTrue: [ ( Dialog confirm: ( self buildPath: self fileName value ), ' exists. Overwrite?' )					ifTrue: [ self accept value: true ] ]			ifFalse: [ self accept value: true ].			^self ].	self fileMustExist 		ifTrue:  [ Dialog warn: '"' , self fileName value , '" does not exist.' ]		ifFalse: [ ( self filenameIsValid: self fileName value )			ifTrue: [ self accept value: true ]			ifFalse: [ Dialog warn: '"' , self fileName value , '" is not a valid file path.' ] ]</body><body package="VRForms">open	"Open the dialog box for opening files. "	self title isEmpty ifTrue: [self title: 'Open'].	^self openDialog: 'Open'</body><body package="VRForms">openDialog: acceptButtonString	"Private - Create and display a File Dialog box."	| spec saveFileName |	self filters value isEmpty		ifTrue: [ self filter: String new ]		ifFalse: [ self filter value isEmpty			ifTrue:[ self filter: ( self filters value at: 1 ) ]			ifFalse:[ self filter: ( self filters value 				detect: [ :filterEntry | self filter value = filterEntry key ] 				ifNone:[ self filters value at: 1 ] ) ] ].	saveFileName := self fileName value. 	self builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self allButOpenFrom:spec.	openedDialog := true.	self builder window label: self title.	self initializeNotification.	self initVolumeAndDirectory.	( self builder componentAt: #acceptButton ) labelString: acceptButtonString.	self setLabels.	Filename volumeSeparator isNil		ifTrue: [ ( self builder componentAt: #volumeNamesWidget ) beInvisible.				( self builder componentAt: #volumeLabel ) beInvisible ].	self fileName: saveFileName.	self fileNames selection: saveFileName.	openedDialog := true.	self builder openDialog.	( self accept value )		ifFalse: [ ^nil ]		ifTrue: [ self fileName value = nil			ifTrue: [ ^nil ]			ifFalse: [ self saveDialogState.				^self buildPath: self fileName value ] ]</body><body package="VRForms">promptForOverwrite	"display message box prompting user to overwrite existing file"	^promptForOverwrite</body><body package="VRForms">promptForOverwrite: aBoolean	"display message box prompting user to overwrite existing file"	promptForOverwrite := aBoolean</body><body package="VRForms">save	"Open a dialog for 'Save As' file"	self title isEmpty ifTrue: [ self title: 'Save As' ].	^self openDialog: 'Save'</body></methods><methods><class-id>UI.CommonFileSelectionDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">labels	^OrderedCollection withAll: #( #fileLabel		#fileTypeLabel		#filenameLabel		#volumeLabel		#DirectoryLabel		#acceptButton		#cancelButton )</body><body package="VRForms">openFile	| inst |	inst := self new.	inst addCommonFilter.	^inst open</body><body package="VRForms">openFileWithFilter: filterArray	| inst |	inst := self new.	inst addFilters: filterArray.	^inst open</body><body package="VRForms">saveFile	| inst |	inst := self new.	inst addCommonFilter.	^inst save</body><body package="VRForms">saveFileWithFilter: filterArray	| inst |	inst := self new.	inst addFilters: filterArray.	^inst save</body></methods><methods><class-id>UI.VRDetailForm</class-id> <category>api</category><body package="VRForms">accept	"perform acceptance based on mode"	super accept.	self perform: self editMode.	self parent notNil		ifTrue: [self returnToParent]</body><body package="VRForms">add	"adding a new entity"	^self</body><body package="VRForms">cancel	"leave actions here to concrete subclasses"	super cancel.	self parent notNil		ifTrue: [self returnToParent]</body><body package="VRForms">disableEditButtons	self disable: #(#accept #cancel)</body><body package="VRForms">edit	"accepting an edit"	^self</body><body package="VRForms">enableEditButtons	self enable: #(#accept #cancel)</body><body package="VRForms">returnToParent	"raise parent window if have it"	self parent builder window raise</body><body package="VRForms">showEditModeButtons	^false</body></methods><methods><class-id>UI.VRDetailForm</class-id> <category>interface control</category><body package="VRForms">customizeClient	^self</body><body package="VRForms">customizeEmbeddedSubcanvas: spec	"we are embedded, and subcanvases son't &lt;do the right thing&gt;.  So fix it"	^spec</body><body package="VRForms">postBuildWith: bldr	super postBuildWith: bldr.	self showEditModeButtons		ifTrue: [bldr addSpec: (UISpecification from: self class editSpec)].	self windowLabel notNil		ifTrue: [self builder window label: self windowLabel]</body><body package="VRForms">useConstantData: data	"data cached in paging form that may be needed"	^self</body></methods><methods><class-id>UI.VRDetailForm</class-id> <category>editing</category><body package="VRForms">editMode	^editMode</body><body package="VRForms">editMode: aValue	editMode := aValue</body></methods><methods><class-id>UI.VRDetailForm</class-id> <category>initialize-release</category><body package="VRForms">initialize	super initialize.	self editMode: #edit</body><body package="VRForms">initWith: aModel	(self model isNil)		ifTrue: [self model: aModel asValue]		ifFalse: [self model value: aModel]</body></methods><methods><class-id>UI.VRDetailForm</class-id> <category>accessing</category><body package="VRForms">owner	^owner</body><body package="VRForms">owner: aValue	owner := aValue</body><body package="VRForms">parent	^self</body><body package="VRForms">parent: aValue	parent := aValue</body><body package="VRForms">windowLabel	^windowLabel</body><body package="VRForms">windowLabel: aValue	windowLabel := aValue</body></methods><methods><class-id>UI.VRLoginForm</class-id> <category>accessing</category><body package="VRForms">detailFormName	"interface to provide a detail form name for the follow on form"	^nil</body><body package="VRForms">usesTable	^usesTable</body><body package="VRForms">usesTable: aValue	usesTable := aValue</body></methods><methods><class-id>UI.VRLoginForm</class-id> <category>private-navigation</category><body package="VRForms">navigateTo: ifc with: data	"allows for easier modifications of generated forms"	| pageForm |	pageForm := VRPagingForm initWith: data on: ifc.	self open: pageForm interface: #windowSpec</body><body package="VRForms">navigateToNextForm	| data ifc queryData |	queryData := self class sqlQuery.	data := self dataModel doSQLQuery: (queryData at: 1) forClass: (queryData at: 2).	ifc := self answerFromRegistry: self class nextIFC.	self navigateTo: ifc with: data.</body><body package="VRForms">navigateToNextTabular	| data ifc queryData |	queryData := self class sqlQuery.	data := self dataModel doSQLQuery: (queryData at: 1) forClass: (queryData at: 2).	ifc := self answerFromRegistry: self class nextIFC.	self navigateToTable: ifc with: data</body><body package="VRForms">navigateToTable: ifc with: data	"allows for easier modifications of generated forms"	ifc initializeTable: data from: ifc tableSpec.	ifc detailForm: self detailFormName.	self open: ifc interface: #windowSpec</body></methods><methods><class-id>UI.VRLoginForm</class-id> <category>api</category><body package="VRForms">navigateToNext	self usesTable		ifTrue: [self navigateToNextTabular]		ifFalse: [self navigateToNextForm]</body></methods><methods><class-id>UI.VRLoginForm class</class-id> <category>As yet unclassified</category><body package="VRForms">nextIFC	^#''</body><body package="VRForms">sqlQuery	"answer SQL and table"	^#('' #'')</body></methods><methods><class-id>UI.VRTableViewer</class-id> <category>accessing</category><body package="VRForms">aspects	^aspects</body><body package="VRForms">aspects: aValue	aspects := aValue</body><body package="VRForms">columnLabels	^columnLabels</body><body package="VRForms">columnLabels: aValue	columnLabels := aValue.	self changed: #columnLabels</body><body package="VRForms">dataList	^dataList</body><body package="VRForms">dataList: aValue 	dataList := aValue.	(self pageAmount isNil or: [self pageAmount = 0])		ifTrue: [self pageAmount: self defaultTableLength]</body><body package="VRForms">defaultTableLength	^self class defaultTableLength</body><body package="VRForms">fields	^fields</body><body package="VRForms">fields: aValue	fields := aValue</body><body package="VRForms">index	^index</body><body package="VRForms">index: aValue	index := aValue</body><body package="VRForms">pageAmount	^(pageAmount isNil or: [pageAmount = 0])		ifTrue: [self class defaultTableLength]		ifFalse: [pageAmount]</body><body package="VRForms">pageAmount: aValue	pageAmount := aValue</body><body package="VRForms">rowLabelsBlock	^rowLabelsBlock</body><body package="VRForms">rowLabelsBlock: aValue	rowLabelsBlock := aValue.	self changed: #rowLabelsBlock</body><body package="VRForms">table	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^table isNil		ifTrue:			[table := VRTableCanvas new]		ifFalse:			[table]</body><body package="VRForms">tableSubCanvas	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableSubCanvas isNil		ifTrue:			[tableSubCanvas := VRTableCanvas new]		ifFalse:			[tableSubCanvas]</body><body package="VRForms">widths	^widths</body><body package="VRForms">widths: aValue	widths := aValue</body></methods><methods><class-id>UI.VRTableViewer</class-id> <category>initialize-release</category><body package="VRForms">dataList: data pageBy: pageSize	"set up defaults"	self dataList: data.	self pageAmount: pageSize</body><body package="VRForms">initialize	"set up index"	super initialize.	self pageAmount: self defaultTableLength.	self index: 1.</body><body package="VRForms">initializeTable: labels aspects: symbols widths: lengths 	"set up the table"	self		initializeTableWithRowLabelsBlock: nil		columnLabels: labels		aspects: symbols		widths: lengths.	self aspects: symbols.	self columnLabels: labels.	self widths: lengths</body><body package="VRForms">initializeTableWithRowLabelsBlock: rLabelsBlock columnLabels: cLabels aspects: symbols widths: lengths 	"set up the table"	self aspects: symbols.	self rowLabelsBlock: rLabelsBlock.	self columnLabels: cLabels.	self widths: lengths.	self resetTable</body></methods><methods><class-id>UI.VRTableViewer</class-id> <category>api</category><body package="VRForms">first	"beginning of list"	self index: 1.	self resetTable</body><body package="VRForms">last	"end of list"	self index: (self dataList size - (self pageAmount - 1) max: 1).	self resetTable</body><body package="VRForms">next	"move forward"	| end |	end := self index + self pageAmount.	end &gt; self dataList size ifTrue: [end := self dataList size - (self pageAmount - 1) max: 1].	self index: end.	self resetTable</body><body package="VRForms">prev	"move backwards in the table of data"	| end |	end := self index - self pageAmount.	end &lt; 1 ifTrue: [end := 1].	self index: end.	self resetTable</body><body package="VRForms">selection	^self tableSubCanvas selection</body></methods><methods><class-id>UI.VRTableViewer</class-id> <category>private</category><body package="VRForms">getData	"answer a list of pageAmount elements from current index forward"	| end list |	end := self index + (self pageAmount - 1).	end &gt; self dataList size ifTrue: [end := self dataList size].	list := (self dataList copyFrom: self index to: end) asList.	^list</body><body package="VRForms">resetTable	"give table new data to force scroll - must alter row labels as they are different for each row"	| displayedData rLabels |	displayedData := self getData.	self rowLabelsBlock notNil ifTrue: [(rLabels := self rowLabelsBlock value: displayedData) isEmpty not ifTrue: [self tableSubCanvas rowLabelsArray: rLabels]].	self tableSubCanvas columnLabelsArray: self columnLabels.	self tableSubCanvas table columnWidths: self widths.	self tableSubCanvas table: (TableAdaptor on: displayedData adaptors: (RowAdaptor adaptForAspects: self aspects))</body><body package="VRForms">setLabels: labelArray withJustification: aSymbol	| tableModel |	tableModel := self tableSubCanvas table.	tableModel columnLabelsArray: labelArray.	tableModel columnLabelsFormats: aSymbol</body></methods><methods><class-id>UI.VRTableViewer</class-id> <category>interface control</category><body package="VRForms">noCloseButton	self disable: #close</body></methods><methods><class-id>UI.VRTableViewer class</class-id> <category>As yet unclassified</category><body package="VRForms">defaultTableLength	^DefaultTableLength</body><body package="VRForms">empty	"self empty"	^self		on: #()		rowLabelsBlock: nil		columnLabels: #()		aspects: #()		widths: #()</body><body package="VRForms">example1	"self example1"	^self		on: VRTableExamplePerson example		rowLabelsBlock: nil		columnLabels: #('ID' 'Name' 'Salary')		aspects: #(#id #name #salary)		widths: #(100 300 150)</body><body package="VRForms">initialize	"VRTableViewer initialize"	DefaultTableLength := 10</body><body package="VRForms">on: data aspects: aspects widths: widths 	"convenience - no row or column labels, use default table length"	^self		on: data		rowLabelsBlock: nil		columnLabels: #()		aspects: aspects		widths: widths		tableLength: self defaultTableLength</body><body package="VRForms">on: data fields: fields aspects: aspects widths: widths	"create on a dataset"	| inst |	inst := self new dataList: data pageBy: DefaultPage.	inst initializeTable: fields aspects: aspects widths: widths.	^inst</body><body package="VRForms">on: data rowLabelsBlock: rLabelsBlock columnLabels: cLabels aspects: aspects widths: widths 	"convenience - use default table length"	^self		on: data		rowLabelsBlock: rLabelsBlock		columnLabels: cLabels		aspects: aspects		widths: widths		tableLength: self defaultTableLength</body><body package="VRForms">on: data rowLabelsBlock: rLabelsBlock columnLabels: cLabels aspects: aspects widths: widths tableLength: length 	"create on a table"	| inst |	inst := self new dataList: data pageBy: length.	inst		initializeTableWithRowLabelsBlock: rLabelsBlock		columnLabels: cLabels		aspects: aspects		widths: widths.	^inst</body></methods><methods><class-id>UI.VRTableForm</class-id> <category>api</category><body package="VRForms">add	"add a new entity by popping a detail form"	| detail |	detail := (Smalltalk at: self domainFormClass) new.	detail editMode: #add.	detail parent: self.	detail windowLabel: self windowLabel.	self open: detail interface: #windowSpec.</body><body package="VRForms">edit	"Edit selected object"	| detail domainObject |	domainObject := self webTable selection.	domainObject isNil		ifTrue: [^self].  	detail := self answerFromRegistry: self domainFormClass.	detail model value: domainObject.	detail editMode: #edit.	detail parent: self.	detail windowLabel: self windowLabel.	self open: detail interface: #windowSpec.</body><body package="VRForms">editAll	"bring up a paging form on the list"	| form | 	self webTable dataList  isEmpty		ifTrue: [^self].	form := VRPagingForm 				initWith: self webTable dataList  				on: (Smalltalk at: self domainFormClass) new.	form windowLabel: self windowLabel.	self open: form interface: #windowSpec</body><body package="VRForms">remove	"This stub method was generated by UIDefiner"	"remove selected entity from the list"	|  domainObject |	domainObject := self webTable selection.	domainObject isNil		ifTrue: [^self].	self webTable dataList  remove: domainObject.	self webTable resetTable</body><body package="VRForms">save	"This stub method was generated by UIDefiner"	"save to a formatted file.  NOTE:  Objects in collection must	respond to the #printOntoStream: message"	self class messageNotUnderstoodSignal		handle: [:ex | Dialog 						warn: 'No API defined for Saving this object'						for: self builder window.					ex return]		do: [self printToFile]</body></methods><methods><class-id>UI.VRTableForm</class-id> <category>accessing</category><body package="VRForms">detailForm: aValue	"for compatibility; no-op"</body><body package="VRForms">domainFormClass	^domainFormClass</body><body package="VRForms">domainFormClass: aValue	domainFormClass := aValue</body><body package="VRForms">printHeader	^printHeader</body><body package="VRForms">printHeader: aValue	printHeader := aValue</body><body package="VRForms">printType	^printType</body><body package="VRForms">printType: aValue	printType := aValue</body><body package="VRForms">tableSpec	^tableSpec</body><body package="VRForms">tableSpec: aValue	tableSpec := aValue</body><body package="VRForms">webTable	^webTable</body><body package="VRForms">webTable: aValue	webTable := aValue</body><body package="VRForms">windowLabel	^windowLabel</body><body package="VRForms">windowLabel: aValue	windowLabel := aValue</body></methods><methods><class-id>UI.VRTableForm</class-id> <category>printing support</category><body package="VRForms">flatPrintStream: aStream	"use standard print api"	| dataList count |	dataList := self webTable dataList.	count := 1.	dataList do: [:each |		each printFlatOntoStream: aStream forRecord: count]</body><body package="VRForms">print	"print the objects, with a form feed between each.	NOTE:  Objects in collection must	respond to the #printOntoStream: message"	self class messageNotUnderstoodSignal		handle: [:ex | Dialog 						warn: 'No API defined for Printing this object'						for: self builder window.					ex return]		do: [self printToPrinter]</body><body package="VRForms">producePrintStream: aStream	"do either a flat or report print"	self perform: (self printType, 'PrintStream:') asSymbol with: aStream.</body><body package="VRForms">reportPrintStream: aStream	"use standard print api"	| dataList count |	dataList := self webTable dataList.	count := 1.	dataList do: [:each |		each printOntoStream: aStream forRecord: count]</body></methods><methods><class-id>UI.VRTableForm</class-id> <category>initialize-release</category><body package="VRForms">initialize	super initialize.	self printHeader: 'Print Report For All Records'.	self printType: 'report'</body><body package="VRForms">initializeTable: dataList	"set up table"	self initializeTable: dataList from: self  tableSpec</body><body package="VRForms">initializeTable: dataList from: aSpec	"set up table"	self webTable: VRTableViewer new.	self webTable dataList: dataList.	self webTable 			initializeTable: (aSpec at: 1)			aspects: (aSpec at: 2) 			widths: (aSpec at: 3)</body></methods><methods><class-id>UI.VRTableForm</class-id> <category>interface control</category><body package="VRForms">postBuildWith: bldr	super postBuildWith: bldr.	self windowLabel isNil		ifTrue: [self builder window label: 'Tabular Display Form on: ', self webTable dataList   size printString, ' elements']		ifFalse: [self builder window label: self windowLabel]</body></methods><methods><class-id>UI.VRTableForm class</class-id> <category>As yet unclassified</category><body package="VRForms">on: aList detailForm: aClassName	| inst |	inst := self new.	inst initializeTable: aList.	inst domainFormClass: aClassName.	^inst</body><body package="VRForms">open: aSymbol withPolicy: aPolicy inSession: anApplicationContext	"Open the ApplicationModel's user interface, using the specification 	named and the given look policy and application context."	| spec |	"if web, sub the spec"	self executeForWebOnly: [spec := #webSpec].	spec := aSymbol isSymbol not ifTrue: [ #windowSpec ] ifFalse: [ aSymbol ].	^self new openInterface: spec withPolicy: aPolicy inSession: anApplicationContext</body><body package="VRForms">tableSpec	^#()</body></methods><methods><class-id>UI.TopVRApplicationModel</class-id> <category>initialize-release</category><body package="VRForms">release	super release.	self releaseRegistry</body></methods><methods><class-id>UI.CommonMessageDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">criticalImage	"UIMaskEditor new openOnClass: self andSelector: #criticalImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue red; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; yourself)) usingBits: (ByteArray fromPackedString: '****@@*******(@@@B*****(@@@@@*****@@@@@@**** @@@@@@***(@@@@@@@***@@@@@@@@** @B@@@H@@**@@*@@B(@A* @J*@@*(@A*@@J*@J*@@F(@@J*B* @@V@@@J**(@@@X@@@J**@@@A @@@J* @@@E@@@@**@@@@T@@@J**@@@AP@@B***@@@E @@*(J*@@AV@@J*@J*@@EX@B* @J*@@V(@B(@@J @EZ @B@@@H@@U* @@@@@@@EZ* @@@@@@AU** @@@@@@UZ** @@@@@EV*** @@@@AU****$@@@AUZ****%P@EUV*****)UUUV*******%UZ*** @a'))</body><body package="VRForms">criticalMask	"UIMaskEditor new openOnClass: self andSelector: #criticalMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 15 192 0 0 127 248 0 1 255 254 0 3 255 255 0 7 255 255 128 15 255 255 192 31 255 255 224 63 255 255 240 63 255 255 248 127 255 255 252 127 255 255 252 127 255 255 254 255 255 255 254 255 255 255 254 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 127 255 255 255 127 255 255 255 127 255 255 254 63 255 255 254 63 255 255 254 31 255 255 252 15 255 255 252 7 255 255 248 3 255 255 240 1 255 255 224 0 255 255 192 0 127 255 128 0 31 254 0 0 3 240 0])</body><body package="VRForms">informationImage	"UIMaskEditor new openOnClass: self andSelector: #informationImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: (ByteArray fromPackedString: '****UV*******)V*%Z*****)Z***V*****Z*/:*"****&amp;*+?:*"***)**/?**"***Z**/:**"**&amp;*******"**Z**??***J*&amp;**+?&gt;***F*Z***?:**(Z)***+?***!Z&amp;***/&gt;***E*Z***?:**(V*Z**+?***EZ)**+??:*(U*)**/??**EZ*(******!U**(*****(UZ**(*****EV***(J***AU****)@*(AUZ****)T*EUV******R(UV*******"!Z********"E********* V*********!Z*********%**********&amp;************************* @a'))</body><body package="VRForms">informationMask	"UIMaskEditor new openOnClass: self andSelector: #informationMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 15 128 0 0 127 240 0 1 255 252 0 3 255 254 0 7 255 255 0 15 255 255 128 31 255 255 192 63 255 255 224 63 255 255 224 127 255 255 248 127 255 255 248 127 255 255 252 127 255 255 252 127 255 255 252 63 255 255 252 63 255 255 252 31 255 255 248 15 255 255 248 7 255 255 240 3 255 255 224 1 255 255 192 0 255 255 128 0 127 255 0 0 31 252 0 0 7 224 0 0 3 224 0 0 1 224 0 0 0 224 0 0 0 96 0 0 0 32 0 0 0 0 0 0 0 0 0])</body><body package="VRForms">questionImage	"UIMaskEditor new openOnClass: self andSelector: #questionImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: (ByteArray fromPackedString: '****UV*******)V*%Z*****)Z***V*****Z****"****&amp;*+?:*"***)**:/:*"***Z*/*/:*"**&amp;**?:?**"**Z*+?+&gt;**J*&amp;**+:?***F*Z***/:**(Z)****&gt;***!Z&amp;***/****E*Z***&gt;***(V*Z*******EZ)***/***(U*)**+?***EZ*(**/&gt;**!U**(**/**(UZ**(*****EV***(J***AU****)@*(AUZ****)T*EUV******R(UV*******"!Z********"E********* V*********!Z*********%**********&amp;************************* @a'))</body><body package="VRForms">questionMask	"UIMaskEditor new openOnClass: self andSelector: #questionMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 15 128 0 0 127 240 0 1 255 252 0 3 255 254 0 7 255 255 0 15 255 255 128 31 255 255 192 63 255 255 224 63 255 255 224 127 255 255 248 127 255 255 248 127 255 255 252 127 255 255 252 127 255 255 252 63 255 255 252 63 255 255 252 31 255 255 248 15 255 255 248 7 255 255 240 3 255 255 224 1 255 255 192 0 255 255 128 0 127 255 0 0 31 252 0 0 7 224 0 0 3 224 0 0 1 224 0 0 0 224 0 0 0 96 0 0 0 32 0 0 0 0 0 0 0 0 0])</body><body package="VRForms">warningImage	"UIMaskEditor new openOnClass: self andSelector: #warningImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); yourself)) usingBits: (ByteArray fromPackedString: '**** J********(UJ********EUJ*******(UT********EUT*******(UUR*******EUUR******(UUUJ******EUUUJ*****(UPET******ET@ET*****(UP@UR*****EU@AUR****(UT@EUJ****EUP@UUJ***(UU@AUT****EUU@UUT***(UUTAUUR***EUUPEUUR**(UUU@UUUJ**EUUUEUUUJ*(UUUTUUUT**EUUUUUUUT*(UUUUAUUUR*EUUUPAUUUS(UUUU@EUUUN!UUUUAUUUT&gt;EUUUUUUUUS:EUUUUUUUT?*@@@@@@@@O&gt;*?????????**????????: @a'))</body><body package="VRForms">warningMask	"UIMaskEditor new openOnClass: self andSelector: #warningMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 7 0 0 0 15 128 0 0 31 192 0 0 31 192 0 0 63 224 0 0 63 224 0 0 127 240 0 0 127 240 0 0 255 248 0 0 255 248 0 1 255 252 0 1 255 252 0 3 255 254 0 3 255 254 0 7 255 255 0 7 255 255 0 15 255 255 128 15 255 255 128 31 255 255 192 31 255 255 192 63 255 255 224 63 255 255 224 127 255 255 240 127 255 255 240 255 255 255 252 255 255 255 252 255 255 255 254 255 255 255 254 127 255 255 254 63 255 255 254 31 255 255 252 15 255 255 248])</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 211 112 ) 			#max: #(#Point 211 112 ) 			#bounds: #(#Rectangle 407 328 618 440 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 38 7 ) 					#name: #iconLabel 					#hasCharacterOrientedLabel: false ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 56 15 189 38 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UI.JARApplicationModel class</class-id> <category>As yet unclassified</category><body package="VRForms">firstImage	"UIMaskEditor new openOnClass: self andSelector: #firstRowImage"	&lt;resource: #image&gt;	^Image extent: 16@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 48 132 0 0 49 140 0 0 51 156 0 0 55 188 0 0 63 252 0 0 63 252 0 0 55 188 0 0 51 156 0 0 49 140 0 0 48 132 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="VRForms">lastImage	"UIMaskEditor new openOnClass: self andSelector: #lastImage"	&lt;resource: #image&gt;	^Image extent: 16@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 33 12 0 0 49 140 0 0 57 204 0 0 61 236 0 0 63 252 0 0 63 252 0 0 61 236 0 0 57 204 0 0 49 140 0 0 33 12 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="VRForms">nextImage	"UIMaskEditor new openOnClass: self andSelector: #nextImage"	&lt;resource: #image&gt;	^Image extent: 16@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 16 128 0 0 24 192 0 0 28 224 0 0 30 240 0 0 31 248 0 0 31 248 0 0 30 240 0 0 28 224 0 0 24 192 0 0 16 128 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="VRForms">prevImage	"UIMaskEditor new openOnClass: self andSelector: #prevImage"	&lt;resource: #image&gt;	^Image extent: 16@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 8 0 0 3 24 0 0 7 56 0 0 15 120 0 0 31 248 0 0 31 248 0 0 15 120 0 0 7 56 0 0 3 24 0 0 1 8 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body></methods><methods><class-id>UI.VRApplicationModel class</class-id> <category>As yet unclassified</category><body package="VRForms">errorDialogSpec	"UIPainter new openOnClass: self andSelector: #errorDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec			#label: 'Error Dialog' 			#bounds: #(#Rectangle 63 126 489 303 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CompositeSpecCollection 					#collection: #(						#(#TextEditorSpec							#layout: #(#LayoutFrame 0 0.0 0 0.18125 0 1.0 0 0.74375 ) 							#name: #errorText 							#model: #errorText 							#menu: #errorText ) 						#(#LabelSpec							#layout: #(#LayoutOrigin 0 0.319218 0 0.0 ) 							#name: #appErrorLabel 							#label: 'Application Error !!' ) 						#(#ActionButtonSpec 							#layout: #(#LayoutFrame 0 0.358306 0 0.78125 0 0.641694 0 1.0 ) 							#name: #accept 							#model: #accept 							#label: 'Accept' 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 48 10 355 170 ) ) ) ) ) )</body></methods><methods><class-id>UI.VRListForm class</class-id> <category>interface specs</category><body package="VRForms">webSpec	"UIPainter new openOnClass: self andSelector: #webSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'List Display Form' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 181 139 658 510 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0.00419287 0 0.00539084 0 0.997904 0 0.876011 ) 					#name: #dataList 					#flags: 15 					#model: #dataList 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#doubleClickSelector: #edit ) 					#style: #fixed 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #enforceBoundaryWithGIF true ) 					#layout: #(#LayoutFrame 0 0.00419287 0 0.902965 0 0.134172 0 0.986523 ) 					#name: #edit 					#model: #edit 					#label: 'Edit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #enforceBoundaryWithGIF true ) 					#layout: #(#LayoutFrame 0 0.259958 0 0.902965 0 0.389937 0 0.986523 ) 					#name: #add 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #enforceBoundaryWithGIF true ) 					#layout: #(#LayoutFrame 0 0.387841 0 0.902965 0 0.51782 0 0.986523 ) 					#name: #remove 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #enforceBoundaryWithGIF true ) 					#layout: #(#LayoutFrame 0 0.132075 0 0.902965 0 0.262054 0 0.986523 ) 					#name: #editAll 					#model: #editAll 					#label: 'Edit All' 					#defaultable: true ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #enforceBoundaryWithGIF true ) 					#layout: #(#LayoutFrame 0 0.867924 0 0.902965 0 0.997904 0 0.986523 ) 					#name: #exit 					#model: #closeRequest 					#label: 'Exit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #enforceBoundaryWithGIF true ) 					#layout: #(#LayoutFrame 0 0.515723 0 0.902965 0 0.645702 0 0.986523 ) 					#name: #save 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #enforceBoundaryWithGIF true ) 					#layout: #(#LayoutFrame 0 0.643606 0 0.902965 0 0.773585 0 0.986523 ) 					#name: #print 					#model: #print 					#label: 'Print' 					#defaultable: true ) ) ) )</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'List Display Form' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 201 166 678 537 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0.00419287 0 0.00539084 0 0.997904 0 0.876011 ) 					#name: #dataList 					#flags: 15 					#model: #dataList 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#doubleClickSelector: #edit ) 					#style: #fixed 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.00419287 0 0.902965 0 0.134172 0 0.986523 ) 					#name: #edit 					#model: #edit 					#label: '&amp;Edit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.259958 0 0.902965 0 0.389937 0 0.986523 ) 					#name: #add 					#model: #add 					#label: '&amp;Add' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.387841 0 0.902965 0 0.51782 0 0.986523 ) 					#name: #remove 					#model: #remove 					#label: '&amp;Remove' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.132075 0 0.902965 0 0.262054 0 0.986523 ) 					#name: #editAll 					#model: #editAll 					#label: 'E&amp;dit All' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.867924 0 0.902965 0 0.997904 0 0.986523 ) 					#name: #exit 					#model: #closeRequest 					#label: 'E&amp;xit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.515723 0 0.902965 0 0.645702 0 0.986523 ) 					#name: #save 					#model: #save 					#label: '&amp;Save' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.643606 0 0.902965 0 0.773585 0 0.986523 ) 					#name: #print 					#model: #print 					#label: '&amp;Print' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.CommonListChooser class</class-id> <category>As yet unclassified</category><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 251 123 ) 			#bounds: #(#Rectangle 515 451 766 574 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#Rectangle 12 23 234 58 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 9 43 239 57 ) 					#name: #listWidget 					#flags: 15 					#model: #list 					#multipleSelections: false 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 76 108 104 ) 					#name: #okButton 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 139 76 227 104 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body><body package="VRForms">windowSpecMultipleSelect	"UIPainter new openOnClass: self andSelector: #windowSpecMultipleSelect"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 251 123 ) 			#bounds: #(#Rectangle 515 451 766 574 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#Rectangle 12 23 234 58 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 9 43 239 57 ) 					#name: #listWidget 					#flags: 15 					#model: #list 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 76 108 104 ) 					#name: #okButton 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 139 76 227 104 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Directory' 			#min: #(#Point 355 285 ) 			#max: #(#Point 355 285 ) 			#bounds: #(#Rectangle 399 290 754 575 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#Rectangle 13 29 342 56 ) 					#name: #path 					#model: #path ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 13 83 233 217 ) 					#name: #directoryNamesWidget 					#model: #directoryNames 					#useModifierKeys: true 					#selectionType: #highlight) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 13 241 233 268 ) 					#name: #volumeNamesWidget 					#model: #volumeName 					#comboList: #volumeNames ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 248 83 340 119 ) 					#name: #okButton 					#model: #okPressed 					#label: 'OK' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 248 127 340 163 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#Point 10 8 ) 					#name: #pathLabel 					#label: 'Path:' ) 				#(#LabelSpec 					#layout: #(#Point 11 62 ) 					#name: #directoryLabel 					#label: 'Directory:' ) 				#(#LabelSpec 					#layout: #(#Point 11 220 ) 					#name: #volumeLabel 					#label: 'Drive:' ) ) ) )</body></methods><methods><class-id>UI.VRTableCanvas class</class-id> <category>As yet unclassified</category><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Table' 			#bounds: #(#Rectangle 90 128 560 401 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TableViewSpec 					#layout: #(#LayoutFrame 0 0.00425532 0 0.0 0 0.995745 0 0.996337 ) 					#name: #table 					#model: #table 					#showHGrid: true 					#showVGrid: true 					#selectionStyle: #row ) ) ) )</body></methods><methods><class-id>UI.VRExceptionDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">databaseIcon	"UIMaskEditor new openOnClass: self andSelector: #databaseIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image			extent: 24 @ 24			depth: 3			bitsPerPixel: 4			palette: (MappedPalette withColors: ((Array new: 5)						at: 1 put: ColorValue black;						at: 2 put: ColorValue yellow;						at: 3 put: (ColorValue							scaledRed: 6553							scaledGreen: 6553							scaledBlue: 6553);						at: 4 put: ColorValue white;						at: 5 put: (ColorValue							scaledRed: 1638							scaledGreen: 8191							scaledBlue: 2056); yourself))			usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H"H"H@@@@BH@@@@BH"H"HDQDPBHDQDPBH"H"H@@@@BH@@@@BH"H"H"@"H"H"HBH"H"H"H"@"H"H"HBH"H"H"H"@"H"H"HBH"H"H"H"@"H"H@@@@BH"H"H"@"H"HDQDPBH"H"H"@"H"H@@@@BH"H"H"@"H"H"HBH"H"H"H"@"@@@@@BH"H"H"H"@"@"H"H @@@BH"H"@"@"H"@CL3L0@"H@@@@@H L3L3L3LBHDQDQ@H @CL3L0@BH@@@@@H DP@@@ADBH"H"H"H DQDSDQDBH"H"H"H DQD1LQDBH"H"H"H DQDSDQDBH"H"H"H DQD1LQDBH"H"H"H"@ADSDP@"H"H"H"H"H @@@BH"H"H"H"H"H"H"H"H"'))</body><body package="VRForms">dbErrorSpec	"UIPainter new openOnClass: self andSelector: #dbErrorSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' Database Error' 			#bounds: #(#Rectangle 188 352 584 519 ) 			#colors: 			#(#LookPreferences 				#setForegroundColor: #(#ColorValue #black ) 				#setBackgroundColor: #(#ColorValue 5734 5734 5734 ) 				#setSelectionForegroundColor: #(#ColorValue #black ) 				#setSelectionBackgroundColor: #(#ColorValue 4915 4915 4915 ) 				#setBorderColor: #(#ColorValue #black ) ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 18 32 ) 					#label: 'Database Error Description: ' ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 17 56 341 127 ) 					#name: #errorDescriptionID 					#model: #errorDescription ) 				#(#LabelSpec 					#layout: #(#Point 16 5 ) 					#label: #databaseIcon 					#hasCharacterOrientedLabel: false ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 17 135 69 158 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) ) ) )</body><body package="VRForms">listSpec	"UIPainter new openOnClass: self andSelector: #listSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Error Report' 			#bounds: #(#Rectangle 216 332 615 595 ) 			#colors: 			#(#LookPreferences 				#setForegroundColor: #(#ColorValue #black ) 				#setBackgroundColor: #(#ColorValue 5734 5734 5734 ) 				#setSelectionForegroundColor: #(#ColorValue #black ) 				#setSelectionBackgroundColor: #(#ColorValue 4915 4915 4915 ) 				#setBorderColor: #(#ColorValue #black ) ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Rectangle 17 210 93 241 ) 					#model: #ok 					#label: 'OK' 					#defaultable: true ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 17 9 245 35 ) 					#name: #errorDescription 					#model: #errorDescription 					#isReadOnly: true ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 17 42 245 200 ) 					#name: #dataList 					#model: #dataList 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' Application Error Report' 			#bounds: #(#Rectangle 247 465 643 632 ) 			#colors: 			#(#LookPreferences 				#setForegroundColor: #(#ColorValue #black ) 				#setBackgroundColor: #(#ColorValue 5734 5734 5734 ) 				#setSelectionForegroundColor: #(#ColorValue #black ) 				#setSelectionBackgroundColor: #(#ColorValue 4915 4915 4915 ) 				#setBorderColor: #(#ColorValue #black ) ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 18 32 ) 					#label: 'Application Error Description' ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 17 56 341 127 ) 					#name: #errorDescriptionID 					#model: #errorDescription ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 17 135 69 158 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.CommonPrompter class</class-id> <category>As yet unclassified</category><body package="VRForms">emptySpec"UIPainter new openOnClass: self andSelector: #emptySpec"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 20 20 ) 			#max: #(#Point 1280 1024 ) 			#bounds: #(#Rectangle 486 611 754 650 ) 			#isEventDriven: true ) 		#component: #(#SpecCollection #collection: #() ) )</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 220 114 ) 			#max: #(#Point 220 114 ) 			#bounds: #(#Rectangle 476 377 696 491 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#Rectangle 16 9 146 38 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UI.VRPagingForm class</class-id> <category>interface specs</category><body package="VRForms">smallSpec	"UIPainter new openOnClass: self andSelector: #smallSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'WebPage Form' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 277 156 764 261 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0.00616016 0 0.285714 0 0.989733 0 0.961905 ) 					#name: #dataView 					#flags: 9 					#majorKey: #ApplicationModel 					#minorKey: #windowSpec 					#clientKey: #dataView ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #javaScriptEventHandlers #(#PropertyListDictionary ) ) 					#layout: #(#LayoutFrame 0 0.291581 0 0.0 0 0.468172 0 0.257143 ) 					#name: #next 					#model: #nextObject 					#label: #nextImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.464066 0 0.0 0 0.640657 0 0.257143 ) 					#name: #last 					#model: #lastObject 					#label: #lastImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.638604 0 0.0 0 0.815195 0 0.257143 ) 					#name: #prev 					#model: #prevObject 					#label: #prevImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.813142 0 0.0 0 0.989733 0 0.257143 ) 					#name: #first 					#model: #firstObject 					#label: #firstImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) ) ) )</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'WebPage Form' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 157 98 644 503 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0.00410678 0 0.160494 0 0.997947 0 0.883951 ) 					#name: #dataView 					#flags: 9 					#majorKey: #ApplicationModel 					#minorKey: #windowSpec 					#clientKey: #dataView ) 				#(#ActionButtonSpec 					#properties: #(#PropertyListDictionary #javaScriptEventHandlers #(#PropertyListDictionary ) ) 					#layout: #(#LayoutFrame 0 0.293635 0 0 0 0.470226 0 0.14321 ) 					#name: #next 					#model: #nextObject 					#label: #nextImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.466119 0 0.0 0 0.644764 0 0.14321 ) 					#name: #last 					#model: #lastObject 					#label: #lastImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.640657 0 0.0 0 0.819302 0 0.14321 ) 					#name: #prev 					#model: #prevObject 					#label: #prevImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.815195 0 0.0 0 0.99384 0 0.14321 ) 					#name: #first 					#model: #firstObject 					#label: #firstImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.00616016 0 0.916049 0 0.203285 0 0.987654 ) 					#name: #close 					#model: #closeRequest 					#label: 'Close' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.0143737 0 0.0469136 ) 					#name: #countLabel 					#label: '1 Of 10000' ) ) ) )</body></methods><methods><class-id>UI.ProcessWatcher class</class-id> <category>As yet unclassified</category><body package="VRForms">cancelSpec	"UIPainter new openOnClass: self andSelector: #cancelSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Executing...' 			#bounds: #(#Rectangle 188 239 449 364 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.35249 0 0.56 0 0.655172 0 0.856 ) 					#name: #cancel 					#model: #killProc 					#label: 'Cancel' 					#isDefault: true 					#defaultable: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 0 0.0344828 0 0.184 0 0.969349 0 0.424 ) 					#name: #message 					#flags: 0 					#model: #message 					#tabable: false 					#alignment: #center 					#isReadOnly: true ) ) ) )</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Executing...' 			#bounds: #(#Rectangle 188 239 449 364 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame 0 0.0344828 0 0.368 0 0.969349 0 0.608 ) 					#name: #message 					#flags: 0 					#model: #message 					#tabable: false 					#alignment: #center 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UI.AbstractVRLoginForm class</class-id> <category>As yet unclassified</category><body package="VRForms">loggedInSpec	"UIPainter new openOnClass: self andSelector: #loggedInSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Login Form' 			#bounds: #(#Rectangle 32 50 453 373 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.0617577 0 0.526316 ) 					#name: #usernameID 					#label: 'Username' ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.0617577 0 0.674923 ) 					#name: #passwordID 					#label: 'Password' ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 0 0.315914 0 0.510836 0 0.764846 0 0.582043 ) 					#name: #user 					#model: #user ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 0 0.315914 0 0.671827 0 0.764846 0 0.743034 ) 					#name: #pass 					#model: #pass 					#type: #password ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.0522565 0 0.849462 0 0.254157 0 0.973118 ) 					#name: #login 					#flags: 40 					#model: #login 					#label: 'Login' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.733967 0 0.849462 0 0.935867 0 0.973118 ) 					#name: #logout 					#model: #logout 					#label: 'Logout' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.370546 15 0 ) 					#name: #logo 					#label: #logo 					#hasCharacterOrientedLabel: false ) ) ) )</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Login Form' 			#bounds: #(#Rectangle 32 50 453 373 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.0617577 0 0.526316 ) 					#name: #usernameID 					#label: 'Username' ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.0617577 0 0.674923 ) 					#name: #passwordID 					#label: 'Password' ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 0 0.315914 0 0.510836 0 0.764846 0 0.582043 ) 					#name: #user 					#model: #user ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 0 0.315914 0 0.671827 0 0.764846 0 0.743034 ) 					#name: #pass 					#model: #pass 					#type: #password ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.0522565 0 0.849462 0 0.254157 0 0.973118 ) 					#name: #login 					#model: #login 					#label: 'Login' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.733967 0 0.849462 0 0.935867 0 0.973118 ) 					#name: #logout 					#flags: 40 					#model: #logout 					#label: 'Logout' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.370546 15 0 ) 					#name: #logo 					#label: #logo 					#hasCharacterOrientedLabel: false ) ) ) )</body></methods><methods><class-id>UI.CommonFileSelectionDialog class</class-id> <category>As yet unclassified</category><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 381 256 ) 			#max: #(#Point 381 256 ) 			#bounds: #(#Rectangle 102 122 483 378 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 5 -2 ) 					#name: #filenameLabel 					#label: 'Filename:' ) 				#(#LabelSpec 					#layout: #(#Point 7 177 ) 					#name: #fileTypeLabel 					#label: 'File Type:' ) 				#(#LabelSpec 					#layout: #(#Point 188 46 ) 					#name: #DirectoryLabel 					#label: 'Directory:' ) 				#(#LabelSpec 					#layout: #(#Point 230 177 ) 					#name: #volumeLabel 					#label: 'Drive:' ) 				#(#LabelSpec 					#layout: #(#Point 7 46 ) 					#name: #fileLabel 					#label: 'File:' ) 				#(#LabelSpec 					#layout: #(#Point 249 43 ) 					#name: #directoryLabel 					#style: #small ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 12 17 372 40 ) 					#name: #fileName 					#model: #fileName 					#tabable: true ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 9 65 179 177 ) 					#name: #fileNamesList 					#flags: 15 					#model: #fileNames 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 196 65 372 177 ) 					#name: #directoryNamesWidget 					#flags: 15 					#model: #directoryNames 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 9 197 219 221 ) 					#model: #filter 					#type: #object 					#comboList: #filters 					#readSelector: 					#stringToFilter: 					#printSelector: 					#filterToString: ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 232 196 372 220 ) 					#name: #volumeNamesWidget 					#model: #volumeName 					#comboList: #volumeNames ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 7 228 104 252 ) 					#name: #acceptButton 					#model: #okPressed 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 109 228 204 252 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.VRDetailForm class</class-id> <category>As yet unclassified</category><body package="VRForms">editSpec	"UIPainter new openOnClass: self andSelector: #editSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#bounds: #(#Rectangle 143 90 490 424 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CompositeSpecCollection 					#collection: #(						#(#ActionButtonSpec 							#layout: #(#LayoutFrame 0 0.734104 0 0.0 0 1.0 0 1.0 ) 							#name: #cancel 							#model: #cancel 							#label: 'Cancel' 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#LayoutFrame 0 0.0 0 0.0 0 0.265896 0 1.0 ) 							#name: #accept 							#model: #accept 							#label: 'Accept' 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 1 294 347 333 ) ) ) ) ) )</body></methods><methods><class-id>UI.VRTableViewer class</class-id> <category>As yet unclassified</category><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Web Table Form' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 44 38 602 457 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.293907 0 0.0 0 0.471326 0 0.143198 ) 					#name: #next 					#model: #next 					#label: #nextImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.467742 0 0.0 0 0.645161 0 0.143198 ) 					#name: #last 					#model: #last 					#label: #lastImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.639785 0 0.0 0 0.820788 0 0.143198 ) 					#name: #prev 					#model: #prev 					#label: #prevImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.815412 0 0.0 0 0.994624 0 0.143198 ) 					#name: #first 					#model: #first 					#label: #firstImage 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 -0.00537634 0 0.207637 0 0.996416 0 0.926014 ) 					#name: #tableSubCanvas					#flags: 0 					#majorKey: #VRTableCanvas 					#minorKey: #windowSpec 					#clientKey: #tableSubCanvas ) ) ) )</body></methods><methods><class-id>UI.VRTableForm class</class-id> <category>As yet unclassified</category><body package="VRForms">webSpec	"UIPainter new openOnClass: self andSelector: #webSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Table View' 			#bounds: #(#Rectangle 119 114 681 486 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0.00533808 0 0.00268817 0 0.998221 0 0.981183 ) 					#name: #webTable 					#flags: 0 					#majorKey: #VRTableViewer 					#minorKey: #windowSpec 					#clientKey: #webTable ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.00355872 0 0.913978 0 0.133452 0 0.997312 ) 					#name: #edit 					#model: #edit 					#label: 'Edit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.259786 0 0.913978 0 0.38968 0 0.997312 ) 					#name: #add 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.3879 0 0.913978 0 0.517794 0 0.997312 ) 					#name: #remove 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.131673 0 0.913978 0 0.261566 0 0.997312 ) 					#name: #editAll 					#model: #editAll 					#label: 'Edit All' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.868327 0 0.913978 0 0.998221 0 0.997312 ) 					#name: #exit 					#model: #closeRequest 					#label: 'Exit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.516014 0 0.913978 0 0.645907 0 0.997312 ) 					#name: #save 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.644128 0 0.913978 0 0.774021 0 0.997312 ) 					#name: #print 					#model: #print 					#label: 'Print' 					#defaultable: true ) ) ) )</body><body package="VRForms">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Table View' 			#bounds: #(#Rectangle 119 114 681 486 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0.00533808 0 0.00268817 0 0.998221 0 0.981183 ) 					#name: #webTable 					#flags: 0 					#majorKey: #VRTableViewer 					#minorKey: #windowSpec 					#clientKey: #webTable ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.00355872 0 0.913978 0 0.133452 0 0.997312 ) 					#name: #edit 					#model: #edit 					#label: '&amp;Edit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.259786 0 0.913978 0 0.38968 0 0.997312 ) 					#name: #add 					#model: #add 					#label: '&amp;Add' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.3879 0 0.913978 0 0.517794 0 0.997312 ) 					#name: #remove 					#model: #remove 					#label: '&amp;Remove' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.131673 0 0.913978 0 0.261566 0 0.997312 ) 					#name: #editAll 					#model: #editAll 					#label: 'E&amp;dit All' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.868327 0 0.913978 0 0.998221 0 0.997312 ) 					#name: #exit 					#model: #closeRequest 					#label: 'E&amp;xit' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.516014 0 0.913978 0 0.645907 0 0.997312 ) 					#name: #save 					#model: #save 					#label: '&amp;Save' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.644128 0 0.913978 0 0.774021 0 0.997312 ) 					#name: #print 					#model: #print 					#label: '&amp;Print' 					#defaultable: true ) ) ) )</body></methods><initialize><class-id>UI.CommonMessageDialog</class-id></initialize><initialize><class-id>UI.CommonDirectorySelectionDialog</class-id></initialize><initialize><class-id>Core.FormattingStream</class-id></initialize><initialize><class-id>UI.VRTableViewer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TextStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lengths emphases currentEmphasis runStartPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TableAdaptor</name><environment>UI</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents baseCollection adaptors columnSize transposed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>