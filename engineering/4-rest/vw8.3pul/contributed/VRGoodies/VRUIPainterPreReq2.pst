<?xml version="1.0"?><st-source><!-- Name: VRUIPainterPreReq2Notice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains all the overrides and base level extensions that I have made to the core system (mostly in the UI area) to support my goodies.  A lot of these overrides are in support of the UIDefiner hacks, or the VRDetailForm frameworkDevelopmentPrerequisites: #(#(#any 'VRUIPainterPreReq' ''))PackageName: VRUIPainterPreReq2Parcel: #('VRUIPainterPreReq2')ParcelName: VRUIPainterPreReq2PrerequisiteParcels: #(#('VRUIPainterPreReq' ''))Version: 7Date: 10:22:24 AM November 19, 2015 --><time-stamp>From VisualWorks®, 8.1 of July 17, 2015 on November 19, 2015 at 10:22:24 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ModelDefiner</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameSpace aClass aspects generator stream classLookup uiClassLookup category apiMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>VRUIPainterPreReq2</package></attributes></class><comment><class-id>UI.ModelDefiner</class-id><body>This class works in conjunction with the modified UIDefiner.  If the developer has entered a domain model class, this class' job is to-- define the new class if necessary-- create an appropriate set of variables and initializerThe code is generated based on the the 'type' information entered for each UI object used in the UIPainter tools.Instance Variables:	nameSpace	&lt;Symbol&gt;	The namespace that the new class should reside in	aClass	&lt;Symbol&gt;	Name of the new domain model	aspects	&lt;Collection&gt;	 a collection of string names of attributes	generator	&lt;Class&gt;	 The class that actually generates the code.  This separates us				from Compiler variances	stream	&lt;Stream&gt;	Stream used for generated code	classLookup	&lt;Dictionary&gt;	 keytable of objects to use based on UI aspects	uiClassLookup	&lt;Dictionary&gt;	 keytable of objects to use based on UI aspects	category	&lt;String&gt;	 Category (browser) to use for this class	apiMethods	&lt;Collection&gt;	 names of methods to go behind buttons that exist in the UI</body></comment><class><name>CodingAssistant</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classNameChannel instVarList readAccessing writeAccessing dependency finder fromBrowser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>VRUIPainterPreReq2</package></attributes></class><comment><class-id>Tools.CodingAssistant</class-id><body>CodingAssistant is a simple application that can be used to generate accessing methods for arbitrary classes. An instance of UIDefiner does the real work. Useful in its own right, CodingAssistant demonstrates multi-selection SequenceViews, and the uses of dependency in the coordination of the models underlying the constituent widgets of a user interface.Instance Variables:	classNameChannel	&lt;ValueHolder with: Symbol&gt;  Holds the name of the class	instVarList	&lt;MultiSelectionInList&gt;  Holds the user's indications of which variables are to be provided for	readAccessing	&lt;ValueHolder with: Boolean&gt;  Whether to generate read accessors	writeAccessing	&lt;ValueHolder with: Boolean&gt;  Whether to generate write accessors	dependency	&lt;ValueHolder with: Boolean&gt;  Whether to generate write accessors which send change notification</body></comment><class><name>UIDefiner</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aClass initializeModels excludedBindings aSpec domainModel isBuffered isUpdated defineInstVars useLazyInit hasStartedAspectInitGeneration myDlg </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>VRUIPainterPreReq2</package></attributes></class><comment><class-id>Tools.UIDefiner</class-id><body>UIDefiner is used by UIPainter for automatically generating 'stub' aspect and action methods for newly painted components.  For historical reasons, it also provides some public entries for simple generation of accessor and mutator methods based on instance variables in the class being defined for (see the 'defining' protocol).  When used by the UIPainter, It can generate limited initializations for the models for which it writes accessors, based on the default models employed by UIPainter.  These initializations can optionally be included in the accessors themselves.Instance Variables:	aClass	&lt;Temp class&gt;  Cache of the target class of the UIPainter, so that changes in the target can be detected	initializeModels	&lt;ValueHolder with: Boolean&gt;  Whether or not to include initialization code in the accessors	excludedBindings	&lt;IdentityDictionary key: &lt;Symbol&gt; value: &lt;Object&gt;&gt;  Bindings for which the user is currently declining automatic generation.  The value of the association is the default model</body></comment><methods><class-id>UI.ModelDefiner</class-id> <category>generating</category><body package="VRUIPainterPreReq2">addInstVars: aCollection to: aClassName	| cls |	aClassName isBehavior		ifTrue: [cls := aClassName]		ifFalse: [cls := (self nameSpace bindingFor: aClassName) value].	self generator targetClass: cls.	self generator protocol: #accessing.	self generator isMeta: false.	aCollection do: [:each |		self generator addInstVar: each key asString]</body><body package="VRUIPainterPreReq2">createClass: aClassName	| names env cName |	aClassName isBehavior		ifTrue: [^aClassName]. 	names := self getNamesFrom: aClassName.	env := (BindingReference simpleName: names first) value.	self nameSpace: env.	cName := names last asSymbol.	env defineClass: cName		superclass: #{UI.Model}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: self category.	^env at: cName"	Model subclass: aClassName	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: self category "</body><body package="VRUIPainterPreReq2">generate: theClass varList: aCollection	"generate the class" 	| cls |	cls := self createClass: theClass. 	self aClass: cls.	self aspects: aCollection.	self addInstVars: aCollection to: cls.	self generateAccessorsFor: cls using: aCollection.	self generateAPIMethods.	self generateConstructorFor: cls.	self generateStockComment: cls using: aCollection</body><body package="VRUIPainterPreReq2">generateAccessorsFor: aClassName using: aCollection	self generateGetMethods: aCollection.	self generateSetMethods: aCollection</body><body package="VRUIPainterPreReq2">generateAPIMethods	self apiMethods isNil		ifTrue: [^self].	self generator protocol: 'api'.	self generator isMeta: false.	stream := WriteStream on: (String new: 100).	aClass isSymbol not		ifTrue: [aClass := aClass name].	self apiMethods do: [:each | | apiName |		apiName := each key. 		((self nameSpace at: aClass) selectors includes: apiName)			ifFalse: [				stream reset.				stream nextPutAll: apiName; cr; tab.				stream nextPutAll: '"generated API call from UI"'; cr; cr; tab.				stream nextPutAll: '^self'.				self generator generateMethod: stream]]</body><body package="VRUIPainterPreReq2">generateConstructorFor: aClassName	self generator isMeta: true.	self generator protocol: #'instance creation'.	stream reset.	stream nextPutAll: 'new'.	stream cr; tab.	stream nextPutAll: '^super new initialize'.	self generator generateMethod: stream</body><body package="VRUIPainterPreReq2">generateGetMethods: aCollection	aCollection do: [:each |		stream reset.		stream nextPutAll: each key asString.		stream cr; tab.		stream nextPutAll: '^', each key asString.		self generator generateMethod: stream]</body><body package="VRUIPainterPreReq2">generateSetMethods: aCollection	aCollection do: [:each |		stream reset.		stream nextPutAll: each key asString.		stream nextPutAll: ': aValue'.		stream cr; tab.		stream nextPutAll:  each key asString, ' := aValue.'.		stream cr; tab.		stream nextPutAll: 'self changed: #', each key asString.		self generator generateMethod: stream]</body><body package="VRUIPainterPreReq2">generateStockComment: theClass using: aCollection	"generate a class comment"	self generateStockComment: theClass using: aCollection mapTypes: true</body><body package="VRUIPainterPreReq2">generateStockComment: theClass using: aCollection mapTypes: shouldMap	"generate a class comment"	stream reset.	stream nextPutAll: 'This is the auto-generated comment for class ', theClass name printString.	stream nextPutAll: '.  This comment should be edited for accuracy'.	stream cr; cr.	stream nextPutAll: 'Instance Variables: '; cr; cr.	aCollection do: [:each | |name type |		name := each key asString.		shouldMap			ifTrue: [type := self classTypeFrom: each value  class name]			ifFalse: [type := self uiClassTypeFrom: each value].		stream nextPutAll: name; tab; tab.		stream nextPutAll: '&lt;'.		stream nextPutAll: type, '&gt;'.		stream cr].	theClass comment: stream contents</body><body package="VRUIPainterPreReq2">initializeLists: aCollection andValues: valueSlots	"generate an initialize method"  	self doesModelAlreadyImplementInitialize		ifTrue: [^self].	self generator isMeta: false.	self generator protocol: #'initialize-release'.	stream reset.	stream nextPutAll: 'initialize'.	stream cr; tab.	stream nextPutAll: '"This is an auto-generated initialize method.  It should be updated"'. 	stream cr; tab.	aCollection do: [:each | 		stream nextPutAll: 'self ', each key asString, ':', ' List new.'.		stream cr; tab].	valueSlots do: [:each | | val |		val := each value value printString.		('HTMLText*' match: val)			ifTrue: [val := ''''' asHTMLText'].		stream nextPutAll: 'self ', each key asString, ': ', val.		stream nextPut: $..		stream cr; tab].	self generator generateMethod: stream</body></methods><methods><class-id>UI.ModelDefiner</class-id> <category>accessing</category><body package="VRUIPainterPreReq2">aClass	^aClass</body><body package="VRUIPainterPreReq2">aClass: aValue	aClass := aValue</body><body package="VRUIPainterPreReq2">apiMethods	^apiMethods</body><body package="VRUIPainterPreReq2">apiMethods: aValue	apiMethods := aValue</body><body package="VRUIPainterPreReq2">aspects	^aspects</body><body package="VRUIPainterPreReq2">aspects: aValue	aspects := aValue</body><body package="VRUIPainterPreReq2">category	category isNil		ifTrue: [category := 'Models'].	^category</body><body package="VRUIPainterPreReq2">category: aValue	category := aValue</body><body package="VRUIPainterPreReq2">classLookup	^classLookup</body><body package="VRUIPainterPreReq2">classLookup: aValue	classLookup := aValue</body><body package="VRUIPainterPreReq2">generator	^generator</body><body package="VRUIPainterPreReq2">generator: aValue	generator := aValue</body><body package="VRUIPainterPreReq2">nameSpace	^nameSpace</body><body package="VRUIPainterPreReq2">nameSpace: aValue	nameSpace := aValue</body><body package="VRUIPainterPreReq2">targetClass	^aClass</body><body package="VRUIPainterPreReq2">targetClass: aValue	aClass := aValue</body><body package="VRUIPainterPreReq2">uiClassLookup	^uiClassLookup</body><body package="VRUIPainterPreReq2">uiClassLookup: aValue	uiClassLookup := aValue</body></methods><methods><class-id>UI.ModelDefiner</class-id> <category>private</category><body package="VRUIPainterPreReq2">classTypeFrom: aSymbol	^self classLookup at: aSymbol ifAbsent: ['Undefined'].</body><body package="VRUIPainterPreReq2">doesModelAlreadyImplementInitialize	"check to see if model already implements #initialize.  Return boolean"	| cls |	cls := self generator targetClass.	^cls selectors includes: #initialize</body><body package="VRUIPainterPreReq2">getNamesFrom: aClassName	| str pos cName env |	str := aClassName asString readStream.	str setToEnd.	str skip: -1.	[str position = 1 or: [str peek = $.]]		whileFalse: [str skip: -1].	pos := str position.	pos = 1 		ifTrue: [env := 'Smalltalk'.				cName := aClassName asString]		ifFalse: [str next.			cName := str upToEnd.			str position: pos.			env := aClassName asString copyFrom: 1 to: pos].	^Array with: env with: cName</body><body package="VRUIPainterPreReq2">uiClassTypeFrom: aModel	| modelType type objType string |	modelType := aModel class name.	(aModel respondsTo: #value)		ifTrue: [objType := aModel value class name asString]		ifFalse: [objType := aModel class name asString].	objType first isVowel		ifTrue: [string := 'an ', objType]		ifFalse: [string := 'a ', objType].	type := self uiClassLookup at: modelType ifAbsent: ['Undefined'].	type = 'ValueModel'		ifTrue: [^string]		ifFalse: [^type]</body></methods><methods><class-id>UI.ModelDefiner</class-id> <category>initialize-release</category><body package="VRUIPainterPreReq2">initialize	self generator: VRCodeGeneratorModel new. 	stream := WriteStream on: (String new: 100).	self classLookup: IdentityDictionary new.	self classLookup at: #TableInterface put: 'List'.	self classLookup at: #SelectionInList put: 'List'.	self classLookup at: #MultiSelectionInList put: 'List'.	self classLookup at: #True put: 'Boolean'.	self classLookup at: #False put: 'Boolean'.	self uiClassLookup: IdentityDictionary new.	self uiClassLookup at: #TableInterface put: 'TableInterface'.	self uiClassLookup at: #SelectionInList put: 'SelectionInList'.	self uiClassLookup at: #MultiSelectionInList put: 'MultiSelectionInList'.	self uiClassLookup at: #ValueHolder put: 'ValueModel'.</body></methods><methods><class-id>UI.ModelDefiner class</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">new	^super new initialize</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>initialize-release</category><body package="VRUIPainterPreReq2">classNameChannel: aClassNameHolder	classNameChannel retractInterestIn: #value for: self.	classNameChannel := aClassNameHolder.	classNameChannel onChangeSend: #changedClassName to: self.	self changedClassName</body><body package="VRUIPainterPreReq2">initialize	instVarList := MultiSelectionInList new.	self classNameChannel: nil asValue.	readAccessing := true asValue.	writeAccessing := true asValue.	dependency := false asValue.	writeAccessing onChangeSend: #changedWriteAccessing to: self.	fromBrowser := false.</body><body package="VRUIPainterPreReq2">targetClass	^classNameChannel value</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>interface opening</category><body package="VRUIPainterPreReq2">postBuildWith: aBuilder	classNameChannel value isNil		ifTrue:[(aBuilder componentAt: #defineButton) disable]		ifFalse:[ fromBrowser ifTrue:[ self selectAllInstVars ] ]</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>aspects</category><body package="VRUIPainterPreReq2">className	^classNameChannel</body><body package="VRUIPainterPreReq2">dependency	^dependency</body><body package="VRUIPainterPreReq2">instVarList	^instVarList</body><body package="VRUIPainterPreReq2">readAccessing	^readAccessing</body><body package="VRUIPainterPreReq2">writeAccessing	^writeAccessing</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>private</category><body package="VRUIPainterPreReq2">changedClassName	| cn tc| 	cn := classNameChannel value.	cn == nil		ifTrue:			[builder notNil ifTrue:				[(builder componentAt: #defineButton) disable].			instVarList list: List new]		ifFalse:			[(tc := self targetClass) == nil				ifTrue: [Dialog warn: 'Class ', cn , ' does not exist.' for: builder window.						builder notNil ifTrue:							[(builder componentAt: #defineButton) disable.							instVarList list: List new]]				ifFalse: [instVarList list: tc instVarNames.							builder notNil ifTrue:								[(builder componentAt: #defineButton) enable]]]</body><body package="VRUIPainterPreReq2">changedWriteAccessing	writeAccessing value		ifTrue: [(builder componentAt: #dependency) enable]		ifFalse: [(builder componentAt: #dependency) disable]</body><body package="VRUIPainterPreReq2">chosenInstVarNames	^instVarList selections</body><body package="VRUIPainterPreReq2">doBuildAccessing	| assistant iv |	iv := self chosenInstVarNames.	(iv == nil or: [iv isEmpty]) ifTrue: [^self].	assistant := UIDefiner for: self targetClass.	readAccessing value		ifTrue: [assistant addReadingAccessFor: iv].	writeAccessing value		ifTrue: [dependency value					ifTrue: [assistant addDependencyWritingAccessFor: iv]					ifFalse: [assistant addWritingAccessFor: iv]]</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>actions</category><body package="VRUIPainterPreReq2">apply	self doBuildAccessing</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>tool-support</category><body package="VRUIPainterPreReq2">selectAllInstVars	"select All instVars"	self instVarList selectAll</body><body package="VRUIPainterPreReq2">setFromBrowserTrue	fromBrowser := true</body></methods><methods><class-id>Tools.CodingAssistant class</class-id> <category>instance creation</category><body package="VRUIPainterPreReq2">new	^super new initialize</body></methods><methods><class-id>Tools.CodingAssistant class</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">openFor: aClassName	| classHolder inst |	classHolder := aClassName asValue.	inst := super new initialize classNameChannel: classHolder.	inst open</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="VRUIPainterPreReq2">addDependencyWritingAccessFor: instVarNames 	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	| class |	class := self targetClass.	instVarNames do: [:eachName | (class includesSelector: (eachName , ':') asSymbol)			ifFalse: 				[| aStream |				aStream := String new writeStream.				aStream nextPutAll: eachName.				aStream nextPutAll: ': aValue'.				aStream cr; cr; tab.				aStream nextPutAll: eachName.				aStream nextPutAll: ' := aValue.'.				aStream cr; tab.				aStream nextPutAll: 'self changed: #'.				aStream nextPutAll: eachName.				class compile: aStream contents classified: #accessing]]</body><body package="VRUIPainterPreReq2">addInstVarNames: ivNames	"add inst vars to class"	ivNames do: [:each |		aClass addInstVarName: each]</body><body package="VRUIPainterPreReq2">addReadingAccessFor: instVarNames 	"Build read accessing messages to the reciever's target class."	| class |	class := self targetClass.	instVarNames do: [:eachName | (class includesSelector: eachName asSymbol)			ifFalse: 				[| aStream |				aStream := String new writeStream.				aStream nextPutAll: eachName.				aStream cr; cr; tab.				aStream nextPut: $^.				aStream nextPutAll: eachName.				class compile: aStream contents classified: #accessing]]</body><body package="VRUIPainterPreReq2">addWritingAccessFor: instVarNames 	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	| class |	class := self targetClass.	instVarNames do: [:eachName | (class includesSelector: (eachName , ':') asSymbol)			ifFalse: 				[| aStream |				aStream := String new writeStream.				aStream nextPutAll: eachName.				aStream nextPutAll: ': aValue'.				aStream cr; cr; tab.				aStream nextPutAll: eachName.				aStream nextPutAll: ' := aValue'.				class compile: aStream contents classified: #accessing]]</body><body package="VRUIPainterPreReq2">alertForMissingProperties: incompletes among: selectionList withNumberRequired: numberNeeded for: aController 	"Return true if we are to continue with defining, false otherwise."	| choice |	incompletes isEmpty ifTrue: [^true].	selectionList size = 1		ifTrue:			[((selectionList first widget class == CompositePart)					and: [(selectionList first spec isKindOf: SubCanvasSpec) not])				ifTrue:					[Dialog warn: 'The selected composite has componentswhose properties don''t specify their models' for: aController view.					^ numberNeeded &gt; incompletes size].			Dialog warn: 'This component lacks properties needed for defining its model.' for: aController view.			^false]		ifFalse:			[((selectionList size &gt; incompletes size or:				[selectionList isEmpty]) and:					[numberNeeded &gt; incompletes size])				ifTrue:					[(choice :=						Dialog							choose:								'Some components lack properties needed for defining models.Define models for the others, or select the ones that need editing?'							labels: #('Define' 'Select &amp; Cancel' 'Cancel')							values: #(#define #select #cancel)							default: #define							for: aController view) == #define						ifTrue: [^true].					choice == #select						ifTrue:							[aController broadcastPendingSelectionChange.							aController								selectionList:									(self findSelectablesIn: aController havingSpecs: incompletes)].					^false]				ifFalse:					[incompletes isEmpty						ifTrue:							[Dialog warn: 'Some components lack properties needed for defining models.' for: aController view]						ifFalse:							[(Dialog									choose: 'Some components lack properties needed for defining models.Select the items that need editing?'									labels: #('Select &amp; Cancel' 'Cancel')									values: #(true false)									default: true									for: aController view)								ifTrue:									[aController broadcastPendingSelectionChange.									aController										selectionList:											(self findSelectablesIn: aController havingSpecs: incompletes)]].					^false]].</body><body package="VRUIPainterPreReq2">aspectPathClassFor: someClass	| pathCl |	(pathCl :=		aClass messageNotUnderstoodSignal			handle:				[:ex |				ex parameter selector == #aspectPathClass					ifTrue: [ex returnWith: nil]					ifFalse: [ex reject]]			do: [aClass aspectPathClass]) isNil		ifTrue: [pathCl := UIAspectPath].	^pathCl</body><body package="VRUIPainterPreReq2">define: bindings for: aController	self isAdvanced		ifTrue: [(self advancedWriteDefsFor: bindings for: aController) readStream fileIn]		ifFalse: [(self writeDefinitions: bindings for: aController) readStream fileIn].	UIFinderVW2 installed: (Array with: self targetClass  with: #notUsed)</body><body package="VRUIPainterPreReq2">defineEssentialsFor: anApplicationSpec	| cl |	(self writeEssentialsFor: anApplicationSpec) readStream fileIn.	cl := self getClassNamed: anApplicationSpec name.	cl notNil		ifTrue:			[cl messageNotUnderstoodSignal				handle:					[:exc |					exc parameter selector == #rowType:						ifTrue: [exc return]						ifFalse: [exc reject]]				do:					[cl rowType: nil]]</body><body package="VRUIPainterPreReq2">does: someClass inheritFromClassNamed: aSymbol	| cl | 	cl := Smalltalk at: aSymbol ifAbsent: [nil].	^cl == nil		ifTrue: [false]		ifFalse: [someClass inheritsFrom: cl]</body><body package="VRUIPainterPreReq2">enumeratorClass	^AspectEnumerator</body><body package="VRUIPainterPreReq2">expandDetails: detailSlots 	"We need to check to see if there are details whose content aspects 	are aspect paths, since instance variables and accessors for such 	aspects will not be generated as part of the usual service for 	generating detail aspects. This also allows any of the heads of such 	paths needing defining to be presented in the dialog to the user."	| results |	results := Set new.	detailSlots do:		[:slot |		| path |		(path := (self aspectPathClassFor: aClass) forAspect: (slot value contentKey) fromBuilder: nil) tail notNil			ifTrue: [results add: path head -&gt; nil asValue]].	^results</body><body package="VRUIPainterPreReq2">expandPaths: bindingSlots	| slotNames results |	slotNames := Set new.	results := Set new.	bindingSlots do:		[:slot |		| aspect |		aspect := (self aspectPathClassFor: aClass) forAspect: slot key fromBuilder: nil.		aspect tail notNil			ifTrue:				[slotNames add: aspect head.				aspect trigger notNil ifTrue: [slotNames add: aspect trigger]]			ifFalse:				[results add: slot]].	slotNames do: [:slnm | results add: slnm -&gt; nil asValue].	^results</body><body package="VRUIPainterPreReq2">fetchExpressionForClientDetail: detailSlot on: aStream	| spec |	aStream		nextPutAll: 'self ';		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']).	(self does: aClass inheritFromClassNamed: #LensDataManager)		ifTrue: [self finishFetchExpressionForDataFormDetail: detailSlot on: aStream]		ifFalse: [self finishFetchExpressionForTopDetail: detailSlot on: aStream]</body><body package="VRUIPainterPreReq2">fetchMethodBodyForDataFormDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])]']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body><body package="VRUIPainterPreReq2">fetchMethodBodyForTopDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values])]']				ifFalse:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values])]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body><body package="VRUIPainterPreReq2">findDetailVars: detailSlots 	"detailSlots is a collection of associations of detail aspect symbols to 	detail specs.  The contentKey may be an aspect path."	| result |	result := OrderedCollection new.	detailSlots do:		[:assn |		| spec path |		result add: (spec := assn value) clientKey.		spec sourceType ~~ #query			ifTrue:				[path := (self aspectPathClassFor: aClass) forAspect: spec contentKey fromBuilder: nil.				path head notNil ifTrue: [result add: path head].				path trigger notNil ifTrue: [result add: path trigger]]].	^result</body><body package="VRUIPainterPreReq2">findSelectablesIn: aController havingSpecs: specList	^aController view components		select:			[:cmp | (cmp isKindOf: SpecWrapper) and: [cmp includesSpecIn: specList]]</body><body package="VRUIPainterPreReq2">finishFetchExpressionForDataFormDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body><body package="VRUIPainterPreReq2">finishFetchExpressionForTopDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body><body package="VRUIPainterPreReq2">getClassNamed: aSymbol	^Smalltalk at: aSymbol ifAbsent: [nil]</body><body package="VRUIPainterPreReq2">initStringForClient: clientSlot on: aStream	aStream nextPutAll: clientSlot value; space;		nextPutAll: 'new'</body><body package="VRUIPainterPreReq2">initStringForDSV: dsvSlot on: aStream 	| enum deps |	deps := Set new.	(enum := self enumeratorClass new source: aClass)			doSpecs: (dsvSlot value columns).	enum bindings keys		do:			[:colM |			| head |			(head := ((self aspectPathClassFor: aClass) forAspect: colM fromBuilder: nil) head) notNil				ifTrue:					[deps add: head]].	aStream nextPutAll: ' SelectionInList new'.	deps isEmpty ifTrue: [^self].	aStream		nextPut: $.;		cr; tab; tab; tab;		nextPutAll: dsvSlot key;		nextPutAll: ' selectionIndexHolder compute:';		cr; tab; tab; tab; tab;		nextPutAll: '[:v |'.	deps do:		[:asp |		aStream			cr; tab; tab; tab; tab;			nextPutAll: 'self ';			nextPutAll: asp;			nextPutAll: ' value: ';			nextPutAll: dsvSlot key;			nextPutAll: ' selection.'].	aStream		skip: -1;		nextPutAll: '].';		cr; tab; tab; tab;		nextPutAll: dsvSlot key</body><body package="VRUIPainterPreReq2">initStringForList: listSlot on: aStream	aStream nextPutAll: listSlot value class name;		space; nextPutAll: 'new'</body><body package="VRUIPainterPreReq2">initStringForTable: tableSlot on: aStream	aStream nextPutAll: tableSlot value class name;		space; nextPutAll: 'new selectionInTable: SelectionInTable new'</body><body package="VRUIPainterPreReq2">initStringForValue: valueSlot on: aStream	aStream nextPutAll: (self initializeStringFor: valueSlot value value);		space; nextPutAll: 'asValue'</body><body package="VRUIPainterPreReq2">initializeStringFor: anObject		(anObject isKindOf: String)		ifTrue: [^'String new'].	anObject class == Text 		ifTrue: [^'Text new'].	anObject class == List		ifTrue: [^'List new'].	^anObject storeString</body><body package="VRUIPainterPreReq2">interactivelyUpgradeDefns: selectionList for: aController	"NB: if necessary this can be modified so that each and every internal	aspect of a detail is shown in the define dialog, by linking them all to	the selfsame spec object and identifying them in terms of the associated	spec object at generation time (i.e. we tell that fooChannel is the channel	aspect by finding it at the channel place inside the associated spec)."	| enum requiredBindings bindingsWantingDefinition modelsToDefine tmp choice |	self aSpec: aController model targetSelector.	aController model targetTrouble		ifTrue:			[(UIPainter preferenceFor: #installForDefine)				ifTrue:					[(aController model installFor: aController) isNil						ifTrue: [^self]]				ifFalse:					[Dialog warn: 'The canvas isn''t installed on any class' for: aController view.					^self]]. 	(enum := self enumeratorClass new source: aController model builder source).	selectionList isEmpty		ifTrue:			[enum doSpec: (aController model extractFullSpec)]		ifFalse:			[selectionList do:				[:sw |				enum doSpec: sw extractedSpec]].	requiredBindings := enum actions.	requiredBindings addAll: (self expandPaths: enum bindings associations).	requiredBindings addAll: (self expandDetails: enum details associations).	requiredBindings addAll: (enum clients associations).	requiredBindings addAll: (enum details associations).		"Filter out those messages that must be inherited from LensDataManager."	(self does: aClass inheritFromClassNamed: #LensApplicationModel)		ifTrue:			[requiredBindings associations do:				[:assn |				(aClass excludedBindings includes: assn key)					ifTrue: [requiredBindings removeKey: assn key]]].	(requiredBindings isEmpty and: [enum incompletes isEmpty])		ifTrue:			[self warnNoRequiredBindingsFor: selectionList.			^self].	(self			alertForMissingProperties: enum incompletes			among: selectionList			withNumberRequired: requiredBindings size + enum incompletes size			for: aController)		ifFalse:			[^self].	(aController canvasHasChanged and: [UIPainter preferenceFor: #installForDefine])		ifTrue:			[(choice :=				Dialog					choose: 'The canvas has changed since it was last installed.Install before defining models?'					labels: #('Install First' 'Define As Is' 'Cancel')					values: #(#install #define #cancel)					default: #define					for: aController view) == #cancel				ifTrue: [^self].			(choice == #install and:				[(aController model installFor: aController) isNil]) 				ifTrue:					[^self]].		tmp := IdentityDictionary new.	tmp addAll:		(self excludedBindings associations reject:			[:assn |			((requiredBindings includesKey: assn key) not or:				[((requiredBindings at: assn key)					isKindOf: assn value class) not])]).	self excludedBindings: tmp.	bindingsWantingDefinition :=		requiredBindings associations select:			[:bndg | (self excludedBindings includesKey: bndg key) not].	modelsToDefine :=		self			openDefinitionDialogOn:				(requiredBindings associations collect: [:bndg | bndg key]) asSortedStrings			selecting: (bindingsWantingDefinition collect: [:bndg | bndg key]).	modelsToDefine isNil ifTrue: [^self].	self		define:			(modelsToDefine collect:				[:mdl | requiredBindings associationAt: mdl])		for: aController.	requiredBindings associations do:		[:bndg |		(modelsToDefine includes: bndg key)			ifTrue: [excludedBindings removeKey: bndg key ifAbsent: []]			ifFalse: [excludedBindings add: bndg]]</body><body package="VRUIPainterPreReq2">isDataFormSpec: obj	| c1 c2 |	c1 := Smalltalk at: #LinkedDetailSpec ifAbsent: [nil].	c2 := Smalltalk at: #EmbeddedDetailSpec ifAbsent: [nil].	c1 isNil ifTrue: [^false].	c2 isNil ifTrue: [^false].	^(obj isKindOf: c1) or: [obj isKindOf: c2]</body><body package="VRUIPainterPreReq2">openDefinitionDialogOn: models selecting: modelsToDefine	| builder dialog modelList result |	builder := (dialog := SimpleDialog new) builder.	builder aspectAt: #addInitialization put: self initializeModels.	builder aspectAt: #isBuffered put: self isBuffered.	builder aspectAt: #isUpdated put: self isUpdated.	builder aspectAt: #defineInstVars put: self defineInstVars.	builder aspectAt: #domainModel put: self domainModel.	builder aspectAt: #useLazyInit put: self useLazyInit.	(builder aspectAt: #useLazyInit)		onChangeSend: #wantsNonLazy		to: self.	(builder aspectAt: #defineInstVars)		onChangeSend: #wantsInstVars		to: self.	myDlg := dialog.	(modelList :=		builder			aspectAt: #modelList			put: (MultiSelectionInList with: models)).	modelList selections: modelsToDefine asOrderedCollection.	builder		aspectAt: #doOK		put:			[result := modelList selections.			dialog close].	builder		aspectAt: #doAbort		put:			[result := nil.			dialog close].	dialog openFrom:		(UISpecification from:			(models size == 1				ifTrue: [self class smallDefineDialogSpec]				ifFalse: [self class defineDialogSpec])).	^result</body><body package="VRUIPainterPreReq2">setClass: class 	"Set the value of the target class to be class."	aClass := class</body><body package="VRUIPainterPreReq2">warnNoRequiredBindingsFor: selectionList	Dialog warn:		(selectionList isEmpty			ifTrue: ['There are no items that needmodels to be defined for them.']			ifFalse:				[selectionList size = 1					ifTrue:						[(selectionList first spec model notNil)							ifTrue: ['The application already inheritsa model for the selected item.']							ifFalse: ['The selected item needs no model.']]					ifFalse: ['The selected items need nomodels to be defined for them.']])</body><body package="VRUIPainterPreReq2">whereClauseForDetail: detailClass into: aCodeStream 	| qe qOp dcl whr |	dcl := self class environment		at: detailClass		ifAbsent: 			[Dialog warn: 'The Class: ' , detailClass , 'is not defined yet.The restricting query method generated in the parentwill not contain the default joins that would make thechild DataForm''s fetch sensitive to the row selectedin the parent.You can edit the restricting query using the QueryEditor, or use ''define'' again after creating the classfor the child Data Form'.			^nil].	(dcl respondsTo: #rowType)		ifFalse: 			[^nil].	(qOp := (self getClassNamed: #QueryOperation)) == nil ifTrue: [^nil].	qOp := qOp new.	qOp containerNames: dcl rowType.	qOp mode: #mixin.	(qe := (self getClassNamed: #QueryEditor)) == nil ifTrue: [^nil].	qe := qe new.	qe ldm: self targetClass dataModel.	qe targetClass: self targetClass.	qe loadTheQuery: qOp.	whr := qe defaultMixinJoin.	whr size &gt; 0		ifTrue: 			[qe where value: whr.			qe putWhereInto: aCodeStream]</body><body package="VRUIPainterPreReq2">writeAccessor: aspect for: assn initGen: initStringMethod on: aStream	aStream cr; cr; nextPutAll: aspect.	self initializeModels value		ifTrue:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."']		ifFalse:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'].	aStream cr; cr; tab;		nextPutAll: '^' , aspect.	self initializeModels value		ifTrue:			[aStream				nextPutAll: ' isNil';				cr; tab; tab;				nextPutAll: 'ifTrue:';				cr; tab; tab; tab;				nextPut: $[; nextPutAll: aspect; nextPutAll: ' := '.			self perform: initStringMethod with: assn with: aStream.			aStream				nextPut: $];				cr; tab; tab;				nextPutAll: 'ifFalse:';				cr; tab; tab; tab;				nextPut: $[; nextPutAll: aspect; nextPut: $]].	aStream nextPut: $!</body><body package="VRUIPainterPreReq2">writeAccessors: prop for: slots initGen: initGenMethod on: aStream	slots isEmpty not		ifTrue:			[slots do:				[:assn |				self					writeAccessor: (assn value perform: prop)					for: assn					initGen: initGenMethod					on: aStream]]</body><body package="VRUIPainterPreReq2">writeAccessorsFor: slots initGen: initGenMethod on: codeStream	| aStream |	slots isEmpty not		ifTrue:			[aStream := String new writeStream.			slots do:				[:assn |				self					writeAccessor: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body><body package="VRUIPainterPreReq2">writeAccessorsForClients: clientSlots andDetails: detailSlots on: aStream	(detailSlots isEmpty not or: [clientSlots isEmpty not])		ifTrue:			[aStream				cr; cr;				nextPut: $!;				nextPutAll: aClass fullName;				nextPutAll: ' methodsFor: ''accessing''!'.			self				writeAccessors: #clientKey				for: detailSlots				initGen: #initStringForClientDetail:on:				on: aStream.			self writeAccessorsFor: clientSlots initGen: #initStringForClient:on: on: aStream.			aStream nextPutAll: ' !'].</body><body package="VRUIPainterPreReq2">writeAutoFetchMethod: autoFetchSlots on: aStream		aStream		cr; cr;		nextPutAll: 'autoFetchFor: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	autoFetchSlots isEmpty		ifTrue:			[aStream cr; tab; nextPutAll: '^self']		ifFalse:			[autoFetchSlots				do:					[:detl |					aStream						cr; tab;						nextPutAll: 'aChild == self ';						nextPutAll: detl clientKey;						nextPutAll: ' ifTrue: [self ';						nextPutAll: detl fetchAction;						nextPutAll: '].']].	aStream nextPut: $!</body><body package="VRUIPainterPreReq2">writeAutoOpenMethod: autoOpenSlots on: aStream		aStream		cr; cr;		nextPutAll: 'autoOpenChildren';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	autoOpenSlots isEmpty		ifFalse:			[autoOpenSlots				do:					[:assn |					| spec cnv |					aStream						cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: (spec := assn value) clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printString]);						nextPut: $.]].	aStream cr; tab; nextPutAll: 'super autoOpenChildren'.	aStream nextPut: $!</body><body package="VRUIPainterPreReq2">writeChildRemovalMethod: detailSlots on: aStream	detailSlots isEmpty ifTrue: [^self].	aStream		cr; cr;		nextPutAll: 'removeChild: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."';		cr; cr; tab;		nextPutAll: 'super removeChild: aChild'.	detailSlots do:		[:detl |		aStream			nextPut: $.;			cr; tab;			nextPutAll: 'aChild == ';			nextPutAll: detl clientKey;			nextPutAll: ' ifTrue: [';			nextPutAll: detl clientKey;			nextPutAll: ' := nil]'].	aStream nextPut: $!</body><body package="VRUIPainterPreReq2">writeClassDefiningMessageForIVs: ivNames on: codeStream 	"Create a new class definition string starting with the current one. Build the 	instance variables string by taking the current one, adding a space and 	then adding the new instance variables separated by spaces. Then format 	the class definition message and put it as the next chunk in the code 	stream"	| aStream msg index |	aStream := String new writeStream.	msg := aClass definitionMessage.	index := msg selector keywords				indexOf: 'instanceVariableNames:'				ifAbsent: [self error: 'I can''t add any instance variable names'].	aStream nextPutAll: (msg arguments at: index).	aStream space.	ivNames do: [:e | aStream nextPutAll: e; space].	msg arguments at: index put: aStream contents.	aStream := String new writeStream.	msg receiver printOn: aStream.	msg selector keywords with: msg arguments		do: 			[:word :arg | 			arg == aClass name				ifTrue: [aStream space]				ifFalse: [aStream cr; tab].			aStream nextPutAll: word; space; store: arg].	codeStream nextChunkPut: aStream contents</body><body package="VRUIPainterPreReq2">writeDefinitions: bindings for: aController	"bindings includes all required bindings in the selection set	that the user has not specifically disallowed.  Test to see whether	instance variables are already there.  Must check to see whether	action methods are already there, and do not redefine them if they	exist.  Always redefine aspect methods against the possibility that	the type of the model has changed.	NB: aspect methods incorporate lazy instVar initialization."	| allnames actionSlots valueSlots listSlots tableSlots clientSlots dsvSlots detailSlots ivNames detailVars codeStream allDetails notifySlots validateSlots |	allnames := aClass allInstVarNames asSet.	notifySlots := self allNotifySlotsFor: aClass.	validateSlots := self allValidateSlotsFor: aClass.	actionSlots := bindings select: [:e | e value isKindOf: BlockClosure].	valueSlots := bindings select: [:e | e value isKindOf: ValueModel].	listSlots := bindings select: [:e | e value isKindOf: SelectionInList].	tableSlots := bindings select: [:e | e value isKindOf: TableInterface].	clientSlots := bindings select: [:e | e value isKindOf: Symbol].	dsvSlots := bindings select: [:e | e value isKindOf: DataSetSpec].	detailSlots := bindings select:		[:e | self isDataFormSpec: e value].	detailVars := self findDetailVars: detailSlots.	ivNames :=		(((valueSlots, listSlots, tableSlots, clientSlots, dsvSlots) collect: [:e | e key ]), detailVars			select: [:e | (allnames includes: e asString) not]) asSet.	codeStream := String new writeStream.	self writeClassDefiningMessageForIVs: ivNames on: codeStream.	self writeAccessorsForClients: clientSlots andDetails: detailSlots on: codeStream.	self buildNotifyMethods: notifySlots onto: codeStream.	self buildValidateMethods: validateSlots onto: codeStream.	self		writeSimpleActions: actionSlots		andDetailActions: detailSlots		on: codeStream.	self		writeSimpleAspects: valueSlots		andListAspects: listSlots		andTableAspects: tableSlots		andDSVAspects: dsvSlots		on: codeStream.		allDetails := 		(self enumeratorClass new source: aController model builder source)			doSpec: aController model extractFullSpec; details.	(self does: aClass inheritFromClassNamed: #LensApplicationModel)		ifTrue:			[self				writeMixinQueryMethods: detailSlots on: codeStream.			"The private methods must be written to take into account all details			on the canvas, not just those currently selected."			self writePrivateMethods: allDetails for: aController on: codeStream]		ifFalse:			[allDetails isEmpty not				ifTrue:					[Dialog warn:'A complete set of definitions could not be generatedto support the Data Form(s) being defined for, becausethis canvas is installed on a non-database class.  Youshould reinstall the canvas on a new class that is eithera Data Form or a Database Application, and try again.']].			^codeStream contents</body><body package="VRUIPainterPreReq2">writeDemandFetchMethod: detailSlots on: aStream		aStream		cr; cr;		nextPutAll: 'fetchFor: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	detailSlots		do:			[:assn |			| dtl |			aStream				cr; tab;				nextPutAll: 'aChild == self ';				nextPutAll: (dtl := assn value) clientKey.			dtl fetchAction isNil				ifTrue:					[aStream						cr; tab; tab;						nextPutAll: 'ifTrue:';						cr; tab; tab; tab;						nextPut: $[.					self fetchExpressionForClientDetail: dtl on: aStream]				ifFalse:					[aStream						nextPutAll: ' ifTrue: [self ';						nextPutAll: assn value fetchAction].			aStream nextPutAll: '].'].	aStream nextPut: $!</body><body package="VRUIPainterPreReq2">writeEssentialsFor: anApplicationSpec 	"The class decides what needs to be defined for it, inheriting from whichever behavior was defined in the superclass"	| codeStream cl |	codeStream := String new writeStream.	(cl := self class environment at: anApplicationSpec name asSymbol ifAbsent: [nil]) notNil		ifTrue:			[cl messageNotUnderstoodSignal				handle:					[:ex |					ex parameter selector == #writeEssentialsFor:using:into:						ifTrue: [ex returnWith: nil]						ifFalse: [ex reject]]				do:					[cl						writeEssentialsFor: anApplicationSpec						using: self						into: codeStream]].	^codeStream contents</body><body package="VRUIPainterPreReq2">writeFetchActions: detailSlots on: aStream	(detailSlots isEmpty or:			[(detailSlots detect: [:assn | assn value fetchAction notNil] ifNone: []) isNil])		ifTrue: [^self].	detailSlots		do:			[:assn |			assn value fetchAction notNil				ifTrue:					[aStream						cr; cr;						nextPutAll: assn value fetchAction;						cr; tab;						nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."';						cr; cr; tab.					(self does: aClass inheritFromClassNamed: #LensDataManager)						ifTrue: [self fetchMethodBodyForDataFormDetail: assn on: aStream]						ifFalse: [self fetchMethodBodyForTopDetail: assn on: aStream].					aStream nextPut: $!]]</body><body package="VRUIPainterPreReq2">writeMixinQueryMethods: detailSlots on: aStream	| codeStream emptyPos |	detailSlots isEmpty not		ifTrue:			[codeStream := String new writeStream.			codeStream				cr; cr;				nextPut: $!;				nextPutAll: aClass fullName asString;				nextPutAll: ' methodsFor: ''query''!'.			emptyPos := codeStream writePosition.			detailSlots				do:					[:slot |					| spec mixQK |					((spec := slot value ) sourceType == #query and:						[(mixQK := spec contentKey) notNil])						ifTrue:							[codeStream								cr; cr;								nextPutAll:									(self										mixinQueryContentsForDetail: spec majorKeyReference										named: mixQK);								nextPut: $!.]].			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="VRUIPainterPreReq2">writeOpenActions: detailSlots on: aStream	"If there is any detailSlot with an openAction defined, add the 	definition of the method to aStream for each such detailSlot"	(detailSlots isEmpty or:			[(detailSlots detect: [:assn |  assn value openAction notNil] ifNone: []) isNil])		ifTrue: [^self].	detailSlots		do:			[:assn |			| cnv spec |			(spec := assn value) openAction notNil				ifTrue:					[aStream						cr; cr;						nextPutAll: spec openAction;						cr; tab;						nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."';						cr; cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: spec clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printString]);						nextPut: $!]]</body><body package="VRUIPainterPreReq2">writePrivateMethods: allDetails for: aController on: aStream 	"Always rewrite the 'private' methods taking into account all of the 	details on the canvas, not just those that are currently selected."	aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''private''!'.	self		writeChildRemovalMethod: allDetails		on: aStream.	self		writeAutoOpenMethod:			(allDetails				select:					[:assn |					assn value openAction notNil and:						[assn value autoOpen]])		on: aStream.	self		writeAutoFetchMethod:			(allDetails				select:					[:assn |					assn value fetchAction notNil and:						[assn value autoFetch]])		on: aStream.	self		writeDemandFetchMethod: allDetails		on: aStream.	(self does: aClass inheritFromClassNamed: #{LensDataManager})		ifTrue:			[self				writeSynchronizeMethod:					(allDetails select: [:assn | assn value synchronize])			on: aStream].	aStream nextPutAll: ' !'</body><body package="VRUIPainterPreReq2">writeSimpleActions: actionSlots andDetailActions: detailSlots andDSVSortActions: dsvColSlots on: aStream	"Be careful never to rewrite simple actions that already exist,	however detail fetch and open actions must needs be rewritten	against the chance the user has changed these properties."	| codeStream emptyPos |	(actionSlots isEmpty not or: [detailSlots isEmpty not or: [dsvColSlots isEmpty not]])"	(actionSlots isEmpty not or: [detailSlots isEmpty not])"		ifTrue:			[codeStream := String new writeStream.			codeStream cr; cr; nextPutAll: '!' , aClass fullName ,				' methodsFor: ''actions''!'.			emptyPos := codeStream writePosition.			self				writeSimpleActions:					(actionSlots select: [:assn | (aClass canUnderstand: assn key) not])				on: codeStream.			self				writeFetchActions:					(detailSlots select:						[:assn | assn value fetchAction notNil])				on: codeStream.			self				writeOpenActions:					(detailSlots select:						[:assn | assn value openAction notNil])				on: codeStream.			self				writeSortActionsFor: dsvColSlots				initGen: #initStringForDSV:on:				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="VRUIPainterPreReq2">writeSimpleActions: actionSlots andDetailActions: detailSlots on: aStream	"Be careful never to rewrite simple actions that already exist,	however detail fetch and open actions must needs be rewritten	against the chance the user has changed these properties."	| codeStream emptyPos |	(actionSlots isEmpty not or: [detailSlots isEmpty not])		ifTrue:			[codeStream := String new writeStream.			codeStream cr; cr; nextPutAll: '!' , aClass fullName ,				' methodsFor: ''actions''!'.			emptyPos := codeStream writePosition.			self				writeSimpleActions:					(actionSlots select: [:assn | (aClass canUnderstand: assn key) not])				on: codeStream.			self				writeFetchActions:					(detailSlots select:						[:assn | assn value fetchAction notNil])				on: codeStream.			self				writeOpenActions:					(detailSlots select:						[:assn | assn value openAction notNil])				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="VRUIPainterPreReq2">writeSimpleActions: actionSlots on: aStream	actionSlots isEmpty ifTrue: [^self].	actionSlots		do:			[:actn |			aStream				nextPutAll: actn key;				cr; cr; tab;				nextPutAll: '"This stub method was generated by UIDefiner"';				cr; cr; tab.				self domainModel isNil					ifTrue: [aStream nextPutAll: '^self!']					ifFalse: [aStream nextPutAll: 'self model value ', actn key.							aStream nextPut: $!]]</body><body package="VRUIPainterPreReq2">writeSimpleAspects: valueSlots andListAspects: listSlots andTableAspects: tableSlots andDSVAspects: dsvSlots on: aStream	"Always redefine the more accessor-like methods"	| codeStream emptyPos |	(valueSlots isEmpty not or:		[listSlots isEmpty not or:			[tableSlots isEmpty not or:				[dsvSlots isEmpty not]]])		ifTrue:			[codeStream := String new writeStream.			codeStream				cr; cr;				nextPut: $!;				nextPutAll: aClass fullName;				nextPutAll: ' methodsFor: ''aspects''!'.			emptyPos := codeStream writePosition.			self writeAccessorsFor: valueSlots initGen: #initStringForValue:on: on: codeStream.			self				writeAccessorsFor: listSlots				initGen: #initStringForList:on:				on: codeStream.			self				writeAccessorsFor: tableSlots				initGen: #initStringForTable:on:				on: codeStream.			self				writeAccessorsFor: dsvSlots				initGen: #initStringForDSV:on:				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="VRUIPainterPreReq2">writeSynchronizeMethod: synchroSlots on: aStream	aStream		cr; cr;		nextPutAll: 'synchronize: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'; cr.	synchroSlots isEmpty		ifTrue:			[aStream cr; tab; nextPutAll: '^self']		ifFalse:			[synchroSlots do:				[:slt |				| spec |				aStream					cr; tab;					nextPutAll: 'aChild == self ';					nextPutAll: (spec := slt) clientKey;					cr; tab; tab;					nextPutAll: ' ifTrue:';					cr; tab; tab; tab;					nextPutAll: '[self row '.				spec fetchAction isNil					ifTrue:						[aStream							nextPutAll: 'compute:';							cr; tab; tab; tab; tab;							nextPutAll: '[:v |';							cr; tab; tab; tab; tab.						self fetchExpressionForClientDetail: slt on: aStream.						aStream							nextPut:$];							cr; tab;tab;tab;							nextPutAll: 'for: aChild']					ifFalse:						[aStream							nextPutAll: 'onChangeSend: ';							nextPutAll: spec fetchAction printString;							nextPutAll: ' to: self for: aChild'].				aStream nextPutAll: '].']].	aStream nextPut: $!</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private-Datasets</category><body package="VRUIPainterPreReq2">ascendingSortBlockStringFor: aDataSetColumnSpec	| strm |	strm := WriteStream on: (String new: 50).	strm nextPutAll: '[:x :y | x '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort.	strm nextPutAll: ' printString &lt;= y '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort. 	strm nextPutAll: ' printString]'.	^strm contents</body><body package="VRUIPainterPreReq2">descendingSortBlockStringFor: aDataSetColumnSpec	| strm |	strm := WriteStream on: (String new: 50).	strm nextPutAll: '[:x :y | x '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort.	strm nextPutAll: ' printString &gt;= y '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort. 	strm nextPutAll: ' printString]'.	^strm contents</body><body package="VRUIPainterPreReq2">writeSortAction: aspect for: assn initGen: initStringMethod on: aStream	| dsvColSpec dsvSpec |	aStream cr; cr; nextPutAll: aspect.	self initializeModels value		ifTrue:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."']		ifFalse:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'].	dsvColSpec := assn value.	dsvSpec := dsvColSpec dataSetSpec.	aStream cr; cr; tab;		nextPutAll: '| ascSortBlock dscSortBlock sortBlock |'.	aStream cr; tab; 		nextPutAll: 'ascSortBlock := '.	aStream nextPutAll: (self ascendingSortBlockStringFor: dsvColSpec).	aStream nextPutAll: '.'.	aStream cr; tab; 		nextPutAll: 'dscSortBlock := '.	aStream nextPutAll: (self descendingSortBlockStringFor: dsvColSpec).	aStream nextPutAll: '.'.	aStream cr; cr; tab;		nextPutAll: 'self ', dsvSpec model, ' sortAspect == #', dsvColSpec fullColumnAspect.	aStream cr; tab; tab;		nextPutAll: 'ifTrue: ['.	aStream cr; tab; tab; tab;		nextPutAll: 'self ', dsvSpec model, ' sortDirection == #asc'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'ifTrue: [self ', dsvSpec model, ' sortDirection: #dsc.'.	aStream cr; tab; tab; tab; tab; tab;		nextPutAll: 'sortBlock := ascSortBlock]'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'ifFalse: [self ', dsvSpec model, ' sortDirection: #asc.'.	aStream cr; tab; tab; tab; tab; tab;		nextPutAll: 'sortBlock := dscSortBlock]]'.	aStream cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: 'self ', dsvSpec model, ' sortAspect: #', dsvColSpec fullColumnAspect, '.'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'self ', dsvSpec model, ' sortDirection: #dsc.'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'sortBlock := ascSortBlock].'.	aStream cr; cr; tab;		nextPutAll: 'self ', dsvSpec model, ' list:'.	aStream cr; tab; tab.	aStream nextPutAll: '(SortedCollection withAll: (self ', dsvSpec model, ' list)'.	aStream cr; tab; tab; tab.	aStream nextPutAll: 'sortBlock: sortBlock) asList.'.	aStream nextPut: $!</body><body package="VRUIPainterPreReq2">writeSortActionsFor: slots initGen: initGenMethod on: codeStream	| aStream |	slots isEmpty not		ifTrue:			[aStream := String new writeStream.			slots do:				[:assn |				self					writeSortAction: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>accessing</category><body package="VRUIPainterPreReq2">excludedBindings	^excludedBindings</body><body package="VRUIPainterPreReq2">excludedBindings: aDictionary	excludedBindings := aDictionary</body><body package="VRUIPainterPreReq2">initializeModels	^initializeModels</body><body package="VRUIPainterPreReq2">targetClass	"Answer the target class of the receiver."	^aClass</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>defining</category><body package="VRUIPainterPreReq2">addAccessing	"For each instance variable of the target class, add the reading and writing 	access interface."	self addReadingAccess.	self addWritingAccess</body><body package="VRUIPainterPreReq2">addDependencyWritingAccess	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	self addDependencyWritingAccessFor: self targetClass instVarNames</body><body package="VRUIPainterPreReq2">addReadingAccess	"Build read accessing messages to the reciever's target class."	self addReadingAccessFor: self targetClass instVarNames.</body><body package="VRUIPainterPreReq2">addWritingAccess	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	self addWritingAccessFor: self targetClass instVarNames</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>initialize-release</category><body package="VRUIPainterPreReq2">initialize	initializeModels := true asValue.	isBuffered := false asValue.	isUpdated := false asValue.	domainModel := nil asValue.	defineInstVars := false asValue.	useLazyInit := false asValue.	self hasStartedAspectInitGeneration: false.	excludedBindings := Dictionary new</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>aspect-creation</category><body package="VRUIPainterPreReq2">aSpec	^aSpec</body><body package="VRUIPainterPreReq2">aSpec: aValue	aSpec := aValue</body><body package="VRUIPainterPreReq2">advancedWriteDefsFor: bindings for: aController	"bindings includes all required bindings in the selection set	that the user has not specifically disallowed.  Test to see whether	instance variables are already there.  Must check to see whether	action methods are already there, and do not redefine them if they	exist.  Always redefine aspect methods against the possibility that	the type of the model has changed.	NB: aspect methods incorporate lazy instVar initialization."	| allnames actionSlots valueSlots listSlots tableSlots clientSlots dsvSlots detailSlots ivNames detailVars codeStream allDetails current notifySlots validateSlots modelDefiner | 	allnames := aClass allInstVarNames asSet.	notifySlots := self allNotifySlotsFor: aClass.	validateSlots := self allValidateSlotsFor: aClass. 	actionSlots := bindings select: [:e | e value isKindOf: BlockClosure].	valueSlots := bindings select: [:e | e value isKindOf: ValueModel].	listSlots := bindings select: [:e | e value isKindOf: SelectionInList].	tableSlots := bindings select: [:e | e value isKindOf: TableInterface].	clientSlots := bindings select: [:e | e value isKindOf: Symbol].	dsvSlots := bindings select: [:e | e value isKindOf: DataSetSpec].	detailSlots := bindings select:		[:e | self isDataFormSpec: e value].	detailVars := self findDetailVars: detailSlots.	ivNames := ( listSlots, tableSlots, clientSlots, dsvSlots).	self defineInstVars value ifTrue: [ivNames := ivNames, valueSlots].	ivNames :=		((ivNames collect: [:e | e key ]), detailVars			select: [:e | (allnames includes: e asString) not]).	ivNames add: 'model'.	self isBuffered value		ifTrue: [ivNames add: 'trigger']. 	current := self targetClass allInstVarNames.	ivNames := (ivNames reject: [:each | current includes: each]) asSet.	codeStream := String new writeStream."	self writeClassDefiningMessageForIVs: ivNames on: codeStream."	self addInstVarNames: ivNames.	self writeAccessorForModelIVOn: codeStream.	self buildModelNamingMethodOnto: codeStream.	self buildInitializeMethodOnto: codeStream.	self buildApplicationInitializeOnto: codeStream.	self buildNotifyMethods: notifySlots onto: codeStream.	self buildValidateMethods: validateSlots onto: codeStream.	self writeAccessorsForClients: clientSlots andDetails: detailSlots on: codeStream.	self		writeSimpleActions: actionSlots		andDetailActions: detailSlots		on: codeStream.	self		writeAdvancedAspects: valueSlots		andListAspects: listSlots		andTableAspects: tableSlots		andDSVAspects: dsvSlots		on: codeStream.	modelDefiner := ModelDefiner new. 	modelDefiner nameSpace: self targetClass environment.	modelDefiner category: self targetClass category.	modelDefiner apiMethods: actionSlots.	modelDefiner 		generateStockComment: aClass 		using:  (valueSlots, listSlots, tableSlots, dsvSlots)		mapTypes: false.		self domainModel value isNil		ifFalse: [modelDefiner targetClass: self.				modelDefiner 					generate: self domainModel value 					varList: (valueSlots, listSlots, tableSlots, dsvSlots).				modelDefiner initializeLists: (listSlots, tableSlots, dsvSlots) andValues: valueSlots].		allDetails := 		(self enumeratorClass new source: aController model builder source)			doSpec: aController model extractFullSpec; details.	(self does: aClass inheritFromClassNamed: #LensApplicationModel)		ifTrue:			[self				writeMixinQueryMethods: detailSlots on: codeStream.			"The private methods must be written to take into account all details			on the canvas, not just those currently selected."			self writePrivateMethods: allDetails for: aController on: codeStream]		ifFalse:			[allDetails isEmpty not				ifTrue:					[Dialog warn:'A complete set of definitions could not be generatedto support the Data Form(s) being defined for, becausethis canvas is installed on a non-database class.  Youshould reinstall the canvas on a new class that is eithera Data Form or a Database Application, and try again.']].			^codeStream contents</body><body package="VRUIPainterPreReq2">allNotifySlotsFor: someClass	| methodNames theSpecObject components |	methodNames := OrderedCollection new.	theSpecObject := FullSpec from: (someClass perform: self aSpec).	components := theSpecObject component collection.	components do: [:each | | spec |		(each respondsTo: #callbacksSpec)			ifTrue: [spec := each callbacksSpec.				methodNames add: spec focusInSelector.				methodNames add: spec focusOutSelector.				methodNames add: spec valueChangeSelector.				methodNames add: spec doubleClickSelector]].	^methodNames copyWithout: nil</body><body package="VRUIPainterPreReq2">allValidateSlotsFor: someClass	| methodNames theSpecObject components |	methodNames := OrderedCollection new.	theSpecObject := FullSpec from: (someClass perform: self aSpec).	components := theSpecObject component collection.	components do: [:each | | spec |		(each respondsTo: #callbacksSpec)			ifTrue: [spec := each callbacksSpec.				methodNames add: spec requestFocusInSelector.				methodNames add: spec requestFocusOutSelector.				methodNames add: spec requestValueChangeSelector.				methodNames add: spec requestDoubleClickSelector]].	^methodNames copyWithout: nil</body><body package="VRUIPainterPreReq2">answerAspectAdaptorFor: aspect updates: aBoolean	| stream |	stream := WriteStream on: String new.	stream nextPutAll: '((AspectAdaptor subjectChannel: self model'.	stream cr;tab; tab; tab.	stream nextPutAll: 'sendsUpdates: ', aBoolean printString, ')'.	stream cr; tab.	stream nextPutAll: 'forAspect: ', aspect printString.	stream nextPutAll: ')'.	^stream contents</body><body package="VRUIPainterPreReq2">answerBufferedAdaptorFor: aspect updates: aBoolean	| stream adaptorString |	stream := WriteStream on: String new.	adaptorString := self answerAspectAdaptorFor: aspect updates: aBoolean.	stream nextPutAll: 'BufferedValueHolder subject: ('.	stream cr; tab.	stream nextPutAll: adaptorString, ')'.	stream cr; tab; tab.	stream nextPutAll: 'triggerChannel: self trigger'.	^stream contents</body><body package="VRUIPainterPreReq2">buildAdaptorOnto: aStream for: aspect using: initMethod for: assn 	"shove std stuff out" 	aStream cr;tab. 	self isUpdated value		ifTrue: [aStream nextPutAll: (self defineAdaptorUpdateFor: aspect)]		ifFalse: [aStream nextPutAll: (self defineAdaptorNoUpdateFor: aspect)].	aStream cr; cr.</body><body package="VRUIPainterPreReq2">buildAdvancedOnto: aStream for: aspect using: initMethod for: assn 	"shove aspect/buffered stuff out"	self buildLazyAspectsOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildApplicationInitializeOnto: aStream	"stock initialize"	"first check - ONLY define this method if not already there"	self initializeApplicationMethodExists		ifTrue: [^self].	aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''initialize-release''!'.	aStream cr;cr.	aStream nextPutAll: 'initializeApplication'.	aStream cr; tab.	aStream nextPutAll: '"UIDefiner defined this method.'; cr; tab.	aStream nextPutAll: 'UIDefiner will not recreate this method, so all custom initialization code should be placed here."'.	aStream cr; cr; tab.	aStream nextPutAll: '! !'.</body><body package="VRUIPainterPreReq2">buildBufferedOnto: aStream for: aspect using: initMethod for: assn 	"shove std stuff out"	aStream cr;tab.	self isUpdated value		ifTrue: [aStream nextPutAll: (self defineBufferedUpdateFor: aspect)]		ifFalse: [aStream nextPutAll: (self defineBufferedNoUpdateFor: aspect)].</body><body package="VRUIPainterPreReq2">buildInitStartOnto: aStream		aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''initialize-release''!'.	aStream cr;cr.	aStream nextPutAll: 'initAspects'.	aStream cr; tab.	aStream nextPutAll: '"UIDefiner defined this method"'.	aStream cr; cr; tab.</body><body package="VRUIPainterPreReq2">buildInitializeMethodOnto: aStream	"stock initialize"	| string |	aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''initialize-release''!'.	aStream cr;cr.	aStream nextPutAll: 'initialize'.	aStream cr; tab.	aStream nextPutAll: '"UIDefiner defined this method.'; cr; tab.	aStream nextPutAll: 'Do NOT modify this method; place custom code in &lt;initializeApplication&gt;"'.	aStream cr; cr; tab.	aStream nextPutAll: 'super initialize.'.	aStream cr; tab.	self domainModel value isSymbol		ifTrue: [string := self domainModel value asString]		ifFalse: [string := self domainModel value name asString].	self domainModel value notNil		ifTrue: [aStream nextPutAll: 'self model: '.				aStream nextPutAll: string, ' new asValue.'; cr;tab].	self isBuffered value		ifTrue: [aStream nextPutAll: 'self trigger: false asValue.'; cr; tab].	self useLazyInit value		ifFalse: [aStream nextPutAll: 'self initializeAspects.';cr; tab].	aStream nextPutAll: 'self initializeApplication.'.	aStream nextPutAll: '! !'.</body><body package="VRUIPainterPreReq2">buildInitializedAdaptorOnto: aStream for: aspect using: initMethod for: assn	"create (or add onto) existing init method"	self hasStartedAspectInitGeneration		ifTrue: [aStream skip: -3]		ifFalse: [self buildInitStartOnto: aStream.				self hasStartedAspectInitGeneration: true].	aStream nextPutAll: aspect, ':= '.	aStream nextPutAll: (self answerAspectAdaptorFor: aspect updates: self isUpdated value).	aStream cr.	aStream nextPutAll: '! !'.</body><body package="VRUIPainterPreReq2">buildInitializedBufferedOnto:  aStream for: aspect using: initMethod for: assn	"create (or add onto) existing init method"	self hasStartedAspectInitGeneration		ifTrue: [aStream skip: -3]		ifFalse: [self buildInitStartOnto: aStream.				self hasStartedAspectInitGeneration: true].	aStream nextPutAll: aspect, ':= '.	aStream nextPutAll: (self answerBufferedAdaptorFor: aspect updates: self isUpdated value).	aStream cr.	aStream nextPutAll: '! !'.</body><body package="VRUIPainterPreReq2">buildLazyAspectsOnto: aStream for: aspect using: initMethod for: assn	self isBuffered value 		ifTrue: [self buildBufferedOnto:  aStream for: aspect using: initMethod for: assn]		ifFalse: [self buildAdaptorOnto: aStream for: aspect using: initMethod for: assn]</body><body package="VRUIPainterPreReq2">buildModelNamingMethodOnto: aStream	"stock initialize"	| string |	self domainModel value isNil		ifTrue: [^self].	aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' class methodsFor: ''accessing''!'.	aStream cr;cr.	aStream nextPutAll: 'uiDomainModelName'.	aStream cr; tab.	aStream nextPutAll: '"UIDefiner defined this method.'; cr; tab.	aStream nextPutAll: 'This method is used internally by UIDefiner"'.	aStream cr; cr; tab. 	self domainModel value isSymbol		ifTrue: [string := self domainModel value asString]		ifFalse: [string := self domainModel value name asString].	aStream nextPutAll: '^', string.	aStream nextPutAll: '! !'.</body><body package="VRUIPainterPreReq2">buildNonLazyAdaptorOnto: aStream for: aspect using: initMethod for: assn 	"shove std stuff out" 	aStream cr;tab. 	self isUpdated value		ifTrue: [aStream nextPutAll: (self defineNonLazyAdaptorUpdateFor: aspect)]		ifFalse: [aStream nextPutAll: (self defineNonLazyAdaptorNoUpdateFor: aspect)].	aStream cr; cr.</body><body package="VRUIPainterPreReq2">buildNonLazyAdvancedDSVOnto: aStream for: aspect using: initMethod for: assn 	"shove aspect/buffered stuff out"	self buildNonLazyDSVAspectsOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildNonLazyAdvancedListOnto: aStream for: aspect using: initMethod for: assn 	"shove aspect/buffered stuff out"	self buildNonLazyListAspectsOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildNonLazyAdvancedOnto: aStream for: aspect using: initMethod for: assn 	"shove aspect/buffered stuff out"	self buildNonLazyAspectsOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildNonLazyAdvancedTableOnto: aStream for: aspect using: initMethod for: assn 	"shove aspect/buffered stuff out"	self buildNonLazyTableAspectsOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildNonLazyAspectsOnto: aStream for: aspect using: initMethod for: assn	self isBuffered value 		ifTrue: [self buildNonLazyBufferedOnto:  aStream for: aspect using: initMethod for: assn]		ifFalse: [self buildNonLazyAdaptorOnto: aStream for: aspect using: initMethod for: assn]</body><body package="VRUIPainterPreReq2">buildNonLazyBufferedOnto: aStream for: aspect using: initMethod for: assn 	"shove std stuff out"	aStream cr;tab.	self isUpdated value		ifTrue: [aStream nextPutAll: (self defineNonLazyBufferedUpdateFor: aspect)]		ifFalse: [aStream nextPutAll: (self defineNonLazyBufferedNoUpdateFor: aspect)].</body><body package="VRUIPainterPreReq2">buildNonLazyDSVAspectsOnto: aStream for: aspect using: initMethod for: assn	self buildNonLazyListAdaptorOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildNonLazyListAdaptorOnto: aStream for: aspect using: initMethod for: assn 	"shove std stuff out" 	| nameString |	nameString := assn value class name asString.	aStream cr;tab. 	aStream nextPutAll: aspect, ' := ', nameString, ' with: self model value ', aspect, '.'.	aStream cr; cr.</body><body package="VRUIPainterPreReq2">buildNonLazyListAspectsOnto: aStream for: aspect using: initMethod for: assn	self buildNonLazyListAdaptorOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildNonLazyTableAdaptorOnto: aStream for: aspect using: initMethod for: assn 	"shove std stuff out" 	aStream cr;tab. 	aStream nextPutAll: aspect, ' := TableInterface new selectionInTable: SelectionInTable new.'.	aStream cr; cr.</body><body package="VRUIPainterPreReq2">buildNonLazyTableAspectsOnto: aStream for: aspect using: initMethod for: assn	self buildNonLazyTableAdaptorOnto: aStream for: aspect using: initMethod for: assn</body><body package="VRUIPainterPreReq2">buildNotifyMethods: notifySlots onto: aStream	"notification methods"	| didWork |	didWork := false.	notifySlots do: [:each |		(aClass selectors includes: each)			ifFalse: [didWork ifFalse: [					aStream						cr; cr;						nextPut: $!;						nextPutAll: aClass fullName;						nextPutAll: ' methodsFor: ''notification events''!'.						aStream cr;cr].										aStream cr; cr.					aStream nextPutAll: each asString.					(self messageIsKeyword: each)						ifTrue: [aStream nextPutAll: ' aController'].					didWork := true.					aStream cr; tab.					aStream nextPutAll: '"UIDefiner defined this method"'.					aStream cr; cr; tab.					aStream nextPutAll: '^self.'.					aStream cr; tab.					aStream nextPutAll: '!']].	didWork ifTrue: [aStream nextPutAll: ' !'; cr; cr].</body><body package="VRUIPainterPreReq2">buildValidateMethods: validateSlots onto: aStream	"notification methods"	| didWork |	didWork := false.	validateSlots do: [:each |		(aClass selectors includes: each)			ifFalse: [didWork ifFalse: [					aStream						cr; cr;						nextPut: $!;						nextPutAll: aClass fullName;						nextPutAll: ' methodsFor: ''validation events''!'.						aStream cr;cr].					aStream nextPutAll: each asString.					(self messageIsKeyword: each)						ifTrue: [aStream nextPutAll: ' aController'].					didWork := true.					aStream cr; tab.					aStream nextPutAll: '"UIDefiner defined this method"'.					aStream cr; cr; tab.					aStream nextPutAll: '^true.'.					aStream cr; tab.					aStream nextPutAll: '!'; cr; cr]].	didWork ifTrue: [aStream nextPutAll: ' !'; cr; cr].</body><body package="VRUIPainterPreReq2">buildValueHolderOnto: aStream for: aspect using: initMethod for: assn 	"shove std stuff out"	aStream nextPutAll: '^' , aspect.	aStream nextPutAll: ' isNil'; cr; tab; tab; nextPutAll: 'ifTrue:'; cr; tab; tab; tab; nextPut: $[; nextPutAll: aspect; nextPutAll: ' := '.	self		perform: initMethod		with: assn		with: aStream.	aStream nextPut: $]; cr; tab; tab; nextPutAll: 'ifFalse:'; cr; tab; tab; tab; nextPut: $[; nextPutAll: aspect; nextPut: $]</body><body package="VRUIPainterPreReq2">defineAdaptorNoUpdateFor: aspect	"create a standard aspectAdaptor method assuming a model	variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeAspectVarNoUpdateFor: aspect]		ifFalse: [self writeAspectNoUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">defineAdaptorUpdateFor: aspect	"create a standard aspectAdaptor method assuming a model	variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeAspectVarUpdateFor: aspect]		ifFalse: [self writeAspectUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">defineBufferedNoUpdateFor: aspect	"create a standard buffered aspectAdaptor method assuming a model variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeBufferedVarNoUpdateFor: aspect]		ifFalse: [self writeBufferedNoUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">defineBufferedUpdateFor: aspect	"create a standard buffered aspectAdaptor method assuming a model variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeBufferedVarUpdateFor: aspect]		ifFalse: [self writeBufferedUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">defineInstVars	defineInstVars isNil		ifTrue: [defineInstVars := false asValue].	^defineInstVars</body><body package="VRUIPainterPreReq2">defineNonLazyAdaptorNoUpdateFor: aspect	"create a standard aspectAdaptor method assuming a model	variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeNonLazyAspectVarNoUpdateFor: aspect]		ifFalse: [self writeNonLazyAspectNoUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">defineNonLazyAdaptorUpdateFor: aspect	"create a standard aspectAdaptor method assuming a model	variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeNonLazyAspectVarUpdateFor: aspect]		ifFalse: [self writeNonLazyAspectUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">defineNonLazyBufferedNoUpdateFor: aspect	"create a standard buffered aspectAdaptor method assuming a model variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeNonLazyBufferedVarNoUpdateFor: aspect]		ifFalse: [self writeNonLazyBufferedNoUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">defineNonLazyBufferedUpdateFor: aspect	"create a standard buffered aspectAdaptor method assuming a model variable with a valueModel in it"	^self defineInstVars value		ifTrue: [self writeNonLazyBufferedVarUpdateFor: aspect]		ifFalse: [self writeNonLazyBufferedUpdateFor: aspect]</body><body package="VRUIPainterPreReq2">domainModel		domainModel isNil		ifTrue: [domainModel := nil asValue].	^domainModel</body><body package="VRUIPainterPreReq2">hasStartedAspectInitGeneration	^hasStartedAspectInitGeneration</body><body package="VRUIPainterPreReq2">hasStartedAspectInitGeneration: aValue	hasStartedAspectInitGeneration := aValue</body><body package="VRUIPainterPreReq2">initAdvancedStringForDSV: dsvSlot on: aStream 	| enum deps |	deps := Set new.	(enum := self enumeratorClass new source: aClass)			doSpecs: (dsvSlot value columns).	enum bindings keys		do:			[:colM |			| head |			(head := ((self aspectPathClassFor: aClass) forAspect: colM fromBuilder: nil) head) notNil				ifTrue:					[deps add: head]].	aStream nextPutAll: ' SelectionInList new'.	deps isEmpty ifTrue: [^self].	aStream		nextPut: $.;		cr; tab; tab; tab;		nextPutAll: dsvSlot key;		nextPutAll: ' selectionIndexHolder compute:';		cr; tab; tab; tab; tab;		nextPutAll: '[:v |'.	deps do:		[:asp |		aStream			cr; tab; tab; tab; tab;			nextPutAll: 'self ';			nextPutAll: asp;			nextPutAll: ' value: ';			nextPutAll: dsvSlot key;			nextPutAll: ' selection.'].	aStream		skip: -1;		nextPutAll: '].';		cr; tab; tab; tab;		nextPutAll: dsvSlot key</body><body package="VRUIPainterPreReq2">initAdvancedStringForList: listSlot on: aStream	aStream nextPutAll: listSlot value class name;		space; nextPutAll: 'with: self model value ', listSlot key asString</body><body package="VRUIPainterPreReq2">initAdvancedStringForTable: tableSlot on: aStream	aStream nextPutAll: tableSlot value class name;		space; nextPutAll: 'new selectionInTable: SelectionInTable new'</body><body package="VRUIPainterPreReq2">initializeApplicationMethodExists	^aClass includesSelector: #initializeApplication</body><body package="VRUIPainterPreReq2">isAdvanced	^self domainModel value notNil</body><body package="VRUIPainterPreReq2">isBuffered		isBuffered isNil		ifTrue: [isBuffered := false asValue].	^isBuffered</body><body package="VRUIPainterPreReq2">isUpdated	isUpdated isNil		ifTrue: [isUpdated := false asValue].	^isUpdated</body><body package="VRUIPainterPreReq2">messageIsKeyword: aSelectorName	^aSelectorName asString includes: $:</body><body package="VRUIPainterPreReq2">release	super release.	(myDlg builder aspectAt:  #useLazyInit) retractInterestsFor: self.	(myDlg builder aspectAt:  #defineInstVars) retractInterestsFor: self.	myDlg := nil</body><body package="VRUIPainterPreReq2">setSpec: aSymbol	aSpec := aSymbol</body><body package="VRUIPainterPreReq2">useLazyInit 	useLazyInit isNil		ifTrue: [useLazyInit := false asValue].	^useLazyInit</body><body package="VRUIPainterPreReq2">wantsInstVars	"user can ONLY have non-lazy IF he gets inst vars"	|  instVH lazyVH |	lazyVH := myDlg builder aspectAt: #useLazyInit.	instVH := myDlg builder aspectAt: #defineInstVars.	instVH  value		ifFalse: [lazyVH retractInterestsFor: self.				lazyVH value: true.				lazyVH onChangeSend: #wantsNonLazy to: self].</body><body package="VRUIPainterPreReq2">wantsNonLazy	"user can ONLY have non-lazy IF he gets inst vars"	|  instVH lazyVH |	lazyVH := myDlg builder aspectAt: #useLazyInit.	instVH := myDlg builder aspectAt: #defineInstVars.	lazyVH  value		ifFalse: [instVH retractInterestsFor: self.				instVH value: true.				instVH onChangeSend: #wantsInstVars to: self].</body><body package="VRUIPainterPreReq2">writeAccessorForModelIVOn: codeStream	"add accessors for the 'model' variable if needed"	| array |	self isBuffered value		ifTrue: [array := #('model' 'trigger')]		ifFalse: [array := #('model')].	self addReadingAccessFor: array.	self addWritingAccessFor: array.</body><body package="VRUIPainterPreReq2">writeAdvancedAccessor: aspect for: assn initGen: initStringMethod on: aStream	aStream cr; cr; nextPutAll: aspect.	self initializeModels value		ifTrue:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."']		ifFalse:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'].	aStream cr; cr; tab.	self isAdvanced		ifFalse: [self 					buildValueHolderOnto: aStream 					for: aspect 					using: initStringMethod 					for: assn]		ifTrue: [self					buildAdvancedOnto: aStream					for: aspect					using: initStringMethod					for: assn].		aStream nextPut: $!</body><body package="VRUIPainterPreReq2">writeAdvancedAccessorsFor: slots initGen: initGenMethod on: codeStream	| aStream | 	slots isEmpty not		ifTrue:			[aStream := String new writeStream.				slots do:				[:assn |				self					writeAdvancedAccessor: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body><body package="VRUIPainterPreReq2">writeAdvancedAspects: valueSlots andListAspects: listSlots andTableAspects: tableSlots andDSVAspects: dsvSlots on: aStream	"Always redefine the more accessor-like methods" 	| codeStream |	(valueSlots isEmpty not or:		[listSlots isEmpty not or:			[tableSlots isEmpty not or:				[dsvSlots isEmpty not]]])		ifTrue:			[self useLazyInit value				ifTrue: [codeStream := String new writeStream.				self 					writeAdvancedLazyInit: valueSlots 					andListAspects: listSlots 					andTableAspects: tableSlots 					andDSVAspects: dsvSlots 					codeStream: codeStream					on: aStream]				ifFalse: [codeStream := String new writeStream.				self 					writeAdvancedNonLazyInit: valueSlots 					andListAspects: listSlots 					andTableAspects: tableSlots 					andDSVAspects: dsvSlots 					codeStream: codeStream					on: aStream.				self 					writeValueSlotAccessorsFor: valueSlots					on: aStream.				self 					writeValueSlotAccessorsFor: listSlots					on: aStream.				self 					writeValueSlotAccessorsFor: tableSlots					on: aStream.				self 					writeValueSlotAccessorsFor: dsvSlots					on: aStream]]</body><body package="VRUIPainterPreReq2">writeAdvancedLazyInit: valueSlots andListAspects: listSlots andTableAspects: tableSlots andDSVAspects: dsvSlots codeStream: codeStream on: aStream			| emptyPos | 	codeStream					cr; cr;					nextPut: $!;					nextPutAll: aClass fullName;					nextPutAll: ' methodsFor: ''aspects''!'.					emptyPos := codeStream writePosition.			self writeAdvancedAccessorsFor: valueSlots initGen: #initStringForValue:on: on: codeStream.			self				writeAccessorsFor: listSlots				initGen: #initAdvancedStringForList:on:				on: codeStream.			self				writeAccessorsFor: tableSlots				initGen: #initAdvancedStringForTable:on:				on: codeStream.			self				writeAccessorsFor: dsvSlots				initGen: #initAdvancedStringForDSV:on:				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']</body><body package="VRUIPainterPreReq2">writeAdvancedNonLazyInit: valueSlots andListAspects: listSlots andTableAspects: tableSlots andDSVAspects: dsvSlots codeStream: codeStream on: aStream	| emptyPos |	codeStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''initialize-release''!'; cr; cr;		nextPutAll: 'initializeAspects'; cr; tab;		nextPutAll: '"Preset all aspects.  UIDefiner will overwrite this method"'; cr; tab.		emptyPos := codeStream writePosition.		self 			writeNonLazyAdvancedAccessorsFor: valueSlots 			initGen: #initStringForValue:on: 			on: codeStream.			self				writeNonLazyAdvancedListAccessorsFor: listSlots				initGen: #initAdvancedStringForList:on:				on: codeStream.			self				writeNonLazyAdvancedTableAccessorsFor: tableSlots				initGen: #initAdvancedStringForTable:on:				on: codeStream.			self				writeNonLazyAdvancedDSVAccessorsFor: dsvSlots				initGen: #initAdvancedStringForDSV:on:				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' ! !']</body><body package="VRUIPainterPreReq2">writeAspectNoUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPut: $^.	stream nextPutAll: 		(self answerAspectAdaptorFor: aspect updates: false).	^stream contents</body><body package="VRUIPainterPreReq2">writeAspectUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPut: $^.	stream nextPutAll: 		(self answerAspectAdaptorFor: aspect updates: true).	^stream contents</body><body package="VRUIPainterPreReq2">writeAspectVarNoUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' isNil '.	stream cr; tab; tab.	stream nextPutAll: 'ifTrue: [', aspect, ':= '.	stream nextPutAll: (self answerAspectAdaptorFor: aspect updates: false).	stream nextPutAll: '].'; cr; tab.	stream nextPutAll: '^', aspect.	^stream contents</body><body package="VRUIPainterPreReq2">writeAspectVarUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' isNil '.	stream cr; tab; tab.	stream nextPutAll: 'ifTrue: [', aspect, ':= '.	stream nextPutAll: (self answerAspectAdaptorFor: aspect updates: true).	stream nextPutAll: '].'; cr; tab.	stream nextPutAll: '^',  aspect.	^stream contents</body><body package="VRUIPainterPreReq2">writeBufferedNoUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPut: $^.	stream nextPutAll: 		(self answerBufferedAdaptorFor: aspect updates: false).	^stream contents</body><body package="VRUIPainterPreReq2">writeBufferedUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPut: $^.	stream nextPutAll: 		(self answerBufferedAdaptorFor: aspect updates: true).	^stream contents</body><body package="VRUIPainterPreReq2">writeBufferedVarNoUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' isNil '.	stream cr; tab; tab.	stream nextPutAll: 'ifTrue: [', aspect, ':= '.	stream nextPutAll: (self answerBufferedAdaptorFor: aspect updates: false).	stream nextPutAll: '].'; cr; tab.	stream nextPutAll: '^',  aspect.	^stream contents</body><body package="VRUIPainterPreReq2">writeBufferedVarUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' isNil '.	stream cr; tab; tab.	stream nextPutAll: 'ifTrue: [', aspect, ':= '.	stream nextPutAll: (self answerBufferedAdaptorFor: aspect updates: true).	stream nextPutAll: '].'; cr; tab.	stream nextPutAll: '^',  aspect.	^stream contents</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedAccessor: aspect for: assn initGen: initStringMethod on: aStream	self		buildNonLazyAdvancedOnto: aStream		for: aspect		using: initStringMethod		for: assn.</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedAccessorsFor: slots initGen: initGenMethod on: codeStream	| aStream | 	slots isEmpty not		ifTrue:			[aStream := String new writeStream.				slots do:				[:assn |				self					writeNonLazyAdvancedAccessor: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedAspects: valueSlots andListAspects: listSlots andTableAspects: tableSlots andDSVAspects: dsvSlots on: aStream	"Always redefine the more accessor-like methods" 	| codeStream emptyPos |  self halt.	(valueSlots isEmpty not or:		[listSlots isEmpty not or:			[tableSlots isEmpty not or:				[dsvSlots isEmpty not]]])		ifTrue:			[codeStream := String new writeStream.			self 				writeAdvancedLazyInit: valueSlots 				andListAspects: listSlots 				andTableAspects: tableSlots 				andDSVAspects: dsvSlots 				codeStream: codeStream				on: aStream.			codeStream					cr; cr;					nextPut: $!;					nextPutAll: aClass fullName;					nextPutAll: ' methodsFor: ''aspects''!'.					emptyPos := codeStream writePosition.			self writeAdvancedAccessorsFor: valueSlots initGen: #initStringForValue:on: on: codeStream.			self				writeAccessorsFor: listSlots				initGen: #initAdvancedStringForList:on:				on: codeStream.			self				writeAccessorsFor: tableSlots				initGen: #initAdvancedStringForTable:on:				on: codeStream.			self				writeAccessorsFor: dsvSlots				initGen: #initAdvancedStringForDSV:on:				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedDSVAccessor: aspect for: assn initGen: initStringMethod on: aStream	self		buildNonLazyAdvancedDSVOnto: aStream		for: aspect		using: initStringMethod		for: assn.</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedDSVAccessorsFor: slots initGen: initGenMethod on: codeStream	| aStream | 	slots isEmpty not		ifTrue:			[aStream := String new writeStream.				slots do:				[:assn |				self					writeNonLazyAdvancedDSVAccessor: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedListAccessor: aspect for: assn initGen: initStringMethod on: aStream	self		buildNonLazyAdvancedListOnto: aStream		for: aspect		using: initStringMethod		for: assn.</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedListAccessorsFor: slots initGen: initGenMethod on: codeStream	| aStream | 	slots isEmpty not		ifTrue:			[aStream := String new writeStream.				slots do:				[:assn |				self					writeNonLazyAdvancedListAccessor: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedTableAccessor: aspect for: assn initGen: initStringMethod on: aStream	self		buildNonLazyAdvancedTableOnto: aStream		for: aspect		using: initStringMethod		for: assn.</body><body package="VRUIPainterPreReq2">writeNonLazyAdvancedTableAccessorsFor: slots initGen: initGenMethod on: codeStream	| aStream | 	slots isEmpty not		ifTrue:			[aStream := String new writeStream.				slots do:				[:assn |				self					writeNonLazyAdvancedTableAccessor: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body><body package="VRUIPainterPreReq2">writeNonLazyAspectVarNoUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' := '.	stream nextPutAll: (self answerAspectAdaptorFor: aspect updates: false).	stream nextPut: $..	stream cr; tab.	^stream contents</body><body package="VRUIPainterPreReq2">writeNonLazyAspectVarUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' := '.	stream nextPutAll: (self answerAspectAdaptorFor: aspect updates: true).	stream nextPut: $..	stream cr; tab.	^stream contents</body><body package="VRUIPainterPreReq2">writeNonLazyBufferedVarNoUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' := '.	stream nextPutAll: (self answerBufferedAdaptorFor: aspect updates: false).	stream nextPut: $..	stream cr; tab.	^stream contents</body><body package="VRUIPainterPreReq2">writeNonLazyBufferedVarUpdateFor: aspect	| stream |	stream := WriteStream on: String new.	stream nextPutAll: aspect, ' := '.	stream nextPutAll: (self answerBufferedAdaptorFor: aspect updates: true).	stream nextPut: $..	stream cr; tab.	^stream contents</body><body package="VRUIPainterPreReq2">writeValueSlotAccessorsFor: slots on: aStream	(slots isEmpty not)		ifTrue:			[aStream				cr; cr;				nextPut: $!;				nextPutAll: aClass fullName;				nextPutAll: ' methodsFor: ''accessing''!';cr; cr.			slots do: [:each |				aStream nextPutAll: each key asString.				aStream cr; tab.				aStream nextPutAll: '^', each key asString.				aStream nextPutAll: ' !'.				aStream cr; cr].			aStream nextPutAll: ' !' ].</body></methods><methods><class-id>Tools.UIDefiner class</class-id> <category>instance creation</category><body package="VRUIPainterPreReq2">for: aClass	"Create an instance of the receiver for the class aClass."	^self for: aClass targetSpec: #windowSpec</body><body package="VRUIPainterPreReq2">new	^self basicNew initialize</body></methods><methods><class-id>Tools.UIDefiner class</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">for: aClass targetSpec: aSpec	"Create an instance of the receiver for the class aClass."	^self new setClass: aClass; setSpec: aSpec</body></methods><methods><class-id>OS.Filename class</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">volumeSeparator	"Answer the platform's filename volume separator."	^''</body></methods><methods><class-id>Graphics.MockMedium</class-id> <category>accessing</category><body package="VRUIPainterPreReq2">topComponent	^component</body></methods><methods><class-id>UI.ControlManager</class-id> <category>web-compat</category><body package="VRUIPainterPreReq2">servesScreen	^true</body><body package="VRUIPainterPreReq2">servesWeb	^false</body></methods><methods><class-id>UI.TableView</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">accomodateVisuals	"Modifies existing visualBlocks to just pass through VisualComponents found in the view's table."	1 to: visualBlock size		do: 			[:i | 			| oldBlock |			oldBlock := visualBlock at: i.			visualBlock at: i put: [:view :index | ((view table at: index)					isKindOf: VisualComponent)					ifTrue: [BoundingWrapper on: (view table at: index)]					ifFalse: [oldBlock value: view value: index]]]</body></methods><methods><class-id>UI.MenuButtonView</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">currentChoice: aValue	"set the value associated with the current choice of the model."	currentChoice := aValue.	self resetCurrent</body></methods><methods><class-id>UI.ApplicationModel class</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">hasDynamicBindings	^false</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">customizeEmbeddedSubcanvas: spec	"default interface"	^spec</body><body package="VRUIPainterPreReq2">hasDynamicBindings	^false</body><body package="VRUIPainterPreReq2">initializeApplication^self</body><body package="VRUIPainterPreReq2">initializeAspects^self</body></methods><methods><class-id>UI.SubCanvasSpec</class-id> <category>private</category><body package="VRUIPainterPreReq2">getSubSpecIn: builder 	| spec  |   	minorKey == nil ifTrue: [^nil].	(builder source notNil and: [builder source hasDynamicBindings])		ifTrue: [spec := builder source customizeEmbeddedSubcanvas: self].	spec := builder subCanvasAt: majorKey at: minorKey.	spec == nil ifFalse: [^self extractSpecsFrom: spec].	builder isEditing		ifFalse: [^builder raiseErrorMessage: 'sub canvas &lt;1p&gt; not found!' with: minorKey].	^nil</body></methods><methods><class-id>Core.Timestamp</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">displayString	"Format a respresentation of the receiver. for display"	^self asDate printString</body></methods><methods><class-id>OS.PCFilename class</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">volumeSeparator	^':'</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>commands</category><body package="VRUIPainterPreReq2">doDefine		(model definer targetClass respondsTo: #uiDomainModelName)		ifTrue: [model definer domainModel value:					model definer targetClass uiDomainModelName]. 	model definer domainModel value: model definer domainModel value.	model definer		interactivelyUpgradeDefns: self selectionList copy		for: self</body></methods><methods><class-id>Graphics.ImageReader class</class-id> <category>As yet unclassified</category><body package="VRUIPainterPreReq2">fromStream: imageStream ofType: aTypeString	"Answer an instance initialized from the stream"	| readerClass reader | 	readerClass := self readerClassFor: 'file.', aTypeString.	reader := readerClass new from: imageStream.	^reader</body></methods><methods><class-id>Tools.CodingAssistant class</class-id> <category>interface specs</category><body package="VRUIPainterPreReq2">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: #(#WindowSpec #label: 'Coding Assistant' #min: #(#Point 242 320 ) #max: #(#Point 242 320 ) #bounds: #(#Rectangle 765 340 1007 660 ) ) #component: #(#SpecCollection #collection: #(#(#LabelSpec #layout: #(#LayoutOrigin 14 0 12 0 ) #label: 'ADD ACCESSORS to Class' ) #(#LabelSpec #layout: #(#LayoutOrigin 16 0 65 0 ) #label: 'for Instance Variables' ) #(#GroupBoxSpec #layout: #(#LayoutFrame 16 0 -128 1 -14 1 -14 1 ) #label: ' Accessing Methods ' ) #(#InputFieldSpec #layout: #(#LayoutFrame 16 0 38 0 -14 1 60 0 ) #model: #className #type: #symbol ) #(#SequenceViewSpec #layout: #(#LayoutFrame 16 0 85 0 -14 1 -134 1 ) #model: #instVarList #multipleSelections: true ) #(#CheckBoxSpec #layout: #(#AlignmentOrigin -56 0.5 -95 1 0.5 0.5 ) #model: #readAccessing #label: 'read' ) #(#CheckBoxSpec #layout: #(#AlignmentOrigin -54 0.5 -74 1 0.5 0.5 ) #model: #writeAccessing #label: 'write' ) #(#CheckBoxSpec #layout: #(#AlignmentOrigin 0 0.644628 -74 1 0.5 0.5 ) #name: #dependency #model: #dependency #label: 'dependency' ) #(#ActionButtonSpec #layout: #(#LayoutFrame 25 0 -55 1 -24 1 -23 1 ) #name: #defineButton #model: #apply #label: 'Define' #isDefault: true ) ) ) )</body></methods><methods><class-id>Tools.UIDefiner class</class-id> <category>interface specs</category><body package="VRUIPainterPreReq2">defineDialogSpec	"UIPainter new openOnClass: self andSelector: #defineDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 400 347 ) 			#max: #(#Point 400 347 ) 			#bounds: #(#Rectangle 200 127 600 474 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#LayoutOrigin 8 0 101 0 ) 					#label: 'DEFINE Models' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: 'OK' 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: 'Cancel' 					#defaultable: true ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 8 0 127 0 -9 1 -89 1 ) 					#model: #modelList 					#multipleSelections: true ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 16 0 -73 1 0 0 ) 					#model: #addInitialization 					#label: 'Add Initialization' ) 				#(#CompositeSpecCollection 					#collection: #(						#(#LabelSpec 							#layout: #(#Point 0 4 ) 							#name: #domainID 							#label: 'Domain' ) 						#(#InputFieldSpec 							#layout: #(#Rectangle 61 0 297 28 ) 							#name: #domainModel 							#model: #domainModel 							#type: #symbol ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 40 ) 							#name: #isBuffered 							#model: #isBuffered 							#label: 'Buffer Aspects ?' ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 67 ) 							#name: #isUpdated 							#model: #isUpdated 							#label: 'Model Sends Updates ?' ) 						#(#CheckBoxSpec 							#layout: #(#Point 168 40 ) 							#name: #defineInstVars 							#model: #defineInstVars 							#label: 'Aspects in Instance Variables ?' ) 						#(#CheckBoxSpec 							#layout: #(#Point 167 67 ) 							#name: #useLazyInit 							#model: #useLazyInit 							#label: 'Use Lazy Initialization ?' ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 8 6 376 92 ) ) ) ) ) )</body><body package="VRUIPainterPreReq2">smallDefineDialogSpec	"UIPainter new openOnClass: self andSelector: #smallDefineDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 397 255 ) 			#bounds: #(#Rectangle 281 173 678 428 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#LayoutOrigin 8 0 99 0 ) 					#label: 'DEFINE Model' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: 'OK' 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: 'Cancel' 					#defaultable: true ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 8 0 129 0 -22 1 -95 1 ) 					#flags: 12 					#model: #modelList 					#multipleSelections: true ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 8 0 -73 1 0 0 ) 					#model: #addInitialization 					#label: 'Add Initialization' ) 				#(#CompositeSpecCollection 					#collection: #(						#(#LabelSpec 							#layout: #(#Point 0 4 ) 							#name: #domainID 							#label: 'Domain' ) 						#(#InputFieldSpec 							#layout: #(#Rectangle 61 0 297 28 ) 							#name: #domainModel 							#model: #domainModel 							#type: #symbol ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 40 ) 							#name: #isBuffered 							#model: #isBuffered 							#label: 'Buffer Aspects ?' ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 67 ) 							#name: #isUpdated 							#model: #isUpdated 							#label: 'Model Sends Updates ?' ) 						#(#CheckBoxSpec 							#layout: #(#Point 168 40 ) 							#name: #defineInstVars 							#model: #defineInstVars 							#label: 'Aspects in Instance Variables ?' ) 						#(#CheckBoxSpec 							#layout: #(#Point 167 67 ) 							#name: #useLazyInit 							#model: #useLazyInit 							#label: 'Use Lazy Initialization ?' ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 8 6 376 92 ) ) ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MockMedium</name><environment>Graphics</environment><super>Graphics.GraphicsMedium</super><private>false</private><indexed-type>none</indexed-type><inst-vars>printerMedium component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Printing-Support</category><attributes><package>Graphics-Printing-Support</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>MenuButtonView</name><environment>UI</environment><super>UI.PushButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentChoice defaultChoice menu vcBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>UIPainterController</name><environment>Tools</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentMode oldPoint showGrid gridStep griddedHorizontally griddedVertically fenced primarySelection selections handles canvasHasChanged </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><class><name>ControlManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scheduledControllers activeController activeControllerProcess interruptLock outstandingMetaOrDamage modalWindowChain openInProgress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>TableView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state table columnInfo rowInfo selectionChannel selectionIndex targetIndex grid columnWidths rowHeights visualBlock textStyle displayStringSelector showCGrid showRGrid strokedSelection isSlave lpDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>SubCanvasSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>majorKey minorKey clientKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class></st-source>