<?xml version="1.0"?><st-source><!-- Name: VRCommonDialogsDbIdentifier: psql_public_cst_2007DbTrace: 51653PackageName: VRCommonDialogsParcel: #('VRCommonDialogs')ParcelDirectory: dev/VRCommonDialogsPrintStringCache: (9.106,jamesr)Version: (9.106,stevek)Date: 12:45:01 PM February 18, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on February 18, 2011 at 12:45:01 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CommonDirectorySelectionDialog</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryName title volumeName volumeNames directoryNames subDirectoryName directoryMustExist openedDialog directoryLabel path partMoveBy rememberedPaths oldVolume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRCommonDialogs</package></attributes></class><comment><class-id>UI.CommonDirectorySelectionDialog</class-id><body>This class is the superclass for a common file dialog that works across platforms.  The sole subclass should actually be used.  This class handles directory accessInstance VariablesdirectoryName &lt;String&gt; Name of the current directorytitle &lt;String&gt;  Title for the windowvolumeName &lt;String&gt; Name of the current volume (Windows Specific)volumeNames &lt;Collection&gt; All volumes present on this system (Windows Specific)directoryNames &lt;Collection&gt; Recently visitedsubDirectoryName &lt;String&gt; Name of subdirectory visiteddirectoryMustExist &lt;Boolean&gt; If true, cannot create new directoriesopenedDialog &lt;Boolean&gt; If true, we are in dialog modedirectoryLabel &lt;String&gt; Name of directorypath &lt;String&gt; Current pathpartMoveBy rememberedPaths &lt;Collection&gt; Recently visited directoriesoldVolume &lt;String&gt; Last volume visited</body></comment><class><name>CommonFileSelectionDialog</name><environment>UI</environment><super>UI.CommonDirectorySelectionDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filters filter fileNames fileName fileMustExist promptForOverwrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRCommonDialogs</package></attributes></class><comment><class-id>UI.CommonFileSelectionDialog</class-id><body>This is a cross platform file selection dialog.  See the class side protocol for example usage, including adding of filtersInstance Variablesfilters &lt;Collection&gt; Collection of all filters availablefilter &lt;CommonFileFilter&gt; The filter being usedfileNames &lt;Collection&gt; All files in the current directoryfileName &lt;String&gt; Selected file namefileMustExist  &lt;Boolean&gt; For file being entered - if true, it must exist alreadypromptForOverwrite &lt;Boolean&gt; If true, prompt user before saving to an existing file</body></comment><class><name>CommonFileFilter</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRCommonDialogs</package></attributes></class><comment><class-id>UI.CommonFileFilter</class-id><body>This class holds filters used by the file dialog to filter current directory contentsInstance Variables:	filter	&lt;Association&gt;	 A filter used to filter contents	description	&lt;String&gt;	 name of filter (Word Doc, Parcel, etc)</body></comment><class><name>CommonMessageDialog</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title button message iconStyle buttonStyle </inst-vars><class-inst-vars>buttonLabelList iconStyleList </class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRCommonDialogs</package></attributes></class><comment><class-id>UI.CommonMessageDialog</class-id><body>This class is a more sophisticated common 'Warning' dialog.  See the class side protocol for example usageInstance Variables:	title	&lt;String&gt;	 Window title	button	&lt;Number&gt;	Controls the number of buttons to use	message	&lt;String&gt;	 Prompter message	iconStyle	&lt;Symbol&gt;	Name of icon to use	buttonStyle	&lt;Symbol&gt;	Image (if any) to use on button(s)</body></comment><class><name>CommonPrompter</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message initialAnswer title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRCommonDialogs</package></attributes></class><comment><class-id>UI.CommonPrompter</class-id><body>This class represents a common (Cross Platform) prompter for input.  See the class side protocol for example usageInstance Variablesmessage &lt;String&gt; The prompter messageinitialAnswer &lt;String&gt; Default inputtitle &lt;String&gt; Window title</body></comment><class><name>CommonListChooser</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title message multipleSelect list initialSelection printSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Portable Common-Dialogs</category><attributes><package>VRCommonDialogs</package></attributes></class><comment><class-id>UI.CommonListChooser</class-id><body>This class is a common (cross platform) list picker.  See the class side protocol for example usageInstance Variablestitle &lt;String&gt; Title for the windowmessage &lt;String&gt; Prompter messagemultipleSelect &lt;Boolean&gt; If true, allow multi-selectlist &lt;Collection&gt; The list of objects to choose frominitialSelection &lt;Number&gt; Index of initial selectionprintSelector &lt;Symbol&gt; Unused</body></comment><shared-variable><name>CurrentVolume</name><environment>UI.CommonDirectorySelectionDialog</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>VRCommonDialogs</package></attributes></shared-variable><shared-variable><name>CurrentDirectory</name><environment>UI.CommonDirectorySelectionDialog</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>VRCommonDialogs</package></attributes></shared-variable><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>file utils</category><body package="VRCommonDialogs" selector="buildPath:">buildPath: aPathElement	"Private - Answer a path string 'volume:directory\aPathElement'.	This element may be a file name or a subdirectory."	| volumeString |	( ( volumeString := self volumeName value ) last ~= Filename separator )		ifTrue: [ volumeString := volumeString , self separator ].	( aPathElement = '..' )		ifTrue: [ ^self constructPath: volumeString			with: self directoryName asFilename head ]		ifFalse: [ ^self constructPath: ( self constructPath: volumeString with: self directoryName )			with: aPathElement ]</body><body package="VRCommonDialogs" selector="constructPath:with:">constructPath: aString1 with: aString2	"Private - Answer a string which combine the path elements into a valid path string."	^self class constructPath: aString1 with: aString2</body><body package="VRCommonDialogs" selector="directoryPathIsValid:">directoryPathIsValid: pathString	"Private - check if directory is valid path"	| components index |	index := self getVolumeFromPath: pathString.	( index + 1 &lt;= pathString size )		ifTrue: [			components := Filename components: 				( pathString copyFrom: index + 1 to: pathString size ).			components do: [ :dir |					 dir ~= self separator					ifTrue: [ ( self filenameIsValid: dir ) ifFalse: [ ^false ] ] ] ].	^true</body><body package="VRCommonDialogs" selector="enteredPath">enteredPath	"Private - Handles input for user specified path."	self builder keyboardProcessor focusIsShifting ifFalse: [ ^self ].	self processEnteredPath</body><body package="VRCommonDialogs" selector="filenameIsValid:">filenameIsValid: pathString	"Private - Check to make sure the directory does not have illegal chars."	( ( self stringHasWildcard: pathString ) or: 	[ pathString includes: Filename volumeSeparator ] )		ifFalse: [ pathString detect: [ :c | Filename defaultClass isBadCharacter: c ] 			ifNone: [ ^true ] ].	^false</body><body package="VRCommonDialogs" selector="getVolumeFromPath:">getVolumeFromPath: pathString	"Private -  take path components to see if the volume exists.  This method is to handle	network path names which Filename components: does not recognize"	( self volumeExists: ( Filename components: pathString ) first ) notNil		ifTrue: [ ^( Filename components: pathString ) first size ]		ifFalse: [ self volumeNames value do: [ :volume | | interval |			interval :=  pathString findString: volume startingAt: 1 ignoreCase: true useWildcards: false.			interval first = 1 ifTrue: [ ^interval last ] ] ].	^0</body><body package="VRCommonDialogs" selector="parsePath:accountForFilename:">parsePath: pathString accountForFilename: filenameExists	"Private - Parse a directory path, including relative path, and paths with the volume specified"	| volume  index directory pathComponents |	index := self getVolumeFromPath: pathString.	index = 0 		ifTrue: [ volume := self volumeName value.			pathComponents := Filename components: pathString.			directory := self directoryName.			( pathComponents first = '.' ) | ( pathComponents first = '..' ) 				ifTrue: [ ( directory isEmpty or: [ ( Filename components: directory ) first = '.' ] )						ifTrue: [ directory := self class currentDirectory.							volume := self class currentVolume ].					( Filename components: directory ) first = '..' 						ifTrue: [ directory := self class currentDirectory asFilename head.							volume := self class currentVolume ] ] ]		ifFalse: [ volume := pathString copyFrom: 1 to: index.			directory := self separator.			pathComponents := OrderedCollection new.			pathString size &gt; index				ifTrue: [  pathComponents := Filename components: 						( pathString copyFrom: index + 1 to: pathString size ) ] ].	pathComponents size &gt; 0 ifTrue: [		1 to: pathComponents size do: [ :currentIndex | | pathElement saveDirectory |			pathElement := pathComponents at: currentIndex.			pathElement = self separator				ifTrue: [ directory := self separator ]				ifFalse: [ pathElement = '..' 					ifTrue:[ directory := directory asFilename head.						directory last ~= Filename separator ifTrue: [ directory := directory , self separator ] ]					ifFalse: [ pathElement = '.'						ifFalse: [ saveDirectory := directory.							directory := self constructPath: 								( self constructPath: directory with: pathElement ) with: self separator.							( ( (self pathExists: (self constructPath: volume with: directory ) )  and: 							[ (self constructPath: volume with: directory ) asFilename isDirectory ] ) and:							[ ( self stringHasWildcard: pathElement ) not ] )								ifFalse: [ filenameExists 									ifTrue: [										directory := self constructPath: saveDirectory with: self separator.										( self pathExists: volume , self separator ) 											ifFalse: [ self setVolumeAsEmpty.												directory := self separator ].										self volumeName retractInterestsFor: self.										self volumeName value: volume.										self volumeName onChangeSend: #changedVolume to: self.										directoryName := directory.										^pathComponents size - ( currentIndex - 1 ) ]									ifFalse: [ ^pathComponents size - ( currentIndex - 1 ) ] ] ] ] ] ] ].	( self pathExists: volume )		ifFalse: [ self setVolumeAsEmpty.			directory := self separator ].	self volumeName retractInterestsFor: self.	self volumeName value: volume.	self volumeName onChangeSend: #changedVolume to: self.	directoryName := directory.	^0</body><body package="VRCommonDialogs" selector="pathExists:">pathExists: aString"Private - check if path is valid, handle exceptions, and return a boolean"	^self class pathExists: aString</body><body package="VRCommonDialogs" selector="processEnteredPath">processEnteredPath	"Private - Handles input for user specified path."	| leftovers pathComponents |	self path value isEmpty not 		ifTrue: [  leftovers := self updatePath: self path value.			self path retractInterestsFor: self.			leftovers = 1					ifTrue: [ 					pathComponents := Filename components: self path value.					( self stringHasWildcard: pathComponents last )						ifFalse: [ self okPressed ] ]."entering input = clicking OK button"			leftovers = 0 "if valid string, clear input field"				ifTrue: [ self okPressed ].			( leftovers &gt; 1 and: [ self directoryMustExist = false ] )				ifTrue: [ self okPressed ].			self path onChangeSend: #enteredPath to: self ]</body><body package="VRCommonDialogs" selector="stringHasWildcard:">stringHasWildcard: aString	"Private - check if string has * or ? chars"	^( ( aString includes: $* ) or: [ aString includes: $? ] )</body><body package="VRCommonDialogs" selector="updatePath:">updatePath: aPathString	"Private - Handles input for user specified path."	| leftovers pathComponents|  	pathComponents := Filename components: aPathString . 	leftovers := self parsePath: aPathString accountForFilename: self directoryMustExist not.	( leftovers = 1 and: [ self stringHasWildcard: pathComponents last ] )		ifTrue: [ self updateCurrentDirectoryContents: pathComponents last ]		ifFalse: [ self updateCurrentDirectoryContents: nil.			leftovers = 0 ifTrue: [ self path: ( self buildPath: String new ) ] ].	^leftovers</body><body package="VRCommonDialogs" selector="volumeExists:">volumeExists: aVolumeName"Private - check if aVolumeName exists within volumeNames"	| volumeString |	( volumeString := aVolumeName ) last ~= Filename separator		ifTrue: [ volumeString := volumeString , self separator ].	( self stringHasWildcard: volumeString ) ifTrue: [ ^nil ].		^self volumeNames value detect: [ :volume |  		volumeString match: volume ] ifNone: [ 		( volumeString includes: self separator )					ifTrue: [ ( self pathExists: volumeString )				ifTrue: [ ^volumeString ]				ifFalse: [ ^nil ] ] ].</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>accessing</category><body package="VRCommonDialogs" selector="directoryMustExist">directoryMustExist	"Answer a boolean value whether the dialog can specify a path to a non existent directory."	^directoryMustExist</body><body package="VRCommonDialogs" selector="directoryMustExist:">directoryMustExist: aBoolean	"Assign aBoolean value whether the dialog can specify a path to a non existent directory."	directoryMustExist := aBoolean</body><body package="VRCommonDialogs" selector="directoryName">directoryName	"Answer the directory which the dialog currently is referencing."	^directoryName</body><body package="VRCommonDialogs" selector="directoryName:">directoryName: aDirectory	"Assign the directory path the dialog box will point to.  The argument should be 	of the format \path where \ is the current OS file separator.  	Do not pass the volume."	| wildcardPattern textInputString val |	openedDialog		ifTrue: [	Object errorSignal					handle: [:ex | ex proceed]					do: [val := aDirectory isEmpty not].					val ifTrue: [ 			textInputString := ( self perform: self getTextInputField ) value.			( ( self stringHasWildcard: textInputString )  and:			[ ( Filename components: textInputString ) size = 1 ] )				ifTrue: [ wildcardPattern := textInputString ]				ifFalse: [ wildcardPattern := String new ].		self updatePath: ( self constructPath: aDirectory with: wildcardPattern ) ] ]		ifFalse: [ directoryName := aDirectory ]</body><body package="VRCommonDialogs" selector="directoryNames">directoryNames	"Private - List of current subdirectories within current hierarchy"	^directoryNames</body><body package="VRCommonDialogs" selector="directoryNames:">directoryNames: aNamesList	"Private - Assign a list of current subdirectories within current hierarchy"	directoryNames := aNamesList</body><body package="VRCommonDialogs" selector="getTextInputField">getTextInputField	"Private"	^#path</body><body package="VRCommonDialogs" selector="oldVolume">oldVolume	^oldVolume</body><body package="VRCommonDialogs" selector="oldVolume:">oldVolume: aValue	oldVolume := aValue</body><body package="VRCommonDialogs" selector="path">path	"Client supplied fully specified path"	^path</body><body package="VRCommonDialogs" selector="path:">path: aString	"Client supplied fully specified path"	self path value: aString</body><body package="VRCommonDialogs" selector="rememberedPaths">rememberedPaths	^rememberedPaths</body><body package="VRCommonDialogs" selector="rememberedPaths:">rememberedPaths: aValue	rememberedPaths := aValue</body><body package="VRCommonDialogs" selector="separator">separator	"OS specific separator as a String"	^self class separator</body><body package="VRCommonDialogs" selector="setDirectoryLabel">setDirectoryLabel	"Private - Update the label which specifies the current path"	| newPath |	self builder notNil		ifTrue: [ 				newPath :=  self buildPath: String new.			newPath ~= self path value				ifTrue: [ self path: newPath ] ]</body><body package="VRCommonDialogs" selector="title">title	"Return the string that is to be displayed on the dialog's title bar"	^title</body><body package="VRCommonDialogs" selector="title:">title: aTitle	"Assign the string that is to be displayed on the dialog's title bar"	title := aTitle</body><body package="VRCommonDialogs" selector="volumeName">volumeName	"The current volume value"	^volumeName</body><body package="VRCommonDialogs" selector="volumeName:">volumeName: aVolume	"Set volume for inital display of dialog.  The argument must be a member of the current	 collection of volumes; otherwise the default volume is used."	openedDialog 		ifTrue: [			aVolume ~= self volumeName value ifTrue: [ 				( self volumeExists: aVolume )					ifTrue: [ self volumeName value: aVolume ]					ifFalse: [ self volumeName value isNil 						ifTrue: [ self volumeName value: self class currentVolume ]						ifFalse: [ ( self volumeExists: self volumeName value ) notNil							ifTrue: [ self volumeName value: self volumeName value ]							ifFalse: [ self volumeName value: self class currentVolume ] ] ] ] ]		ifFalse: [ self volumeName value: aVolume ]</body><body package="VRCommonDialogs" selector="volumeNames">volumeNames	"Private - current list of volume names which appear in the volumes combo box"	^volumeNames</body><body package="VRCommonDialogs" selector="volumeNames:">volumeNames: aVolumeNameCollection	"Private - Assign the collection of volumes which can be selected in File Dialog."	volumeNames := aVolumeNameCollection asValue</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>initialize-release</category><body package="VRCommonDialogs" selector="initVolumeAndDirectory">initVolumeAndDirectory	"private - initialize and check the volume and directory values from client."	| tempArray |	self class updateCurrentPath.	self path notNil		ifTrue: [ ( self pathExists: self path value )			ifTrue: [ ^self updatePath: self path value ] ].	tempArray := self setInitialState: self volumeName value directoryName: self directoryName.	self volumeName retractInterestsFor: self.	self volumeName value: ( tempArray at: 1 ).	directoryName := tempArray at: 2.	self oldVolume: self volumeName value.	self rememberedPaths at: self oldVolume put: directoryName.	self volumeName onChangeSend: #changedVolume to: self.	( ( ( Filename components: directoryName ) first = '.' or: 	[ ( Filename components: directoryName ) first = '..' ] )		ifTrue: [ ( self parsePath: directoryName			accountForFilename: false ) ~= 0 ]		ifFalse: [ ( self parsePath: ( self buildPath: String new )			accountForFilename: false ) ~= 0 ] )			ifTrue: [ self volumeName value: self class currentVolume.				directoryName := self class currentDirectory ].	self updatePath: self directoryName</body><body package="VRCommonDialogs" selector="initialize">initialize	super initialize.	directoryNames := SelectionInList new.	volumeName := '' asValue.	volumeNames := Filename volumes asList asValue.	path := '' asValue.	directoryName := ''.	directoryMustExist := true.	openedDialog := false.	rememberedPaths := Dictionary new</body><body package="VRCommonDialogs" selector="initializeNotification">initializeNotification	"Private - update dependencies"	self volumeName onChangeSend: #changedVolume to: self.	self path onChangeSend: #enteredPath to: self.	(self builder componentAt: #directoryNamesWidget) widget controller setDispatcher:		(UIDispatcher new doubleClick: [self changedDirectory]).	self builder keyboardProcessor			keyboardHook:  [:ev :ctrl | self keyboardEvent: ev].	self title isNil ifFalse: [ self builder window label: self title ].</body><body package="VRCommonDialogs" selector="setInitialState:directoryName:">setInitialState: volume directoryName: directory"Private - setup initial volume and directory depending upon user info provided. This method guarantees that both the volume and directory will have a value, although it does not check for validity."	| tempVolume tempDirectory components |	tempVolume := nil.	tempDirectory := nil.	directory isEmpty		ifTrue: [  volume isEmpty "vol but no dir, so root"			ifFalse: [ tempVolume := volume.				tempDirectory := self separator ] ] 		ifFalse: [ components := Filename components: directory. 			 ( ( components first = '.' or: [ components first = '..' ] ) or: [ volume isEmpty ] )				ifTrue: [ tempVolume := self class currentVolume.					components first = '.' ifTrue: [ tempDirectory := self class currentDirectory ].					components first = '..' ifTrue: [ tempDirectory := self class currentDirectory asFilename head ].					tempDirectory notNil						ifTrue: [ components size &gt; 1							ifTrue: [ 2 to: components size do: [ :anElement | 							tempDirectory := self constructPath: tempDirectory 								with: ( components at: anElement ) ] ] ]						ifFalse: [ tempDirectory := directory ] ]				ifFalse: [ tempVolume := volume.					tempDirectory := directory ] ].	( self pathExists: ( self constructPath: tempVolume with: tempDirectory ) )		ifFalse: [ tempVolume := self class currentVolume.			tempDirectory := self class currentDirectory ].	^Array with: tempVolume with: tempDirectory</body><body package="VRCommonDialogs" selector="setLabels">setLabels	"Open the dialog"	| fontDesc charAttr textAttr label |	label := ComposedText new.	fontDesc := (TextAttributes defaultNoCopy characterAttributes defaultQueryFor: nil) copy.	fontDesc pixelSize: ( fontDesc pixelSize min: 16 ).	charAttr := CharacterAttributes newWithDefaultAttributes.	charAttr setDefaultQuery: fontDesc.	textAttr := TextAttributes characterAttributes: charAttr.	self class labels do: [ :component |		label :=  ( self builder componentAt: component ) widget label text string asComposedText.		label textStyle: textAttr.		label compositionWidth: label width.		( self builder componentAt: component ) label: label ]</body><body package="VRCommonDialogs" selector="setVolumeAsEmpty">setVolumeAsEmpty	"Private - Found a volume that is not valid, eg floppy drive with no floppy.  Set the list of 	directories as empty"	directoryNames list: List new.</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>actions</category><body package="VRCommonDialogs" selector="okPressed">okPressed	"Private - Method handler for the open or save button."	(self directoryMustExist)	ifTrue: [ ( self pathExists: self path value )		ifTrue: [ self accept value: true ]		ifFalse: [ Dialog warn: '"' , self path value, '" does not exist.' ] ]	ifFalse: [ 		( self directoryPathIsValid: self path value ) 			ifTrue: [ ^self accept value: true ].		Dialog warn: '"' , self path value , '" is not a valid file path.' ]</body><body package="VRCommonDialogs" selector="open">open	"Open a Directory dialog box which allows the selection of a directory path.  	If OK is pressed, then a string indiciating a full path is answered.  	Cancel answers nil."	| spec |	self builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self allButOpenFrom:spec.	self initializeNotification.	self initVolumeAndDirectory.	Filename volumeSeparator isNil		ifTrue: [ ( self builder componentAt: #volumeNamesWidget ) beInvisible.			( self builder componentAt: #volumeLabel ) beInvisible ].	openedDialog := true.	self setLabels.	"kludgy fix, must move part after open or list box defaults to wrong look policy"	self postOpenBlock: [  :dialog :uiBuilder | 		partMoveBy notNil ifTrue: [ ( self builder componentAt: #compPart ) moveBy: partMoveBy ] ].	self builder openDialog.	(self accept value)		ifFalse: [ ^nil ]		ifTrue: [ self saveDialogState.			^(self constructPath: self path value 				with: self separator ) ]</body><body package="VRCommonDialogs" selector="saveDialogState">saveDialogState	"Private - save the state so it can be restored next time the dialog is opened."	self class currentDirectory: self directoryName.	self class currentVolume: self volumeName value</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>events</category><body package="VRCommonDialogs" selector="changedDirectory">changedDirectory	"Private - The selection in the Directory list widget has occurred.  Update	the input field with the revised path. "	( self directoryNames selectionIndex = 0 )	ifFalse: [ ( self directoryNames selection = '..' )		ifTrue: [ self directoryName: '..' ]		ifFalse: [ self directoryName: ( self constructPath: self directoryName 			with: self directoryNames selection ) ] ]</body><body package="VRCommonDialogs" selector="changedVolume">changedVolume	"Private - The volume has so update the current directory as root."	| newDir | 	self rememberedPaths at: oldVolume put: self directoryName.	newDir := self rememberedPaths at: self volumeName value ifAbsent: [nil].	self oldVolume: self volumeName value.	( self pathExists: self volumeName value )		ifTrue: [ newDir notNil				ifTrue: [self directoryName: newDir]				ifFalse: [self directoryName: self separator ]]		ifFalse: [ "Drive is not valid eg empty floppy so set list as empty"			directoryName := self separator.			self setVolumeAsEmpty.			self setDirectoryLabel ]</body><body package="VRCommonDialogs" selector="keyboardEvent:">keyboardEvent: ev	"Private - If the event is an escape then do a cancel"	ev keyValue = Character esc		ifTrue: [ self accept value: false.				self closeRequest.				^nil ].	ev keyValue = Character cr		ifTrue: [			( self builder componentAt: #cancelButton ) widget controller =				self builder keyboardProcessor currentConsumer				ifTrue: [ 					self accept value: false.					self closeRequest.					^nil ].			( ( self builder componentAt: #directoryNamesWidget ) widget controller =				self builder keyboardProcessor currentConsumer and: 				[ self directoryNames selectionIndex ~= 0 ] )				ifTrue: [ self changedDirectory.					^nil ]				ifFalse: [					self builder keyboardProcessor forceGlobalAccept.					( self builder componentAt: self getTextInputField ) 						widget controller selectEntireText.					self processEnteredPath.					^nil ] ].	^ev</body><body package="VRCommonDialogs" selector="updateCurrentDirectoryContents:">updateCurrentDirectoryContents: filterString"Private  - This method handles the interaction with the filing system when the user navigates through the directory structure. directoryNames, which hold the subdirectories within a particular directory, is updated with new values."	| temp fullList list dList originalCursor entryFullPath |	originalCursor := Cursor currentCursor.	Cursor wait showWhile: [	( self pathExists: self volumeName value )	ifFalse: [ self setVolumeAsEmpty ]	ifTrue:		[ Filename errorReporter errorSignal			handle: [:ex |				directoryNames list: List new.				originalCursor show.				^nil ]			do: [temp := ( self buildPath: String new ) asFilename.					list := temp directoryContents asSortedCollection.					fullList := ( temp filesMatching: '*' ) asSortedCollection].		dList := List new.		list with: fullList do: [ :directoryEntry :directoryEntryPath |				entryFullPath := Filename concreteClass new named: directoryEntryPath.			entryFullPath  isReadable				ifTrue:[ entryFullPath isDirectory					ifTrue: [ filterString isNil						ifTrue:[ dList add: directoryEntry]						ifFalse: [ ( filterString match: directoryEntry )							ifTrue:[ dList add: directoryEntry ] ] ] ] ].		( self directoryName asString match: self directoryName asFilename head ) 			ifFalse: [ dList addFirst: '..' ]. "if not at top of dir hierarchy"		directoryNames list: dList ] ]</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog</class-id> <category>private</category><body package="VRCommonDialogs" selector="widget:">widget: aWidget	"Private - Set the widget for the receiver."	^self loadFromWidget: aWidget</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="constructPath:with:">constructPath: aString1 with: aString2	| newString |	( aString1 isNil or: [ aString1 isEmpty ] )		ifTrue: [ ^ aString2 ]		ifFalse: [ 	( ( newString := aString1 ) last = Filename volumeSeparator )			ifTrue: [ newString := newString , self separator ].			aString2 notNil				ifTrue: [ 					Object errorSignal						handle: [:ex | ^newString last = Filename separator								ifTrue: [ newString , aString2 ]								ifFalse: [ newString, self separator, aString2 ] ]						do: [^newString asFilename constructString: aString2]]				ifFalse: [ ^newString ] ]</body><body package="VRCommonDialogs" selector="currentDirectory">currentDirectory	"Return the directory that the user last accessed from the directory or file selection dialogs. 	This currently gets updated only when the user presses OK"	CurrentDirectory isNil ifTrue: [ CurrentDirectory := self getDefaultDirectoryName ].	^CurrentDirectory</body><body package="VRCommonDialogs" selector="currentDirectory:">currentDirectory: aDirectory	"Assign the directory that the user last accessed from the directory or file 	selection dialogs.  This currently gets updated only when the user presses OK"	CurrentDirectory := aDirectory</body><body package="VRCommonDialogs" selector="currentVolume">currentVolume	"Return the volume that the user last accessed from the directory or file selection dialogs.  	This currently gets updated only when the user presses OK"	( CurrentVolume isNil or: [ CurrentVolume isEmpty ] ) ifTrue: 		[ CurrentVolume := self getDefaultVolumeName ].	^CurrentVolume</body><body package="VRCommonDialogs" selector="currentVolume:">currentVolume: aVolume	"Assign the volume that the user last accessed from the directory or file selection dialogs.  	This currently gets updated only when the user presses OK"	CurrentVolume := aVolume</body><body package="VRCommonDialogs" selector="getDefaultDirectoryName">getDefaultDirectoryName	"Get the initial volume to the volume specified in the default directory."	|temp dirName|	dirName := ''.	temp := Filename components: Filename defaultDirectory asString.	temp removeFirst.	temp do: [:anElement | dirName := dirName, self separator, anElement].	^dirName, self separator</body><body package="VRCommonDialogs" selector="getDefaultVolumeName">getDefaultVolumeName	"Get the initial volume to the volume specified in the default directory."	| volumeString |	volumeString := ( Filename components: Filename defaultDirectory asString ) first.	volumeString last ~= Filename separator 		ifTrue: [ volumeString := volumeString , self separator ].	^self getSystemVolumeNames 		detect: [ :volume | volume match: volumeString ] 		ifNone: [ ^self getSystemVolumeNames first ]</body><body package="VRCommonDialogs" selector="getSystemVolumeNames">getSystemVolumeNames	"Get the list of volumes available within the entire system.  This list of volumes is the default"	^Filename volumes</body><body package="VRCommonDialogs" selector="initialize">initialize	"CommonDirectorySelectionDialog initialize"	self currentVolume: nil.	self currentDirectory: nil.</body><body package="VRCommonDialogs" selector="labels">labels	"Private - IDs for label and button widgets.  Used to pass font information to these static	text widgets"	^OrderedCollection withAll: #( 		#pathLabel		#volumeLabel		#directoryLabel		#okButton		#cancelButton )</body><body package="VRCommonDialogs" selector="pathExists:">pathExists: aString	"Check if a path string exists.  Return a boolean"	| result pathString components |	( aString isNil or: [ aString isEmpty ] ) ifTrue: [ ^false ].	self separator notNil 		ifTrue: [ ( aString occurrencesOf: Filename volumeSeparator ) &gt; 1			ifTrue: [ ^false ] ].	components := Filename components: aString. 	 ( components first = '.' or: [ components first = '..' ] ) 		ifTrue: [ 			components first = '.' 				ifTrue: [ pathString := self constructPath: self currentVolume 					with: self currentDirectory ].			components first = '..' 				ifTrue: [ pathString := self constructPath: self currentVolume 					with: self currentDirectory asFilename head ].		components size &gt; 1			ifTrue: [ 2 to: components size do: [ :anElement | 				anElement = '.' ifFalse: [					anElement = '..' 						ifTrue: [ pathString := pathString asFilename head ]						ifFalse: [ pathString := self constructPath: pathString with: ( components at: anElement ) ] ] ] ] ]		ifFalse: [ pathString := aString ].	Object errorSignal		handle: [:ex | result := false. ex return]		do: [result := pathString asFilename definitelyExists].	^result</body><body package="VRCommonDialogs" selector="separator">separator	^String with: Filename separator</body><body package="VRCommonDialogs" selector="updateCurrentPath">updateCurrentPath	"Check if the CurrentVolume and CurrentDirectory is as valid path.  If not reset"	( self currentVolume isEmpty )		ifTrue: [ ( self pathExists: self currentDirectory )			ifFalse: [ self currentVolume: self getDefaultVolumeName.				self currentDirectory: self getDefaultDirectoryName ] ]		ifFalse: [ ( self pathExists: ( self constructPath: self currentVolume with: self currentDirectory ) )			ifFalse: [ self currentVolume: self getDefaultVolumeName.				self currentDirectory: self getDefaultDirectoryName ] ]</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>private</category><body package="VRCommonDialogs" selector="getTextInputField">getTextInputField	^#fileName</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>initialize-release</category><body package="VRCommonDialogs" selector="initialize">initialize	"Private - Initialize dialog to have default values."	super initialize.	fileName := String new asValue.	filter := '' asValue.	filters := List new asValue.	title := String new.	fileNames := SelectionInList new.	fileMustExist := false.	promptForOverwrite := false.</body><body package="VRCommonDialogs" selector="initializeNotification">initializeNotification	"Private - update dependencies"	super initializeNotification. 	self filter onChangeSend: #updateCurrentDirectoryContents: to: self.	self fileName onChangeSend: #enteredPath to: self.	fileNames selectionIndexHolder onChangeSend: #changedFile to:self.	(self builder componentAt: #fileNamesList) widget controller setDispatcher:		(UIDispatcher new doubleClick: [self fileName value = '' ifFalse: [accept value: true]]).</body><body package="VRCommonDialogs" selector="setDirectoryLabel">setDirectoryLabel	"Private - Update the label which specifies the current path"	|labelWidgetWrapper|	(labelWidgetWrapper := self builder componentAt: #directoryLabel) isNil		ifFalse: [ labelWidgetWrapper labelString: ( self buildPath: String new ) ]</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>accessing</category><body package="VRCommonDialogs" selector="fileMustExist">fileMustExist	"Specifies whether the file name specified must exist within the system in order to accept"	^fileMustExist</body><body package="VRCommonDialogs" selector="fileMustExist:">fileMustExist: aBoolean	"Specifies whether the file name specified must exist within the system in order to accept"	fileMustExist := aBoolean</body><body package="VRCommonDialogs" selector="fileName">fileName	"Returns the filename.ext string"	fileName isNil ifTrue: [ fileName := String new asValue ].	^fileName</body><body package="VRCommonDialogs" selector="fileName:">fileName: aName	"Assign the filename.ext"	aName ~= self fileName value ifTrue: [ self fileName value: aName ]</body><body package="VRCommonDialogs" selector="fileNames">fileNames	"Private - List of filenames within the current subdirectories"	^fileNames</body><body package="VRCommonDialogs" selector="fileNames:">fileNames: aNameCollection	"Private - assign the list of filenames within the current subdirectories"	fileNames := aNameCollection</body><body package="VRCommonDialogs" selector="filter">filter	"Returns the current filter in effect"	^filter</body><body package="VRCommonDialogs" selector="filter:">filter: aFilter	"Assign the default filter value for File Dialog. The filter must exist within the list of filters or this 	operation is ignored.  If no filter is provided then all files are displayed."	filter value:  aFilter.</body><body package="VRCommonDialogs" selector="filters">filters	"Collection of current active filters"	^filters</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>api</category><body package="VRCommonDialogs" selector="okPressed">okPressed	"Private - check if path is valid."	( ( self pathExists: ( self buildPath: self fileName value ) ) and:  	[ ( self buildPath: self fileName value ) asFilename isDirectory not] )		ifTrue: [ self promptForOverwrite "valid file exists on the system"			ifTrue: [ ( Dialog confirm: ( self buildPath: self fileName value ), ' exists. Overwrite?' )					ifTrue: [ self accept value: true ] ]			ifFalse: [ self accept value: true ].			^self ].	self fileMustExist 		ifTrue:  [ Dialog warn: '"' , self fileName value , '" does not exist.' ]		ifFalse: [ ( self filenameIsValid: self fileName value )			ifTrue: [ self accept value: true ]			ifFalse: [ Dialog warn: '"' , self fileName value , '" is not a valid file path.' ] ]</body><body package="VRCommonDialogs" selector="open">open	"Open the dialog box for opening files. "	self title isEmpty ifTrue: [self title: 'Open'].	^self openDialog: 'Open'</body><body package="VRCommonDialogs" selector="openDialog:">openDialog: acceptButtonString	"Private - Create and display a File Dialog box."	| spec saveFileName |	self filters value isEmpty		ifTrue: [ self filter: String new ]		ifFalse: [ self filter value isEmpty			ifTrue:[ self filter: ( self filters value at: 1 ) ]			ifFalse:[ self filter: ( self filters value 				detect: [ :filterEntry | self filter value = filterEntry key ] 				ifNone:[ self filters value at: 1 ] ) ] ].	saveFileName := self fileName value. 	self builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self allButOpenFrom:spec.	openedDialog := true.	self builder window label: self title.	self initializeNotification.	self initVolumeAndDirectory.	( self builder componentAt: #acceptButton ) labelString: acceptButtonString.	self setLabels.	Filename volumeSeparator isNil		ifTrue: [ ( self builder componentAt: #volumeNamesWidget ) beInvisible.				( self builder componentAt: #volumeLabel ) beInvisible ].	self fileName: saveFileName.	self fileNames selection: saveFileName.	openedDialog := true.	self builder openDialog.	( self accept value )		ifFalse: [ ^nil ]		ifTrue: [ self fileName value = nil			ifTrue: [ ^nil ]			ifFalse: [ self saveDialogState.				^self buildPath: self fileName value ] ]</body><body package="VRCommonDialogs" selector="promptForOverwrite">promptForOverwrite	"display message box prompting user to overwrite existing file"	^promptForOverwrite</body><body package="VRCommonDialogs" selector="promptForOverwrite:">promptForOverwrite: aBoolean	"display message box prompting user to overwrite existing file"	promptForOverwrite := aBoolean</body><body package="VRCommonDialogs" selector="save">save	"Open a dialog for 'Save As' file"	self title isEmpty ifTrue: [ self title: 'Save As' ].	^self openDialog: 'Save'</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>events</category><body package="VRCommonDialogs" selector="changedDirectory">changedDirectory	"Private - A click in the Directory list widget has occurred and we must update."	super changedDirectory.	self fileNames selection: self fileName value</body><body package="VRCommonDialogs" selector="changedFile">changedFile	"Private - Update the file name input field with the file selected in the file List box."	(self fileNames selection = 0 | self fileNames selection isNil)		ifFalse: [ self fileName retractInterestsFor: self.			self fileName: self fileNames selection.			self fileName onChangeSend: #enteredPath to: self ]</body><body package="VRCommonDialogs" selector="enteredPath">enteredPath	"Private - Handles input for user specified path."		self builder keyboardProcessor focusIsShifting ifFalse: [ ^self ].	self processEnteredPath</body><body package="VRCommonDialogs" selector="updateCurrentDirectoryContents:">updateCurrentDirectoryContents: filterString	"Private - open the current directory and update directoryNames and fileNames instance variables	 with the contents of the directory"	| temp list fullList dList fList originalCursor filterPattern entryFullPath |	filterString isNil 		ifTrue: [ self filters value isEmpty			ifTrue:[ filterPattern := '' ]			ifFalse: [ filterPattern := self filter value key ] ]		ifFalse: [ filterPattern := filterString ].	originalCursor := Cursor currentCursor.	Cursor wait showWhile: [	( self pathExists: self volumeName value )	ifTrue:		[ Object errorSignal			handle: [:ex | directoryNames list: List new.				fileNames list: List new.				originalCursor show.				^nil ]			do: [temp := ( self buildPath: String new ) asFilename.					list := temp directoryContents asSortedCollection.					fullList := ( temp filesMatching: '*' ) asSortedCollection].		dList := List new.		fList := List new.		list with: fullList do: [ :directoryEntry :directoryEntryPath |			entryFullPath := Filename concreteClass new named: directoryEntryPath.			entryFullPath  isReadable				ifTrue:[ entryFullPath  isDirectory					ifTrue: [ dList add: directoryEntry ]					ifFalse: [ filterPattern isEmpty						ifTrue:[ fList add: directoryEntry ]						ifFalse: [ ( filterPattern match: directoryEntry )							ifTrue:[ fList add: directoryEntry ] ] ] ] ].		( self directoryName asString match: self directoryName asFilename head )			ifFalse: [ dList addFirst: '..' ]. "if not at top of dir hierarchy"		directoryNames list: dList.		fileNames list: fList ] ]</body></methods><methods><class-id>UI.CommonFileSelectionDialog</class-id> <category>file utils</category><body package="VRCommonDialogs" selector="addCommonFilter">addCommonFilter	self addFilter: '*.pcl' description: 'Parcels'.	self addFilter: '*.st' description: 'ST Source'.	self addFilter: '*.txt' description: 'Text Files'.	self addFilter: '*.*' description: 'All Files'.	self filter: '*.*'</body><body package="VRCommonDialogs" selector="addFilter:description:">addFilter: aFilter description: aDescription	"Add an entry into the filters dictionary which becomes the filter list for the dialog box.  The 	description is the text to be displayed.  aFilter is the filter string used for matching 	eg. var addFilter: '*.txt' description: 'Text Files' "	self filters value add: (aFilter-&gt;aDescription).</body><body package="VRCommonDialogs" selector="addFilters:">addFilters: anArray	"add a set of filters"	anArray do: [:each |		self addFilter: each filter description: each description].	self filter: (anArray at: 1) filter</body><body package="VRCommonDialogs" selector="filterToString:">filterToString: anAssociation	"Private - convert from a filter to its description"	anAssociation = '' 		ifTrue:[^nil]		ifFalse:[^anAssociation value]</body><body package="VRCommonDialogs" selector="processEnteredPath">processEnteredPath	"Private - Handles input for user specified path."	| leftovers pathComponents |		self fileName value isEmpty not 		ifTrue: [  leftovers := self updatePath: self fileName value.			pathComponents := Filename components: self fileName value.			self fileName retractInterestsFor: self. 			leftovers = 1"Filename was given as last element of path"				ifTrue: [ self fileName value: pathComponents last. 					( self stringHasWildcard: pathComponents last ) not						ifTrue: [ self okPressed ] ].			leftovers = 0 "Entered a directory"				ifTrue: [ self fileName value: String new ].			self fileName onChangeSend: #enteredPath to: self ]</body><body package="VRCommonDialogs" selector="setVolumeAsEmpty">setVolumeAsEmpty	"Private - Found a volume that is not valid, eg floppy drive with no floppy.  Set the list of 	directories and files as empty"	super setVolumeAsEmpty.	fileNames list: List new.</body><body package="VRCommonDialogs" selector="stringToFilter:">stringToFilter: aString	"Private - Convert from a filter description to the filter"	filters value do: [ :anElement | aString = anElement value 		ifTrue: [ ^anElement ] ]</body><body package="VRCommonDialogs" selector="updatePath:">updatePath: aPathString	"Private - Handles input for user specified path."	| leftovers pathComponents|	pathComponents := Filename components: aPathString .	leftovers := self parsePath: aPathString accountForFilename: true.	leftovers &gt; 1		ifTrue: [ Dialog warn: '"' , ( self buildPath: aPathString) , '" is not a valid path.' ]		ifFalse: [ self setDirectoryLabel.			( leftovers = 1 and: [ self stringHasWildcard: pathComponents last ] )				ifTrue: [ self updateCurrentDirectoryContents: pathComponents last ]				ifFalse: [ self updateCurrentDirectoryContents: nil ] ].	^leftovers</body></methods><methods><class-id>UI.CommonFileSelectionDialog class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="labels">labels	^OrderedCollection withAll: #( #fileLabel		#fileTypeLabel		#filenameLabel		#volumeLabel		#DirectoryLabel		#acceptButton		#cancelButton )</body><body package="VRCommonDialogs" selector="openFile">openFile	| inst |	inst := self new.	inst addCommonFilter.	^inst open</body><body package="VRCommonDialogs" selector="openFileWithFilter:">openFileWithFilter: filterArray	| inst |	inst := self new.	inst addFilters: filterArray.	^inst open</body><body package="VRCommonDialogs" selector="saveFile">saveFile	| inst |	inst := self new.	inst addCommonFilter.	^inst save</body><body package="VRCommonDialogs" selector="saveFileWithFilter:">saveFileWithFilter: filterArray	| inst |	inst := self new.	inst addFilters: filterArray.	^inst save</body></methods><methods><class-id>UI.CommonFileFilter</class-id> <category>accessing</category><body package="VRCommonDialogs" selector="description">description	^description</body><body package="VRCommonDialogs" selector="description:">description: aValue	description := aValue</body><body package="VRCommonDialogs" selector="filter">filter	^filter</body><body package="VRCommonDialogs" selector="filter:">filter: aValue	filter := aValue</body></methods><methods><class-id>UI.CommonFileFilter class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="filter:description:">filter: aFilter description: aDescription	^self new filter: aFilter; description: aDescription</body></methods><methods><class-id>UI.CommonMessageDialog</class-id> <category>accessing</category><body package="VRCommonDialogs" selector="button">button	"return default button value"	^button</body><body package="VRCommonDialogs" selector="button:">button: aButton	"Assign the default button to have focus.  Valid values are true, false and nil"	button := aButton</body><body package="VRCommonDialogs" selector="buttonStyle">buttonStyle	"valid styles symbols are #ok, #okCancel, #yesNo, #yesNoCancel, #retryCancel, #abortRetryIgnore"	^buttonStyle</body><body package="VRCommonDialogs" selector="buttonStyle:">buttonStyle: aButtonStyle	"valid styles symbols are #ok, #okCancel, #yesNo, #yesNoCancel, #retryCancel, #abortRetryIgnore"	(self class escapeIsCancelList includes: aButtonStyle)		ifTrue: [self escapeIsCancel: true]		ifFalse: [self escapeIsCancel: false].	buttonStyle := aButtonStyle</body><body package="VRCommonDialogs" selector="criticalIcon">criticalIcon	"Private"	^OpaqueImage		figure: self class criticalImage		shape: self class criticalMask</body><body package="VRCommonDialogs" selector="iconStyle">iconStyle	"Returns one of the following symbols: #information, #warning, #question, #critical"	^iconStyle</body><body package="VRCommonDialogs" selector="iconStyle:">iconStyle: styleSymbol	"valid symbols are #information, #warning, #question, #critical"	iconStyle := styleSymbol.</body><body package="VRCommonDialogs" selector="informationIcon">informationIcon	"Private"	^OpaqueImage		figure: self class informationImage		shape: self class informationMask</body><body package="VRCommonDialogs" selector="message">message	"The string to be displayed within the message box"	^message</body><body package="VRCommonDialogs" selector="message:">message: aString	"The string to be displayed within the message box"	message value: aString asString.</body><body package="VRCommonDialogs" selector="questionIcon">questionIcon	"Private"	^OpaqueImage		figure: self class questionImage		shape: self class questionMask</body><body package="VRCommonDialogs" selector="title">title	"Returns the text to be displayed on the dialog windows title bar"	^title</body><body package="VRCommonDialogs" selector="title:">title: aString	"Assigns the text string to be displayed on the dialog windows title bar"	title := aString</body><body package="VRCommonDialogs" selector="warningIcon">warningIcon	"Private"	^OpaqueImage		figure: self class warningImage		shape: self class warningMask</body></methods><methods><class-id>UI.CommonMessageDialog</class-id> <category>actions</category><body package="VRCommonDialogs" selector="open">open	"open method for MessageDialog, has new text placement"	| result spec valueList labelList layout textHeight textWidth 	windowWidth composedMessage defaultButton |	self buttonStyle isNil		ifTrue: [ labelList := self class buttonLabelList at: #ok ]		ifFalse: [ labelList := self class buttonLabelList at: self buttonStyle ].	valueList := self class buttonValueList at: labelList size.	( self button &gt; valueList size ) ifTrue: [ self button: 1 ].	defaultButton := valueList at: self button.	result := ValueHolder new.	spec := self class interfaceSpecFor: #windowSpec.	self allButOpenFrom:spec.	composedMessage := self message value asComposedText.	layout := ( self builder componentAt: #messageArea ) layout.	textWidth := composedMessage width + 20.	textWidth &gt; ( Screen default bounds width  / 2 )		ifTrue: [ textWidth := ( Screen default bounds right  / 2).			composedMessage compositionWidth: textWidth ].	textHeight :=composedMessage height + composedMessage lineGrid.	self setInitialGap.	self addGap: layout top + textHeight.	self addLabels: labelList		values: valueList		default: defaultButton		storeInto: result		takeKeyboard: true		equalize: true.	self addGap: 10.	windowWidth := textWidth + 20.	self iconStyle = #none		ifFalse: [ ( self builder componentAt: #iconLabel )			label: ( self perform: (self class iconStyleList at: self iconStyle ) ).			windowWidth := windowWidth + ( self builder componentAt: #iconLabel ) bounds right + 20.					( windowWidth &lt; self builder window displayBox extent x ) 						ifTrue: [ windowWidth := self builder window displayBox extent x.							layout left: ( self builder componentAt: #iconLabel ) bounds right + 20 ]						ifFalse:[ layout left: ( ( self builder componentAt: #iconLabel ) bounds right + 15 ) ] ]		ifTrue:[ ( windowWidth &lt; self builder window displayBox extent x ) 					ifTrue: [ windowWidth := self builder window displayBox extent x ].				layout left: 15 ].	layout right: layout left + textWidth.	layout bottom: layout top + textHeight.	( self builder componentAt: #messageArea ) layout: layout.	self builder window label: self title.	self builder openDialogWithExtent: windowWidth @ 		self builder window displayBox extent y.		cancel value		ifTrue:[ ^( valueList at: ( labelList indexOf: 'Cancel' ) ) ]		ifFalse:[ ^result value ]</body></methods><methods><class-id>UI.CommonMessageDialog</class-id> <category>initialize-release</category><body package="VRCommonDialogs" selector="initialize">initialize	"Private"	super initialize.	self title: ''.	message := '' asValue.	self button: 1.	self escapeIsCancel: false.	self iconStyle: #none</body></methods><methods><class-id>UI.CommonMessageDialog class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="buttonLabelList">buttonLabelList	"Private - Initialize a dictionary that associates a user supplied symbol with the label value"	buttonLabelList isNil		ifTrue:[			buttonLabelList := Dictionary new.			buttonLabelList at: #ok put: #('OK');				at: #okCancel put: #('OK' 'Cancel');				at: #yesNo put: #('Yes' 'No');				at: #retryCancel put: #('Retry' 'Cancel');				at: #yesNoCancel put: #('Yes' 'No' 'Cancel');				at: #abortRetryIgnore put: #('Abort' 'Retry' 'Ignore')].		^buttonLabelList</body><body package="VRCommonDialogs" selector="buttonValueList">buttonValueList	"Private - list of possible return values for button action"	^#(#(true) #(true false) #(true false nil)).</body><body package="VRCommonDialogs" selector="escapeIsCancelList">escapeIsCancelList	"Private - A list of button styles which equates the escape key with cancel"	^#(#yesNoCancel #okCancel #retryCancel)</body><body package="VRCommonDialogs" selector="iconStyleList">iconStyleList	"Private - Initialize a dictionary that associates a icon symbol to the method which returns the image"	iconStyleList isNil		ifTrue:[			iconStyleList := Dictionary new.			iconStyleList at: #information put: #informationIcon;				at: #critical put: #criticalIcon;				at: #warning put: #warningIcon;				at: #question put: #questionIcon].		^iconStyleList</body><body package="VRCommonDialogs" selector="initialize">initialize	"CommonMessageDialog initialize"	self buttonLabelList.	self buttonValueList.	self iconStyleList</body><body package="VRCommonDialogs" selector="open:message:title:">open: iconSymbol message: aMessageString title: aTitleString	| inst |	inst := self new.	inst message: aMessageString.	inst iconStyle: iconSymbol.	^inst open</body><body package="VRCommonDialogs" selector="openCritical:">openCritical: aMessage	^self 		open: #critical		message: aMessage		title: 'Critical Warning !'</body><body package="VRCommonDialogs" selector="openInformation:">openInformation: aMessage	^self 		open: #information		message: aMessage		title: 'Information'</body><body package="VRCommonDialogs" selector="openQuestion:">openQuestion: aMessage	^self 		open: #question		message: aMessage		title: 'Question'</body><body package="VRCommonDialogs" selector="openWarning:">openWarning: aMessage	^self 		open: #warning		message: aMessage		title: 'Warning !'</body></methods><methods><class-id>UI.CommonPrompter</class-id> <category>accessing</category><body package="VRCommonDialogs" selector="initialAnswer">initialAnswer	"Returns the string initially displayed in the text input widget"	^initialAnswer</body><body package="VRCommonDialogs" selector="initialAnswer:">initialAnswer: aString	"Assign the string initially displayed in the text input widget"	initialAnswer := aString</body><body package="VRCommonDialogs" selector="message">message 	"The string displayed in the message portion of the dialog"	^message</body><body package="VRCommonDialogs" selector="message:">message: aMessage	"The string displayed in the message portion of the dialog"	message value: aMessage</body><body package="VRCommonDialogs" selector="title">title	"Returns the string to be displayed in the window title bar"	^title</body><body package="VRCommonDialogs" selector="title:">title: aTitle	"Assign the string to be displayed in the window title bar"	title := aTitle</body></methods><methods><class-id>UI.CommonPrompter</class-id> <category>initialize-release</category><body package="VRCommonDialogs" selector="initialize">initialize	"Private"	super initialize.	self title: ''.	message := ''  asValue.	self initialAnswer: ''.</body></methods><methods><class-id>UI.CommonPrompter</class-id> <category>actions</category><body package="VRCommonDialogs" selector="open">open	"open the dialog"	| spec string textWidth textHeight composedMessage layout |	string := ValueHolder with: self initialAnswer asString.	spec := (self class interfaceSpecFor: #windowSpec).	self allButOpenFrom:spec.	composedMessage := self message value asComposedText.	layout := (self builder componentAt: #messageArea) layout.	textWidth := composedMessage width + 20.	textWidth &gt; (Screen default bounds width  / 2)		ifTrue: [ textWidth := (Screen default bounds right  / 2).			composedMessage compositionWidth: textWidth ].	textHeight :=composedMessage height.	layout right &lt; ( layout left + textWidth + 20 )		ifTrue: [ layout right: layout left + textWidth + 20 ].	layout bottom: layout top + textHeight.	(self builder componentAt: #messageArea) layout: layout.	self setInitialGap.	self addGap: 15.	self addGap: textHeight + 10.	self addTextLine: string.	self addGap: 10.	self addOK: [true].	self addGap: 20.	self preOpen.	self builder window label: self title.	self builder openDialogWithExtent: 		( ( layout left + layout right ) max: self builder window extent x ) @ 		self builder window displayBox extent y.	^self accept value		ifTrue: [string value]		ifFalse: [nil].</body></methods><methods><class-id>UI.CommonPrompter class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="openPrompter:">openPrompter: aString	^self openPrompter: aString initialAnswer: ''</body><body package="VRCommonDialogs" selector="openPrompter:initialAnswer:">openPrompter: aString initialAnswer: answer	^self openPrompter: aString initialAnswer: answer title: ''</body><body package="VRCommonDialogs" selector="openPrompter:initialAnswer:title:">openPrompter: aString initialAnswer: answer title: title	| inst |	inst := self new.	inst message: aString.	inst initialAnswer: answer.	inst title: title.	^inst open</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>accessing</category><body package="VRCommonDialogs" selector="initialSelection">initialSelection	"Accessor for the initial selection"	^initialSelection</body><body package="VRCommonDialogs" selector="initialSelection:">initialSelection: aListItem	"Assign the initial selection"	initialSelection := aListItem</body><body package="VRCommonDialogs" selector="list">list	"Accessor for the list of items"	^list</body><body package="VRCommonDialogs" selector="list:">list: aList	"Assignment for the list of item to be displayed"	list := aList</body><body package="VRCommonDialogs" selector="message">message	"Returns the message to be displayed on the list dialog"	^message</body><body package="VRCommonDialogs" selector="message:">message: aMessage	"Assigns the message string to be displayed on the list dialog"	message value: aMessage</body><body package="VRCommonDialogs" selector="multipleSelect">multipleSelect	"A boolean whether multiple selections are allowed"	^multipleSelect</body><body package="VRCommonDialogs" selector="multipleSelect:">multipleSelect: aBoolean	"Assign whether multiple selections are allowed"	multipleSelect := aBoolean</body><body package="VRCommonDialogs" selector="printSelector">printSelector	"Returns the symbol of the selector used to obtain the display string for the SequenceView.	If nil, then the SequenceView default will be used"	^printSelector</body><body package="VRCommonDialogs" selector="printSelector:">printSelector: aSymbol	"Assign the symbol of the selector used to obtain the display string for the SequenceView.	If nil, then the SequenceView default will be used"	printSelector := aSymbol</body><body package="VRCommonDialogs" selector="title">title	"Returns the string to be displayed in the dialog window's title bar."	^title</body><body package="VRCommonDialogs" selector="title:">title: aString	"Returns the string to be displayed in the dialog window's title bar."	title := aString</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>initialize-release</category><body package="VRCommonDialogs" selector="initialize">initialize	"Private"	super initialize.	list := SelectionInList new.	self title: ''.	self multipleSelect: false.	message := '' asValue.	self printSelector: nil.</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>private</category><body package="VRCommonDialogs" selector="adjustLayout">adjustLayout	"Private -  adjust the layout of the message label to span multiple lines and list widget	to calculated list box height depending on the number of elements." 		| composedMessage layout textWidth textHeight listHeight wrapper listWidth index pad |	composedMessage := self message value asComposedText.	wrapper := self builder componentAt: #messageArea.	layout := wrapper layout.	textWidth := composedMessage width.	textWidth &gt; layout width		ifTrue: [ textWidth := layout width.			composedMessage compositionWidth: textWidth - 20 ].	textHeight := composedMessage height.	layout right: layout left + textWidth.	layout bottom: layout top + textHeight.	wrapper layout: layout.	wrapper := self builder componentAt: #listWidget.	layout := wrapper layout.	self list list size &lt;= 10		ifTrue: [ wrapper decorator noVerticalScrollBar ].	listWidth := wrapper layout right - wrapper layout left.	index := 0.	pad := layout bottom - layout top.	self list list detect: [ :entry | 		index := index + 1.		( wrapper widget displayStringAt: index ) asComposedText width &gt; listWidth ]		ifNone: [ wrapper decorator noHorizontalScrollBar.			pad := 0 ].	listHeight := ( wrapper widget displayStringAt: index ) asComposedText height * 		( self list list size min: 10 ) .	layout bottom: layout top + listHeight + pad.	wrapper layout: layout.	( self builder componentAt: #okButton ) moveBy: 0@( textHeight + listHeight ).	( self builder componentAt: #cancelButton ) moveBy: 0@( textHeight + listHeight )</body></methods><methods><class-id>UI.CommonListChooser</class-id> <category>actions</category><body package="VRCommonDialogs" selector="open">open	"Open the dialog"	| spec |	self builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self multipleSelect		ifTrue: [ 			self list:( MultiSelectionInList with: self list ).			spec := self class interfaceSpecFor: #windowSpecMultipleSelect ]		ifFalse: [ 			self list: ( SelectionInList with: self list ).			spec := self class interfaceSpecFor: #windowSpec ].	self allButOpenFrom:spec.	( self builder componentAt: #listWidget ) widget displayStringSelector: self printSelector.	self adjustLayout. 	self builder window label: self title.	( self builder componentAt: #listWidget ) widget 		controller setDispatcher: (UIDispatcher new doubleClick: 		[ ( self list selection  = 0 ) ifFalse: [ accept value: true ] ] ).	( self list list includes: self initialSelection )		ifTrue: [ self list selection: self initialSelection ].	"kludgy fix, must move list box after open or it defaults to wrong look policy"	self postOpenBlock: [  :dialog :uiBuilder | | layout | 		layout := ( uiBuilder componentAt: #messageArea ) layout.		(uiBuilder componentAt: #listWidget) moveBy: 0@( layout bottom - layout top) ].	self builder openDialogWithExtent: self builder window width @ 		( ( self builder componentAt: #okButton) layout bottom + 15 ).	( self accept value )		ifFalse: [ ^nil ]		ifTrue: [ self multipleSelect			ifTrue: [ ^self list selections ]			ifFalse:[ ^self list selection ] ]</body></methods><methods><class-id>UI.CommonListChooser class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="openMultiWith:">openMultiWith: aList	^self openWith: aList multiSelect: true</body><body package="VRCommonDialogs" selector="openWith:">openWith: aList	^self openWith: aList multiSelect: false</body><body package="VRCommonDialogs" selector="openWith:multiSelect:">openWith: aList multiSelect: aBoolean	| inst | 	inst := self new.	inst list: aList.	inst multipleSelect: aBoolean.	^inst open</body></methods><methods><class-id>OS.Filename class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="volumeSeparator">volumeSeparator	"Answer the platform's filename volume separator."	^''</body></methods><methods><class-id>OS.PCFilename class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="volumeSeparator">volumeSeparator	^':'</body></methods><methods><class-id>UI.CommonDirectorySelectionDialog class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Directory' 			#min: #(#Point 355 285 ) 			#max: #(#Point 355 285 ) 			#bounds: #(#Rectangle 399 290 754 575 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#Rectangle 13 29 342 56 ) 					#name: #path 					#model: #path ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 13 83 233 217 ) 					#name: #directoryNamesWidget 					#model: #directoryNames 					#useModifierKeys: true 					#selectionType: #highlight) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 13 241 233 268 ) 					#name: #volumeNamesWidget 					#model: #volumeName 					#comboList: #volumeNames ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 248 83 340 119 ) 					#name: #okButton 					#model: #okPressed 					#label: 'OK' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 248 127 340 163 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#Point 10 8 ) 					#name: #pathLabel 					#label: 'Path:' ) 				#(#LabelSpec 					#layout: #(#Point 11 62 ) 					#name: #directoryLabel 					#label: 'Directory:' ) 				#(#LabelSpec 					#layout: #(#Point 11 220 ) 					#name: #volumeLabel 					#label: 'Drive:' ) ) ) )</body></methods><methods><class-id>UI.CommonFileSelectionDialog class</class-id> <category>interface specs</category><body package="VRCommonDialogs" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 447 279 ) 			#max: #(#{Core.Point} 447 279 ) 			#bounds: #(#{Graphics.Rectangle} 840 525 1287 804 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 0.226636 0 1.0 ) 							#name: #acceptButton 							#model: #okPressed 							#label: 'OK' 							#isDefault: true 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.778037 0 0.0 0 1.0 0 1.0 ) 							#name: #cancelButton 							#model: #cancel 							#label: 'Cancel' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.0201342 0 0.899641 0 0.977629 0 0.985663 ) 						#name: #Composite1 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #fileTypeLabel 							#label: 'File Type:' ) 						#(#{UI.ComboBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.509804 0 0.579439 0 0.980392 ) 							#model: #filter 							#type: #object 							#comboList: #filters 							#readSelector: 							#stringToFilter: 							#printSelector: 							#filterToString: ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.614486 0 0.0392157 ) 							#name: #volumeLabel 							#label: 'Drive:' ) 						#(#{UI.ComboBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.614486 0 0.529412 0 1.0 0 1.0 ) 							#name: #volumeNamesWidget 							#model: #volumeName 							#comboList: #volumeNames ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.0201342 0 0.663082 0 0.977629 0 0.845878 ) 						#name: #Composite2 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0 ) 							#name: #filenameLabel 							#label: 'Filename:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.510638 0 1.0 0 1.0 ) 							#name: #fileName 							#model: #fileName 							#tabable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.0201342 0 0.0 0 0.977629 0 0.168459 ) 						#name: #Composite4 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #fileLabel 							#label: 'File:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.530374 0 0.0 ) 							#name: #DirectoryLabel 							#label: 'Directory:' ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 292 2 ) 							#name: #directoryLabel 							#style: #small ) 						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.189781 0 0.469626 0 1.0 ) 							#name: #fileNamesList 							#flags: 15 							#model: #fileNames 							#useModifierKeys: true 							#selectionType: #highlight ) 						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.530374 0 0.189781 0 1.0 0 1.0 ) 							#name: #directoryNamesWidget 							#flags: 15 							#model: #directoryNames 							#useModifierKeys: true 							#selectionType: #highlight ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.0201342 0 0.172043 0 0.977629 0 0.663082 ) 						#name: #Composite3 ) ) ) ) )</body></methods><methods><class-id>UI.CommonMessageDialog class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="criticalImage">criticalImage	"UIMaskEditor new openOnClass: self andSelector: #criticalImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue red; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; yourself)) usingBits: (ByteArray fromPackedString: '****@@*******(@@@B*****(@@@@@*****@@@@@@**** @@@@@@***(@@@@@@@***@@@@@@@@** @B@@@H@@**@@*@@B(@A* @J*@@*(@A*@@J*@J*@@F(@@J*B* @@V@@@J**(@@@X@@@J**@@@A @@@J* @@@E@@@@**@@@@T@@@J**@@@AP@@B***@@@E @@*(J*@@AV@@J*@J*@@EX@B* @J*@@V(@B(@@J @EZ @B@@@H@@U* @@@@@@@EZ* @@@@@@AU** @@@@@@UZ** @@@@@EV*** @@@@AU****$@@@AUZ****%P@EUV*****)UUUV*******%UZ*** @a'))</body><body package="VRCommonDialogs" selector="criticalMask">criticalMask	"UIMaskEditor new openOnClass: self andSelector: #criticalMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 15 192 0 0 127 248 0 1 255 254 0 3 255 255 0 7 255 255 128 15 255 255 192 31 255 255 224 63 255 255 240 63 255 255 248 127 255 255 252 127 255 255 252 127 255 255 254 255 255 255 254 255 255 255 254 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 127 255 255 255 127 255 255 255 127 255 255 254 63 255 255 254 63 255 255 254 31 255 255 252 15 255 255 252 7 255 255 248 3 255 255 240 1 255 255 224 0 255 255 192 0 127 255 128 0 31 254 0 0 3 240 0])</body><body package="VRCommonDialogs" selector="informationImage">informationImage	"UIMaskEditor new openOnClass: self andSelector: #informationImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: (ByteArray fromPackedString: '****UV*******)V*%Z*****)Z***V*****Z*/:*"****&amp;*+?:*"***)**/?**"***Z**/:**"**&amp;*******"**Z**??***J*&amp;**+?&gt;***F*Z***?:**(Z)***+?***!Z&amp;***/&gt;***E*Z***?:**(V*Z**+?***EZ)**+??:*(U*)**/??**EZ*(******!U**(*****(UZ**(*****EV***(J***AU****)@*(AUZ****)T*EUV******R(UV*******"!Z********"E********* V*********!Z*********%**********&amp;************************* @a'))</body><body package="VRCommonDialogs" selector="informationMask">informationMask	"UIMaskEditor new openOnClass: self andSelector: #informationMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 15 128 0 0 127 240 0 1 255 252 0 3 255 254 0 7 255 255 0 15 255 255 128 31 255 255 192 63 255 255 224 63 255 255 224 127 255 255 248 127 255 255 248 127 255 255 252 127 255 255 252 127 255 255 252 63 255 255 252 63 255 255 252 31 255 255 248 15 255 255 248 7 255 255 240 3 255 255 224 1 255 255 192 0 255 255 128 0 127 255 0 0 31 252 0 0 7 224 0 0 3 224 0 0 1 224 0 0 0 224 0 0 0 96 0 0 0 32 0 0 0 0 0 0 0 0 0])</body><body package="VRCommonDialogs" selector="questionImage">questionImage	"UIMaskEditor new openOnClass: self andSelector: #questionImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: (ByteArray fromPackedString: '****UV*******)V*%Z*****)Z***V*****Z****"****&amp;*+?:*"***)**:/:*"***Z*/*/:*"**&amp;**?:?**"**Z*+?+&gt;**J*&amp;**+:?***F*Z***/:**(Z)****&gt;***!Z&amp;***/****E*Z***&gt;***(V*Z*******EZ)***/***(U*)**+?***EZ*(**/&gt;**!U**(**/**(UZ**(*****EV***(J***AU****)@*(AUZ****)T*EUV******R(UV*******"!Z********"E********* V*********!Z*********%**********&amp;************************* @a'))</body><body package="VRCommonDialogs" selector="questionMask">questionMask	"UIMaskEditor new openOnClass: self andSelector: #questionMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 15 128 0 0 127 240 0 1 255 252 0 3 255 254 0 7 255 255 0 15 255 255 128 31 255 255 192 63 255 255 224 63 255 255 224 127 255 255 248 127 255 255 248 127 255 255 252 127 255 255 252 127 255 255 252 63 255 255 252 63 255 255 252 31 255 255 248 15 255 255 248 7 255 255 240 3 255 255 224 1 255 255 192 0 255 255 128 0 127 255 0 0 31 252 0 0 7 224 0 0 3 224 0 0 1 224 0 0 0 224 0 0 0 96 0 0 0 32 0 0 0 0 0 0 0 0 0])</body><body package="VRCommonDialogs" selector="warningImage">warningImage	"UIMaskEditor new openOnClass: self andSelector: #warningImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); yourself)) usingBits: (ByteArray fromPackedString: '**** J********(UJ********EUJ*******(UT********EUT*******(UUR*******EUUR******(UUUJ******EUUUJ*****(UPET******ET@ET*****(UP@UR*****EU@AUR****(UT@EUJ****EUP@UUJ***(UU@AUT****EUU@UUT***(UUTAUUR***EUUPEUUR**(UUU@UUUJ**EUUUEUUUJ*(UUUTUUUT**EUUUUUUUT*(UUUUAUUUR*EUUUPAUUUS(UUUU@EUUUN!UUUUAUUUT&gt;EUUUUUUUUS:EUUUUUUUT?*@@@@@@@@O&gt;*?????????**????????: @a'))</body><body package="VRCommonDialogs" selector="warningMask">warningMask	"UIMaskEditor new openOnClass: self andSelector: #warningMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 7 0 0 0 15 128 0 0 31 192 0 0 31 192 0 0 63 224 0 0 63 224 0 0 127 240 0 0 127 240 0 0 255 248 0 0 255 248 0 1 255 252 0 1 255 252 0 3 255 254 0 3 255 254 0 7 255 255 0 7 255 255 0 15 255 255 128 15 255 255 128 31 255 255 192 31 255 255 192 63 255 255 224 63 255 255 224 127 255 255 240 127 255 255 240 255 255 255 252 255 255 255 252 255 255 255 254 255 255 255 254 127 255 255 254 63 255 255 254 31 255 255 252 15 255 255 248])</body><body package="VRCommonDialogs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 211 112 ) 			#max: #(#Point 211 112 ) 			#bounds: #(#Rectangle 407 328 618 440 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 38 7 ) 					#name: #iconLabel 					#hasCharacterOrientedLabel: false ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 56 15 189 38 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UI.CommonPrompter class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="emptySpec">emptySpec"UIPainter new openOnClass: self andSelector: #emptySpec"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 20 20 ) 			#max: #(#Point 1280 1024 ) 			#bounds: #(#Rectangle 486 611 754 650 ) 			#isEventDriven: true ) 		#component: #(#SpecCollection #collection: #() ) )</body><body package="VRCommonDialogs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 220 114 ) 			#max: #(#Point 220 114 ) 			#bounds: #(#Rectangle 476 377 696 491 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#Rectangle 16 9 146 38 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UI.CommonListChooser class</class-id> <category>As yet unclassified</category><body package="VRCommonDialogs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 251 123 ) 			#bounds: #(#Rectangle 515 451 766 574 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#Rectangle 12 23 234 58 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 9 43 239 57 ) 					#name: #listWidget 					#flags: 15 					#model: #list 					#multipleSelections: false 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 76 108 104 ) 					#name: #okButton 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 139 76 227 104 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body><body package="VRCommonDialogs" selector="windowSpecMultipleSelect">windowSpecMultipleSelect	"UIPainter new openOnClass: self andSelector: #windowSpecMultipleSelect"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 251 123 ) 			#bounds: #(#Rectangle 515 451 766 574 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#Rectangle 12 23 234 58 ) 					#name: #messageArea 					#flags: 4 					#model: #message 					#isReadOnly: true ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 9 43 239 57 ) 					#name: #listWidget 					#flags: 15 					#model: #list 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 76 108 104 ) 					#name: #okButton 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 139 76 227 104 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><initialize><class-id>UI.CommonDirectorySelectionDialog</class-id></initialize><initialize><class-id>UI.CommonMessageDialog</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>