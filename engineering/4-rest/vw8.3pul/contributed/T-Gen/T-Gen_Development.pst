<?xml version="1.0"?><st-source><!-- Name: T-Gen DevelopmentComment: T-Gen Development  Along with T-Gen Core, this parcel contains the UI, classes, and methods required to GENERATE a T-Gen parser and scanner from a grammar descriptionHideSource: falsePackageName: T-Gen DevelopmentParcel: #('T-Gen_Development')ParcelName: T-Gen DevelopmentSaveSource: trueVersion: 5.0aPre-Unload Block: 	[ :pkg |  #{Tgen.TranslatorGenerator} value preUnloadFor: pkg]Date: 5:31:17 PM January 27, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 27, 2016 at 5:31:17 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GrammarSpecScanner</name><environment>Tgen</environment><super>Tgen.OptimizedScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Development</package></attributes></class><comment><class-id>Tgen.GrammarSpecScanner</class-id><body>This scanner class was automatically generated by T-gen, Version 2.1.</body></comment><class><name>GrammarSpecParser</name><environment>Tgen</environment><super>Tgen.OptimizedLR1Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Development</package></attributes></class><comment><class-id>Tgen.GrammarSpecParser</class-id><body>This parser class was automatically generated by T-gen, Version 2.1.</body></comment><class><name>TranslatorGenerator</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar transformedGrammar isLL1 isSLR1 isLALR1 isLR1 parser statusTextBuffer tokenSpecification grammarSpecification inputText grammarMode parserMode parserResult tokenSpecController scannerClass treeBuilderClass oldScannerSpec oldScannerLits oldScanner specsFileName conflictStrategy parserClassBasename scannerClassname classCategoryName </inst-vars><class-inst-vars>grammarSpecParser tokenSpecParser </class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Development</package></attributes></class><comment><class-id>Tgen.TranslatorGenerator</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I'm an application for generating scanners and parsers for arbitrary context-free languages.  My view contains four panes and several status buttons, as described below:View Panes:	top-left 		- token class specifications are entered and 'accepted' here.	bottom-left	- grammar specifications are entered and 'accepted' here.  Status buttons control what kind of parser is generated, either LL or LR varieties.	top-right		- status transcript, status messages and other information is sent here.	bottom-right	- test strings in the specified language are entered and 'accepted' here.  Status buttons control the resulting parser actions.  To view the result of a test input parse choose the middle button menu item 'result' in the transcript pane.I attempt to generate a parser for a given a context-free grammar.  Basically, I try LL(1) first and LR variations second.  (See the parser generation protocol for more details.)Instance Variables:	grammar					&lt;Grammar&gt; - original context-free grammar for which I'm trying to build a parser.	transformedGrammar	&lt;Grammar | UndefinedObject&gt; - an LL(1) transformed version of my grammar, if needed, requested, and possible.	isLL1,	isSLR1,	isLALR1,	isLR1						&lt;Boolean&gt; - grammar status flags.	parser						&lt;LL1Parser | LR1Parser | UndefinedObject&gt; - a parser for my grammar, if one could be built.	statusTextBuffer			&lt;Text&gt; - status transcript pane text buffer.	tokenSpecification		&lt;Text&gt;	grammarSpecification		&lt;Text&gt;	inputText					&lt;Text&gt;	grammarMode				&lt;Symbol&gt; - represents state of grammar pane status button.	parserMode				&lt;Symbol&gt; - represents state of test input pane status button.	parserResult				&lt;DerivationTreeNode | ParseTreeNode&gt; - result of test input parse.	tokenSpecController		&lt;Controller&gt; - 'accepting' a grammar specification actually processes both grammar and token class specifications.  Direct access to the token spec Controller is needed for reporting errors in the token class specification.	scannerClass				&lt;FSABasedScanner | ?&gt; - class used to build scanners.  Some languages may require more sophisticated scanners with multiple-token lookahead (see FSABasedScannerWithOneTokenLookahead and FSABasedScannerWithTwoTokenLookahead).	treeBuilderClass			&lt;AbstractSyntaxTreeBuilder | ?&gt; - class used to build AST builders for parsers.  Users may define specilizations of this class.	oldScannerSpec 			&lt;String&gt; - previous scanner spec.	oldScannerLits 				&lt;Set of String&gt; - literals from previous grammar spec.	oldScanner 					&lt;FSABasedScanner | ?&gt; - previously generated scanner.	specsFileName				&lt;String&gt; - last used base file name for saving or loading specs.MBB October 8, 1996 -- Added storage of scanner base name and category during installation of a scanner and parser.	parserClassBasename		&lt;String&gt;  the parser base name	scannerClassname			&lt;String&gt;  the name of the scanner class 	classCategoryName 			&lt;String&gt;	  the class category for storing the scanner and parserClass Variables:	StatusTextBufferMenu		&lt;ActionMenu&gt; - menu cache	TextMenu					&lt;ActionMenu&gt; - menu cache	TokenSpecMetaChars 		&lt;Set of: Character&gt; - These characters are special to the token specification parser and must be escaped.</body></comment><class><name>TranslatorGeneratorView</name><environment>Tgen</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammarMode parserMode generator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Development</package></attributes></class><comment><class-id>Tgen.TranslatorGeneratorView</class-id><body>=================================================    Copyright (c) 1994 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am the VisualWorks-style view (application model) for a TranslatorGenerator.  SeeTranslatorGenerator class comment for a description of my subviews.Instance Variables: grammarMode  &lt;AspectAdaptor&gt; - for the generator's grammarMode. parserMode   &lt;AspectAdaptor&gt; - for the generator's parserMode. generator    &lt;TranslatorGenerator&gt; - domain model.</body></comment><class><name>GrammarTreeBuilder</name><environment>Tgen</environment><super>Tgen.AbstractSyntaxTreeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Development</package></attributes></class><shared-variable><name>StatusTextBufferMenu</name><environment>Tgen.TranslatorGenerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>T-Gen Development</package></attributes></shared-variable><shared-variable><name>TokenSpecMetaChars</name><environment>Tgen.TranslatorGenerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>T-Gen Development</package></attributes></shared-variable><shared-variable><name>TextMenu</name><environment>Tgen.TranslatorGenerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>T-Gen Development</package></attributes></shared-variable><methods><class-id>Tgen.GrammarSpecScanner class</class-id> <category>class initialization</category><body package="T-Gen Development">initialize	"GrammarSpecScanner initialize"	"&lt;id&gt;			: [a-zA-Z_][a-zA-Z_0-9]* 			;&lt;keyword&gt;		: ([a-zA-Z_][a-zA-Z_0-9]*\:)+ 		;&lt;literal&gt;			: '(~['] | '')+' {compactDoubleApostrophes} ;&lt;tokenClass&gt;	: \&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;		;&lt;comment&gt;		: \""(~[\""]|\""\""|[\s\t\r\n])*\""	{ignoreComment} ;&lt;space&gt; 		: [\s\t\r\n]+				{ignoreDelimiter} ;"	| table |	self fsa: #( #( nil nil nil nil nil nil nil nil 2 2 nil nil 2 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 2 nil 3 nil nil nil nil 5 9 9 9 9 nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9 9 10 nil nil 9 nil 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 nil nil nil 9 13 nil 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 9 9 9 nil nil ) #( nil nil nil nil nil nil nil nil 2 2 nil nil 2 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 2 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 3 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 8 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 nil ) #( nil nil nil nil 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 6 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 6 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 nil nil nil nil 11 nil 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 11 11 11 11 11 11 11 11 11 11 nil nil nil nil 12 nil nil 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 nil nil nil nil 11 nil 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 13 13 13 13 13 13 13 13 13 13 14 nil nil nil nil nil nil 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 nil nil nil nil 13 nil 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 nil nil nil nil 15 nil 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 15 15 15 15 15 15 15 15 15 15 14 nil nil nil nil nil nil 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 nil nil nil nil 15 nil 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 nil nil nil nil nil ) ).	table := #( nil #( #( ) #( #('&lt;space&gt;' #ignoreDelimiter) ) ) nil #( #( ) #( #('&lt;comment&gt;' #ignoreComment) ) ) nil nil #( #( ) #( #('&lt;literal&gt;' #compactDoubleApostrophes) ) ) nil #( #( '^' '+' ';' '*' ':' ')' '(' '}' '|' '{' '?' ) #( ) ) nil nil #( #( ) #( #('&lt;tokenClass&gt;' nil) ) ) #( #( ) #( #('&lt;id&gt;' nil) ) ) #( #( ) #( #('&lt;keyword&gt;' nil) ) ) nil ).	self constructFinalStateTable: table</body></methods><methods><class-id>Tgen.GrammarSpecParser</class-id> <category>private</category><body package="T-Gen Development">scannerClass	^GrammarSpecScanner</body><body package="T-Gen Development">treeBuilderClass	^GrammarTreeBuilder</body></methods><methods><class-id>Tgen.GrammarSpecParser class</class-id> <category>class initialization</category><body package="T-Gen Development">initialize	"GrammarSpecParser initialize"	"gram	: rule gram					{liftRightChild} ; gram	: 							{GrammarNode} ; rule	 : nonterm ':' rightParts ';' {RRPGProductionNode} ; nonterm : &lt;id&gt;					{NonterminalNode} ; rightParts : regExpr '|' rightParts		{alternate:with:} ; rightParts : regExpr  					; regExpr	: listExpr trans {RRPGRightHandSideNode} ; listExpr		: listExpr '^' catExpr		{ListNode} ;listExpr		: catExpr					;catExpr	 : expr catExpr  {concatenate:with:} ; catExpr	:							{EpsilonNode} ; expr : baseExpr '*'				{StarClosureNode} ; expr : baseExpr '+'				{PlusClosureNode} ; expr : baseExpr '?'				{OptionalNode} ; expr : baseExpr					; baseExpr	: term						; baseExpr	: nonterm					; baseExpr	: '(' subExpr ')'				; subExpr	: listExpr '|' subExpr {alternate:with:} ;subExpr	: listExpr					; trans		: '{' transSym '}'				; trans		:							{nil} ; transSym	: &lt;id&gt; {TranslationNode} ;transSym	: &lt;keyword&gt; {TranslationNode} ; term : &lt;tokenClass&gt;				{TerminalNode } ; term : &lt;literal&gt;					{TerminalNode} ; "	| table prodTable |	prodTable := #( #rule '&lt;Character value: 4&gt;' "16r0004" #trans '&lt;id&gt;' ')' #listExpr '(' ';' #baseExpr ':' #rightParts #gram #expr '}' #subExpr #catExpr '|' #nonterm #regExpr '^' '&lt;tokenClass&gt;' #transSym '{' '?' #term '+' '&lt;keyword&gt;' '&lt;literal&gt;' '*' 'liftRightChild' 'StarClosureNode' 'OptionalNode' 'RRPGRightHandSideNode' 'RRPGProductionNode' 'nil' 'alternate:with:' 'TranslationNode' 'GrammarNode' 'concatenate:with:' 'PlusClosureNode' 'NonterminalNode' 'ListNode' 'TerminalNode' 'EpsilonNode' ).	self tokenTypeTable:  (prodTable copyFrom: 1 to:  29).	table := #( #( 36 #(12 #()38)  nil 19 nil nil nil nil nil nil nil 38 nil nil nil nil nil 2 nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil 3 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil 19 #(16 #()44)  4 13 #(16 #()44)  6 nil 34 nil 11 nil nil 20 #(16 #()44)  18 31 #(16 #()44)  17 nil #(16 #()44)  nil 10 nil nil 12 nil ) #( nil nil 30 nil nil nil nil #(3 #()35)  nil nil nil nil nil nil nil nil #(3 #()35)  nil nil 5 nil nil 25 nil nil nil nil nil nil ) #( nil nil nil 19 #(16 #()44)  nil 13 #(16 #()44)  6 nil nil nil 11 nil nil 24 #(16 #()44)  18 nil #(16 #()44)  17 nil #(16 #()44)  nil 10 nil nil 12 nil ) #( nil nil nil #(13 #(9 ))  #(13 #(9 ))  nil #(13 #(9 ))  #(13 #(9 ))  nil nil nil nil nil nil nil nil #(13 #(9 ))  nil nil #(13 #(9 ))  #(13 #(9 ))  nil #(13 #(9 ))  7 nil 9 nil #(13 #(9 ))  8 ) #( nil nil nil #(13 #(9 24 )32)  #(13 #(9 24 )32)  nil #(13 #(9 24 )32)  #(13 #(9 24 )32)  nil nil nil nil nil nil nil nil #(13 #(9 24 )32)  nil nil #(13 #(9 24 )32)  #(13 #(9 24 )32)  nil #(13 #(9 24 )32)  nil nil nil nil #(13 #(9 24 )32)  nil ) #( nil nil nil #(13 #(9 29 )31)  #(13 #(9 29 )31)  nil #(13 #(9 29 )31)  #(13 #(9 29 )31)  nil nil nil nil nil nil nil nil #(13 #(9 29 )31)  nil nil #(13 #(9 29 )31)  #(13 #(9 29 )31)  nil #(13 #(9 29 )31)  nil nil nil nil #(13 #(9 29 )31)  nil ) #( nil nil nil #(13 #(9 26 )40)  #(13 #(9 26 )40)  nil #(13 #(9 26 )40)  #(13 #(9 26 )40)  nil nil nil nil nil nil nil nil #(13 #(9 26 )40)  nil nil #(13 #(9 26 )40)  #(13 #(9 26 )40)  nil #(13 #(9 26 )40)  nil nil nil nil #(13 #(9 26 )40)  nil ) #( nil nil nil #(9 #(25 ))  #(9 #(25 ))  nil #(9 #(25 ))  #(9 #(25 ))  nil nil nil nil nil nil nil nil #(9 #(25 ))  nil nil #(9 #(25 ))  #(9 #(25 ))  nil #(9 #(25 ))  #(9 #(25 ))  nil #(9 #(25 ))  nil #(9 #(25 ))  #(9 #(25 ))  ) #( nil nil nil 19 #(16 #()44)  nil 13 #(16 #()44)  6 nil nil nil 11 nil nil 23 #(16 #()44)  18 nil #(16 #()44)  17 nil #(16 #()44)  nil 10 nil nil 12 nil ) #( nil nil nil #(25 #(28 )43)  #(25 #(28 )43)  nil #(25 #(28 )43)  #(25 #(28 )43)  nil nil nil nil nil nil nil nil #(25 #(28 )43)  nil nil #(25 #(28 )43)  #(25 #(28 )43)  nil #(25 #(28 )43)  #(25 #(28 )43)  nil #(25 #(28 )43)  nil #(25 #(28 )43)  #(25 #(28 )43)  ) #( nil nil nil 19 #(16 #()44)  14 13 #(16 #()44)  6 nil nil nil 11 nil 21 20 #(16 #()44)  18 nil #(16 #()44)  17 nil #(16 #()44)  nil 10 nil nil 12 nil ) #( nil nil nil nil #(15 #(6 ))  nil nil nil nil nil nil nil nil nil nil nil 15 nil nil 5 nil nil nil nil nil nil nil nil nil ) #( nil nil nil 19 #(16 #()44)  14 13 #(16 #()44)  6 nil nil nil 11 nil 16 20 #(16 #()44)  18 nil #(16 #()44)  17 nil #(16 #()44)  nil 10 nil nil 12 nil ) #( nil nil nil nil #(15 #(6 17 15 )36)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil #(25 #(21 )43)  #(25 #(21 )43)  nil #(25 #(21 )43)  #(25 #(21 )43)  nil nil nil nil nil nil nil nil #(25 #(21 )43)  nil nil #(25 #(21 )43)  #(25 #(21 )43)  nil #(25 #(21 )43)  #(25 #(21 )43)  nil #(25 #(21 )43)  nil #(25 #(21 )43)  #(25 #(21 )43)  ) #( nil nil nil #(9 #(18 ))  #(9 #(18 ))  nil #(9 #(18 ))  #(9 #(18 ))  nil nil nil nil nil nil nil nil #(9 #(18 ))  nil nil #(9 #(18 ))  #(9 #(18 ))  nil #(9 #(18 ))  #(9 #(18 ))  nil #(9 #(18 ))  nil #(9 #(18 ))  #(9 #(18 ))  ) #( nil nil nil #(18 #(4 )41)  #(18 #(4 )41)  nil #(18 #(4 )41)  #(18 #(4 )41)  nil #(18 #(4 )41)  nil nil nil nil nil nil #(18 #(4 )41)  nil nil #(18 #(4 )41)  #(18 #(4 )41)  nil #(18 #(4 )41)  #(18 #(4 )41)  nil #(18 #(4 )41)  nil #(18 #(4 )41)  #(18 #(4 )41)  ) #( nil nil nil nil #(6 #(16 ))  nil nil #(6 #(16 ))  nil nil nil nil nil nil nil nil #(6 #(16 ))  nil nil #(6 #(16 ))  nil nil #(6 #(16 ))  nil nil nil nil nil nil ) #( nil nil nil nil 22 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil #(9 #(7 15 5 ))  #(9 #(7 15 5 ))  nil #(9 #(7 15 5 ))  #(9 #(7 15 5 ))  nil nil nil nil nil nil nil nil #(9 #(7 15 5 ))  nil nil #(9 #(7 15 5 ))  #(9 #(7 15 5 ))  nil #(9 #(7 15 5 ))  #(9 #(7 15 5 ))  nil #(9 #(7 15 5 ))  nil #(9 #(7 15 5 ))  #(9 #(7 15 5 ))  ) #( nil nil nil nil #(16 #(13 16 )39)  nil nil #(16 #(13 16 )39)  nil nil nil nil nil nil nil nil #(16 #(13 16 )39)  nil nil #(16 #(13 16 )39)  nil nil #(16 #(13 16 )39)  nil nil nil nil nil nil ) #( nil nil nil nil #(6 #(6 20 16 )42)  nil nil #(6 #(6 20 16 )42)  nil nil nil nil nil nil nil nil #(6 #(6 20 16 )42)  nil nil #(6 #(6 20 16 )42)  nil nil #(6 #(6 20 16 )42)  nil nil nil nil nil nil ) #( nil nil nil 27 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 28 nil nil nil nil 26 nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil #(22 #(27 )37)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil #(22 #(4 )37)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil 29 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil #(3 #(23 22 14 ))  nil nil nil nil nil nil nil nil #(3 #(23 22 14 ))  nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil #(19 #(6 3 )33)  nil nil nil nil nil nil nil nil #(19 #(6 3 )33)  nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil #(11 #(19 ))  nil nil nil nil nil nil nil nil 32 nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil 19 #(16 #()44)  4 13 #(16 #()44)  6 nil 33 nil 11 nil nil 20 #(16 #()44)  18 31 #(16 #()44)  17 nil #(16 #()44)  nil 10 nil nil 12 nil ) #( nil nil nil nil nil nil nil #(11 #(19 17 11 )36)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil 35 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil #(1 #(18 10 11 8 )34)  nil #(1 #(18 10 11 8 )34)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( 36 #(12 #()38)  nil 19 nil nil nil nil nil nil nil 37 nil nil nil nil nil 2 nil nil nil nil nil nil nil nil nil nil nil ) #( nil #(12 #(1 12 )30)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil 39 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) ).	self constructParseTable: table  with: prodTable.	self finalState: 39</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>status text</category><body package="T-Gen Development">clear	"Reset the transcriptView for the next accept."	self statusTextBuffer clear</body><body package="T-Gen Development">cr	"Perform a carriage return."	self statusTextBuffer cr</body><body package="T-Gen Development">show: aString 	"Append aString to the status transcript text."	self statusTextBuffer show: aString</body><body package="T-Gen Development">showCR: aString 	"Append aString to the status transcript text and perform a carriage return."	self statusTextBuffer show: aString; cr</body><body package="T-Gen Development">tab	"Perform a tab over."	self statusTextBuffer tab</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>state accessing</category><body package="T-Gen Development">grammar	^grammar</body><body package="T-Gen Development">grammar: argument 	grammar := argument</body><body package="T-Gen Development">grammarMode	^grammarMode</body><body package="T-Gen Development">grammarMode: argument 	grammarMode := argument</body><body package="T-Gen Development">grammarSpecification	^grammarSpecification</body><body package="T-Gen Development">grammarSpecification: argument 	grammarSpecification := argument</body><body package="T-Gen Development">inputText	^inputText</body><body package="T-Gen Development">inputText: argument 	inputText := argument</body><body package="T-Gen Development">isLALR1	^isLALR1</body><body package="T-Gen Development">isLALR1: argument 	isLALR1 := argument</body><body package="T-Gen Development">isLL1	^isLL1</body><body package="T-Gen Development">isLL1: argument 	isLL1 := argument</body><body package="T-Gen Development">isLR1	^isLR1</body><body package="T-Gen Development">isLR1: argument 	isLR1 := argument</body><body package="T-Gen Development">isSLR1	^isSLR1</body><body package="T-Gen Development">isSLR1: argument 	isSLR1 := argument</body><body package="T-Gen Development">oldScanner	^oldScanner</body><body package="T-Gen Development">oldScanner: argument 	oldScanner := argument</body><body package="T-Gen Development">oldScannerLits	^oldScannerLits</body><body package="T-Gen Development">oldScannerLits: argument 	oldScannerLits := argument</body><body package="T-Gen Development">oldScannerSpec	^oldScannerSpec</body><body package="T-Gen Development">oldScannerSpec: argument 	oldScannerSpec := argument</body><body package="T-Gen Development">parser	^parser</body><body package="T-Gen Development">parser: argument 	parser := argument</body><body package="T-Gen Development">parserMode	^parserMode</body><body package="T-Gen Development">parserMode: argument 	parserMode := argument</body><body package="T-Gen Development">parserResult	^parserResult</body><body package="T-Gen Development">parserResult: argument 	parserResult := argument</body><body package="T-Gen Development">scannerClass	^scannerClass</body><body package="T-Gen Development">scannerClass: argument 	scannerClass := argument</body><body package="T-Gen Development">specsFileName	^specsFileName</body><body package="T-Gen Development">specsFileName: argument 	specsFileName := argument</body><body package="T-Gen Development">statusTextBuffer	^statusTextBuffer</body><body package="T-Gen Development">statusTextBuffer: argument 	statusTextBuffer := argument</body><body package="T-Gen Development">tokenSpecController	^tokenSpecController</body><body package="T-Gen Development">tokenSpecController: argument 	tokenSpecController := argument</body><body package="T-Gen Development">tokenSpecification	^tokenSpecification</body><body package="T-Gen Development">tokenSpecification: argument 	tokenSpecification := argument</body><body package="T-Gen Development">transformedGrammar	^transformedGrammar</body><body package="T-Gen Development">transformedGrammar: argument 	transformedGrammar := argument</body><body package="T-Gen Development">treeBuilderClass	^treeBuilderClass</body><body package="T-Gen Development">treeBuilderClass: argument 	treeBuilderClass := argument</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>LL parser generation</category><body package="T-Gen Development">ll1Parser	"Attempt to construct an LL(1) parser for my grammar. 	Answer true if I can and false otherwise."	| table prod |	table := self llParserTableClass new.	self grammar selectSets		associationsDo: 			[:assoc | 			prod := assoc key.			assoc value do: [:term | table					atNonterminal: prod leftHandSide					andTerminal: term					addProduction: prod]].	table isDeterministic		ifTrue: 			[self isLL1: true.			self parser: (self ll1ParserClass parseTable: table spaceOptimize startSymbol: self grammar startSymbol).			^true]		ifFalse: 			[self parser: (self ll1ParserClass parseTable: table startSymbol: self grammar startSymbol).			^false]</body><body package="T-Gen Development">ll1ParserWithTransformations	"Assuming my original grammar is not LL(1), attempt to derive an equivalent LL(1) 	grammar and parser for my original grammar through various grammar 	manipulations. Answer true if I can and false otherwise."	| oldGrammar |	oldGrammar := self grammar.	self grammar: oldGrammar copy.	self grammar makeLL1Transformations.	self ll1Parser		ifTrue: 			[self isLL1: true.			self transformedGrammar: self grammar.			self grammar: oldGrammar.			^true]		ifFalse: 			[self grammar: oldGrammar.			^false]</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>private</category><body package="T-Gen Development">astModeMarker	^#AST</body><body package="T-Gen Development">computeProductionMap	"Delegate to my grammar."	^self grammar computeProductionMap</body><body package="T-Gen Development">defaultModeMarker	^#default</body><body package="T-Gen Development">defaultScannerClass	"This is the default scanner class, a more specialized scanner class may be designated using a 	middle button menu item in the transcript pane."	^FSABasedScanner</body><body package="T-Gen Development">defaultTreeBuilderClass	"This is the default tree builder class, a more specialized tree builder class may be designated 	using a middle button menu item in the transcript pane."	^AbstractSyntaxTreeBuilder</body><body package="T-Gen Development">fsaStateClass	^FSAState</body><body package="T-Gen Development">grammarClass	^Grammar</body><body package="T-Gen Development">initialLR0ItemSet	^ItemSet with: (self lr0ItemClass initialItemForGrammar: self grammar)</body><body package="T-Gen Development">initialLR1ItemSet	^ItemSet with: (self lr1ItemClass initialItemForGrammar: self grammar)</body><body package="T-Gen Development">ll1ParserClass	^LL1Parser</body><body package="T-Gen Development">llModeMarker	^#LL</body><body package="T-Gen Development">llParserTableClass	^LLParserTable</body><body package="T-Gen Development">lr0ItemClass	^LR0Item</body><body package="T-Gen Development">lr1ItemClass	^LR1Item</body><body package="T-Gen Development">lr1LookaheadSetFor: item 	"Delegate to my grammar."	^self grammar lr1LookaheadSetFor: item</body><body package="T-Gen Development">lrModeMarker	^#LR</body><body package="T-Gen Development">lrParserClass	^LR1Parser</body><body package="T-Gen Development">lrParserFinalStateClass	^FSAFinalState</body><body package="T-Gen Development">lrParserStateClass	^LRParserState</body><body package="T-Gen Development">shamAstModeMarker	^#shamAST</body><body package="T-Gen Development">traceModeMarker	^#Trace</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>LR parser generation</category><body package="T-Gen Development">computeLR0ClosureOf: itemSet 	"For all items in itemSet of the form 'B -&gt; &lt;alpha&gt; . A &lt;beta&gt;' 	recursively add new items of the form 'A -&gt; . &lt;gamma&gt;'."	^self computeLR0ClosureOf: itemSet withProdMap: self computeProductionMap</body><body package="T-Gen Development">computeLR0ClosureOf: itemSet withProdMap: prodMap	"For all items in itemSet of the form 'B -&gt; &lt;alpha&gt; . A &lt;beta&gt;' 	recursively add new items of the form 'A -&gt; . &lt;gamma&gt;'."	| nonterms sym newItemSet |	nonterms := Set new.	itemSet do: [:item | (sym := item nextSymbol) isNonterminal ifTrue: [nonterms add: sym]].	newItemSet := ItemSet new.	newItemSet addAll: itemSet.	nonterms do: [:nont | newItemSet addAll: ((prodMap at: nont)				collect: [:prod | prod asInitialLR0Item])].	^itemSet size = newItemSet size		ifTrue: [newItemSet]		ifFalse: [self computeLR0ClosureOf: newItemSet withProdMap: prodMap]</body><body package="T-Gen Development">computeLR1ClosureOf: itemSet 	"For all items in itemSet of the form 'B -&gt; &lt;alpha&gt; . A &lt;beta&gt; : lookahead' 	recursively add new items of the form 'A -&gt; . &lt;gamma&gt; : First(&lt;beta&gt; lookahead)'."	^self computeLR1ClosureOf: itemSet withProdMap: self computeProductionMap</body><body package="T-Gen Development">computeLR1ClosureOf: itemSet withProdMap: prodMap	"For all items in itemSet of the form 'B -&gt; &lt;alpha&gt; . A &lt;beta&gt; : lookahead' 	recursively add new items of the form 'A -&gt; . &lt;gamma&gt; : First(&lt;beta&gt; lookahead)'."	| nontermItems newItemSet |	nontermItems := Set new.	itemSet do: [:item | item nextSymbol isNonterminal ifTrue: [nontermItems add: item]].	newItemSet := ItemSet new.	newItemSet addAll: itemSet.	nontermItems do: [:item | (self lr1LookaheadSetFor: item)			do: [:la | (prodMap at: item nextSymbol)					do: [:prod | newItemSet add: (prod asInitialLR1ItemWithLookahead: la)]]].	^itemSet size = newItemSet size		ifTrue: [newItemSet]		ifFalse: [self computeLR1ClosureOf: newItemSet withProdMap: prodMap]</body><body package="T-Gen Development">extantStateFor: itemSet in: stateItemMap 	"If stateItemMap includes itemSet as one of its values answer the corresponding 	state, otherwise answer nil. (This is the same as Dictionary&gt;&gt;keyAtValue:ifAbsent: 	[^nil] except that it uses = rather than ==.)"	stateItemMap associationsDo: [:assoc | assoc value = itemSet ifTrue: [^assoc key]].	^nil</body><body package="T-Gen Development">findTransitionItemSet: itemSet 	"Arbitrarily choose a transition symbol (immediately after a dot) 	and answer the set of items that have transitions on that symbol. 	All 'atEnd' items have already been removed."	| transitSym |	transitSym := itemSet first postDotSymbols first.	^itemSet select: [:item | self is: item postDotSymbols first theSameAs: transitSym]</body><body package="T-Gen Development">is: symOne theSameAs: symTwo 	"Compare the symbols for equality. This method is required because T-gen uses	Strings to represent terminals and Symbols for non-terminals, and a String and	Symbol with the same characters are considered equal. Thus, 'prod' = #prod is true	in Smalltalk but not in T-gen."	^symOne isTerminal = symTwo isTerminal		ifTrue: [symOne = symTwo]		ifFalse: [false]</body><body package="T-Gen Development">lr1Parser	"Attempt to build an LR(1) parser for my grammar. 	Answer true if successful and false otherwise. 		Based on Algorithm 6.2 from 'Principles of Compiler Design', 	by Aho and Ullman, 1977."	| stateItemMap startState unprocessedStates currState closure transitItems transitSym newItemSet nextState finalState conflictStates |	stateItemMap := Dictionary new.	conflictStates := Set new.	startState := self lrParserStateClass new.	unprocessedStates := Set with: startState.	stateItemMap at: startState put: self initialLR1ItemSet.	[unprocessedStates isEmpty]		whileFalse: 			[currState := unprocessedStates removeFirst.			closure := self computeLR1ClosureOf: (stateItemMap at: currState).			"Process all reduce items."			(closure select: [:item | item atEnd])				do: 					[:item | 					item isFinalStateItem						ifTrue: [finalState := currState]						ifFalse: 							[currState reduceMap at: item lookahead add: item asGrammarProduction.							currState reduceMap at: item lookahead ifNotUnique: 								["reduce/reduce conflict"								conflictStates add: currState]].					closure remove: item].			[closure isEmpty]				whileFalse: 					[transitItems := self findTransitionItemSet: closure.					transitSym := transitItems first postDotSymbols first.					newItemSet := ItemSet new.					transitItems do: [:item | newItemSet add: item copy shift].					(nextState := self extantStateFor: newItemSet in: stateItemMap) isNil						ifTrue: 							[nextState := self lrParserStateClass new.							unprocessedStates add: nextState.							stateItemMap at: nextState put: newItemSet].					currState goto: nextState on: transitSym.					(currState reduceMap includesKey: transitSym)						ifTrue: 							["shift/reduce conflict"							conflictStates add: currState].					closure removeAll: transitItems]].	conflictStates isEmpty		ifTrue: 			[self isLR1: true.			self parser: (self lrParserClass parseTable: startState finalState: finalState) spaceOptimize.			^true]		ifFalse: 			[self parser: (self lrParserClass parseTable: startState finalState: finalState).			^false]</body><body package="T-Gen Development">slr1Parser	"Attempt to build an SLR(1) parser for my grammar. 	Answer true if successful and false otherwise. 		Based on Algorithm 6.1 from 'Principles of Compiler Design', 	by Aho and Ullman, 1977."	| stateItemMap startState unprocessedStates currState closure transitItems transitSym newItemSet nextState finalState conflictStates slr1Parser |	stateItemMap := Dictionary new.	conflictStates := Set new.	startState := self lrParserStateClass new.	unprocessedStates := Set new.	stateItemMap at: startState put: self initialLR0ItemSet.	unprocessedStates add: startState.	[unprocessedStates isEmpty]		whileFalse: 			[currState := unprocessedStates removeFirst.			closure := self computeLR0ClosureOf: (stateItemMap at: currState).			"Process all reduce items."			(closure select: [:item | item atEnd])				do: 					[:item | 					item isFinalStateItem						ifTrue: [finalState := currState]						ifFalse: 							["SLR(1) lookahead symbols"							(self grammar followSetOf: item leftHandSide)								do: 									[:term | 									currState reduceMap at: term add: item asGrammarProduction.									currState reduceMap at: term ifNotUnique: 										["reduce/reduce conflict"										conflictStates addAll: (conflictStrategy resolveReduceReduceFor: term atState: currState)]]].					closure remove: item].			[closure isEmpty]				whileFalse: 					[transitItems := self findTransitionItemSet: closure.					transitSym := transitItems first postDotSymbols first.					newItemSet := ItemSet new.					transitItems do: [:item | newItemSet add: item copy shift].					(nextState := self extantStateFor: newItemSet in: stateItemMap) isNil						ifTrue: 							[nextState := self lrParserStateClass new.							unprocessedStates add: nextState.							stateItemMap at: nextState put: newItemSet].					currState goto: nextState on: transitSym.					(currState reduceMap includesKey: transitSym)						ifTrue: 							["shift/reduce conflict"							conflictStates addAll: (conflictStrategy resolveShiftReduceFor: transitSym atState: currState)].					closure removeAll: transitItems]].	slr1Parser := self lrParserClass parseTable: startState finalState: finalState.	conflictStates isEmpty		ifTrue: 			[self isSLR1: true.			self parser: slr1Parser spaceOptimize.			^true]		ifFalse: 			["try LALR(1) analysis"			(slr1Parser lalr1AnalyzeConflicts: conflictStates originalGrammar: self grammar)				ifTrue: 					[self isLALR1: true.					self parser: slr1Parser spaceOptimize.					^true]				ifFalse: 					[self parser: slr1Parser.					^false]]</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>scanner generation</category><body package="T-Gen Development">buildFSAFrom: rules and: literalDict 	"Answer a minimal deterministic FSA that will recognize rules and literals."	| startState fsa stream ch state nextStateSet nextState |	"First, build the basic DFSA for the token classes (rules)."	startState := self fsaStateClass new.	rules do: [:rule | rule regExpr			asFSAWithType: rule tokenClass			andAction: rule directive			startingAt: startState].	fsa := startState asNearMinimalDFSAWithUniqueTokenClasses.	"Then, see if any of the literal tokens (keywords) can be placed in an existing final state."	literalDict copy associationsDo: [:assoc |		stream := ReadStream on: assoc key.		ch := stream next.		state := fsa.		"Remember, we have not yet space optimized so we are dealing with SetDictionaries."		[nextStateSet := state transitionFor: ch ifNone: [nil].		nextState := nextStateSet isNil ifTrue: [nil] ifFalse: [nextStateSet first].		nextState isNil or: [stream atEnd]]			whileFalse:				[state := nextState.				ch := stream next].		nextState isFSAFinalState			ifTrue:				[nextState addLiteralToken: assoc key.				literalDict removeKey: assoc key]].	"Attach remaining literal tokens to start state, re-DFSA-ify, and space optimize."	literalDict associationsDo: [:assoc | assoc value asFSAWithLiteral: assoc key startingAt: fsa].	^fsa asNearMinimalDFSAWithUniqueTokenClasses spaceOptimize</body><body package="T-Gen Development">buildLiteralDictionaryIfFail: aBlock 	"Answer a Dictionary from (de-escaped) literal tokens to their corresponding 	regular expressions."	| litDict |	litDict := Dictionary new.	self grammar literalTerminals do: [:lit | litDict at: lit put: (self convertToRegExpr: lit ifFail: aBlock)].	^litDict</body><body package="T-Gen Development">buildScannerFromRules: rules withLiteralDict: literalDict 	"Answer a scanner that scans according to the rules, also recognizing 	literalTokens."	| fsa |	fsa := self buildFSAFrom: rules and: literalDict.	^self scannerClass new fsa: fsa</body><body package="T-Gen Development">convertToRegExpr: aString ifFail: aBlock 	"Answer a regular expression object by interpreting aString as a token class 	specification. Token specification meta-characters must be escaped in aString."	| rules tokenSpecNode |	tokenSpecNode := self tokenSpecParser parseForAST: (self escapedTokenSpecDeclFor: aString)				ifFail: aBlock.	rules := tokenSpecNode asSpecRuleList.	^rules first regExpr</body><body package="T-Gen Development">escapedTokenSpecDeclFor: aString 	"Answer a string of the form '&lt;x&gt; : aString ;' where all metacharacters in aString 	have been escaped (proceeded by a backslash)."	| aStream metaChars |	aStream := WriteStream on: (String new: 20).	aStream nextPutAll: '&lt;x&gt; : '.	metaChars := self tokenSpecMetaChars.	aString do: 		[:ch | 		(metaChars includes: ch)			ifTrue: [aStream nextPut: $\].		aStream nextPut: ch].	aStream nextPut: $;.	^aStream contents</body><body package="T-Gen Development">oldBuildFSAFrom: rules and: literalDict 	"Answer a minimal deterministic FSA that will recognize rules and literals."	| startState |	startState := self fsaStateClass new.	rules do: [:rule | rule regExpr			asFSAWithType: rule tokenClass			andAction: rule directive			startingAt: startState].	literalDict associationsDo: [:assoc | assoc value asFSAWithLiteral: assoc key startingAt: startState].	^startState asNearMinimalDFSAWithUniqueTokenClasses spaceOptimize</body><body package="T-Gen Development">sameScannerSpec: newSpec usingLits: newLits 	"Has the Specification for the scanner changed since it was last generated?"	(self oldScannerSpec = nil or: [self oldScannerLits = nil])		ifTrue: [^false].	^self oldScannerLits size = (newLits keys union: self oldScannerLits) size and: [self oldScannerSpec = newSpec asString]</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>parser generation</category><body package="T-Gen Development">generateLLParser	"Try to build an LL parser for this language."	self ll1Parser ifTrue: [^true].	(Dialog confirm: 'Grammar is not LL(1) but a transformation may be.Do you wish to try transforming the grammar?')		ifTrue: [self ll1ParserWithTransformations ifTrue: [^true]].	^false</body><body package="T-Gen Development">generateLRParser	"Try to build an LR parser for this language."	self slr1Parser ifTrue: [^true].	(Dialog confirm: 'Grammar is not LALR(1).Do you wish to try LR(1) analysis(this may take a while)?')		ifTrue: [self lr1Parser ifTrue: [^true]].	^false</body><body package="T-Gen Development">generateParser	"Try to build a parser for this language."	^self generateLLParser		ifTrue: [true]		ifFalse: [self generateLRParser]</body><body package="T-Gen Development">grammarClassification	"Answer a string describing my classification."	self isLL1 ifTrue: [self transformedGrammar isNil			ifTrue: [^'Grammar is LL(1).']			ifFalse: [^'Grammar is LL(1), but required transformations.']].	self isSLR1 ifTrue: [^'Grammar is SLR(1).'].	self isLALR1 ifTrue: [^'Grammar is LALR(1).'].	self isLR1		ifTrue: [^'Grammar is LR(1).']		ifFalse: [^'Parser generation failed; nondeterministic parser is available for inspection.']</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>initialization</category><body package="T-Gen Development">init	"set status defaults"	statusTextBuffer := TextCollector new.	self resetParserAndFlags.	self tokenSpecification: Text new.	self setGrammarModeToDefault.	self setParserModeToDefault.	self scannerClass: self defaultScannerClass.	self treeBuilderClass: self defaultTreeBuilderClass.	self oldScannerSpec: nil.	self oldScannerLits: nil.	conflictStrategy := StandardConflictStrategy new.</body><body package="T-Gen Development">resetParserAndFlags	"Reset my state for parser generation."	self isLL1: false.	self isSLR1: false.	self isLALR1: false.	self isLR1: false.	self parser: nil.	self grammar: nil.	self transformedGrammar: nil</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>public access</category><body package="T-Gen Development">buildParserIfFail: aBlock 	| tokenSpecNode grammarNode rules scanner newParser litDict |	self resetParserAndFlags.	tokenSpecNode := self tokenSpecParser parseForAST: self tokenSpecification ifFail: aBlock.	grammarNode := self grammarSpecParser parseForAST: self grammarSpecification ifFail: aBlock.	rules := tokenSpecNode asSpecRuleList.	self cr; show: 'Checking grammar... '.	self grammarClass notReducedSignal		handle: [:ex | self showCR: ex errorString.  ^aBlock value]		do: [self grammar: grammarNode asContextFreeGrammar].	self showCR: 'done.'.	litDict := self buildLiteralDictionaryIfFail: aBlock.	self show: 'Building scanner... starting at: '.	self showCR: Time now printString; tab.	(self sameScannerSpec: self tokenSpecification usingLits: litDict)		ifTrue: 			[self showCR: 'Scanner has not changed - no build required.'.			scanner := self oldScanner]		ifFalse: 			[self showCR: 'Scanner new or has changed - build required.'.			Cursor execute showWhile: [scanner := self buildScannerFromRules: rules withLiteralDict: litDict]].	self tab; showCR: '...done.'.	self oldScannerSpec: self tokenSpecification asString.		"Must force a copy"	self oldScannerLits: litDict keys.	self oldScanner: scanner.	self show: 'Building parser...starting at: '.	self showCR: Time now printString.	Cursor execute showWhile: [self isGrammarModeDefault			ifTrue: [self generateParser]			ifFalse: [self isGrammarModeLL					ifTrue: [self generateLLParser]					ifFalse: [self isGrammarModeLR							ifTrue: [self generateLRParser]							ifFalse: [self error: 'What mode am I in then?!?!']]]].	self tab; show: '...done at:'.	self showCR: Time now printString.	self showCR: self grammarClassification.	newParser := self parser.	newParser scanner: scanner.	newParser treeBuilder: self treeBuilderClass new.	^newParser</body><body package="T-Gen Development">loadSpecFrom: fileName	| file |	file := Filename named: fileName , '.tok'.	file isReadable		ifTrue: 			[(Dialog confirm: 'This load will overwrite the existing specs.Are you sure you want to do this?') ifFalse: [^self].			tokenSpecification := file contentsOfEntireFile.			self changed: #tokenSpecification]		ifFalse: 			[self showCR: 'Could not find file ''' , fileName , '.tok' , '''  - skipping load.'.			^self].	file := Filename named: fileName , '.grm'.	file isReadable		ifTrue: 			[grammarSpecification := file contentsOfEntireFile.			self changed: #grammarSpecification].	file := Filename named: fileName , '.eg'.	file isReadable		ifTrue: 			[inputText := file contentsOfEntireFile.			self changed: #inputText]</body><body package="T-Gen Development">saveSpecTo: fileName 	tokenSpecification notNil ifTrue: [((Filename named: fileName , '.tok') writeStream) nextPutAll: tokenSpecification; close].	grammarSpecification notNil ifTrue: [((Filename named: fileName , '.grm') writeStream) nextPutAll: grammarSpecification; close].	^inputText notNil ifTrue: [((Filename named: fileName , '.eg') writeStream) nextPutAll: inputText; close]</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>accessing</category><body package="T-Gen Development">classCategoryName	"Return the category name for the scanner and parser classes."	classCategoryName isNil ifTrue: [classCategoryName := 'Tgen-ParsersAndScanners'].	^classCategoryName</body><body package="T-Gen Development">classCategoryName: aString 	"Set the category name for the scanner and parser classes to be aString."	classCategoryName := aString</body><body package="T-Gen Development">grammarSpecParser	^self class grammarSpecParser</body><body package="T-Gen Development">parserClassBasename	"Return the parser class basename."	parserClassBasename isNil ifTrue: [parserClassBasename := self treeBuilderClass = self defaultTreeBuilderClass					ifTrue: ['Gork']					ifFalse: [self treeBuilderClass name asString]].	^parserClassBasename</body><body package="T-Gen Development">parserClassBasename: aString 	"Set the parser class basename to be aString. Parser will be named &lt;aString&gt;Parser."	parserClassBasename := aString</body><body package="T-Gen Development">scannerClassname	"Return the scanner class name."	scannerClassname isNil ifTrue: [scannerClassname := self parserClassBasename , 'Scanner'].	^scannerClassname</body><body package="T-Gen Development">scannerClassname: aString 	"Set the scanner class name to be a String."	scannerClassname := aString</body><body package="T-Gen Development">tokenSpecMetaChars	^TokenSpecMetaChars</body><body package="T-Gen Development">tokenSpecParser	^self class tokenSpecParser</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>input text</category><body package="T-Gen Development">acceptInputText: aText from: aController 	self inputText: aText.	self parser isNil		ifTrue: 			[self cr; showCR: 'No parser has been generated.'.			^true].	isLL1 | isSLR1 | isLALR1 | isLR1 ifFalse: [(Dialog confirm: 'The current parser was nondeterministic when built.Are you sure you want to continue?')			ifFalse: [^true]].	self parser requestor: aController.	self isParserModeDefault		ifTrue: 			[self parserResult: (self parser parseForDerivationTree: aText asString ifFail: [^false]).			self postInspectResultMessage.			^true].	self isParserModeTrace		ifTrue: 			[self parserResult: (self parser					parseAndTrace: aText asString					on: self					ifFail: [^false]).			self postSuccessMessage.			^true].	self isParserModeShamAST		ifTrue: 			[self parserResult: (self parser parseForShamAST: aText asString ifFail: [^false]).			self postInspectResultMessage.			^true].	self isParserModeAST		ifTrue: 			[self parserResult: (self parser parseForAST: aText asString ifFail: [^false]).			self postInspectResultMessage.			^true].	^false</body><body package="T-Gen Development">postInspectResultMessage	self cr; showCR: 'Choose ''result'' from the middle button menu in this pane to inspect the results of the successful parse.'</body><body package="T-Gen Development">postSuccessMessage	self cr; showCR: 'The parse of the test input was successful.'</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>parser mode</category><body package="T-Gen Development">isParserModeAST	^self parserMode = self astModeMarker</body><body package="T-Gen Development">isParserModeDefault	^self parserMode = self defaultModeMarker</body><body package="T-Gen Development">isParserModeShamAST	^self parserMode = self shamAstModeMarker</body><body package="T-Gen Development">isParserModeTrace	^self parserMode = self traceModeMarker</body><body package="T-Gen Development">setParserMode: modeMarker	self parserMode: modeMarker.	self changed: #value		"broadcast change so radio buttons may change"</body><body package="T-Gen Development">setParserModeToAST	self parserMode: self astModeMarker</body><body package="T-Gen Development">setParserModeToDefault	self parserMode: self defaultModeMarker</body><body package="T-Gen Development">setParserModeToShamAST	self parserMode: self shamAstModeMarker</body><body package="T-Gen Development">setParserModeToTrace	self parserMode: self traceModeMarker</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>grammar mode</category><body package="T-Gen Development">isGrammarModeDefault	^self grammarMode = self defaultModeMarker</body><body package="T-Gen Development">isGrammarModeLL	^self grammarMode = self llModeMarker</body><body package="T-Gen Development">isGrammarModeLR	^self grammarMode = self lrModeMarker</body><body package="T-Gen Development">setGrammarMode: modeMarker	self grammarMode: modeMarker.	self changed: #value		"broadcast change so radio buttons may change"</body><body package="T-Gen Development">setGrammarModeToDefault	self grammarMode: self defaultModeMarker</body><body package="T-Gen Development">setGrammarModeToLL	self grammarMode: self llModeMarker</body><body package="T-Gen Development">setGrammarModeToLR	self grammarMode: self lrModeMarker</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>grammar text</category><body package="T-Gen Development">acceptGrammarSpec: aText from: aController 	self grammarSpecification: aText.	self grammarSpecParser requestor: aController.	self tokenSpecParser requestor: self tokenSpecController.	(self tokenSpecification isNil or: [self tokenSpecification isEmpty])		ifTrue: [self cr; showCR: 'No token classes have been specified (did you forget to ''accept'' them?).'].	self buildParserIfFail: [^false].	^true</body></methods><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>version information</category><body package="T-Gen Development">tgenCopyright	"Bring up a read-only text window with the T-gen copyright notice."	"TranslatorGenerator tgenCopyright"	| copyright aComposedTextView topView |	copyright := 'The authors make NO WARRANTY or representation, either express or implied, with respect to this software, its quality, accuracy, merchantability, or fitness for a particular purpose.  This software is provided "AS IS", and you, its user, assume the entire risk as to its quality and accuracy.This software is copyright (c) 1992 by Justin O. Graver.All rights reserved, except as specified below.Permission is hereby granted to use, copy, modify, and distribute this software (or portions thereof) for any purpose, without fee, subject to these conditions:(1) If any part of the source code for this software is distributed, then this notice must be included, unaltered; and any additions, deletions, or changes to the original files must be clearly indicated in accompanying documentation.(2) Permission for use of this software is granted only if the user accepts full responsibility for any undesirable consequences; the authors accept NO LIABILITY for damages of any kind.Permission is NOT granted for the use of any author''s name in advertising or publicity relating to this software or products derived from it.We specifically permit and encourage the use of this software as the basis of commercial products, provided that all warranty or liability claims are assumed by the product vendor.Developed under the direction of Justin Graver.Authors include: Justin Graver, Virat Hanvivatpong, and David Wilson.Send any comments, suggestions, or defects to: graver@comm.mot.com.'.	aComposedTextView := ComposedTextView model: (ValueHolder with: copyright).	topView := ScheduledWindow new.	topView controller model: aComposedTextView model.	topView component: (LookPreferences edgeDecorator on: aComposedTextView).	topView label: TranslatorGenerator versionName , ' Copyright Notice'.	topView minimumSize: 470 @ 550.	aComposedTextView controller: NoController new.	topView open</body><body package="T-Gen Development">versionName	^'T-Gen, Version 5.0'</body></methods><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>examples</category><body package="T-Gen Development">example1	"Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	(none) 		grammar spec: 	S	: 'a' S 'b' 	{Pair} ;	S	: 		 	{Core} ;		status: LL(1) and SLR(1) 		test input: 	aaabbb 	"</body><body package="T-Gen Development">example10	"Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	&lt;var&gt;	: [a-z] ; 	&lt;num&gt;	: [0-9]+ ; 	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; 		grammar spec: 	Prog 			: LetExpr ; 	Prog 			: Expr 						{LetNode} ; 	LetExpr		: 'let' Defs 'in' Expr 		{LetNode} ; 	Defs 			: Def Defs0				{liftRightChild} ; 	Defs0 			: ',' Defs ; 	Defs0	 		: 							{OrderedChildren} ; 	Def	 		: VarName '=' Number	{DefinitionNode} ; 	Expr	 		: Term Expr0 				{liftRightChild}; 	Expr0	 		: '+' Expr 					{PlusNode} ; 	Expr0			: '-' Expr 					{MinusNode} ; 	Expr0			: 							{nil} ; 	Term			: Factor Term0 			{liftRightChild}; 	Term0			: '*' Term 					{TimesNode} ; 	Term0			: '/' Term 					{DivideNode} ; 	Term0 		: 							{nil}; 	Factor		: VarName ; 	Factor 		: Number ; 	Factor 		: '(' Expr ')' ; 	VarName		: &lt;var&gt; 					{VarNode} ; 	Number		: &lt;num&gt; 					{NumberNode} ; 		status: LL(1) and SLR(1) 		test input: 	let 	x = 3, 	y = 7, 	z = 2 	in 	x * (y + z / 4)	"</body><body package="T-Gen Development">example11	"This grammar demonstrates the ability to fix nondeterministic parsers by hand. 	Evaluate the following expression and then test the grammar. Try to build an LL(1) parser 	and when asked to perform transformations, answer no. From the middle button menu in 	the transcript pane inspect the parser. Inspect the parseTable instance variable. The 'E' row 	and 'else' column has a double entry. Using the inspectors, remove the production 'E : ;' from 	the set and evaluate 'self spaceOptimize' in the parseTable inspector. The resulting parser 	will successfully parse the input and can be installed. For more information see the T-gen 	User's Guide."	"TranslatorGeneratorView open"	"token spec: 	&lt;space&gt; : [\s\t\r]+	{ignoreDelimiter} ; 		grammar spec: 	G : S ';' ; 	S : 'if' S E | 'other' ; 	E : 'else' S | ; 		status: not LL(1) and not LR(1) 		test input: 	if if other else other; 	"</body><body package="T-Gen Development">example2	"Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	&lt;id&gt; : [a-z]+ ; 	&lt;number&gt; : [0-9]+ ; 	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; 				grammar spec: 	Z		: 'program' Decls Stmts		{Program} ; 	Decls	: 'var' IdList ':' 'integer'		{Decls} ; 	IdList	: Name IdList				{liftRightChild} ; 	IdList	: Name						{IdList} ; 	Stmts	: 'begin' SL 'end'			{Stmts} ; 	SL		: S SL 						{liftRightChild} ; 	SL		: Stmts SL					{liftRightChild} ; 	SL		: S 							{StmtList} ; 	SL		: Stmts						{StmtList} ; 	S		: Name ':=' E ';' 				{Assign} ; 	E		: E '+' T						{Plus} ; 	E		: T ; 	T		: P '*' T						{Times} ; 	T		: P; 	P		: '(' E ')' ; 	P		: Name ; 	P		: &lt;number&gt;					{Number} ; 	Name	: &lt;id&gt;						{Id} ; 	status: SLR(1) and LL(1), with transformations 		test input: 	program 	var a b c : integer 	begin 		a := 3; 		b := a * 4 * 5; 		begin 			c := a + b * 19;			b := b * c + 1;			a := (a + 1) * a; 		end		c := b * (c + 5);	end 	"</body><body package="T-Gen Development">example3	"Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; 		grammar spec: 	 	E : T Ec 			{liftRightChild} ; 	Ec : '+' E		{Plus} ; 	Ec :				{nil} ; 	T : P Tc			{liftRightChild} ; 	Tc : '*' T		{Times} ; 	Tc :				{nil} ; 	P : 'a' 			{A} ; 	P : 'b' 			{B} ; 	P : 'c' 			{C} ; 		status: LL(1) and SLR(1) 		test input: 	a + b * c + a 	"</body><body package="T-Gen Development">example4	"Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; 			grammar spec: 	E : P ; 	P : 'a' ;	P : '(' A ';' A ')' ;	P : '(' V ',' V ')' ; 	V : 'a' ; 	A : 'a' ; 		status: LALR(1) 		test input: 	(a ; a) 	"</body><body package="T-Gen Development">example5	"Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	(none)			grammar spec: 	S : 'a' B 'b' ;	S : 'a' D 'a' ;	S : 'b' B 'a' ;	S : 'b' D 'b' ; 	B : A ; 	A : 'a' ; 	D : 'a' ; 		status: LR(1) 		test input: 	aaa 	"</body><body package="T-Gen Development">example6	"Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; 			grammar spec: 	S : E ;	E : E '+' E | E '*' E | 'a' ; 		status: not LL(1) and not LR(1) 		test input: 	a + a * a 	"</body><body package="T-Gen Development">example7	"This grammar demonstrates the need of simple scanner backup. 	Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	(none) 		grammar spec: 	S : E S | ; 	E : 'a' | 'abc' | 'bd' ; 		status: LL(1) and SLR(1) 		test input: 	abd 	"</body><body package="T-Gen Development">example8	"This grammar demonstrates the need of two-token scanner lookahead. 	Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	(none) 		grammar spec: 	S : E S | ; 	E : 'a' | 'ab' | 'abc' | 'bd' ; 		status: LL(1) and SLR(1) 		test input: 	abd 	"</body><body package="T-Gen Development">example9	"This demonstrates how to build flat non-empty lists. 	Evaluate the following expression and then test the grammar."	"TranslatorGeneratorView open"	"token spec: 	(none) 		grammar spec: 	E : E P		{liftLeftChild} 	| P			{OrderedChildren} ; 	P : 'a'		{A} 	| 'b'			{B} 	| 'c'			{C} ; 		status: LL(1) with transformations (translations are still not handled) and SLR(1) 		test input: 	abc 	"</body></methods><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>instance creation</category><body package="T-Gen Development">new	^super new init</body></methods><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>class initialization</category><body package="T-Gen Development">initialize	"TranslatorGenerator initialize"	self grammarSpecParser: GrammarSpecParser new.	self tokenSpecParser: TokenSpecParser new.	self initializeTokenSpecMetaChars.</body><body package="T-Gen Development">initializeTokenSpecMetaChars	"These characters are special to the TokenSpecParser and must be escaped."	| chars |	chars := Set new.	chars addAll: #($: $; $| $* $+ $? $( $) $[ $] $~ $- $&lt; $&gt; ${ $} $\ ).	chars		 add: Character space;		 add: Character tab;		 add: Character cr.	TokenSpecMetaChars := chars</body></methods><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>state accessing</category><body package="T-Gen Development">grammarSpecParser	^grammarSpecParser</body><body package="T-Gen Development">grammarSpecParser: argument 	grammarSpecParser := argument</body><body package="T-Gen Development">tokenSpecParser	^tokenSpecParser</body><body package="T-Gen Development">tokenSpecParser: argument 	tokenSpecParser := argument</body></methods><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>fileIn/Out</category><body package="T-Gen Development">prerequisitesForLoading	"List those classes that must be filed or BOSSed into the system 	before I can be loaded."	| list |	list := OrderedCollection new.	list add: GrammarSpecParser.	^list</body></methods><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>parcel load/unload</category><body package="T-Gen Development">preUnloadFor: theTgenDevelopmentParcel	"Close the TranslatorGenerator if it is open."	#{ApplicationModel} ifDefinedDo:		[:appModel | appModel checkUnloadOfApplicationsDefinedBy: theTgenDevelopmentParcel]</body></methods><methods><class-id>Tgen.TranslatorGeneratorView</class-id> <category>aspects</category><body package="T-Gen Development">grammarMode ^grammarMode isNil  ifTrue: [grammarMode := (AspectAdaptor subject: self generator)      forAspect: #grammarMode]  ifFalse: [grammarMode]</body><body package="T-Gen Development">grammarSpec	| adaptor |	adaptor := AspectAdaptor subject: generator.	adaptor forAspect: #grammarSpecification.	adaptor subjectSendsUpdates: true.	^adaptor</body><body package="T-Gen Development">parserMode ^parserMode isNil  ifTrue: [parserMode := (AspectAdaptor subject: self generator)      forAspect: #parserMode]  ifFalse: [parserMode]</body><body package="T-Gen Development">test	| adaptor |	adaptor := AspectAdaptor subject: generator.	adaptor forAspect: #inputText.	adaptor subjectSendsUpdates: true.	^adaptor</body><body package="T-Gen Development">tokenSpec	| adaptor |	adaptor := AspectAdaptor subject: generator.	adaptor forAspect: #tokenSpecification.	adaptor subjectSendsUpdates: true.	^adaptor</body></methods><methods><class-id>Tgen.TranslatorGeneratorView</class-id> <category>custom views</category><body package="T-Gen Development">statusView 	| tcv |	tcv := TextCollectorView new model: self generator statusTextBuffer.	tcv controller: TextEditorController new.	tcv controller menuHolder: (self class statusMenu) asValue.	tcv controller performer: self.	tcv controller keyboardProcessor: builder keyboardProcessor.	^tcv</body></methods><methods><class-id>Tgen.TranslatorGeneratorView</class-id> <category>initialize-release</category><body package="T-Gen Development">defaultGeneratorClass	^TranslatorGenerator</body><body package="T-Gen Development">initialize	self generator: self defaultGeneratorClass new</body></methods><methods><class-id>Tgen.TranslatorGeneratorView</class-id> <category>state accessing</category><body package="T-Gen Development">generator ^generator</body><body package="T-Gen Development">generator: argument generator := argument</body></methods><methods><class-id>Tgen.TranslatorGeneratorView</class-id> <category>accepting</category><body package="T-Gen Development">acceptGrammarSpec: aText from: aController 	generator acceptGrammarSpec: aText from: aController</body><body package="T-Gen Development">acceptInputText: aText from: aController 	generator acceptInputText: aText from: aController</body></methods><methods><class-id>Tgen.TranslatorGeneratorView</class-id> <category>actions</category><body package="T-Gen Development">defineScannerClass	"Prompt the user for the name of a new scanner class. An instance of this class will 	be installed in each new parser built."	| scannerName newScannerClass newScannerClassBinding |	scannerName := Dialog request: 'Type the name of the preferred scanner class.' initialAnswer: 'FSABasedScanner'.	newScannerClassBinding := scannerName asSymbol asQualifiedReference bindingOrNil.	newScannerClassBinding isNil ifTrue: [^generator showCR: 'No class named ' , scannerName , '.'].	newScannerClass := newScannerClassBinding value.	newScannerClass isBehavior ifFalse: [^generator showCR: scannerName , ' is not a class name.'].	generator scannerClass: newScannerClass.	generator showCR: 'Rebuild scanner and parser.'.	generator resetParserAndFlags.	"Force generation of new scanner, even is spec has not changed."	generator oldScannerSpec: nil</body><body package="T-Gen Development">defineTreeBuilderClass	"Prompt the user for the name of a new parse tree builder class. An instance of this class will 	be installed in each new parser built."	| builderName builderClass builderClassBinding |	builderName := Dialog request: 'Type the name of the new parse tree builder class.' initialAnswer: (generator treeBuilderClass = generator defaultTreeBuilderClass					ifTrue: [(generator parserClassBasename isNil							ifTrue: ['AbstractSyntax']							ifFalse: [generator parserClassBasename])							, 'TreeBuilder']					ifFalse: [generator treeBuilderClass name asString]).	builderClassBinding := builderName asSymbol asQualifiedReference bindingOrNil.	builderClassBinding isNil ifTrue: [^generator showCR: 'No class named ' , builderName , '.'].	builderClass := builderClassBinding value.	builderClass isBehavior ifFalse: [^generator showCR: builderName , ' is not a class name.'].	generator treeBuilderClass: builderClass.	generator parser notNil		ifTrue: 			[generator parser treeBuilder: builderClass new.			generator showCR: 'New parse tree builder installed in current parser.']</body><body package="T-Gen Development">inspectGrammar	generator transformedGrammar isNil		ifTrue: [generator grammar inspect]		ifFalse: [generator transformedGrammar inspect]</body><body package="T-Gen Development">inspectParser	generator parser isNil		ifTrue: [generator showCR: 'No parser to inspect.']		ifFalse: [generator parser inspect]</body><body package="T-Gen Development">inspectResult	generator parserResult inspect</body><body package="T-Gen Development">installScannerAndParserClasses	"Install a scanner and parser class."	| category baseName |	baseName := Dialog request: 'Type in a base name for the new parserclass, e.g. if you type ''Gork''the class created would be named GorkParser' initialAnswer: generator parserClassBasename.	baseName isEmpty ifTrue: [^self].	generator parserClassBasename: baseName.	category := Dialog request: 'Type in the category name for the new classes.' initialAnswer: generator classCategoryName.	category isEmpty ifTrue: [^self].	generator classCategoryName: category.	generator					cr;					show: 'Installing classes ';					show: baseName;					show: 'Scanner and ';					show: baseName;					show: 'Parser... '.				generator parser fastParser					createScannerParserClassesNamed: baseName					category: category					tokenSpec: generator tokenSpecification					grammarSpec: generator grammarSpecification.				generator showCR: 'done.'</body><body package="T-Gen Development">loadSpecs	"load a token specification, a grammar specification, and a sample 	input. Use a single file name with three different extensions: 	*.tok, *.grm, and  *.eg."	| fileName |	fileName := Dialog request: 'Enter base file name (standard extensions will be added):' initialAnswer: (generator specsFileName isNil					ifTrue: ['Tgen']					ifFalse: [generator specsFileName]).	fileName isEmpty		ifTrue: [^self]		ifFalse: ["cache" generator specsFileName: fileName].	generator loadSpecFrom: fileName.</body><body package="T-Gen Development">saveSpecs	"Save the token specification, the grammar specification, and the 	sample input. Use a single file name with three different extensions: 	*.tok, *.grm, and *.eg."	| fileName |	fileName := Dialog request: 'Enter base file name (standard extensions will be added):' initialAnswer: (generator specsFileName isNil					ifTrue: [generator parserClassBasename isNil ifTrue: ['Tgen'] ifFalse: [generator parserClassBasename]]					ifFalse: [generator specsFileName]).	fileName isEmpty		ifTrue: [^self]		ifFalse: ["cache"			generator specsFileName: fileName].	Cursor write showWhile: [generator saveSpecTo: fileName]</body></methods><methods><class-id>Tgen.TranslatorGeneratorView</class-id> <category>interface opening</category><body package="T-Gen Development">postBuildWith: aBuilder 	| controller |	super postBuildWith: aBuilder.	controller := (aBuilder  componentAt: #tokenSpecView) widget controller.	generator tokenSpecController: controller.	controller autoAccept: false.	controller := (aBuilder componentAt: #grammarSpecView) widget controller.	controller autoAccept: false.	controller := (aBuilder componentAt: #testView) widget controller.	controller autoAccept: false</body></methods><methods><class-id>Tgen.GrammarTreeBuilder</class-id> <category>tree building</category><body package="T-Gen Development">alternate: node1 with: node2 	^node1 alternateWith: node2</body><body package="T-Gen Development">concatenate: node1 with: node2 	^node1 concatenateWith: node2</body></methods><methods><class-id>Core.Array</class-id> <category>tgen-reconstructing</category><body package="T-Gen Development">reconstructOn: aStream 	"Emit #( elements) on aStream ."	aStream		 poundSign;		 leftParenthesis;		 space.	1 to: self size do: 		[:index | 		(self at: index)			reconstructOn: aStream.		aStream space].	aStream rightParenthesis</body><body package="T-Gen Development">reconstructOn: aStream using: tokenTable 	aStream		 poundSign;		 leftParenthesis;		 space.	1 to: self size do: 		[:index | 		(self at: index)			reconstructOn: aStream using: tokenTable.		aStream space].	aStream rightParenthesis</body></methods><methods><class-id>Core.String</class-id> <category>tgen-reconstructing</category><body package="T-Gen Development">reconstructOn: aStream 	self printOn: aStream</body></methods><methods><class-id>Core.Dictionary</class-id> <category>tgen-reconstructing</category><body package="T-Gen Development">reconstructOn: aStream 	"Emit #( keys ) and #( values ) on aSteam"	aStream		 poundSign;		 leftParenthesis;		 space.	self		associationsDo: 			[:assoc | 			assoc key reconstructOn: aStream.			aStream space].	aStream		 rightParenthesis;		 space;		 poundSign;		 leftParenthesis.	self		associationsDo: 			[:assoc | 			assoc value reconstructOn: aStream.			aStream space].	aStream rightParenthesis; space</body></methods><methods><class-id>Core.Collection</class-id> <category>tgen-reconstructing</category><body package="T-Gen Development">reconstructOn: aStream 	"Emit #( elements ) on aStream "	aStream poundSign; leftParenthesis.	self do: 		[:ea | 		ea reconstructOn: aStream.		aStream space].	aStream rightParenthesis</body></methods><methods><class-id>Core.Stream</class-id> <category>tgen-character writing</category><body package="T-Gen Development">leftParenthesis	"Append a left parenthesis character to the receiver."	self nextPut: Character leftParenthesis</body><body package="T-Gen Development">period	"Append a period character to the receiver."	self nextPut: Character period</body><body package="T-Gen Development">poundSign	"Append a # character to the receiver."	self nextPut: Character poundSign</body><body package="T-Gen Development">rightParenthesis	"Append a right parenthesis character to the receiver."	self nextPut: Character rightParenthesis</body></methods><methods><class-id>Core.Object</class-id> <category>tgen-reconstructing</category><body package="T-Gen Development">reconstructOn: aStream 	self printOn: aStream</body><body package="T-Gen Development">reconstructOn: aStream using: dummy 	self printOn: aStream</body></methods><methods><class-id>Core.Character</class-id> <category>tgen-reconstructing</category><body package="T-Gen Development">reconstructOn: aStream 	"Emit '&lt;Character value: x&gt;' where x is the integer value for the receiver on aStream "	aStream nextPut: $'; nextPutAll: '&lt;Character value: ' ; nextPutAll: self asInteger printString ; nextPut: $&gt;; nextPut: $'"using the inherited printOn: aStream for Character can cause a problem in the generated initialize method for a  Tgen generated parser cincom said:Normally, one does not create a method with a non-printable character sothis problem will not occur.  The character definition for 16r0004 asthe second item of prodTable is the problem here.  The classes thatinterpret file-in code for VW are based on XML classes and XML does notuse non-printable characters and instead uses escape sequences asnecessary.  If you change the method defintion to not use non-printablecharacters the code will work.  In fact, Smalltalk file-ins should notbe expected to read non-printable characters so you should either changethis method definition in any case."</body></methods><methods><class-id>Tgen.TranslatorGeneratorView class</class-id> <category>interface specs</category><body package="T-Gen Development">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'T-gen' 			#min: #(#Point 453 323 ) 			#bounds: #(#Rectangle 348 298 801 621 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 1 0 -21 1 0 0.5 -1 1 ) 					#model: #grammarMode 					#menu: #grammarModeMenu ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 1 0.5 -21 1 -1 1 -1 1 ) 					#model: #parserMode 					#menu: #parserModeMenu ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0.00221729 0 0.00309597 0 0.498891 0 0.297214 ) 					#name: #tokenSpecView 					#model: #tokenSpec 					#menu: #tokenSpecMenu ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0.00443459 0 0.30031 0 0.498891 0 0.928793 ) 					#name: #grammarSpecView 					#model: #grammarSpec 					#menu: #grammarSpecMenu ) 				#(#ArbitraryComponentSpec 					#layout: #(#LayoutFrame 0 0.503326 0 0.00619195 0 0.997783 0 0.291022 ) 					#name: #statusView 					#flags: 9 					#component: #statusView ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0.503326 0 0.30031 0 0.995565 0 0.931888 ) 					#name: #testView 					#model: #test 					#menu: #inputMenu ) ) ) )</body></methods><methods><class-id>Tgen.TranslatorGeneratorView class</class-id> <category>resources</category><body package="T-Gen Development">grammarModeMenu "UIMenuEditor new openOnClass: self andSelector: #grammarModeMenu" &lt;resource: #menu&gt; ^#(#Menu #(   #(#MenuItem    #label: 'LL(1)' )   #(#MenuItem    #label: 'SLR(1), LALR(1), LR(1)' )   #(#MenuItem    #label: 'don''t care' ) ) #(3 ) #(#LL #LR #default ) )decodeAsLiteralArray</body><body package="T-Gen Development">grammarSpecMenu	"UIMenuEditor new openOnClass: self andSelector: #tokenSpecMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: '&amp;find...' 				#value: #find ) 			#(#MenuItem 				#rawLabel: '&amp;replace...' 				#value: #replace ) 			#(#MenuItem 				#rawLabel: '&amp;undo' 				#value: #undo ) 			#(#MenuItem 				#rawLabel: '&amp;copy' 				#value: #copySelection ) 			#(#MenuItem 				#rawLabel: 'cu&amp;t' 				#value: #cut ) 			#(#MenuItem 				#rawLabel: '&amp;paste' 				#value: #paste ) 			#(#MenuItem 				#rawLabel: '&amp;accept' 				#value: 				#acceptGrammarSpec:from: ) 			#(#MenuItem 				#rawLabel: 'cancel' 				#value: #cancelText ) ) #(2 1 3 2 ) nil ) decodeAsLiteralArray</body><body package="T-Gen Development">inputMenu	"UIMenuEditor new openOnClass: self andSelector: #tokenSpecMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: '&amp;find...' 				#value: #find ) 			#(#MenuItem 				#rawLabel: '&amp;replace...' 				#value: #replace ) 			#(#MenuItem 				#rawLabel: '&amp;undo' 				#value: #undo ) 			#(#MenuItem 				#rawLabel: '&amp;copy' 				#value: #copySelection ) 			#(#MenuItem 				#rawLabel: 'cu&amp;t' 				#value: #cut ) 			#(#MenuItem 				#rawLabel: '&amp;paste' 				#value: #paste ) 			#(#MenuItem 				#rawLabel: '&amp;accept' 				#value: 				#acceptInputText:from:) 			#(#MenuItem 				#rawLabel: 'cancel' 				#value: #cancelText ) ) #(2 1 3 2 ) nil ) decodeAsLiteralArray</body><body package="T-Gen Development">parserModeMenu "UIMenuEditor new openOnClass: self andSelector: #parserModeMenu" &lt;resource: #menu&gt; ^#(#Menu #(   #(#MenuItem    #label: 'derivation tree' )   #(#MenuItem    #label: 'trace' )   #(#MenuItem    #label: 'sham AST' )   #(#MenuItem    #label: 'AST' ) ) #(4 ) #(#default #Trace #shamAST #AST ) )decodeAsLiteralArray</body><body package="T-Gen Development">statusMenu	"MenuEditor new openOnClass: self andSelector: #statusMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 'result' 				#value: #inspectResult ) 			#(#MenuItem 				#rawLabel: 'builder' 				#value: #defineTreeBuilderClass ) 			#(#MenuItem 				#rawLabel: 'grammar' 				#value: #inspectGrammar ) 			#(#MenuItem 				#rawLabel: 'parser' 				#value: #inspectParser ) 			#(#MenuItem 				#rawLabel: 'scanner' 				#value: #defineScannerClass ) 			#(#MenuItem 				#rawLabel: 'install' 				#value: #installScannerAndParserClasses ) 			#(#MenuItem 				#rawLabel: 'save specs' 				#value: #saveSpecs ) 			#(#MenuItem 				#rawLabel: 'load specs' 				#value: #loadSpecs ) ) #(5 1 2 ) nil ) decodeAsLiteralArray</body><body package="T-Gen Development">tokenSpecMenu	"UIMenuEditor new openOnClass: self andSelector: #tokenSpecMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: '&amp;find...' 				#value: #find ) 			#(#MenuItem 				#rawLabel: '&amp;replace...' 				#value: #replace ) 			#(#MenuItem 				#rawLabel: '&amp;undo' 				#value: #undo ) 			#(#MenuItem 				#rawLabel: '&amp;copy' 				#value: #copySelection ) 			#(#MenuItem 				#rawLabel: 'cu&amp;t' 				#value: #cut ) 			#(#MenuItem 				#rawLabel: '&amp;paste' 				#value: #paste ) 			#(#MenuItem 				#rawLabel: '&amp;accept' 				#value: 				#accept) 			#(#MenuItem 				#rawLabel: 'cancel' 				#value: #cancelText ) ) #(2 1 3 2 ) nil ) decodeAsLiteralArray</body></methods><initialize><class-id>Tgen.GrammarSpecScanner</class-id></initialize><initialize><class-id>Tgen.GrammarSpecParser</class-id></initialize><initialize><class-id>Tgen.TranslatorGenerator</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>OptimizedLR1Parser</name><environment>Tgen</environment><super>Tgen.LR1Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokenTypeTable </inst-vars><class-inst-vars>tokenTypeTable </class-inst-vars><imports></imports><category>T-gen-Compilers-Parsers</category><attributes><package>T-Gen Core</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>OptimizedScanner</name><environment>Tgen</environment><super>Tgen.FSABasedScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>finalStateTable </inst-vars><class-inst-vars>finalStateTable tokenTable </class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>AbstractSyntaxTreeBuilder</name><environment>Tgen</environment><super>Tgen.ParseTreeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shamMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Parse Trees</category><attributes><package>T-Gen Core</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>