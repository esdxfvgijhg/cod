<?xml version="1.0"?><st-source><!-- Name: T-Gen TestingComment: T-Gen TestingThis parcel contains methods used to test the T-Gen generation system (but not the UI, yet).To run all test, evaluate:	Tgen.TranslatorGenerator runAllTests.To open a view on a grammar, evauate:	Tgen.TranslatorGeneratorView openand then copy and paste the token spec and grammar spec from Tgen.TranslatorGenerator example2 into the token and grammar panes, accept.  Paste the test input into the test pane and accept.  HideSource: falsePackageName: T-Gen TestingParcel: #('T-Gen_Testing')ParcelName: T-Gen TestingSaveSource: trueVersion: 5.0aDate: 5:31:36 PM January 27, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 27, 2016 at 5:31:36 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Tgen.TranslatorGenerator class</class-id> <category>testing</category><body package="T-Gen Testing">basicLLParserGenerationTest1	"TranslatorGenerator basicLLParserGenerationTest1"	| tgen failBlock testName |	testName := 'T-gen LL Parser Generation Test 1'.	tgen := self new setGrammarModeToLL.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			''			'aabb'			)		compareDTTo: (Array			with: '#S\ . ''&lt;epsilon&gt;''\' withCRs			with: '#S\ . ''a''\ . #S\ .  . ''a''\ .  . #S\ .  .  . ''&lt;epsilon&gt;''\ .  . ''b''\ . ''b''\' withCRs			)		compareSASTTo: (Array			with: '#Core\' withCRs			with: '#Pair\ . #Pair\ .  . #Core\' withCRs			)		tokenSpec: ''		grammarSpec: '	S	: ''a'' S ''b'' 	{Pair} ;	S	: 			{Core} ;'		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLLParserGenerationTest2	"TranslatorGenerator basicLLParserGenerationTest2"	| tgen failBlock testName |	testName := 'T-gen LL Parser Generation Test 2'.	tgen := self new setGrammarModeToLL.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: (Array with:			'	program\	var a b c : integer\	begin\		a := 3;\		b := a * 4 * 5;\		begin\			c := a + b * 19;\			b := b * c + 1;\			a := (a + 1) * a;\		end\		c := b * (c + 5);\	end\' withCRs			)		compareDTToAny: (Array with: (Array			with: '#Z\ . ''program''\ . #Decls\ .  . ''var''\ .  . #IdList\ .  .  . #Name\ .  .  .  . ''&lt;id&gt;''\ .  .  . #IdList1\ .  .  .  . #IdList\ .  .  .  .  . #Name\ .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  . #IdList1\ .  .  .  .  .  . #IdList\ .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  . #IdList1\ .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  . '':''\ .  . ''integer''\ . #Stmts\ .  . ''begin''\ .  . #SL\ .  .  . #S\ .  .  .  . #Name\ .  .  .  .  . ''&lt;id&gt;''\ .  .  .  . '':=''\ .  .  .  . #E\ .  .  .  .  . #T\ .  .  .  .  .  . #P\ .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  . #T1\ .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  . #E0\ .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  . '';''\ .  .  . #SL2\ .  .  .  . #SL\ .  .  .  .  . #S\ .  .  .  .  .  . #Name\ .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  . '':=''\ .  .  .  .  .  . #E\ .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  . '';''\ .  .  .  .  . #SL2\ .  .  .  .  .  . #SL\ .  .  .  .  .  .  . #Stmts\ .  .  .  .  .  .  .  . ''begin''\ .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  . #SL2\ .  .  .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  .  .  . #SL2\ .  .  .  .  .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''(''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . '')''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  .  .  .  .  . #SL2\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  . ''end''\ .  .  .  .  .  .  . #SL1\ .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''(''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . '')''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  . #SL2\ .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  . ''end''\' withCRs			with: '#Z\ . ''program''\ . #Decls\ .  . ''var''\ .  . #IdList\ .  .  . #Name\ .  .  .  . ''&lt;id&gt;''\ .  .  . #IdList1\ .  .  .  . #IdList\ .  .  .  .  . #Name\ .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  . #IdList1\ .  .  .  .  .  . #IdList\ .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  . #IdList1\ .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  . '':''\ .  . ''integer''\ . #Stmts\ .  . ''begin''\ .  . #SL\ .  .  . #S\ .  .  .  . #Name\ .  .  .  .  . ''&lt;id&gt;''\ .  .  .  . '':=''\ .  .  .  . #E\ .  .  .  .  . #T\ .  .  .  .  .  . #P\ .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  . #T1\ .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  . #E0\ .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  . '';''\ .  .  . #SL1\ .  .  .  . #SL\ .  .  .  .  . #S\ .  .  .  .  .  . #Name\ .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  . '':=''\ .  .  .  .  .  . #E\ .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  . '';''\ .  .  .  .  . #SL1\ .  .  .  .  .  . #SL\ .  .  .  .  .  .  . #Stmts\ .  .  .  .  .  .  .  . ''begin''\ .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  . #SL1\ .  .  .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  .  .  . #SL1\ .  .  .  .  .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''(''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . '')''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  .  .  .  .  . #SL1\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  . ''end''\ .  .  .  .  .  .  . #SL2\ .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''(''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . '')''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T1\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  .  . #E0\ .  .  .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  .  . #SL1\ .  .  .  .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  . ''end''\' withCRs			))		tokenSpec: '	&lt;id&gt; : [a-z]+ ; 	&lt;number&gt; : [0-9]+ ; 	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ;			'		grammarSpec: '	Z		: ''program'' Decls Stmts		{Program} ; 	Decls	: ''var'' IdList '':'' ''integer''		{Decls} ; 	IdList	: Name IdList				{liftRightChild} ; 	IdList	: Name						{IdList} ; 	Stmts	: ''begin'' SL ''end''			{Stmts} ; 	SL		: S SL 						{liftRightChild} ; 	SL		: Stmts SL					{liftRightChild} ; 	SL		: S 							{StmtList} ; 	SL		: Stmts						{StmtList} ; 	S		: Name '':='' E '';'' 				{Assign} ; 	E		: E ''+'' T						{Plus} ; 	E		: T ; 	T		: P ''*'' T						{Times} ; 	T		: P; 	P		: ''('' E '')'' ; 	P		: Name ; 	P		: &lt;number&gt;					{Number} ; 	Name	: &lt;id&gt;						{Id} ; 			'		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLLParserGenerationTest3	"TranslatorGenerator basicLLParserGenerationTest3"	| tgen failBlock testName |	testName := 'T-gen LL Parser Generation Test 3'.	tgen := self new setGrammarModeToLL.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			'a'			'a + b * c + a'			)		compareDTTo: (Array			with: '#E\ . #T\ .  . #P\ .  .  . ''a''\ .  . #Tc\ .  .  . ''&lt;epsilon&gt;''\ . #Ec\ .  . ''&lt;epsilon&gt;''\' withCRs			with: '#E\ . #T\ .  . #P\ .  .  . ''a''\ .  . #Tc\ .  .  . ''&lt;epsilon&gt;''\ . #Ec\ .  . ''+''\ .  . #E\ .  .  . #T\ .  .  .  . #P\ .  .  .  .  . ''b''\ .  .  .  . #Tc\ .  .  .  .  . ''*''\ .  .  .  .  . #T\ .  .  .  .  .  . #P\ .  .  .  .  .  .  . ''c''\ .  .  .  .  .  . #Tc\ .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  . #Ec\ .  .  .  . ''+''\ .  .  .  . #E\ .  .  .  .  . #T\ .  .  .  .  .  . #P\ .  .  .  .  .  .  . ''a''\ .  .  .  .  .  . #Tc\ .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  . #Ec\ .  .  .  .  .  . ''&lt;epsilon&gt;''\' withCRs			)		compareSASTTo: (Array			with: '#A\' withCRs			with: '#Plus\ . #A\ . #Plus\ .  . #Times\ .  .  . #B\ .  .  . #C\ .  . #A\' withCRs			)		tokenSpec: '	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; '		grammarSpec: '	E : T Ec 			{liftRightChild} ; 	Ec : ''+'' E		{Plus} ; 	Ec :				{nil} ; 	T : P Tc			{liftRightChild} ; 	Tc : ''*'' T		{Times} ; 	Tc :				{nil} ; 	P : ''a'' 			{A} ; 	P : ''b'' 			{B} ; 	P : ''c'' 			{C} ; '		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLRParserGenerationTest1	"TranslatorGenerator basicLRParserGenerationTest1"	| tgen failBlock testName |	testName := 'T-gen LR Parser Generation Test 1'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			''			'aabb'			)		compareDTTo: (Array			with: '#S\ . ''&lt;epsilon&gt;''\' withCRs			with: '#S\ . ''a''\ . #S\ .  . ''a''\ .  . #S\ .  .  . ''&lt;epsilon&gt;''\ .  . ''b''\ . ''b''\' withCRs			)		compareSASTTo: (Array			with: '#Core\' withCRs			with: '#Pair\ . #Pair\ .  . #Core\' withCRs			)		tokenSpec: ''		grammarSpec: '	S	: ''a'' S ''b'' 	{Pair} ;	S	: 		 	{Core} ;		'		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLRParserGenerationTest2	"TranslatorGenerator basicLRParserGenerationTest2"	| tgen failBlock testName |	testName := 'T-gen LR Parser Generation Test 2'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: (Array			with: '	program\	var a b c : integer\	begin\		a := 3;\		b := a * 4 * 5;\		begin\			c := a + b * 19;\			b := b * c + 1;\			a := (a + 1) * a;\		end\		c := b * (c + 5);\	end\' withCRs			)		compareDTTo: (Array			with: '#Z\ . ''program''\ . #Decls\ .  . ''var''\ .  . #IdList\ .  .  . #Name\ .  .  .  . ''&lt;id&gt;''\ .  .  . #IdList\ .  .  .  . #Name\ .  .  .  .  . ''&lt;id&gt;''\ .  .  .  . #IdList\ .  .  .  .  . #Name\ .  .  .  .  .  . ''&lt;id&gt;''\ .  . '':''\ .  . ''integer''\ . #Stmts\ .  . ''begin''\ .  . #SL\ .  .  . #S\ .  .  .  . #Name\ .  .  .  .  . ''&lt;id&gt;''\ .  .  .  . '':=''\ .  .  .  . #E\ .  .  .  .  . #T\ .  .  .  .  .  . #P\ .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  . '';''\ .  .  . #SL\ .  .  .  . #S\ .  .  .  .  . #Name\ .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  . '':=''\ .  .  .  .  . #E\ .  .  .  .  .  . #T\ .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  . '';''\ .  .  .  . #SL\ .  .  .  .  . #Stmts\ .  .  .  .  .  . ''begin''\ .  .  .  .  .  . #SL\ .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  .  .  . #SL\ .  .  .  .  .  .  .  .  . #S\ .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  . ''(''\ .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  .  .  . '')''\ .  .  .  .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  . '';''\ .  .  .  .  .  . ''end''\ .  .  .  .  . #SL\ .  .  .  .  .  . #S\ .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  . '':=''\ .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  . ''*''\ .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  . ''(''\ .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  . #E\ .  .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  . #Name\ .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;id&gt;''\ .  .  .  .  .  .  .  .  .  .  .  . ''+''\ .  .  .  .  .  .  .  .  .  .  .  . #T\ .  .  .  .  .  .  .  .  .  .  .  .  . #P\ .  .  .  .  .  .  .  .  .  .  .  .  .  . ''&lt;number&gt;''\ .  .  .  .  .  .  .  .  .  .  . '')''\ .  .  .  .  .  .  . '';''\ .  . ''end''\' withCRs			)		compareSASTTo: (Array			with: '#Program\ . #Decls\ .  . #IdList\ .  .  . ''a''\ .  .  . ''b''\ .  .  . ''c''\ . #Stmts\ .  . #StmtList\ .  .  . #Assign\ .  .  .  . ''a''\ .  .  .  . ''3''\ .  .  . #Assign\ .  .  .  . ''b''\ .  .  .  . #Times\ .  .  .  .  . ''a''\ .  .  .  .  . #Times\ .  .  .  .  .  . ''4''\ .  .  .  .  .  . ''5''\ .  .  . #Stmts\ .  .  .  . #StmtList\ .  .  .  .  . #Assign\ .  .  .  .  .  . ''c''\ .  .  .  .  .  . #Plus\ .  .  .  .  .  .  . ''a''\ .  .  .  .  .  .  . #Times\ .  .  .  .  .  .  .  . ''b''\ .  .  .  .  .  .  .  . ''19''\ .  .  .  .  . #Assign\ .  .  .  .  .  . ''b''\ .  .  .  .  .  . #Plus\ .  .  .  .  .  .  . #Times\ .  .  .  .  .  .  .  . ''b''\ .  .  .  .  .  .  .  . ''c''\ .  .  .  .  .  .  . ''1''\ .  .  .  .  . #Assign\ .  .  .  .  .  . ''a''\ .  .  .  .  .  . #Times\ .  .  .  .  .  .  . #Plus\ .  .  .  .  .  .  .  . ''a''\ .  .  .  .  .  .  .  . ''1''\ .  .  .  .  .  .  . ''a''\ .  .  . #Assign\ .  .  .  . ''c''\ .  .  .  . #Times\ .  .  .  .  . ''b''\ .  .  .  .  . #Plus\ .  .  .  .  .  . ''c''\ .  .  .  .  .  . ''5''\' withCRs			)		tokenSpec: '	&lt;id&gt; : [a-z]+ ; 	&lt;number&gt; : [0-9]+ ; 	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ;			'		grammarSpec: '	Z		: ''program'' Decls Stmts		{Program} ; 	Decls	: ''var'' IdList '':'' ''integer''		{Decls} ; 	IdList	: Name IdList				{liftRightChild} ; 	IdList	: Name						{IdList} ; 	Stmts	: ''begin'' SL ''end''			{Stmts} ; 	SL		: S SL 						{liftRightChild} ; 	SL		: Stmts SL					{liftRightChild} ; 	SL		: S 							{StmtList} ; 	SL		: Stmts						{StmtList} ; 	S		: Name '':='' E '';'' 				{Assign} ; 	E		: E ''+'' T						{Plus} ; 	E		: T ; 	T		: P ''*'' T						{Times} ; 	T		: P; 	P		: ''('' E '')'' ; 	P		: Name ; 	P		: &lt;number&gt;					{Number} ; 	Name	: &lt;id&gt;						{Id} ; 			'		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLRParserGenerationTest3	"TranslatorGenerator basicLRParserGenerationTest3"	| tgen failBlock testName |	testName := 'T-gen LR Parser Generation Test 3'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			'a'			'a + b * c + a'			)		compareDTTo: (Array			with: '#E\ . #T\ .  . #P\ .  .  . ''a''\ .  . #Tc\ .  .  . ''&lt;epsilon&gt;''\ . #Ec\ .  . ''&lt;epsilon&gt;''\' withCRs			with: '#E\ . #T\ .  . #P\ .  .  . ''a''\ .  . #Tc\ .  .  . ''&lt;epsilon&gt;''\ . #Ec\ .  . ''+''\ .  . #E\ .  .  . #T\ .  .  .  . #P\ .  .  .  .  . ''b''\ .  .  .  . #Tc\ .  .  .  .  . ''*''\ .  .  .  .  . #T\ .  .  .  .  .  . #P\ .  .  .  .  .  .  . ''c''\ .  .  .  .  .  . #Tc\ .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  . #Ec\ .  .  .  . ''+''\ .  .  .  . #E\ .  .  .  .  . #T\ .  .  .  .  .  . #P\ .  .  .  .  .  .  . ''a''\ .  .  .  .  .  . #Tc\ .  .  .  .  .  .  . ''&lt;epsilon&gt;''\ .  .  .  .  . #Ec\ .  .  .  .  .  . ''&lt;epsilon&gt;''\' withCRs			)		compareSASTTo: (Array			with: '#A\' withCRs			with: '#Plus\ . #A\ . #Plus\ .  . #Times\ .  .  . #B\ .  .  . #C\ .  . #A\' withCRs			)		tokenSpec: '	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; '		grammarSpec: '	E : T Ec 			{liftRightChild} ; 	Ec : ''+'' E		{Plus} ; 	Ec :				{nil} ; 	T : P Tc			{liftRightChild} ; 	Tc : ''*'' T		{Times} ; 	Tc :				{nil} ; 	P : ''a'' 			{A} ; 	P : ''b'' 			{B} ; 	P : ''c'' 			{C} ; '		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLRParserGenerationTest4	"TranslatorGenerator basicLRParserGenerationTest4"	| tgen failBlock testName |	testName := 'T-gen LR Parser Generation Test 4'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			'(a ; a)'			'(a , a)'			)		compareDTTo: (Array			with: '#E\ . #P\ .  . ''(''\ .  . #A\ .  .  . ''a''\ .  . '';''\ .  . #A\ .  .  . ''a''\ .  . '')''\' withCRs			with: '#E\ . #P\ .  . ''(''\ .  . #V\ .  .  . ''a''\ .  . '',''\ .  . #V\ .  .  . ''a''\ .  . '')''\' withCRs			)		tokenSpec: '	&lt;space&gt; : [\s\t\r]+			{ignoreDelimiter} ; '		grammarSpec: '	E : P ; 	P : ''a'' ;	P : ''('' A '';'' A '')'' ;	P : ''('' V '','' V '')'' ; 	V : ''a'' ; 	A : ''a'' ; '		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLRParserGenerationTest5	"TranslatorGenerator basicLRParserGenerationTest5"	| tgen failBlock testName |	testName := 'T-gen LR Parser Generation Test 5'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			'aab'			'aaa'			'baa'			'bab'			)		compareDTTo: (Array			with: '#S\ . ''a''\ . #B\ .  . #A\ .  .  . ''a''\ . ''b''\' withCRs			with: '#S\ . ''a''\ . #D\ .  . ''a''\ . ''a''\' withCRs			with: '#S\ . ''b''\ . #B\ .  . #A\ .  .  . ''a''\ . ''a''\' withCRs			with: '#S\ . ''b''\ . #D\ .  . ''a''\ . ''b''\' withCRs			)		tokenSpec: ''		grammarSpec: '	S : ''a'' B ''b'' ;	S : ''a'' D ''a'' ;	S : ''b'' B ''a'' ;	S : ''b'' D ''b'' ; 	B : A ; 	A : ''a'' ; 	D : ''a'' ; '		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicLRParserGenerationTest6	"TranslatorGenerator basicLRParserGenerationTest6"	| tgen failBlock testName |	testName := 'T-gen LR Parser Generation Test 6'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #()		compareDTTo: #()		tokenSpec: ''		grammarSpec: '	S : E ; E : E ''+'' E | E ''*'' E | ''a'' ;'		ifFail: failBlock.	(tgen isLL1 | tgen isSLR1 | tgen isLALR1 | tgen isLR1)		ifTrue: [failBlock value]		ifFalse: [Transcript show: '*'].	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicScannerTest1	"TranslatorGenerator basicScannerTest1"	| tgen failBlock testName |	testName := 'T-gen Scanner Test 1'.	tgen := self new setGrammarModeToLR.	tgen scannerClass: FSABasedScannerWithOneTokenLookahead.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			'abc'			'abd'			)		compareDTTo: (Array			with: '#S\ . #E\ .  . ''abc''\ . #S\ .  . ''&lt;epsilon&gt;''\' withCRs			with: '#S\ . #E\ .  . ''a''\ . #S\ .  . #E\ .  .  . ''bd''\ .  . #S\ .  .  . ''&lt;epsilon&gt;''\' withCRs			)		tokenSpec: ''		grammarSpec: 'S : E S | ; E : ''a'' | ''abc'' | ''bd'' ;'		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">basicScannerTest2	"TranslatorGenerator basicScannerTest2"	| tgen failBlock testName |	testName := 'T-gen Scanner Test 2'.	tgen := self new setGrammarModeToLR.	tgen scannerClass: FSABasedScannerWithTwoTokenLookahead.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen		parseInputs: #(			'abc'			'abd'			'abbd'			'a'			)		compareDTTo: (Array			with: '#S\ . #E\ .  . ''abc''\ . #S\ .  . ''&lt;epsilon&gt;''\' withCRs			with: '#S\ . #E\ .  . ''a''\ . #S\ .  . #E\ .  .  . ''bd''\ .  . #S\ .  .  . ''&lt;epsilon&gt;''\' withCRs			with: '#S\ . #E\ .  . ''ab''\ . #S\ .  . #E\ .  .  . ''bd''\ .  . #S\ .  .  . ''&lt;epsilon&gt;''\' withCRs			with: '#S\ . #E\ .  . ''a''\ . #S\ .  . ''&lt;epsilon&gt;''\' withCRs			)		tokenSpec: ''		grammarSpec: 'S : E S | ; E : ''a'' | ''ab'' | ''abc'' | ''bd'' ;'		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">rrpgToCfgTransformationsTest1	"TranslatorGenerator rrpgToCfgTransformationsTest1"	| tgen failBlock testName |	testName := 'T-gen RRPG-to-CFG Transformation Test 1'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen tokenSpecification: ''.	tgen		grammarSpec: 'S : ''b''+ ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' S0 ;\S0	: ''b'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b''+ ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: ''b'' S0 ;\S0	: ''b'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b''+ ''c'' ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' S0 ;\S0	: ''b'' ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b''+ ''c'' ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: ''b'' S0 ;\S0	: ''b'' ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b''* ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' S0 ;\S0	: ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b''* ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: ''b'' S0 ;\S0	: ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b''* ''c'' ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' S0 ;\S0	: ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b''* ''c'' ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: ''b'' S0 ;\S0	: ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b''? ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' ;\S0	: ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b''? ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: ''b'' ;\S0	: ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b''? ''c'' ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' ''c'' ;\S0	: ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b''? ''c'' ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: ''b'' ''c'' ;\S0	: ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b'' ^ ''d'' ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' ;\S0	: ''b'' ''d'' S0 ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b'' ^ ''d'' ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''a'' ''b'' ;\S0	: ''a'' ''b'' ''d'' S0 ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b'' ^ ''d'' ''c'' ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''b'' ;\S0	: ''b'' ''d'' ''c'' S0 ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b'' ^ ''d'' ''c'' ;\' withCRs		targetGrammar: 'S	: S0 ;\S0	: ''a'' ''b'' ;\S0	: ''a'' ''b'' ''d'' ''c'' S0 ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b'' | ''d'' ;\' withCRs		targetGrammar: 'S	: ''b'' ;\S	: ''d'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b'' | ''d'' ;\' withCRs		targetGrammar: 'S	: ''a'' ''b'' ;\S	: ''d'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''b'' | ''d'' ''c'' ;\' withCRs		targetGrammar: 'S	: ''b'' ;\S	: ''d'' ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b'' | ''d'' ''c'' ;\' withCRs		targetGrammar: 'S	: ''a'' ''b'' ;\S	: ''d'' ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : (''b'' | ''d'') ;\' withCRs		targetGrammar: 'S	: ''b'' ;\S	: ''d'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' (''b'' | ''d'') ;\' withCRs		targetGrammar: 'S	: ''a'' ''b'' ;\S	: ''a'' ''d'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : (''b'' | ''d'') ''c'' ;\' withCRs		targetGrammar: 'S	: ''b'' ''c'' ;\S	: ''d'' ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' (''b'' | ''d'') ''c'' ;\' withCRs		targetGrammar: 'S	: ''a'' ''b'' ''c'' ;\S	: ''a'' ''d'' ''c'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : A B+ ;\A : ''a'' ;\B : ''b'' ;\' withCRs		targetGrammar: 'S	: A S0 ;\S0	: B S0 ;\S0	: B ;\A	: ''a'' ;\B	: ''b'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : A B* ;\A : ''a'' ;\B : ''b'' ;\' withCRs		targetGrammar: 'S	: A S0 ;\S0	: B S0 ;\S0	: ;\A	: ''a'' ;\B	: ''b'' ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : A B? ;\A : ''a'' ;\B : ''b'' ;\' withCRs		targetGrammar: 'S	: A S0 ;\S0	: B ;\S0	: ;\A	: ''a'' ;\B	: ''b'' ;\' withCRs		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">rrpgToCfgTransformationsTest2	"TranslatorGenerator rrpgToCfgTransformationsTest2"	| tgen failBlock testName |	testName := 'T-gen RRPG-to-CFG Transformation Test 2'.	tgen := self new setGrammarModeToLR.	failBlock := [self error: testName, ' failed.'].	Transcript cr; show: 'START: ' , testName; cr.	tgen tokenSpecification: ''.	tgen		grammarSpec: 'S : ''a'' (''b'' | ''d'')? ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: ''b'' ;\S0	: ''d'' ;\S0	: ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' ''b'' | ''d''? ;\' withCRs		targetGrammar: 'S	: ''a'' ''b'' ;\S	: S0 ;\S0	: ''d'' ;\S0	: ;\' withCRs		ifFail: failBlock.	tgen		grammarSpec: 'S : ''a'' (B ^ C)? ;\B : ''b'' ;\C : ''c'' ;\' withCRs		targetGrammar: 'S	: ''a'' S0 ;\S0	: S00 ;\S00	: B ;\S00	: B C S00 ;\S0	: ;\B	: ''b'' ;\C	: ''c'' ;\' withCRs		ifFail: failBlock.	Transcript cr; show: 'STOP: ' , testName</body><body package="T-Gen Testing">runAllTests	"TranslatorGenerator runAllTests"	Transcript cr; show: 'T-gen TEST SUITE (answer ''yes'' to all prompters)'.	self basicLLParserGenerationTest1.	self basicLLParserGenerationTest2.	self basicLLParserGenerationTest3.	self basicLRParserGenerationTest1.	self basicLRParserGenerationTest2.	self basicLRParserGenerationTest3.	self basicLRParserGenerationTest4.	self basicLRParserGenerationTest5.	self basicLRParserGenerationTest6.	self basicScannerTest1.	self basicScannerTest2.	self rrpgToCfgTransformationsTest1.	self rrpgToCfgTransformationsTest2.	Transcript cr; show: 'ALL TESTS PASSED'; cr.</body></methods><methods><class-id>Tgen.TranslatorGenerator</class-id> <category>testing</category><body package="T-Gen Testing">buildAndInstallParserNamed: name tokenSpec: tSpec grammarSpec: gSpec ifFail: failBlock	self tokenSpecification: tSpec.	self grammarSpecification: gSpec.		self buildParserIfFail: failBlock.	self parser fastParser		createScannerParserClassesNamed: name		category: self testingCategoryName		tokenSpec: self tokenSpecification		grammarSpec: self grammarSpecification</body><body package="T-Gen Testing">grammarSpec: gSpec targetGrammar: gram ifFail: failBlock	self grammarSpecification: gSpec.	self buildParserIfFail: failBlock.	self grammar printString = gram		ifTrue: [Transcript show: '*']		ifFalse: [failBlock value]</body><body package="T-Gen Testing">parseInputs: strings compareDTTo: dtTargets compareSASTTo: sastTargets tokenSpec: tSpec grammarSpec: gSpec ifFail: failBlock 	| scannerName parserName dt scannerClassBinding parserClassBinding |	scannerName := (self testingClassBaseName , 'Scanner') asSymbol.	scannerClassBinding := scannerName asSymbol asQualifiedReference bindingOrNil.	scannerClassBinding isNil ifFalse: [self error: 'A class named ' , scannerName , ' already exists.'].	parserName := (self testingClassBaseName , 'Parser') asSymbol.	parserClassBinding := parserName asSymbol asQualifiedReference bindingOrNil.	parserClassBinding isNil ifFalse: [self error: 'A class named ' , parserName , ' already exists.'].	self		buildAndInstallParserNamed: self testingClassBaseName		tokenSpec: tSpec		grammarSpec: gSpec		ifFail: failBlock.	parserClassBinding := parserName asSymbol asQualifiedReference binding.	scannerClassBinding := scannerName asSymbol asQualifiedReference binding.	strings with: dtTargets		do: 			[:string :target | 			dt := parserClassBinding value new parseForDerivationTree: string ifFail: failBlock.			dt printString = target				ifTrue: [Transcript show: '*']				ifFalse: [failBlock value]].	strings with: sastTargets		do: 			[:string :target | 			dt := parserClassBinding value new parseForShamAST: string ifFail: failBlock.			dt printString = target				ifTrue: [Transcript show: '*']				ifFalse: [failBlock value]].	scannerClassBinding value removeFromSystem.	parserClassBinding value removeFromSystem</body><body package="T-Gen Testing">parseInputs: strings compareDTTo: targets tokenSpec: tSpec grammarSpec: gSpec ifFail: failBlock 	| scannerName parserName dt scannerClassBinding parserClassBinding |	scannerName := (self testingClassBaseName , 'Scanner') asSymbol.	scannerClassBinding := scannerName asSymbol asQualifiedReference bindingOrNil.	scannerClassBinding isNil ifFalse: [self error: 'A class named ' , scannerName , ' already exists.'].	parserName := (self testingClassBaseName , 'Parser') asSymbol.	parserClassBinding := parserName asSymbol asQualifiedReference bindingOrNil.	parserClassBinding isNil ifFalse: [self error: 'A class named ' , parserName , ' already exists.'].	self		buildAndInstallParserNamed: self testingClassBaseName		tokenSpec: tSpec		grammarSpec: gSpec		ifFail: failBlock.	parserClassBinding := parserName asSymbol asQualifiedReference binding.	scannerClassBinding := scannerName asSymbol asQualifiedReference binding.	strings with: targets		do: 			[:string :target | 			dt := parserClassBinding value new parseForDerivationTree: string ifFail: failBlock.			dt printString = target				ifTrue: [Transcript show: '*']				ifFalse: [failBlock value]].	scannerClassBinding value removeFromSystem.	parserClassBinding value removeFromSystem</body><body package="T-Gen Testing">parseInputs: strings compareDTToAny: targets tokenSpec: tSpec grammarSpec: gSpec ifFail: failBlock 	"The argument 'strings' is an Array of strings. The argument 'targets' 	is an Array of Array of strings. The test for a given element of 'strings' 	will succeed if it matches any of the strings in the corresponding 	'targets' Array. Due to the nondeterminism of hashing, productions 	are sometimes processed in different orders and new nonterminals 	get numbered differently. As an example, see TranslatorGenerator 	class&gt;&gt;basicLLParserGenerationTest2."	| scannerName parserName dt dtps scannerClassBinding parserClassBinding |	scannerName := (self testingClassBaseName , 'Scanner') asSymbol.	scannerClassBinding := scannerName asSymbol asQualifiedReference bindingOrNil.	scannerClassBinding isNil ifFalse: [self error: 'A class named ' , scannerName , ' already exists.'].	parserName := (self testingClassBaseName , 'Parser') asSymbol.	parserClassBinding := parserName asSymbol asQualifiedReference bindingOrNil.	parserClassBinding isNil ifFalse: [self error: 'A class named ' , parserName , ' already exists.'].	self		buildAndInstallParserNamed: self testingClassBaseName		tokenSpec: tSpec		grammarSpec: gSpec		ifFail: failBlock.	parserClassBinding := parserName asSymbol asQualifiedReference binding.	scannerClassBinding := scannerName asSymbol asQualifiedReference binding.	strings with: targets		do: 			[:string :target | 			dt := parserClassBinding value new parseForDerivationTree: string ifFail: failBlock.			dtps := dt printString.			(target inject: false into: [:result :targetStr | result or: [dtps = targetStr]])				ifTrue: [Transcript show: '*']				ifFalse: [failBlock value]].	scannerClassBinding value removeFromSystem.	parserClassBinding value removeFromSystem</body><body package="T-Gen Testing">testingCategoryName	^'T-gen-Interface'</body><body package="T-Gen Testing">testingClassBaseName	^'TgenTemporaryTest'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TranslatorGenerator</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar transformedGrammar isLL1 isSLR1 isLALR1 isLR1 parser statusTextBuffer tokenSpecification grammarSpecification inputText grammarMode parserMode parserResult tokenSpecController scannerClass treeBuilderClass oldScannerSpec oldScannerLits oldScanner specsFileName conflictStrategy parserClassBasename scannerClassname classCategoryName </inst-vars><class-inst-vars>grammarSpecParser tokenSpecParser </class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Development</package></attributes></class></st-source>