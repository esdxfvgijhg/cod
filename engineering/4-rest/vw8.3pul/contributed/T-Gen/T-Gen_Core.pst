<?xml version="1.0"?><st-source><!-- Name: T-Gen CoreComment: T-Gen Core This parcel contains code required to support a T-Gen generated parser and scanner.HideSource: falsePackageName: T-Gen CoreParcel: #('T-Gen_Core')ParcelName: T-Gen CoreSaveSource: trueVersion: 5.0aDate: 5:30:51 PM January 27, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 27, 2016 at 5:30:51 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Tgen</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Tgen-Name Spaces</category><attributes><package>T-Gen Core</package></attributes></name-space><class><name>ParseTreeBuilder</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Parse Trees</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ParseTreeBuilder</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This is an abstract class that provides a framework for building parse trees during parsing.  Parse trees are built in a bottom-up fashion during parsing by processing key productions, and with the help of a stack.  In general, a key production has the form:	A -&gt; N1 N2 ... Nk =&gt; symbolwhere A and the Ni are nonterminals (terminals may be interspersed freely in the right-hand side) and symbol is the production directive (or translation symbol).  Since trees are built bottom-up, the information flow in a production is from the right-hand side to the left-hand side.  When a production is ready to be processed, the top of the stack contains objects (parse trees) associated with the right-hand-side nonterminals of the production.  Processing a production involves replacing these objects with a single object representing (associated with) the left-hand-side nonterminal.  This can be thought of as computing a value for A as a function of the values of the Ni's, i.e. value(A) = fcn(value(N1), value(N2), ..., value(Nk)).  Default functions are defined in my concrete subclasses but users may define their own production processing functions by creating a new subclass and implementing appropriate messages.  This enables users to have direct control over exactly how parse trees are built. Instance Variables:	stack	&lt;Stack&gt; - holds intermediate node values during production processing.</body></comment><class><name>TreeNode</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TreeNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This abstract class provides the framework for both destructive and non-destructive tree traversals in which references to locally global objects are available without being explicitly passed as arguments.Concrete subclasses must implement methods for traversing	childrenDo:		"Evaluate the argument block with each of my children."	updateChildrenUsing:		"Replace my children with the result of evaluating the argument block with the corresponding child."</body></comment><class><name>ParseTreeNode</name><environment>Tgen</environment><super>Tgen.TreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Parse Trees</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ParseTreeNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class that provides the framework for parse tree nodes, basically just a reminder that the following messages may need to be implemented by concrete subclasses:	addChildrenFirst:	addChildrenInitial:	addChildrenLast:	setAttribute:</body></comment><class><name>RegularExpressionNode</name><environment>Tgen</environment><super>Tgen.ParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.RegularExpressionNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am the root of a regular expression tree.</body></comment><class><name>CharacterNode</name><environment>Tgen</environment><super>Tgen.RegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.CharacterNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a atomic character of a regular expression.Instance Variables:	charSpec	&lt;String&gt; - contains the character atom specification for this node (different types of specifications are represented by subclasses).</body></comment><class><name>HexadecimalCharNode</name><environment>Tgen</environment><super>Tgen.CharacterNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.HexadecimalCharNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a atomic character of a regular expression.  I am specified by a String of the form '\xHH' where each H is a hexadecimal digit (0-9, a-f or A-F) and HH is my corresponding ASCII value.</body></comment><class><name>UnaryRegExprNode</name><environment>Tgen</environment><super>Tgen.RegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>onlyChild </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.UnaryRegExprNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a unary regular expression.</body></comment><class><name>PlusClosureNode</name><environment>Tgen</environment><super>Tgen.UnaryRegExprNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.PlusClosureNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the regular expression '(expr)+' which denotes 'expr (expr)*'.</body></comment><class><name>ProductionPartition</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftHandSide problemProductions otherProductions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ProductionPartition</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a partition of productions for a given nonterminal into two sets, potentially problematic productions and others.  I am currently used for detecting left-recursive productions and productions with common prefixes.Instance Variables:	leftHandSide			&lt;Symbol&gt; - the left hand side nonterminal of my productions.	problemProductions	&lt;Set of: GrammarProduction&gt; - when used for left-recursion							&lt;Set of: (Set of: GrammarProduction)&gt; - when used for left-factoring.	otherProductions		&lt;Set of: GrammarProduction&gt;.</body></comment><class><name>AbstractParser</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner prevToken requestor failBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Parsers</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.AbstractParser</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class represents abstract parsing behavior.Instance Variables:	scanner &lt;a scanner class&gt;	- this parser's scanner	prevToken &lt;String + Symbol&gt;	- the last token scanned	requestor &lt;Controller + Object&gt;	- the object invoking the parser, errors are reported to this object	failBlock &lt;Block&gt;		- this block is evaluated before the parse is aborted</body></comment><class><name>TableDrivenParser</name><environment>Tgen</environment><super>Tgen.AbstractParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parseTable transcript treeBuilder </inst-vars><class-inst-vars>parseTable </class-inst-vars><imports></imports><category>T-gen-Compilers-Parsers</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TableDrivenParser</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class representing table (FSA) driven parsers.Instance Variables:	parseTable	&lt;LL1ParserTable | LRParserState&gt; - basic parsing mechanism.	transcript		&lt;TranslatorGenerator | UndefinedObject&gt; - status messages get sent here.	treeBuilder	&lt;ParseTreeBuilder&gt; - used in the construction of abstract syntax trees.</body></comment><class><name>LL1Parser</name><environment>Tgen</environment><super>Tgen.TableDrivenParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startSymbol </inst-vars><class-inst-vars>startSymbol </class-inst-vars><imports></imports><category>T-gen-Compilers-Parsers</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.LL1Parser</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an LL(1) parser.Instance Variables:	parseTable*	&lt;LL1ParserTable&gt; - basic parsing mechanism.	startSymbol  &lt;Symbol&gt; - my grammars start symbol.* inherited from AbstractParser</body></comment><class><name>ConflictStrategy</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Conflict Strategies</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ConflictStrategy</class-id><body>ConflictStrategy implements the action that a translator generator performs when it detects a conflict.Subclasses must implement the following messages:	resolving		resolveReduceReduceFor:		resolveShiftReduceFor:</body></comment><class><name>StandardConflictStrategy</name><environment>Tgen</environment><super>Tgen.ConflictStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Conflict Strategies</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.StandardConflictStrategy</class-id><body>StandardConflictStrategy implements the standard conflict resolution present in the original T-Gen (i.e., none)</body></comment><class><name>BinaryRegExprNode</name><environment>Tgen</environment><super>Tgen.RegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftChild rightChild </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.BinaryRegExprNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a binary regular expression.Instance Variables:	leftChild	&lt;RegExprNode&gt;	rightChild	&lt;RegExprNode&gt;</body></comment><class><name>PartitionTransitionMap</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>partition transitionMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.PartitionTransitionMap</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a partition-based transition map for an ordinary fsa state.  I am used as an intermediate computational object in the dfsa minimization algorithm (see #asMinimalDFSA in class FiniteStateAutomata).  My responsibilities include adding new partition-based transitions and testing for transition map equivalence.Instance Variables:	partition			&lt;Partition&gt; - the partition for the super state that I represent.	transitionMap 	&lt;Dictionary from: (transition symbol) to: Partition&gt;where &lt;Partition&gt; = &lt;Set of: (FSAState + FSAFinalState)&gt;</body></comment><class><name>GraphNode</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.GraphNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class of graph nodes.</body></comment><class><name>DirectedGraphNode</name><environment>Tgen</environment><super>Tgen.GraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predecessors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.DirectedGraphNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I maintain a collection of my predecessor nodes.Instance Variables:	predecessors		&lt;OrderedCollection of: DirectedGraphNode&gt;</body></comment><class><name>NodeLabeledDigraphNode</name><environment>Tgen</environment><super>Tgen.DirectedGraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.NodeLabeledDigraphNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I add labels to my nodes.  Node labels are assumed to be unique (see LabeledDigraph) although hashing and such is still done based on the node itself.Instance Variables:	label	&lt;String&gt;</body></comment><class><name>LLParserTable</name><environment>Tgen</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars>noTransitionSignal </class-inst-vars><imports></imports><category>T-gen-Scanning/Parsing</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.LLParserTable</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I implement a two dimensional LL(1) parser table with rows indexed by nonterminals, columns indexed by terminals, and with production table entries.  At the top level I'm a Dictionary from nonterminals to rows; each row is a SetDictionary from terminals to productions.  In deterministic tables (tables without multiple entries) the SetDictionaries can be (and are) converted into simple Dictionaries.</body></comment><class><name>GrammarParseTreeNode</name><environment>Tgen</environment><super>Tgen.ParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.GrammarParseTreeNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class is an abstract class for grammar parse tree nodes.</body></comment><class><name>RightHandSideNode</name><environment>Tgen</environment><super>Tgen.GrammarParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbols translationSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.RightHandSideNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class represents the right-hand side of a grammar rule.Instance Variables	symbols		&lt;OrderedCollection&gt;	- rhs of production rule.	translationSymbol	&lt;Symbol&gt;	- symbol for transduction.</body></comment><class><name>AbstractScanner</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source nextChar token tokenType buffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.AbstractScanner</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I scan a source string and break it up into tokens using mechanisms provided in concrete subclasses.Instance Variables:	source			&lt;ReadStream&gt; - character input stream.	nextChar		&lt;Character + UndefinedObject&gt; - one-character lookahead buffer for source, nil if no input left.	token			&lt;String&gt; - current token buffer.	tokenType	&lt;String + Symbol&gt; - current token type buffer.	buffer			&lt;WriteStream&gt; - character accumulation buffer for tokens.</body></comment><class><name>FSABasedScanner</name><environment>Tgen</environment><super>Tgen.AbstractScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fsa </inst-vars><class-inst-vars>fsa </class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FSABasedScanner</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class of scanner that scans a source string and breaks it up into tokens using a minimal deterministic finite-state automata (FSA).  Each token is also given a type by its associated final state in the FSA.  Specific FSAs are stored in class instance variables of my concrete subclasses.Instance Variables:	fsa				&lt;FSAState&gt; - a local reference to the token recognizer, in minimal deterministic form, for this class of scanner.</body></comment><class><name>OptimizedScanner</name><environment>Tgen</environment><super>Tgen.FSABasedScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>finalStateTable </inst-vars><class-inst-vars>finalStateTable tokenTable </class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OptimizedScanner</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class of scanner that scans a source string and breaks it up into tokensusing a table created by converting FSA to integer.instance Variables:	finalStateTable		- a table that maps integer ( represented as final state ) to 						   literal tokens and token classes.</body></comment><class><name>ShiftingConflictStrategy</name><environment>Tgen</environment><super>Tgen.ConflictStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Conflict Strategies</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ShiftingConflictStrategy</class-id><body>ShiftingConflictStrategy resolves shift/reduce conflicts by always shifting, this handles most ambiguities correctly.</body></comment><class><name>LR0Item</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>leftHandSide preDotSymbols postDotSymbols translationSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.LR0Item</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a context-free grammar production with a 'dot' somewhere in the right hand side.  I'm used in the construction of LR(0), SLR(1), and LALR(1) parsers.	leftHandSide -&gt; &lt;preDotSymbols&gt; . &lt;postDotSymbols&gt; =&gt; &lt;translationSymbol&gt;Instance Variables:	leftHandSide			&lt;Symbol&gt;	preDotSymbols		&lt;OrderedCollection of: (String + Symbol)&gt;	postDotSymbols		&lt;OrderedCollection of: (String + Symbol)&gt;	translationSymbol	&lt;String + Symbol&gt; - used for generating abstract syntax trees.</body></comment><class><name>GrammarProduction</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>leftHandSide rightHandSide </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Scanning/Parsing</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.GrammarProduction</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent one production of a context-free grammar.  I am responsible for some parts of the first/follow set computation algorithm and for converting myself between various related representations (e.g. LR(0) items).Instance Variables:	leftHandSide		&lt;Symbol&gt;	rightHandSide 	&lt;OrderedCollection of: (String + Symbol)&gt;</body></comment><class><name>TransductionGrammarProduction</name><environment>Tgen</environment><super>Tgen.GrammarProduction</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>translationSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Scanning/Parsing</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TransductionGrammarProduction</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I add a translation attribute to context-free grammar productions so that I can be used to build simple transduction grammars (or syntax-directed translation scheme).  Transduction grammars are used to build abstract syntax trees rather than derivation trees during parsing.  For more information, refer to Chapter 7. ("Syntax-Directed Translation") in {\em Compiler Construction:  Theory and Practice} by Barrett, Bates, Gustafson, and Couch.Instance Variables:	translationSymbol &lt;String&gt; - used as basis for translation node when parsing.</body></comment><class><name>TokenSpecParseNode</name><environment>Tgen</environment><super>Tgen.ParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Token Specification Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenSpecParseNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class for token specification parse tree nodes.</body></comment><class><name>TokenSpecRuleNode</name><environment>Tgen</environment><super>Tgen.TokenSpecParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokenClass regExpr directive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Token Specification Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenSpecRuleNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================Instance Variables:	tokenClass	&lt;TokenClassNode&gt; - the name of the token class.	regExpr		&lt;RegularExpressionNode&gt; (actually, any one of its concrete subclasses) - the regular expression tree representing the specification of the token class.	directive 		&lt;DirectiveNode + UndefinedObject&gt; - the optional scanner directive.</body></comment><class><name>LR1Parser</name><environment>Tgen</environment><super>Tgen.TableDrivenParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>finalState </inst-vars><class-inst-vars>finalState </class-inst-vars><imports></imports><category>T-gen-Compilers-Parsers</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.LR1Parser</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an LR parser.Instance Variables:	parseTable*	&lt;LRParserState&gt; - basic parsing mechanism, a CFSM.	finalState		&lt;LRParserState&gt; - final state of my CFSM.* inherited from AbstractParser</body></comment><class><name>OptimizedLR1Parser</name><environment>Tgen</environment><super>Tgen.LR1Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokenTypeTable </inst-vars><class-inst-vars>tokenTypeTable </class-inst-vars><imports></imports><category>T-gen-Compilers-Parsers</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OptimizedLR1Parser</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an LR parser represented efficietly in Array table form.Instance variables:	tokenTypeTable &lt;Array of: String&gt;	- the integer mapping of terminals and nonterminals</body></comment><class><name>ProductionNode</name><environment>Tgen</environment><super>Tgen.GrammarParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftHandSide rightHandSides </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ProductionNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a grammar production.Instance Variables:	leftHandSide	&lt;NonterminalNode&gt;	rightHandSides 	&lt;OrderedCollection&gt;	- rhs's for productions of the form A -&gt; x | y | z.</body></comment><class><name>RRPGProductionNode</name><environment>Tgen</environment><super>Tgen.ProductionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.RRPGProductionNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an RRPG production.</body></comment><class><name>OptimizedLookaheadScanner</name><environment>Tgen</environment><super>Tgen.OptimizedScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>savePosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OptimizedLookaheadScanner</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This is an abstract class for table-based optimized scanners with lookahead.Instance Variables:	savePosition &lt;Integer&gt; - pointer into input source for error notification.</body></comment><class><name>OptimizedScannerWithTwoTokenLookahead</name><environment>Tgen</environment><super>Tgen.OptimizedLookaheadScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateStack saveState saveChar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OptimizedScannerWithTwoTokenLookahead</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class provides a table-based optimized scanner with simple two-token lookahead.Instance Variables:	stateStack	&lt;Stack&gt; - primary state stack for scanning tokens.	saveState	&lt;Integer&gt; - pointer into input source for error notification.	saveChar	&lt;Character&gt; - pointer into input source for error notification.</body></comment><class><name>OrderedPair</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Kernel-Objects</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OrderedPair</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================An OrderedPair extends the concept of a Point from Numbers to Objects. It is oftenconvenient to associate two objects together or to return a pair of objects from amethod.  OrderedPair provides the mechanism to do this without the inconvenienceof verbose syntax (as would be required if an Array or OrderedCollection were used).The main instance creation method for OrderedPairs is the binary operator @.  Thisoperator is defined in Object and (now) overridden in Number so that numericalpoints are treated and created in the traditional manner.instance variables:	x	&lt;Object&gt;	the first component of the pair	y	&lt;Object&gt;	the second component of the pair</body></comment><class><name>EdgeLabeledDigraphNode</name><environment>Tgen</environment><super>Tgen.GraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>edgeLabelMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.EdgeLabeledDigraphNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a node in an edge-labeled digraph.Instance Variables:	edgeLabelMap		&lt;SetDictionary from: labels to: successors&gt;</body></comment><class><name>FSAState</name><environment>Tgen</environment><super>Tgen.EdgeLabeledDigraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateID </inst-vars><class-inst-vars>noTransitionSignal </class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FSAState</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a general state in a finite state automata.</body></comment><class><name>TokenSpecNode</name><environment>Tgen</environment><super>Tgen.TokenSpecParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specRules </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Token Specification Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenSpecNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am the root of a token specification.Instance Variables:	specRules	&lt;OrderedCollection&gt;	- the rules for this spec.</body></comment><class><name>Graph</name><environment>Tgen</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graphs</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.Graph</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class of graphs.</body></comment><class><name>DirectedGraph</name><environment>Tgen</environment><super>Tgen.Graph</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graphs</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.DirectedGraph</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class represents a directed graph.</body></comment><class><name>LabeledDigraph</name><environment>Tgen</environment><super>Tgen.DirectedGraph</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graphs</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.LabeledDigraph</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class represents a directed graph whose edges are labeled.</body></comment><class><name>FirstFollowGraph</name><environment>Tgen</environment><super>Tgen.LabeledDigraph</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FirstFollowGraph</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a graph consisting of FirstFollowGraphNodes used in the computation of first and follow sets.  I serve as the public interface to my nodes.</body></comment><class><name>EnnaryRegExprNode</name><environment>Tgen</environment><super>Tgen.RegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.EnnaryRegExprNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent an n-ary regular expression.</body></comment><class><name>ConcatenationNode</name><environment>Tgen</environment><super>Tgen.EnnaryRegExprNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ConcatenationNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the concatenation of two or more regular expressions, i.e. child1 child2 ... childN.</body></comment><class><name>StarClosureNode</name><environment>Tgen</environment><super>Tgen.UnaryRegExprNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.StarClosureNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the regular expression '(expr)*' which denotes zero or more repetitions of 'expr'.</body></comment><class><name>RRPGRightHandSideNode</name><environment>Tgen</environment><super>Tgen.RightHandSideNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.RRPGRightHandSideNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class represents the right hand side of an RRPG grammar production.Instance Variables:	regexpr	&lt;RegularExpressionNode&gt;	- the rhs of an RRPG grammar production is a regular expression of grammar symbols.</body></comment><class><name>TokenSpecLeafNode</name><environment>Tgen</environment><super>Tgen.TokenSpecParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Token Specification Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenSpecLeafNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class for token spec leaf nodes.Instance Variables:	symbol	&lt;Character&gt;	- token symbol</body></comment><class><name>DirectiveNode</name><environment>Tgen</environment><super>Tgen.TokenSpecLeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Token Specification Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.DirectiveNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I hold the token class directive.</body></comment><class><name>GrammarLeafNode</name><environment>Tgen</environment><super>Tgen.GrammarParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.GrammarLeafNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class for grammar tree leaf nodes.Instance Variables:	symbol	&lt;Symbol + String&gt;	- a terminal, nonterminal, or transduction symbol.</body></comment><class><name>TranslationNode</name><environment>Tgen</environment><super>Tgen.GrammarLeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TranslationNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I hold a transduction node.</body></comment><class><name>SetDictionary</name><environment>Tgen</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Unordered</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.SetDictionary</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class represents a Dictionary of Sets.</body></comment><class><name>AlternationNode</name><environment>Tgen</environment><super>Tgen.EnnaryRegExprNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.AlternationNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the alternation of two or more regular expressions, i.e. child1 | child2 | ... | childN.</body></comment><class><name>OrderedChildren</name><environment>Tgen</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sourcePosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Parse Trees</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OrderedChildren</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================It is often helpful to create a node that has a arbitrary (but flat) collection of nodes as a child.  My instances provide containers for these "collection children".  In other words, I am a collection that acts like a single parse tree node.</body></comment><class><name>AlternationRangeNode</name><environment>Tgen</environment><super>Tgen.EnnaryRegExprNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.AlternationRangeNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the alternation of two or more atomic regular expressions.  My specification encorporates the use of character ranges, e.g. [a-z] (= a | b | c | ... | z).  My children are either simple characters or character ranges, e.g. [a-z0-9!@#] or [aeiou] (vowels).</body></comment><class><name>Grammar</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>nonterminals terminals productions startSymbol nullableNonterminals firstSets followSets </inst-vars><class-inst-vars>notReducedSignal </class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.Grammar</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a context-free grammar.  My two main responsibilities are to compute my first and follow sets and to perform certain grammar manipulations sometimes needed to construct certain classes of parsers.  The two grammar manipulations currently supported are removal of left-recursion and common prefixes (left-factoring).Instance Variables:	nonterminals			&lt;Set of: Symbol&gt; - nonterminals are represented by Symbols.	terminals				&lt;Set of: String&gt; - terminals are represented by Strings.	productions			&lt;OrderedCollection of: GrammarProduction&gt; - order is only important from a logical point of veiw (i.e. for printing).	startSymbol			&lt;Symbol&gt; - a nonterminal.	nullableNonterminals	&lt;Set of: Symbol&gt; - those nonterminals that can derive epsilon in zero or more steps.	firstSets				&lt;SetDictionary from: Symbol to: Strings&gt; - for each nonterminal, the terminals that could begin a sentence derivable from that nonterminal.	followSets			&lt;SetDictionary from: Symbol to: Strings&gt; - for each nonterminal, the terminals that could appear immediately to the right of that nonterminal in some sentential form in some valid derivation sequence.</body></comment><class><name>DecimalCharNode</name><environment>Tgen</environment><super>Tgen.CharacterNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.DecimalCharNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a atomic character of a regular expression.  I am specified by a String of the form '\ddd' where each d is a decimal digit and ddd is my corresponding ASCII value.</body></comment><class><name>BidirectionalEdgeLabeledDigraphNode</name><environment>Tgen</environment><super>Tgen.FSAState</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predecessorLabelMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.BidirectionalEdgeLabeledDigraphNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a node in an edge-labeled digraph.  I maintain edges in both directions, i.e. I can follow edges forwards or backwards.Instance Variables:	predecessorLabelMap		&lt;SetDictionary from: labels to: predecessors&gt;</body></comment><class><name>LRParserState</name><environment>Tgen</environment><super>Tgen.BidirectionalEdgeLabeledDigraphNode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>reduceMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Scanning/Parsing</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.LRParserState</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a node in an LR parser characteristic finite state machine.Instance Variables:	edgeLabelMap		&lt;Dictionary from: symbols to: successors&gt; - overridden from EdgeLabeledDigraphNode for efficiency since only deterministic FSAs are constructed.	reduceMap		&lt;SetDictionary from: symbols to: productions&gt;</body></comment><class><name>AbstractSyntaxTreeBuilder</name><environment>Tgen</environment><super>Tgen.ParseTreeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shamMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Parse Trees</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.AbstractSyntaxTreeBuilder</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I build parse trees by creating specific objects for each kind of node as indicated by the parser directives in grammar productions.  Parser directives currently fall into one of three groups: node (class) names, special directives, and arbitrary message selectors. For a node name, a new instance of the specified node is created and given the values associated with the right-hand side nonterminals, if any, as its children. The special directive 'nil' simply returns nil. The directive liftRightChild adds any nodes preceeding the right-most node as children to the right-most node, and returns the right-most node. The directive liftLeftChild works in an analogous fashion. Arbitrary message selectors must take the same number of arguments as there are right-hand-side nodes and are invoked as a builder message, thus allowing users to define their own tree-building messages.Productions of the form 'A -&gt; &lt;tc&gt; =&gt; symbol' are treated specially. The symbol can be either a node name or a one-argument message selector. If it is a node name then create a new instance of that node with the specified attribute value. If it is a message selector then invoke the corresponding operation on the builder with the specified value.Instance Variables:	shamMode	&lt;Boolean&gt; - If true DerivationTreeNode-based ASTs are built, otherwise specific ParseTreeNode-based ASTs are built.</body></comment><class><name>TokenSpecificationRule</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokenClass regExpr directive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Token Specification Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenSpecificationRule</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================Instance Variables:	tokenClass	&lt;String&gt; - the name of the token class.	regExpr		&lt;RegularExpressionNode&gt; (actually, any one of its concrete subclasses) - the (pure) regular expression tree representing the specification of the token class.	directive 		&lt;String + UndefinedObject&gt; - the optional scanner directive.</body></comment><class><name>ListNode</name><environment>Tgen</environment><super>Tgen.BinaryRegExprNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ListNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an instance of the regular expression 'a list b' which is equivalent to a(ba)*.</body></comment><class><name>OptimizedLL1Parser</name><environment>Tgen</environment><super>Tgen.LL1Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nonterminals terminals </inst-vars><class-inst-vars>nonterminals terminals </class-inst-vars><imports></imports><category>T-gen-Compilers-Parsers</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OptimizedLL1Parser</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an LL(1) parser represented efficiently in Array table format.Instance variables:	tokenTypeTable &lt;Array of: String&gt;	- the integer mapping for terminals and nonterminals</body></comment><class><name>HandCodedScanner</name><environment>Tgen</environment><super>Tgen.AbstractScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charTypeTable </inst-vars><class-inst-vars>charTypeTable </class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.HandCodedScanner</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am an abstract class of scanner that scans a source string and breaks it up into tokens using a character type table and hand-coded scanner methods.  Specific type tables are stored in class instance variables of my concrete subclasses.Instance Variables:	charTypeTable	&lt;Array of: Symbol&gt; - a local reference to the type table for this class of scanner; the ascii value of each character is mapped to a symbol token type.</body></comment><class><name>RetractableWriteStream</name><environment>Tgen</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Streams</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.RetractableWriteStream</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class adds a 'backspace' method and overrides several methods to correctly support this behavior.</body></comment><class><name>TokenClassification</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tokenType action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Scanning/Parsing</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenClassification</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a class of tokens. Instance Variables:	tokenType	&lt;String&gt; - name of this token class.	action		&lt;Symbol + UndefinedObject&gt; - a message selector that will be sent to the scanner (via #perform:) when a token with this type is recognized.</body></comment><class><name>FirstFollowGraphNode</name><environment>Tgen</environment><super>Tgen.NodeLabeledDigraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>terminals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FirstFollowGraphNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent a nonterminal of a grammar for the purpose of first and follow set computation.Instance Variables:	terminals	&lt;Set of: Symbols&gt; - the first or follow set of my nonterminal.</body></comment><class><name>TokenSpecScanner</name><environment>Tgen</environment><super>Tgen.OptimizedScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenSpecScanner</class-id><body>This scanner class was automatically generated by T-gen, Version 2.1.</body></comment><class><name>EpsilonNode</name><environment>Tgen</environment><super>Tgen.RegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.EpsilonNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the empty regular expression.</body></comment><class><name>ItemSet</name><environment>Tgen</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ItemSet</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================ItemSets are equal if they contain equal elements.</body></comment><class><name>LR1Item</name><environment>Tgen</environment><super>Tgen.LR0Item</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>lookahead </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Support</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.LR1Item</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I associate a lookahead symbol with a context-free grammar production with a 'dot' somewhere in the right hand side.  I'm used in the construction of LR(1) parsers.	leftHandSide -&gt; &lt;preDotSymbols&gt; . &lt;postDotSymbols&gt; : &lt;lookahead&gt; =&gt; &lt;translationSymbol&gt;Instance Variables:	lookahead			&lt;Symbol&gt;</body></comment><class><name>GrammarNode</name><environment>Tgen</environment><super>Tgen.GrammarParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.GrammarNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am the root of the grammar tree.Instance Variables:	productions	&lt;OrderedCollection&gt;	- the productions of the grammar.</body></comment><class><name>FSABasedLookaheadScanner</name><environment>Tgen</environment><super>Tgen.FSABasedScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>savePosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FSABasedLookaheadScanner</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This is an abstract class for scanners with lookahead.Instance Variables:	savePosition &lt;Integer&gt; - pointer into input source for error notification.</body></comment><class><name>OptionalNode</name><environment>Tgen</environment><super>Tgen.UnaryRegExprNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OptionalNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the regular expression '{expr}' which denotes 'expr | &lt;epsilon&gt;'.</body></comment><class><name>TokenSpecParser</name><environment>Tgen</environment><super>Tgen.OptimizedLR1Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Interface</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenSpecParser</class-id><body>This parser class was automatically generated by T-gen, Version 2.1.</body></comment><class><name>DerivationTreeNode</name><environment>Tgen</environment><super>Tgen.ParseTreeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Parse Trees</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.DerivationTreeNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent an arbitrary node in a derivation or abstract tree.  (It would be nice to expand this concept so that heterogeneous parse trees could be built.)Instance Variables:	symbol	&lt;String&gt; - node attribute.	children	&lt;OrderedCollection of: DerivationTreeNode&gt;</body></comment><class><name>FSABasedScannerWithOneTokenLookahead</name><environment>Tgen</environment><super>Tgen.FSABasedLookaheadScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FSABasedScannerWithOneTokenLookahead</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class provides a scanner with simple one-token lookahead.  </body></comment><class><name>TokenTypeActionHolder</name><environment>Tgen</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Scanning/Parsing</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenTypeActionHolder</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am used to package token type and actions together for transport between FSAFinalStates and the scanner.Instance Variables:	type		&lt;String&gt; - token type.	action		&lt;Symbol + UndefinedObject&gt; - a message selector that will be sent to the scanner (via #perform:) when a token with this type is recognized.</body></comment><class><name>OptimizedScannerWithOneTokenLookahead</name><environment>Tgen</environment><super>Tgen.OptimizedLookaheadScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OptimizedScannerWithOneTokenLookahead</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class provides a table-based optimized scanner with simple one-token lookahead.  </body></comment><class><name>ComplementedAlternationRangeNode</name><environment>Tgen</environment><super>Tgen.AlternationRangeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.ComplementedAlternationRangeNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the alternation of two or more atomic regular expressions (specified as the complement of an alternation range).  I take the complement of the universe of printable characters only, e.g. ~[aeiou] (all non-vowel printable characters).</body></comment><class><name>FSABasedScannerWithTwoTokenLookahead</name><environment>Tgen</environment><super>Tgen.FSABasedLookaheadScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateStack saveState saveChar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Compilers-Scanners</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FSABasedScannerWithTwoTokenLookahead</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class provides a scanner with simple two-token lookahead.Instance Variables:	stateStack	&lt;Stack&gt; - primary state stack for scanning tokens.	saveState	&lt;Integer&gt; - pointer into input source for error notification.	saveChar	&lt;Character&gt; - pointer into input source for error notification.</body></comment><class><name>TerminalNode</name><environment>Tgen</environment><super>Tgen.GrammarLeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TerminalNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I hold a terminal.</body></comment><class><name>CharRangeNode</name><environment>Tgen</environment><super>Tgen.RegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstChar lastChar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.CharRangeNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I represent the alternations of each atomic character in a range.  I.e. 'firstChar-lastChar' = 'firstChar | ... | lastChar'.  I may only appear as a child of a AlternationRangeNode or a ComplementedAlternationRangeNode.Instance Variables:	firstChar	&lt;CharacterNode&gt;	lastChar	&lt;CharacterNode&gt;</body></comment><class><name>OctalCharNode</name><environment>Tgen</environment><super>Tgen.CharacterNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.OctalCharNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a atomic character of a regular expression.  I am specified by a String of the form '\oOOO' where each O is a octal digit (0-7) and OOO is my corresponding ASCII value.</body></comment><class><name>TokenClassNode</name><environment>Tgen</environment><super>Tgen.TokenSpecLeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Token Specification Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.TokenClassNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I hold the token class.</body></comment><class><name>NonterminalNode</name><environment>Tgen</environment><super>Tgen.GrammarLeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Grammar Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.NonterminalNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I hold a nonterminal.</body></comment><class><name>RetractableReadStream</name><environment>Tgen</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Streams</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.RetractableReadStream</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This class adds a 'backspace' method and overrides several methods to correctly support this behavior.</body></comment><class><name>EscapedCharNode</name><environment>Tgen</environment><super>Tgen.CharacterNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Regular Expression Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.EscapedCharNode</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a atomic character of a regular expression.  I am specified by a String of the form '\c' where each c is some character.  Normally, the character I represent is just c, however, some specifications have special meanings (see comment in class initialization method).</body></comment><class><name>FSAFinalState</name><environment>Tgen</environment><super>Tgen.FSAState</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literalTokens tokenClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Collections-Graph Nodes</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.FSAFinalState</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================I am a final state of a finite state automata.  If I'm part of a minimal deterministic fsa then it is possible that I represent several final states of some original non-deterministic fsa.  My instance variables are used to distinguish between these various different final states.  Final states for literal tokens (keywords) are represented by name in literalTokens.  Final states for larger token classes are represented by TokenClassifications.  When a token is recognized by this final state, it is first checked against the list of literal tokens.  If not found, it is then classified as belonging to the one token class of which it is a member.  The current implementation does not support overlapping token classes, hence, there can only really be one element in the OrderedCollection.  However, in the future we hope to be able to support overlapping token classes.Instance Variables:	literalTokens		&lt;Set of: String&gt; - the literal tokens I recognize.	tokenClasses 	&lt;OrderedCollection of: TokenClassification&gt; - the token classes I recognize.</body></comment><class><name>DerivationTreeBuilder</name><environment>Tgen</environment><super>Tgen.ParseTreeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>T-gen-Parse Trees</category><attributes><package>T-Gen Core</package></attributes></class><comment><class-id>Tgen.DerivationTreeBuilder</class-id><body>=================================================    Copyright (c) 1992 by Justin O. Graver.    All rights reserved (with exceptions).    For complete information evaluate "Object tgenCopyright."=================================================This concrete class is used for building derivation trees for a parse.  It uses homogeneous DerivationTreeNodes for all nodes and a specialized production processor.</body></comment><shared-variable><name>NoTransitionSignal</name><environment>Tgen.OptimizedScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>T-Gen Core</package></attributes></shared-variable><shared-variable><name>SpecialCharMap</name><environment>Tgen.EscapedCharNode</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>T-Gen Core</package></attributes></shared-variable><shared-variable><name>NoTransitionSignal</name><environment>Tgen.OptimizedLR1Parser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>T-Gen Core</package></attributes></shared-variable><shared-variable><name>NoTransitionSignal</name><environment>Tgen.OptimizedLL1Parser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>T-Gen Core</package></attributes></shared-variable><methods><class-id>Tgen.ParseTreeBuilder</class-id> <category>initialization</category><body package="T-Gen Core">init	self stack: OrderedCollection new</body></methods><methods><class-id>Tgen.ParseTreeBuilder</class-id> <category>state accessing</category><body package="T-Gen Core">stack	^stack</body><body package="T-Gen Core">stack: argument 	stack := argument</body></methods><methods><class-id>Tgen.ParseTreeBuilder</class-id> <category>accessing</category><body package="T-Gen Core">popStack	^self stack removeFirst</body><body package="T-Gen Core">pushStack: anObject 	^self stack addFirst: anObject</body><body package="T-Gen Core">result	"Answer the root of the tree build by this tree builder."	self stack size = 1 ifFalse: [self error: 'incorrectly built tree'].	^self popStack</body></methods><methods><class-id>Tgen.ParseTreeBuilder</class-id> <category>production processing</category><body package="T-Gen Core">addChildrenFirst: children to: aNode 	"Add children, as the new first children, to aNode and answer aNode."	aNode addChildrenFirst: children.	^aNode</body><body package="T-Gen Core">addChildrenLast: children to: aNode 	"Add children, as the new last children, to aNode and answer aNode."	aNode addChildrenLast: children.	^aNode</body><body package="T-Gen Core">answerArgument: arg 	^arg</body><body package="T-Gen Core">answerNil	^nil</body><body package="T-Gen Core">makeNewNode: stringOrSymbol 	"Answer a new parse tree node representing the argument."	self subclassResponsibility</body><body package="T-Gen Core">makeNewNode: stringOrSymbol withAttribute: value 	"Answer a new parse tree node and initialize its attribute value using the 	setAttribute: message."	| newNode |	newNode := self makeNewNode: stringOrSymbol.	newNode setAttribute: value.	^newNode</body><body package="T-Gen Core">makeNewNode: stringOrSymbol withChildren: children 	"Answer a new parse tree node and initialize its children using the 	addChildrenInitial: message."	| newNode |	newNode := self makeNewNode: stringOrSymbol.	newNode addChildrenInitial: children.	^newNode</body></methods><methods><class-id>Tgen.ParseTreeBuilder</class-id> <category>tree building</category><body package="T-Gen Core">popArgNodesForProduction: grammarProd fromParser: parser 	"Answer a collection of nodes from my stack required for processing 	grammarProd. The order for collecting nodes is parser dependent."	| nodes |	nodes := OrderedCollection new.	parser performsLeftmostDerivation		ifTrue: [grammarProd numberOfRhsNonterminals timesRepeat: [nodes add: self popStack]]		ifFalse: [grammarProd numberOfRhsNonterminals timesRepeat: [nodes addFirst: self popStack]].	^nodes</body><body package="T-Gen Core">processProduction: grammarProd forParser: parser 	"This is the main driver for production processing. The actual production 	processing messages are sent indirectly by grammarProd."	self pushStack: (grammarProd hasSingleTokenClassRhs			ifTrue: [grammarProd computeResultNodeFor: self withTokenClassValue: parser prevToken]			ifFalse: [grammarProd computeResultNodeFor: self withArgNodes: (self popArgNodesForProduction: grammarProd fromParser: parser)])</body></methods><methods><class-id>Tgen.ParseTreeBuilder class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.TreeNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock	"Evaluate aBlock for each of my children.	This message should be reimplemented by my subclasses."	^self		"default"</body><body package="T-Gen Core">preorderDo: preBlock updateUsing: postBlock 	"Perform a traversal on myself and my children.  The preBlock is	evaluated when first entering a node.  My children are replaced	with the results of the traversal.  Thus, this message can be used	to generate objects or alter my structure, whereas postorderDo:	can only be used to examine my structure.  This message may be	used in the following manner. 	 	a := aMethodNode		preorderDo: [:node | node msg1]		updateUsing: [:node | node msg2: globalRef]"	preBlock value: self.	self updateChildrenUsing: [:child | child preorderDo: preBlock updateUsing: postBlock].	^postBlock value: self</body><body package="T-Gen Core">updateChildrenUsing: aBlock	"Replace my children according to the value of aBlock.	This message should be reimplemented by my subclasses."	^self		"default"</body><body package="T-Gen Core">updateCopyUsing: aBlock 	"Perform a postorder traversal on a copy of myself and	my children, replacing my children with the results of the traversal. 	Thus, this message can be used to generate objects or alter 	my structure, whereas postorderDo: can only be used to examine 	my structure.  This message may be used in the following manner. 	 	a := aMethodNode updateCopyUsing: [:node | node msg: globalRef]"	| newNode |	newNode := self copy.	newNode updateChildrenUsing: [:child | child updateCopyUsing: aBlock].	^aBlock value: newNode</body><body package="T-Gen Core">updateUsing: aBlock 	"Perform a postorder traversal on myself and my children, 	replacing my children with the results of the traversal. 	Thus, this message can be used to generate objects or alter 	my structure, whereas postorderDo: can only be used to examine 	my structure.  This message may be used in the following manner. 	 	a := aMethodNode updateUsing: [:node | node msg: globalRef]"	self updateChildrenUsing: [:child | child updateUsing: aBlock].	^aBlock value: self</body></methods><methods><class-id>Tgen.TreeNode</class-id> <category>copying</category><body package="T-Gen Core">copyTree	"Answer a copy of this tree."	^self copy updateChildrenUsing: [:child | child copyTree]</body></methods><methods><class-id>Tgen.TreeNode</class-id> <category>enumerating</category><body package="T-Gen Core">postorderDo: aBlock	"Perform a postorder traversal on myself and my children.	This message may be used for examining the nodes of a tree	for the purpose of gathering data or altering data fields.	To alter the structure of the tree see traverseDo:.  One of	the main advantages of this message is that it allows all nodes	of the tree 'global' access to objects referenced in aBlock.	Before, such arguments had to be passed explitely as arguments.	This message may be used as follows.	aMethodNode postorderDo: [:node | node enc: encoder root: self]"	self childrenDo: [:child | child postorderDo: aBlock].	aBlock value: self</body><body package="T-Gen Core">preorderDo: preBlock postorderDo: postBlock 	"Perform a traversal on myself and my children.  The preBlock is 	evaluated when entering a node and postBlock is evaluated just before 	leaving.  See comment in postorderDo:."	preBlock value: self.	self childrenDo: [:child | child preorderDo: preBlock postorderDo: postBlock].	postBlock value: self</body></methods><methods><class-id>Tgen.ParseTreeNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenFirst: anOrderedCollection 	"Subclasses should implement this message."	self shouldNotImplement</body><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	"Subclasses should implement this message."	self shouldNotImplement</body><body package="T-Gen Core">addChildrenLast: anOrderedCollection 	"Subclasses should implement this message."	self shouldNotImplement</body><body package="T-Gen Core">setAttribute: value 	"Subclasses should implement this message."	self shouldNotImplement</body></methods><methods><class-id>Tgen.ParseTreeNode</class-id> <category>testing</category><body package="T-Gen Core">isConcatenationNode	^false</body></methods><methods><class-id>Tgen.RegularExpressionNode</class-id> <category>private</category><body package="T-Gen Core">alternationNodeClass	^AlternationNode</body><body package="T-Gen Core">characterNodeClass	^CharacterNode</body><body package="T-Gen Core">concatenationNodeClass	^ConcatenationNode</body><body package="T-Gen Core">createNewProductionWithLHS: lhsNode andRHS: anOrderedCollection 	"Create a new RRPGProductionNode given its lhs and a collection of regular 	expression nodes whose concatenation forms the rhs. Note: anOrderedCollection 	may contain ConcatenationNodes which need to be 'expanded' to avoid nesting 	within the ConcatenationNode created by this method. Since each transformation 	is done individually (i.e. this method gets invoked each time a new production is 	created), the CatenationNodes will never be nested more then one deep."	| rhs rhsNode childNodes |	rhs := anOrderedCollection isEmpty				ifTrue: [self epsilonNodeClass new]				ifFalse: [anOrderedCollection size = 1						ifTrue: [anOrderedCollection first]						ifFalse: 							[childNodes := OrderedCollection new.							anOrderedCollection do: [:node | node isConcatenationNode									ifTrue: [childNodes addAllLast: node children]									ifFalse: [childNodes addLast: node]].							self concatenationNodeClass children: childNodes]].	rhsNode := self rhsNodeClass symbols: rhs translationSymbol: nil.	^self productionNodeClass leftHandSide: lhsNode rightHandSides: rhsNode</body><body package="T-Gen Core">epsilon	"Answer an object used to represent the empty string (epsilon)."	^self epsilonNodeClass epsilon</body><body package="T-Gen Core">epsilonNodeClass	^EpsilonNode</body><body package="T-Gen Core">fsaFinalStateClass	^FSAFinalState</body><body package="T-Gen Core">fsaStateClass	^FSAState</body><body package="T-Gen Core">nameExtensionString	"Answer a string appropriate for creating new nonterminals by suffixing."	^'0'</body><body package="T-Gen Core">newNonterminal: lhsNode with: lhsNames 	| lhs |	lhs := lhsNode.	lhsNames isEmpty		ifTrue: [lhsNames add: lhs]		ifFalse: 			[[lhsNames includes: lhs]				whileTrue: [lhs := lhs , '`'].			lhsNames add: lhs].	^NonterminalNode new setAttribute: lhs</body><body package="T-Gen Core">newNonterminalFrom: lhsNode excluding: lhsNames 	"Answer a new nonterminal based on lhsNode that is	not already in lhsNames."	| newName |	newName := lhsNode symbol.	[newName := newName , self nameExtensionString.	lhsNames includes: newName] whileTrue.	lhsNames add: newName.	^self nonterminalNodeClass symbol: newName</body><body package="T-Gen Core">nonterminalNodeClass	^NonterminalNode</body><body package="T-Gen Core">productionNodeClass	^RRPGProductionNode</body><body package="T-Gen Core">rhsNodeClass	^RRPGRightHandSideNode</body><body package="T-Gen Core">starClosureNodeClass	^StarClosureNode</body><body package="T-Gen Core">tokenClassificationClass	^TokenClassification</body></methods><methods><class-id>Tgen.RegularExpressionNode</class-id> <category>converting</category><body package="T-Gen Core">asDFSA	| fsa |	fsa := self asFSA.	^fsa asDeterministicFSA</body><body package="T-Gen Core">asFSA	| startState finalState |	startState := self fsaStateClass new.	finalState := self fsaFinalStateClass new.	self asFSAStartingAt: startState endingAt: finalState.	^startState</body><body package="T-Gen Core">asFSAStartingAt: startState endingAt: finalState 	self subclassResponsibility</body><body package="T-Gen Core">asFSAWithLiteral: literal startingAt: startState 	| finalState |	"First, build main fsa."	finalState := self fsaFinalStateClass new.	self asFSAStartingAt: startState endingAt: finalState.	finalState addLiteralToken: literal.	^startState</body><body package="T-Gen Core">asFSAWithType: type andAction: action startingAt: startState 	| finalState |	"First, build main fsa."	finalState := self fsaFinalStateClass new.	self asFSAStartingAt: startState endingAt: finalState.	finalState addTokenClass: (self tokenClassificationClass tokenType: type action: action).	^startState</body><body package="T-Gen Core">asPureRegExpr	"Answer a new version of the receiver consisting of only characters, 	concatenations, alternations, and (star) closures. Also, eliminate single 	child alternations and concatenations."	^self		"default"</body><body package="T-Gen Core">minimize: recognizer 	^recognizer asMinimalDFSA</body></methods><methods><class-id>Tgen.RegularExpressionNode</class-id> <category>traversing</category><body package="T-Gen Core">addNonemptyLeavesTo: aSet 	^self		"default is do nothing"</body><body package="T-Gen Core">collectNonemptyLeavesIn: aSet 	self postorderDo: [:child | child addNonemptyLeavesTo: aSet]</body></methods><methods><class-id>Tgen.RegularExpressionNode</class-id> <category>transforming</category><body package="T-Gen Core">needsTransforming	^false</body></methods><methods><class-id>Tgen.RegularExpressionNode</class-id> <category>building parse trees</category><body package="T-Gen Core">alternateWith: node	^node alternateWithNonAltNode: self</body><body package="T-Gen Core">alternateWithAltNode: node	node children addLast: self.	^node</body><body package="T-Gen Core">alternateWithNonAltNode: node	^self alternationNodeClass children: (OrderedCollection with: node with: self)</body><body package="T-Gen Core">concatenateWith: node	^node concatenateWithNonCatNode: self</body><body package="T-Gen Core">concatenateWithCatNode: node	node children addLast: self.	^node</body><body package="T-Gen Core">concatenateWithNonCatNode: node	^self concatenationNodeClass children: (OrderedCollection with: node with: self)</body></methods><methods><class-id>Tgen.RegularExpressionNode</class-id> <category>testing</category><body package="T-Gen Core">isAlternationNode	^false</body></methods><methods><class-id>Tgen.CharacterNode</class-id> <category>state accessing</category><body package="T-Gen Core">charSpec	^charSpec</body><body package="T-Gen Core">charSpec: argument 	charSpec := argument</body></methods><methods><class-id>Tgen.CharacterNode</class-id> <category>building parse trees</category><body package="T-Gen Core">setAttribute: value 	self charSpec: value</body></methods><methods><class-id>Tgen.CharacterNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self charSpec printOn: aStream</body></methods><methods><class-id>Tgen.CharacterNode</class-id> <category>traversing</category><body package="T-Gen Core">addNonemptyLeavesTo: aSet 	aSet add: self myChar</body></methods><methods><class-id>Tgen.CharacterNode</class-id> <category>converting</category><body package="T-Gen Core">addCharsTo: aCollection 	"Add each character in my range to aCollection."	aCollection add: self myChar</body><body package="T-Gen Core">addPureCharNodesTo: childNodes 	childNodes add: self</body><body package="T-Gen Core">asFSAStartingAt: startState endingAt: finalState 	startState goto: finalState on: self myChar</body></methods><methods><class-id>Tgen.CharacterNode</class-id> <category>accessing</category><body package="T-Gen Core">asInteger	^self myChar asInteger</body><body package="T-Gen Core">myChar	"Answer the Character represented by the receiver."	self charSpec size = 1		ifTrue: [^self charSpec first]		ifFalse: [self error: 'Only single character regular expressions atoms are currently supported.']</body></methods><methods><class-id>Tgen.CharacterNode class</class-id> <category>instance creation</category><body package="T-Gen Core">charSpec: arg1 	| newMe |	newMe := self new.	newMe charSpec: arg1.	^newMe</body></methods><methods><class-id>Tgen.HexadecimalCharNode</class-id> <category>accessing</category><body package="T-Gen Core">myChar	"Answer the Character represented by the receiver. 	The spec is of the form '\xHH'."	| spec |	spec := self charSpec.	(spec size = 4 and: [spec first = $\ and: [(spec at: 2)				= $x]])		ifTrue: [^Character value: ('16r' , (spec copyFrom: 3 to: 4)) asNumber]		ifFalse: [self error: 'Hexadecimal character specifications must be of the form ''\xHH''.']</body></methods><methods><class-id>Tgen.UnaryRegExprNode</class-id> <category>state accessing</category><body package="T-Gen Core">onlyChild	^onlyChild</body><body package="T-Gen Core">onlyChild: argument 	onlyChild := argument</body></methods><methods><class-id>Tgen.UnaryRegExprNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock 	"Evaluate aBlock for each of my children."	aBlock value: self onlyChild</body><body package="T-Gen Core">updateChildrenUsing: aBlock 	"Replace my children according to the value of aBlock."	self onlyChild: (aBlock value: self onlyChild)</body></methods><methods><class-id>Tgen.UnaryRegExprNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	anOrderedCollection size = 1		ifTrue: [self onlyChild: anOrderedCollection removeFirst]		ifFalse: [self error: 'wrong number of children']</body></methods><methods><class-id>Tgen.UnaryRegExprNode</class-id> <category>transforming</category><body package="T-Gen Core">needsTransforming	^true</body></methods><methods><class-id>Tgen.UnaryRegExprNode class</class-id> <category>instance creation</category><body package="T-Gen Core">onlyChild: arg1 	| newMe |	newMe := self new.	newMe onlyChild: arg1.	^newMe</body></methods><methods><class-id>Tgen.PlusClosureNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPut: $(.	self onlyChild printOn: aStream.	aStream nextPutAll: ')+'</body></methods><methods><class-id>Tgen.PlusClosureNode</class-id> <category>converting</category><body package="T-Gen Core">asPureRegExpr	"Answer a new version of the receiver consisting of only characters, 	concatenations, alternations, and (star) closures."	^self concatenationNodeClass children: (OrderedChildren with: self onlyChild asPureRegExpr with: (self starClosureNodeClass onlyChild: self onlyChild asPureRegExpr))</body></methods><methods><class-id>Tgen.PlusClosureNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes 	"Transform productions of the form 'A -&gt; alpha beta+ gamma' 	into 'A -&gt; alpha B', 'B -&gt; beta B', and 'B -&gt; beta gamma'."	| newProds newLHS |	newProds := OrderedCollection new.	newLHS := self newNonterminalFrom: lhsNode excluding: lhsNames.	newProds add: (self createNewProductionWithLHS: lhsNode andRHS: (alphaNodes addLast: newLHS; yourself)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: (OrderedCollection					with: self onlyChild copy					with: newLHS)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: (gammaNodes addFirst: self onlyChild copy; yourself)).	^newProds</body></methods><methods><class-id>Tgen.ProductionPartition</class-id> <category>adding</category><body package="T-Gen Core">addOtherProduction: prod 	self otherProductions add: prod</body><body package="T-Gen Core">addProblemProduction: prod 	self problemProductions add: prod</body></methods><methods><class-id>Tgen.ProductionPartition</class-id> <category>testing</category><body package="T-Gen Core">anyProblems	^self problemProductions isEmpty not</body></methods><methods><class-id>Tgen.ProductionPartition</class-id> <category>initialization</category><body package="T-Gen Core">initWithLeftHandSide: lhs 	self leftHandSide: lhs.	self problemProductions: Set new.	self otherProductions: Set new</body></methods><methods><class-id>Tgen.ProductionPartition</class-id> <category>state accessing</category><body package="T-Gen Core">leftHandSide	^leftHandSide</body><body package="T-Gen Core">leftHandSide: argument 	leftHandSide := argument</body><body package="T-Gen Core">otherProductions	^otherProductions</body><body package="T-Gen Core">otherProductions: argument 	otherProductions := argument</body><body package="T-Gen Core">problemProductions	^problemProductions</body><body package="T-Gen Core">problemProductions: argument 	problemProductions := argument</body></methods><methods><class-id>Tgen.ProductionPartition class</class-id> <category>instance creation</category><body package="T-Gen Core">partitionProdSetForLeftFactoring: prodSet 	"ProdSet contains all productions for a given nonterminal. Partition these 	productions into two sets: a set of sets of problem productions with common 	prefixes and all the rest. Answer the partitioned productions."	| prodPrefix newPP |	prodSet isEmpty ifTrue: [self error: 'cannot partition an empty prodSet'].	prodPrefix := SetDictionary new.	prodSet do: [:prod | prodPrefix at: (prod rightHandSide isEmpty				ifTrue: [self epsilon]				ifFalse: [prod rightHandSide first])			add: prod].	newPP := self new initWithLeftHandSide: prodSet first leftHandSide.	prodPrefix do: [:set | set size &gt; 1			ifTrue: [newPP addProblemProduction: set]			ifFalse: [newPP addOtherProduction: set first]].	^newPP</body><body package="T-Gen Core">partitionProdSetForLeftRecursion: prodSet 	"ProdSet contains all productions for a given nonterminal. Partition these 	productions into two sets: left-recursive problem productions and other 	non-left-recursive productions. Answer the partitioned productions."	| newPP |	prodSet isEmpty ifTrue: [self error: 'cannot partition an empty prodSet'].	newPP := self new initWithLeftHandSide: prodSet first leftHandSide.	prodSet do: [:prod | (prod rightHandSide isEmpty or: [prod leftHandSide ~= prod rightHandSide first])			ifTrue: [newPP addOtherProduction: prod]			ifFalse: [newPP addProblemProduction: prod]].	^newPP</body></methods><methods><class-id>Tgen.ProductionPartition class</class-id> <category>constants</category><body package="T-Gen Core">epsilon	"Answer an object used to represent the empty string (epsilon)."	^EpsilonNode epsilon</body></methods><methods><class-id>Tgen.AbstractParser</class-id> <category>state accessing</category><body package="T-Gen Core">failBlock	^failBlock</body><body package="T-Gen Core">failBlock: argument 	failBlock := argument</body><body package="T-Gen Core">prevToken	^prevToken</body><body package="T-Gen Core">prevToken: argument 	prevToken := argument</body><body package="T-Gen Core">requestor	^requestor</body><body package="T-Gen Core">requestor: argument 	requestor := argument</body><body package="T-Gen Core">scanner	^scanner</body><body package="T-Gen Core">scanner: argument 	scanner := argument</body></methods><methods><class-id>Tgen.AbstractParser</class-id> <category>scanning</category><body package="T-Gen Core">endOfInput	"Some parsers may use the eof token while others may use the eof token type."	self subclassResponsibility</body><body package="T-Gen Core">endOfInputToken	"Answer the token used by my scanner to represent the end of the input."	^self scanner endOfInputToken</body><body package="T-Gen Core">endOfInputTokenType	"Answer the token type used by my scanner to represent the end of the input."	^self scanner endOfInputTokenType</body><body package="T-Gen Core">initScannerSource: aString 	"The scanner is responsible for scanning the first token (i.e. for priming the token 	buffers)."	self scanner scanSource: aString</body><body package="T-Gen Core">nextToken	^self scanner tokenType</body><body package="T-Gen Core">nextTokenValue	^self scanner token</body><body package="T-Gen Core">scanToken	"Subclasses may not always want the previous token value and may override this 	method for efficiency."	self prevToken: self nextTokenValue.	self scanner scanToken</body></methods><methods><class-id>Tgen.AbstractParser</class-id> <category>private</category><body package="T-Gen Core">scannerClass	"Answer the preferred class of scanners for this kind of parser."	self subclassResponsibility</body></methods><methods><class-id>Tgen.AbstractParser</class-id> <category>initialization</category><body package="T-Gen Core">init	self scanner: self scannerClass new</body></methods><methods><class-id>Tgen.AbstractParser class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>scanning</category><body package="T-Gen Core">endOfInput	"Use the eof token type."	^self endOfInputTokenType</body><body package="T-Gen Core">endOfInputTokenType	"Answer the token type used by my scanner to represent the end of the input."	^self scanner endOfInputTokenType</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>state accessing</category><body package="T-Gen Core">parseTable	^parseTable</body><body package="T-Gen Core">parseTable: argument 	parseTable := argument</body><body package="T-Gen Core">requestor	^requestor</body><body package="T-Gen Core">requestor: argument 	requestor := argument</body><body package="T-Gen Core">transcript	^transcript</body><body package="T-Gen Core">transcript: argument 	transcript := argument</body><body package="T-Gen Core">treeBuilder	^treeBuilder</body><body package="T-Gen Core">treeBuilder: argument 	treeBuilder := argument</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>testing</category><body package="T-Gen Core">performsLeftmostDerivation	"This is the default, let subclasses override."	^false</body><body package="T-Gen Core">performsRightmostDerivation	"This is the default, let subclasses override."	^false</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>public access</category><body package="T-Gen Core">parse: aString ifFail: aBlock 	self failBlock: aBlock.	self exceptionHandlers		handleDo: 			[self initScannerSource: aString.			^self parse]</body><body package="T-Gen Core">parseAndTrace: aString ifFail: aBlock 	self failBlock: aBlock.	"Make sure we don't accidently write to someone else's window."	self transcript: nil.	self exceptionHandlers		handleDo: 			[self initScannerSource: aString.			^self traceParse]</body><body package="T-Gen Core">parseAndTrace: aString on: aTranscript ifFail: aBlock 	self failBlock: aBlock.	self transcript: aTranscript.	self exceptionHandlers		handleDo: 			[self initScannerSource: aString.			^self traceParse]</body><body package="T-Gen Core">parseForAST: aString ifFail: aBlock 	self failBlock: aBlock.	self exceptionHandlers		handleDo: 			[self initScannerSource: aString.			^self parseForAST]</body><body package="T-Gen Core">parseForDerivationTree: aString ifFail: aBlock 	self failBlock: aBlock.	self exceptionHandlers		handleDo: 			[self initScannerSource: aString.			^self parseForDerivationTree]</body><body package="T-Gen Core">parseForShamAST: aString ifFail: aBlock 	self failBlock: aBlock.	self exceptionHandlers		handleDo: 			[self initScannerSource: aString.			^self parseForShamAST]</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>parsing</category><body package="T-Gen Core">parse	self subclassResponsibility</body><body package="T-Gen Core">parseForAST	| builder |	builder := self treeBuilder reset.	^self parseWithTreeBuilder: builder</body><body package="T-Gen Core">parseForDerivationTree	^self parseWithTreeBuilder: self derivationTreeBuilderClass new</body><body package="T-Gen Core">parseForShamAST	| builder |	builder := self treeBuilder reset.	builder setShamMode.	^self parseWithTreeBuilder: builder</body><body package="T-Gen Core">parseWithTreeBuilder: parseTreeBuilder 	"Return the result of a parse with parseTreeBuilder."	self subclassResponsibility</body><body package="T-Gen Core">traceParse	self subclassResponsibility</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>private</category><body package="T-Gen Core">derivationTreeBuilderClass	^DerivationTreeBuilder</body><body package="T-Gen Core">myParseTable	^self class parseTable</body><body package="T-Gen Core">scannerClass	"Translator generator tools may initially create an 'abstract' parser and 'plug-in' 	a scanner. This allows instances of these abstract parsers to be used in this 	fashion. Ultimately, the tools will create concrete scanner and parser classes 	with the proper links established."	^Object</body><body package="T-Gen Core">treeBuilderClass	"Different tree builders can either be plugged in or subclasses can override this 	method."	^AbstractSyntaxTreeBuilder</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>tracing</category><body package="T-Gen Core">cr	self show: ''</body><body package="T-Gen Core">defaultTranscript	^Transcript</body><body package="T-Gen Core">show: aString 	(self transcript isNil		ifTrue: [self defaultTranscript]		ifFalse: [self transcript])		show: aString</body><body package="T-Gen Core">showCR: aString 	self show: aString , ''</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>exception handling</category><body package="T-Gen Core">abort	| block |	block := self failBlock.	self failBlock: nil.	^block value</body><body package="T-Gen Core">exceptionHandlers	"Answer a HandlerList that will catch and handle scanner and parser errors."	| handlers |	handlers := HandlerList new.	handlers on: self scannerErrorSignal		handle: 			[:ex | 			self requestor notNil				ifTrue: 					[self requestor insertAndSelect: 'SCANNER ERROR: ' , ex description , ' -&gt;' at: self scanner errorPosition.					self requestor activate].			self abort].	handlers on: self parserErrorSignal		handle: 			[:ex | 			self requestor notNil				ifTrue: 					[self requestor insertAndSelect: '&lt;- PARSER ERROR: ' , ex description at: self scanner errorPosition.					self requestor activate].			self abort].	^handlers</body><body package="T-Gen Core">parserErrorSignal	self subclassResponsibility</body><body package="T-Gen Core">scannerErrorSignal	^FSAState noTransitionSignal</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>converting</category><body package="T-Gen Core">spaceOptimize	self parseTable spaceOptimize</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self parseTable: self myParseTable.	self treeBuilder: self treeBuilderClass new</body></methods><methods><class-id>Tgen.TableDrivenParser</class-id> <category>scanner/parser generation</category><body package="T-Gen Core">classInitializationMethodTextForClassNamed: name spec: grammarSpec 	^self subclassResponsibility</body><body package="T-Gen Core">createParserClassNamed: name category: category spec: grammarSpec 	| parserClass |	parserClass := self defaultParserClass				subclass: name asSymbol				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: category.	parserClass comment: self generatedParserClassComment.	parserClass class compile: (self classInitializationMethodTextForClassNamed: name spec: grammarSpec)		classified: 'class initialization'.	parserClass initialize.	^parserClass</body><body package="T-Gen Core">createParserClassNamed: parserClassname scannerClassname: scannerClassname category: categoryName grammarSpec: grammarSpec 	"Create a parser class named parserClassname using grammerSpec whose scanner is class 	named  scannerClassname and install it in category named categoryName."	| parserClass |	parserClass := self				createParserClassNamed: parserClassname				category: categoryName				spec: grammarSpec.	parserClass compile: 'scannerClass	^' , scannerClassname classified: 'private'.	parserClass compile: 'treeBuilderClass	^' , self treeBuilder class printString classified: 'private'</body><body package="T-Gen Core">createScannerClassNamed: name category: category spec: tokenSpec 	^self scanner		createScannerClassNamed: name		category: category		spec: tokenSpec</body><body package="T-Gen Core">createScannerParserClassesNamed: namePrefix category: category tokenSpec: tokenSpec grammarSpec: grammarSpec 	"Create a scanner class named &lt;namePrefix&gt;Scanner using tokenSpec and parser class named 	&lt;namePrefix&gt;Parser using grammerSpec and install it in category named categoryName."	self		createScannerClassNamed: namePrefix , 'Scanner'		category: category		spec: tokenSpec.	self		createParserClassNamed: namePrefix , 'Parser'		scannerClassname: namePrefix , 'Scanner'		category: category		grammarSpec: grammarSpec</body><body package="T-Gen Core">defaultParserClass	^self class</body><body package="T-Gen Core">generatedParserClassComment	^'This parser class was automatically generated by ', TranslatorGenerator versionName , '.'</body><body package="T-Gen Core">newStreamForMethodRendering | ws | ws := WriteStream on: (String new: 2048). ws policy printCharactersLiterally: true. ^ws</body></methods><methods><class-id>Tgen.TableDrivenParser class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"Concrete subclasses must somehow provide a parse table. Subclasses created 	by automatic means may simply 'plug-in' a dynamically computed parse table. 	However, if a class that can be filed-out is desired then it is worthwhile to 	override this initialization method with one that can build the appropriate parse 	table directly."	"TableDrivenParser initialize"	self parseTable: nil</body></methods><methods><class-id>Tgen.TableDrivenParser class</class-id> <category>state accessing</category><body package="T-Gen Core">parseTable	^parseTable</body><body package="T-Gen Core">parseTable: argument 	parseTable := argument</body></methods><methods><class-id>Tgen.TableDrivenParser class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.TableDrivenParser class</class-id> <category>utility</category><body package="T-Gen Core">convertFromStoredProductionTable: prodTable	"Return a copy of prodTable where the string &lt;Character value: * is converted to a character object"	| newProdTable |	newProdTable := prodTable copy.	1 to: prodTable size do: 		[:index | 		| goodString |		goodString := prodTable at: index.		(goodString isCharacters and: ['&lt;Character value:*' match: goodString ignoreCase: true])			ifTrue: 				[goodString := goodString copyFrom: 2 to: goodString size - 1.				newProdTable at: index put: (Character readFromString: goodString)]].	^newProdTable</body></methods><methods><class-id>Tgen.LL1Parser</class-id> <category>state accessing</category><body package="T-Gen Core">startSymbol	^startSymbol</body><body package="T-Gen Core">startSymbol: argument 	startSymbol := argument</body></methods><methods><class-id>Tgen.LL1Parser</class-id> <category>private</category><body package="T-Gen Core">epsilon	"Answer an object used to represent the empty string (epsilon)."	^'&lt;epsilon&gt;'</body><body package="T-Gen Core">myStartSymbol	^self class startSymbol</body><body package="T-Gen Core">parserErrorSignal	^LLParserTable noTransitionSignal</body></methods><methods><class-id>Tgen.LL1Parser</class-id> <category>exception handling</category><body package="T-Gen Core">raiseExceptionExpectedToken: aString 	self raiseNoTransitionExceptionErrorString: 'expecting ' , aString</body><body package="T-Gen Core">raiseExceptionUnparsedTokens	self raiseNoTransitionExceptionErrorString: 'unparsed tokens remaining in input'</body><body package="T-Gen Core">raiseNoTransitionExceptionErrorString: aString 	self parserErrorSignal raiseErrorString: aString</body></methods><methods><class-id>Tgen.LL1Parser</class-id> <category>parsing</category><body package="T-Gen Core">parse	| stack prod |	stack := OrderedCollection new.	stack addFirst: self startSymbol.	[stack isEmpty] whileFalse: 			[stack first isTerminal				ifTrue: 					[stack first = self nextToken						ifTrue: 							[stack removeFirst.							self scanToken]						ifFalse: [self raiseExceptionExpectedToken: stack first symbol]]				ifFalse: 					[prod := self productionAtNonterminal: stack removeFirst andTerminal: self nextToken.					prod rightHandSide reverseDo: [:sym | stack addFirst: sym]]].	self nextToken = self endOfInput		ifFalse: [self raiseExceptionUnparsedTokens]</body><body package="T-Gen Core">parseForDerivationTreeAlternative	"Derivation trees can be build efficiently during a top-down parse. 	This method implements this option (see parseForDerivationTree)."	| stack prod root parent node |	stack := OrderedCollection new.	root := DerivationTreeNode symbol: self startSymbol.	stack addFirst: root.	[stack isEmpty] whileFalse: 			[stack first isTerminal				ifTrue: 					[stack first symbol = self nextToken						ifTrue: 							[stack removeFirst.							self scanToken]						ifFalse: [self raiseExceptionExpectedToken: stack first symbol]]				ifFalse: 					[prod := self productionAtNonterminal: stack first symbol andTerminal: self nextToken.					parent := stack removeFirst.					prod rightHandSide isEmpty						ifTrue: 							[node := DerivationTreeNode symbol: self epsilon.							parent addChild: node]						ifFalse: 							[prod rightHandSide reverseDo: 									[:sym | 									node := DerivationTreeNode symbol: sym.									parent addFirstChild: node.									stack addFirst: node]]]].	self nextToken = self endOfInput		ifFalse: [self raiseExceptionUnparsedTokens].	^root</body><body package="T-Gen Core">parseWithTreeBuilder: parseTreeBuilder 	"Rather than building the tree top-down during the parse, it's easier to save 	the productions on a stack and build the tree bottom-up after parsing."	| stack productionStack |	productionStack := OrderedCollection new.	stack := OrderedCollection new.	stack addFirst: self startSymbol.	[stack isEmpty] whileFalse: 			[stack first isTerminal				ifTrue: 					["cancel matching tokens"					stack first = self nextToken						ifTrue: 							[stack removeFirst.							self scanToken]						ifFalse: [self raiseExceptionExpectedToken: stack top]]				ifFalse: 					["expand nonterminal"					productionStack						addFirst: (self productionAtNonterminal: stack removeFirst andTerminal: self nextToken)								@ self nextTokenValue.					productionStack first x rightHandSide reverseDo: [:sym | stack addFirst: sym]]].	self nextToken = self endOfInput		ifFalse: [self raiseExceptionUnparsedTokens].	productionStack do: 			[:prod | 			self prevToken: prod y.			parseTreeBuilder processProduction: prod x forParser: self].	^parseTreeBuilder result</body><body package="T-Gen Core">productionAtNonterminal: nont andTerminal: term	^self parseTable productionAtNonterminal: nont andTerminal: term</body><body package="T-Gen Core">traceParse	| stack prod |	self		 cr;		 cr;		 showCR: 'LL Parser trace of:  ' , self scanner contents;		 cr.	stack := OrderedCollection new.	stack addFirst: self startSymbol.	[stack isEmpty]		whileFalse: [stack first isTerminal				ifTrue: [stack first = self nextToken						ifTrue: 							[self showCR: 'cancel ''' , stack first asString, ''' from input'.							stack removeFirst.							self scanToken]						ifFalse: [self error: 'raise exception:  top of stack = ''' , stack first asString , ''' next token = ''' , self nextToken asString, '''']]				ifFalse: 					[prod := self productionAtNonterminal: stack first andTerminal: self nextToken.					self showCR: 'apply production ' , prod printString.					stack removeFirst.					prod rightHandSide reverseDo: [:sym | stack addFirst: sym]]].	self nextToken = self endOfInput ifFalse: [self raiseExceptionUnparsedTokens]</body></methods><methods><class-id>Tgen.LL1Parser</class-id> <category>testing</category><body package="T-Gen Core">performsLeftmostDerivation	^true</body></methods><methods><class-id>Tgen.LL1Parser</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self startSymbol: self myStartSymbol</body></methods><methods><class-id>Tgen.LL1Parser</class-id> <category>converting</category><body package="T-Gen Core">fastParser	^OptimizedLL1Parser buildFrom: self</body></methods><methods><class-id>Tgen.LL1Parser class</class-id> <category>instance creation</category><body package="T-Gen Core">parseTable: table startSymbol: sym 	| newParser |	newParser := self new.	newParser parseTable: table.	newParser startSymbol: sym.	^newParser</body></methods><methods><class-id>Tgen.LL1Parser class</class-id> <category>state accessing</category><body package="T-Gen Core">startSymbol	^startSymbol</body><body package="T-Gen Core">startSymbol: argument 	startSymbol := argument</body></methods><methods><class-id>Tgen.ConflictStrategy</class-id> <category>resolving</category><body package="T-Gen Core">resolveReduceReduceFor: aTerm atState: currState 	self subclassResponsibility</body><body package="T-Gen Core">resolveShiftReduceFor: aTransitSymbol atState: currState 	self subclassResponsibility</body></methods><methods><class-id>Tgen.StandardConflictStrategy</class-id> <category>resolving</category><body package="T-Gen Core">resolveReduceReduceFor: aTerm atState: currState 	^OrderedCollection with: currState</body><body package="T-Gen Core">resolveShiftReduceFor: aTransitSymbol atState: currState 	^OrderedCollection with: currState</body></methods><methods><class-id>Tgen.BinaryRegExprNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenFirst: anOrderedCollection 	anOrderedCollection size = 1		ifTrue: [self leftChild: anOrderedCollection removeFirst]		ifFalse: [self error: 'wrong  number of children']</body><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	anOrderedCollection size = 2		ifTrue: 			[self leftChild: anOrderedCollection removeFirst.			self rightChild: anOrderedCollection removeFirst]		ifFalse: [anOrderedCollection size = 1				ifTrue: [self rightChild: anOrderedCollection removeFirst]				ifFalse: [self error: ' wrong  number of children']]</body></methods><methods><class-id>Tgen.BinaryRegExprNode</class-id> <category>state accessing</category><body package="T-Gen Core">leftChild	^leftChild</body><body package="T-Gen Core">leftChild: argument 	leftChild := argument</body><body package="T-Gen Core">rightChild	^rightChild</body><body package="T-Gen Core">rightChild: argument 	rightChild := argument</body></methods><methods><class-id>Tgen.BinaryRegExprNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock 	"Evaluate aBlock for each of my children."	aBlock value: self leftChild.	aBlock value: self rightChild</body><body package="T-Gen Core">updateChildrenUsing: aBlock 	"Replace my children according to the value of aBlock."	self leftChild: (aBlock value: self leftChild).	self rightChild: (aBlock value: self rightChild)</body></methods><methods><class-id>Tgen.BinaryRegExprNode class</class-id> <category>instance creation</category><body package="T-Gen Core">leftChild: arg1 rightChild: arg2 	| newMe |	newMe := self new.	newMe leftChild: arg1.	newMe rightChild: arg2.	^newMe</body></methods><methods><class-id>Tgen.PartitionTransitionMap</class-id> <category>state transitions</category><body package="T-Gen Core">goto: aPartition on: aSymbol 	(self transitionMap includesKey: aSymbol)		ifTrue: [self error: 'these are supposed to be deterministic, what gives?'].	self transitionMap at: aSymbol put: aPartition</body></methods><methods><class-id>Tgen.PartitionTransitionMap</class-id> <category>state accessing</category><body package="T-Gen Core">partition	^partition</body><body package="T-Gen Core">partition: argument 	partition := argument</body><body package="T-Gen Core">transitionMap	^transitionMap</body><body package="T-Gen Core">transitionMap: argument 	transitionMap := argument</body></methods><methods><class-id>Tgen.PartitionTransitionMap</class-id> <category>initialization</category><body package="T-Gen Core">initWithPartition: pt 	self transitionMap: Dictionary new.	self partition: pt</body></methods><methods><class-id>Tgen.PartitionTransitionMap</class-id> <category>testing</category><body package="T-Gen Core">isPartitionTransitionMap	^true</body></methods><methods><class-id>Tgen.PartitionTransitionMap</class-id> <category>comparing</category><body package="T-Gen Core">hasSameTransitionMapAs: aPTMap 	"Two partition transition maps are equivalent if they have equivalent transition maps."	| map1 map2 |	aPTMap isPartitionTransitionMap ifFalse: [^false].	map1 := self transitionMap.	map2 := aPTMap transitionMap.	map1 size = map2 size ifFalse: [^false].	map1 keysAndValuesDo: [:key :val | (map2 at: key ifAbsent: [^false]) = val ifFalse: [^false]].	^true</body></methods><methods><class-id>Tgen.PartitionTransitionMap</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPutAll: self partition hash printString; cr.	self transitionMap printOn: aStream</body></methods><methods><class-id>Tgen.PartitionTransitionMap class</class-id> <category>instance creation</category><body package="T-Gen Core">forPartition: pt 	^self new initWithPartition: pt</body></methods><methods><class-id>Tgen.DirectedGraphNode</class-id> <category>state accessing</category><body package="T-Gen Core">predecessors	^predecessors</body><body package="T-Gen Core">predecessors: argument 	predecessors := argument</body></methods><methods><class-id>Tgen.DirectedGraphNode</class-id> <category>initialization</category><body package="T-Gen Core">init	self predecessors: OrderedCollection new</body></methods><methods><class-id>Tgen.DirectedGraphNode</class-id> <category>modifying</category><body package="T-Gen Core">addPredecessor: node 	self predecessors add: node</body><body package="T-Gen Core">removePredecessor: node 	self predecessors remove: node ifAbsent: [self error: 'precedessor not found']</body><body package="T-Gen Core">removePredecessor: node ifAbsent: aBlock 	self predecessors remove: node ifAbsent: [^aBlock value]</body></methods><methods><class-id>Tgen.DirectedGraphNode</class-id> <category>enumerating</category><body package="T-Gen Core">predecessorsDo: aBlock 	"Evaluate aBlock with each of my predecessors."	self predecessors do: aBlock</body></methods><methods><class-id>Tgen.DirectedGraphNode class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.NodeLabeledDigraphNode</class-id> <category>state accessing</category><body package="T-Gen Core">label	^label</body><body package="T-Gen Core">label: argument 	label := argument</body></methods><methods><class-id>Tgen.NodeLabeledDigraphNode class</class-id> <category>instance creation</category><body package="T-Gen Core">label: arg1 	| newMe |	newMe := self new.	newMe label: arg1.	^newMe</body></methods><methods><class-id>Tgen.LLParserTable</class-id> <category>testing</category><body package="T-Gen Core">isDeterministic	self detect: [:row | row isDeterministic not]		ifNone: [^true].	^false</body></methods><methods><class-id>Tgen.LLParserTable</class-id> <category>private</category><body package="T-Gen Core">newRow	^self rowClass new</body><body package="T-Gen Core">rowClass	^SetDictionary</body></methods><methods><class-id>Tgen.LLParserTable</class-id> <category>accessing</category><body package="T-Gen Core">atNonterminal: nont andTerminal: term addProduction: prod 	| row |	row := self at: nont ifAbsent: [self at: nont put: self newRow].	^row at: term add: prod</body><body package="T-Gen Core">productionAtNonterminal: nont andTerminal: term 	| row |	row := self at: nont ifAbsent: [self raiseNoTransitionExceptionErrorString: 'illegal nonterminal symbol encountered:  ' , nont].	^row at: term ifAbsent: [self raiseNoTransitionExceptionErrorString: 'expecting one of ' , row keys printString , ' but encountered:  ''' , term displayString , '''']</body></methods><methods><class-id>Tgen.LLParserTable</class-id> <category>converting</category><body package="T-Gen Core">spaceOptimize	"Assumes self isDeterministic."	self associationsDo: [:assoc | self at: assoc key put: assoc value asDictionary]</body></methods><methods><class-id>Tgen.LLParserTable</class-id> <category>exception handling</category><body package="T-Gen Core">raiseNoTransitionExceptionErrorString: aString 	self class noTransitionSignal raiseErrorString: aString</body></methods><methods><class-id>Tgen.LLParserTable class</class-id> <category>state accessing</category><body package="T-Gen Core">noTransitionSignal	^noTransitionSignal</body><body package="T-Gen Core">noTransitionSignal: argument 	noTransitionSignal := argument</body></methods><methods><class-id>Tgen.LLParserTable class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"LLParserTable initialize"	self noTransitionSignal: (Signal new nameClass: self message: #noTransitionSymbol)</body></methods><methods><class-id>Tgen.GrammarParseTreeNode</class-id> <category>private</category><body package="T-Gen Core">alternationNodeClass	^AlternationNode</body><body package="T-Gen Core">concatenationNodeClass	^ConcatenationNode</body></methods><methods><class-id>Tgen.GrammarParseTreeNode</class-id> <category>building parse trees</category><body package="T-Gen Core">alternateWith: node	^node alternateWithNonAltNode: self</body><body package="T-Gen Core">alternateWithAltNode: node	node children addLast: self.	^node</body><body package="T-Gen Core">alternateWithNonAltNode: node	^self alternationNodeClass children: (OrderedCollection with: node with: self)</body><body package="T-Gen Core">concatenateWith: node	^node concatenateWithNonCatNode: self</body><body package="T-Gen Core">concatenateWithCatNode: node	node children addLast: self.	^node</body><body package="T-Gen Core">concatenateWithNonCatNode: node	^self concatenationNodeClass children: (OrderedCollection with: node with: self)</body></methods><methods><class-id>Tgen.RightHandSideNode</class-id> <category>state accessing</category><body package="T-Gen Core">symbols	^symbols</body><body package="T-Gen Core">symbols: argument 	symbols := argument</body><body package="T-Gen Core">translationSymbol	^translationSymbol</body><body package="T-Gen Core">translationSymbol: argument 	translationSymbol := argument</body></methods><methods><class-id>Tgen.RightHandSideNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	self symbols: anOrderedCollection removeFirst.	self translationSymbol: anOrderedCollection removeFirst</body></methods><methods><class-id>Tgen.RightHandSideNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock 	"Evaluate aBlock for each of my children."	self symbols do: aBlock.	aBlock value: self translationSymbol</body><body package="T-Gen Core">updateChildrenUsing: aBlock 	"Replace my children according to the value of aBlock."	self symbols: (self symbols collect: aBlock).	self translationSymbol: (aBlock value: self translationSymbol)</body></methods><methods><class-id>Tgen.RightHandSideNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self  printSymbolsOn: aStream.	self translationSymbol notNil		ifTrue: 			[aStream nextPut: ${.			self translationSymbol printOn: aStream.			aStream nextPutAll: '}  ;']</body><body package="T-Gen Core">printSymbolsOn: aStream 	self symbols do: 		[:sym | 		sym printOn: aStream.		aStream space]</body></methods><methods><class-id>Tgen.RightHandSideNode</class-id> <category>converting</category><body package="T-Gen Core">asProductionWithLeftHandSide: lhs 	"Answer the GrammarProduction I represent."	| rhs |	rhs := self convertSymbols.	^self translationSymbol isNil		ifTrue: [GrammarProduction leftHandSide: lhs rightHandSide: rhs]		ifFalse: [TransductionGrammarProduction				leftHandSide: lhs				rightHandSide: rhs				translationSymbol: self translationSymbol symbol]</body><body package="T-Gen Core">convertSymbols 	^self symbols collect: [:sym | sym asGrammarSymbol]</body></methods><methods><class-id>Tgen.RightHandSideNode class</class-id> <category>instance creation</category><body package="T-Gen Core">symbols: arg1 translationSymbol: arg2	| newNode |	newNode := self new.	newNode symbols: arg1.	newNode translationSymbol: arg2.	^newNode</body></methods><methods><class-id>Tgen.AbstractScanner</class-id> <category>initialization</category><body package="T-Gen Core">init	self buffer: (RetractableWriteStream on: (String new: 32))</body><body package="T-Gen Core">reset	"Reset the initial state of the scanner before scanning a new source."	self buffer reset.	self token: nil.	self tokenType: nil.	self nextChar: nil</body><body package="T-Gen Core">scanSource: aString 	"Convert the input string to a read stream and scan the first token."	self reset.	self source: (RetractableReadStream on: aString).	self nextChar: self source next.	self scanToken</body></methods><methods><class-id>Tgen.AbstractScanner</class-id> <category>state accessing</category><body package="T-Gen Core">buffer	^buffer</body><body package="T-Gen Core">buffer: argument 	buffer := argument</body><body package="T-Gen Core">nextChar	^nextChar</body><body package="T-Gen Core">nextChar: argument 	nextChar := argument</body><body package="T-Gen Core">source	^source</body><body package="T-Gen Core">source: argument 	source := argument</body><body package="T-Gen Core">token	^token</body><body package="T-Gen Core">token: argument 	token := argument</body><body package="T-Gen Core">tokenType	^tokenType</body><body package="T-Gen Core">tokenType: argument 	tokenType := argument</body></methods><methods><class-id>Tgen.AbstractScanner</class-id> <category>scanning</category><body package="T-Gen Core">backspaceSource	"When the source is at the end, 'source current' is the last character."	self atEnd ifFalse: [self source backspace].	self nextChar: self source current</body><body package="T-Gen Core">getNextChar	"Source will answer an empty string when no more input is available. 	Subclasses may override this to avoid unnecessary buffering."	self buffer nextPut: self nextChar.	self nextChar: self source next</body><body package="T-Gen Core">putBackChar	"Remove the last character in the buffer and backspace the source. 	Subclasses may override this to avoid unnecessary buffering."	self buffer backspace.	self backspaceSource</body><body package="T-Gen Core">scanToken	"Subclasses must compute values for token and tokenType here."	self subclassResponsibility</body><body package="T-Gen Core">signalEndOfInput	"Set scanner to the end-of-input state."	self tokenType: self endOfInputTokenType.	self token: self endOfInputToken</body></methods><methods><class-id>Tgen.AbstractScanner</class-id> <category>testing</category><body package="T-Gen Core">atEnd	^self nextChar = self endOfInputToken</body></methods><methods><class-id>Tgen.AbstractScanner</class-id> <category>accessing</category><body package="T-Gen Core">contents	^self source contents</body><body package="T-Gen Core">endOfInputToken	"Answer a token representing the end of the input."	self subclassResponsibility</body><body package="T-Gen Core">endOfInputTokenType	"Answer the token type representing the end of the input."	self subclassResponsibility</body><body package="T-Gen Core">errorPosition	"Answer the source position of the last acceptable character."	^source position + (self atEnd			ifTrue: [1]			ifFalse: [0]) max: 1</body><body package="T-Gen Core">position	^self source position</body></methods><methods><class-id>Tgen.AbstractScanner class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body><body package="T-Gen Core">scanFrom: aString 	| newScanner |	newScanner := self new.	newScanner scanSource: aString.	^newScanner</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>state accessing</category><body package="T-Gen Core">fsa	^fsa</body><body package="T-Gen Core">fsa: argument 	fsa := argument</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>scanning directives</category><body package="T-Gen Core">compactDoubleApostrophes	"Compact all two apostrophe sequences in my current token into a single 	apostrophe."	| readStream writeStream ch nextCh |	readStream := ReadStream on: self token.	writeStream := WriteStream on: (String new: 20).	[readStream atEnd]		whileFalse: 			[writeStream nextPut: (ch := readStream next).			(ch = $' and: [(nextCh := readStream peek) notNil and: [nextCh = $']])				ifTrue: [readStream skip: 1]].	self token: writeStream contents</body><body package="T-Gen Core">ignoreComment	self scanToken</body><body package="T-Gen Core">ignoreDelimiter	self scanToken</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>accessing</category><body package="T-Gen Core">endOfInputToken	"Answer a token representing the end of the input."	^Character endOfInput</body><body package="T-Gen Core">endOfInputTokenType	"Answer the token type representing the end of the input."	^self endOfInputToken</body><body package="T-Gen Core">myFsa	^self class fsa</body><body package="T-Gen Core">startState	^self fsa</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>scanning</category><body package="T-Gen Core">scanToken	"Scan the next token and compute its token type."	| state nextState tok typeAction |	self atEnd		ifTrue: [self signalEndOfInput]		ifFalse: 			[state := self startState.			[(nextState := self at: state transitionFor: self nextChar) isNil]				whileFalse: 					[state := nextState.					self getNextChar].			tok := self buffer contents.			typeAction := self at: state tokenTypeAndActionFor: tok.			self tokenType: typeAction type.			self token: tok.			self buffer reset.			typeAction action notNil ifTrue: [self perform: typeAction action]]</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self fsa: self myFsa</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>scanner generation</category><body package="T-Gen Core">classInitializationMethodTextForClassNamed: name spec: tokenSpec 	^self subclassResponsibility</body><body package="T-Gen Core">createScannerClassNamed: name category: category spec: tokenSpec 	| scannerClass |	scannerClass := self defaultScannerClass				subclass: name asSymbol				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: category.	scannerClass comment: self generatedScannerClassComment.	scannerClass class compile: (self classInitializationMethodTextForClassNamed: name spec: tokenSpec)		classified: 'class initialization'.	scannerClass initialize.	^scannerClass</body><body package="T-Gen Core">defaultOptimizedScannerClass	^OptimizedScanner</body><body package="T-Gen Core">defaultScannerClass	^self class</body><body package="T-Gen Core">generatedScannerClassComment	^'This scanner class was automatically generated by ', TranslatorGenerator versionName , '.'</body><body package="T-Gen Core">newStreamForMethodRendering | ws | ws := WriteStream on: (String new: 2048). ws policy printCharactersLiterally: true. ^ws</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>converting</category><body package="T-Gen Core">fastScanner	^self defaultOptimizedScannerClass buildFrom: self</body></methods><methods><class-id>Tgen.FSABasedScanner</class-id> <category>private</category><body package="T-Gen Core">at: state tokenTypeAndActionFor: tok 	^state tokenTypeAndActionFor: tok</body><body package="T-Gen Core">at: state transitionFor: char 	^state transitionFor: char</body></methods><methods><class-id>Tgen.FSABasedScanner class</class-id> <category>state accessing</category><body package="T-Gen Core">fsa	^fsa</body><body package="T-Gen Core">fsa: argument 	fsa := argument</body></methods><methods><class-id>Tgen.FSABasedScanner class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"Concrete subclasses must somehow provide a fsa. Subclasses created by 	automatic means may simply 'plug-in' a dynamically computed fsa. However, if a 	class that can be filed-out is desired then it is worthwhile to override this 	initialization method with one that can build the appropriate fsa directly."	"FSABasedScanner initialize"	self fsa: nil</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>converting</category><body package="T-Gen Core">assignNextIDAfter: id toSuccessorOf: state 	"I try to assing a number to fsa in order to create a fsa table."	| nextID nextState |	nextID := id + 1.	state edgeLabelMap		associationsDo: 			[:assoc | 			nextState := assoc value.			nextState stateID isNil				ifTrue: 					[nextState stateID: nextID.					nextState isFSAFinalState ifTrue: [(finalStateTable includes: nextState)							ifFalse: [finalStateTable at: nextID put: nextState]].					nextID := self assignNextIDAfter: nextID toSuccessorOf: nextState]].	^nextID</body><body package="T-Gen Core">changeFSAToObjectTable: fsaState 	| sizePlusOne objectTable  |	fsaState stateID notNil ifTrue: [fsaState nilOutStateIDs].	fsaState stateID:  self startState.	self finalStateTable: Dictionary new.	sizePlusOne := self assignNextIDAfter: self startState toSuccessorOf: fsaState.	objectTable := Array new: sizePlusOne - 1.	self convert: fsaState to: objectTable.	self modifyFSAFinalStates: sizePlusOne - 1.		"convert Dictionary to Array for speed"	^objectTable</body><body package="T-Gen Core">convert: state to: objectTable 	"I try to create a table that maps state ( represented by integer ) to state"	| arr nextState |	arr := Array new: 127.	objectTable at: state stateID put: arr.	state edgeLabelMap		associationsDo: 			[:assoc | 			nextState := assoc value.			(objectTable at: nextState stateID) isNil ifTrue: [self convert: nextState to: objectTable].			arr at: assoc key asInteger put: nextState stateID].	^objectTable</body><body package="T-Gen Core">convertToTable: fsaScanner 	self fsa: (self changeFSAToObjectTable: fsaScanner fsa)</body><body package="T-Gen Core">modifyFSAFinalStates: index 	"Convert Dictionary and its values to Array of Array"	| tokenSet table |	table := Array new: index.	finalStateTable do: 		[:st | 		tokenSet := Array new: 2.		tokenSet at: 1 put: st literalTokens asOrderedCollection asArray; at: 2 put: st tokenClasses asArray.		table at: st stateID put: tokenSet].	self finalStateTable: table</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>private</category><body package="T-Gen Core">at: state transitionFor: char 	| value |	(value := (fsa at: state)				at: char asInteger) isNil ifTrue: [(finalStateTable at: state) isNil ifTrue: [self raiseNoTransitionExceptionErrorString: (char == self endOfInputToken					ifTrue: [self endOfInputErrorString]					ifFalse: [self standardErrorString , '''' , char displayString , ''''])]].	^value</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self finalStateTable: self myFinalStateTable</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>state accessing</category><body package="T-Gen Core">finalStateTable	^finalStateTable</body><body package="T-Gen Core">finalStateTable: arg 	finalStateTable := arg</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>accessing</category><body package="T-Gen Core">myFinalStateTable	^self class finalStateTable</body><body package="T-Gen Core">startState	^1</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>exception handling</category><body package="T-Gen Core">endOfInputErrorString	^'end of input encountered'</body><body package="T-Gen Core">raiseNoTransitionExceptionErrorString: aString 	self class noTransitionSignal raiseErrorString: aString</body><body package="T-Gen Core">standardErrorString	^'illegal character encountered:  '</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>testing</category><body package="T-Gen Core">atEnd	^nextChar == self endOfInputToken		"end-of-file character"</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>reconstructing</category><body package="T-Gen Core">reconstructFinalStateTableOn: aStream 	aStream nextPutAll: 'table := '.	finalStateTable reconstructOn: aStream.	aStream		period;		crtab;		nextPutAll: 'self constructFinalStateTable: table'</body><body package="T-Gen Core">reconstructFSAOn: aStream 	aStream nextPutAll: 'self fsa: '.	fsa reconstructOn: aStream.	aStream period; crtab</body><body package="T-Gen Core">reconstructOn: aStream 	"Recreate fsa and final state tables"	self reconstructFSAOn: aStream.	self reconstructFinalStateTableOn: aStream</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>scanner generation</category><body package="T-Gen Core">classInitializationMethodTextForClassNamed: name spec: tokenSpec | ws | ws := self newStreamForMethodRendering. ws  nextPutAll: 'initialize';  crtab;  nextPut: $";  nextPutAll: name;  nextPutAll: ' initialize"';  crtab;  nextPut: $". tokenSpec do:  [:ch |  "double embedded double-quote characters"  ws nextPut: ch.  ch = $" ifTrue: [ws nextPut: $"]]. ws  nextPut: $";  cr;  crtab;  nextPutAll: '| table |';  crtab. self reconstructOn: ws. ^ws contents</body></methods><methods><class-id>Tgen.OptimizedScanner</class-id> <category>scanning</category><body package="T-Gen Core">at: state tokenTypeAndActionFor: aString 	"The current implementation does not handle overlapping token classes. Hence, a final state 	can only represent a literal or a single token class. Therefore, if not a literal then it must be 	the token class."	| tc |	(((finalStateTable at: state)		at: 1)		includes: aString)		ifTrue: [^TokenTypeActionHolder type: aString action: nil].	tc := ((finalStateTable at: state)				at: 2) first .	^TokenTypeActionHolder type: tc tokenType action: tc action</body><body package="T-Gen Core">getNextChar	"Source will answer an eof char when no more input is available. 	Subclasses may override this to avoid unnecessary buffering."	buffer nextPut: nextChar.	nextChar := source next</body><body package="T-Gen Core">signalEndOfInput	"Set scanner to the end-of-input state."	tokenType := token := self endOfInputToken</body></methods><methods><class-id>Tgen.OptimizedScanner class</class-id> <category>state accessing</category><body package="T-Gen Core">finalStateTable	^finalStateTable</body><body package="T-Gen Core">finalStateTable: arg 	finalStateTable := arg</body><body package="T-Gen Core">noTransitionSignal	^NoTransitionSignal</body><body package="T-Gen Core">noTransitionSignal: arg 	NoTransitionSignal := arg</body><body package="T-Gen Core">tokenTable	^tokenTable</body><body package="T-Gen Core">tokenTable: arg 	tokenTable := arg</body></methods><methods><class-id>Tgen.OptimizedScanner class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"OptimizedScanner initialize"	self noTransitionSignal: (Signal new nameClass: self message: #noTransitionSymbol).</body></methods><methods><class-id>Tgen.OptimizedScanner class</class-id> <category>reconstructing</category><body package="T-Gen Core">constructFinalStateTable: arg 	finalStateTable := Array new: arg size.	1 to: arg size do: [:index | finalStateTable at: index put: ((arg at: index) isNil				ifTrue: [nil]				ifFalse: [Array with: ((arg at: index)							at: 1)						with: (self constructTokenClassification: ((arg at: index)									at: 2))])]</body><body package="T-Gen Core">constructTokenClassification: aCollection 	| tc ea arr |	aCollection size == 1		ifTrue: 			[tc := aCollection first.			^Array with: (TokenClassification					tokenType: (tc at: 1)					action: (tc at: 2))]		ifFalse: 			[arr := Array new: aCollection size.			1 to: aCollection size do: 				[:index | 				ea := aCollection at: index.				arr at: index put: (TokenClassification						tokenType: (ea at: 1)						action: (ea at: 2))].			^arr]</body></methods><methods><class-id>Tgen.OptimizedScanner class</class-id> <category>instance creation</category><body package="T-Gen Core">buildFrom: fsaScanner	^self new convertToTable: fsaScanner</body></methods><methods><class-id>Tgen.ShiftingConflictStrategy</class-id> <category>resolving</category><body package="T-Gen Core">resolveReduceReduceFor: aTerm atState: currState 	^OrderedCollection with: currState</body><body package="T-Gen Core">resolveShiftReduceFor: aTransitSymbol atState: currState 	currState reduceMap removeKey: aTransitSymbol.	^OrderedCollection new.</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>state accessing</category><body package="T-Gen Core">leftHandSide	^leftHandSide</body><body package="T-Gen Core">leftHandSide: argument 	leftHandSide := argument</body><body package="T-Gen Core">postDotSymbols	^postDotSymbols</body><body package="T-Gen Core">postDotSymbols: argument 	postDotSymbols := argument</body><body package="T-Gen Core">preDotSymbols	^preDotSymbols</body><body package="T-Gen Core">preDotSymbols: argument 	preDotSymbols := argument</body><body package="T-Gen Core">translationSymbol	^translationSymbol</body><body package="T-Gen Core">translationSymbol: argument 	translationSymbol := argument</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>copying</category><body package="T-Gen Core">postCopy	super postCopy.	self preDotSymbols: self preDotSymbols copy.	self postDotSymbols: self postDotSymbols copy.	^self</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>private</category><body package="T-Gen Core">makeGrammarProductionWithLeftHandSide: lhs rightHandSide: rhs 	^self translationSymbol isNil		ifTrue: [GrammarProduction leftHandSide: lhs rightHandSide: rhs]		ifFalse: [TransductionGrammarProduction				leftHandSide: lhs				rightHandSide: rhs				translationSymbol: self translationSymbol]</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>conversion</category><body package="T-Gen Core">asGrammarProduction	| rhs |	rhs := OrderedCollection new.	rhs addAll: self preDotSymbols.	rhs addAll: self postDotSymbols.	^self makeGrammarProductionWithLeftHandSide: self leftHandSide rightHandSide: rhs</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>accessing</category><body package="T-Gen Core">augmentedGrammarStartSymbol	^self class augmentedGrammarStartSymbol</body><body package="T-Gen Core">endOfInputSymbol	^self class endOfInputSymbol</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self leftHandSide printOn: aStream.	aStream nextPutAll: ' -&gt; '.	self preDotSymbols do: 		[:sym | 		sym printOn: aStream.		aStream space].	aStream nextPutAll: '. '.	self postDotSymbols do: 		[:sym | 		sym printOn: aStream.		aStream space]</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>operations</category><body package="T-Gen Core">nextSymbol	"Answer the symbol immediately to the right of the dot and nil if none."	^self postDotSymbols isEmpty		ifTrue: [nil]		ifFalse: [self postDotSymbols first]</body><body package="T-Gen Core">shift	"Conceptually move the dot past the next symbol."	self atEnd ifFalse: [self preDotSymbols addLast: self postDotSymbols removeFirst]</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>testing</category><body package="T-Gen Core">atEnd	^self postDotSymbols isEmpty</body><body package="T-Gen Core">isFinalStateItem	"A final state item is of the form '@@ -&gt; S &lt;endOfInput&gt; . '."	^self atEnd and: [self leftHandSide = self augmentedGrammarStartSymbol]</body><body package="T-Gen Core">isLR0Item	^true</body></methods><methods><class-id>Tgen.LR0Item</class-id> <category>comparing</category><body package="T-Gen Core">= anItem 	^anItem isLR0Item		ifTrue: [self leftHandSide = anItem leftHandSide and: [self preDotSymbols = anItem preDotSymbols and: [self postDotSymbols = anItem postDotSymbols]]]		ifFalse: [false]</body><body package="T-Gen Core">hash	"This is redefined because = is redefined."	^self leftHandSide hash bitXor: (self preDotSymbols hash bitXor: self postDotSymbols hash)</body></methods><methods><class-id>Tgen.LR0Item class</class-id> <category>constants</category><body package="T-Gen Core">augmentedGrammarStartSymbol	^#@@</body><body package="T-Gen Core">endOfInputSymbol	^Character endOfInput</body></methods><methods><class-id>Tgen.LR0Item class</class-id> <category>instance creation</category><body package="T-Gen Core">initialItemForGrammar: grammar 	"After conceptually augment the grammar with the production 	'@@ -&gt; S &lt;endOfInput&gt;', answer the initial item for construction 	of the LR CFSM."	^self		leftHandSide: self augmentedGrammarStartSymbol		preDotSymbols: OrderedCollection new		postDotSymbols: (OrderedCollection with: grammar startSymbol with: self endOfInputSymbol)</body><body package="T-Gen Core">leftHandSide: arg1 preDotSymbols: arg2 postDotSymbols: arg3 	| newMe |	newMe := self new.	newMe leftHandSide: arg1.	newMe preDotSymbols: arg2.	newMe postDotSymbols: arg3.	^newMe</body><body package="T-Gen Core">leftHandSide: arg1 preDotSymbols: arg2 postDotSymbols: arg3 translationSymbol: arg4 	| newMe |	newMe := self new.	newMe leftHandSide: arg1.	newMe preDotSymbols: arg2.	newMe postDotSymbols: arg3.	newMe translationSymbol: arg4.	^newMe</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>state accessing</category><body package="T-Gen Core">leftHandSide	^leftHandSide</body><body package="T-Gen Core">leftHandSide: argument 	leftHandSide := argument</body><body package="T-Gen Core">rightHandSide	^rightHandSide</body><body package="T-Gen Core">rightHandSide: argument 	rightHandSide := argument</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>copying</category><body package="T-Gen Core">postCopy	super postCopy.	self rightHandSide: self rightHandSide copy.	^self</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>parse tree building</category><body package="T-Gen Core">computeResultNodeFor: builder withArgNodes: nodes 	"Productions without translation symbols can only pass on a single argument 	node."	nodes size = 1 ifFalse: [self error: 'Productions without translation symbols can onlypass on results from a single right-hand side nonterminal'].	^builder answerArgument: nodes first</body><body package="T-Gen Core">computeResultNodeFor: builder withTokenClassValue: value 	"See this method in class TransductionGrammarProduction."	self error: 'No translation has been specified that wouldcreate a place to store the token class value.'</body><body package="T-Gen Core">numberOfRhsNonterminals	"Answer the number of nonterminals in my right-hand side."	^self rightHandSide inject: 0 into: [:count :sym | sym isNonterminal			ifTrue: [count + 1]			ifFalse: [count]]</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>testing</category><body package="T-Gen Core">hasSingleTokenClassRhs	"Answer true if my right hand side consists solely of 	a single token class terminal symbol and false otherwise."	^self rightHandSide size = 1 and: [self rightHandSide first isTokenClassTerminal]</body><body package="T-Gen Core">hasSingleTokenRhs	"Answer true if my right hand side consists solely of 	a single token terminal symbol, including keywords defined	in the parser, and false otherwise.	Note that terminal symbols are represented as String and	nonterminal symbols are represented as Symbol."	^self rightHandSide size = 1 and: [self rightHandSide first isTerminal]</body><body package="T-Gen Core">hasTranslation	"See class TransductionGrammarProduction."	^false</body><body package="T-Gen Core">isEpsilonProduction	"Answer true if I am a production of the form S -&gt; &lt;epsilon&gt; (i.e. if my right hand 	side is empty) and false otherwise."	^self rightHandSide isEmpty</body><body package="T-Gen Core">isGrammarProduction	^true</body><body package="T-Gen Core">rightHandSideComprisedOf: aSet 	"Answer true if all symbols in my right-hand side 	are included in aSet and false otherwise."	self rightHandSide detect: [:sym | (aSet includes: sym) not]		ifNone: [^true].	^false</body><body package="T-Gen Core">rightHandSideHasAllNontermsIn: aSet 	"Answer true if all nonterminals in my right-hand side 	are included in aSet and false otherwise."	self rightHandSide detect: [:sym | sym isNonterminal and: [(aSet includes: sym) not]]		ifNone: [^true].	^false</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self printSymbol: self leftHandSide on: aStream.	aStream		 tab;		 nextPut: $:;		 space.	self rightHandSide do: 		[:sym | 		self printSymbol: sym on: aStream.		aStream space]</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>private</category><body package="T-Gen Core">lr0ItemClass	^LR0Item</body><body package="T-Gen Core">lr1ItemClass	^LR1Item</body><body package="T-Gen Core">lrParserStateClass	^LRParserState</body><body package="T-Gen Core">printSymbol: sym on: aStream 	"Render the given grammar symbol (terminal or nonterminal) on aStream. 	This is provided so that grammars are printed in T-gen specification form.	Nonterminals and token class terminals are printed without #s or 's and	terminals are printed as strings."	(sym isNonterminal or: [sym isTokenClassTerminal])		ifTrue: [sym do: [:ch | aStream nextPut: ch]]		ifFalse: [sym printOn: aStream]</body><body package="T-Gen Core">symbolSuffixSeparatorChar	^self lrParserStateClass symbolSuffixSeparatorChar</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>conversion</category><body package="T-Gen Core">asInitialLR0Item	^self lr0ItemClass		leftHandSide: self leftHandSide		preDotSymbols: OrderedCollection new		postDotSymbols: self rightHandSide copy</body><body package="T-Gen Core">asInitialLR1ItemWithLookahead: terminal 	^self lr1ItemClass		leftHandSide: self leftHandSide		preDotSymbols: OrderedCollection new		postDotSymbols: self rightHandSide copy		lookahead: terminal</body><body package="T-Gen Core">asNonLalrSuffixedProduction	"Assuming I am of the form 'A.&lt;stuff1&gt;* -&gt; B.&lt;stuff2&gt;* C.&lt;stuff3&gt;*', 	answer the prefix production 'A -&gt; B C'."	| separator lhs rhs |	separator := self symbolSuffixSeparatorChar.	lhs := self leftHandSide copyUpTo: separator.	rhs := self rightHandSide collect: [:sym | sym copyUpTo: separator].	^self species leftHandSide: lhs rightHandSide: rhs</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>first/follow sets</category><body package="T-Gen Core">computeFirstIn: grammar using: graph 	"Build dependency graph for first sets and initialize first sets. Starting at the left 	end of my right hand side, symbols are processed until a terminal or non-nullable 	nonterminal is encountered. Any terminal encountered is added to the first set 	associated with my left hand side node in the graph. Any nonterminal 	encountered means that I must include its first set in mine. This accomplished 	(indirectly) by adding an edge in the graph from the nonterminal's node to my lhs 	node. The actual first set unioning will be done after the graph is complete (see 	sender)."	self rightHandSide do: 		[:sym | 		sym isTerminal			ifTrue: 				[graph addTerminal: sym toNodeLabeled: self leftHandSide.				^self].		graph addEdgeFromNodeLabeled: sym toNodeLabeled: self leftHandSide.		(grammar isNullable: sym)			ifFalse: [^self]]</body><body package="T-Gen Core">computeFollowIn: grammar using: graph 	"Build dependency graph for follow sets and initialize follow sets. This method 	performs two distinct parts of the algorithm. First, each nonterminal in my right 	hand side is checked to what symbols can follow it. Those symbols are added to 	the follow set for the nonterminal's graph node. Second, starting at the right end 	of my right hand side, symbols are processed until a terminal or non-nullable 	nonterminal is encountered. Any nonterminal encountered means that my follow 	set should also be included in its follow set. This accomplished (indirectly) by 	adding an edge in the graph from my lhs node to the nonterminal's node. The 	actual follow set unioning will be done after the graph is complete (see sender)."	| n currSym more j nextSym |	n := self rightHandSide size.	1 to: n - 1 do: [:i | (currSym := self rightHandSide at: i) isNonterminal			ifTrue: 				[more := true.				j := i + 1.				[j &lt;= n &amp; more]					whileTrue: 						[nextSym := self rightHandSide at: j.						(grammar firstSetOf: nextSym)							do: [:sym | graph addTerminal: sym toNodeLabeled: currSym].						j := j + 1.						more := grammar isNullable: nextSym]]].	self rightHandSide		reverseDo: 			[:sym | 			sym isTerminal ifTrue: [^self].			graph addEdgeFromNodeLabeled: self leftHandSide toNodeLabeled: sym.			(grammar isNullable: sym)				ifFalse: [^self]]</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>comparing</category><body package="T-Gen Core">= aProd 	^aProd isGrammarProduction		ifTrue: [self leftHandSide = aProd leftHandSide and: [self rightHandSide = aProd rightHandSide]]		ifFalse: [false]</body><body package="T-Gen Core">hash	"This is redefined because = is redefined."	^self leftHandSide hash bitXor: self rightHandSide hash</body></methods><methods><class-id>Tgen.GrammarProduction</class-id> <category>reconstructing</category><body package="T-Gen Core">constructItsContentOn: aStream using: tokenTable 	"Emit lhs and #( rhs ) on aStream"	(tokenTable indexOf: self leftHandSide)		reconstructOn: aStream.	aStream		 space;		 poundSign;		 leftParenthesis.	self rightHandSide do: 		[:ea | 		(tokenTable indexOf: ea)			reconstructOn: aStream.		aStream space].	aStream rightParenthesis</body><body package="T-Gen Core">reconstructOn: aStream 	"Emit #( productions ) on aStream "	aStream poundSign; leftParenthesis.	(self symbolTable at: self leftHandSide)		reconstructOn: aStream.	aStream		 space;		 poundSign;		 leftParenthesis.	self rightHandSide do: 		[:ea | 		(self symbolTable at: ea)			reconstructOn: aStream.		aStream space].	aStream		 rightParenthesis;		 rightParenthesis;		 space</body><body package="T-Gen Core">reconstructOn: aStream using: tokenTable 	aStream poundSign; leftParenthesis.	self constructItsContentOn: aStream using: tokenTable.	aStream rightParenthesis; space</body></methods><methods><class-id>Tgen.GrammarProduction class</class-id> <category>instance creation</category><body package="T-Gen Core">leftHandSide: arg1 rightHandSide: arg2 	| newMe |	newMe := self new.	newMe leftHandSide: arg1.	newMe rightHandSide: arg2.	^newMe</body></methods><methods><class-id>Tgen.TransductionGrammarProduction</class-id> <category>state accessing</category><body package="T-Gen Core">translationSymbol	^translationSymbol</body><body package="T-Gen Core">translationSymbol: argument 	translationSymbol := argument</body></methods><methods><class-id>Tgen.TransductionGrammarProduction</class-id> <category>testing</category><body package="T-Gen Core">hasTranslation	^true</body></methods><methods><class-id>Tgen.TransductionGrammarProduction</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' {'.	self printSymbol: self translationSymbol asSymbol on: aStream.	aStream nextPutAll: '} '</body></methods><methods><class-id>Tgen.TransductionGrammarProduction</class-id> <category>conversion</category><body package="T-Gen Core">asInitialLR0Item	^self lr0ItemClass		leftHandSide: self leftHandSide		preDotSymbols: OrderedCollection new		postDotSymbols: self rightHandSide copy		translationSymbol: self translationSymbol</body><body package="T-Gen Core">asInitialLR1ItemWithLookahead: terminal 	^self lr1ItemClass		leftHandSide: self leftHandSide		preDotSymbols: OrderedCollection new		postDotSymbols: self rightHandSide copy		lookahead: terminal		translationSymbol: self translationSymbol</body><body package="T-Gen Core">asNonLalrSuffixedProduction	"Assuming I am of the form 'A.&lt;stuff1&gt;* -&gt; B.&lt;stuff2&gt;* C.&lt;stuff3&gt;*', 	answer the prefix production 'A -&gt; B C'."	| separator lhs rhs |	separator := self symbolSuffixSeparatorChar.	lhs := self leftHandSide copyUpTo: separator.	rhs := self rightHandSide collect: [:sym | sym copyUpTo: separator].	^self species		leftHandSide: lhs		rightHandSide: rhs		translationSymbol: self translationSymbol</body></methods><methods><class-id>Tgen.TransductionGrammarProduction</class-id> <category>private</category><body package="T-Gen Core">epsilonSymbol	^#nil</body><body package="T-Gen Core">leftLiftSymbol	^#liftLeftChild</body><body package="T-Gen Core">rightLiftSymbol	^#liftRightChild</body></methods><methods><class-id>Tgen.TransductionGrammarProduction</class-id> <category>parse tree building</category><body package="T-Gen Core">computeResultNodeFor: builder withArgNodes: nodes 	"Three kinds of translation symbols are currently supported: node names, special 	directives, and arbitrary message selectors. For a node name, a new instance of 	the specified node is created and given nodes, if any, as its children. The special 	directive 'nil' simply returns nil. The directive liftRightChild adds any nodes 	preceeding the right-most node as children to the right-most node, and returns 	the right-most node. The directive liftLeftChild works in an analogous fashion. 	Arbitrary message selectors must take the number of arguments in nodes and 	are invoked as a builder message, thus allowing users to define their own 	tree-building messages."	| symbol node |	symbol := self translationSymbol asSymbol.	symbol first isUppercase ifTrue: [^nodes isEmpty			ifTrue: [builder makeNewNode: symbol]			ifFalse: [builder makeNewNode: symbol withChildren: nodes]].	symbol = self epsilonSymbol ifTrue: [^builder answerNil].	symbol = self rightLiftSymbol		ifTrue: 			[nodes size &lt; 2 ifTrue: [self error: 'Only use liftRightChild when there are at least two right-hand-side nonterminals.'].			"special case for building lists ending with epsilon"			(nodes size = 2 and: [nodes last isNil])				ifTrue: [^builder answerArgument: nodes first].			node := nodes removeLast.			^builder addChildrenFirst: nodes to: node].	symbol = self leftLiftSymbol		ifTrue: 			[nodes size &lt; 2 ifTrue: [self error: 'Only use liftLeftChild when there are at least two right-hand-side nonterminals.'].			"special case for building lists beginning with epsilon"			(nodes size = 2 and: [nodes first isNil])				ifTrue: [^builder answerArgument: nodes last].			node := nodes removeFirst.			^builder addChildrenLast: nodes to: node].	symbol numArgs = nodes size ifFalse: [self error: 'Translation message selectors must have the same number of arguments as right-hand-side nonterminals.'].	nodes isEmpty ifTrue: [^builder perform: symbol].	"It may be more efficient to check the number of arguments and use 	perform:with:, etc., but probably not."	^builder perform: symbol withArguments: nodes asArray</body><body package="T-Gen Core">computeResultNodeFor: builder withTokenClassValue: value 	"I am assumed to be a production of the form 'A -&gt; &lt;tc&gt; =&gt; symbol'. 	The symbol can be either a node name or a one-argument message selector. 	If it is a node name then create a new instance of that node with the specified 	attribute value. If it is a message selector then invoke the corresponding 	operation on the builder with the specified value."	| symbol |	symbol := self translationSymbol asSymbol.	symbol first isUppercase		ifTrue: [^builder makeNewNode: symbol withAttribute: value]		ifFalse: [symbol numArgs = 1				ifTrue: [^builder perform: symbol with: value]				ifFalse: [self error: 'Expected either a node name or a one argumentmessage selector as a translation symbol.']]</body></methods><methods><class-id>Tgen.TransductionGrammarProduction</class-id> <category>reconstructing</category><body package="T-Gen Core">constructItsContentOn: aStream using: tokenTable 	"Emit  lhs , #( rhs ) and translationSymbol on aStream"	super constructItsContentOn: aStream using: tokenTable.	(tokenTable indexOf: self translationSymbol)		reconstructOn: aStream</body></methods><methods><class-id>Tgen.TransductionGrammarProduction class</class-id> <category>instance creation</category><body package="T-Gen Core">leftHandSide: arg1 rightHandSide: arg2 translationSymbol: arg3 	| newMe |	newMe := self new.	newMe leftHandSide: arg1.	newMe rightHandSide: arg2.	newMe translationSymbol: arg3.	^newMe</body></methods><methods><class-id>Tgen.TokenSpecRuleNode</class-id> <category>state accessing</category><body package="T-Gen Core">directive	^directive</body><body package="T-Gen Core">directive: argument 	directive := argument</body><body package="T-Gen Core">regExpr	^regExpr</body><body package="T-Gen Core">regExpr: argument 	regExpr := argument</body><body package="T-Gen Core">tokenClass	^tokenClass</body><body package="T-Gen Core">tokenClass: argument 	tokenClass := argument</body></methods><methods><class-id>Tgen.TokenSpecRuleNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	anOrderedCollection size = 3		ifTrue: 			[self tokenClass: anOrderedCollection removeFirst.			self regExpr: anOrderedCollection removeFirst.			self directive: anOrderedCollection removeFirst]		ifFalse: [self error: 'wrong number of children']</body></methods><methods><class-id>Tgen.TokenSpecRuleNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self tokenClass printOn: aStream.	aStream tab; nextPutAll: ': '.	self regExpr printOn: aStream.	aStream tab; tab.	self directive notNil 		ifTrue:			[self directive printOn: aStream.			aStream space].	aStream nextPut: $;</body></methods><methods><class-id>Tgen.TokenSpecRuleNode</class-id> <category>private</category><body package="T-Gen Core">specRuleClass	^TokenSpecificationRule</body></methods><methods><class-id>Tgen.TokenSpecRuleNode</class-id> <category>converting</category><body package="T-Gen Core">asSpecRule	"Answer the specification rule I represent."	^self specRuleClass		tokenClass: self tokenClass symbol		regExpr: self regExpr asPureRegExpr		directive: (self directive notNil				ifTrue: [self directive asMessageSelector]				ifFalse: [nil])</body></methods><methods><class-id>Tgen.TokenSpecRuleNode class</class-id> <category>instance creation</category><body package="T-Gen Core">tokenClass: arg1 regExpr: arg2 directive: arg3 	| newMe |	newMe := self new.	newMe tokenClass: arg1.	newMe regExpr: arg2.	newMe directive: arg3.	^newMe</body></methods><methods><class-id>Tgen.LR1Parser</class-id> <category>state accessing</category><body package="T-Gen Core">finalState	^finalState</body><body package="T-Gen Core">finalState: argument 	finalState := argument</body></methods><methods><class-id>Tgen.LR1Parser</class-id> <category>parsing</category><body package="T-Gen Core">acceptSymbol	^self lrParserStateClass acceptSymbol</body><body package="T-Gen Core">actionAt: currState 	^currState actionFor: self nextToken</body><body package="T-Gen Core">at: state transitionFor: symbol 	^state transitionFor: symbol</body><body package="T-Gen Core">lrParserStateClass	^LRParserState</body><body package="T-Gen Core">parse	| stack action currState |	stack := OrderedCollection new.	currState := self startState.	stack addFirst: currState.		[currState = self finalState		or: [(action := self actionAt: currState) = self acceptSymbol]]			whileFalse: 				[currState := action isGrammarProduction							ifTrue: 								["reduce"								stack removeFirst: action rightHandSide size.								self at: stack first transitionFor: action leftHandSide]							ifFalse: 								["shift"								self scanToken.								action].				stack addFirst: currState]</body><body package="T-Gen Core">parseWithTreeBuilder: parseTreeBuilder 	| stack currState action |	stack := OrderedCollection new.	stack setIndicesFrom: stack basicSize.	currState := self startState.	stack addFirst: currState.		[currState = self finalState		or: [(action := self actionAt: currState) = self acceptSymbol]]			whileFalse: 				[currState := action isGrammarProduction							ifTrue: 								["reduce"								stack removeFirst: action rightHandSide size.								parseTreeBuilder processProduction: action forParser: self.								self at: stack first transitionFor: action leftHandSide]							ifFalse: 								["shift"								self scanToken.								action].				stack addFirst: currState].	^parseTreeBuilder result</body><body package="T-Gen Core">startState	^self parseTable</body><body package="T-Gen Core">traceParse	| stack action currState nextState |	self cr;		cr;		showCR: 'LR Parser trace of:  ' , self scanner contents;		cr.	stack := OrderedCollection new.	currState := self startState.	stack addFirst: currState.		[currState = self finalState		or: [(action := self actionAt: currState) = self acceptSymbol]]			whileFalse: 				[currState := action isGrammarProduction							ifTrue: 								["reduce"								stack removeFirst: action rightHandSide size.								nextState := self at: stack first transitionFor: action leftHandSide.								self showCR: 'reduce by ' , action printString , ' then goto state '											, nextState hash printString.								nextState]							ifFalse: 								["shift"								self showCR: 'shift on ''' , self nextToken asString , ''' to state '											, action hash printString.								self scanToken.								action].				stack addFirst: currState]</body></methods><methods><class-id>Tgen.LR1Parser</class-id> <category>lalr analysis</category><body package="T-Gen Core">lalr1AnalyzeConflicts: stateSet originalGrammar: aGrammar 	^self parseTable lalr1AnalyzeConflicts: stateSet originalGrammar: aGrammar</body></methods><methods><class-id>Tgen.LR1Parser</class-id> <category>private</category><body package="T-Gen Core">myFinalState	^self class finalState</body><body package="T-Gen Core">parserErrorSignal	^LRParserState noTransitionSignal</body></methods><methods><class-id>Tgen.LR1Parser</class-id> <category>testing</category><body package="T-Gen Core">performsRightmostDerivation	^true</body></methods><methods><class-id>Tgen.LR1Parser</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self finalState: self myFinalState</body></methods><methods><class-id>Tgen.LR1Parser</class-id> <category>converting</category><body package="T-Gen Core">fastParser	^OptimizedLR1Parser buildFrom: self</body></methods><methods><class-id>Tgen.LR1Parser class</class-id> <category>instance creation</category><body package="T-Gen Core">parseTable: table finalState: state 	| newParser |	newParser := self new.	newParser parseTable: table.	newParser finalState: state.	^newParser</body></methods><methods><class-id>Tgen.LR1Parser class</class-id> <category>state accessing</category><body package="T-Gen Core">finalState	^finalState</body><body package="T-Gen Core">finalState: argument 	finalState := argument</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>state accessing</category><body package="T-Gen Core">tokenTypeTable	^tokenTypeTable</body><body package="T-Gen Core">tokenTypeTable: arg 	tokenTypeTable := arg</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>reconstructing</category><body package="T-Gen Core">mapProductionToInteger	"Answer an Array of all grammar symbols - nonterminals, terminals, 	and translation symbols."	| transSyms |	transSyms := Set new.	parseTable do: [:row | row do: [:ea | ea isGrammarProduction ifTrue: [ea hasTranslation ifTrue: [transSyms add: ea translationSymbol]]]].	^self tokenTypeTable , transSyms asOrderedCollection asArray</body><body package="T-Gen Core">reconstructOn: aStream 	"Recreate a parse table and a token type table"	| prodTable |	prodTable := self mapProductionToInteger.	aStream nextPutAll: 'prodTable := '.	prodTable reconstructOn: aStream.	aStream		period;		crtab;		nextPutAll: 'self tokenTypeTable:  (prodTable copyFrom: 1 to:  ';		nextPutAll: tokenTypeTable size printString;		nextPutAll: ').';		crtab;		nextPutAll: 'table := '.	self parseTable reconstructOn: aStream using: prodTable.	aStream		period;		crtab;		nextPutAll: 'self constructParseTable: table  with: prodTable.';		crtab;		nextPutAll: 'self finalState: '.	self finalState printOn: aStream</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>private</category><body package="T-Gen Core">parseError	self raiseNoTransitionExceptionErrorString: (scanner tokenType == self endOfInputToken			ifTrue: [self endOfInputErrorString]			ifFalse: [self standardErrorString , '''' , scanner tokenType printString , ''''])</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>exception handling</category><body package="T-Gen Core">endOfInputErrorString	^'end of input encountered'</body><body package="T-Gen Core">parserErrorSignal	^self class noTransitionSignal</body><body package="T-Gen Core">raiseNoTransitionExceptionErrorString: aString 	self parserErrorSignal raiseErrorString: aString</body><body package="T-Gen Core">scannerErrorSignal	^OptimizedScanner noTransitionSignal</body><body package="T-Gen Core">standardErrorString	^'unexpected token encountered:  '</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>converting</category><body package="T-Gen Core">assignNextIDAfter: id toSuccessorOf: state 	| nextID nextState |	nextID := id + 1.	state edgeLabelMap		associationsDo: 			[:assoc | 			tokenTypeTable add: assoc key.			nextState := assoc value.			nextState stateID isNil				ifTrue: 					[nextState stateID: nextID.					nextID := self assignNextIDAfter: nextID toSuccessorOf: nextState]].	state reduceMap associationsDo: [:assoc | tokenTypeTable add: assoc key].	^nextID</body><body package="T-Gen Core">changeToObjectTable: lrParserState 	| sizePlusOne objectTable |	lrParserState stateID notNil ifTrue: [lrParserState nilOutStateIDs].	lrParserState stateID: self startState.	self tokenTypeTable: Set new.	sizePlusOne := self assignNextIDAfter: self startState toSuccessorOf: lrParserState.	self tokenTypeTable: tokenTypeTable asOrderedCollection asArray.	objectTable := Array new: sizePlusOne - 1.	^self convert: lrParserState to: objectTable</body><body package="T-Gen Core">convert: state to: objectTable 	"I try to create a table that maps state ( represented by integer ) to state or state to 	production"	| arr nextState |	arr := Array new: self tokenTypeTable size.	objectTable at: state stateID put: arr.	state edgeLabelMap		associationsDo: 			[:assoc | 			nextState := assoc value.			(objectTable at: nextState stateID) isNil ifTrue: [self convert: nextState to: objectTable].			arr at: (tokenTypeTable indexOf: assoc key)				put: nextState stateID].	state reduceMap associationsDo: [:assoc | arr at: (tokenTypeTable indexOf: assoc key)			put: assoc value first].	^objectTable</body><body package="T-Gen Core">convertToTable: lr1Parser 	self scanner: lr1Parser scanner fastScanner.	self parseTable: (self changeToObjectTable: lr1Parser parseTable).	self treeBuilder:  lr1Parser treeBuilder.	self finalState: lr1Parser finalState stateID</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>scanner/parser generation</category><body package="T-Gen Core">classInitializationMethodTextForClassNamed: name spec: grammarSpec | ws | ws := self newStreamForMethodRendering. ws  nextPutAll: 'initialize';  crtab;  nextPut: $";  nextPutAll: name;  nextPutAll: ' initialize"';  crtab;  nextPut: $". grammarSpec do:  [:ch |  "double embedded double-quote characters"  ws nextPut: ch.  ch = $" ifTrue: [ws nextPut: $"]]. ws  nextPut: $";  cr;  crtab;  nextPutAll: '| table prodTable |';  crtab. self reconstructOn: ws. ^ws contents</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>parsing</category><body package="T-Gen Core">actionAt: currState 	| action |	(action := (parseTable at: currState)				at: (tokenTypeTable indexOf: self nextToken)) isNil ifTrue: [(scanner finalStateTable includes: currState)			ifTrue: [^#accept]			ifFalse: [self parseError]].	^action</body><body package="T-Gen Core">at: currState transitionFor: symbol 	| value |	(value := (parseTable at: currState)				at: (tokenTypeTable indexOf: symbol)) isNil ifTrue: [self raiseNoTransitionExceptionErrorString: (symbol = self endOfInputToken				ifTrue: [self endOfInputErrorString]				ifFalse: [self standardErrorString , '''' , symbol printString , ''''])].	^value</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self tokenTypeTable: self myTokenTypeTable</body></methods><methods><class-id>Tgen.OptimizedLR1Parser</class-id> <category>accessing</category><body package="T-Gen Core">myTokenTypeTable	^self class tokenTypeTable</body><body package="T-Gen Core">startState	^1</body></methods><methods><class-id>Tgen.OptimizedLR1Parser class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"OptimizedLR1Parser initialize"	self noTransitionSignal: (Signal new nameClass: self message: #noTransitionSymbol)</body></methods><methods><class-id>Tgen.OptimizedLR1Parser class</class-id> <category>state accessing</category><body package="T-Gen Core">noTransitionSignal	^NoTransitionSignal</body><body package="T-Gen Core">noTransitionSignal: argument 	NoTransitionSignal := argument</body><body package="T-Gen Core">tokenTypeTable	^tokenTypeTable</body><body package="T-Gen Core">tokenTypeTable: prodTable 	tokenTypeTable := self convertFromStoredProductionTable: prodTable.</body></methods><methods><class-id>Tgen.OptimizedLR1Parser class</class-id> <category>reconstructing</category><body package="T-Gen Core">constructGrammarProduction: arg with: prodTable 	| rhs |	(arg at: 2) isEmpty		ifTrue: [rhs := OrderedCollection new]		ifFalse: 			[rhs := OrderedCollection new.			(arg at: 2)				do: [:ea | rhs addLast: (prodTable at: ea)]].	^GrammarProduction leftHandSide: (prodTable at: (arg at: 1))		rightHandSide: rhs</body><body package="T-Gen Core">constructParseTable: table with: prodTable 	| ea row newProdTable | 	newProdTable := self convertFromStoredProductionTable: prodTable.	parseTable := Array new: table size.	1 to: table size do: 		[:index | 		row := Array new: (table at: index) size.		parseTable at: index put: row.		1 to: (table at: index) size do: 			[:i | 			ea := (table at: index)						at: i.			ea isNil ifFalse: [ea isInteger					ifTrue: [row at: i put: ea]					ifFalse: [ea size == 2							ifTrue: [row at: i put: (self constructGrammarProduction: ea with: newProdTable)]							ifFalse: [row at: i put: (self constructTransductionGrammarProduction: ea with: newProdTable)]]]]]</body><body package="T-Gen Core">constructTransductionGrammarProduction: arg with: prodTable 	| rhs |	(arg at: 2) isEmpty		ifTrue: [rhs := OrderedCollection new]		ifFalse: 			[rhs := OrderedCollection new.			(arg at: 2)				do: [:ea | rhs addLast: (prodTable at: ea)]].	^TransductionGrammarProduction		leftHandSide: (prodTable at: (arg at: 1))		rightHandSide: rhs		translationSymbol: (prodTable at: (arg at: 3))</body></methods><methods><class-id>Tgen.OptimizedLR1Parser class</class-id> <category>instance creation</category><body package="T-Gen Core">buildFrom: fsaParser	^self new convertToTable: fsaParser</body></methods><methods><class-id>Tgen.ProductionNode</class-id> <category>state accessing</category><body package="T-Gen Core">leftHandSide	^leftHandSide</body><body package="T-Gen Core">leftHandSide: argument 	leftHandSide := argument</body><body package="T-Gen Core">rightHandSides	^rightHandSides</body><body package="T-Gen Core">rightHandSides: argument 	rightHandSides := argument</body></methods><methods><class-id>Tgen.ProductionNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	self leftHandSide: anOrderedCollection removeFirst.	self rightHandSides: anOrderedCollection removeFirst</body></methods><methods><class-id>Tgen.ProductionNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock 	"Evaluate aBlock for each of my children."	aBlock value: self leftHandSide.	self rightHandSides do: aBlock</body><body package="T-Gen Core">updateChildrenUsing: aBlock 	"Replace my children according to the value of aBlock."	self leftHandSide: (aBlock value: self leftHandSide).	self rightHandSides: (self rightHandSides collect: aBlock)</body></methods><methods><class-id>Tgen.ProductionNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self leftHandSide printOn: aStream.	aStream nextPutAll: ' : '.	self rightHandSides do: 		[:rhs | 		rhs printOn: aStream.		aStream			 cr;			 tab;			 nextPut: $|.		aStream cr]</body></methods><methods><class-id>Tgen.ProductionNode class</class-id> <category>instance creation</category><body package="T-Gen Core">leftHandSide: lhs rightHandSides: rhs	| newNode |	newNode := self new.	newNode leftHandSide: lhs.	newNode rightHandSides: rhs.	^newNode</body></methods><methods><class-id>Tgen.RRPGProductionNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self leftHandSide printOn: aStream.	aStream nextPutAll: ' : '.	self rightHandSides printOn: aStream.	aStream nextPutAll: ' ; '; cr</body></methods><methods><class-id>Tgen.RRPGProductionNode</class-id> <category>converting</category><body package="T-Gen Core">convertToCFGUsing: lhsNames 	"Remove all RRPG grammar operators from my rhs and answer a 	collection of CFG RRPGProductionNodes. This method recursively 	decomposes productions into more primitive forms until no more 	decomposition is possible (designated by an empty result from 	transformUsing:)"	| prods resultProds |	resultProds := OrderedCollection new.	(prods := self transformUsing: lhsNames) isEmpty		ifTrue: [resultProds add: self]		ifFalse: [prods do: [:p | resultProds addAll: (p convertToCFGUsing: lhsNames)]].	^resultProds</body></methods><methods><class-id>Tgen.RRPGProductionNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames 	"At this point there are two main cases to handle: a top-level 	AlternationNode or an RRPGRightHandSideNode. AlternationNodes 	are simply broken up into several RRPGProductionNodes. 	RRPGRightHandSideNodes are transformed, if necessary. Pass along 	my lhs so whole productions can be created by the rhs nodes."	^self rightHandSides transformUsing: lhsNames withLHS: self leftHandSide</body></methods><methods><class-id>Tgen.OptimizedLookaheadScanner</class-id> <category>accessing</category><body package="T-Gen Core">errorPosition	"Answer the source position of the last acceptable character."	^self savePosition max: 1</body></methods><methods><class-id>Tgen.OptimizedLookaheadScanner</class-id> <category>initialization</category><body package="T-Gen Core">reset	"Reset the initial state of the scanner before scanning a new source."	super reset.	self savePosition: 0</body></methods><methods><class-id>Tgen.OptimizedLookaheadScanner</class-id> <category>state accessing</category><body package="T-Gen Core">savePosition	^savePosition</body><body package="T-Gen Core">savePosition: argument 	savePosition := argument</body></methods><methods><class-id>Tgen.OptimizedLookaheadScanner</class-id> <category>testing</category><body package="T-Gen Core">isFSAFinalState: aState    "Answer true if aState is a final state, false otherwise."    ^(self finalStateTable at: aState) notNil</body></methods><methods><class-id>Tgen.OptimizedScannerWithTwoTokenLookahead</class-id> <category>scanning</category><body package="T-Gen Core">checkForTokenIn: newStateStack buffer: charBuffer 	"Scan the input using the arguments. Answer true if a legal token (or no illegal token) was 	found and false otherwise."	| nextState |	self atEnd ifFalse: 			[newStateStack addFirst: self startState.	"look for longest possible token"						[(nextState := (fsa at: newStateStack first) at: self nextChar asInteger) isNil]					whileFalse: 						[newStateStack addFirst: nextState.	"getNextChar for local vars"						charBuffer nextPut: self nextChar.						self nextChar: self source next].	"save the current position for error notification"			self savePosition: self position + (self atEnd ifTrue: [1] ifFalse: [0]).			(self isFSAFinalState: newStateStack first) ifFalse: 					["save the current position for error notification"					saveChar := self nextChar.					saveState := newStateStack first.	"backup to the previous final state or to the start state"					[newStateStack size = 1 or: [self isFSAFinalState: newStateStack first]]						whileFalse: 							[newStateStack removeFirst.	"putBackChar for local vars"							charBuffer backspace.							self backspaceSource].					newStateStack size = 1 ifTrue: 							["backed up to the start state"							self stateStack == newStateStack								ifTrue: 									["this is the first token, so signal an error (abort and return)"									self at: saveState transitionFor: saveChar]								ifFalse: 									["we may be able to backup in the previous token"									^false]]]].	^true</body><body package="T-Gen Core">scanToken	"Scan the next token and compute its token type."	| tok typeAction newStateStack charBuffer |	newStateStack := OrderedCollection new.	charBuffer := RetractableWriteStream on: (String new: 32).	(self checkForTokenIn: newStateStack buffer: charBuffer)		ifTrue: 			["either a legal token or the end on input was found"			self stateStack isEmpty ifTrue: 					[self atEnd						ifTrue: [^self signalEndOfInput]						ifFalse: [self error: 'no more vaild tokens']].			tok := self buffer contents.			typeAction := self at: stateStack first tokenTypeAndActionFor: tok.			self tokenType: typeAction type.			self token: tok.			self buffer: charBuffer.			self stateStack: newStateStack.			typeAction action notNil ifTrue: [self perform: typeAction action]]		ifFalse: 			["an illegal token was found, try to look for earlier final state in current token buffers"			charBuffer size timesRepeat: 					["put back illegal token chars"					self backspaceSource].	"backup in current token to next smallest legal token"						[self stateStack size = 1 or: 					[self stateStack removeFirst.					self putBackChar.					self isFSAFinalState: stateStack first]]					whileFalse.			self stateStack size = 1				ifTrue: 					["no smaller legal token so signal error"					self at: saveState transitionFor: saveChar]				ifFalse: 					["try again"					self scanToken]]</body></methods><methods><class-id>Tgen.OptimizedScannerWithTwoTokenLookahead</class-id> <category>initialization</category><body package="T-Gen Core">reset	"Reset the initial state of the scanner before scanning a new source."	super reset.	self stateStack: OrderedCollection new</body><body package="T-Gen Core">scanSource: aString 	"Convert the input string to a read stream and scan the first token."	self reset.	self source: (RetractableReadStream on: aString).	self nextChar: self source next.	self checkForTokenIn: self stateStack buffer: self buffer.	self scanToken</body></methods><methods><class-id>Tgen.OptimizedScannerWithTwoTokenLookahead</class-id> <category>state accessing</category><body package="T-Gen Core">saveChar	^saveChar</body><body package="T-Gen Core">saveChar: argument 	saveChar := argument</body><body package="T-Gen Core">saveState	^saveState</body><body package="T-Gen Core">saveState: argument 	saveState := argument</body><body package="T-Gen Core">stateStack	^stateStack</body><body package="T-Gen Core">stateStack: argument 	stateStack := argument</body></methods><methods><class-id>Tgen.OrderedPair</class-id> <category>initialization</category><body package="T-Gen Core">x: anObject y: anotherObject	"initializes an OrderedPair"	x := anObject.	y := anotherObject.</body></methods><methods><class-id>Tgen.OrderedPair</class-id> <category>accessing</category><body package="T-Gen Core">x	"answer the first element of the pair"	^x</body><body package="T-Gen Core">y	"answer the second element of the pair"	^y</body></methods><methods><class-id>Tgen.OrderedPair</class-id> <category>comparing</category><body package="T-Gen Core">= anOrderedPair	"answers whether two OrderedPairs are equal"	^self species = anOrderedPair species		and: [(x = anOrderedPair x) &amp; (y = anOrderedPair y)]</body><body package="T-Gen Core">hash	"answer the receiver's hash value"	^(x hash bitShift: -1) + (y hash bitShift: -2)</body></methods><methods><class-id>Tgen.OrderedPair</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver."	x printOn: aStream.	aStream nextPutAll: ' @ '.	y printString printOn: aStream.</body></methods><methods><class-id>Tgen.OrderedPair class</class-id> <category>instance creation</category><body package="T-Gen Core">x: anObject y: anotherObject	"Answer a new OrderedPair whose x element is anObject and whose y element is anotherObject."	^self new x: anObject y: anotherObject</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode</class-id> <category>accessing</category><body package="T-Gen Core">successors	^self edgeLabelMap elements</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode</class-id> <category>state accessing</category><body package="T-Gen Core">edgeLabelMap	^edgeLabelMap</body><body package="T-Gen Core">edgeLabelMap: argument 	edgeLabelMap := argument</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode</class-id> <category>initialization</category><body package="T-Gen Core">init	self edgeLabelMap: SetDictionary new</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode</class-id> <category>enumerating</category><body package="T-Gen Core">successorsDo: aBlock 	self successors do: aBlock</body><body package="T-Gen Core">successorsExceptSelfDo: aBlock 	(self successors reject: [:succ | succ = self])		do: aBlock</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode</class-id> <category>modifying</category><body package="T-Gen Core">addSuccessor: node withEdgeLabeled: label 	self edgeLabelMap at: label add: node</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self hash printOn: aStream.	aStream nextPutAll: ': '; crtab.	self edgeLabelMap		associationsDo: 			[:assoc | 			assoc key printOn: aStream.			aStream nextPutAll: ' ==&gt; '.			assoc value hash printOn: aStream.			aStream crtab]</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode</class-id> <category>converting</category><body package="T-Gen Core">spaceOptimizeMap	"Assumes self edgeLabelMap isDeterministic. 	Note: doing this will dissable the messages #successors, 	#addSuccessor:withEdgeLabeled:, and any senders of them, 	since they assume a SetDictionary."	self edgeLabelMap: self edgeLabelMap asDictionary</body></methods><methods><class-id>Tgen.EdgeLabeledDigraphNode class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>state accessing</category><body package="T-Gen Core">stateID	^stateID</body><body package="T-Gen Core">stateID: id 	stateID := id</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>testing</category><body package="T-Gen Core">hasStateID	^self stateID notNil</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>building</category><body package="T-Gen Core">goto: aState on: transitionSymbol 	self addSuccessor: aState withEdgeLabeled: transitionSymbol</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>private</category><body package="T-Gen Core">collectStatesIn: stateSet 	"Add myself and all states reachable from me to stateSet. 	If I'm the start state of an fsa then all my states are added."	(stateSet includes: self)		ifFalse: 			[stateSet add: self.			self successorsExceptSelfDo: [:succ | succ collectStatesIn: stateSet]]</body><body package="T-Gen Core">dfsaFinalStateClass	^FSAFinalState</body><body package="T-Gen Core">dfsaStateClass	^FSAState</body><body package="T-Gen Core">endOfInputToken	"Answer a token representing the end of the input."	^Character endOfInput</body><body package="T-Gen Core">epsilon	"Answer an object used to represent the empty string (epsilon)."	^EpsilonNode epsilon</body><body package="T-Gen Core">newDFSAStateFor: multiState 	"Answer a new dfsa state that will represent the argument, a collection of states. 	Make sure to transfer any final state information to the new state."	| newFinalState finalStates |	(finalStates := multiState select: [:state | state isFSAFinalState]) isEmpty		ifTrue: [^self dfsaStateClass new]		ifFalse: 			[newFinalState := self dfsaFinalStateClass new.			finalStates do: 				[:fs | 				fs literalTokens do: [:lit | newFinalState addLiteralToken: lit].				fs tokenClasses do: [:tc | newFinalState addTokenClass: tc]].			^newFinalState]</body><body package="T-Gen Core">nilOutStateIDs	"Set my stateID to nil, likewise with all my successors."	self stateID notNil		ifTrue:			[self stateID: nil.			self successorsDo: [:succ | succ nilOutStateIDs]]</body><body package="T-Gen Core">partitionTransitionMapClass	^PartitionTransitionMap</body><body package="T-Gen Core">stateSetClass	^ItemSet</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>removing nondeterminism</category><body package="T-Gen Core">asDeterministicFSA	"Answer a new deterministic version of myself. 		Based on Algorithm 3.1 from 'Principles of Compiler Design', 	by Aho and Ullman, 1977."	| multiStateMap unprocessedStates newStartState currState ch transitStates multiState epsilonClosures newMultiState newState |	epsilonClosures := self computeEpsilonClosures.	multiStateMap := Dictionary new.	unprocessedStates := Set new.	newStartState := self newDFSAStateFor: (epsilonClosures at: self).	multiStateMap at: (epsilonClosures at: self)		put: newStartState.	unprocessedStates add: newStartState.	[unprocessedStates isEmpty]		whileFalse: 			[currState := unprocessedStates removeFirst.			multiState := multiStateMap keyAtValue: currState.			(self computeTransitionMapFor: multiState)				associationsDo: 					[:assoc | 					ch := assoc key.					transitStates := assoc value.					newMultiState := self stateSetClass new.					transitStates do: [:ts | newMultiState addAll: (epsilonClosures at: ts)].					(multiStateMap includesKey: newMultiState)						ifTrue: 							["previously encountered state"							newState := multiStateMap at: newMultiState]						ifFalse: 							["make a new state"							newState := self newDFSAStateFor: newMultiState.							multiStateMap at: newMultiState put: newState.							unprocessedStates add: newState].					currState goto: newState on: ch]].	^newStartState spaceOptimize</body><body package="T-Gen Core">computeEpsilonClosureOf: stateSet 	"Answer the set of states that can be reached from those in stateSet by epsilon 	transitions alone."	(stateSet includes: self)		ifFalse: 			[stateSet add: self.			(self edgeLabelMap at: self epsilon ifAbsent: [^self])				do: [:state | state computeEpsilonClosureOf: stateSet]]</body><body package="T-Gen Core">computeEpsilonClosures	"Answer a Dictionary from states to their corresponding closures."	| closures |	closures := Dictionary new.	self states do: [:state | closures at: state put: state epsilonClosure].	^closures</body><body package="T-Gen Core">computeTransitionMapFor: multiState 	"Answer a transition map (minus any epsilon transitons) for multiState, 	a collection of states."	| newMap |	newMap := SetDictionary new.	multiState do: [:state | state copyTransitionsTo: newMap].	newMap removeKey: self epsilon ifAbsent: [].	^newMap</body><body package="T-Gen Core">epsilonClosure	"Answer the set of states that can be reached from me by epsilon transitions 	alone."	| states |	states := self stateSetClass new.	self computeEpsilonClosureOf: states.	^states</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>minimizing</category><body package="T-Gen Core">asMinimalDFSA	"Answer a new minimal deterministic version of myself. 	NOTE: the recipient of the DFSA should send the spaceOptimize 	message to the DFSA.		Based on Algorithm 3.3 from 'Principles of Compiler Design', 	by Aho and Ullman, 1977."	| dfsa states statePartitionMap oldPartition newPartition |	dfsa := self asDeterministicFSA.	states := dfsa states.	newPartition := self computeInitialPartitionFor: states.	oldPartition := Set new.	[newPartition size = oldPartition size]		whileFalse: 			[oldPartition := newPartition.			statePartitionMap := self computeStatePartitionMapFor: states using: oldPartition.			self computePartitionTransitionsFor: states using: statePartitionMap.			newPartition := self computeNewPartitionFor: oldPartition using: statePartitionMap].	^self		computeNewDFSAFor: oldPartition		using: statePartitionMap		startState: dfsa</body><body package="T-Gen Core">asNearMinimalDFSAWithUniqueTokenClasses	"Answer a new almost minimal deterministic version of myself. The result is not always 	minimal due to the extra constraint that final state partitions containing final states for two 	different token classes must be split. This allows the DFSA to properly handle overlapping 	token classes.  NOTE: the recipient of the DFSA should send the spaceOptimize 	message to the DFSA.		Based on Algorithm 3.3 from 'Principles of Compiler Design', 	by Aho and Ullman, 1977."	| dfsa states statePartitionMap oldPartition newPartition |	dfsa := self asDeterministicFSA.	states := dfsa states.	newPartition := self computeNearMinimalInitialPartitionFor: states.	oldPartition := Set new.	[newPartition size = oldPartition size]		whileFalse: 			[oldPartition := newPartition.			statePartitionMap := self computeStatePartitionMapFor: states using: oldPartition.			self computePartitionTransitionsFor: states using: statePartitionMap.			newPartition := self computeNewPartitionFor: oldPartition using: statePartitionMap].	^self		computeNewDFSAFor: oldPartition		using: statePartitionMap		startState: dfsa</body><body package="T-Gen Core">computeInitialPartitionFor: states 	"Partition states into final and nonfinal states."	| finalStates nonFinalStates |	finalStates := states select: [:state | state isFSAFinalState].	nonFinalStates := states reject: [:state | state isFSAFinalState].	^nonFinalStates isEmpty		ifTrue: [Set with: finalStates]		ifFalse: [Set with: nonFinalStates with: finalStates]</body><body package="T-Gen Core">computeNearMinimalInitialPartitionFor: states 	"Partition states into nonfinal, literal final, and common token class final state partitions."	| finalStates nonFinalStates partition tokenClasses literalTokens tc |	finalStates := states select: [:state | state isFSAFinalState].	nonFinalStates := states reject: [:state | state isFSAFinalState].	partition := nonFinalStates isEmpty				ifTrue: [Set new]				ifFalse: [Set with: nonFinalStates].	tokenClasses := SetDictionary new.	literalTokens := Set new.	finalStates do: 		[:finalState | 		(tc := finalState tokenClasses) size &gt; 1 ifTrue: [self error: 'multiple token class states are not currently supported'].		tc size = 0			ifTrue: [literalTokens add: finalState]			ifFalse: [tokenClasses at: tc first tokenType add: finalState]].	literalTokens isEmpty ifFalse: [partition add: literalTokens].	tokenClasses isEmpty ifFalse: [partition addAll: tokenClasses].	^partition</body><body package="T-Gen Core">computeNewDFSAFor: partition using: statePartitionMap startState: startState 	"Answer a new dfsa whose states represent partitions and whose transitions are 	computed from the statePartitionMap. The state for the partition containing 	startState is the new start state.  NOTE: the recipient of the DFSA should send	the spaceOptimize message to the DFSA."	| newStateMap partitionRepresentativeState newState ch st newStartState |	newStateMap := IdentityDictionary new.	partition do: [:part | newStateMap at: part put: (self newDFSAStateFor: part)].	partition do: 		[:part | 		partitionRepresentativeState := part first.		newState := newStateMap at: part.		(statePartitionMap at: partitionRepresentativeState) transitionMap			associationsDo: 				[:assoc | 				ch := assoc key.				st := newStateMap at: assoc value.				newState goto: st on: ch]].	newStartState := newStateMap at: (statePartitionMap at: startState) partition.	^newStartState</body><body package="T-Gen Core">computeNewPartitionFor: oldPartition using: statePartitionMap 	"Answer a new state partition that is a refinement of oldPartition based on 	partition transitions. An old partition is split into partitions of states with 	equivalent partition transition maps."	| newPartition partCopy initialState newPart |	newPartition := Set new.	oldPartition do: 		[:part | 		partCopy := part copy.		[partCopy isEmpty]			whileFalse: 				[initialState := partCopy removeFirst.				newPart := self stateSetClass with: initialState.				partCopy copy do: [:state | ((statePartitionMap at: initialState)						hasSameTransitionMapAs: (statePartitionMap at: state))						ifTrue: 							[partCopy remove: state.							newPart add: state]].				newPartition add: newPart]].	^newPartition</body><body package="T-Gen Core">computePartitionTransitionsFor: states using: statePartitionMap 	"For each state in states compute its partition-based transition map, 	i.e. a transition map from characters to partitions."	| char targetPartition |	states do: [:state | state edgeLabelMap			associationsDo: 				[:assoc | 				char := assoc key.				targetPartition := (statePartitionMap at: (state transitionFor: char)) partition.				(statePartitionMap at: state)					goto: targetPartition on: char]]</body><body package="T-Gen Core">computeStatePartitionMapFor: states using: partition 	"Answer a Dictionary mapping each state to an object containing its 	corresponding partition and a partition-based transition map for the state."	| statePartitionMap |	statePartitionMap := Dictionary new.	states do: [:state | statePartitionMap at: state put: (self partitionTransitionMapClass forPartition: (partition detect: [:par | par includes: state]))].	^statePartitionMap</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>exception handling</category><body package="T-Gen Core">endOfInputErrorString	^'end of input encountered'</body><body package="T-Gen Core">raiseNoTransitionExceptionErrorString: aString 	self class noTransitionSignal raiseErrorString: aString</body><body package="T-Gen Core">standardErrorString	^'illegal character encountered:  '</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>state transitions</category><body package="T-Gen Core">copyTransitionsTo: transitionMap 	self edgeLabelMap associationsDo: [:assoc | transitionMap at: assoc key addAll: assoc value]</body><body package="T-Gen Core">transitionFor: aSymbol 	^self transitionFor: aSymbol ifNone: [self raiseNoTransitionExceptionErrorString: (aSymbol = self endOfInputToken				ifTrue: [self endOfInputErrorString]				ifFalse: [self standardErrorString , '''' , aSymbol displayString , ''''])]</body><body package="T-Gen Core">transitionFor: aSymbol ifNone: aBlock 	^self edgeLabelMap at: aSymbol ifAbsent: [^aBlock value]</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>converting</category><body package="T-Gen Core">spaceOptimize	self states do: [:state | state spaceOptimizeMap]</body></methods><methods><class-id>Tgen.FSAState</class-id> <category>accessing</category><body package="T-Gen Core">states	"Answer the Set states reachable from here. 	If I am the start state this is all my states."	| states |	states := self stateSetClass new.	self collectStatesIn: states.	^states</body></methods><methods><class-id>Tgen.FSAState class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.FSAState class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"FSAState initialize"	self noTransitionSignal: (Signal new nameClass: self message: #noTransitionSymbol)</body></methods><methods><class-id>Tgen.FSAState class</class-id> <category>state accessing</category><body package="T-Gen Core">noTransitionSignal	^noTransitionSignal</body><body package="T-Gen Core">noTransitionSignal: argument 	noTransitionSignal := argument</body></methods><methods><class-id>Tgen.TokenSpecNode</class-id> <category>state accessing</category><body package="T-Gen Core">specRules	^specRules</body><body package="T-Gen Core">specRules: argument 	specRules := argument</body></methods><methods><class-id>Tgen.TokenSpecNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenFirst: anOrderedCollection 	self specRules addAllFirst: anOrderedCollection</body><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	self specRules addAll: anOrderedCollection</body></methods><methods><class-id>Tgen.TokenSpecNode</class-id> <category>initialization</category><body package="T-Gen Core">init	self specRules: OrderedCollection new</body></methods><methods><class-id>Tgen.TokenSpecNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self specRules do: 		[:rule | 		rule printOn: aStream.		aStream cr]</body></methods><methods><class-id>Tgen.TokenSpecNode</class-id> <category>converting</category><body package="T-Gen Core">asSpecRuleList	"Answer the collection of specification rules I represent."	| rules |	rules := OrderedCollection new.	self specRules do: [:rule | rules add: rule asSpecRule].	^rules</body></methods><methods><class-id>Tgen.TokenSpecNode class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.Graph class</class-id> <category>instance creation</category><body package="T-Gen Core">preferredNodeClass	^self subclassResponsibility</body><body package="T-Gen Core">withNodesLabeled: aCollection 	| newGraph |	aCollection size ~= aCollection asSet size ifTrue: [self notify: 'warning:  duplicate node names specifed for graph'].	newGraph := self new: aCollection size.	aCollection do: [:nodeName | newGraph add: (self preferredNodeClass label: nodeName)].	^newGraph</body></methods><methods><class-id>Tgen.DirectedGraph</class-id> <category>enumerating</category><body package="T-Gen Core">nodesDo: aBlock 	self do: aBlock</body></methods><methods><class-id>Tgen.DirectedGraph</class-id> <category>modifying</category><body package="T-Gen Core">addEdgeFrom: node1 to: node2 	node2 addPredecessor: node1</body></methods><methods><class-id>Tgen.LabeledDigraph</class-id> <category>modifying</category><body package="T-Gen Core">addEdgeFromNodeLabeled: label1 toNodeLabeled: label2 	| node1 node2 |	label1 ~= label2		ifTrue: 			["self edges are implicit and not represented"			node1 := self detect: [:node | node label = label1].			node2 := self detect: [:node | node label = label2].			self addEdgeFrom: node1 to: node2]</body></methods><methods><class-id>Tgen.LabeledDigraph class</class-id> <category>instance creation</category><body package="T-Gen Core">preferredNodeClass	^NodeLabeledDigraphNode</body></methods><methods><class-id>Tgen.FirstFollowGraph</class-id> <category>accessing</category><body package="T-Gen Core">nodeSetMap	"Answer a map from node names (nonterminals) to sets of terminals, representing 	either the first or follow sets."	| map |	map := SetDictionary new.	self nodesDo: [:node | map add: node asAssociation].	^map</body></methods><methods><class-id>Tgen.FirstFollowGraph</class-id> <category>modifying</category><body package="T-Gen Core">addTerminal: term toNodeLabeled: label 	(self detect: [:node | node label = label])		addTerminal: term</body></methods><methods><class-id>Tgen.FirstFollowGraph</class-id> <category>first/follow sets</category><body package="T-Gen Core">propagateSetUnions	"For each of my nodes, replace its node set with the union of its old node set 	and the node sets along all incoming edges. Repeat until no more changes."	| changes |	changes := true.	[changes]		whileTrue: [changes := self inject: false into: [:chngs :node | chngs | node unionWithPredecessorsChangesMe]]</body></methods><methods><class-id>Tgen.FirstFollowGraph class</class-id> <category>instance creation</category><body package="T-Gen Core">preferredNodeClass	^FirstFollowGraphNode</body></methods><methods><class-id>Tgen.EnnaryRegExprNode</class-id> <category>state accessing</category><body package="T-Gen Core">children	^children</body><body package="T-Gen Core">children: argument 	children := argument</body></methods><methods><class-id>Tgen.EnnaryRegExprNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock 	"Evaluate aBlock for each of my children."	self children do: aBlock</body><body package="T-Gen Core">updateChildrenUsing: aBlock 	"Replace my children according to the value of aBlock."	self children: (self children collect: aBlock)</body></methods><methods><class-id>Tgen.EnnaryRegExprNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenFirst: anOrderedCollection 	self children addAllFirst: anOrderedCollection</body><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	self children addAll: anOrderedCollection</body></methods><methods><class-id>Tgen.EnnaryRegExprNode</class-id> <category>initialization</category><body package="T-Gen Core">init	self children: OrderedCollection new</body></methods><methods><class-id>Tgen.EnnaryRegExprNode</class-id> <category>converting</category><body package="T-Gen Core">asPureRegExpr	"Answer a new version of the receiver consisting of only characters, 	concatenations, alternations, and (star) closures. Also, eliminate single 	child alternations and concatenations."	| newKids |	self children size = 1 ifTrue: [^self children first asPureRegExpr].	newKids := OrderedChildren new.	self childrenDo: [:child | newKids add: child asPureRegExpr].	^self species children: newKids</body></methods><methods><class-id>Tgen.EnnaryRegExprNode class</class-id> <category>instance creation</category><body package="T-Gen Core">children: arg1 	| newMe |	newMe := super new.	newMe children: arg1.	^newMe</body><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.ConcatenationNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self children do: 		[:child | 		child printOn: aStream.		child == self children last ifFalse: [aStream space]]</body></methods><methods><class-id>Tgen.ConcatenationNode</class-id> <category>converting</category><body package="T-Gen Core">asFSAStartingAt: startState endingAt: finalState 	| prevState newState |	prevState := startState.	self children do: [:child | child == self children last			ifTrue: [child asFSAStartingAt: prevState endingAt: finalState]			ifFalse: 				[newState := self fsaStateClass new.				child asFSAStartingAt: prevState endingAt: newState.				prevState := newState]]</body></methods><methods><class-id>Tgen.ConcatenationNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes 	"Transform productions of the form 'A -&gt; alpha (beta)op gamma'. 	Transform AlternationNodes at the last possible moment to minimize 	the number of new nonterminals created. Transform all consequitive 	operator nodes right to left to avoid unnecessary 'tail-splitting', which 	increases the grammar size."	| node |	node := self children reverseDetect: [:child | child needsTransforming]				ifNone: [self children reverseDetect: [:child | child isAlternationNode]						ifNone: [^OrderedCollection new]].	alphaNodes addAllLast: self children.	self children reverseDo: [:child | child == node			ifTrue: 				[alphaNodes removeLast.				^node					transformUsing: lhsNames					withLHS: lhsNode					alpha: alphaNodes					gamma: gammaNodes]			ifFalse: [gammaNodes addFirst: alphaNodes removeLast]].	self error: 'Control should never reach this point.'</body></methods><methods><class-id>Tgen.ConcatenationNode</class-id> <category>testing</category><body package="T-Gen Core">isConcatenationNode	^true</body></methods><methods><class-id>Tgen.ConcatenationNode</class-id> <category>collecting</category><body package="T-Gen Core">collectSymbol	^self children collect: [:sym | sym asGrammarSymbol]</body></methods><methods><class-id>Tgen.ConcatenationNode</class-id> <category>building parse trees</category><body package="T-Gen Core">concatenateWith: node	^node concatenateWithCatNode: self</body><body package="T-Gen Core">concatenateWithCatNode: node	node children addAllLast:  children.	^node</body><body package="T-Gen Core">concatenateWithNonCatNode: node	self children addFirst: node.	^self</body></methods><methods><class-id>Tgen.StarClosureNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPut: $(.	self onlyChild printOn: aStream.	aStream nextPutAll: ')*'</body></methods><methods><class-id>Tgen.StarClosureNode</class-id> <category>converting</category><body package="T-Gen Core">asFSAStartingAt: startState endingAt: finalState 	| middleState |	middleState := self fsaStateClass new.	startState goto: middleState on: self epsilon.	middleState goto: finalState on: self epsilon.	self onlyChild asFSAStartingAt: middleState endingAt: middleState</body><body package="T-Gen Core">asPureRegExpr	"Answer a new version of the receiver consisting of only characters, 	concatenations, alternations, and (star) closures."	^self starClosureNodeClass onlyChild: self onlyChild asPureRegExpr</body></methods><methods><class-id>Tgen.StarClosureNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes 	"Transform productions of the form 'A -&gt; alpha beta* gamma' 	into 'A -&gt; alpha B', 'B -&gt; beta B', and 'B -&gt; gamma'."	| newProds newLHS |	newProds := OrderedCollection new.	newLHS := self newNonterminalFrom: lhsNode excluding: lhsNames.	newProds add: (self createNewProductionWithLHS: lhsNode andRHS: (alphaNodes addLast: newLHS; yourself)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: (OrderedCollection					with: self onlyChild					with: newLHS)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: gammaNodes).	^newProds</body></methods><methods><class-id>Tgen.RRPGRightHandSideNode</class-id> <category>printing</category><body package="T-Gen Core">printSymbolsOn: aStream 	self symbols printOn: aStream</body></methods><methods><class-id>Tgen.RRPGRightHandSideNode</class-id> <category>converting</category><body package="T-Gen Core">convertSymbols	^self symbols collectSymbol</body></methods><methods><class-id>Tgen.RRPGRightHandSideNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode 	^self symbols		transformUsing: lhsNames		withLHS: lhsNode		alpha: OrderedCollection new		gamma: OrderedCollection new</body></methods><methods><class-id>Tgen.TokenSpecLeafNode</class-id> <category>state accessing</category><body package="T-Gen Core">symbol	^symbol</body><body package="T-Gen Core">symbol: argument 	symbol := argument</body></methods><methods><class-id>Tgen.TokenSpecLeafNode</class-id> <category>building parse trees</category><body package="T-Gen Core">setAttribute: value 	self symbol: value</body></methods><methods><class-id>Tgen.TokenSpecLeafNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPutAll: self symbol</body></methods><methods><class-id>Tgen.DirectiveNode</class-id> <category>converting</category><body package="T-Gen Core">asMessageSelector	"My symbol is a string of the form '{selector}'. 	Trim the braces and answer the selector symbol."	^(self symbol copyFrom: 2 to: self symbol size - 1) asSymbol</body></methods><methods><class-id>Tgen.GrammarLeafNode</class-id> <category>state accessing</category><body package="T-Gen Core">symbol	^symbol</body><body package="T-Gen Core">symbol: argument 	symbol := argument</body></methods><methods><class-id>Tgen.GrammarLeafNode</class-id> <category>building parse trees</category><body package="T-Gen Core">setAttribute: value 	self symbol: value</body></methods><methods><class-id>Tgen.GrammarLeafNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream	aStream nextPutAll: self symbol</body></methods><methods><class-id>Tgen.GrammarLeafNode</class-id> <category>transforming</category><body package="T-Gen Core">needsTransforming	^false</body><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes	"Productions of the form 'A -&gt; leaf' do not need transforming.	Signal this by answering an empty collection."	^OrderedCollection new</body></methods><methods><class-id>Tgen.GrammarLeafNode</class-id> <category>testing</category><body package="T-Gen Core">isAlternationNode	^false</body></methods><methods><class-id>Tgen.GrammarLeafNode class</class-id> <category>instance creation</category><body package="T-Gen Core">symbol: aSymbol	| newNode |	newNode := self new.	newNode symbol: aSymbol.	^newNode</body></methods><methods><class-id>Tgen.SetDictionary</class-id> <category>removing</category><body package="T-Gen Core">at: key remove: anObject 	^(self at: key)		remove: anObject</body><body package="T-Gen Core">at: key remove: anObject ifAbsent: aBlock 	^(self at: key)		remove: anObject ifAbsent: aBlock</body></methods><methods><class-id>Tgen.SetDictionary</class-id> <category>accessing</category><body package="T-Gen Core">at: key ifAbsent: absentBlock ifNotUnique: notUniqueBlock 	| elementSet |	elementSet := self at: key ifAbsent: [^absentBlock value].	^elementSet size &gt; 1		ifTrue: [notUniqueBlock value]		ifFalse: [elementSet first]</body><body package="T-Gen Core">at: key ifNotUnique: aBlock 	| elementSet |	elementSet := self at: key.	^elementSet size &gt; 1		ifTrue: [aBlock value]		ifFalse: [elementSet first]</body><body package="T-Gen Core">elements	| elements |	elements := Set new.	self do: [:set | elements addAll: set].	^elements</body></methods><methods><class-id>Tgen.SetDictionary</class-id> <category>adding</category><body package="T-Gen Core">at: key add: anObject 	(self at: key ifAbsent: [self at: key put: Set new])		add: anObject</body><body package="T-Gen Core">at: key addAll: aSet 	(self at: key ifAbsent: [self at: key put: Set new])		addAll: aSet</body></methods><methods><class-id>Tgen.SetDictionary</class-id> <category>testing</category><body package="T-Gen Core">isDeterministic	self associationsDo: [:assoc | assoc value size &gt; 1 ifTrue: [^false]].	^true</body></methods><methods><class-id>Tgen.SetDictionary</class-id> <category>converting</category><body package="T-Gen Core">asDictionary	| newDict |	self isDeterministic		ifTrue: 			[newDict := Dictionary new: self size.			self associationsDo: [:assoc | newDict at: assoc key put: assoc value first].			^newDict]		ifFalse: [self error: 'SetDictionary cannot be converted to a Dictionary']</body></methods><methods><class-id>Tgen.SetDictionary</class-id> <category>dictionary enumerating</category><body package="T-Gen Core">elementsDo: aBlock 	"Evaluate aBlock with each element of each of the receiver's set elements as the 	argument."	self elements do: [:element | aBlock value: element]</body></methods><methods><class-id>Tgen.AlternationNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPut: $(.	self children do: 		[:child | 		child printOn: aStream.		child == self children last ifFalse: [aStream nextPutAll: ' | ']].	aStream nextPut: $)</body></methods><methods><class-id>Tgen.AlternationNode</class-id> <category>converting</category><body package="T-Gen Core">asFSAStartingAt: startState endingAt: finalState 	self children do: [:child | child asFSAStartingAt: startState endingAt: finalState]</body></methods><methods><class-id>Tgen.AlternationNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode 	"I am a top-level node (e.g. A : B | C | D). Break-up the 	right-hand-side into separate productions and answer a collection 	of these productions."	| newProds |	newProds := OrderedCollection new.	self childrenDo: [:child | newProds add: (self productionNodeClass leftHandSide: lhsNode rightHandSides: child)].	^newProds</body><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes 	"Transform productions of the form 'A -&gt; alpha ( beta1 | beta2 ) gamma' 	into 'A -&gt; alpha beta1 gamma' and 'A -&gt; alpha beta2 gamma'."	| newProds |	newProds := OrderedCollection new.	self childrenDo: [:beta | newProds add: (self createNewProductionWithLHS: lhsNode andRHS: ((OrderedCollection new)					addAllLast: alphaNodes copy;					addLast: beta;					addAllLast: gammaNodes copy;					yourself))].	^newProds</body></methods><methods><class-id>Tgen.AlternationNode</class-id> <category>testing</category><body package="T-Gen Core">isAlternationNode	^true</body></methods><methods><class-id>Tgen.AlternationNode</class-id> <category>private</category><body package="T-Gen Core">processTransformation: lhs 	| newNode prods |	prods := OrderedCollection new.	children do: 		[:node | 		newNode := RRPGProductionNode new.		newNode leftHandSide: lhs.		newNode rightHandSides: (RRPGRightHandSideNode new symbols: node).		prods add: newNode].	^prods</body></methods><methods><class-id>Tgen.AlternationNode</class-id> <category>building parse trees</category><body package="T-Gen Core">alternateWith: node	^node alternateWithAltNode: self</body><body package="T-Gen Core">alternateWithAltNode: node	node children addAllLast:  children.	^node</body><body package="T-Gen Core">alternateWithNonAltNode: node	self children addFirst: node.	^self</body></methods><methods><class-id>Tgen.OrderedChildren</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenFirst: anOrderedCollection 	self addAllFirst: anOrderedCollection</body><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	self addAll: anOrderedCollection</body><body package="T-Gen Core">addChildrenLast: anOrderedCollection 	self addAllLast: anOrderedCollection</body><body package="T-Gen Core">setAttribute: value 	self shouldNotImplement</body></methods><methods><class-id>Tgen.AlternationRangeNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPut: $[.	self children do: [:child | child printOn: aStream].	aStream nextPut: $]</body></methods><methods><class-id>Tgen.AlternationRangeNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	anOrderedCollection size = 1		ifTrue: [self children: anOrderedCollection removeFirst]		ifFalse: [self error: 'wrong number of children']</body></methods><methods><class-id>Tgen.AlternationRangeNode</class-id> <category>converting</category><body package="T-Gen Core">asPureRegExpr	"Answer a new version of the receiver consisting of only characters, 	concatenations, alternations, and (star) closures. Also, eliminate single 	child alternations and concatenations."	| kids |	kids := OrderedChildren new.	self characters do: [:char | kids add: (self makeCharNodeFor: char)].	^self alternationNodeClass children: kids</body></methods><methods><class-id>Tgen.AlternationRangeNode</class-id> <category>accessing</category><body package="T-Gen Core">characters	"Answer the Set of Characters I represent."	| chars |	chars := Set new.	self childrenDo: [:child | child addCharsTo: chars].	^chars</body></methods><methods><class-id>Tgen.AlternationRangeNode</class-id> <category>private</category><body package="T-Gen Core">makeCharNodeFor: aChar 	"Answer a new CharacterNode for aChar."	^self characterNodeClass charSpec: (String with: aChar)</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>initialization</category><body package="T-Gen Core">computeNullableNonterminals	"Compute the set of nonterminals that can derive epsilon in one or more steps."	| nullables prevNullables |	nullables := ((self productions select: [:prod | prod rightHandSide isEmpty])				collect: [:prod | prod leftHandSide]) asSet.	prevNullables := Set new.	[nullables size ~= prevNullables size]		whileTrue: 			[prevNullables := nullables.			nullables := prevNullables union: ((self productions select: [:prod | prod rightHandSideComprisedOf: prevNullables])							collect: [:prod | prod leftHandSide]) asSet].	self nullableNonterminals: nullables</body><body package="T-Gen Core">init	self initSymbols.	self isReduced ifTrue: [self initFirstAndFollow]</body><body package="T-Gen Core">initFirstAndFollow	self computeNullableNonterminals.	self computeFirstSets.	self computeFollowSets</body><body package="T-Gen Core">initSymbols	| terms nonterms |	terms := Set new.	nonterms := Set new.	self productions do: 		[:prod | 		nonterms add: prod leftHandSide.		prod rightHandSide do: [:sym | sym isTerminal				ifTrue: [terms add: sym]				ifFalse: [nonterms add: sym]]].	self terminals: terms.	self nonterminals: nonterms</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>state accessing</category><body package="T-Gen Core">firstSets	^firstSets</body><body package="T-Gen Core">firstSets: argument 	firstSets := argument</body><body package="T-Gen Core">followSets	^followSets</body><body package="T-Gen Core">followSets: argument 	followSets := argument</body><body package="T-Gen Core">nonterminals	^nonterminals</body><body package="T-Gen Core">nonterminals: argument 	nonterminals := argument</body><body package="T-Gen Core">nullableNonterminals	^nullableNonterminals</body><body package="T-Gen Core">nullableNonterminals: argument 	nullableNonterminals := argument</body><body package="T-Gen Core">productions	^productions</body><body package="T-Gen Core">productions: argument 	productions := argument</body><body package="T-Gen Core">startSymbol	^startSymbol</body><body package="T-Gen Core">startSymbol: argument 	startSymbol := argument</body><body package="T-Gen Core">terminals	^terminals</body><body package="T-Gen Core">terminals: argument 	terminals := argument</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>copying</category><body package="T-Gen Core">copy	"Answer a copy of myself that can be manipulated without affecting me."	^self species buildGrammarWithProductions: self copyProductions</body><body package="T-Gen Core">copyProductions	"Answer a 'deep' copy of my productions that can be manipulated without affecting me."	^self productions collect: [:prod | prod copy]</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>first/follow sets</category><body package="T-Gen Core">computeFirstSets	| graph |	graph := self firstFollowGraph.	self productions do: [:prod | prod computeFirstIn: self using: graph].	graph propagateSetUnions.	self firstSets: graph nodeSetMap</body><body package="T-Gen Core">computeFollowSets	| graph |	graph := self firstFollowGraph.	self productions do: [:prod | prod computeFollowIn: self using: graph].	graph addTerminal: self epsilon toNodeLabeled: self startSymbol.		"used to denote end-of-input symbol"	graph propagateSetUnions.	self followSets: graph nodeSetMap</body><body package="T-Gen Core">firstFollowGraph	^self firstFollowGraphClass withNodesLabeled: self nonterminals</body><body package="T-Gen Core">firstOfSymbolString: symbolString 	"Answer the set of terminals that could appear at the beginning of the argument 	string at some stage of a derivation. This set will include epsilon only if the 	whole string could derive epsilon."	| first |	first := Set new.	symbolString do: 		[:sym | 		first := first union: (self firstSetOf: sym).		(self isNullable: sym)			ifFalse: [^first]].	first add: self epsilon.	^first</body><body package="T-Gen Core">firstSetOf: symbol 	^self firstSets at: symbol ifAbsent: 		["terminal"		Set with: symbol]</body><body package="T-Gen Core">followSetOf: symbol 	^self followSets at: symbol ifAbsent: 		["terminals don't have follow sets"		Set new]</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>grammar analysis</category><body package="T-Gen Core">generableNonterminals	"Answer a set of the generable nonterminals of this grammar."	| generable prodMap prods prod |	generable := Set with: self startSymbol.	prodMap := self computeProductionMap.	prods := OrderedCollection new.	prods addAll: (prodMap at: self startSymbol).	[prods isEmpty]		whileFalse: 			[prod := prods removeFirst.			prod rightHandSide do: [:sym | (sym isNonterminal and: [(generable includes: sym) not])					ifTrue: 						[generable add: sym.						prods addAll: (prodMap at: sym ifAbsent: [Set new])]]].	^generable</body><body package="T-Gen Core">terminableNonterminals	"Answer a set of the terminable nonterminals of this grammar."	| terminable again |	terminable := Set new.	again := true.	[again]		whileTrue: 			[again := false.			self productions do: [:prod | (terminable includes: prod leftHandSide)					ifFalse: [(prod rightHandSideHasAllNontermsIn: terminable)							ifTrue: 								[terminable add: prod leftHandSide.								again := true]]]].	^terminable</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>empty string</category><body package="T-Gen Core">emptyRHS	"Answer a right hand side that can be used in productions like A -&gt; &lt;epsilon&gt;."	^Array new: 0</body><body package="T-Gen Core">epsilon	"Answer an object used to represent the empty string (epsilon)."	^EpsilonNode epsilon</body><body package="T-Gen Core">isNullable: symbol 	^symbol isTerminal		ifTrue: [false]		ifFalse: [self nullableNonterminals includes: symbol]</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>exception handling</category><body package="T-Gen Core">raiseNotReducedExceptionErrorString: aString 	self class notReducedSignal raiseErrorString: aString</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>private</category><body package="T-Gen Core">firstFollowGraphClass	^FirstFollowGraph</body><body package="T-Gen Core">grammarProductionClass	^GrammarProduction</body><body package="T-Gen Core">makeProductionWithLeftHandSide: lhs rightHandSide: rhs 	^self grammarProductionClass leftHandSide: lhs rightHandSide: rhs</body><body package="T-Gen Core">productionPartitionClass	^ProductionPartition</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>testing</category><body package="T-Gen Core">isReduced	"Answer true if this grammar contains no non-generable nonterminals and	no non-terminable nonterminals.  Raise an exception and answer false otherwise."	| nongen nonterm errorString |	nongen := self nonterminals copy.	nongen removeAll: self generableNonterminals.	nonterm := self nonterminals copy.	nonterm removeAll: self terminableNonterminals.	^nongen isEmpty &amp; nonterm isEmpty		ifTrue: [true]		ifFalse:			[errorString := ('grammar is not reduced,\	non-generable nonterminals: ' , nongen printString , '\	non-terminable nonterminals: ' , nonterm printString , '.\') withCRs.			self raiseNotReducedExceptionErrorString: errorString.			false]</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self productions do: 		[:prod | 		prod printOn: aStream.		aStream nextPut: $;.		aStream cr]</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>parser generation</category><body package="T-Gen Core">computeProductionMap	"Answer a dictionary from nonterminals to sets of their corresponding 	productions."	| prodMap |	prodMap := SetDictionary new.	self productions do: [:prod | prodMap at: prod leftHandSide add: prod].	^prodMap</body><body package="T-Gen Core">literalTerminals	"Answer a collection of my non-token class terminals."	^self terminals reject: [:term | term isTokenClassTerminal]</body><body package="T-Gen Core">lr1LookaheadSetFor: lr1Item 	^self firstOfSymbolString: lr1Item lookaheadTail</body><body package="T-Gen Core">selectSets	"The select set of a production is the set of terminals that signal selection 	of that production in a top-down (LL(1)) parse of the input. Select sets 	are used in construction of the LL(1) parser table."	| select first |	select := Dictionary new.	self productions do: 		[:prod | 		first := self firstOfSymbolString: prod rightHandSide.		(first includes: self epsilon)			ifTrue: 				[first remove: self epsilon.				first addAll: (self followSetOf: prod leftHandSide)].		select at: prod put: first].	^select</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>manipulation support</category><body package="T-Gen Core">maxCommonPrefixFor: prodSet 	"Answer the maximum number of symbols the productions in prodSet share as a 	common prefix. This method assumes more than one element in prodSet, no 	dupilcate productions, and the first symbols are all the same."	| n more key target |	n := 2.	more := true.	key := prodSet first rightHandSide.	[more]		whileTrue: 			[n &lt;= key size				ifTrue: [prodSet do: 						[:prod | 						target := prod rightHandSide.						n &lt;= target size							ifTrue: [(key at: n)									= (target at: n) ifFalse: [more := false]]							ifFalse: [more := false]]]				ifFalse: [more := false].			n := n + 1].	^n - 2</body><body package="T-Gen Core">nonterminalDerivedFrom: aSymbol withSuffix: aString 	"Answer a new nonterminal built from the arguments and add it to my 	nonterminals."	| newNont |	newNont := (aSymbol , aString) asSymbol.	self nonterminals add: newNont.	^newNont</body><body package="T-Gen Core">partitionProdSetForLeftFactoring: prodSet 	^self productionPartitionClass partitionProdSetForLeftFactoring: prodSet</body><body package="T-Gen Core">partitionProdSetForLeftRecursion: prodSet 	^self productionPartitionClass partitionProdSetForLeftRecursion: prodSet</body><body package="T-Gen Core">replaceProductionsWith: prodMap 	"The argument maps each nonterminal to a set of corresponding productions."	| newProds |	newProds := OrderedCollection new.	prodMap do: [:prodSet | newProds addAll: prodSet].	self productions: newProds.	self initFirstAndFollow</body></methods><methods><class-id>Tgen.Grammar</class-id> <category>grammar manipulation</category><body package="T-Gen Core">factorCommonPrefixes	| prodMap aSet oldSet |	prodMap := self computeProductionMap.	aSet := Set new.	"On the first pass, process all production, collecting new nonterminals in aSet."	prodMap copy do: [:prodSet | self			leftFactor: prodSet			fromMap: prodMap			collectingNewNontsIn: aSet].	"Iterate over new nonterminals until no more factoring can be done."	[aSet isEmpty]		whileFalse: 			[oldSet := aSet.			aSet := Set new.			oldSet do: [:nt | self					leftFactor: (prodMap at: nt)					fromMap: prodMap					collectingNewNontsIn: aSet]].	self replaceProductionsWith: prodMap</body><body package="T-Gen Core">leftFactor: prodSet fromMap: prodMap collectingNewNontsIn: aSet 	| partition newProds nont suffix newNont n newBaseProd rhs reallyNewProds |	(partition := self partitionProdSetForLeftFactoring: prodSet) anyProblems		ifTrue: 			["The partition contains problem productions of the form 			A -&gt; &lt;prefix&gt; &lt;stuff1&gt; | &lt;prefix&gt; &lt;stuff2&gt; and other productions without 			the common &lt;prefix&gt;. To factor the common prefix, replace the problem 			productions with A -&gt; &lt;prefix&gt; An and An -&gt; &lt;stuff1&gt; | &lt;stuff2&gt;. Note, 			where a prefix has been factored from more than three productions it 			is possible that a new common prefix exists in the new productions. 			Thus, this process may need to be repeated (done by sender)."			newProds := partition otherProductions.			nont := partition leftHandSide.			suffix := 1.			partition problemProductions do: 				[:set | 				newNont := self nonterminalDerivedFrom: nont withSuffix: suffix printString.				aSet add: newNont.				suffix := suffix + 1.				n := self maxCommonPrefixFor: set.				newBaseProd := self makeProductionWithLeftHandSide: nont rightHandSide: (OrderedCollection with: newNont).				rhs := set first rightHandSide.				n					to: 1					by: -1					do: [:i | newBaseProd rightHandSide addFirst: (rhs at: i)].				newProds add: newBaseProd.				reallyNewProds := Set new.				set do: 					[:prod | 					prod leftHandSide: newNont.					prod rightHandSide removeFirst: n.					reallyNewProds add: prod].				prodMap at: newNont put: reallyNewProds].			prodMap at: nont put: newProds]</body><body package="T-Gen Core">makeLL1Transformations	self removeLeftRecursion.	self factorCommonPrefixes</body><body package="T-Gen Core">removeLeftRecursion	| prodMap partition nont newNont |	prodMap := self computeProductionMap.	prodMap copy do: [:prodSet | (partition := self partitionProdSetForLeftRecursion: prodSet) anyProblems			ifTrue: 				["The partition contains problem productions of the form 				A -&gt; A &lt;stuff1&gt; and other productions of the form A -&gt; &lt;stuff2&gt;. 				To remove the left recursion, change the other productions to 				the form A -&gt; &lt;stuff2&gt; A0 and the problem productions to the 				form A0 -&gt; &lt;stuff1&gt; A0 | &lt;epsilon&gt;."				nont := partition leftHandSide.				newNont := self nonterminalDerivedFrom: nont withSuffix: '0'.				prodMap at: nont put: (partition otherProductions						collect: 							[:prod | 							prod rightHandSide addLast: newNont.							prod]).				prodMap at: newNont put: (partition problemProductions						collect: 							[:prod | 							prod leftHandSide: newNont.							prod rightHandSide removeFirst.							prod rightHandSide addLast: newNont.							prod]).				(prodMap at: newNont)					add: (self makeProductionWithLeftHandSide: newNont rightHandSide: self emptyRHS)]].	self replaceProductionsWith: prodMap</body></methods><methods><class-id>Tgen.Grammar class</class-id> <category>state accessing</category><body package="T-Gen Core">notReducedSignal	^notReducedSignal</body><body package="T-Gen Core">notReducedSignal: argument	notReducedSignal := argument</body></methods><methods><class-id>Tgen.Grammar class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"Grammar initialize"	self notReducedSignal: (Signal new nameClass: self message: #notReducedSymbol)</body></methods><methods><class-id>Tgen.Grammar class</class-id> <category>instance creation</category><body package="T-Gen Core">buildGrammarFrom: anArray 	| newGrammar |	newGrammar := self new.	newGrammar productions: OrderedCollection new.	anArray do: [:prod | prod size = 3			ifTrue: [newGrammar productions add: (TransductionGrammarProduction						leftHandSide: (prod at: 1)						rightHandSide: (prod at: 2) asOrderedCollection						translationSymbol: (prod at: 3))]			ifFalse: [prod size = 2					ifTrue: [newGrammar productions add: (GrammarProduction leftHandSide: (prod at: 1)								rightHandSide: (prod at: 2) asOrderedCollection)]					ifFalse: [self error: 'wrong sized production array']]].	newGrammar startSymbol: ((anArray at: 1)			at: 1).	newGrammar init.	^newGrammar</body><body package="T-Gen Core">buildGrammarWithProductions: prods 	"Assume that the left-hand side of the first production is the start symbol."	^self buildGrammarWithProductions: prods startSymbol: prods first leftHandSide</body><body package="T-Gen Core">buildGrammarWithProductions: prods startSymbol: aSymbol 	| newGrammar |	newGrammar := self new.	newGrammar productions: prods.	newGrammar startSymbol: aSymbol.	newGrammar init.	^newGrammar</body></methods><methods><class-id>Tgen.DecimalCharNode</class-id> <category>accessing</category><body package="T-Gen Core">myChar	"Answer the Character represented by the receiver. 	The spec is of the form '\ddd'."	| spec |	spec := self charSpec.	(spec size = 4 and: [spec first = $\])		ifTrue: [^Character value: (spec copyFrom: 2 to: 4) asNumber]		ifFalse: [self error: 'Decimal character specifications must be of the form ''\ddd''.']</body></methods><methods><class-id>Tgen.BidirectionalEdgeLabeledDigraphNode</class-id> <category>state accessing</category><body package="T-Gen Core">predecessorLabelMap	^predecessorLabelMap</body><body package="T-Gen Core">predecessorLabelMap: argument 	predecessorLabelMap := argument</body></methods><methods><class-id>Tgen.BidirectionalEdgeLabeledDigraphNode</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self predecessorLabelMap: SetDictionary new</body></methods><methods><class-id>Tgen.BidirectionalEdgeLabeledDigraphNode</class-id> <category>modifying</category><body package="T-Gen Core">addPredecessor: node withEdgeLabeled: label 	self predecessorLabelMap at: label add: node</body></methods><methods><class-id>Tgen.BidirectionalEdgeLabeledDigraphNode</class-id> <category>accessing</category><body package="T-Gen Core">predecessors	^self predecessorLabelMap elements</body></methods><methods><class-id>Tgen.BidirectionalEdgeLabeledDigraphNode</class-id> <category>enumerating</category><body package="T-Gen Core">predecessorsDo: aBlock 	self predecessors do: aBlock</body><body package="T-Gen Core">predecessorsExceptSelfDo: aBlock 	(self predecessors reject: [:pred | pred = self])		do: aBlock</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self edgeLabelMap: Dictionary new.		"overrides use of SetDictionary in superclass"	self reduceMap: SetDictionary new</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>state accessing</category><body package="T-Gen Core">reduceMap	^reduceMap</body><body package="T-Gen Core">reduceMap: argument 	reduceMap := argument</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>exception handling</category><body package="T-Gen Core">standardErrorString	^'unexpected token encountered:  '</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	super printOn: aStream.	aStream cr.	self reduceMap printOn: aStream</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>lalr analysis</category><body package="T-Gen Core">appendHashTo: sym 	"Answer a new nonterminal or terminal with my hash value appended."	| newSym |	newSym := sym , self symbolSuffixSeparatorString , self hash printString.	^sym isNonterminal		ifTrue: [newSym asNonterminal]		ifFalse: [newSym]</body><body package="T-Gen Core">buildLalrGrammarWith: stateDict originalGrammar: aGrammar 	"Answer my corresponding LALR(1) grammar. The new productions will not be in any 	particular order so we must be sure to locate and explicitly specify the new start symbol."	| productions startSymbol pattern startSyms |	productions := OrderedCollection new.	self		collectLalrProductionsIn: productions		andProdMapsIn: stateDict		traversedStates: Set new.	pattern := aGrammar startSymbol , self symbolSuffixSeparatorString , '*'.	startSyms := Set new.	productions do: [:prod | (pattern match: prod leftHandSide) ifTrue: [startSyms add: prod leftHandSide]].	startSyms size = 1		ifTrue: [startSymbol := startSyms first]		ifFalse: [self error: 'multiple start symbols in LALR grammar'].	^self buildGrammarWithProductions: productions startSymbol: startSymbol</body><body package="T-Gen Core">collectLalrProductionsIn: aCollection andProdMapsIn: stateDict traversedStates: aSet 	| newProds |	(aSet includes: self)		ifFalse: 			[aSet add: self.			self isReduceState ifTrue: [self					reductionsDo: 						[:prod | 						newProds := self makeLalrProductionFor: prod.						(stateDict includesKey: self)							ifTrue: 								["only need to retain data for conflict states"								newProds do: [:np | (stateDict at: self)										at: prod add: np leftHandSide]].						aCollection addAll: newProds]].			self successorsExceptSelfDo: [:state | state					collectLalrProductionsIn: aCollection					andProdMapsIn: stateDict					traversedStates: aSet]]</body><body package="T-Gen Core">lalr1AnalyzeConflicts: stateSet originalGrammar: aGrammar 	| conflictStateMap newGrammar prodMap prod follows conflictStates |	conflictStates := Set new.	conflictStateMap := Dictionary new: stateSet size.	stateSet do: [:state | conflictStateMap at: state put: SetDictionary new].	newGrammar := self buildLalrGrammarWith: conflictStateMap originalGrammar: aGrammar.	"rebuild reduce maps for inconsistent states"	stateSet do: 		[:state | 		state reduceMap: SetDictionary new.		prodMap := conflictStateMap at: state.		prodMap			associationsDo: 				[:assoc | 				prod := assoc key.				follows := Set new.				assoc value do: [:nonterm | (newGrammar followSetOf: nonterm)						do: [:term | follows add: (term copyUpToLast: self symbolSuffixSeparatorChar)]].				follows do: [:term | state reduceBy: prod on: term]].		state hasReduceReduceConflict			ifTrue: 				[Transcript cr; show: 'reduce/reduce error: ' , state printString.				conflictStates add: state].		state hasShiftReduceConflict			ifTrue: 				[Transcript cr; show: 'shift/reduce error: ' , state printString.				conflictStates add: state]].	^conflictStates isEmpty</body><body package="T-Gen Core">makeLalrProductionFor: prod 	| stateSet rhs newProds lhs currState |	stateSet := Set with: self.	prod rightHandSide reverseDo: [:sym | stateSet := stateSet inject: Set new into: [:set :state | set union: (state predecessorLabelMap at: sym)]].	newProds := Set new.	stateSet do: 		[:state | 		lhs := state appendHashTo: prod leftHandSide.		currState := state.		rhs := OrderedCollection new.		prod rightHandSide do: 			[:sym | 			rhs add: (currState appendHashTo: sym).			currState := currState transitionFor: sym].		newProds add: (self makeProductionWithLeftHandSide: lhs rightHandSide: rhs)].	^newProds</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>building</category><body package="T-Gen Core">goto: aState on: transitionSymbol 	self addSuccessor: aState withEdgeLabeled: transitionSymbol.	aState addPredecessor: self withEdgeLabeled: transitionSymbol</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>state transitions</category><body package="T-Gen Core">actionFor: aTerminal 	| action |	(action := self reductionFor: aTerminal) isNil ifTrue: [(action := self transitionFor: aTerminal) isNil ifTrue: [action := self acceptSymbol]].	^action</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>modifying</category><body package="T-Gen Core">addSuccessor: node withEdgeLabeled: label 	"overridden for Dictionary edgeLabelMap"	(self edgeLabelMap includesKey: label)		ifTrue: [self error: 'check it out'].	self edgeLabelMap at: label put: node</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>accessing</category><body package="T-Gen Core">successors	"overriden for Dictionary edgeLabelMap"	^self edgeLabelMap values</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>private</category><body package="T-Gen Core">acceptSymbol	^self class acceptSymbol</body><body package="T-Gen Core">buildGrammarWithProductions: prods startSymbol: aSymbol 	^self grammarClass buildGrammarWithProductions: prods startSymbol: aSymbol</body><body package="T-Gen Core">grammarClass	^Grammar</body><body package="T-Gen Core">grammarProductionClass	^GrammarProduction</body><body package="T-Gen Core">makeProductionWithLeftHandSide: lhs rightHandSide: rhs 	^self grammarProductionClass leftHandSide: lhs rightHandSide: rhs</body><body package="T-Gen Core">symbolSuffixSeparatorChar	^self class symbolSuffixSeparatorChar</body><body package="T-Gen Core">symbolSuffixSeparatorString	^String with: self symbolSuffixSeparatorChar</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>accessing reductions</category><body package="T-Gen Core">reduceBy: aProduction on: aTerminal 	self reduceMap at: aTerminal add: aProduction</body><body package="T-Gen Core">reductionFor: aSymbol 	^self reduceMap		at: aSymbol		ifAbsent: [nil]		ifNotUnique: [self error: 'reduce/reduce conflict in parser']</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>testing</category><body package="T-Gen Core">hasReduceReduceConflict	"Answer true if there is a reduce/reduce conflict in this state, and false 	otherwise."	^self reduceMap isDeterministic not</body><body package="T-Gen Core">hasShiftReduceConflict	"Answer true if there is a shift/reduce conflict in this state, and false 	otherwise."	| reduceSyms shiftSyms |	reduceSyms := self reduceMap keys.	shiftSyms := self edgeLabelMap keys.	^reduceSyms size + shiftSyms size ~= (reduceSyms union: shiftSyms) size</body><body package="T-Gen Core">isReduceState	^self reduceMap isEmpty not</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>enumerating</category><body package="T-Gen Core">reductionsDo: aBlock 	"Evaluate aBlock for each of my reduce productions."	self reduceMap elementsDo: aBlock</body></methods><methods><class-id>Tgen.LRParserState</class-id> <category>converting</category><body package="T-Gen Core">spaceOptimizeMap	"Predecessors are only needed for LALR(1) analysis."	super spaceOptimizeMap.	self predecessorLabelMap: nil</body></methods><methods><class-id>Tgen.LRParserState class</class-id> <category>constants</category><body package="T-Gen Core">acceptSymbol	^#accept</body><body package="T-Gen Core">symbolSuffixSeparatorChar	^$.</body></methods><methods><class-id>Tgen.LRParserState class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"LRParserState initialize"	self noTransitionSignal: (Signal new nameClass: self message: #noTransitionSymbol)</body></methods><methods><class-id>Tgen.AbstractSyntaxTreeBuilder</class-id> <category>tree building</category><body package="T-Gen Core">makeNewNode: stringOrSymbol 	"The argument represents the name of a node class. If in sham mode answer a 	new derivation tree node for the argument, otherwise answer a new instance of 	that class."	^self shamMode		ifTrue: [DerivationTreeNode symbol: stringOrSymbol]		ifFalse: 			[| aClass |			aClass := stringOrSymbol asQualifiedReference valueOrDo: [nil].			aClass isNil ifTrue: [aClass := (Tgen asFullName: stringOrSymbol) asQualifiedReference valueOrDo: [^self error: 'no class named ' , stringOrSymbol]].			aClass isBehavior ifFalse: [self error: 'no class named ' , stringOrSymbol].			aClass new]</body></methods><methods><class-id>Tgen.AbstractSyntaxTreeBuilder</class-id> <category>accessing</category><body package="T-Gen Core">setNormalMode	self shamMode: false</body><body package="T-Gen Core">setShamMode	self shamMode: true</body></methods><methods><class-id>Tgen.AbstractSyntaxTreeBuilder</class-id> <category>state accessing</category><body package="T-Gen Core">shamMode	^shamMode</body><body package="T-Gen Core">shamMode: argument 	shamMode := argument</body></methods><methods><class-id>Tgen.AbstractSyntaxTreeBuilder</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self setNormalMode</body><body package="T-Gen Core">reset	"Empty the node stack and set to normal mode."	self init</body></methods><methods><class-id>Tgen.TokenSpecificationRule</class-id> <category>state accessing</category><body package="T-Gen Core">directive	^directive</body><body package="T-Gen Core">directive: argument 	directive := argument</body><body package="T-Gen Core">regExpr	^regExpr</body><body package="T-Gen Core">regExpr: argument 	regExpr := argument</body><body package="T-Gen Core">tokenClass	^tokenClass</body><body package="T-Gen Core">tokenClass: argument 	tokenClass := argument</body></methods><methods><class-id>Tgen.TokenSpecificationRule class</class-id> <category>instance creation</category><body package="T-Gen Core">tokenClass: arg1 regExpr: arg2 directive: arg3 	| newMe |	newMe := self new.	newMe tokenClass: arg1.	newMe regExpr: arg2.	newMe directive: arg3.	^newMe</body></methods><methods><class-id>Tgen.ListNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPut: $(.	self leftChild printOn: aStream.	aStream nextPutAll: ' ^ '.	self rightChild printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Tgen.ListNode</class-id> <category>transforming</category><body package="T-Gen Core">needsTransforming	^true</body><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes 	"Transform productions of the form 'A -&gt; alpha beta1 list beta2 gamma' 	into 'A -&gt; alpha B', 'B -&gt; beta1 gamma', and 'B -&gt; beta1 beta2 B'."	| newProds newLHS |	newProds := OrderedCollection new.	newLHS := self newNonterminalFrom: lhsNode excluding: lhsNames.	newProds add: (self createNewProductionWithLHS: lhsNode andRHS: (alphaNodes addLast: newLHS; yourself)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: (gammaNodes addFirst: self leftChild copy; yourself)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: (OrderedCollection					with: self leftChild copy					with: self rightChild copy					with: newLHS)).	^newProds</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>exception handling</category><body package="T-Gen Core">endOfInputErrorString	^'end of input encountered'</body><body package="T-Gen Core">parserErrorSignal	^self class noTransitionSignal</body><body package="T-Gen Core">raiseNoTransitionExceptionErrorString: aString 	self parserErrorSignal raiseErrorString: aString</body><body package="T-Gen Core">scannerErrorSignal	^OptimizedScanner noTransitionSignal</body><body package="T-Gen Core">standardErrorString	^'unexpected token encountered:  '</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>private</category><body package="T-Gen Core">parseError	self raiseNoTransitionExceptionErrorString: (scanner tokenType == self endOfInputToken			ifTrue: [self endOfInputErrorString]			ifFalse: [self standardErrorString , '''' , scanner tokenType printString , ''''])</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>accessing</category><body package="T-Gen Core">myNonterminals	^self class nonterminals</body><body package="T-Gen Core">myTerminals	^self class terminals</body><body package="T-Gen Core">myTokenTypeTable	^self class tokenTypeTable</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self nonterminals: self myNonterminals.	self terminals: self myTerminals</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>parsing</category><body package="T-Gen Core">productionAtNonterminal: nont andTerminal: term 	| nontIndex termIndex prod |	nontIndex := self nonterminals indexOf: nont.	termIndex := self terminals indexOf: term.	^(prod := (self parseTable at: nontIndex)				at: termIndex) isNil		ifTrue: [self raiseNoTransitionExceptionErrorString: (term = self endOfInputToken					ifTrue: [self endOfInputErrorString]					ifFalse: [self standardErrorString , '''' , term printString , ''''])]		ifFalse: [prod]</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>reconstructing</category><body package="T-Gen Core">mapProductionToInteger	"Answer an Array of all grammar symbols - nonterminals, terminals, 	and translation symbols."	| transSyms |	transSyms := Set new.	parseTable do: [:row | row do: [:ea | ea isGrammarProduction ifTrue: [ea hasTranslation ifTrue: [transSyms add: ea translationSymbol]]]].	^self nonterminals , self terminals , transSyms asOrderedCollection asArray</body><body package="T-Gen Core">reconstructOn: aStream 	| prodTable n |	prodTable := self mapProductionToInteger.	aStream nextPutAll: 'prodTable := '.	prodTable reconstructOn: aStream.	aStream		period;		crtab;		nextPutAll: 'self nonterminals:  (prodTable copyFrom: 1 to:  ';		nextPutAll: (n := self nonterminals size) printString;		nextPutAll: ').';		crtab;		nextPutAll: 'self terminals:  (prodTable copyFrom: ';		nextPutAll: (n + 1) printString;		nextPutAll: ' to: ';		nextPutAll: (self terminals size + n) printString;		nextPutAll: ').';		crtab;		nextPutAll: 'table := '.	self parseTable reconstructOn: aStream using: prodTable.	aStream		period;		crtab;		nextPutAll: 'self constructParseTable: table  with: prodTable.';		crtab;		nextPutAll: 'self startSymbol: '.	self startSymbol printOn: aStream</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>scanner/parser generation</category><body package="T-Gen Core">classInitializationMethodTextForClassNamed: name spec: grammarSpec | ws | ws := self newStreamForMethodRendering. ws  nextPutAll: 'initialize';  crtab;  nextPut: $";  nextPutAll: name;  nextPutAll: ' initialize"';  crtab;  nextPut: $". grammarSpec do:  [:ch |  "double embedded double-quote characters"  ws nextPut: ch.  ch = $" ifTrue: [ws nextPut: $"]]. ws  nextPut: $";  cr;  crtab;  nextPutAll: '| table prodTable |';  crtab. self reconstructOn: ws. ^ws contents</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>converting</category><body package="T-Gen Core">changeToObjectTable: llParseTable 	| terms objectTable |	self nonterminals: llParseTable keys asOrderedCollection asArray.	terms := Set new.	llParseTable do: [:row | row			associationsDo: 				[:assoc | 				terms add: assoc key.				assoc value rightHandSide do: [:sym | sym isTerminal ifTrue: [terms add: sym]]]].	self terminals: terms asOrderedCollection asArray.	objectTable := Array new: self nonterminals size.	^self convert: llParseTable to: objectTable</body><body package="T-Gen Core">convert: llParseTable to: objectTable 	| nonterms terms row |	nonterms := self nonterminals.	terms := self terminals.	llParseTable		associationsDo: 			[:assoc1 | 			row := Array new: terms size.			objectTable at: (nonterms indexOf: assoc1 key)				put: row.			assoc1 value associationsDo: [:assoc2 | row at: (terms indexOf: assoc2 key)					put: assoc2 value]].	^objectTable</body><body package="T-Gen Core">convertToTable: ll1Parser 	self scanner: ll1Parser scanner fastScanner.	self parseTable: (self changeToObjectTable: ll1Parser parseTable).	self treeBuilder:  ll1Parser treeBuilder.	self startSymbol: ll1Parser startSymbol</body></methods><methods><class-id>Tgen.OptimizedLL1Parser</class-id> <category>state accessing</category><body package="T-Gen Core">nonterminals	^nonterminals</body><body package="T-Gen Core">nonterminals: arg	nonterminals := arg</body><body package="T-Gen Core">terminals	^terminals</body><body package="T-Gen Core">terminals: arg	terminals := arg</body></methods><methods><class-id>Tgen.OptimizedLL1Parser class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"OptimizedLL1Parser initialize"	self noTransitionSignal: (Signal new nameClass: self message: #noTransitionSymbol)</body></methods><methods><class-id>Tgen.OptimizedLL1Parser class</class-id> <category>instance creation</category><body package="T-Gen Core">buildFrom: ll1Parser	^self new convertToTable: ll1Parser</body></methods><methods><class-id>Tgen.OptimizedLL1Parser class</class-id> <category>state accessing</category><body package="T-Gen Core">nonterminals 	^nonterminals</body><body package="T-Gen Core">nonterminals: prodTable	nonterminals := self convertFromStoredProductionTable: prodTable</body><body package="T-Gen Core">noTransitionSignal	^NoTransitionSignal</body><body package="T-Gen Core">noTransitionSignal: arg	NoTransitionSignal := arg</body><body package="T-Gen Core">terminals	^terminals</body><body package="T-Gen Core">terminals: prodTable	terminals := self convertFromStoredProductionTable: prodTable</body></methods><methods><class-id>Tgen.OptimizedLL1Parser class</class-id> <category>reconstructing</category><body package="T-Gen Core">constructGrammarProduction: arg with: prodTable 	| rhs |	(arg at: 2) isEmpty		ifTrue: [rhs := OrderedCollection new]		ifFalse: 			[rhs := OrderedCollection new.			(arg at: 2)				do: [:ea | rhs addLast: (prodTable at: ea)]].	^GrammarProduction		leftHandSide: (prodTable at: (arg at: 1))		rightHandSide: rhs</body><body package="T-Gen Core">constructParseTable: table with: prodTable 	| ea row newProdTable |	newProdTable := self convertFromStoredProductionTable: prodTable.	parseTable := Array new: table size.	1 to: table size do: 		[:index | 		row := Array new: (table at: index) size.		parseTable at: index put: row.		1 to: (table at: index) size do: 			[:i | 			ea := (table at: index)						at: i.			ea isNil ifFalse: [ea isInteger					ifTrue: [row at: i put: ea]					ifFalse: [ea size == 2							ifTrue: [row at: i put: (self constructGrammarProduction: ea with: newProdTable)]							ifFalse: [row at: i put: (self constructTransductionGrammarProduction: ea with: newProdTable)]]]]]</body><body package="T-Gen Core">constructTransductionGrammarProduction: arg with: prodTable 	| rhs |	(arg at: 2) isEmpty		ifTrue: [rhs := OrderedCollection new]		ifFalse: 			[rhs := OrderedCollection new.			(arg at: 2)				do: [:ea | rhs addLast: (prodTable at: ea)]].	^TransductionGrammarProduction		leftHandSide: (prodTable at: (arg at: 1))		rightHandSide: rhs		translationSymbol: (prodTable at: (arg at: 3))</body></methods><methods><class-id>Tgen.HandCodedScanner</class-id> <category>state accessing</category><body package="T-Gen Core">charTypeTable	^charTypeTable</body><body package="T-Gen Core">charTypeTable: argument 	charTypeTable := argument</body></methods><methods><class-id>Tgen.HandCodedScanner</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self charTypeTable: self myTypeTable</body></methods><methods><class-id>Tgen.HandCodedScanner</class-id> <category>accessing</category><body package="T-Gen Core">endOfInputToken	"Answer a token representing the end of the input."	^nil</body><body package="T-Gen Core">endOfInputTokenType	"Answer the token type representing the end of the input."	^#doIt</body><body package="T-Gen Core">myTypeTable	^self class charTypeTable</body></methods><methods><class-id>Tgen.HandCodedScanner</class-id> <category>testing</category><body package="T-Gen Core">atStartOfComplexToken	"Answer true if the first character of the tokenType is an $x and false otherwise."	^(self tokenType at: 1)		= $x</body></methods><methods><class-id>Tgen.HandCodedScanner</class-id> <category>scanning</category><body package="T-Gen Core">scanToken	"Scan the next token and compute its token type.  This may be 	overridden in subclasses for efficiency and customization."		[self atEnd ifTrue: [^self signalEndOfInput].	self tokenType: (self charTypeTable at: self nextChar asInteger).	self tokenType == #xDelimiter]		whileTrue: 			["Skip delimiters fast, there almost always is one."			self getNextChar].	self atStartOfComplexToken		ifTrue: 			["perform to compute token &amp; type"			self perform: tokenType]		ifFalse: 			["else just the character"			self token: self nextChar.			self getNextChar]</body></methods><methods><class-id>Tgen.HandCodedScanner class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"Concrete subclasses must provide a character type table."	"HandCodedScanner initialize"	| newTable |	newTable := Array new: 256 withAll: #xDefault.		"default"	self charTypeTable: newTable</body></methods><methods><class-id>Tgen.HandCodedScanner class</class-id> <category>state accessing</category><body package="T-Gen Core">charTypeTable	^charTypeTable</body><body package="T-Gen Core">charTypeTable: argument 	charTypeTable := argument</body></methods><methods><class-id>Tgen.RetractableWriteStream</class-id> <category>positioning</category><body package="T-Gen Core">backspace	"Backup one position, if possible. It may be best to signal an error when attempting to backup 	past the beginning of the stream, but for now just do nothing."	self atBeginning ifFalse: [self skip: -1]</body></methods><methods><class-id>Tgen.RetractableWriteStream</class-id> <category>accessing</category><body package="T-Gen Core">size	"Answer how many elements the receiver contains."	^position</body></methods><methods><class-id>Tgen.RetractableWriteStream</class-id> <category>testing</category><body package="T-Gen Core">atBeginning	^position = 0</body></methods><methods><class-id>Tgen.TokenClassification</class-id> <category>state accessing</category><body package="T-Gen Core">action	^action</body><body package="T-Gen Core">action: argument 	action := argument</body><body package="T-Gen Core">tokenType	^tokenType</body><body package="T-Gen Core">tokenType: argument 	tokenType := argument</body></methods><methods><class-id>Tgen.TokenClassification</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream	aStream nextPutAll: self tokenType.	aStream nextPutAll: ' : {'.	aStream nextPutAll: (self action isNil ifTrue: ['nil'] ifFalse: [self action]).	aStream nextPutAll: '} ;'</body></methods><methods><class-id>Tgen.TokenClassification</class-id> <category>reconstructing</category><body package="T-Gen Core">reconstructOn: aStream 	"Emit #( tokenType  action ) on aStream"	aStream poundSign; leftParenthesis.	self tokenType reconstructOn: aStream.	aStream space.	self action reconstructOn: aStream.	aStream rightParenthesis</body></methods><methods><class-id>Tgen.TokenClassification class</class-id> <category>instance creation</category><body package="T-Gen Core">tokenType: arg1 action: arg2 	| newMe |	newMe := self new.	newMe tokenType: arg1.	newMe action: arg2.	^newMe</body></methods><methods><class-id>Tgen.FirstFollowGraphNode</class-id> <category>first/follow sets</category><body package="T-Gen Core">unionWithPredecessorsChangesMe	"Answer true if adding the terminals of my predecessors changes my terminals 	and false otherwise."	| myTerms initialSize |	myTerms := self terminals.	initialSize := myTerms size.	self predecessorsDo: [:pred | myTerms addAll: pred terminals].	^initialSize ~= myTerms size</body></methods><methods><class-id>Tgen.FirstFollowGraphNode</class-id> <category>converting</category><body package="T-Gen Core">asAssociation	^Association key: self label value: self terminals</body></methods><methods><class-id>Tgen.FirstFollowGraphNode</class-id> <category>adding</category><body package="T-Gen Core">addTerminal: term 	self terminals add: term</body></methods><methods><class-id>Tgen.FirstFollowGraphNode</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self terminals: Set new</body></methods><methods><class-id>Tgen.FirstFollowGraphNode</class-id> <category>state accessing</category><body package="T-Gen Core">terminals	^terminals</body><body package="T-Gen Core">terminals: argument 	terminals := argument</body></methods><methods><class-id>Tgen.TokenSpecScanner class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"TokenSpecScanner initialize"	"&lt;tokenClass&gt;	: \&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;	;&lt;directive&gt;		: \{[a-zA-Z_][a-zA-Z_0-9]*\}	;&lt;dchar&gt;		: \\[0-9][0-9][0-9]				;&lt;ochar&gt;		: \\o[0-7][0-7][0-7]			;&lt;hchar&gt;		: \\x[0-9A-F][0-9A-F]			;&lt;eschar&gt;		: \\[!-\~]						;&lt;char&gt;			: [!-\~]						;&lt;comment&gt;		: \""(~[\""]|\""\""|[\s\t\r\n])*\""	{ignoreComment};&lt;space&gt;		:[\s\t\r\n]+			{ignoreDelimiter} ;"	| table |	self fsa: #( #( nil nil nil nil nil nil nil nil 2 2 nil nil 2 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 2 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 7 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 10 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 22 3 3 3 nil ) #( nil nil nil nil nil nil nil nil 2 2 nil nil 2 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 2 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 nil ) #( nil nil nil nil 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 5 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 nil nil nil nil 8 nil 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8 8 8 8 8 8 8 8 8 8 nil nil nil nil 9 nil nil 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 nil nil nil nil 8 nil 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 15 11 11 11 11 11 11 11 11 19 11 11 11 11 11 11 nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 13 13 13 13 13 13 13 13 13 13 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 14 14 14 14 14 14 14 14 14 14 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 16 16 16 16 16 16 16 16 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 17 17 17 17 17 17 17 17 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 18 18 18 18 18 18 18 18 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 20 20 20 20 20 20 20 20 20 20 nil nil nil nil nil nil nil 20 20 20 20 20 20 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 21 21 21 21 21 21 21 21 21 21 nil nil nil nil nil nil nil 21 21 21 21 21 21 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 nil nil nil nil 23 nil 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 23 23 23 23 23 23 23 23 23 23 nil nil nil nil nil nil nil 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 nil nil nil nil 23 nil 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 nil nil 24 nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) ).	table := #( nil #( #( ) #( #('&lt;space&gt;' #ignoreDelimiter) ) ) #( #( '+' ';' ']' ')' '~' '(' '[' '|' '*' ':' '?' '-' ) #( #('&lt;char&gt;' nil) ) ) #( #( ) #( #('&lt;char&gt;' nil) ) ) nil #( #( ) #( #('&lt;comment&gt;' #ignoreComment) ) ) #( #( ) #( #('&lt;char&gt;' nil) ) ) nil #( #( ) #( #('&lt;tokenClass&gt;' nil) ) ) #( #( ) #( #('&lt;char&gt;' nil) ) ) #( #( ) #( #('&lt;eschar&gt;' nil) ) ) #( #( ) #( #('&lt;eschar&gt;' nil) ) ) nil #( #( ) #( #('&lt;dchar&gt;' nil) ) ) #( #( ) #( #('&lt;eschar&gt;' nil) ) ) nil nil #( #( ) #( #('&lt;ochar&gt;' nil) ) ) #( #( ) #( #('&lt;eschar&gt;' nil) ) ) nil #( #( ) #( #('&lt;hchar&gt;' nil) ) ) #( #( ) #( #('&lt;char&gt;' nil) ) ) nil #( #( ) #( #('&lt;directive&gt;' nil) ) ) ).	self constructFinalStateTable: table</body></methods><methods><class-id>Tgen.EpsilonNode</class-id> <category>building parse trees</category><body package="T-Gen Core">concatenateWith: node	^node</body><body package="T-Gen Core">concatenateWithCatNode: node	^node</body><body package="T-Gen Core">concatenateWithNonCatNode: node	^node</body></methods><methods><class-id>Tgen.EpsilonNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPutAll: '&lt;epsilon&gt;'</body></methods><methods><class-id>Tgen.EpsilonNode</class-id> <category>converting</category><body package="T-Gen Core">asFSAStartingAt: startState endingAt: finalState 	startState goto: finalState on: self epsilon</body></methods><methods><class-id>Tgen.EpsilonNode</class-id> <category>collecting</category><body package="T-Gen Core">collectSymbol	^OrderedCollection new</body></methods><methods><class-id>Tgen.EpsilonNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes	"Productions of the form 'A -&gt; &lt;epsilon&gt;' do not need transforming.	Signal this by answering an empty collection."	^OrderedCollection new</body></methods><methods><class-id>Tgen.EpsilonNode class</class-id> <category>constants</category><body package="T-Gen Core">epsilon	"Answer an object used to represent the empty string."	^Character endOfInput</body></methods><methods><class-id>Tgen.ItemSet</class-id> <category>testing</category><body package="T-Gen Core">isItemSet	^true</body></methods><methods><class-id>Tgen.ItemSet</class-id> <category>comparing</category><body package="T-Gen Core">= anItemSet 	^anItemSet isItemSet		ifTrue: [self size = anItemSet size and: [self size = (self union: anItemSet) size]]		ifFalse: [false]</body><body package="T-Gen Core">hash	"Make sure equal sets hash equally."	"A good and fast hashing function will require some more thought. I used to use 	'self size bitXor: self first hash' but there is no guarantee that the first's of 	equal sets will be the same element (even if their basicSizes are the same, due 	to the temporal ordering of hash collisions). If simply 'size' doesn't give 	reasonable performance, then try 'self inject: 0 into: [:max :each 	| max max: each hash]'."	^self isEmpty		ifTrue: [151515]		ifFalse: [self size]</body></methods><methods><class-id>Tgen.LR1Item</class-id> <category>state accessing</category><body package="T-Gen Core">lookahead	^lookahead</body><body package="T-Gen Core">lookahead: argument 	lookahead := argument</body></methods><methods><class-id>Tgen.LR1Item</class-id> <category>testing</category><body package="T-Gen Core">isLR1Item	^true</body></methods><methods><class-id>Tgen.LR1Item</class-id> <category>comparing</category><body package="T-Gen Core">= anItem 	^anItem isLR1Item		ifTrue: [self lookahead = anItem lookahead and: [super = anItem]]		ifFalse: [false]</body><body package="T-Gen Core">hash	"This is redefined because = is redefined."	^(self leftHandSide hash bitXor: self lookahead hash)		bitXor: (self preDotSymbols hash bitXor: self postDotSymbols hash)</body></methods><methods><class-id>Tgen.LR1Item</class-id> <category>accessing</category><body package="T-Gen Core">lookaheadTail	"For an lr1 item 'B -&gt; &lt;alpha&gt; . A &lt;beta&gt; : lookahead' answer 	the string '&lt;beta&gt; lookahead'."	| string |	string := self postDotSymbols copy.	string removeFirst.	string addLast: self lookahead.	^string</body></methods><methods><class-id>Tgen.LR1Item</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ': '.	self lookahead printOn: aStream</body></methods><methods><class-id>Tgen.LR1Item class</class-id> <category>instance creation</category><body package="T-Gen Core">initialItemForGrammar: grammar 	"After conceptually augment the grammar with the production 	'@@ -&gt; S &lt;endOfInput&gt;', answer the initial item for construction 	of the LR CFSM."	^self		leftHandSide: self augmentedGrammarStartSymbol		preDotSymbols: OrderedCollection new		postDotSymbols: (OrderedCollection with: grammar startSymbol with: self endOfInputSymbol)		lookahead: self endOfInputSymbol</body><body package="T-Gen Core">leftHandSide: arg1 preDotSymbols: arg2 postDotSymbols: arg3 lookahead: arg4 	| newMe |	newMe := self new.	newMe leftHandSide: arg1.	newMe preDotSymbols: arg2.	newMe postDotSymbols: arg3.	newMe lookahead: arg4.	^newMe</body><body package="T-Gen Core">leftHandSide: arg1 preDotSymbols: arg2 postDotSymbols: arg3 lookahead: arg4 translationSymbol: arg5 	| newMe |	newMe := self new.	newMe leftHandSide: arg1.	newMe preDotSymbols: arg2.	newMe postDotSymbols: arg3.	newMe lookahead: arg4.	newMe translationSymbol: arg5.	^newMe</body></methods><methods><class-id>Tgen.GrammarNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock 	"Evaluate aBlock for each of my children."	^self productions do: aBlock</body><body package="T-Gen Core">updateChildrenUsing: aBlock 	"Replace my children according to the value of aBlock."	^self productions: (self productions collect: aBlock)</body></methods><methods><class-id>Tgen.GrammarNode</class-id> <category>state accessing</category><body package="T-Gen Core">productions	^productions</body><body package="T-Gen Core">productions: argument 	productions := argument</body></methods><methods><class-id>Tgen.GrammarNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenFirst: anOrderedCollection 	self productions addAllFirst: anOrderedCollection</body><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	self productions addAll: anOrderedCollection</body></methods><methods><class-id>Tgen.GrammarNode</class-id> <category>initialization</category><body package="T-Gen Core">init	self productions: OrderedCollection new</body></methods><methods><class-id>Tgen.GrammarNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self productions do: 		[:prod | 		prod printOn: aStream.		aStream cr]</body></methods><methods><class-id>Tgen.GrammarNode</class-id> <category>converting</category><body package="T-Gen Core">asContextFreeGrammar	"Answer the CFG representation of this RRPG grammar."	| transProds lhsNames baseProds |	transProds := OrderedCollection new.	lhsNames := Set new.	"Remove all RRPG grammar operators."	self childrenDo: [:prod | transProds addAll: (prod convertToCFGUsing: lhsNames)].	"Convert from parsetree format to grammar format."	baseProds := transProds				collect: 					[:prod | 					| lhs |					lhs := prod leftHandSide asGrammarSymbol.					prod rightHandSides asProductionWithLeftHandSide: lhs].	^Grammar buildGrammarWithProductions: baseProds</body></methods><methods><class-id>Tgen.GrammarNode class</class-id> <category>instance creation</category><body package="T-Gen Core">new	^super new init</body></methods><methods><class-id>Tgen.FSABasedLookaheadScanner</class-id> <category>initialization</category><body package="T-Gen Core">reset	"Reset the initial state of the scanner before scanning a new source."	super reset.	self savePosition: 0</body></methods><methods><class-id>Tgen.FSABasedLookaheadScanner</class-id> <category>state accessing</category><body package="T-Gen Core">savePosition	^savePosition</body><body package="T-Gen Core">savePosition: argument 	savePosition := argument</body></methods><methods><class-id>Tgen.FSABasedLookaheadScanner</class-id> <category>accessing</category><body package="T-Gen Core">errorPosition	"Answer the source position of the last acceptable character."	^self savePosition max: 1</body></methods><methods><class-id>Tgen.OptionalNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPut: $(.	self onlyChild printOn: aStream.	aStream nextPutAll: ')?'</body></methods><methods><class-id>Tgen.OptionalNode</class-id> <category>converting</category><body package="T-Gen Core">asPureRegExpr	"Answer a new version of the receiver consisting of only characters, 	concatenations, alternations, and (star) closures."	^self alternationNodeClass children: (OrderedChildren with: self onlyChild asPureRegExpr with: self epsilonNodeClass new)</body></methods><methods><class-id>Tgen.OptionalNode</class-id> <category>transforming</category><body package="T-Gen Core">transformUsing: lhsNames withLHS: lhsNode alpha: alphaNodes gamma: gammaNodes 	"Transform productions of the form 'A -&gt; alpha beta? gamma' 	into 'A -&gt; alpha B', 'B -&gt; beta B', and 'B -&gt; gamma'."	| newProds newLHS |	newProds := OrderedCollection new.	newLHS := self newNonterminalFrom: lhsNode excluding: lhsNames.	newProds add: (self createNewProductionWithLHS: lhsNode andRHS: (alphaNodes addLast: newLHS; yourself)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: ((gammaNodes copy) addFirst: self onlyChild; yourself)).	newProds add: (self createNewProductionWithLHS: newLHS andRHS: gammaNodes copy).	^newProds</body></methods><methods><class-id>Tgen.TokenSpecParser</class-id> <category>private</category><body package="T-Gen Core">scannerClass	^TokenSpecScanner</body><body package="T-Gen Core">treeBuilderClass	^AbstractSyntaxTreeBuilder</body></methods><methods><class-id>Tgen.TokenSpecParser class</class-id> <category>class initialization</category><body package="T-Gen Core">initialize	"TokenSpecParser initialize"	"spec		: rule spec						{liftRightChild} ;spec		:							{TokenSpecNode} ; rule	: type ':' regExpr directive ';' 		{TokenSpecRuleNode} ; type		:&lt;tokenClass&gt;				{TokenClassNode} ; directive 	:  &lt;directive&gt;				{DirectiveNode} ;				 directive		:								{nil} ; regExpr		: catExpr '|' regExpr				{liftRightChild} ;regExpr		: catExpr					{AlternationNode} ; catExpr		: expr catExpr					{liftRightChild} ;catExpr	 : expr					{ConcatenationNode} ; expr	: baseExpr '*'					{StarClosureNode} ;expr	: baseExpr '+'					{PlusClosureNode} ;expr 	: baseExpr '?'					{OptionalNode} ; expr		: baseExpr						; baseExpr	: atom 							;baseExpr	: '(' regExpr ')' 					;baseExpr	: '[' atomList ']' {AlternationRangeNode} ; baseExpr : '~' '[' atomList ']' {ComplementedAlternationRangeNode} ; atomList	: listElmt atomList				{liftRightChild} ;atomList	: listElmt					{OrderedChildren} ; listElmt		: atom 							;listElmt		: atom '-' atom 		{CharRangeNode} ; atom		: &lt;dchar&gt;		{DecimalCharNode} ;atom		: &lt;ochar&gt;				{OctalCharNode} ;atom		:&lt;hchar&gt;			{HexadecimalCharNode} ; atom		: &lt;eschar&gt; 			{EscapedCharNode} ; atom		: &lt;char&gt;	{CharacterNode} ; "	| table prodTable |	prodTable := #( '[' #rule '&lt;Character value: 4&gt;' "16r0004" #atomList ')' '&lt;eschar&gt;' '(' #listElmt ';' #baseExpr ':' #directive #spec '&lt;char&gt;' '~' #atom #expr #type #catExpr '|' '-' #regExpr '&lt;directive&gt;' '&lt;tokenClass&gt;' ']' '&lt;dchar&gt;' '&lt;ochar&gt;' '+' '?' '&lt;hchar&gt;' '*' 'liftRightChild' 'HexadecimalCharNode' 'EscapedCharNode' 'StarClosureNode' 'ConcatenationNode' 'TokenSpecNode' 'OptionalNode' 'OrderedChildren' 'ComplementedAlternationRangeNode' 'TokenClassNode' 'nil' 'AlternationRangeNode' 'CharacterNode' 'CharRangeNode' 'PlusClosureNode' 'TokenSpecRuleNode' 'DecimalCharNode' 'DirectiveNode' 'AlternationNode' 'OctalCharNode' ).	self tokenTypeTable:  (prodTable copyFrom: 1 to:  31).	table := #( #( nil 4 #(13 #()37)  nil nil nil nil nil nil nil nil nil 2 nil nil nil nil 7 nil nil nil nil nil 6 nil nil nil nil nil nil nil ) #( nil nil 3 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil 4 #(13 #()37)  nil nil nil nil nil nil nil nil nil 5 nil nil nil nil 7 nil nil nil nil nil 6 nil nil nil nil nil nil nil ) #( nil nil #(13 #(2 13 )32)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil #(18 #(24 )41)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil nil nil 8 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( 9 nil nil nil nil 14 26 nil nil 29 nil nil nil 10 34 22 33 nil 23 nil nil 39 nil nil nil 19 13 nil nil 18 nil ) #( nil nil nil 11 nil 14 nil 20 nil nil nil nil nil 10 nil 15 nil nil nil nil nil nil nil nil nil 19 13 nil nil 18 nil ) #( #(16 #(14 )44)  nil nil nil #(16 #(14 )44)  #(16 #(14 )44)  #(16 #(14 )44)  nil #(16 #(14 )44)  nil nil nil nil #(16 #(14 )44)  #(16 #(14 )44)  nil nil nil nil #(16 #(14 )44)  #(16 #(14 )44)  nil #(16 #(14 )44)  nil #(16 #(14 )44)  #(16 #(14 )44)  #(16 #(14 )44)  #(16 #(14 )44)  #(16 #(14 )44)  #(16 #(14 )44)  #(16 #(14 )44)  ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 12 nil nil nil nil nil nil ) #( #(10 #(1 4 25 )43)  nil nil nil #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  nil #(10 #(1 4 25 )43)  nil nil nil nil #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  nil nil nil nil #(10 #(1 4 25 )43)  nil nil #(10 #(1 4 25 )43)  nil nil #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  #(10 #(1 4 25 )43)  ) #( #(16 #(27 )51)  nil nil nil #(16 #(27 )51)  #(16 #(27 )51)  #(16 #(27 )51)  nil #(16 #(27 )51)  nil nil nil nil #(16 #(27 )51)  #(16 #(27 )51)  nil nil nil nil #(16 #(27 )51)  #(16 #(27 )51)  nil #(16 #(27 )51)  nil #(16 #(27 )51)  #(16 #(27 )51)  #(16 #(27 )51)  #(16 #(27 )51)  #(16 #(27 )51)  #(16 #(27 )51)  #(16 #(27 )51)  ) #( #(16 #(6 )34)  nil nil nil #(16 #(6 )34)  #(16 #(6 )34)  #(16 #(6 )34)  nil #(16 #(6 )34)  nil nil nil nil #(16 #(6 )34)  #(16 #(6 )34)  nil nil nil nil #(16 #(6 )34)  #(16 #(6 )34)  nil #(16 #(6 )34)  nil #(16 #(6 )34)  #(16 #(6 )34)  #(16 #(6 )34)  #(16 #(6 )34)  #(16 #(6 )34)  #(16 #(6 )34)  #(16 #(6 )34)  ) #( nil nil nil nil nil #(8 #(16 ))  nil nil nil nil nil nil nil #(8 #(16 ))  nil nil nil nil nil nil 16 nil nil nil #(8 #(16 ))  #(8 #(16 ))  #(8 #(16 ))  nil nil #(8 #(16 ))  nil ) #( nil nil nil nil nil 14 nil nil nil nil nil nil nil 10 nil 17 nil nil nil nil nil nil nil nil nil 19 13 nil nil 18 nil ) #( nil nil nil nil nil #(8 #(16 21 16 )45)  nil nil nil nil nil nil nil #(8 #(16 21 16 )45)  nil nil nil nil nil nil nil nil nil nil #(8 #(16 21 16 )45)  #(8 #(16 21 16 )45)  #(8 #(16 21 16 )45)  nil nil #(8 #(16 21 16 )45)  nil ) #( #(16 #(30 )33)  nil nil nil #(16 #(30 )33)  #(16 #(30 )33)  #(16 #(30 )33)  nil #(16 #(30 )33)  nil nil nil nil #(16 #(30 )33)  #(16 #(30 )33)  nil nil nil nil #(16 #(30 )33)  #(16 #(30 )33)  nil #(16 #(30 )33)  nil #(16 #(30 )33)  #(16 #(30 )33)  #(16 #(30 )33)  #(16 #(30 )33)  #(16 #(30 )33)  #(16 #(30 )33)  #(16 #(30 )33)  ) #( #(16 #(26 )48)  nil nil nil #(16 #(26 )48)  #(16 #(26 )48)  #(16 #(26 )48)  nil #(16 #(26 )48)  nil nil nil nil #(16 #(26 )48)  #(16 #(26 )48)  nil nil nil nil #(16 #(26 )48)  #(16 #(26 )48)  nil #(16 #(26 )48)  nil #(16 #(26 )48)  #(16 #(26 )48)  #(16 #(26 )48)  #(16 #(26 )48)  #(16 #(26 )48)  #(16 #(26 )48)  #(16 #(26 )48)  ) #( nil nil nil 21 nil 14 nil 20 nil nil nil nil nil 10 nil 15 nil nil nil nil nil nil nil nil #(4 #(8 )39)  19 13 nil nil 18 nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #(4 #(8 4 )32)  nil nil nil nil nil nil ) #( #(10 #(16 ))  nil nil nil #(10 #(16 ))  #(10 #(16 ))  #(10 #(16 ))  nil #(10 #(16 ))  nil nil nil nil #(10 #(16 ))  #(10 #(16 ))  nil nil nil nil #(10 #(16 ))  nil nil #(10 #(16 ))  nil nil #(10 #(16 ))  #(10 #(16 ))  #(10 #(16 ))  #(10 #(16 ))  #(10 #(16 ))  #(10 #(16 ))  ) #( nil nil nil nil #(22 #(19 )50)  nil nil nil #(22 #(19 )50)  nil nil nil nil nil nil nil nil nil nil 24 nil nil #(22 #(19 )50)  nil nil nil nil nil nil nil nil ) #( 9 nil nil nil nil 14 26 nil nil 29 nil nil nil 10 34 22 33 nil 23 nil nil 25 nil nil nil 19 13 nil nil 18 nil ) #( nil nil nil nil #(22 #(19 20 22 )32)  nil nil nil #(22 #(19 20 22 )32)  nil nil nil nil nil nil nil nil nil nil nil nil nil #(22 #(19 20 22 )32)  nil nil nil nil nil nil nil nil ) #( 9 nil nil nil nil 14 26 nil nil 29 nil nil nil 10 34 22 33 nil 23 nil nil 27 nil nil nil 19 13 nil nil 18 nil ) #( nil nil nil nil 28 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( #(10 #(7 22 5 ))  nil nil nil #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  nil #(10 #(7 22 5 ))  nil nil nil nil #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  nil nil nil nil #(10 #(7 22 5 ))  nil nil #(10 #(7 22 5 ))  nil nil #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  #(10 #(7 22 5 ))  ) #( #(17 #(10 ))  nil nil nil #(17 #(10 ))  #(17 #(10 ))  #(17 #(10 ))  nil #(17 #(10 ))  nil nil nil nil #(17 #(10 ))  #(17 #(10 ))  nil nil nil nil #(17 #(10 ))  nil nil #(17 #(10 ))  nil nil #(17 #(10 ))  #(17 #(10 ))  32 30 #(17 #(10 ))  31 ) #( #(17 #(10 29 )38)  nil nil nil #(17 #(10 29 )38)  #(17 #(10 29 )38)  #(17 #(10 29 )38)  nil #(17 #(10 29 )38)  nil nil nil nil #(17 #(10 29 )38)  #(17 #(10 29 )38)  nil nil nil nil #(17 #(10 29 )38)  nil nil #(17 #(10 29 )38)  nil nil #(17 #(10 29 )38)  #(17 #(10 29 )38)  nil nil #(17 #(10 29 )38)  nil ) #( #(17 #(10 31 )35)  nil nil nil #(17 #(10 31 )35)  #(17 #(10 31 )35)  #(17 #(10 31 )35)  nil #(17 #(10 31 )35)  nil nil nil nil #(17 #(10 31 )35)  #(17 #(10 31 )35)  nil nil nil nil #(17 #(10 31 )35)  nil nil #(17 #(10 31 )35)  nil nil #(17 #(10 31 )35)  #(17 #(10 31 )35)  nil nil #(17 #(10 31 )35)  nil ) #( #(17 #(10 28 )46)  nil nil nil #(17 #(10 28 )46)  #(17 #(10 28 )46)  #(17 #(10 28 )46)  nil #(17 #(10 28 )46)  nil nil nil nil #(17 #(10 28 )46)  #(17 #(10 28 )46)  nil nil nil nil #(17 #(10 28 )46)  nil nil #(17 #(10 28 )46)  nil nil #(17 #(10 28 )46)  #(17 #(10 28 )46)  nil nil #(17 #(10 28 )46)  nil ) #( 9 nil nil nil #(19 #(17 )36)  14 26 nil #(19 #(17 )36)  29 nil nil nil 10 34 22 33 nil 38 #(19 #(17 )36)  nil nil #(19 #(17 )36)  nil nil 19 13 nil nil 18 nil ) #( 35 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil nil 36 nil 14 nil 20 nil nil nil nil nil 10 nil 15 nil nil nil nil nil nil nil nil nil 19 13 nil nil 18 nil ) #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 37 nil nil nil nil nil nil ) #( #(10 #(15 1 4 25 )40)  nil nil nil #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  nil #(10 #(15 1 4 25 )40)  nil nil nil nil #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  nil nil nil nil #(10 #(15 1 4 25 )40)  nil nil #(10 #(15 1 4 25 )40)  nil nil #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  #(10 #(15 1 4 25 )40)  ) #( nil nil nil nil #(19 #(17 19 )32)  nil nil nil #(19 #(17 19 )32)  nil nil nil nil nil nil nil nil nil nil #(19 #(17 19 )32)  nil nil #(19 #(17 19 )32)  nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil #(12 #()42)  nil nil 40 nil nil nil nil nil nil nil nil nil nil 42 nil nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil 41 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) #( nil nil #(2 #(18 11 22 12 9 )47)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #(2 #(18 11 22 12 9 )47)  nil nil nil nil nil nil nil ) #( nil nil nil nil nil nil nil nil #(12 #(23 )49)  nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ) ).	self constructParseTable: table  with: prodTable.	self finalState: 3</body></methods><methods><class-id>Tgen.DerivationTreeNode</class-id> <category>state accessing</category><body package="T-Gen Core">children	^children</body><body package="T-Gen Core">children: argument 	children := argument</body><body package="T-Gen Core">symbol	^symbol</body><body package="T-Gen Core">symbol: argument 	symbol := argument</body></methods><methods><class-id>Tgen.DerivationTreeNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self printOn: aStream level: 0</body><body package="T-Gen Core">printOn: aStream dots: anInteger 	anInteger timesRepeat: [aStream nextPutAll: ' . ']</body><body package="T-Gen Core">printOn: aStream level: level 	self printOn: aStream dots: level.	self symbol printOn: aStream.	aStream cr.	self childrenDo: [:child | child printOn: aStream level: level + 1]</body></methods><methods><class-id>Tgen.DerivationTreeNode</class-id> <category>initialization</category><body package="T-Gen Core">init	self children: OrderedCollection new</body></methods><methods><class-id>Tgen.DerivationTreeNode</class-id> <category>traversing</category><body package="T-Gen Core">childrenDo: aBlock 	self children do: aBlock</body><body package="T-Gen Core">updateChildrenUsing: aBlock 	"Replace my children according to the value of aBlock."	self children: (self children collect: [:child | aBlock value: child])</body></methods><methods><class-id>Tgen.DerivationTreeNode</class-id> <category>testing</category><body package="T-Gen Core">isNonterminal	^self symbol isNonterminal</body><body package="T-Gen Core">isTerminal	^self symbol isTerminal</body></methods><methods><class-id>Tgen.DerivationTreeNode</class-id> <category>manipulating children</category><body package="T-Gen Core">addChild: aNode 	self addLastChild: aNode</body><body package="T-Gen Core">addFirstChild: aNode 	self children addFirst: aNode</body><body package="T-Gen Core">addLastChild: aNode 	self children addLast: aNode</body></methods><methods><class-id>Tgen.DerivationTreeNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenFirst: anOrderedCollection 	anOrderedCollection reverseDo: [:child | self addFirstChild: child]</body><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	self children: anOrderedCollection copy</body><body package="T-Gen Core">addChildrenLast: anOrderedCollection 	anOrderedCollection reverseDo: [:child | self addLastChild: child]</body><body package="T-Gen Core">setAttribute: value 	self symbol: value</body></methods><methods><class-id>Tgen.DerivationTreeNode class</class-id> <category>instance creation</category><body package="T-Gen Core">symbol: aSymbol 	| newNode |	newNode := self new init.	newNode symbol: aSymbol.	^newNode</body></methods><methods><class-id>Tgen.FSABasedScannerWithOneTokenLookahead</class-id> <category>scanner generation</category><body package="T-Gen Core">defaultOptimizedScannerClass	^OptimizedScannerWithOneTokenLookahead</body></methods><methods><class-id>Tgen.FSABasedScannerWithOneTokenLookahead</class-id> <category>scanning</category><body package="T-Gen Core">scanToken	"Scan the next token and compute its token type."	| nextState tok typeAction stateStack saveChar saveState |	stateStack := OrderedCollection new.	self atEnd		ifTrue: [self signalEndOfInput]		ifFalse: 			[stateStack addFirst: self startState.						[(nextState := stateStack first transitionFor: self nextChar ifNone: [nil]) isNil]					whileFalse: 						[stateStack addFirst: nextState.						self getNextChar].	"save the current position for error notification"			self savePosition: self position + (self atEnd ifTrue: [1] ifFalse: [0]).			stateStack first isFSAFinalState ifFalse: 					[saveChar := self nextChar.					saveState := stateStack first.	"backup to the previous final state or to the start state"					[stateStack size = 1 or: [stateStack first isFSAFinalState]] whileFalse: 							[stateStack removeFirst.							self putBackChar].					stateStack size = 1 ifTrue: 							["backed up to the start state so signal an error"							saveState transitionFor: saveChar]].	"answer the newly scanned token"			tok := self buffer contents.			typeAction := stateStack first tokenTypeAndActionFor: tok.			self tokenType: typeAction type.			self token: tok.			self buffer reset.			typeAction action notNil ifTrue: [self perform: typeAction action]]</body></methods><methods><class-id>Tgen.TokenTypeActionHolder</class-id> <category>state accessing</category><body package="T-Gen Core">action	^action</body><body package="T-Gen Core">action: argument 	action := argument</body><body package="T-Gen Core">type	^type</body><body package="T-Gen Core">type: argument 	type := argument</body></methods><methods><class-id>Tgen.TokenTypeActionHolder</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream	aStream nextPutAll: self type.	aStream nextPutAll: ' : {'.	aStream nextPutAll: self action.	aStream nextPutAll: '} ;'</body></methods><methods><class-id>Tgen.TokenTypeActionHolder class</class-id> <category>instance creation</category><body package="T-Gen Core">type: arg1 action: arg2 	| newMe |	newMe := self new.	newMe type: arg1.	newMe action: arg2.	^newMe</body></methods><methods><class-id>Tgen.OptimizedScannerWithOneTokenLookahead</class-id> <category>scanning</category><body package="T-Gen Core">scanToken	"Scan the next token and compute its token type."	| nextState tok typeAction stateStack saveChar saveState |	stateStack := OrderedCollection new.	self atEnd		ifTrue: [self signalEndOfInput]		ifFalse: 			[stateStack addFirst: self startState.			[(nextState := (fsa at: stateStack first) at: self nextChar asInteger) isNil]				whileFalse: 					[stateStack addFirst: nextState.					self getNextChar].	"save the current position for error notification"			self savePosition: self position + (self atEnd ifTrue: [1] ifFalse: [0]).			(self isFSAFinalState: stateStack first) ifFalse: 					["save the current position for error notification"					saveChar := self nextChar.					saveState := stateStack first.	"backup to the previous final state or to the start state"					[stateStack size = 1 or: [self isFSAFinalState: stateStack first]]						whileFalse: 							[stateStack removeFirst.							self putBackChar].					stateStack size = 1 ifTrue: 							["backed up to the start state so signal an error"							self at: saveState transitionFor: saveChar]].	"answer the newly scanned token"			tok := self buffer contents.			typeAction := self at: stateStack first tokenTypeAndActionFor: tok.			self tokenType: typeAction type.			self token: tok.			self buffer reset.			typeAction action notNil ifTrue: [self perform: typeAction action]]</body></methods><methods><class-id>Tgen.ComplementedAlternationRangeNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	aStream nextPut: $~.	super printOn: aStream</body></methods><methods><class-id>Tgen.ComplementedAlternationRangeNode</class-id> <category>accessing</category><body package="T-Gen Core">characters	"Answer the Set of Characters I represent."	| chars |	chars := self characterUniverse.	chars removeAll: super characters.	^chars</body><body package="T-Gen Core">characterUniverse	"Answer a collection of printable characters."	^((5 to: 126)		collect: [:ea | Character value: ea]) asSet</body></methods><methods><class-id>Tgen.FSABasedScannerWithTwoTokenLookahead</class-id> <category>scanner generation</category><body package="T-Gen Core">defaultOptimizedScannerClass	^OptimizedScannerWithTwoTokenLookahead</body></methods><methods><class-id>Tgen.FSABasedScannerWithTwoTokenLookahead</class-id> <category>scanning</category><body package="T-Gen Core">checkForTokenIn: newStateStack buffer: charBuffer 	"Scan the input using the arguments. Answer true if a legal token (or no illegal token) was 	found and false otherwise."	| nextState |	self atEnd ifFalse: 			[newStateStack addFirst: self startState.	"look for longest possible token"						[(nextState := newStateStack first transitionFor: self nextChar ifNone: [nil]) isNil]					whileFalse: 						[newStateStack addFirst: nextState.	"getNextChar for local vars"						charBuffer nextPut: self nextChar.						self nextChar: self source next].	"save the current position for error notification"			self savePosition: self position + (self atEnd ifTrue: [1] ifFalse: [0]).			newStateStack first isFSAFinalState ifFalse: 					[self saveChar: self nextChar.					self saveState: newStateStack first.	"backup to the previous final state or to the start state"					[newStateStack size = 1 or: [newStateStack first isFSAFinalState]]						whileFalse: 							[newStateStack removeFirst.	"putBackChar for local vars"							charBuffer backspace.							self backspaceSource].					newStateStack size = 1 ifTrue: 							["backed up to the start state"							self stateStack == newStateStack								ifTrue: 									["this is the first token, so signal an error (abort and return)"									self saveState transitionFor: self saveChar]								ifFalse: 									["we may be able to backup in the previous token"									^false]]]].	^true</body><body package="T-Gen Core">scanToken	"Scan the next token and compute its token type."	| tok typeAction newStateStack charBuffer |	newStateStack := OrderedCollection new.	charBuffer := RetractableWriteStream on: (String new: 32).	(self checkForTokenIn: newStateStack buffer: charBuffer)		ifTrue: 			["either a legal token or the end on input was found"			self stateStack isEmpty ifTrue: [self atEnd					ifTrue: [^self signalEndOfInput]					ifFalse: [self error: 'no more vaild tokens']].			tok := self buffer contents.			typeAction := self stateStack first tokenTypeAndActionFor: tok.			self tokenType: typeAction type.			self token: tok.			self buffer: charBuffer.			self stateStack: newStateStack.			typeAction action notNil ifTrue: [self perform: typeAction action]]		ifFalse: 			["an illegal token was found, try to look for earlier final state in current token buffers"			charBuffer size timesRepeat: 				["put back illegal token chars"				self backspaceSource].			"backup in current token to next smallest legal token"			[self stateStack size = 1				or: 					[self stateStack removeFirst.					self putBackChar.					self stateStack first isFSAFinalState]] whileFalse.			self stateStack size = 1				ifTrue: 					["no smaller legal token so signal error"					self saveState transitionFor: self saveChar]				ifFalse: 					["try again"					self scanToken]]</body></methods><methods><class-id>Tgen.FSABasedScannerWithTwoTokenLookahead</class-id> <category>state accessing</category><body package="T-Gen Core">saveChar	^saveChar</body><body package="T-Gen Core">saveChar: argument 	saveChar := argument</body><body package="T-Gen Core">saveState	^saveState</body><body package="T-Gen Core">saveState: argument 	saveState := argument</body><body package="T-Gen Core">stateStack	^stateStack</body><body package="T-Gen Core">stateStack: argument 	stateStack := argument</body></methods><methods><class-id>Tgen.FSABasedScannerWithTwoTokenLookahead</class-id> <category>initialization</category><body package="T-Gen Core">reset	"Reset the initial state of the scanner before scanning a new source."	super reset.	self stateStack: OrderedCollection new</body><body package="T-Gen Core">scanSource: aString 	"Convert the input string to a read stream and scan the first token."	self reset.	self source: (RetractableReadStream on: aString).	self nextChar: self source next.	self checkForTokenIn: self stateStack buffer: self buffer.	self scanToken</body></methods><methods><class-id>Tgen.TerminalNode</class-id> <category>converting</category><body package="T-Gen Core">asGrammarSymbol	"Answer my symbol as a Terminal (String). A literal token is a string within a 	string so trim the extra quotes."	| sym |	^(sym := self symbol) isTokenClassTerminal		ifTrue: [sym]		ifFalse: [sym copyFrom: 2 to: sym size - 1]</body></methods><methods><class-id>Tgen.TerminalNode</class-id> <category>testing</category><body package="T-Gen Core">isTerminalNode	^true</body></methods><methods><class-id>Tgen.TerminalNode</class-id> <category>collecting</category><body package="T-Gen Core">collectSymbol	| regexpr |	regexpr := OrderedCollection new.	regexpr add: self asGrammarSymbol.	^regexpr</body></methods><methods><class-id>Tgen.CharRangeNode</class-id> <category>state accessing</category><body package="T-Gen Core">firstChar	^firstChar</body><body package="T-Gen Core">firstChar: argument 	firstChar := argument</body><body package="T-Gen Core">lastChar	^lastChar</body><body package="T-Gen Core">lastChar: argument 	lastChar := argument</body></methods><methods><class-id>Tgen.CharRangeNode</class-id> <category>building parse trees</category><body package="T-Gen Core">addChildrenInitial: anOrderedCollection 	anOrderedCollection size = 2		ifTrue: 			[self firstChar: anOrderedCollection removeFirst.			self lastChar: anOrderedCollection removeFirst]		ifFalse: [self error: 'wrong number of children']</body></methods><methods><class-id>Tgen.CharRangeNode</class-id> <category>printing</category><body package="T-Gen Core">printOn: aStream 	self firstChar printOn: aStream.	aStream nextPut: $-.	self lastChar printOn: aStream</body></methods><methods><class-id>Tgen.CharRangeNode</class-id> <category>private</category><body package="T-Gen Core">makeCharNodeFor: aChar 	"Answer a new CharacterNode for aChar."	^self characterNodeClass charSpec: (String with: aChar)</body></methods><methods><class-id>Tgen.CharRangeNode</class-id> <category>converting</category><body package="T-Gen Core">addCharsTo: aCollection 	"Add each character in my range to aCollection."	self firstChar asInteger to: self lastChar asInteger do: [:ascii | aCollection add: (Character value: ascii)]</body><body package="T-Gen Core">addPureCharNodesTo: childNodes 	"Add CharacterNodes for each character in my range to childNodes."	self firstChar asInteger to: self lastChar asInteger do: [:ascii | childNodes add: (self makeCharNodeFor: (Character value: ascii))]</body></methods><methods><class-id>Tgen.OctalCharNode</class-id> <category>accessing</category><body package="T-Gen Core">myChar	"Answer the Character represented by the receiver. 	The spec is of the form '\oOOO'."	| spec |	spec := self charSpec.	(spec size = 5 and: [spec first = $\ and: [(spec at: 2)				= $o]])		ifTrue: [^Character value: ('8r' , (spec copyFrom: 3 to: 5)) asNumber]		ifFalse: [self error: 'Octal character specifications must be of the form ''\oOOO''.']</body></methods><methods><class-id>Tgen.NonterminalNode</class-id> <category>converting</category><body package="T-Gen Core">asGrammarSymbol	"Answer my symbol as a Nonterminal (Symbol)."	^self symbol asSymbol</body></methods><methods><class-id>Tgen.NonterminalNode</class-id> <category>collecting</category><body package="T-Gen Core">collectSymbol	| regexpr |	regexpr := OrderedCollection new.	regexpr add: self asGrammarSymbol.	^regexpr</body></methods><methods><class-id>Tgen.RetractableReadStream</class-id> <category>positioning</category><body package="T-Gen Core">backspace	"Backup one position, if possible. It may be best to signal an error when attempting to backup 	past the beginning of the stream, but for now just do nothing."	self atBeginning ifFalse: [self skip: -1]</body></methods><methods><class-id>Tgen.RetractableReadStream</class-id> <category>testing</category><body package="T-Gen Core">atBeginning	^position = 0</body></methods><methods><class-id>Tgen.RetractableReadStream</class-id> <category>accessing</category><body package="T-Gen Core">current	"Answer the element at the current position or nil if at the beginning. This is useful for 	rereading the stream after backspacing."	^self atBeginning		ifTrue: [nil]		ifFalse: [collection at: position]</body></methods><methods><class-id>Tgen.RetractableReadStream</class-id> <category>private</category><body package="T-Gen Core">pastEnd	"The receiver has attempted to read past the end, answer an EOF indicator."	"NOTE: currently, this class is used only by T-gen so it is acceptable to use the end-of-input character	rather than nil to denote the end of the stream. However, in a more general context, it may 	be desirable to change this back to nil. If this is done then either the transitionFor:ifNone: 	method in class FSAState must be changed to check for nil as a transition symbol 	(Dictionaries do not allow nil keys), or scanners must be changed to translate a nil character 	to the end-of-input character. These changes affect what happens when a scanner runs out of      input in the middle of a token."	^Character endOfInput</body></methods><methods><class-id>Tgen.EscapedCharNode</class-id> <category>accessing</category><body package="T-Gen Core">myChar	"Answer the Character represented by the receiver. 	The spec is of the form '\c' where some c's are special (see class comment)."	| spec char |	spec := self charSpec.	(spec size = 2 and: [spec first = $\])		ifTrue: 			[char := spec last.			^self specialChars at: char ifAbsent: [char]]		ifFalse: [self error: 'Escaped character specifications must be of the form ''\c''.']</body><body package="T-Gen Core">specialChars	^SpecialCharMap</body></methods><methods><class-id>Tgen.EscapedCharNode class</class-id> <category>initialization</category><body package="T-Gen Core">initialize	"The following characters are special: 		spec	ascii	character 	----	----	-------- 	\0		0		null 	\b		8		backspace 	\t		9		horizontal tab 	\n		10		linefeed (UNIX newline \n) 	\f		12		form feed 	\r		13		carriage return (Smalltalk cr) 	\e		27		escape 	\s		32		space 	\d		127	delete"	"EscapedCharNode initialize"	| dict |	dict := Dictionary new.	dict		 at: $0 put: (Character value: 0);		 at: $b put: (Character value: 8);		 at: $t put: (Character value: 9);		 at: $n put: (Character value: 10);		 at: $f put: (Character value: 12);		 at: $r put: (Character value: 13);		 at: $e put: (Character value: 27);		 at: $s put: (Character value: 32);		 at: $d put: (Character value: 127).	SpecialCharMap := dict</body></methods><methods><class-id>Tgen.FSAFinalState</class-id> <category>initialization</category><body package="T-Gen Core">init	super init.	self literalTokens: Set new.	self tokenClasses: OrderedCollection new</body></methods><methods><class-id>Tgen.FSAFinalState</class-id> <category>state accessing</category><body package="T-Gen Core">literalTokens	^literalTokens</body><body package="T-Gen Core">literalTokens: argument 	literalTokens := argument</body><body package="T-Gen Core">tokenClasses	^tokenClasses</body><body package="T-Gen Core">tokenClasses: argument 	tokenClasses := argument</body></methods><methods><class-id>Tgen.FSAFinalState</class-id> <category>state transitions</category><body package="T-Gen Core">transitionFor: aSymbol 	"The default for final states is to not raise an exception 	if no transitions are possible, rather, they answer nil."	^self transitionFor: aSymbol ifNone: [nil]</body></methods><methods><class-id>Tgen.FSAFinalState</class-id> <category>testing</category><body package="T-Gen Core">isFSAFinalState	^true</body></methods><methods><class-id>Tgen.FSAFinalState</class-id> <category>token classifying</category><body package="T-Gen Core">addLiteralToken: literal 	self literalTokens add: literal</body><body package="T-Gen Core">addTokenClass: tokenClass 	"Don't add the same tokenClass twice."	self tokenClasses detect: [:tc | tc tokenType = tokenClass tokenType]		ifNone: [self tokenClasses size ~~ 0				ifTrue: [self error: 'Current implementation only handles non-overlapping token classes.']				ifFalse: [self tokenClasses add: tokenClass]]</body><body package="T-Gen Core">tokenTypeAndActionFor: aString 	"The current implementation does not handle overlapping token classes. Hence, a final state 	can only represent a literal or a single token class. Therefore, if not a literal then it must be 	the token class."	| tc |	((self literalTokens includes: aString)		or: [aString size = 0])		ifTrue: [^self typeActionHolderClass type: aString action: nil].	tc := self tokenClasses first.	^self typeActionHolderClass type: tc tokenType action: tc action</body></methods><methods><class-id>Tgen.FSAFinalState</class-id> <category>private</category><body package="T-Gen Core">typeActionHolderClass	^TokenTypeActionHolder</body></methods><methods><class-id>Tgen.DerivationTreeBuilder</class-id> <category>tree building</category><body package="T-Gen Core">epsilon	"Answer an object used to represent the empty string (epsilon)."	^'&lt;epsilon&gt;'</body><body package="T-Gen Core">processProduction: grammarProd forParser: parser 	"This is simple and straightforward to implement, so do it all here."	| parent child |	parent := DerivationTreeNode symbol: grammarProd leftHandSide.	grammarProd rightHandSide isEmpty		ifTrue: 			[child := DerivationTreeNode symbol: self epsilon.			parent addChild: child]		ifFalse: [parser performsLeftmostDerivation				ifTrue: [grammarProd rightHandSide do: 						[:sym | 						child := sym isTerminal									ifTrue: [DerivationTreeNode symbol: sym]									ifFalse: [self popStack].						parent addChild: child]]				ifFalse: [grammarProd rightHandSide						reverseDo: 							[:sym | 							child := sym isTerminal										ifTrue: [DerivationTreeNode symbol: sym]										ifFalse: [self popStack].							parent addFirstChild: child]]].	self pushStack: parent</body></methods><methods><class-id>Core.String</class-id> <category>tgen-converting</category><body package="T-Gen Core">asNonterminal	^self asSymbol</body></methods><methods><class-id>Core.String</class-id> <category>tgen-testing</category><body package="T-Gen Core">isTerminal	^true</body><body package="T-Gen Core">isTokenClassTerminal	^'&lt;*&gt;' match: self</body></methods><methods><class-id>Core.Number</class-id> <category>tgen-converting</category><body package="T-Gen Core">@ y 	"Answer a new pair (Point or OrderedPair or ...) whose x value is the receiver	and whose y value is the argument.  Optional.  No Lookup.  See Object 	documentation whatIsAPrimitive."	&lt;primitive: 18&gt;	^y reversePairWith: self</body><body package="T-Gen Core">reversePairWith: x	"Answer a new Point whose x value is the argument and whose y value is the receiver."	^Point x: x y: self</body></methods><methods><class-id>Core.Dictionary</class-id> <category>tgen-converting</category><body package="T-Gen Core">asDictionary	^self</body></methods><methods><class-id>Core.Dictionary</class-id> <category>tgen-accessing</category><body package="T-Gen Core">elements	^self values</body><body package="T-Gen Core">valuesAsSet	"Answer a set containing the receiver's values."	| aSet |	aSet := Set new: self size.	self do: [:each | aSet add: each].	^aSet</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>tgen-enumerating</category><body package="T-Gen Core">reverseDetect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the last element for which aBlock evaluates to true."	self reverseDo: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body></methods><methods><class-id>Core.Object</class-id> <category>tgen-converting</category><body package="T-Gen Core">@ anObject	"Answer an OrderedPair with the receiver as the x element and anObject as the y element."	^Tgen.OrderedPair x: self y: anObject</body></methods><methods><class-id>Core.Object</class-id> <category>tgen-testing</category><body package="T-Gen Core">isFSAFinalState	^false</body><body package="T-Gen Core">isGrammarProduction	^false</body><body package="T-Gen Core">isItemSet	^false</body><body package="T-Gen Core">isLR0Item	^false</body><body package="T-Gen Core">isLR1Item	^false</body><body package="T-Gen Core">isNonterminal	^false</body><body package="T-Gen Core">isPartitionTransitionMap	^false</body><body package="T-Gen Core">isTerminal	^false</body><body package="T-Gen Core">isTerminalNode	^false</body></methods><methods><class-id>Core.Object</class-id> <category>tgen-converting</category><body package="T-Gen Core">reversePairWith: x	"Answer a new OrderedPair whose x value is the argument and whose y value is the receiver."	^Tgen.OrderedPair x: x y: self</body></methods><methods><class-id>Core.Character class</class-id> <category>accessing untypeable characters</category><body package="T-Gen Core">endOfInput	"Answer the Character representing ctrl-d ."	^self value: 4</body><body package="T-Gen Core">leftParenthesis	"Answer the Character representing a left parenthesis."	^self value: 40</body><body package="T-Gen Core">period	"Answer the Character representing a carriage period."	^self value: 46</body><body package="T-Gen Core">poundSign	"Answer the Character representing a pound sign."	^self value: 35</body><body package="T-Gen Core">rightParenthesis	"Answer the Character representing a right parenthesis."	^self value: 41</body></methods><methods><class-id>Core.Character</class-id> <category>tgen-converting</category><body package="T-Gen Core">asString	"Answer the receiver converted into a String."	^String with: self</body></methods><methods><class-id>Core.Character</class-id> <category>tgen-copying</category><body package="T-Gen Core">copyUpToLast: char 	^self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>tgen-copying</category><body package="T-Gen Core">copyUpToLast: aCharacter 	"Answer a copy of the receiver from index 1 to the last occurrence of 	aCharacter, non-inclusive."	| index |	(index := self				prevIndexOf: aCharacter				from: self size				to: 1) isNil ifTrue: [^self].	^self copyFrom: 1 to: index - 1</body></methods><methods><class-id>Core.Symbol</class-id> <category>tgen-testing</category><body package="T-Gen Core">isNonterminal	^true</body><body package="T-Gen Core">isTerminal	^false</body><body package="T-Gen Core">isTokenClassTerminal	^false</body></methods><methods><class-id>Core.Set</class-id> <category>tgen-accessing</category><body package="T-Gen Core">first	"Answer an arbitrary element. If the receiver is empty, provide an error 	notification. The selector 'first' is used for compatibility with 	SequenceableCollections."	self emptyCheck.	self do: [:each | ^each]</body></methods><methods><class-id>Core.Set</class-id> <category>tgen-set operations</category><body package="T-Gen Core">intersect: aSet 	"Answer a new set which is the intersection of myself and aSet."	^self size &lt; aSet size		ifTrue: [self select: [:each | aSet includes: each]]		ifFalse: [aSet select: [:each | self includes: each]]</body></methods><methods><class-id>Core.Set</class-id> <category>tgen-removing</category><body package="T-Gen Core">removeFirst	"Answer (and remove) an arbitrary element. The selector 'removeFirst' is used for 	compatibility with SequenceableCollections."	| element |	element := self first.	self remove: element.	^element</body></methods><methods><class-id>Core.Set</class-id> <category>tgen-set operations</category><body package="T-Gen Core">union: aSet 	"Answer a new set which is the union of myself and aSet."	| newSet |	newSet := self species new.	newSet addAll: self; addAll: aSet.	^newSet</body></methods><initialize><class-id>Tgen.TableDrivenParser</class-id></initialize><initialize><class-id>Tgen.LLParserTable</class-id></initialize><initialize><class-id>Tgen.FSABasedScanner</class-id></initialize><initialize><class-id>Tgen.OptimizedScanner</class-id></initialize><initialize><class-id>Tgen.OptimizedLR1Parser</class-id></initialize><initialize><class-id>Tgen.FSAState</class-id></initialize><initialize><class-id>Tgen.Grammar</class-id></initialize><initialize><class-id>Tgen.LRParserState</class-id></initialize><initialize><class-id>Tgen.OptimizedLL1Parser</class-id></initialize><initialize><class-id>Tgen.HandCodedScanner</class-id></initialize><initialize><class-id>Tgen.TokenSpecScanner</class-id></initialize><initialize><class-id>Tgen.TokenSpecParser</class-id></initialize><initialize><class-id>Tgen.EscapedCharNode</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>