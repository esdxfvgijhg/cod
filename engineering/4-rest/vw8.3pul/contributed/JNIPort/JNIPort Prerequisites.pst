<?xml version="1.0"?><st-source><!-- Name: JNIPort PrerequisitesNotice: Copyright © 2006-2014 Joachim GeidelPortions of this software created by Chris Uppal are © Chris Uppal.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.- - Portions of this software which were created by Chris Uppal are covered by Chris Uppal's  license:"The terms under which you may use the software from this site are:    * You must not claim that you wrote it.    * You must not claim that you own it.    * You use it at your own risk.So you can pretty-much use it for what you like, provided you are honest about it."BundleName: JNIPort PrerequisitesBundleStructure: a Store.BundleForParcelComment: This bundle contains necessary prerequisites for the JNIPort bundle. This bundle is part of JNIPort and not intended to be used in isolation. If you want to use JNIPort, load the bundle JNIPort.To use JNIPort, you also need the following components:	- "JNIPort Prerequisites",	- "Registry" (version 28 or later),	- "FastCMethodPointers" (version 1.1 or later),	- "WeakCollections" (version 5 or later).Tests for JNIPort are available in "JNIPort Tests", and development tools in "JNIPort Tools".These components are available as parcels in the "Contributed" directory of the VisualWorks distribution. Alternatively, you can load them from the Cincom Public Repository. If you load JNIPort from a Store repository, you should configure the Store > Prerequisites settings in the VisualWorks Settings tool such that Store always loads the latest versions with blessing level "Development", and to search bundles and packages first. Some of the prerequisites are distributed with VisualWorks as parcels, e.g. the Registry parcel in the Contributed directory of the VisualWorks distribution. If you want to load these parcels instead of packages from a Store repository, set the search policy for prerequisites of type #any to "Search parcels first" in the Store > Prerequisites settings.DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))Parcel: nilParcelName: JNIPort PrerequisitesPrerequisiteDescriptions: #(#(#name 'DLLCC' #componentType #package))PrerequisiteParcels: #(#('DLLCC' '') #('DLLCC' ''))Version: 3.0a2Date: 5:10:06 PM August 22, 2014 --><time-stamp>From VisualWorks®, Pre-Release 8.0 (aug14.2) of 8 August 2014 on 22 August 2014 at 17:10:06</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>JNIPort</name><environment>Smalltalk</environment><private>false</private><imports>			Smalltalk.*			</imports><category>JNIPort-Namespace</category><attributes><package>JNIPort-Namespace</package></attributes></name-space><name-space><name>Tests</name><environment>JNIPort</environment><private>false</private><imports>			Smalltalk.*			private JNIPort.*			</imports><category>JNIPort-Namespace</category><attributes><package>JNIPort-Namespace</package></attributes></name-space><class><name>Mutex</name><environment>JNIPort</environment><super>Core.RecursionLock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-VW-Extensions</category><attributes><package>JNIPort-VW-Extensions</package></attributes></class><comment><class-id>JNIPort.Mutex</class-id><body>In Squeak, RecursionLocks are called Mutex. We introduce this class as an alias for RecursionLock such that JNIPort code can use Mutex in all Smalltalk dialects.</body></comment><class><name>VaList</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bytes nextOffset pointers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-StandardLibInterface</category><attributes><package>JNIPort-StandardLibInterface</package></attributes></class><comment><class-id>JNIPort.VaList</class-id><body>A VaList represents the "object" known in C as a 'va_list' (see &lt;stdarg.h&gt;). Note that with the current implementation, using VaLists from VisualWorks is not yet supported on 64bit systems, as the memory layout for va_list is completely different than on 32bit systems. For details, see e.g. the "System V Application Binary Interface" documentation at http://www.x86-64.org/documentation/abi.pdf, chapter 3.5.7.Many C functions take a variable number of parameters, for instance printf() does.  Using printf() as an example, the C delaration of printf() is something like:	extern int printf(char *, ...);where the ... means that it takes a variable number of extra arguments after the format specifier.  Dolphin's external interfacing provides no  general way of calling such functions (the best you can do is have a number of different wrappers that each have a different number of arguments).  This class is intended to help with that problem.The normal implementation of a function like printf() is to use the standard C feature called varargs, and the implementation of printf() might look something like:	#include &lt;stdarg.h&gt;	int	printf(char *format, ...)	{		int retval;		va_list args;		va_start(args, format);		retval = vprintf(format, args);		va_end(args);		return retval;	}Here the programmer uses &lt;stdargs.h&gt; to get a va_list structure that can be passed to the vprinf() function.  The important thing is that vprintf() takes a *fixed* number of arguments (one of which is a va_list), and so if we can fake the memory structure of a va_list, then we can call that function.  That wouldn't be a lot of use in general except that nearly every programmer who writes varags functions follows the above pattern, with two functions: function(args, ...) and vfunction(args, va_list) where the latter is the implementation of the former.  Since the "v" functions (they nearly always are given names starting with 'v') are useful in their own right, most APIs that use varargs functions also expose the "v" function equivalents.VaList is intended to help build (or decode) such structures. In one role it stands for an externally defined va_list (presumably passed as the argument to some varags callback).  In this role it is unusual for in that it does *NOT KNOW HOW BIG IT IS*.  It is your responsibility to use some other indicator (such as a printf()-style format string) to "know" what it should contain and not run off the end.  In the other role, it wraps a chunk of memory, and you build up a structure in that.The way it is used is rather Stream-like.  It maintains a current "position" (like a pointer) and increments that as you either read elements from it, or add elements to it.  The pointer is actually the index of the next 32-bit word to be read or written (we use 32-bits because C va_lists are built with 32-bits for each element -- except floats and doubles which are both represented as 64-bit).If you are building a VaList then you should try to give a reasonable estimate of how big it will eventually grow in the constructor (c.f. OrderedCollection); but the VaList will grow automatically if necessary.  Note that it does no great harm to use a VaList that is longer than is needed.If you are reading an externally-supplied VaList, then be very careful -- you are messing around at the level of C pointers, and all sorts of Bad Things can happen if you screw up.NB: when declaring a VaList in an external method's external descriptor, it seems that you have to specify it as "VaList*" rather than "VaList". See the implementation of String&gt;&gt;vsnprintfWithArguments: for an example of how to use VaLists.</body></comment><class><name>ReadStreamAdaptor</name><environment>JNIPort</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-CollectionAdaptors</category><attributes><package>JNIPort-CollectionAdaptors</package></attributes></class><comment><class-id>JNIPort.ReadStreamAdaptor</class-id><body>Adaptor to make any subject which understands &lt;#atEnd #next&gt; function as a readable stream; if it also understands #do: or #contents then it also forwards those.</body></comment><class><name>JavaLangStringStreamEncoder</name><environment>JNIPort</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bigEndian </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-StringEncoding</category><attributes><package>JNIPort-StringEncoding</package></attributes></class><comment><class-id>JNIPort.JavaLangStringStreamEncoder</class-id><body>JavaLangStringStreamEncoder is used for mapping data streams where Character data is encoded as in java.lang.String. In Java 5, this is UTF-16 according to the Unicode Standard version 4.0. The classes UTF16StreamEncoder and UnicodeStreamEncoder (as of VW 7.4.1) also both implement UTF-16, but according to the Unicode version 3.0 which did not yet have the notion of supplementary characters (code points above 0xFFFF). Supplementary characters, i.e. characters with code points in the range from 16r10000 to 16r10FFFF, have to be encoded as two surrogate code points according to Unicode 4.0. The largest possible code point is 16r10FFFF. JavaLangStringStreamEncoder replaces code points larger than the largest Unicode code point 16r10FFFF by "Character illegalCode" (16rFFFF). As the purpose of this encoder is to encode and decode Strings which come from the Java VM, never from files, we never write Byte Order Marks and also do not look for them at the beginning of Strings. As it could happen in the future that the encoding used in java.lang.String changes (as between Java 1.4 and Java 5 by adding support for supplementary characters), and may not match whatever encodings are available in VisualWorks, it is better not to use the StreamEncoders coming with VisualWorks, even if this means that this class happens to implement an encoding provided by some other StreamEncoder class.For additional information concerning supplementary characters in Java see http://java.sun.com/developer/technicalArticles/Intl/Supplementary/</body></comment><class><name>ExceptionSetWithExclusions</name><environment>JNIPort</environment><super>Core.ExceptionSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>exclusions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-VW-Extensions</category><attributes><package>JNIPort-VW-Extensions</package></attributes></class><comment><class-id>JNIPort.ExceptionSetWithExclusions</class-id><body>Instances of class ExceptionSetWithExclusions hold a collection of Exception classes or Signals to allow a handler to serve for many different Exception types or Signals that are not related by inheritance.  Instances also hold a collection of Exception classes or Signals which are explicitly not handled. This allows to exclude particular subclasses of an Exception class from error handling. An example where this is useful is a situation where Exception or Notification must be handled, but EndOfStreamNotification should not be handled.ExceptionSetWithExclusions are created by sending #- to an Exception class, ExceptionSet, or Signal, e.g. 	[  ]		on: (Exception1, Exception2) - Exception3		do: [:ex |  ]Caveat: When nesting an ExceptionSetWithExclusions in another ExceptionSet, the outer ExceptionSet takes precedence. If the outer ExceptionSet includes an Exception, then the Exception will be handled even if it is excluded by the inner ExceptionSetWithExclusions, see examples below. It is best to keep the "exception arithmetics" simple to avoid errors in ExceptionSet creation. Examples:An ExceptionsSetWithExclusions does not handle it's exclusions:	['' readStream next] on: Error - EndOfStreamNotification do: [:ex | ex return: 'handled']		"-&gt; nil"Adding an ExceptionSetWithExclusions to an ExceptionSet does not exclude its exclusions from the other elements. In the following example, the ExceptionSet includes the class Exception, which will handle the EndOfStreamNotification:	['' readStream next] on: Exception , (Error - EndOfStreamNotification) do: [:ex | ex return: 'handled']		"-&gt; 'handled'	"Adding an exception descriptor to an ExceptionSetWithExclusions does not override the exclusions:	['' readStream next] on: (Error - EndOfStreamNotification) , Exception do: [:ex | ex return: 'handled']		"-&gt; nil"Instance Variables	exclusions	&lt;ExceptionSet&gt;	Set of exceptions which are not handled by the receiver</body></comment><class><name>PluggableSet</name><environment>JNIPort</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>hashBlock equalBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-VW-Extensions</category><attributes><package>JNIPort-VW-Extensions</package></attributes></class><comment><class-id>JNIPort.PluggableSet</class-id><body>PluggableSets allow the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the set which in turn can heavily improve the performance of sets and dictionaries.Instance variables:	hashBlock	&lt;BlockContext&gt;	A one argument block used for hashing the elements.	equalBlock	&lt;BlockContext&gt;	A two argument block used for comparing the elements.</body></comment><class><name>GhostMethod</name><environment>JNIPort</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sourceDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-GhostClasses</category><attributes><package>JNIPort-GhostClasses</package></attributes></class><comment><class-id>JNIPort.GhostMethod</class-id><body>A GhostMethod is a CompiledMethod which can store its source code in an instance variable. This is useful for methods compiled at runtime where compilation bypasses the usual mechanisms for change set management and source storage. Usually, GhostMethods don't store their source code, but for debugging, the source can be appended to the method.Instance Variables:	sourceDescriptor	&lt;String | nil&gt;	the source code of the method</body></comment><class><name>JNIPortCallback</name><environment>JNIPort</environment><super>External.CCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-External</category><attributes><package>JNIPort-External</package></attributes></class><comment><class-id>JNIPort.JNIPortCallback</class-id><body>JNIPortCallback is an alias for CCallback such that we can use a uniform class name in all Smalltalk dialects.</body></comment><class><name>CollectionAdaptor</name><environment>JNIPort</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject diyIncludes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-CollectionAdaptors</category><attributes><package>JNIPort-CollectionAdaptors</package></attributes></class><comment><class-id>JNIPort.CollectionAdaptor</class-id><body>Adaptor to make any subject which understands &lt;#add:, #do: #remove:ifAbsent: #size&gt; and (optionally) #includes: function as a Collection.</body></comment><class><name>ArrayAdaptor</name><environment>JNIPort</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject diyLoop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-CollectionAdaptors</category><attributes><package>JNIPort-CollectionAdaptors</package></attributes></class><comment><class-id>JNIPort.ArrayAdaptor</class-id><body>Adaptor to make any subject which understands &lt;#size, #at: #at:put:&gt; and (optionally) #from:to:keysAndValuesDo:, function as a SequenceableCollection.</body></comment><class><name>JNIPortAssertionFailure</name><environment>JNIPort</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-VW-Extensions</category><attributes><package>JNIPort-VW-Extensions</package></attributes></class><comment><class-id>JNIPort.JNIPortAssertionFailure</class-id><body>An AssertionFailureSignal is raised when an assertion fails.</body></comment><class><name>JNIPortExternalStructure</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>externalData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-External</category><attributes><package>JNIPort-External</package></attributes></class><comment><class-id>JNIPort.JNIPortExternalStructure</class-id><body>ExternalStructure is a wrapper class for instances of subclasses of CDatum. By implementing subclasses, one can add customized methods for dealing with external data, which is not possible if one uses instances of CDatum directly. Subclass responsibilities	class methods		baseCType 		answers an instance of CType describing the kind of external data wrapped by the subclassInstance Variables:	externalData	&lt;CCompositePointer&gt;	external data wrapped by the ExternalStructure</body></comment><class><name>StandardLibInterface</name><environment>JNIPort</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private JNIPort.StandardLibInterfaceDictionary.*			</imports><category>JNIPort-StandardLibInterface</category><attributes><includeFiles><item>stdio.h</item> <item>stdarg.h</item></includeFiles><includeDirectories><item>include</item></includeDirectories><libraryFiles><item>msvcrt.dll</item> <item>libc.so.6</item> <item>libc.sl</item> <item>libSystem.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>JNIPort-StandardLibInterface</package></attributes></class><comment><class-id>JNIPort.StandardLibInterface</class-id><body>StandardLibInterface contains wrapper methods for functions from the C standard library (libc). Currently, it contains only wrappers for snprintf(), vsnprintf() and strcmp().</body></comment><class><name>JNIPortWeakRegistry</name><environment>JNIPort</environment><super>OS.HandleRegistry</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>JNIPort-VW-Extensions</package></attributes></class><comment><class-id>JNIPort.JNIPortWeakRegistry</class-id><body>JNIPortWeakRegistry is a subclass of HandleRegistry which serves as an alias for that class, such that JNIPort can use the same class name in all Smalltalk dialects.</body></comment><class><name>SetAdaptor</name><environment>JNIPort</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-CollectionAdaptors</category><attributes><package>JNIPort-CollectionAdaptors</package></attributes></class><comment><class-id>JNIPort.SetAdaptor</class-id><body>Adaptor to make any subject which understands &lt;#add:, #do: #remove:ifAbsent: #size #includes&gt; function as a Set.</body></comment><class><name>DictionaryAdaptor</name><environment>JNIPort</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>subject diyIncludes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-CollectionAdaptors</category><attributes><package>JNIPort-CollectionAdaptors</package></attributes></class><comment><class-id>JNIPort.DictionaryAdaptor</class-id><body>Adaptor to make any subject which understands &lt;#at:ifAbsent #at:put: #keysAndValuesDo: #removeKey:ifAbsent: #size&gt; and, optionaly &lt;#includesKey:&gt; function as a Dictionary.</body></comment><class><name>WriteStreamAdaptor</name><environment>JNIPort</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-CollectionAdaptors</category><attributes><package>JNIPort-CollectionAdaptors</package></attributes></class><comment><class-id>JNIPort.WriteStreamAdaptor</class-id><body>Adaptor to make any subject which understands &lt;#atEnd #nextPut:&gt; function as a readable stream; if the subject also understands #close or #contents then it also forwards those.</body></comment><class><name>JavaModifiedUTF8StreamEncoder</name><environment>JNIPort</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-StringEncoding</category><attributes><package>JNIPort-StringEncoding</package></attributes></class><comment><class-id>JNIPort.JavaModifiedUTF8StreamEncoder</class-id><body>JavaModifiedUTF8StreamEncoder is used for mapping data streams where Character data is mapped using the variant of UTF-8 stream encoding as defined in the JNI 1.4.0 Specification included in the JDK 1.5.0, Chapter 3 "JNI Types and Data Structures", section "Modified UTF-8 Strings".The spec describes the differences from UTF-8 as follows: "There are two differences between this format and the standard UTF-8 format. First, the null character (char)0 is encoded using the two-byte format rather than the one-byte format. This means that modified UTF-8 strings never have embedded nulls. Second, only the one-byte, two-byte, and three-byte formats of standard UTF-8 are used. The Java VM does not recognize the four-byte format of standard UTF-8; it uses its own two-times-three-byte format instead."In comparison with UTF8StreamEncoder (as of VW 7.4.1) the implementation has an additional check mandated by The Unicode Standard Version 4.1: UTF-8 never produces more than 4 bytes per character, and the largest possible code point is 16r10FFFF. The code of UTF8StreamEncoder is a bit misleading, as it can answer characterSizes of up to 7 bytes, but this would only occur if using an illegal code point. JavaModifiedUTF8StreamEncoder replaces code points larger than the largest Unicode code point 16r10FFFF by "Character illegalCode" (16rFFFF). For supplementary characters, i.e. characters with code points in the range from 16r10000 to 16r10FFFF, two 3-byte surrogate code point encodings are used as defined in the JNI specification.For additional information concerning supplementary characters in Java see http://java.sun.com/developer/technicalArticles/Intl/Supplementary/</body></comment><class><name>JNIPortNotification</name><environment>JNIPort</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-VW-Extensions</category><attributes><package>JNIPort-VW-Extensions</package></attributes></class><comment><class-id>JNIPort.JNIPortNotification</class-id><body>JNIPort.Notification is like normal Notification, except that it always emits its description on the system Transcript when it is not handled.</body></comment><class><name>JNIPortUtility</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-VW-Extensions</category><attributes><package>JNIPort-VW-Extensions</package></attributes></class><comment><class-id>JNIPort.JNIPortUtility</class-id><body>JNIPortUtility is a class holding some utility methods which need different implementations in different Smalltalk dialects.</body></comment><class><name>OrderedCollectionAdaptor</name><environment>JNIPort</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>subject diyLoop diyReplace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-CollectionAdaptors</category><attributes><package>JNIPort-CollectionAdaptors</package></attributes></class><comment><class-id>JNIPort.OrderedCollectionAdaptor</class-id><body>Adaptor to make any subject which understands &lt;#size, #at: #at:put: #add: #removeAtIndex:&gt; and (optionally) &lt;#from:to:keysAndValuesDo: #removeAll #replaceFrom:to:with:startingAt:&gt;, function as a SequencedGrowableCollection.So far, only a few methods are implemented, which are not enough to be compatible with OrderedCollection. Additional methods should be added as needed.</body></comment><shared-variable><name>Default</name><environment>JNIPort.StandardLibInterface</environment><private>true</private><constant>false</constant><category>default</category><initializer></initializer><attributes><package>JNIPort-StandardLibInterface</package></attributes></shared-variable><shared-variable><name>EncoderStream</name><environment>JNIPort.JavaModifiedUTF8StreamEncoder</environment><private>false</private><constant>false</constant><category>encoding</category><attributes><package>JNIPort-StringEncoding</package></attributes></shared-variable><shared-variable><name>StandardLibInterfaceDictionary</name><environment>JNIPort</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>JNIPort-StandardLibInterface</package></attributes></shared-variable><shared-variable><name>IsGhostClassMethod</name><environment>JNIPort.GhostMethod</environment><private>true</private><constant>false</constant><category>prototypes</category><attributes><package>JNIPort-GhostClasses</package></attributes></shared-variable><methods><class-id>JNIPort.VaList</class-id> <category>operations</category><body package="JNIPort-StandardLibInterface">ensureCapacity: anInteger	"ensure that we have the capacity to hold a total of at least anInteger 32-bit elements"	self capacity &lt; anInteger ifTrue: [self capacity: anInteger + self class capacityIncrement].</body><body package="JNIPort-StandardLibInterface">ensureExtraCapactity: anInteger 	"ensure that we have the capacity to add at least anInteger more 32-bit elements without		resizing"	self ensureCapacity: anInteger + self position</body><body package="JNIPort-StandardLibInterface">ensureInitialized	"private -- ensure that we are initialized properly, this is needed	since we may be created in an uninitialized form directly by the	VM"	nextOffset isNil ifTrue: [nextOffset := 1].</body></methods><methods><class-id>JNIPort.VaList</class-id> <category>accessing</category><body package="JNIPort-StandardLibInterface">asPointer	^bytes sizeInBytes &lt; self elementSize 		ifTrue: [CPointerType nullPointer]		ifFalse: [bytes]</body><body package="JNIPort-StandardLibInterface">capacity	"answer how many 32-bit slots-worth of data we currently have space allocated	to hold.	If this is VaList refers to externally supplied memory (e.g. provided by a callback)	then this measure is meaningless, and we answer 0"	^bytes sizeInBytes // self elementSize</body><body package="JNIPort-StandardLibInterface">capacity: anInteger 	"set how many 32-bit slots-worth of data we currently have space allocated	to hold."	| length newBytes |	length := anInteger * self elementSize.	newBytes := bytes class new: length.	newBytes 		replaceBytesFrom: 1		to: bytes sizeInBytes		with: bytes		startingAt: 1.	bytes := newBytes.	nextOffset := nextOffset min: bytes sizeInBytes</body><body package="JNIPort-StandardLibInterface">elementSize	"Answers the minimum number of bytes for an element of a VaList."	^4</body><body package="JNIPort-StandardLibInterface">pointers	^pointers</body><body package="JNIPort-StandardLibInterface">position	"answer the index of the next 32-bit word to be read from or	written to this list"	self ensureInitialized.	"internally we use byte offsets so we have to convert"	^nextOffset // self elementSize + 1</body><body package="JNIPort-StandardLibInterface">position: anInteger	"set the index of the next 32-bit word to be read from or	written to this list"	"internally we use byte offsets so we have to convert"	nextOffset := (anInteger - 1) * self elementSize + 1.</body></methods><methods><class-id>JNIPort.VaList</class-id> <category>adding</category><body package="JNIPort-StandardLibInterface">addAddressOf: anObject 	"add the in-memory address of anObject to our list, expanding if necessary.	NB: be very carefull with this; if anObject is moved or garbage collected while	this VaList is still in use, then Bad Things will happen.  Note that adding the	address to the VaList does not itself protect anObject from GC"	| pointer |	pointer := anObject gcCopyToHeap.	pointers add: pointer.	pointer type dataSize &gt; 4		ifTrue: [self addUnsignedInt64: pointer referentAddress]		ifFalse: [self addUnsignedInt: pointer referentAddress]</body><body package="JNIPort-StandardLibInterface">addBoolean: aBool 	"add the C representation of aBoolean our list, expanding if necessary"	self ensureExtraCapactity: 1.	bytes booleanLongAt: nextOffset put: aBool.	self incrementPositionBy: 1</body><body package="JNIPort-StandardLibInterface">addChar: aCharacter 	"add a 'char' to our list, expanding if necessary"	"chars in a C va_list are represented as 32-bit ints"	self addUnsignedChar: aCharacter</body><body package="JNIPort-StandardLibInterface">addDouble: aFloat	"add a 'double' to our list, expanding if necessary"	self ensureExtraCapactity: 2.	bytes doubleAt: nextOffset put: aFloat asDouble.	self incrementPositionBy: 2.</body><body package="JNIPort-StandardLibInterface">addFloat: aFloat 	"add a 'float' to our list, expanding if necessary"	"floats are promoted to double in a C va_list"	self addDouble: aFloat</body><body package="JNIPort-StandardLibInterface">addInt64: anInteger	"add a (signed) '__int64' to our list, expanding if necessary"	self ensureExtraCapactity: 2.	bytes longLongAt: nextOffset put: anInteger.	self incrementPositionBy: 2.</body><body package="JNIPort-StandardLibInterface">addInt: anInteger	"add a (signed) 'int' to our list, expanding if necessary"	self ensureExtraCapactity: 1.	bytes longAt: nextOffset put: anInteger.	self incrementPositionBy: 1.</body><body package="JNIPort-StandardLibInterface">addLong: anInteger	"add a (signed) 'long' to our list, expanding if necessary"	StandardLibInterface sizeofLongIs64Bit 		ifTrue: [self addInt64: anInteger]		ifFalse: [self addInt: anInteger]</body><body package="JNIPort-StandardLibInterface">addShort: anInteger	"add a (signed) 'short' to our list, expanding if necessary"	"shorts in a C va_list are represented as 32-bit unsigned ints"	self addInt: anInteger.</body><body package="JNIPort-StandardLibInterface">addSignedChar: aCharacter	"add a 'signed char' to our list, expanding if necessary"	"chars in a C va_list are represented as 32-bit ints (we don't care about sign)"	self addInt: (aCharacter codePoint).</body><body package="JNIPort-StandardLibInterface">addUnsignedChar: aCharacter 	"add an 'unsigned char' to our list, expanding if necessary"	"chars in a C va_list are represented as 32-bit ints"	self ensureExtraCapactity: 1.	bytes unsignedLongAt: nextOffset put: aCharacter codePoint.	self incrementPositionBy: 1</body><body package="JNIPort-StandardLibInterface">addUnsignedInt64: anInteger	"add an 'unsigned __int64' to our list, expanding if necessary"	self ensureExtraCapactity: 2.	bytes unsignedLongLongAt: nextOffset put: anInteger.	self incrementPositionBy: 2.</body><body package="JNIPort-StandardLibInterface">addUnsignedInt: anInteger	"add an 'unsigned int' to our list, expanding if necessary"	self addUnsignedLong: anInteger</body><body package="JNIPort-StandardLibInterface">addUnsignedLong: anInteger 	"add an 'unsigned long' to our list, expanding if necessary"	self ensureExtraCapactity: 1.	bytes unsignedLongAt: nextOffset put: anInteger.	self incrementPositionBy: 1</body><body package="JNIPort-StandardLibInterface">addUnsignedShort: anInteger	"add an 'unsigned short' to our list, expanding if necessary"	"unsigned shorts in a C va_list are represented as 32-bit unsigned ints"	self addUnsignedInt: anInteger.</body></methods><methods><class-id>JNIPort.VaList</class-id> <category>reading</category><body package="JNIPort-StandardLibInterface">nextAddress	"interpret the next 32 or 64 bits (depending on platform) in the list as a 'void*' (address) and	answer that.	Answers an instance of JNIPortExternalStructure"	^ self nextInstanceOfClass: JNIPortExternalStructure.</body><body package="JNIPort-StandardLibInterface">nextBoolean	"interpret the next 32-bit word in the list as a Boolean and	answer that"	"use C interpretation where anything exept 0 is true"	^ self nextInt ~= 0.</body><body package="JNIPort-StandardLibInterface">nextChar	"interpret the next 32-bit word in the list as a 'char' and	answer that"	^ Character codePoint: self nextInt.</body><body package="JNIPort-StandardLibInterface">nextDouble	"interpret the next two 32-bit words in the list as an 'double' and	answer that"	| answer |	self ensureInitialized.	answer := bytes doubleAt: nextOffset.	self incrementPositionBy: 2.	^ answer.</body><body package="JNIPort-StandardLibInterface">nextFloat	"interpret the next two 32-bit words in the list as an 'float' and	answer that	NB: we read 64-bits because C encodes floats as doubles in this context"	^ self nextDouble asFloat</body><body package="JNIPort-StandardLibInterface">nextInstanceOfClass: aClass	"interpret the next 32 or 64 bits (depending on the platform) in the list as the address of	an instance of aClass and answer that.	aClass must have a factory method called #fromAddress: that takes an Integer	as parameter (e.g. String does)"	| address pointer pointerType |	pointerType := aClass baseCType pointerType.	address := pointerType dataSize &gt; 4 ifTrue: [self nextUnsignedInt64] ifFalse: [self nextUnsignedInt].	pointer := pointerType newOfAddress: address.	^aClass fromAddress: pointer</body><body package="JNIPort-StandardLibInterface">nextInt	"interpret the next 32-bit word in the list as an 'int' and	answer that"	| answer |	self ensureInitialized.	answer := bytes longAt: nextOffset.	self incrementPositionBy: 1.	^answer</body><body package="JNIPort-StandardLibInterface">nextInt64	"interpret the next two 32-bit words in the list as an '__int64' and	answer that"	| answer |	self ensureInitialized.	answer := bytes longLongAt: nextOffset.	self incrementPositionBy: 2.	^answer</body><body package="JNIPort-StandardLibInterface">nextLong	"interpret the next 32-bit word in the list as an 'long' and	answer that"	| answer |	self ensureInitialized.	StandardLibInterface sizeofLongIs64Bit		ifTrue: 			[answer := bytes longLongAt: nextOffset.			self incrementPositionBy: 2]		ifFalse: 			[answer := bytes longAt: nextOffset.			self incrementPositionBy: 1].	^answer</body><body package="JNIPort-StandardLibInterface">nextShort	"interpret the next 32-bit word in the list as a 'short' and	answer that"	^ self nextInt.</body><body package="JNIPort-StandardLibInterface">nextSignedChar	"interpret the next 32-bit word in the list as a 'signed char' and	answer that"	^ Character codePoint: self nextInt.</body><body package="JNIPort-StandardLibInterface">nextUnsignedChar	"interpret the next 32-bit word in the list as an 'unsigned char' and	answer that"	^ Character codePoint: self nextUnsignedInt.</body><body package="JNIPort-StandardLibInterface">nextUnsignedInt	"interpret the next 32-bit word in the list as an 'unsigned int' and	answer that"	| answer |	self ensureInitialized.	answer := bytes unsignedLongAt: nextOffset.	self incrementPositionBy: 1.	^ answer.</body><body package="JNIPort-StandardLibInterface">nextUnsignedInt64	"interpret the next two 32-bit words in the list as an 'unsigned __int64' and	answer that"	| answer |	self ensureInitialized.	answer := bytes unsignedLongLongAt: nextOffset.	self incrementPositionBy: 2.	^ answer.</body><body package="JNIPort-StandardLibInterface">nextUnsignedLong	"interpret the next 32-bit word in the list as an 'unsigned long' and	answer that"	| answer |	self ensureInitialized.	answer := bytes unsignedLongAt: nextOffset.	self incrementPositionBy: 1.	^ answer.</body><body package="JNIPort-StandardLibInterface">nextUnsignedShort	"interpret the next 32-bit word in the list as an 'unsigned short' and	answer that"	^ self nextUnsignedInt.</body></methods><methods><class-id>JNIPort.VaList</class-id> <category>initialize-release</category><body package="JNIPort-StandardLibInterface">initialize	self initialize: 0</body><body package="JNIPort-StandardLibInterface">initialize: anInteger 	bytes := UninterpretedBytes new: anInteger * 4.	nextOffset := 1.	pointers := OrderedCollection new</body><body package="JNIPort-StandardLibInterface">initializeFrom: aSequenceableCollection 	| sizeInBytes |	sizeInBytes := aSequenceableCollection inject: 0				into: [:bytesSoFar :each | bytesSoFar + (each baseCType dataSize max: 4)].	bytes := UninterpretedBytes new: sizeInBytes.	nextOffset := 1.	pointers := OrderedCollection new.	aSequenceableCollection do: [:each | each addToVaList: self]</body></methods><methods><class-id>JNIPort.VaList</class-id> <category>converting</category><body package="JNIPort-StandardLibInterface">asVaList	"answer a VaList with the same contents as this collection.  This is implemented here	so that VaLists can be passed to methods that expect to get SequencedCollections that	they then convert to VaLists"	"we are already a VaList"	^ self.</body></methods><methods><class-id>JNIPort.VaList</class-id> <category>positioning</category><body package="JNIPort-StandardLibInterface">incrementPositionBy: anInteger	"increment the index of the next 32-bit word to be read from or	written to this list"	nextOffset := nextOffset + (anInteger * self elementSize).</body></methods><methods><class-id>JNIPort.VaList class</class-id> <category>instance creation</category><body package="JNIPort-StandardLibInterface">from: aSequenceableCollection	^self basicNew initializeFrom: aSequenceableCollection</body><body package="JNIPort-StandardLibInterface">new	"answer a new instance containing its own buffer and with the default	capacity"	^ self new: self defaultCapacity.</body><body package="JNIPort-StandardLibInterface">new: anInteger	"answer a new instance initialized with the capacity to hold anInteger 32-bit words of	data without having to grow itself"	^self basicNew initialize: anInteger</body></methods><methods><class-id>JNIPort.VaList class</class-id> <category>constants</category><body package="JNIPort-StandardLibInterface">capacityIncrement	"answer how many extra 32-bit slots we add each time we	expand ourself"	^ 3.</body><body package="JNIPort-StandardLibInterface">defaultCapacity	"answer how many 32-bit slots-worth of capacity to given instances by	default"	^ 3.</body></methods><methods><class-id>JNIPort.ReadStreamAdaptor</class-id> <category>enumerating</category><body package="JNIPort-CollectionAdaptors">do: a1Block	"if our subject understands #do: then answer the result of forwarding to it,	otherwise execure the loop ourselves"	^ (subject respondsTo: #do:)		ifTrue: [subject do: a1Block]		ifFalse: [super do: a1Block].</body></methods><methods><class-id>JNIPort.ReadStreamAdaptor</class-id> <category>accessing</category><body package="JNIPort-CollectionAdaptors">contents	"if our subject understands #contents then answer the result of forwarding to it,	otherwise throw an error"	^subject contents</body><body package="JNIPort-CollectionAdaptors">flush	"subclass responsibility - do nothing, this is for compatibility with BufferedExternalStreams."</body><body package="JNIPort-CollectionAdaptors">next	"one of the root methods for &lt;ReadStream&gt;"	^ subject next.</body><body package="JNIPort-CollectionAdaptors">nextPut: anObject 	"Provide an error notification that the receiver does not implement this message."	self shouldNotImplement</body></methods><methods><class-id>JNIPort.ReadStreamAdaptor</class-id> <category>testing</category><body package="JNIPort-CollectionAdaptors">atEnd	"one of the root methods for &lt;ReadStream&gt;"	^ subject atEnd.</body><body package="JNIPort-CollectionAdaptors">isReadable	"Answer whether the stream implements #next."	^true</body><body package="JNIPort-CollectionAdaptors">isWritable	"Answer whether the stream implements #nextPut:."	^false</body></methods><methods><class-id>JNIPort.ReadStreamAdaptor</class-id> <category>status</category><body package="JNIPort-CollectionAdaptors">close	(subject respondsTo: #close) ifTrue: [subject close].	subject := nil</body></methods><methods><class-id>JNIPort.ReadStreamAdaptor</class-id> <category>initializing</category><body package="JNIPort-CollectionAdaptors">subject: anObject 	"private -- set the object to which we forward the basic stream messages"	subject := anObject</body></methods><methods><class-id>JNIPort.ReadStreamAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-CollectionAdaptors">for: anObject	"answer a new instance which wraps anObject and forwards #atEnd: and #next: to it.  If it	also understands #do:, #next:into:startingAt:, or #contents then they are also forwarded"	^ (self basicNew)		subject: anObject;		yourself.</body></methods><methods><class-id>JNIPort.JavaLangStringStreamEncoder</class-id> <category>initialize</category><body package="JNIPort-StringEncoding">initialize	bigEndian := UninterpretedBytes isBigEndian.	super initialize</body></methods><methods><class-id>JNIPort.JavaLangStringStreamEncoder</class-id> <category>private</category><body package="JNIPort-StringEncoding">basicNextFrom: aStream 	"Reads a character from aStream. Does not substitute surrogate characters, this is done in #nextFrom:. This method is copied from UTF16StreamEncoder&gt;&gt;nextFrom:."	| c1 c2 |	c1 := aStream next.	c1 == nil ifTrue: [^nil].	c2 := aStream next.	c2 == nil ifTrue: [^nil].	^bigEndian 		ifTrue: [Character value: (c1 bitShift: 8) + c2]		ifFalse: [Character value: (c2 bitShift: 8) + c1]</body><body package="JNIPort-StringEncoding">nextPutTwoBytes: anInteger on: aStream 	"Writes anInteger as two bytes to aStream."	| highByte lowByte |	highByte := anInteger bitShift: -8.	lowByte := anInteger bitAnd: 16rFF.	bigEndian 		ifTrue: 			[aStream				nextPut: highByte;				nextPut: lowByte]		ifFalse: 			[aStream				nextPut: lowByte;				nextPut: highByte]</body></methods><methods><class-id>JNIPort.JavaLangStringStreamEncoder</class-id> <category>accessing</category><body package="JNIPort-StringEncoding">nextFrom: aStream 	"Decodes the next byte(s) in the UTF encoded stream, and answers the character. If the bytes read are a trailing surrogate (without preceding leading surrogate), then skip it and decode the next bytes. If the bytes read represent a leading surrogate, also decode the following bytes. If they are a trailing surrogate, answer the supplementary character represented by combining the two surrogates. If the character after a leading surrogate is not a trailing surrogate, then skip the leading surrogate and answer the character following it."	| character leadingSurrogate |	character := self basicNextFrom: aStream.	character == nil ifTrue: [^nil].	"Skip leading surrogates which are followed by another leading surrogate. Look for the next character which is not a leading surrogate."	leadingSurrogate := nil.	[character isLeadingSurrogate] whileTrue: 			[leadingSurrogate := character.			character := self basicNextFrom: aStream.			character == nil 				ifTrue: 					[^nil	"There have been only leading surrogates so far, and the end of the stream has been reached. There is no valid character to answer."]].	^(leadingSurrogate ~~ nil and: [character isTrailingSurrogate]) 		ifTrue: [character := Character combineSurrogate: leadingSurrogate with: character]		ifFalse: 			["Skip isolated trailing surrogates."			[character isTrailingSurrogate] whileTrue: 					[character := self basicNextFrom: aStream.					character == nil 						ifTrue: 							[^nil	"There have been only trailing surrogates so far, and the end of the stream has been reached. There is no valid character to answer."]].			character]</body><body package="JNIPort-StringEncoding">nextPut: aCharacter on: aStream 	"Encodes aCharacter and writes it to aStream. Replaces Characters with code points larger than the largest legal value by the code point representing illegal Characters."	| codePoint |	codePoint := aCharacter asInteger.	16r10FFFF &lt; codePoint ifTrue: [codePoint := Character illegalCode].	16rFFFF &gt;= codePoint 		ifTrue: [self nextPutTwoBytes: codePoint on: aStream]		ifFalse: 			[self				nextPutTwoBytes: aCharacter leadingSurrogate on: aStream;				nextPutTwoBytes: aCharacter trailingSurrogate on: aStream].	^aCharacter</body></methods><methods><class-id>JNIPort.JavaLangStringStreamEncoder</class-id> <category>querying</category><body package="JNIPort-StringEncoding">characterSize: aCharacter 	"Returns the size in bytes of &lt;aCharacter&gt;, which is 2 except for supplementary characters. For supplementary characters, i.e. characters with code points in the range 16r10000 to 16r10FFFF, the answer is 4 bytes, as these characters are represented by two surrogate code points. Characters with code points beyond 16r10FFFF will be replaced by Character illegalCode, such that they need 2 bytes."	^aCharacter isSupplementary ifTrue: [4] ifFalse: [2]</body></methods><methods><class-id>JNIPort.JavaLangStringStreamEncoder class</class-id> <category>accessing</category><body package="JNIPort-StringEncoding">streamEncodingType	"Answer the symbol of this encoding."	^#JavaLangString</body></methods><methods><class-id>JNIPort.ExceptionSetWithExclusions</class-id> <category>removing</category><body package="JNIPort-VW-Extensions">- anExceptionSelector 	self exclude: anExceptionSelector.	^self</body></methods><methods><class-id>JNIPort.ExceptionSetWithExclusions</class-id> <category>copying</category><body package="JNIPort-VW-Extensions">copyEmpty: aSize 	^(super copyEmpty: aSize)		initialize;		yourself</body></methods><methods><class-id>JNIPort.ExceptionSetWithExclusions</class-id> <category>testing</category><body package="JNIPort-VW-Extensions">accepts: anExceptionCreator 	"Answer whether the receiver accepts the argument--this is roughly	equivalent to saying that the receiver handles exceptions that are	created by the argument. Answer false if one of the exclusions accepts	the argument."	^(exclusions accepts: anExceptionCreator) not 		and: [super accepts: anExceptionCreator]</body><body package="JNIPort-VW-Extensions">handles: anException 	"Answer true if the receiver handles anException. Answer false if one of the 	exclusions handles the argument."	^(exclusions handles: anException) not and: [super handles: anException]</body></methods><methods><class-id>JNIPort.ExceptionSetWithExclusions</class-id> <category>initialize-release</category><body package="JNIPort-VW-Extensions">initialize	exclusions := ExceptionSet new</body></methods><methods><class-id>JNIPort.ExceptionSetWithExclusions</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">exclude: anExceptionSelector	exclusions add: anExceptionSelector</body></methods><methods><class-id>JNIPort.ExceptionSetWithExclusions class</class-id> <category>instance creation</category><body package="JNIPort-VW-Extensions">new	^(super new)		initialize;		yourself</body><body package="JNIPort-VW-Extensions">with: anExceptionSelector1 exclude: anExceptionSelector2 	^(self with: anExceptionSelector1)		exclude: anExceptionSelector2;		yourself</body></methods><methods><class-id>JNIPort.PluggableSet</class-id> <category>copying</category><body package="JNIPort-VW-Extensions">copyEmpty: aSize	^(super copyEmpty: aSize)		hashBlock: self hashBlock;		equalBlock: self equalBlock;		yourself</body></methods><methods><class-id>JNIPort.PluggableSet</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">equalBlock	^equalBlock ifNil: [[:object1 :object2 | object1 = object2]]</body><body package="JNIPort-VW-Extensions">equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock := aBlock</body><body package="JNIPort-VW-Extensions">hashBlock	^hashBlock ifNil: [[:object | object hash]]</body><body package="JNIPort-VW-Extensions">hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock := aBlock</body></methods><methods><class-id>JNIPort.PluggableSet</class-id> <category>private</category><body package="JNIPort-VW-Extensions">findElementOrNil: anObject	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."	| index length probe pass |	length := self basicSize.	pass := 1.	index := self initialIndexFor: (self hashBlock value: anObject) boundedBy: length.	[(probe := self basicAt: index) == nil or: [self equalBlock value: probe value: anObject]]		whileFalse: 			[(index := index + 1) &gt; length				ifTrue: 					[index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findElementOrNil: anObject]]].	^index</body></methods><methods><class-id>JNIPort.GhostMethod</class-id> <category>accessing</category><body package="JNIPort-GhostClasses">sourceDescriptor: aString 	"Set the source code of the method to be aString. The name of this method is chosen such that it is compatible to Dolphin Smalltalk."	sourceDescriptor := aString</body></methods><methods><class-id>JNIPort.GhostMethod</class-id> <category>source code management</category><body package="JNIPort-GhostClasses">getSource	"Answer the source code for the receiver.  Answer nil if this method	has no stored source."	^sourceDescriptor</body><body package="JNIPort-GhostClasses">methodSources	^self getSource ifNotNil: [:src | MethodSourceCollection source: src]</body></methods><methods><class-id>JNIPort.GhostMethod</class-id> <category>testing</category><body package="JNIPort-GhostClasses">isGhostMethod	^true</body></methods><methods><class-id>JNIPort.GhostMethod class</class-id> <category>private</category><body package="JNIPort-GhostClasses">generateIsGhostClassMethod	| methodNode |	methodNode := self compilerClass new 				compile: 'isGhostClass ^true.'				in: self				notifying: nil				ifFail: [nil].	^methodNode generate</body></methods><methods><class-id>JNIPort.GhostMethod class</class-id> <category>instance creation</category><body package="JNIPort-GhostClasses">installIsGhostClassMethodIn: aClass 	| method metaClass |	metaClass := aClass class.	method := IsGhostClassMethod 				ifNil: [IsGhostClassMethod := self generateIsGhostClassMethod].	method := self newAsCopyOf: method in: metaClass.	metaClass addSelector: #isGhostClass withMethod: method</body><body package="JNIPort-GhostClasses">newAsCopyOf: aCompiledMethod in: aClassDescription 	| meth |	meth := self 				newBytes: aCompiledMethod bytes				literals: aCompiledMethod literals				numArgs: aCompiledMethod numArgs				numTemps: aCompiledMethod numTempsOnly				maxDepth: aCompiledMethod frameSize				needsFrame: aCompiledMethod isQuick not				inBlock: false				hybrid: aCompiledMethod needsHybridFrame				forContext: aCompiledMethod usesContextInstVars.	meth mclass: aClassDescription.	meth postCopy.	^meth</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>initializing</category><body package="JNIPort-CollectionAdaptors">subject: anObject	"private -- set the receiver's subject to anObject"	subject := anObject.	diyIncludes := (subject respondsTo: #includes) not.</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>private</category><body package="JNIPort-CollectionAdaptors">species	"answer the kind of collection to be used when copying the receiver"	"it is arguable that the fundamental concrete container is actually Bag, however	it seems a little perverse, so I've choosen to use"	^ OrderedCollection.</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>removing</category><body package="JNIPort-CollectionAdaptors">remove: anObject ifAbsent: a0Block	"one of the root methods for &lt;Collection&gt;"	^ subject remove: anObject ifAbsent: a0Block.</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>enumerating</category><body package="JNIPort-CollectionAdaptors">do: a1Block	"one of the root methods for &lt;Collection&gt;"	^ subject do: a1Block.</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>adding</category><body package="JNIPort-CollectionAdaptors">add: anObject	"one of the root methods for &lt;Collection&gt;"	^ subject add: anObject.</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>copying</category><body package="JNIPort-CollectionAdaptors">copyEmpty: anInteger	"private -overriden to use species (which it probably should have done in the first place)"	^ self species new: anInteger.</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>accessing</category><body package="JNIPort-CollectionAdaptors">size	"one of the root methods for &lt;Collection&gt;"	^ subject size.</body><body package="JNIPort-CollectionAdaptors">subject	"private -- answer the receiver's subject"	^ subject.</body></methods><methods><class-id>JNIPort.CollectionAdaptor</class-id> <category>testing</category><body package="JNIPort-CollectionAdaptors">includes: anObject	"one of the root methods of Collection; optional because it can be implemented	in terms of #do:"	^ diyIncludes		ifTrue: [super includes: anObject]		ifFalse: [subject includes: anObject].</body></methods><methods><class-id>JNIPort.CollectionAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-CollectionAdaptors">for: anObject	"answer a new instance which wraps anObject and forwards #add:, #do: #remove:ifAbsent:	and #size to that object.  If the subject doesn't understand #species or responds to it with its	own class (which can't be suitable for our purposes or it wouldn't be wrapped in one of these)	then we'll ask for it's species when copying.  If the subject also understands #includes: then	that's gravy and we'll forward it too"	^ (self basicNew: 1)		"using a non-zero basic size may help avoid divide-by-zero errors"		subject: anObject;		yourself.</body></methods><methods><class-id>JNIPort.ArrayAdaptor</class-id> <category>accessing</category><body package="JNIPort-CollectionAdaptors">at: anInteger	"one of the root methods for &lt;SequenceableCollection&gt;"	^ subject at: anInteger.</body><body package="JNIPort-CollectionAdaptors">at: anInteger put: anObject	"one of the root methods for &lt;SequenceableCollection&gt;"	^ subject at: anInteger put: anObject.</body><body package="JNIPort-CollectionAdaptors">size	"one of the root methods for &lt;Collection&gt;"	^ subject size.</body><body package="JNIPort-CollectionAdaptors">subject	"private -- answer the receiver's subject"	^ subject.</body></methods><methods><class-id>JNIPort.ArrayAdaptor</class-id> <category>initializing</category><body package="JNIPort-CollectionAdaptors">subject: anObject 	"private -- set the receiver's subject to anObject"	subject := anObject.	diyLoop := (anObject respondsTo: #from:to:keysAndValuesDo:) not</body></methods><methods><class-id>JNIPort.ArrayAdaptor</class-id> <category>copying</category><body package="JNIPort-CollectionAdaptors">copyEmpty: anInteger	"private -overriden to use species (which it probably should have done in the first place)"	^ self species new: anInteger.</body></methods><methods><class-id>JNIPort.ArrayAdaptor</class-id> <category>enumerating</category><body package="JNIPort-CollectionAdaptors">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block 	^diyLoop 		ifTrue: 			[super 				from: aStartIndex				to: aStopIndex				keysAndValuesDo: a2Block]		ifFalse: 			[subject 				from: aStartIndex				to: aStopIndex				keysAndValuesDo: a2Block]</body></methods><methods><class-id>JNIPort.ArrayAdaptor</class-id> <category>private</category><body package="JNIPort-CollectionAdaptors">species	"answer the kind of collection to be used when copying the receiver"	^Array</body></methods><methods><class-id>JNIPort.ArrayAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-CollectionAdaptors">for: anObject	"answer a new instance which wraps anObject and forwards #size, #at: and #at:put:	to that object;  if the subject also understands #from:to:keysAndValuesDo: or, #replaceFrom:to:with:startingAt:	then that's gravy and we'll forward them too"	^ (self basicNew)		subject: anObject;		yourself.</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure</class-id> <category>printing</category><body package="JNIPort-External">printOn: aStream 	super printOn: aStream.	aStream		space;		nextPut: $&lt;;		print: externalData;		nextPut: $&gt;</body><body package="JNIPort-External">storeOn: aStream 	"Writes the storeString of the receiver's class name (a Symbol) on aStream and adds a comment containing the receiver's printString. The receiver cannot be regenerated from a storeString anyway. This is necessary to generate a representation of the receiver during decompilation of a GhostMethod, when the receiver is the value of a LiteralNode."	aStream nextPut: $(.	self class name storeOn: aStream.	aStream		space;		nextPut: $".	self printOn: aStream.	aStream nextPutAll: '")'</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure</class-id> <category>testing</category><body package="JNIPort-External">isNull	^externalData isNil or: [externalData isValid not]</body><body package="JNIPort-External">notNull	^self isNull not</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure</class-id> <category>initialize-release</category><body package="JNIPort-External">externalData: aCDatum	externalData := aCDatum</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure</class-id> <category>memory management</category><body package="JNIPort-External">beFinalizable	"Makes sure that the external data are automatically freed when the receiver and thus the external data are garbage collected. This should only be used when there is no other mechanism which frees the external data, e.g. using the finalization mechanism of an ephemeron or a weak collection."	externalData ifNotNil: [externalData beGarbageCollectable]</body><body package="JNIPort-External">beUnfinalizable	"Makes sure that the external data are not automatically freed when the receiver and thus the external data are garbage collected. This can be used when it is made sure that the external data will be freed by another mechanism, e.g. using the finalization mechanism of an ephemeron or a weak collection."	externalData ifNotNil: [externalData beNonGarbageCollectable]</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure</class-id> <category>accessing</category><body package="JNIPort-External">externalData	externalData ifNil: [externalData := self baseCType gcCalloc].	^externalData</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure class</class-id> <category>external accessing</category><body package="JNIPort-External">baseCType	^self subclassResponsibility</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure class</class-id> <category>instance creation</category><body package="JNIPort-External">fromAddress: aCPointer 	"Answers an instance of the receiver which references the address aCPointer. Dolphin Smalltalk compatibility method."	^self on: aCPointer</body><body package="JNIPort-External">on: aCDatum 	^(self new)		externalData: aCDatum;		yourself</body></methods><methods><class-id>JNIPort.StandardLibInterface</class-id> <category>types</category><body package="JNIPort-StandardLibInterface">char	^CIntegerType char</body><body package="JNIPort-StandardLibInterface">intSized_size_t	&lt;C: typedef unsigned int size_t&gt;</body><body package="JNIPort-StandardLibInterface">longSized_size_t	&lt;C: typedef unsigned long size_t&gt;</body><body package="JNIPort-StandardLibInterface">size_t	^ObjectMemory is64Bit ifTrue: [self longSized_size_t] ifFalse: [self intSized_size_t]</body><body package="JNIPort-StandardLibInterface">va_list	&lt;C: typedef char * va_list&gt;</body></methods><methods><class-id>JNIPort.StandardLibInterface</class-id> <category>public interface</category><body package="JNIPort-StandardLibInterface">getClasspath	"Answers the CLASSPATH environment variable"	^self getenv: 'CLASSPATH'</body><body package="JNIPort-StandardLibInterface">getenv: aString	"Answer the value of the environment variable aString."	| pointer |	pointer := [self primGetenv: aString] 				on: ExternalObjectNotFoundError				do: [:error | error return: nil].	^pointer isNull ifTrue: [String new] ifFalse: [pointer copyCStringFromHeap]</body></methods><methods><class-id>JNIPort.StandardLibInterface</class-id> <category>procedures</category><body package="JNIPort-StandardLibInterface">vsnprintf: buffer count: maxbuf format: format vaList: aVaList	"Write data formatted by the format string into the buffer; aVaList	supplies the 'variable' arguments to the call.	This function should be available on most platforms, but currently, we cannot	use VaLists on 64bit systems - their memory layout there seems to be different,	such that we can't pass them as a parameter to an external function."	ObjectMemory is64Bit ifTrue: [^self error: 'Passing VaLists to external functions is not yet supported on this platform.'].	^self		callVsnprintf: buffer		count: maxbuf		format: format		va_list: aVaList asPointer</body></methods><methods><class-id>JNIPort.StandardLibInterface class</class-id> <category>private</category><body package="JNIPort-StandardLibInterface">libraryFilesSearchSignals	"Answer a SignalCollection used to handle exceptions raised when scanning for library files.	 The signals answered by this method will result in those signals being ignored by the	 library search machinery. Clients should not answer signals they wish to receive."	^#{LibraryNotFoundError} ifDefinedDo: 			[:libraryNotFound |			libraryNotFound , LibraryNotLoadedError , ExternalObjectNotFoundError]		elseDo: [LibraryNotLoadedError , ExternalObjectNotFoundError]</body></methods><methods><class-id>JNIPort.StandardLibInterface class</class-id> <category>testing</category><body package="JNIPort-StandardLibInterface">is64Bit	^ObjectMemory is64Bit</body><body package="JNIPort-StandardLibInterface">sizeofLongIs64Bit	^CIntegerType long sizeof = 8</body><body package="JNIPort-StandardLibInterface">supportsVsnprintf	^self is64Bit not</body></methods><methods><class-id>JNIPort.StandardLibInterface class</class-id> <category>accessing</category><body package="JNIPort-StandardLibInterface">default	^Default ifNil: [Default := self new].</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>private</category><body package="JNIPort-CollectionAdaptors">species	"answer the kind of collection to be used when copying the receiver"	^ Set.</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>enumerating</category><body package="JNIPort-CollectionAdaptors">do: a1Block	"one of the root methods for &lt;Collection&gt;"	^ subject do: a1Block.</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>testing</category><body package="JNIPort-CollectionAdaptors">includes: anObject	"one of the root methods for &lt;Set&gt;"	^ subject includes: anObject.</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>accessing</category><body package="JNIPort-CollectionAdaptors">size	"one of the root methods for &lt;Collection&gt;"	^ subject size.</body><body package="JNIPort-CollectionAdaptors">subject	"private -- answer the receiver's subject"	^ subject.</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>adding</category><body package="JNIPort-CollectionAdaptors">add: anObject	"one of the root methods for &lt;Collection&gt;"	^ subject add: anObject.</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>removing</category><body package="JNIPort-CollectionAdaptors">remove: anObject ifAbsent: a0Block	"one of the root methods for &lt;Collection&gt;"	^ subject remove: anObject ifAbsent: a0Block.</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>copying</category><body package="JNIPort-CollectionAdaptors">copyEmpty: anInteger	"private -overriden to use species (which it probably should have done in the first place)"	^ self species new: anInteger.</body></methods><methods><class-id>JNIPort.SetAdaptor</class-id> <category>initializing</category><body package="JNIPort-CollectionAdaptors">subject: anObject	"private -- set the receiver's subject to anObject"	subject := anObject.</body></methods><methods><class-id>JNIPort.SetAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-CollectionAdaptors">for: anObject	"answer a new instance which wraps anObject and forwards #add:, #do: #remove:ifAbsent:	#includes, and #size to that object.  If the subject understands #rehash and #shrink then they	are also forwarded"	^ (self basicNew: 1)		"using a capacity of 1 may help avoid divide-by-zero errors"		subject: anObject;		yourself.</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>dictionary testing</category><body package="JNIPort-CollectionAdaptors">includesKey: aKey	"one of the root methods for &lt;Dictionary&gt;, optional because implementable in terms	of at:ifAbsent:"	^ diyIncludes		ifTrue: [subject at: aKey ifAbsent: [^ false]. true]		ifFalse: [subject includesKey: aKey].</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>dictionary removing</category><body package="JNIPort-CollectionAdaptors">removeKey: aKey ifAbsent: a0Block	"one of the root methods for &lt;Dictionary&gt;"	^ subject removeKey: aKey ifAbsent: a0Block.</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>private</category><body package="JNIPort-CollectionAdaptors">changeCapacityTo: anInteger	"overridden to ignore"</body><body package="JNIPort-CollectionAdaptors">species	"answer the kind of collection to be used when copying the receiver"	^Dictionary</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>accessing</category><body package="JNIPort-CollectionAdaptors">associationAt: aKey ifAbsent: a0Block 	"this association crap is the absolute limit"	| val |	val := self at: aKey ifAbsent: [^a0Block value].	^aKey -&gt; val</body><body package="JNIPort-CollectionAdaptors">at: aKey ifAbsent: a0Block	"one of the root methods for &lt;Dictionary&gt;"	^ subject at: aKey ifAbsent: a0Block.</body><body package="JNIPort-CollectionAdaptors">at: aKey put: anObject	"one of the root methods for &lt;Dictionary&gt;"	^ subject at: aKey put: anObject.</body><body package="JNIPort-CollectionAdaptors">size	"one of the root methods for &lt;Collection&gt;"	^ subject size.</body><body package="JNIPort-CollectionAdaptors">subject	"private -- answer the receiver's subject"	^ subject.</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>enumerating</category><body package="JNIPort-CollectionAdaptors">do: a1Block 	^self keysAndValuesDo: [:key :value | a1Block value: value]</body><body package="JNIPort-CollectionAdaptors">keysAndValuesDo: a2Block	"one of the root methods for &lt;Dictionary&gt;"	^ subject keysAndValuesDo: a2Block.</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>adding</category><body package="JNIPort-CollectionAdaptors">add: anAssociation 	"one of the root methods for &lt;Collection&gt;.  Overriden to 'know' about bloody Associations"	^self at: anAssociation key put: anAssociation value</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>initializing</category><body package="JNIPort-CollectionAdaptors">subject: anObject	"private -- set the receiver's subject to anObject"	subject := anObject.	diyIncludes := (anObject respondsTo: #includesKey:) not.</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>dictionary enumerating</category><body package="JNIPort-CollectionAdaptors">associationsDo: a1Block 	^self keysAndValuesDo: [:key :value | a1Block value: key -&gt; value]</body></methods><methods><class-id>JNIPort.DictionaryAdaptor</class-id> <category>copying</category><body package="JNIPort-CollectionAdaptors">copyEmpty: anInteger	"private -overriden to use species (which it probably should have done in the first place)"	^ self species new: anInteger.</body></methods><methods><class-id>JNIPort.DictionaryAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-CollectionAdaptors">for: anObject	"answer a new instance which wraps anObject and forwards #at:ifAbsent, #at:put:, #keysAndValuesDo:,	#removeKey:ifAbsent:, and #size to that object.  If the subject understands #includesKey:, #rehash, or	#shrink then they are also forwarded"	^ (self basicNew: 1)		"using a capacity of 1 may help avoid divide-by-zero errors"		subject: anObject;		yourself.</body></methods><methods><class-id>JNIPort.WriteStreamAdaptor</class-id> <category>accessing</category><body package="JNIPort-CollectionAdaptors">contents	"if our subject understands #contents then answer the result of forwarding to it,	otherwise throw an error"	^subject contents</body><body package="JNIPort-CollectionAdaptors">flush	"subclass responsibility - do nothing, this is for compatibility with BufferedExternalStreams."</body><body package="JNIPort-CollectionAdaptors">next	self shouldNotImplement</body><body package="JNIPort-CollectionAdaptors">nextPut: anObject	"one of the root methods of &lt;WriteStream&gt;"	^ subject nextPut: anObject.</body></methods><methods><class-id>JNIPort.WriteStreamAdaptor</class-id> <category>testing</category><body package="JNIPort-CollectionAdaptors">atEnd	"one of the root methods for &lt;WriteStream&gt;"	^subject atEnd</body><body package="JNIPort-CollectionAdaptors">isReadable	"Answer whether the stream implements #next."	^false</body><body package="JNIPort-CollectionAdaptors">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>JNIPort.WriteStreamAdaptor</class-id> <category>status</category><body package="JNIPort-CollectionAdaptors">close	"one of the root methods for &lt;WriteStream&gt;"	(subject respondsTo: #close) ifTrue: [subject close].	subject := nil.</body></methods><methods><class-id>JNIPort.WriteStreamAdaptor</class-id> <category>initializing</category><body package="JNIPort-CollectionAdaptors">subject: anObject	"private -- set the object to which we forward the basic stream messages"	subject := anObject</body></methods><methods><class-id>JNIPort.WriteStreamAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-CollectionAdaptors">for: anObject	"answer a new instance which wraps anObject and forwards #atEnd: and #nextPut: to it.	If it also understands any of #close, #flush, #next:put:, #next:putAll:startingAt:, or #contents	then they are also forwarded"	^ (self basicNew)		subject: anObject;		yourself.</body></methods><methods><class-id>JNIPort.JavaModifiedUTF8StreamEncoder</class-id> <category>private</category><body package="JNIPort-StringEncoding">basicNextFrom: aStream 	"Reads a character from aStream. Does not substitute surrogate characters, this is done in #nextFrom:. This method is copied from UTF8StreamEncoder&gt;&gt;nextFrom:, but reading 4-byte characters has been deleted, as they are not used in Java modified UTF-8."	| c1 c2 c3 |	c1 := aStream next.	c1 == nil ifTrue: [^nil].	16r7F &gt;= c1 ifTrue: [^Character value: c1].	"1-byte character"	16rC0 == (c1 bitAnd: 16rE0) 		ifTrue: 			["2-byte character"			c2 := aStream next.			c2 == nil ifTrue: [^nil].			^Character value: ((c1 bitAnd: 16r1F) bitShift: 6) + (c2 bitAnd: 16r3F)].	16rE0 == (c1 bitAnd: 16rF0) 		ifTrue: 			["3-byte character"			| codePoint |			c2 := aStream next.			c2 == nil ifTrue: [^nil].			c3 := aStream next.			c3 == nil ifTrue: [^nil].			codePoint := ((c1 bitAnd: 16r0F) bitShift: 12) 						+ ((c2 bitAnd: 16r3F) bitShift: 6) + (c3 bitAnd: 16r3F).			^Character value: (16r10FFFF &lt; codePoint 						ifTrue: [Character illegalCode]						ifFalse: [codePoint])].	^Character illegalCode asCharacter</body><body package="JNIPort-StringEncoding">nextPutNullOn: aStream 	"Writes the encoding for a null Character to aStream."	aStream		nextPut: 2r11000000;		nextPut: 2r10000000</body><body package="JNIPort-StringEncoding">nextPutOneByte: anInteger on: aStream 	"Writes the one-byte encoding for the code point anInteger to aStream."	aStream nextPut: anInteger</body><body package="JNIPort-StringEncoding">nextPutSurrogatesFor: anInteger on: aStream 	"Writes the two 3-byte encoded surrogate code points for the code point anInteger to aStream. The algorithm is a direct translation of the specification in the JNI spec."	"Uncomment the following statements for testing if the algorithm produces valid leading and trailing surrogate code points:"	"| c1 c2 c3 codePoint |	c1 := 2r11101101.	c2 := 2r10100000 + ((anInteger bitShift: -16) bitAnd: 2r00001111).	c3 := 2r10000000 + ((anInteger bitShift: -10) bitAnd: 2r00111111).	codePoint := ((c1 bitAnd: 16r0F) bitShift: 12) + ((c2 bitAnd: 16r3F) bitShift: 6) + (c3 bitAnd: 16r3F).	self jniAssert: ((Character value: codePoint) isLeadingSurrogate).	c1 := 2r11101101.	c2 := 2r10110000 + ((anInteger bitShift: -6) bitAnd: 2r00001111).	c3 := 2r10000000 + (anInteger bitAnd: 2r00111111).	codePoint := ((c1 bitAnd: 16r0F) bitShift: 12) + ((c2 bitAnd: 16r3F) bitShift: 6) + (c3 bitAnd: 16r3F).	self jniAssert: ((Character value: codePoint) isTrailingSurrogate)."	aStream		nextPut: 2r11101101;		nextPut: 2r10100000 + ((anInteger bitShift: -16) - 1 bitAnd: 2r00001111);		nextPut: 2r10000000 + ((anInteger bitShift: -10) bitAnd: 2r00111111);		nextPut: 2r11101101;		nextPut: 2r10110000 + ((anInteger bitShift: -6) bitAnd: 2r00001111);		nextPut: 2r10000000 + (anInteger bitAnd: 2r00111111)</body><body package="JNIPort-StringEncoding">nextPutThreeBytes: anInteger on: aStream 	"Writes the three-byte encoding for the code point anInteger to aStream."	aStream		nextPut: 2r11100000 + (anInteger bitShift: -12);		nextPut: 2r10000000 + ((anInteger bitShift: -6) bitAnd: 2r00111111);		nextPut: 2r10000000 + (anInteger bitAnd: 2r00111111)</body><body package="JNIPort-StringEncoding">nextPutTwoBytes: anInteger on: aStream 	"Writes the two-byte encoding for the code point anInteger to aStream."	aStream		nextPut: 2r11000000 + (anInteger bitShift: -6);		nextPut: 2r10000000 + (anInteger bitAnd: 2r00111111)</body></methods><methods><class-id>JNIPort.JavaModifiedUTF8StreamEncoder</class-id> <category>accessing</category><body package="JNIPort-StringEncoding">nextFrom: aStream 	"Decodes the next byte(s) in the UTF encoded stream, and answers the character. If the bytes read are a trailing surrogate (without preceding leading surrogate), then skip it and decode the next bytes. If the bytes read represent a leading surrogate, also decode the following bytes. If they are a trailing surrogate, answer the supplementary character represented by combining the two surrogates. If the character after a leading surrogate is not a trailing surrogate, then skip the leading surrogate and answer the character following it."	| character leadingSurrogate |	character := self basicNextFrom: aStream.	character == nil ifTrue: [^nil].	"Skip leading surrogates which are followed by another leading surrogate. Look for the next character which is not a leading surrogate."	leadingSurrogate := nil.	[character isLeadingSurrogate] whileTrue: 			[leadingSurrogate := character.			character := self basicNextFrom: aStream.			character == nil 				ifTrue: 					[^nil	"There have been only leading surrogates so far, and the end of the stream has been reached. There is no valid character to answer."]].	^(leadingSurrogate ~~ nil and: [character isTrailingSurrogate]) 		ifTrue: [character := Character combineSurrogate: leadingSurrogate with: character]		ifFalse: 			["Skip isolated trailing surrogates."			[character isTrailingSurrogate] whileTrue: 					[character := self basicNextFrom: aStream.					character == nil 						ifTrue: 							[^nil	"There have been only trailing surrogates so far, and the end of the stream has been reached. There is no valid character to answer."]].			character]</body><body package="JNIPort-StringEncoding">nextPut: aCharacter on: aStream 	"Encodes aCharacter and writes it to aStream. Replaces Characters with code points larger than the largest legal value by the code point representing illegal Characters."	| codePoint |	codePoint := aCharacter asInteger.	16r10FFFF &lt; codePoint ifTrue: [codePoint := Character illegalCode].	0 = codePoint 		ifTrue: 			[self nextPutNullOn: aStream.			^aCharacter].	16r007F &gt;= codePoint 		ifTrue: 			[self nextPutOneByte: codePoint on: aStream.			^aCharacter].	16r7FF &gt;= codePoint 		ifTrue: 			[self nextPutTwoBytes: codePoint on: aStream.			^aCharacter].	16rFFFF &gt;= codePoint 		ifTrue: 			[self nextPutThreeBytes: codePoint on: aStream.			^aCharacter].	"codePoint &gt;= 0x10000 - replace supplementary character with surrogates"	self nextPutSurrogatesFor: codePoint on: aStream.	^aCharacter</body></methods><methods><class-id>JNIPort.JavaModifiedUTF8StreamEncoder</class-id> <category>querying</category><body package="JNIPort-StringEncoding">characterSize: aCharacter 	"Returns the size in bytes of aCharacter. For code points larger than the largest Unicode code point 16r10FFFF, answers the byte size for Character illegalCode. For supplementary characters, i.e. characters with code points in the range 16r10000 to 16r10FFFF, the answer is 6 bytes, as these characters are represented by two 3-byte surrogate code points. The null character is encoded by two bytes."	| val |	val := aCharacter asInteger.	0 = val ifTrue: [^2].	16r10FFFF &lt; val ifTrue: [val := Character illegalCode].	^16r007F &gt;= val 		ifTrue: [1]		ifFalse: 			[16r07FF &gt;= val 				ifTrue: [2]				ifFalse: [16rFFFF &gt;= val ifTrue: [3] ifFalse: [6]]]</body></methods><methods><class-id>JNIPort.JavaModifiedUTF8StreamEncoder class</class-id> <category>utilities</category><body package="JNIPort-StringEncoding">encode: aString 	"Encode aString using a preallocated encoded stream. Creating such a stream is expensive. Using this method is much faster than evaluating		self asByteArrayEncoding: #JavaModifiedUTF8."	^(self encoderStream)		reset;		nextPutAll: aString;		close;		encodedContents</body></methods><methods><class-id>JNIPort.JavaModifiedUTF8StreamEncoder class</class-id> <category>accessing</category><body package="JNIPort-StringEncoding">alternateNames	"Answer the symbol of this encoding."	^#(#JavaModifiedUTF8 #JNI)</body><body package="JNIPort-StringEncoding">encoderStream	EncoderStream isNil 		ifTrue: 			[EncoderStream := ((ByteArray new: 100) withEncoding: #JavaModifiedUTF8) 						writeStream].	^EncoderStream</body><body package="JNIPort-StringEncoding">streamEncodingType	"Answer the symbol of this encoding."	^#'JavaModifiedUTF-8'</body></methods><methods><class-id>JNIPort.JNIPortNotification</class-id> <category>private - actions</category><body package="JNIPort-VW-Extensions">defaultAction	"What to do when the exception is unhandled. By default, Notifications can be ignored, but the receiver ."	self toTrace.	^super defaultAction</body></methods><methods><class-id>JNIPort.JNIPortUtility class</class-id> <category>utilities</category><body package="JNIPort-VW-Extensions">exceptionsWithoutNotifications	"Answer an ExceptionSet which matches all Exceptions, but not Notifications and similar signals which can be ignored"	^Exception - (Notification , InformationSignal)</body><body package="JNIPort-VW-Extensions">executesForeignCallbacksInSmalltalkThread	"Answer if the Smalltalk VM executes a callback from a thread other than the one executing Smalltalk code in the Smalltalk thread. This is true for VisualWorks."	^true</body><body package="JNIPort-VW-Extensions">flushVMmethodCache	"the system keeps a cache of compilation results, which can result in	old references to classes (with all our resulting machinery) being kept 	around for much longer than you'd expect.  This is a brutal, but	effective way of stopping it"	Class flushVMmethodCache</body><body package="JNIPort-VW-Extensions">garbageCollect	ObjectMemory garbageCollect</body><body package="JNIPort-VW-Extensions">isRuntime	^RuntimeSystem isRuntime</body><body package="JNIPort-GhostClasses">removeGhostClassIfNeeded: aClass	"Don't do anything, the class will be garbage collected. Other Smalltalk dialects where no real ghost classes can be created may need to actively remove aClass from the system."</body><body package="JNIPort-VW-Extensions">signalEndOfStream: aStream	"Some Smalltalk dialects raise a Notification when the end of a Stream is reached, some just return nil. VisualWorks raises an EndOfStreamNotification."	^aStream class endOfStreamSignal signalWith: aStream</body><body package="JNIPort-VW-Extensions">subscriptOutOfBoundsError	^SubscriptOutOfBoundsError</body><body package="JNIPort-VW-Extensions">supportsForeignCallbacksFromJava	^true</body><body package="JNIPort-VW-Extensions">waitForMilliseconds: anInteger	(Delay forMilliseconds: anInteger) wait</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>mutating</category><body package="JNIPort-CollectionAdaptors">changeCapacityTo: anInteger	"private -- overridden to ignore"</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>private</category><body package="JNIPort-CollectionAdaptors">insert: anObject before: spot 	^self add: anObject afterIndex: spot - 1</body><body package="JNIPort-CollectionAdaptors">species	"answer the kind of collection to be used when copying the receiver"	^ OrderedCollection.</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>accessing</category><body package="JNIPort-CollectionAdaptors">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;"	^ subject at: anIndex.</body><body package="JNIPort-CollectionAdaptors">at: anIndex put: anObject	"one of the root methods for &lt;SequenceableCollection&gt;"	^ subject at: anIndex put: anObject.</body><body package="JNIPort-CollectionAdaptors">replaceFrom: aStartIndex to: aStopIndex with: replacementElements startingAt: aReplacementIndex	"one of the root methods for &lt;SequenceableCollection&gt;, optional because it can be	implemented in terms of #at:, #at:put:, and #size"	^ diyReplace		ifTrue: [super replaceFrom: aStartIndex to: aStopIndex with: replacementElements startingAt: aReplacementIndex]		ifFalse: [subject replaceFrom: aStartIndex to: aStopIndex with: replacementElements startingAt: aReplacementIndex].</body><body package="JNIPort-CollectionAdaptors">size	"one of the root methods for &lt;Collection&gt;"	^ subject size.</body><body package="JNIPort-CollectionAdaptors">subject	"private -- answer the receiver's subject"	^ subject.</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>enumerating</category><body package="JNIPort-CollectionAdaptors">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block	"one of the root methods for &lt;SequenceableCollection&gt;, optional because it can be	implemented in terms of #at: and #size"	"if the subject doesn't understand this, then we inline the loop here for speed rather then	falling back to the superclass implementation"	^ diyLoop		ifTrue: [aStartIndex to: aStopIndex do: [:i | a2Block value: i value: (subject at: i)]]		ifFalse: [subject from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block].</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>adding</category><body package="JNIPort-CollectionAdaptors">add: anObject	^subject add: anObject</body><body package="JNIPort-CollectionAdaptors">add: anObject afterIndex: anIndex	"one of the root methods for &lt;SequencedGrowableCollection&gt;"	^ subject add: anObject afterIndex: anIndex.</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>removing</category><body package="JNIPort-CollectionAdaptors">removeAtIndex: anIndex	"one of the root methods for &lt;SequencedGrowableCollection&gt;"	^ subject removeAtIndex: anIndex.</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>initializing</category><body package="JNIPort-CollectionAdaptors">subject: anObject	"private -- set the receiver's subject to anObject"	subject := anObject.	diyLoop := (anObject respondsTo: #from:to:keysAndValuesDo:) not.	diyReplace := (anObject respondsTo: #replaceFrom:to:with:startingAt:) not.</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor</class-id> <category>copying</category><body package="JNIPort-CollectionAdaptors">copyEmpty: anInteger	"private -overriden to use species (which it probably should have done in the first place)"	^ self species new: anInteger.</body></methods><methods><class-id>JNIPort.OrderedCollectionAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-CollectionAdaptors">for: anObject	"answer a new instance which wraps anObject and forwards #size, #at: #at:put: #add:afterIndex:	and #removeAtIndex: to that object;  if the subject also understands #from:to:keysAndValuesDo:,	#removeAll, or #replaceFrom:to:with:startingAt: then that's gravy and we'll forward them too"	^ (self basicNew)		subject: anObject;		yourself.</body></methods><methods><class-id>Core.Integer</class-id> <category>bit manipulation</category><body package="JNIPort-VW-Extensions">| anInteger	^self bitOr: anInteger</body><body package="JNIPort-VW-Extensions">mask: anInteger set: aBoolean 	"Treat the argument as a bit mask.  Answer a copy of the receiver with the	corresponding bits turned on if aBoolean is true, or turned off if aBoolean is false.	Dolphin Smalltalk compatibility"	^aBoolean 		ifTrue: [self maskSet: anInteger]		ifFalse: [self maskClear: anInteger]</body></methods><methods><class-id>Core.String class</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">lineDelimiter	"Answer an instance of the receiver containing the host system end-of-line 	character sequence (a Cr/Lf pair on Windows). This is a method of String rather than	Character because the answer will always be a String."	| lineEndConvention |	lineEndConvention := IOAccessor defaultLineEndConvention.	(lineEndConvention == OS.IOConstants.LineEndCR 		or: [lineEndConvention == OS.IOConstants.LineEndTransparent]) 			ifTrue: [^self with: Character cr].	lineEndConvention == OS.IOConstants.LineEndCRLF 		ifTrue: [^self with: Character cr with: Character lf].	lineEndConvention == OS.IOConstants.LineEndLF ifTrue: [^self with: Character lf].	^self with: Character cr</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="JNIPort-VW-Extensions">asClassOrNilIn: anEnvironment	"Answers a class in anEnvironment (a Namespace) with a name equal to the receiver, or nil if no such class is found."	| reference |	reference := self asQualifiedReference.	reference home: anEnvironment.	^reference valueOrDo: [nil]</body><body package="JNIPort-VW-Extensions">subStrings: aString 	^self tokensBasedOn: aString first</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">instanceClass	^self instanceBehavior</body></methods><methods><class-id>Core.Object</class-id> <category>class membership</category><body package="JNIPort-VW-Extensions">becomeA: aClass	^self changeClassTo: aClass</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="JNIPort-VW-Extensions">errorNotFound: anObject 	"Raise a NotFoundError indicating that anObject was not found 	in the receiver"	^NotFoundError signalWith: anObject</body><body package="JNIPort-VW-Extensions">errorSubscriptBounds: anIndex 	"Raise a signal indicating that an improper index was used as an index in a send of selector with index."	^self subscriptBoundsError: anIndex</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="JNIPort-VW-Extensions">jniAssert: aBlock 	"Renamed from assert: to avoid conflicts with SUnit and other implemetations of assert:."	aBlock value ifFalse: [JNIPortAssertionFailure raiseSignal]</body></methods><methods><class-id>Core.Object</class-id> <category>system primitives</category><body package="JNIPort-VW-Extensions">swappingBecome: anObject 	"Dolphin Smalltalk Compatibility"	^self become: anObject</body></methods><methods><class-id>Core.Object</class-id> <category>event triggering</category><body package="JNIPort-VW-Extensions">trigger: aSymbol 	"Dolphin Smalltalk compatibility"	^self triggerEvent: aSymbol</body><body package="JNIPort-VW-Extensions">trigger: aSymbol with: anArgument 	"Dolphin Smalltalk compatibility"	^self triggerEvent: aSymbol with: anArgument</body><body package="JNIPort-VW-Extensions">trigger: aSymbol with: anArgument1 with: anArgument2 	"Dolphin Smalltalk compatibility"	^self 		triggerEvent: aSymbol		with: anArgument1		with: anArgument2</body><body package="JNIPort-VW-Extensions">trigger: aSymbol withArguments: anArray 	"Dolphin Smalltalk compatibility"	^self triggerEvent: aSymbol withArguments: anArray</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="JNIPort-VW-Extensions">asUnicode	^self asInteger</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">at: anInteger ifAbsent: a0Block	"Answer the element at index anInteger or the result of evaluating	a0Block if anInteger is does not index an existing element"	^ (anInteger between: 1 and: self size)		ifTrue: [self at: anInteger]		ifFalse: [a0Block value].</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="JNIPort-VW-Extensions">copyReplacing: oldElement withObject: newElement 	^self copyReplaceAll: (Array with: oldElement)		with: (Array with: newElement)</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="JNIPort-VW-Extensions">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block 	"one of the root methods for &lt;SequenceableCollection&gt;, optional because it can be	implemented in terms of #at: and #size"	^aStartIndex to: aStopIndex do: [:i | a2Block value: i value: (self at: i)]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="JNIPort-VW-Extensions">identityIncludes: anObject 	"Dolphin Smalltalk compatibility"	^(self identityIndexOf: anObject) &gt; 0</body></methods><methods><class-id>Core.Dictionary</class-id> <category>copying</category><body package="JNIPort-VW-Extensions">deepCopy	| copy |	copy := self species new: self size.	self keysAndValuesDo: [:key :value | copy at: key put: value deepCopy].	^copy</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">findElement: anObject ifAbsent: aZeroArgumentBlock 	"Searches for an element equal to anObject. Answers the element found. If not found, answers the result of evaluating aZeroArgumentBlock"	^self detect: [:element | element = anObject] ifNone: aZeroArgumentBlock</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">findElement: anObject ifAbsent: aZeroArgumentBlock	"Dolphin Smalltalk compatibility: Searches for an element equal to anObject. Answers the element found. If not found, answers the result of evaluating aZeroArgumentBlock"		^self findElementLike: anObject ifAbsent: aZeroArgumentBlock</body></methods><methods><class-id>Core.ExceptionSet</class-id> <category>removing</category><body package="JNIPort-VW-Extensions">- anExceptionSelector 	^ExceptionSetWithExclusions with: self exclude: anExceptionSelector</body></methods><methods><class-id>Core.Behavior</class-id> <category>enumerating</category><body package="JNIPort-VW-Extensions">allSubclassesPreOrderDo: aBlock 	"Dolphin Smalltalk compatibility"	^self allSubclassesDo: aBlock</body><body package="JNIPort-VW-Extensions">allSuperclassesDo: aOneArgumentBlock 	"Dolphin Smalltalk compatibility"	self superclass ifNotNil: 			[:mySuperclass | 			aOneArgumentBlock value: mySuperclass.			mySuperclass allSuperclassesDo: aOneArgumentBlock]</body><body package="JNIPort-VW-Extensions">withAllSuperclassesDo: aOneArgumentBlock 	"Dolphin Smalltalk compatibility"	aOneArgumentBlock value: self.	self superclass 		ifNotNil: [:mySuperclass | mySuperclass withAllSuperclassesDo: aOneArgumentBlock]</body></methods><methods><class-id>Core.Float</class-id> <category>converting</category><body package="JNIPort-VW-Extensions">asIEEE32BitWord	| bytes |	bytes := UninterpretedBytes new: 4.	bytes floatAt: 1 put: self.	^bytes unsignedLongAt: 1</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">findElement: anObject ifAbsent: aZeroArgumentBlock 	"Searches for an element equal to anObject. Answers the element found. If not found, answers the result of evaluating aZeroArgumentBlock"	^self detect: [:element | element == anObject] ifNone: aZeroArgumentBlock</body></methods><methods><class-id>Core.Signal</class-id> <category>conversion</category><body package="JNIPort-VW-Extensions">- anExceptionSelector 	^ExceptionSetWithExclusions with: self exclude: anExceptionSelector</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="JNIPort-VW-Extensions">capitalize	self isEmpty ifTrue: [^self].	self at: 1 put: self first asUppercase</body><body package="JNIPort-VW-Extensions">capitalized	^(self copy)		capitalize;		yourself</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">at: anInteger ifAbsent: a0Block	"Answer the element at index anInteger or the result of evaluating	a0Block if anInteger is does not index an existing element"	anInteger isInteger ifFalse: [^self nonIntegerIndexError: anInteger].	^(anInteger &lt; 1 or: [anInteger + firstIndex - 1 &gt; lastIndex])		ifTrue: [a0Block value]		ifFalse: [super at: anInteger + firstIndex - 1]</body></methods><methods><class-id>Core.GenericException class</class-id> <category>converting</category><body package="JNIPort-VW-Extensions">- anExceptionSelector 	^ExceptionSetWithExclusions with: self exclude: anExceptionSelector</body></methods><methods><class-id>Core.GenericException class</class-id> <category>compatibility - raising</category><body package="JNIPort-VW-Extensions">signal: aString with: aParameter 	^self raiseWith: aParameter errorString: aString</body></methods><methods><class-id>Core.GenericException</class-id> <category>signalling</category><body package="JNIPort-VW-Extensions">jniportNotify	JNIPortNotification raiseSignal: 'Error: ' , self description</body></methods><methods><class-id>Core.GenericException</class-id> <category>accessing</category><body package="JNIPort-VW-Extensions">tag	^self parameter</body></methods><methods><class-id>Core.GenericException</class-id> <category>printing</category><body package="JNIPort-VW-Extensions">toTrace	Transcript show: self description; cr</body></methods><methods><class-id>External.CDatum</class-id> <category>copying</category><body package="JNIPort-StringEncoding">copyJavaModifiedUTF8StringFromHeap	^theDatum copyJavaModifiedUTF8StringFromHeap</body></methods><methods><class-id>External.CPointer</class-id> <category>copying</category><body package="JNIPort-StringEncoding">copyJavaModifiedUTF8StringFromHeap	^self copyCStringFromHeap: #JavaModifiedUTF8</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="JNIPort-StringEncoding">fromJavaLangStringEncodedByteArray: aByteArray	"Answer a new instance of the receiver initialised by decoding the java.lang.String encoded byte array."	^aByteArray asStringEncoding: #JavaLangString</body><body package="JNIPort-StringEncoding">fromJavaModifiedUTF8EncodedByteArray: aByteArray	"Answer a new instance of the receiver initialised by decoding the nearly-but-not-quite UTF8	encoded byte array."	^aByteArray asStringEncoding: #JavaModifiedUTF8</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="JNIPort-StringEncoding">asJavaLangStringEncodedByteArray	"Answer the receiver as a ByteArray encoded as a java.lang.String."	^self asByteArrayEncoding: #JavaLangString</body><body package="JNIPort-StringEncoding">asJavaModifiedUTF8EncodedByteArray	"Answer the receiver as a ByteArray encoded in the variant of UTF8 that	is used in JNI and the JVM classfile format."	^self asByteArrayEncoding: #JavaModifiedUTF8</body></methods><methods><class-id>Core.Character class</class-id> <category>instance creation</category><body package="JNIPort-StringEncoding">combineSurrogate: leadingSurrogate with: trailingSurrogate 	"Combine the leading and trailing surrogate code points (which are Integers) to the corresponding supplementary character. The algorithm is taken from the UTF-16 FAQ at http://www.unicode.org/unicode/faq/utf_bom.html#35	const UTF32 SURROGATE_OFFSET = 0x10000 - (0xD800 &lt;&lt; 10) - 0xDC00;	// result: -56613888	UTF32 codepoint = (lead &lt;&lt; 10) + trail + SURROGATE_OFFSET;"	| codePoint |	codePoint := (leadingSurrogate asInteger bitShift: 10) + trailingSurrogate asInteger				- 56613888.	"SURROGATE_OFFSET"	^self value: codePoint</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="JNIPort-StringEncoding">isLeadingSurrogate	"Answers if the receiver is in the leading surrogate range, i.e. its code point is between 16rD800 and 16rDBFF."	^self asInteger between: 16rD800 and: 16rDBFF</body><body package="JNIPort-StringEncoding">isSupplementary	"Answers if the receiver is a supplementary Character according to Unicode 4.0, i.e. if its code point is larger than 0xFFFF, but not larger than the largest legal code point 0x10FFFF."	^self asInteger between: 16r10000 and: 16r10FFFF</body><body package="JNIPort-StringEncoding">isTrailingSurrogate 	"Answers if the receiver is in the trailing surrogate range, i.e. its code point is between 16rDC00 and 16rDFFF."	^self asInteger between: 16rDC00 and: 16rDFFF</body></methods><methods><class-id>Core.Character</class-id> <category>accessing</category><body package="JNIPort-StringEncoding">leadingSurrogate	"Answers the leading surrogate code point (an Integer) for the receiver, if it is a supplementary character, otherwise raises an Error. The algorithm is taken from the UTF-16 FAQ at http://www.unicode.org/unicode/faq/utf_bom.html#35	const UTF32 LEAD_OFFSET = 0xD800 - (0x10000 &gt;&gt; 10);	//  result: 16rD7C0 or 55232	UTF16 lead = LEAD_OFFSET + (codepoint &gt;&gt; 10);	UTF16 trail = 0xDC00 + (codepoint &amp; 0x3FF);"	self isSupplementary 		ifFalse: [^self error: 'Only supplementary characters have surrogates.'].	^16rD7C0 + (self asInteger bitShift: -10)</body><body package="JNIPort-StringEncoding">trailingSurrogate	"Answers the trailing surrogate code point (an Integer) for the receiver, if it is a supplementary character, otherwise raises an Error. The algorithm is taken from the UTF-16 FAQ at http://www.unicode.org/unicode/faq/utf_bom.html#35	const UTF32 LEAD_OFFSET = 0xD800 - (0x10000 &gt;&gt; 10);	//  result: -67053568	UTF16 lead = LEAD_OFFSET + (codepoint &gt;&gt; 10);	UTF16 trail = 0xDC00 + (codepoint &amp; 0x3FF);"	self isSupplementary 		ifFalse: [^self error: 'Only supplementary characters have surrogates.'].	^16rDC00 + (self asInteger bitAnd: 16r03FF)</body></methods><methods><class-id>Core.UninterpretedBytes</class-id> <category>copying</category><body package="JNIPort-StringEncoding">copyJavaModifiedUTF8StringFromHeap	^self copyCStringFromHeap: #JavaModifiedUTF8</body></methods><methods><class-id>External.CTypedefType</class-id> <category>testing</category><body package="JNIPort-External">validateValue: anObject 	type validateValue: anObject</body></methods><methods><class-id>External.CPointer</class-id> <category>enumerating</category><body package="JNIPort-External">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block elementType: aCType	"Evaluate a2Block for all indexes and elements in the array the receiver points to, starting at element index aStartIndex, up to element index aStopIndex, where the elements are of type aCType. Note that in VisualWorks, the type will be ignored, because CPointers know about the type of the elements."	aStartIndex to: aStopIndex		do: [:i | a2Block value: i value: (self at: i - 1)]</body></methods><methods><class-id>External.CPointer</class-id> <category>testing</category><body package="JNIPort-External">isGarbageCollectable	^CPointer.GarbageCollectablePointers includes: self</body><body package="JNIPort-External">notNull	^self isNull not</body></methods><methods><class-id>External.CProcedurePointer</class-id> <category>testing</category><body package="JNIPort-External">notNull	^self isNull not</body></methods><methods><class-id>External.CProcedurePointer</class-id> <category>accessing</category><body package="JNIPort-External">resultType	"Answers the type result of the procedure."	^type baseReferentType resultType</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="JNIPort-External">fromAddress: aPointer length: length 	| bytes |	bytes := self new: length.	(CIntegerType unsignedShort pointerType cast: aPointer) 		copyAt: 0		to: bytes		size: length		startingAt: 1.	^bytes</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="JNIPort-External">isNull	^true</body><body package="JNIPort-External">notNull	^false</body></methods><methods><class-id>External.CPointerType class</class-id> <category>instance creation</category><body package="JNIPort-External">nullPointer	^self uniqueDefaultPointer newOfAddress: 0</body></methods><methods><class-id>External.CType</class-id> <category>converting</category><body package="JNIPort-External">arrayType	"Answers a type representing an array of the receiver type."	^CArrayType new referentType: self</body><body package="JNIPort-External">arrayType: anInteger 	"Answers a type representing an array of size anInteger of the receiver type."	^(self arrayType)		numElements: anInteger;		yourself</body><body package="JNIPort-External">pointerArrayType	"Answers a type representing an array of pointers to the receiver type."	^self pointerType arrayType</body><body package="JNIPort-External">pointerArrayType: anInteger 	"Answers a type representing an array of size anInteger of pointers to the receiver type."	^self pointerType arrayType: anInteger</body></methods><methods><class-id>External.CType</class-id> <category>testing</category><body package="JNIPort-External">validateValue: anObject 	"Nothing to do. Subclasses which do range checking should validate anObject and raise an IllegalAssignment exception if the object is not appropriate for the type."</body></methods><methods><class-id>External.CIntegerType</class-id> <category>testing</category><body package="JNIPort-External">validateValue: anObject	| valueIsValid |	valueIsValid := self isBoolean				ifTrue: [anObject == false or: [anObject == true]]				ifFalse: [anObject asInteger between: self minVal and: self maxVal].	valueIsValid ifFalse: [IllegalAssignmentSignal raiseWith: anObject]</body></methods><methods><class-id>External.CCompoundType</class-id> <category>enumerating</category><body package="JNIPort-External">memberNames	"Answers the receiver's member names."	| memberNames |	memberNames := OrderedCollection new.	self memberNamesDo: [:memberName | memberNames add: memberName].	^memberNames</body><body package="JNIPort-External">memberNamesDo: aBlock 	"Evaluate the one argument aBlock for the receiver's member names "	| index size slotsPerMember |	index := 1.	size := self size.	slotsPerMember := self slotsPerMember.	[index &lt;= size] whileTrue: 			[aBlock value: (self memberNameAt: index).			index := index + slotsPerMember]</body></methods><methods><class-id>Core.Integer</class-id> <category>double dispatch</category><body package="JNIPort-StandardLibInterface">addToVaList: aVaList	"Private -- add a representation of the receiver to aVaList.	This is part of the implementation of SequenceableCollection&gt;&gt;asVaList.	Since we can only make a best guess at what representation is	most appropriate it may sometimes be better to build a VaList explicitly	rather then using #asVaList.	This is a particular problem for Integer since we can't know which of the	{signed/unsigned} {short/int/long/__int64} representations is right"	aVaList addInt: self.</body></methods><methods><class-id>External.CPointer</class-id> <category>converting</category><body package="JNIPort-StandardLibInterface">asVaList	"Answers the receiver. We assume that it points to a VaList."	^self</body></methods><methods><class-id>Core.Number</class-id> <category>double dispatch</category><body package="JNIPort-StandardLibInterface">addToVaList: aVaList	"Private -- add a representation of the receiver to aVaList.	This is part of the implementation of SequenceableCollection&gt;&gt;asVaList.	Since we can only make a best guess at what representation is	most appropriate it may sometimes be better to build a VaList explicitly	rather then using #asVaList"	aVaList addFloat: self asFloat.</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="JNIPort-StandardLibInterface">asVaList	"Answers a VaList with the same contents as the receiver.  Note that this is not aways	exacty what you might want since we can only ask our elements to add themselves	to the VaList, and they may 'guess' wrong about what format to use -- e.g. LargeInteger	does not automatically add itself as a 64-bit field"	^VaList from: self</body></methods><methods><class-id>Core.String</class-id> <category>comparing</category><body package="JNIPort-StandardLibInterface">strcmp: comparand	"Direct access to C runtime strcmp()."	^StandardLibInterface default strcmp: self string2: comparand</body></methods><methods><class-id>Core.String</class-id> <category>printing</category><body package="JNIPort-StandardLibInterface">vsnprintfWithArguments: aSequenceableCollectionOrCPointer 	"Answer a String which is a message formatted from the receiver (assumed to be a C-printf	format String) with substitutions from the given SequenceableCollection of arguments.	Note:	- The argument can be a previously created VaList instead of a SequenceableCollection.	- This is not yet supported on 64bit systems.	E.g:		format two Floats right-justfied in a field of width 12, with 2 places of precision, and		forcing the use/non-use of scientific notation.		'[%*.*f][%*.*e]' vsnprintfWithArguments: #(12 2 3.141592653 12 2 3.141592653)		format an integer right-justfied in a field of width 12, 0-padded to 5 digits.		'[%*.*d]' vsnprintfWithArguments: #(12 5 33)		format a string left-justfied in a field of width 30.		'[%*s]' vsnprintfWithArguments: #(-30 'Hi there')		format a string left-justfied in a field of width 10 and truncated to 3 letters.		'[%-*.*s]' vsnprintfWithArguments: #(10 3 'Hi there')		format 3 characters in fields of width 5.		'[%5c][%5c][%5c]' vsnprintfWithArguments: #($A $B $C)		format an integer as hex, 0-padded to 8 digits.		'0x%.*X' vsnprintfWithArguments: #(8 47789)	"	| vaList n crt buffer size formattedString |	crt := StandardLibInterface default.	vaList := aSequenceableCollectionOrCPointer asVaList.	size := self size + 128.	"we don't know enough info to make a better guess"		[	[buffer := (String new: size) copyToHeap. "This will create a buffer of length (size + 1), cf. the implementation of String&gt;&gt;copyToHeap:encoding:."	n := crt 			vsnprintf: buffer			count: size			format: self			vaList: vaList.	"Linux: In recent versions of glibc, if n is equal to or greater than the buffer length (i.e. strictly greater than size), then the output was truncated, and n is the number of bytes which would have been written, excluding the terminating null character. glibc 2.0.6 and earlier return -1 when the output was truncated.	MS Windows: If the buffer is not large enough, the answer is -1. If it is positive, it is the number of characters written, excluding the terminating null character.	If n is less than -1, there was a real error, so give up."	n &lt; -1 ifTrue: [^self error: 'Error in vsnprintf'].	n &lt; 0 or: [n &gt; size]] 			whileTrue: 				[buffer free.				size := n &gt; 0 					ifTrue: [n	"Linux/Unix: n is the number of bytes needed"]					ifFalse: [size + 100	"Windows: We don't know how large the buffer should be, make it larger. Doubling could lead to exceedingly large buffers."]].	formattedString := buffer copyCStringFromHeap] 			ensure: [buffer free].	^formattedString</body></methods><methods><class-id>Core.Boolean</class-id> <category>double dispatch</category><body package="JNIPort-StandardLibInterface">addToVaList: aVaList	"Private -- add a representation of the receiver to aVaList.	This is part of the implementation of SequenceableCollection&gt;&gt;asVaList.	Since we can only make a best guess at what representation is	most appropriate it may sometimes be better to build a VaList explicitly	rather then using #asVaList"	aVaList addBoolean: self.</body></methods><methods><class-id>Core.Object</class-id> <category>double dispatch</category><body package="JNIPort-StandardLibInterface">addToVaList: aVaList	"Private -- add a representation of the receiver to aVaList.	This is part of the implementation of SequenceableCollection&gt;&gt;asVaList.	Since we can only make a best guess at what representation is	most appropriate it may sometimes be better to build a VaList explicitly	rather then using #asVaList"	aVaList addAddressOf: self.</body></methods><methods><class-id>Core.Character</class-id> <category>double dispatch</category><body package="JNIPort-StandardLibInterface">addToVaList: aVaList	"Private -- add a representation of the receiver to aVaList.	This is part of the implementation of SequenceableCollection&gt;&gt;asVaList.	Since we can only make a best guess at what representation is	most appropriate it may sometimes be better to build a VaList explicitly	rather then using #asVaList"	aVaList addChar: self.</body></methods><methods><class-id>Core.Metaclass</class-id> <category>*JNIPort-GhostClasses</category><body package="JNIPort-GhostClasses">ghostClassRoot	"If the receiver is a ghost class then answer the 'real' class from which it was derived,	otherwise answer the receiver."	^ self instanceClass ghostClassRoot class</body><body package="JNIPort-GhostClasses">isGhostClass	"Answer whether the receiver is a 'ghost class'.  None of the normal Smalltalk classes	are, only those generated on-the-fly by #makeGhostClass:, and they never appear	in the class browsers etc."	^ self instanceClass isGhostClass.</body></methods><methods><class-id>Core.Class</class-id> <category>*JNIPort-GhostClasses</category><body package="JNIPort-GhostClasses">anonymousSubclass: aString 	"Answer a new subclass of the receiver which is not installed as a global variable, nor	linked into the class hierarchy proper.  It will consider its name to be aString, but is -- of	course -- not accessible under that name"	| newMeta newClass importDefinitions |	newMeta := (Metaclass new)				superclass: self class;				methodDictionary: MethodDictionary new;				setInstanceFormat: self class format;				yourself.	newClass := (newMeta new)				superclass: self;				methodDictionary: MethodDictionary new;				setInstanceFormat: (self format);				setName: aString asSymbol;				yourself.	"normal classes have Symbol names, so we might as well too"	importDefinitions := newClass importDefinitions.	importDefinitions add: ((GeneralNameSpaceImport pathString: #JNIPort) private: true).	newClass setImportDefinitions: importDefinitions.	^newClass</body><body package="JNIPort-GhostClasses">ghostClassRoot	"If the receiver is a ghost class then answer the 'real' class from which it was derived,	otherwise answer the receiver."	^ self isGhostClass		ifTrue: [self superclass ghostClassRoot]		ifFalse: [self].</body><body package="JNIPort-GhostClasses">isGhostClass	"Answer whether the receiver is a 'ghost class'.  None of the normal Smalltalk classes	are, only those generated on-the-fly by #makeGhostClass:, and they never appear	in the class browsers etc."	^ false.</body><body package="JNIPort-GhostClasses">makeGhostClass: aString 	"Answer a new subclass of the receiver which is not installed as a global variable, nor	linked into the class hierarchy proper.  It will consider its name to be aString, but is -- of	course -- not accessible under that name  It will have no instance methods installed initially,	and only:		isGhostClass ^ true.	on the class side"	| ghost |	ghost := self anonymousSubclass: aString.	GhostMethod installIsGhostClassMethodIn: ghost.	^ghost</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>*JNIPort-GhostClasses</category><body package="JNIPort-GhostClasses">addSelector: aSymbol withGhostMethod: aCompiledMethod	self addSelector: aSymbol withMethod: aCompiledMethod</body><body package="JNIPort-GhostClasses">compileGhostMethod: aString map: aDictionary	"Private - Compile aString and enter a GhostMethod corresponding to the result to our	method dictionary.	The map is a Dictionary mapping literals in the generated method's to replacement values.	The important thing about ghost methods is that they consume few system resources -- they	are not written to the change log.	Answers the ghost method or raises an Error if the compilation failed."	| methodNode method aCompiledMethod |	methodNode := self compilerClass new				compile: aString				in: self				notifying: nil				ifFail: [nil].	aCompiledMethod := methodNode generate.	method := GhostMethod newAsCopyOf: aCompiledMethod in: self.	aDictionary ifNotNil: [method replaceSymbolLiteralsUsing: aDictionary].	^method</body><body package="JNIPort-GhostClasses">compilePrototypeMethod: methodSource 	| methodNode |	methodNode := self compilerClass new 				compile: methodSource				in: self				notifying: nil				ifFail: [nil].	^GhostMethod newAsCopyOf: methodNode generate		in: self ghostClassRoot</body><body package="JNIPort-GhostClasses">ghostClassRoot	^self subclassResponsibility</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>*JNIPort-GhostClasses</category><body package="JNIPort-GhostClasses">isGhostMethod	^false</body><body package="JNIPort-GhostClasses">replaceSymbolLiteralsUsing: aDictionary 	1 to: self numLiterals		do: 			[:i | 			| literal |			(literal := self basicAt: i) isSymbol 				ifTrue: 					[| replacement |					replacement := aDictionary at: literal ifAbsent: [literal].					replacement == literal ifFalse: [self literalAt: i put: replacement]]				ifFalse: 					[(literal isKindOf: CompiledBlock) 						ifTrue: [literal replaceSymbolLiteralsUsing: aDictionary]						ifFalse: 							[BlockClosure == literal class 								ifTrue: [literal method replaceSymbolLiteralsUsing: aDictionary]]]]</body></methods><methods><class-id>JNIPort.StandardLibInterface</class-id> <category>public interface</category><body package="JNIPort-StandardLibInterface">strcmp: string1 string2: string2 	"Answer the order between the &lt;String&gt; arguments, string1 and string2."	&lt;C: int strcmp( const char *string1, const char *string2 )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>JNIPort.StandardLibInterface</class-id> <category>procedures</category><body package="JNIPort-StandardLibInterface">callVsnprintf: buffer count: maxbuf format: format va_list: aVaList 	"Private - Write data formatted by the format string into the buffer; aVaList	supplies the 'variable' arguments to the call.	This function should be available on most platforms, but currently, we cannot	use VaLists on 64bit systems - their memory layout there seems to be different,	such that we can't pass them as a parameter to an external function."	&lt;C: int vsnprintf( char *buffer, size_t maxbuf, const char *format, va_list aVaList )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-StandardLibInterface">primGetenv: string 	"Answer the value of the environment variable aString."	&lt;C: char * getenv( const char *string )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>CDatum</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>theDatum type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>CProcedurePointer</name><environment>External</environment><super>External.CDatum</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>CCallback</name><environment>External</environment><super>External.CProcedurePointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>CType</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specifierFlags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>ExceptionSet</name><environment>Core</environment><super>Core.IdentitySet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>RecursionLock</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CTypedefType</name><environment>External</environment><super>External.CQualifiedType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CCompoundType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>HandleRegistry</name><environment>OS</environment><super>Core.WeakDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>CIntegerType</name><environment>External</environment><super>External.CScalarType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>Signal</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent mayProceed notifierString nameClass nameMessage exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CPointer</name><environment>External</environment><super>External.CDatum</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class></st-source>