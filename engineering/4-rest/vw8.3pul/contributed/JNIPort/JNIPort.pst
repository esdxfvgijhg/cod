<?xml version="1.0"?><st-source><!-- Name: JNIPortNotice: Copyright © 2006-2014 Joachim GeidelPortions of this software created by Chris Uppal are © Chris Uppal.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.- - Portions of this software which were created by Chris Uppal are covered by Chris Uppal's  license:"The terms under which you may use the software from this site are:    * You must not claim that you wrote it.    * You must not claim that you own it.    * You use it at your own risk.So you can pretty-much use it for what you like, provided you are honest about it."BundleName: JNIPortBundleStructure: a Store.BundleForParcelComment: This bundle contains an interface to the Java Virtual Machine. It is based in the Java Native Interface (JNI). The original implementation was done by Chris Uppal in Dolphin Smalltalk. The bundle contains a port of this implementation to VisualWorks. Documentation is online at	http://jniport.wikispaces.com/The documentation is work in progress. You can monitor updates by subscribing to the RSS feed at	http://jniport.wikispaces.com/space/xmla?v=rss_2_0To use JNIPort, you also need the following components:	- "JNIPort Prerequisites",	- "Registry" (version 28 or later),	- "FastCMethodPointers" (version 1.1 or later),	- "WeakCollections" (version 5 or later).Tests for JNIPort are available in "JNIPort Tests", and development tools in "JNIPort Tools".These components are available as parcels in the "Contributed" directory of the VisualWorks distribution. Alternatively, you can load them from the Cincom Public Repository. If you load JNIPort from a Store repository, you should configure the Store > Prerequisites settings in the VisualWorks Settings tool such that Store always loads the latest versions with blessing level "Development", and to search bundles and packages first. Some of the prerequisites are distributed with VisualWorks as parcels, e.g. the Registry parcel in the Contributed directory of the VisualWorks distribution. If you want to load these parcels instead of packages from a Store repository, set the search policy for prerequisites of type #any to "Search parcels first" in the Store > Prerequisites settings.The bundle JNIPort contains two archives with additional files:JNIPort_Extras.zip 	This archive contains the following files:	DolphinJNIHelper.dll and its source code 				This library is needed for handling the hook functions provided by JNI for monitoring the state of a running JVM. See the package comment of ''CU JNI Helper''.		Currently only available for MS Windows. The source code is in src/DolphinJNIHelper.	JNIPort30.jar and its source code in src/JNIPort		This Java library is necessary for handling callbacks from Java to Smalltalk.	JNIPort30-Tests.jar and its source code in src/JNIPort/test and src/JNIPort/examples		This Java library contains classes which are needed for running the tests in the bundle ''JNIPort Tests''.JNIPort_Docs.zip 	This archive contains the original JNIPort documentation written by Chris Uppal. Please read this before using JNIPort.Example for using JNIPort with automatic generation of wrapper classes and methods for Java classes (when evaluating the code, ignore warnings about undefined selectors):- - - - - - - - - - - - - - - - - - - - - - - - [| jvmSettings jvm zfClass zipfile entries |jvmSettings := (JNIPort.JVMSettings new)			name: 'JVM with ghost class generation';			yourself.jvmSettings usesGhosts: true.jvmSettings jniPortSettings useJNIHelperLibrary: false.jvm := JNIPort.JVM newWithSettings: jvmSettings.zfClass := jvm findClass: #'java.util.zip.ZipFile'.zipfile := zfClass new_String: 'JNIPort.jar'.zipfile size. "- > answers an Integer"entries := zipfile entries.entries asAnEnumeration do: [:each | Transcript cr; print: each].]- - - - - - - - - - - - - - - - - - - - - - - - You can start only one Java virtual machine per operating system process. This means that once a JVM has been initialized, you have to leave it running until it is no longer needed. You can always access it by evaluating the expression "JVM current".DevelopmentPrerequisites: #(#(#any 'FastCMethodPointers' '') #(#any 'WeakCollections' '') #(#any 'Registry' '') #(#any 'JNIPort Prerequisites' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'DLLCC' #componentType #package) #(#name 'JNIPort-VW-Extensions' #componentType #package) #(#name 'JNIPort-StringEncoding' #componentType #package) #(#name 'JNIPort-StandardLibInterface' #componentType #package) #(#name 'JNIPort-Namespace' #componentType #package) #(#name 'JNIPort-GhostClasses' #componentType #package) #(#name 'JNIPort-External' #componentType #package) #(#name 'JNIPort-CollectionAdaptors' #componentType #package))Padded: falseParcel: nilParcelName: JNIPortPrerequisiteDescriptions: #(#(#name 'FastCMethodPointers' #componentType #package) #(#name 'WeakCollections' #componentType #package) #(#name 'Registry' #componentType #package) #(#name 'JNIPort Prerequisites' #componentType #bundle))PrerequisiteParcels: #(#('FastCMethodPointers' '') #('WeakCollections' '') #('Registry' '') #('JNIPort Prerequisites' ''))Version: 3.0a4Date: 5:09:58 PM August 22, 2014 --><time-stamp>From VisualWorks®, Pre-Release 8.0 (aug14.2) of 8 August 2014 on 22 August 2014 at 17:09:58</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>JavaClassWrapperGenerator</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classStatic targetClass installer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaClassWrapperGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaClassWrapperInstaller</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source destination settings installed problems classGeneratorClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaClassWrapperInstaller</class-id><body>Copyright © Chris Uppal, 2002-2007.chris.uppal@metagnostic.orgThis class exist mainly in order to reduce the number of subclasses of JavaClassWrapperGenerator and JavaMethodGenerator, and duplication amongst those subclasses.  The problem being that we would need a ghost subclass of each "leaf" class, and that those subclasses would contain a great deal of duplicated code.  By factoring some of the logic into this class, which is designed to have a subclass that knows how to install ghost classes, we can eliminate a useful amount of that duplication.However it is also nice to have a split of resposnibility between the classes that generate method sources, and those that actually install the compiled methods, so this class (and its subclasses) aren't *just* workarounds for the lack of multiple-inheritance (or mixins, or whatever).</body></comment><class><name>JavaGhostClassInstaller</name><environment>JNIPort</environment><super>JNIPort.JavaClassWrapperInstaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JavaGhostClassInstaller</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaObject</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaObject</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgAbstract class that captures the commonality amongst a number of subclasses that all, in some way or other, act as "proxies" for entities in a Java runtime.  The principle subclasses are JavaInstance, which are proxies for Java objects, and JavaStatic, which are "proxies" for Java classes (the name proxy is misleading, "facade" might be better, because there is no such object as a Java class, however they act uniformly with the real proxies, so...).The immediate subclasses (down a couple of levels) are the JNIPort framework.  Below that are various custom subclasses that wrap different Java classes.  E.g. JavaLangString corresponds to (the instance side of) java.lang.String.The main features of this class are that instances all:	- know what their owning JVM is (and therefor also know the JNIEnv to use to talk to the Java runtime).	- have a variety of methods for calling Java methods and accessing Java fields.Many of thoese methods require a JNI signature.  For more information on them see either the Java (JNI or JVM) documentation, or read Docs\JNIPort\jni-names.html.</body></comment><class><name>JavaInstance</name><environment>JNIPort</environment><super>JNIPort.JavaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>static javaIdentityHash </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaInstance</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgAbstract class that captures the commonality amongst a number of subclasses, each of which represents a proxy (in some sense, that depends on the subclass) for a Java object.The main points of this class are to expose some reflection methods, and to provide default wrapper methods for all the methods defined on java.lang.Object.  (Since *all* Java objects inherit from java.lang.Object, it is always possible to call, say, toString() in Java, even if the reference is declared to be of an interface type that doens't obviously provide toString().  To emulate that we define wrappers for those methods here, rather than down in the JavaLangObject subclass where you might expect to find them).</body></comment><class><name>JavaClassInstance</name><environment>JNIPort</environment><super>JNIPort.JavaInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jniObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaClassInstance</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgAbstract class.Instances of sub-classes stand in a direct 1-1 relationship with instances of JNIObject (or its subclasses).  That is they wrap the JNI "pointer" to a Java object.These are strongly managed in the sense that they are finalizable and will arrange that the owning JVM is told when they die.  This permits it to release the JNI "local ref" to that object.Note that these are proxies for *references* to Java objects.  I.e. you can have more than one proxy for the same Java object.  The #= and #hash method are defined such that they test for identity of the underlying Java object.</body></comment><class><name>JavaLangObject</name><environment>JNIPort</environment><super>JNIPort.JavaClassInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangObject</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgWrapper for instances of java.lang.Object, and other Java classes that are not given more specialised wrappers.It is not necessary to derive wrappers for subclasses of java.lang.Object from this class, but it is normally tidier to try to keep the Java class hierarchy and the wrapper hierarchy recognisably similar.</body></comment><class><name>JNIPortAbstractSmalltalkRequest</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JNIPortAbstractSmalltalkRequest</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class jniport.AbstractSmalltalkRequest</body></comment><class><name>JNIPortSmalltalkRequest</name><environment>JNIPort</environment><super>JNIPort.JNIPortAbstractSmalltalkRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JNIPortSmalltalkRequest</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class jniport.SmalltalkRequest</body></comment><class><name>JavaLangThread</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangThread</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.Thread</body></comment><class><name>JavaInstanceClassWrapperGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaClassWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaInstanceClassWrapperGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaLangReflectAccessibleObject</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameCache declaredInCache declaredInCacheIsValid modifiersCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgI've defined #getDeclaringClass, #getModifiers, and against #getName this class, although the Java doc doesn't require java.lang.reflect.AccessibleMember to implement java.lang.reflect.Member.  All the instantiable subclasses do implement it, so it's better to put the method short-cuts here.Similarly java.lang.Class isn't really a subclass of java,lang.reflect.AccessibleObject, but it is convenient to treat it as if it were.</body></comment><class><name>JavaLangReflectMethod</name><environment>JNIPort</environment><super>JNIPort.JavaLangReflectAccessibleObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCache parameterTypesCache signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangReflectMethod</class-id><body>Copyright © Chris Uppal, 2001 - 2005.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.reflect.Method.I've included a few wrappers (#isBridge_null, #isVarargs_null, #isSynthetic_null) that are only defined in JDK1.5.  The 'raw' wrappers will fail with a no-such-method error if we are running on an earlier JVM.  The 'cooked' wrappers (#isBridge, #isVarargs, #isSynthetic) trap the error and answer false.</body></comment><class><name>JavaStatic</name><environment>JNIPort</environment><super>JNIPort.JavaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jvm classObject javaSuperclass instanceClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgA JavaStatic (usually referred to as a "class static", or just a "static") is an object that stands for a Java class.  It acts as a "proxy" for the class in the sense that the static methods and fields of the Java class are exposed via methods on these objects.Each instance is paired with a normal (instance-side) proxy for the actual java.lang.Class object that stands for the class in Java space.  That object is accessed by #classObject.All JavaInstances know which JavaStatic they belong to, e.g. all wrappers for java.lang.String objects (which are all instances of JavaLangString) know that they are owned by the specific instance of JavaStatic that corresponds to java.lang.String (actually that instance will be the only instance of our subclass StaticJavaLangString).  You can get the owning class static of any class instance by sending it the #static message.</body></comment><class><name>JavaClassStatic</name><environment>JNIPort</environment><super>JNIPort.JavaStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry allInstancesAreCanonical </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaClassStatic</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgSpecialised form of class static that is used to wrap classes that have instances.  This adds the machinery needed to allow class statics to fullfill their responsibility of wrapping Java object references in instances of the correct proxy classes (our instanceClass).Since these stand for instantiable Java classes, they add the ability to act as factories for Java objects of the corresponding type.  E.g. see #new.Note also that instances can be used to to filter exceptions in the same way as the JavaException or JavaLangThrowable classes (see either of those classes' comments).</body></comment><class><name>StaticJavaLangObject</name><environment>JNIPort</environment><super>JNIPort.JavaClassStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangObject</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgWrapper for the class-side java.lang.Object, and other Java classes that are not given more specialised wrappers.It is not necessary to derive wrappers for subclasses of java.lang.Object from this class, but it is normally tidier to try to keep the Java class hierarchy and the wrapper hierarchy recognisably similar.</body></comment><class><name>JavaException</name><environment>JNIPort</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaException</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgThese are used to hold a Java exception.  The 'tag' is an instance of some subclass of JavaLangThrowable which, in turn, wraps (or is a proxy for) a reference to a Java java.lang.Thowable object.It's worth noting that you can trap Java exceptions (in Smalltalk) by doing something like:	[...blah blah...]		on: XXX		do: [:err | ...]where XXX can be any of:	This class (i.e. normal Smalltalk exception trapping).	JavaLangThrowable, or a subclass.	The class Static of the Java class of the Java exception object.</body></comment><class><name>JavaAggregate</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptorCache sizeCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaAggregate</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgAbstract class that collects together some behaviour of Java objects which can be mapped onto a Collections-like interface.There are a few short-hand methods defined (#do: #select: #inject:into: and so on), but mostly you get a Collection-flavoured interface by asking for its Collection adaptor with #asCollection.</body></comment><class><name>JavaPrimitiveArray</name><environment>JNIPort</environment><super>JNIPort.JavaAggregate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgAbstract class that gathers together the common behaviour of Java's various kinds of arrays.Note that there is no defined Java class corresponding to *any* array.  Java arrays are always objects, and they have java.lang.Class objects, they all have a public clone() method, and they all have the readonly instance-side field, *but* there is no java.lang.Array class of which they are all (sub)instances.That may make sense to you; it doesn't to me.  Sigh...</body></comment><class><name>JavaIntArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaIntArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java int arrays.</body></comment><class><name>StaticJavaLangClass</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangClass</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Class and provide access to its class-side methods.</body></comment><class><name>JavaStaticWrapperGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaClassWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaStaticWrapperGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>StaticJavaLangNumber</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangNumber</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Number and would provide access to its class-side methods and fields if it had any...</body></comment><class><name>StaticJavaLangLong</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangLong</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Long and provide access to its class-side methods and fields.</body></comment><class><name>JavaPrimitiveStatic</name><environment>JNIPort</environment><super>JNIPort.JavaStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgJava's primitive types are not classes, but there are instances of java.lang.Class corresponding to each of them.  So we have corresponding specialised class statics too.  They don't actually add a lot of value except that by using these things we can use polymorphism for some common tests, instead of having to go back to the Java runtime for information.</body></comment><class><name>JavaPrimitiveDoubleStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveDoubleStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaIteratorAdaptor</name><environment>JNIPort</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaIteratorAdaptor</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgOne of thise will wrap any JavaClassInstance which implements the java.util.Iterator interface.  It acts as an adaptor to allow the wrappee to look like a ReadStream.Note: this uses the wrapper-style messages, #hasNext_null and #next_null, to call the Java methods.</body></comment><class><name>JNIPortVTableClient</name><environment>JNIPort</environment><super>JNIPort.JNIPortExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vtable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIPortVTableClient</class-id><body>Basically we represent C++/COM like objects which store a pointer to a vtable in an instance variable.  Hence we can define methods on ourself which invoke the function pointers stored in the corresponding vtable.</body></comment><class><name>JNIPortJavaVM</name><environment>JNIPort</environment><super>JNIPort.JNIPortVTableClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIPortJavaVM</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgWrapper for JNI's JavaVM type.Note: the name of this class is derived from the JNI documentation.  Instances are *not* JVM's (neither here nor in JNI), they are simply structures that allow access to JNI functionality on a non-per-thread basis (mostly for administering the relationship between the JVM and the various client threads).</body></comment><class><name>JavaMethodGenerator</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass output generateComment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaMethodGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaMemberWrapperGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMethodGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reflection name generateLongKeywords includeTypeInSelector selectorCache parametersCache genericTypeNameCache jniSignatureCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaMemberWrapperGenerator</class-id><body>Copyright © Chris Uppal, 2002-2007.chris.uppal@metagnostic.org</body></comment><class><name>JavaFieldAccessorGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMemberWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaFieldAccessorGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaObjectRegistry</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jvm registry sharedMutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaObjectRegistry</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgThese are used by class statics (JavaClassStatic) to hold their collections of canonical instances.  These are essentially just weak sets that are specialised to hold just one JavaClassInstance for any given underlying Java object.</body></comment><class><name>JavaLangThrowable</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangThrowable</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgClass used to wrap instances of java.lang.Throwable.  When instances are thrown, the JNIPort machinery will actually throw an instance of JavaException, which contains the instance.  One effect of this is that you can trap Java exceptions (in Smalltalk) by doing something like:	[...blah blah...]		on: XXX		do: [:err | ...]where XXX can be any of:	JavaException (or a superclass, i.e. normal Smalltalk exception trapping).	This class, or a subclass.	The class Static of the Java class of the Java exception object.</body></comment><class><name>JavaLangError</name><environment>JNIPort</environment><super>JNIPort.JavaLangThrowable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaLangError</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.Error</body></comment><class><name>StaticJavaLangSystem</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangSystem</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgThis class exists to provide easy access to static methods and fields in the java.lang.System class.  An instance is available directly from the JVM by sending it #javaLangSystem.</body></comment><class><name>JavaLangClassLoader</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangClassLoader</class-id><body>Copyright © Chris Uppal, 2001 - 2005.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.ClassLoader.We add a (lazily created) JavaClassIndex to each instance, so that we can work as a &lt;JavaClassFinder&gt; with reasonable efficiency.  For this reason, we have to use canonical instances.</body></comment><class><name>JavaNetURLClassLoader</name><environment>JNIPort</environment><super>JNIPort.JavaLangClassLoader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaNetURLClassLoader</class-id><body>Copyright © Chris Uppal, 2005.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.ClassLoader.There's no real need for a wrapper for this class, but since I've added one for the class-side, I though I might as well do one for the instance-side too.</body></comment><class><name>JavaClassIndex</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index sharedMutex classFinder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaClassIndex</class-id><body>Copyright © Chris Uppal, 2001-2005.chris.uppal@metagnostic.orgThis is a cache keyed by the Java name of a class (e.g. int, java.lang.String, double[][]) expressed as a Symbol and containing the relevant class static.These are used as helpers by &lt;javaClassFinder&gt;s --  which is to say, either by the JVM object itself (though that actually uses an instance of a subclass) or by a java.lang.Classloader or a LocalJavaClasspathEntry.Note that the same class may appear in this index several times under different names.</body></comment><class><name>JavaInterfaceInstance</name><environment>JNIPort</environment><super>JNIPort.JavaInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaInterfaceInstance</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances take a JavaInstance and a JavaStatic and allow you to see the object as if it were an instance of the class.The point of this is to give some sort of organisation to how we wrap Java interfaces.In JNI, interfaces are just classes, and as such we represent them as instances of JavaLangClass.  Thus, the static members (methods and fields) of an interface are all accessed via the usual class static mechanism (see the comment on JavaStatic for more detail).However, it is common to want to provide helper methods which are defined against an interface.  E.g. we want to wrap the APIs of java.util.Collection and subinterfaces in such a way that they can be used with any object that implements those interfaces.  It'd be easy to add subclasses under JavaLangObject with defined helpers, but the problem is that those helper methods would only apply to instances of some specific Java class and its subclasses, rather than any class which implements the interface.Therefore we define this class and its subclasses.  Each instance is build from a JavaInstance and a JavaStatic (which ought to be an interface class).  These are used to construct an object which acts as if the underlying Java object were a member of the corresponding class.E.g. we can define a JavaUtilCollection subclass with helper methods to provide easy access to that API.  Now, when we have a Java object which implements that interface, we can wrap in in an instance of JavaUtilCollection, and invoke those methods directly on the new wrapper.JavaInstance has a method #as: which takes a JavaClassStatic object as argument and answers a new instance of (a subclass of) JavaInterface which has the JavaClassStatic object as its javaClass, and the original object as its real Java object.  It is conventional -- but by no means required -- that you only use the #as: mechanism to "cast" objects to their actual interfaces.E.g. given an object, hashMapObj, which wraps a Java instance of java.util.HashMap, and a JavaLangClass object for the java.util.Map interface:	hashMapObj := ...	mapInterface := jvm findClass: #'java.util.Map'.We can now say:	map := hashMapObj as: mapInterface.We can now access the static members of java.util.Map via the usual static mechanism (actually Map has no statics),  e.g:	xxx := map static callVoidMethod: 'anImaginaryStaticMethod' signature: '()V'.If anyone had set up a special subclass of JavaStatic for java.util.Map (but there'd be no point) then map static would answer an instance of that class.Similarly, if someone had set up a specialised subclass of JavaInterface for java.util.map with a #keysAndValuesDo: helper method on it (and there'd be a lot of point in doing so), then map would be an instance of that class and so we could say:	map keysAndValuesDo: [:key :value | ...].</body></comment><class><name>JavaExternalIterator</name><environment>JNIPort</environment><super>JNIPort.JavaInterfaceInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaExternalIterator</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgAbstract class intended to capture the commonality (or hide the differences, if you prefer to see it that way) between the old-style and new-style Java external iterators.  Of course, other iterator classes can be added too.This class and subclasses add a minimal set of &lt;ReadableStream&gt; protocol methods to Java's external iterators.  A more complete implementation can be obtained by asking for a ReadStreamAdaptor with #asReadStream.</body></comment><class><name>JavaUtilEnumeration</name><environment>JNIPort</environment><super>JNIPort.JavaExternalIterator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilEnumeration</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.Enumeration</body></comment><class><name>JavaClassNameMethodGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMethodGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaClassNameMethodGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>StaticJavaLangInteger</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangInteger</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Integer and provide access to its class-side methods and fields.</body></comment><class><name>JavaFieldSetterGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaFieldAccessorGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaFieldSetterGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaClassRegistry</name><environment>JNIPort</environment><super>JNIPort.JavaObjectRegistry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>javaLangClass javaLangObject javaLangString javaLangThrowable notificationQueue eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaClassRegistry</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgOne of these holds a collection of JavaLangClass objects.  It ensures that no further class objects are added which correspond to a Java class which is already in the registry.Ownership is shared between the JVM and the class static for java.lang.Class (which uses the class registry as its ObjectRegistry).It is important to understand that any objects entered into the registry are made *unfinalizable*.  That is because they are now "owned" by the registry and are no longer responsible for cleaning up after themselves.  Also note that the owning JVM is finalizable, and that it holds a ref to the registry; if the registry or any of its contents were finalizable too, then we'd have a finalization loop, where the Dolphin VM will choose one object *arbitrarily* to finalize first.</body></comment><class><name>JavaCodeWrapperGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMemberWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaCodeWrapperGenerator</class-id><body>Copyright © Chris Uppal, 2002-2007.chris.uppal@metagnostic.org</body></comment><class><name>JavaConstructorWrapperGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaCodeWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaConstructorWrapperGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaGhostConstructorGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaConstructorWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JavaGhostConstructorGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JNIHelper</name><environment>JNIPort</environment><super>JNIPort.JNIPortExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>library </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNIHelper</category><attributes><package>JNIPort-JNIHelper</package></attributes></class><comment><class-id>JNIPort.JNIHelper</class-id><body>Simple wrapper for the "helper" structures used by the DolphinJNIHelper DLL.Note that instances must release the corresponding resources in the DLL before they are garbage collected.</body></comment><class><name>JavaInterfaceStatic</name><environment>JNIPort</environment><super>JNIPort.JavaStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaInterfaceStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgSpecialised form of class static that is used to wrap interface classes.  This is split out from JavaClassStatic mainly just to allow us to substitute polymorphism for runtime tests (e.g. #isInterface).</body></comment><class><name>SupplementaryClassloaderTree</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jvm entriesByName eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.SupplementaryClassloaderTree</class-id><body>Copyright © Chris Uppal, 2005.chris.uppal@metagnostic.orgThis is the central object in the JNIPort framework for using custom Java classloaders.Please note that instances of java.lang.ClassLoader (and its subclasses) are normal Java objects like any other, and as such can be manipuilated via JNIPort without using this framework.  It's just a bit more work, and doesn't mesh very nicely with the wrapper class concept.First a bit of explanation about classloaders.  In Java you can define a classloader at any time, and then use it to load classes from classfiles (or similar).  The main points of doing so are:	- in order to obtain a namespace that is completely independent of any other.	- in order to be able to discard a classloader, and hence allow the classes it loaded to be GCed.Java classes are never GCed unless their owning classloader is also eligible for GC.   Classloaders are aranged into a tree.  At the root is the primordial classloader which is built into the JVM (often called the 'null classloader' or the 'bootstrap classloader'), this is often written in the same implementation language as the JVM itself, and so may not be a Java object at all (whence it's representation as Java 'null' -- and one of its nicknames).   As a child of that classloader is the 'application classloader', this is the one that loads the application classes from the %CLASSPATH% (or from the path supplied by a -cp argument, or whatever similar mechanism is used -- in JNIPort it's the #classpath in the #runtimeSetting that are used to initialise JNIPort).   Applications can then define further classloaders that are children of the application classloader.  It's important to realise any classloaders (if it follows the normal rules) will delagate any attempt to load a class to its parent /before/ it will attempt to load the class itself.  So classloaders do NOT "override" their parents.The JVM instance controlling JNIPort contains an instance of this class.  You can create and use additional instances independently of the one the JVM knows about, but this comment does not address that case.  The 'central' instance is created from the #supplementaryClassloaders sub-setting of the JNIPort settings.  If those sub-settings have #useAtStartup then JNIPort will create a tree of classloaders as it starts up, otherwise it will not do so, and the supplementary classloaders feature will be inactive (you can [dis]activate it by sending #useSupplementaryClassloaders: to the JVM object at any time after it has started up).The tree is populated by instances of SupplementaryClassloader.  Each of these has a Symbol name, a Symbol (or nil) name of its parent, and some data to alloow it to create an instance of java.lang.ClassLoader to do the actual classloading.  In fact, by default, they will create instances of java.net.URLClassLoader, and pass their #path string to it  to use as the search path.  SupplementaryClassloader can be added to, or removed from, the tree at any time after the JVM has started up, thus allowing some dynamic control over the algorothm use to locate Javas classsfiles by name.Each SupplementaryClassloader can be enabled or disabled (almost) independently of all the others.  If it is active, then it acts as a &lt;javaClassFinder&gt; and will find classes by name, (#findClass: -- just like the JVM object, which is also a &lt;javaClassFinder) using the internal java.lang.ClassLoader to do the work.  SupplementaryClassloader are laziliy initialised, when you ask one to frind a class it will first ask its parent (if any) to find the class, then if that fails, it will ensure that it is initialised (this is the time at which the internal classloader is created), and then ask the internal classloader to find the class with the given name.  If it finds one, then it will add the classname -&gt; class record to its classIndex (to be used as a cache), and answers the discovered JavaClassStatic.When a SupplementaryClassloader becomes active, it searches the hierarchy under JavaObject for any wrapper classes that declare that they are wrappers for classes that should be loaded via a SupplementaryClassloader with a given name.  Any such that it finds will be regstered with that SupplementaryClassloader in much the same way as most wrapper classes register with the JVM object.   Wrapper classes may elect to register with more than one SupplementaryClassloader, but there is no point in them attempting to register with the JVM object too, since it they do so, their underlying Java class will be loaded via the application or primordial classloader, and hence no custorm classloader will ever 'see' that class.   Classes opt-in to particular classloaders by answering a list of classloader names from the class-side method #supplementaryClassloaderNames.  Alternatively, you could override #shouldRegisterWithSupplementaryClassloader: if you need to use a more complicated criterion).Thus far we have seen that SupplementaryClassloaders allow you to load classes into custom classloaders, and to control what wrapper classes, if any, will be used for them.  That covers (as far as I think it worthwhile) the 'namespace' aspect of classloader use.   The other part is the dynamic loading/unloading part, which is probably best described by example.Say you are developing some new Java classes.  You would like to be able to test them out from Smalltalk, but there's a problem -- whenever you change and recompile a Java class, you have to restart Dolphin (and JNIPort) or it will not 'see' the changes.   SupplementaryClassloader are intended to help with this case (and with others involving dynamic use of classloaders, but this is the best example I can think of).  To do that, set up a SupplementaryClassloader called, say, #Development, and arrange that it's #path points to the place where your Java development tools (IDE or whatever) put the generated classfiles (a folder or JARfile).  That place must not be on your main classpath or (as I said above) the classes will be loaded by the application classloader and then can never be unloaded again.  You may need to set up a more complicated tree of classloaders, but for this simple case, I imagine that is unlikely.  Now you can activate the SupplementaryClassloader, you may choose to have it do so by default (in the settings) or maybe you prefer to do it explicitly.  You can also arrange to create the SupplementaryClassloader as part of the JNIPort settings, or do so explicitly from code after the JVM has started, in this case I think the former makes more sense, but either is possible.Once that is set up, you can load classes via the new classloader.  You can either say:	jvm := JVM current.	myClass := jvm findClass: 'my.test.Class' in: #Development.or you can ask for a reference to the SupplementaryClassloader itself,	jvm := JVM current.	loader := jvm supplementaryClassloaderNamed: #Development.and use that directly as a &lt;javaClassFinder&gt;	myClass := loader findClass: 'my.test.Class'.If you have set up any wrapper classes for 'my.test.Class' and arranged for the class's #supplementaryClassloaderNames to include #Development, then those classes will be set up as wrappers from the newly loaded class.  (BTW, at this time the Wrapper Generator Wizzard is not SupplementaryClassloader-aware, so you will have to create the relevant overload of #supplementaryClassloaderNames yourself).Now suppose that you change and re-compile your Java classes.  You now need to tell the #Development SupplementaryClassloader that it is out-of-date.  You do that by sending it #purge.  That will do several things:	1) purge any child classloaders in the tree.	2) remove any record of the classes it has loaded from JNIPort.	3) discard its own classloader (so that it can be re-created lazily).Now you can re-load the class by using #findClass: again, and JNIPort should now see the new versions of the classfiles.  If you are using Ghost Classes, then the ghost wrappers will be re-generated and will reflect any changes to the class definitions.Note that JNIPort does not (not yet, anyway) actually 'kill' the old class objects and their instances, so they will still hang around if you are holding onto references to them, and should continue to work more-or-less 'normally' (but it would be better not to rely on that -- 'normal' in this case probably means 'buggy').  Also it is your responsibility to remove any callbacks that rely on those classes, JNIPort won't do that for you.   NB: currently the supplementary classloader framework lacks proper mutex protection.  The class indexes themselves are OK, but the tree structure, and the 'central instance' in the JVM are not thread-safe.</body></comment><class><name>JavaReadStream</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaReadStream</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to the Java classes java.io.InputStream and java.io.Reader and their various subclasses.  Those two classes are not, in fact related in the Java class hierarchy, but there's some commonality that we capture here.This class adds a little of the Smalltalk ReadStream protocol, however the emulation is far from complete.  The problem being that the InputStream protocols seem to be built on the assumption that the stream is positionable, but Java input streams are not (they are not *arbitrarily* positionable).  One result of this is that although we can provide #upToEnd, we cannot provide #contents (since #contents reads from the *begining* of the stream, not from the current position).Instances will be binary or not depending on the Java object's class.</body></comment><class><name>JavaIoInputStream</name><environment>JNIPort</environment><super>JNIPort.JavaReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaIoInputStream</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.io.InputStream</body></comment><class><name>StaticJavaLangReflectModifier</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangReflectModifier</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.reflect.Modifier and provide access to its class-side methods (actually, most static fields).</body></comment><class><name>JVMSubSettings</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>flags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JVMSubSettings</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgThis class is to be considered deprecated since I intend to move the subclasses to use my more powerfull "application settings" package/framework, when -- if -- I finish it.</body></comment><class><name>SupplementaryClassloadersSettings</name><environment>JNIPort</environment><super>JNIPort.JVMSubSettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.SupplementaryClassloadersSettings</class-id><body>Copyright © Chris Uppal, 2005.chris.uppal@metagnostic.orgOne of these holds settings that are used for so-called 'supplementary classloaders -- see the class comment of SupplementaryClassloaderTree for more details.</body></comment><class><name>StaticJavaLangShort</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangShort</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Short and provide access to its class-side methods and fields.</body></comment><class><name>JVM</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name status javaVM jniEnv library jniHelper sharedMutex settings classRegistry classIndex rawJavaLangSystem rawJavaLangObject rawJavaLangClass isArrayMethodID isInterfaceMethodID identityHashCodeMethodID hashCodeMethodID equalsMethodID hasJava5Extensions externalCallbacks localCapacity localCount globalCount objectsCreated objectsReleased watchers supplementaryClassloaders objectRegistry eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JVM</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgThese act as the central point of the Java stuff.  Essentially instances act as hubs through which the various co-operating objects can find each other.  In particular instances are the entry-point through which newly created references to Java objects are wrapped in Smalltalk objects of the correct class.Also contains the initialisation code, and some housekeeping.Note that some of the logic of this class has been forcibly factored out into two subclasses. There is no OO justification for doing this, it just allows me to split out callback handling into a separate package.  Also the choice of concrete subclass is used as the means to configure whether callbacks are supported or not.  Note that all three classes were designed together and althogh physically separable, are not logically so.  Also note that the split into subclasses is not to my taste, so they may well end up merged together again in a later version of JNIPort.</body></comment><class><name>JavaWriteStream</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaWriteStream</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to the Java classes java.io.OutputStream and java.io.Writer and their various subclasses.  Those two classes are not, in fact related in the Java class hierarchy, but there's a fair amount of commonality that we capture here.This class adds a reasonably facsimile of the Smalltalk WriteStream protocol, #nextPut: etc.  Note that whether the stream is considered to be binary will depend on the Java class that we wrap.</body></comment><class><name>JNIVTableMethod</name><environment>JNIPort</environment><super>External.PreparedCMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>resultClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIVTableMethod</class-id><body>A JNIVTableMethod is a wrapper for a function pointer from a vtable of the JNI library, which translates a JNI specific result of a function call to an appropriate Smalltalk class.Instance Variables	resultClass	&lt;Class&gt;	Class of the results of a function call</body></comment><class><name>StaticJavaLangFloat</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangFloat</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Float and provide access to its class-side methods and fields.</body></comment><class><name>JavaMethodWrapperGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaCodeWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaMethodWrapperGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaGhostMethodGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMethodWrapperGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JavaGhostMethodGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JNIFieldID</name><environment>JNIPort</environment><super>JNIPort.JNIPortExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIFieldID</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgEquivalent to the JNI opaque pointer type, jfieldID.</body></comment><class><name>JavaNonvirtual</name><environment>JNIPort</environment><super>JNIPort.JavaInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaNonvirtual</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgThese are rather odd.  They are like the JavaInterfaceInstaces in that they make an existing JavaClassInstance act as if it were a member of some other class.   In this case that must be a superclass, and the supclasss methods will be invoked even if they are overridden in the actual class of the object.  The easiest way to create these is to use the #super method on JavaClassInstance.  Once created the new object will circumvent Java's method overrides.  E.g.	str := 'Hello there' asJavaString: jvm.	"java.lang.String.toString() returns itself, so:"	str toString_null asString.		--&gt; 'Hello there'	"but the overridden implementation in java.lang.Object.toString() returns a new String with	the class name and an ID number, and so sending the same message to the 'super' of the	same String object will answer that instead:"	str super toString_null asString.	--&gt; 'java.lang.String@ce2be576'You can send #super repeatedly to climb the inheritance chain, or you can use the class-side #wrap:asStatic: factory method directly.</body></comment><class><name>JavaSignature</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modifiers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaSignature</class-id><body>JavaSignature is an abstract class for objects representing the signature of Java members. Concrete subclasses represent the signatures of methods, fields, and constructors. JavaSignatures are created from the string representation of a member, i.e. the result of toString() sent to a java.lang.reflect.AccessibleObject. JavaSignatures are used for deriving Smalltalk selectors for wrapper methods, and for determining other properties of the member. A clean way to do this would be to use Java reflection, but parsing the signature string of a member in Smalltalk is much faster than using Java reflection.Subclasses must implement the following messages:	accessing		shortMethodName		type	initialize-release		fromString:Instance Variables:	modifiers	&lt;Collection of: String&gt;	the list of modifiers of the signature (abstract, private etc.)</body></comment><class><name>JavaByteArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaByteArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java byte arrays.Note that Java byte is a *signed* quantity.</body></comment><class><name>JavaContainerInterface</name><environment>JNIPort</environment><super>JNIPort.JavaInterfaceInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptorCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaContainerInterface</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgSubclasses are wrapers for various Java2 Collections interfaces.  Objects that implement those interfaces can be asked for the appropriate interface wrapper (using #asASet, etc), which will answer an instance of one of our subclasses.  The wrapper implements the basic methods of the corresponding Smalltalk class (#collect:, etc), and can answer a further adaptor that provides a more complete implementation if sent #asCollection.</body></comment><class><name>JavaUtilMap</name><environment>JNIPort</environment><super>JNIPort.JavaContainerInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilMap</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.Map</body></comment><class><name>JVMWithoutCallbacks</name><environment>JNIPort</environment><super>JNIPort.JVM</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JVMWithoutCallbacks</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgSpecial subclass of JVM that forbids any callbacks.  The principle differences are:	- we can use JNI "local" references (which are supposed to be faster).	- we (therefore) keep track of the local pool size, and adjust it when necessary.	- we don't set up a class registry.Please note: despite the subclass relationship, and despite the fact that this class is in a separate (and separable) package from the other concrete subclass, this class and the other and our superclass are not independent in design.</body></comment><class><name>JavaUtilCollection</name><environment>JNIPort</environment><super>JNIPort.JavaContainerInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilCollection</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.Collection</body></comment><class><name>JavaUtilSet</name><environment>JNIPort</environment><super>JNIPort.JavaUtilCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilSet</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.Set</body></comment><class><name>JavaPrimitiveVoidStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveVoidStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaCallbackHandler</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JavaCallbackHandler</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgA callback handler is an object that understands the #value:value: message.  They can be used as the "handlers" set in the callback registry.The Java class org.metagnostic.jniport.AbstractDolphinRequest defines a callback request as having (at least) an "originator" (often the object that sent the callback), and a "parameter" (an unconstained Java object).  This abstract class is a framework for handlers that use such conventions.</body></comment><class><name>JavaUtilSortedSet</name><environment>JNIPort</environment><super>JNIPort.JavaUtilSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilSortedSet</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.SortedSet</body></comment><class><name>JavaLangNumber</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaLangNumber</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of any of the concrete subclasses of Java class java.lang.Number</body></comment><class><name>JNIObject</name><environment>JNIPort</environment><super>JNIPort.JNIPortExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isLocalRef isReleased javaIdentityHash </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIObject</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgEquivalent to the JNI opaque pointer type, jobject.</body></comment><class><name>JavaMessageSend</name><environment>JNIPort</environment><super>JNIPort.JavaCallbackHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JavaMessageSend</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgThis class is designed to help with writing callback handlers for the case where the (proxy for the) originator is to be the target of a message and  the parameter is a (Java) array of parameters.</body></comment><class><name>JavaIoWriter</name><environment>JNIPort</environment><super>JNIPort.JavaWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaIoWriter</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.io.Writer</body></comment><class><name>JavaUtilComparator</name><environment>JNIPort</environment><super>JNIPort.JavaInterfaceInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilComparator</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.Comparator</body></comment><class><name>StaticJavaLangClassLoader</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangClassLoader</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.ClassLoader and provide access to its class-side methods.</body></comment><class><name>StaticJavaNetURLClassLoader</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangClassLoader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaNetURLClassLoader</class-id><body>Copyright © Chris Uppal, 2005.chris.uppal@metagnostic.orgThis wrapper exists mainly because the interface to creating instances is so odd. By providing an easier interface which takes an optional parent and optional array of Strings, we can compensate for the awkwardness, and also allow the "local class path" stuff to be more generic.</body></comment><class><name>JNIPortJNIEnv</name><environment>JNIPort</environment><super>JNIPort.JNIPortVTableClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>javaVM exceptionCheckFunction jniVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIPortJNIEnv</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgWrapper for JNI's JNIEnv type.Note: in JNI proper, there is one of these (at least) for each 'attatched' client thread.  Since Dolphin is single-threaded (in the sense that it's 'Processes' do not correspond to Windows threads), Dolphin looks to the JVM like just one thread, hence we use just one JNIEnv per JavaVM (unless we are usingcallbacks, in which case we need to maintain a stack of the things).Also note that since these can never exist without a corresponding JavaVM, we add an instvar to record what that is.</body></comment><class><name>JavaShortArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaShortArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java arrays of short.</body></comment><class><name>StaticJavaLangThread</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangThread</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Thread and provide access to its class-side methods and fields.</body></comment><class><name>JVMWatcher</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jvmIsInitialized </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JVMWatcher</class-id><body>Copyright © Chris Uppal, 2001-2004.chris.uppal@metagnostic.orgBase class for classes that are informed whenever a JVM starts up.  The typical action is to add a new instance to that JVM's watcher list; the JVM will then send notification messages to that watcher as it operates.The idea of a JVMWatcher is to allow flexible and configurable extensions to the JVM.  The immediate application is to create a Ghost class "manager" that watches for new classes being registered and converts them into ghosts.  Other potential applications will undoubtedly discover themselves to us in due course.Note that the list of subclasses to which a new JVM will send #onJvmStartup is configurable as part of the JavaBaseSettings, and therefore will vary on a by-JVM basis.  That is one reason why the event system is not used.  (Another is that the event system is relatively slow, and -- although I don't yet have a need for it -- this mechanism is intended to provide a tightly-coupled linkage to the JVM.)</body></comment><class><name>JVMGhostClassMaker</name><environment>JNIPort</environment><super>JNIPort.JVMWatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JVMGhostClassMaker</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgOne of these sits watching the JVM and waiting for new Java classes to be registered.  When they are it converts them to ghosts.</body></comment><class><name>JavaLangException</name><environment>JNIPort</environment><super>JNIPort.JavaLangThrowable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaLangException</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.Exception</body></comment><class><name>JavaPrimitiveCharStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveCharStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>AmbiguousJavaMethodError</name><environment>JNIPort</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.AmbiguousJavaMethodError</class-id><body>Thrown from automatically generated methods, if the "normal" (short) form of the method's selector corresponds to two (or more) Java members.  If that is the case then JNPort should have generated two (or more) other methods with long-form names that are not ambiguous.  The parameter of this exception holds an Association where the key is the ambiguous selector and the value is a Collection of the names of the alternative methods.</body></comment><class><name>JNINativeMethod</name><environment>JNIPort</environment><super>JNIPort.JNIPortExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signature name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNINativeMethod</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgWrapper for JNI's JavaNativeMethod type.</body></comment><class><name>JVMWithCallbacks</name><environment>JNIPort</environment><super>JNIPort.JVM</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jniEnvStack callbackRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JVMWithCallbacks</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgSpecial subclass of JVM that knows how to do callbacks.  The principle differences are:	- we force *all* JNI references to be global as soon as we see them.	- we don't (therefore) bother to keep track of the local pool size.	- we do set up a callback registry during initialisation.Please note: despite the subclass relationship, and despite the fact that this class is in a separate (and separable) package from the superclass, and the other concrete subclass, this class and the other two are not independent in design.</body></comment><class><name>JNIPortSmalltalkNotification</name><environment>JNIPort</environment><super>JNIPort.JNIPortAbstractSmalltalkRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JNIPortSmalltalkNotification</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class jniport.SmalltalkNotification</body></comment><class><name>StaticJavaLangThrowable</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangThrowable</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Throwable and provide access to its class-side methods.</body></comment><class><name>JavaCallbackRegistry</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jvm callbacks connected mutex notifierClass queueClass trace eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JavaCallbackRegistry</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgThe callback registry holds a mapping from 'tag' objects (which are unique Java objects used to identify each callback) to 'handlers'.It is designed to work with the Java helper classes for callbacks.  The idea is that since we can't easily handle Java callbacks *directly* (because of thread problems), we can build on the very restricted subset of real callbacks that do work, to implement a message queue holding requests and notifications.  When the Java queue notifies us that it has some content (this 0-bit notification is the only safe way to cross the boundary) we can then use the normal facilities of JNIPort to pull the messages our of the queue and service them.Handlers are objects that implement the #value:#value: message.  The first arguement is the 'originator' of the message, the second argument is the 'parameter' to the message.  The returned value *must* be a JavaObject or nil, it will be returned to Java as the result (not necessarily used) of the request.  If the handler throws an exception (Java or Smalltalk) then that will be converted to a Java exception and rethrown (if the caller is still waiting for a response) in the Java space.</body></comment><class><name>JavaLangString</name><environment>JNIPort</environment><super>JNIPort.JavaAggregate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangString</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.String.Note that not all Java Strings can be represented as Smalltalk Strings, since Java allows a slightly larger range of values from the space of Unicode characters (i.e it allows 16bit chars, rather than 8bit -- neither can handle the full range of Unicode).----Addition (Joachim Geidel):In VisualWorks, there is no restriction to 8bit Characters, i.e. all Java Strings can be represented as Smalltalk Strings. Also, it seems that starting with Java 5, Java Strings can handle the full range of Unicode characters, encoding supplementary characters by their two surrogate code points.</body></comment><class><name>JNIPortJNIInterface</name><environment>JNIPort</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorStrings </inst-vars><class-inst-vars></class-inst-vars><imports>			private JNIPort.JNIPortJNIInterfaceDictionary.*			</imports><category>JNIPort-JNI</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIPortJNIInterface</class-id><body>JNIPortJNIInterface is an external interface for the Java Native Interface (JNI) functions of the Java virtual machine. It is based on the header file jni.h from the JDK 1.5.0. Most of the JNI functions are stored in two vtable structures, JNINativeInterface_ and JNIInvokeInterface_. For details see Sun's JNI documentation.</body></comment><class><name>JNIPortJNIInterfaceForMacOSX</name><environment>JNIPort</environment><super>JNIPort.JNIPortJNIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private JNIPort.JNIPortJNIInterfaceForMacOSXDictionary.*			</imports><category>JNIPort-JNI</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libjvm.dylib</item></libraryFiles><libraryDirectories><item>/System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Libraries</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIPortJNIInterfaceForMacOSX</class-id><body>Some names of C functions in the Mac OS X version of the JVM shared library are named differently</body></comment><class><name>JavaPrimitiveIntStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveIntStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaWriteListIteratorAdaptor</name><environment>JNIPort</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaWriteListIteratorAdaptor</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgOne of thise will wrap any JavaInstance which implements the java.util.ListIterator interface.  It acts as an adaptor to allow the wrappee to look like a WriteStream.Note: this uses the wrapper-style messages, #hasNext_null, #add_Object:, and #set_Object:, to call the Java methods.</body></comment><class><name>JavaCharArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaCharArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java char arrays.Chars can be specified as Smalltalk Characters or as integers.  Char values of elements are converted to Characters if they fit in 8bits, or are returned as Integers otherwise.----Addition (Joachim Geidel):In VisualWorks, there is no restriction to 8bit Characters. Elements will always be Characters, never Integers.</body></comment><class><name>JavaArrayClassStatic</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementClassCache instanceElementWrapperCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaArrayClassStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgSpecialised class static used as a root class for all Java array classes.  Specialises the inherited behaviour a bit, but the main added value is that it knows how to act as a Smalltalk-style array factory.</body></comment><class><name>JavaSNIConstructorGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMethodGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaSNIConstructorGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaLangReflectConstructor</name><environment>JNIPort</environment><super>JNIPort.JavaLangReflectAccessibleObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterTypesCache signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangReflectConstructor</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.reflect.Constructor</body></comment><class><name>JavaPrimitiveShortStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveShortStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>StaticJNIPortSmalltalkRequestQueue</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.StaticJNIPortSmalltalkRequestQueue</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgInstances reify the Java class jniport.SmalltalkRequestQueue and provide access to its class-side methods.</body></comment><class><name>JavaUtilList</name><environment>JNIPort</environment><super>JNIPort.JavaUtilCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilList</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.List</body></comment><class><name>JavaWrapperGeneratorSettings</name><environment>JNIPort</environment><super>JNIPort.JVMSubSettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaWrapperGeneratorSettings</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgOne of these holds the options for controlling how new wrapper classes are generated.The system-wide one in the current JVM settings is used to set the used by the wrapper generation wizard.</body></comment><class><name>JavaObjectArray</name><environment>JNIPort</environment><super>JNIPort.JavaAggregate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaObjectArray</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to Java object arrays (for any subclass of java.lang.Object).</body></comment><class><name>JavaPrimitiveLongStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveLongStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>JVMSettings</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name categories </inst-vars><class-inst-vars>template predefined </class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JVMSettings</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgA JVMSettings is really just a dictionary of sub-settings keyed by a selector.  This allows us to add/remove categories of settings according to which JNIport extensions are in use.We also (the class) act as a factory for instances in the normal manner, but the new instances are created by cloning our "template" (which is an editable aspect of the class), rather than by initialising a newly created instance.Last we also contain a list of pre-defined settings, that is also an editable aspect of the class.  Default JVMs are initialised from the first on the list of predefined settings.Instances know how to persist themselves into the registry, or to re-configure themselves by reading the registry.  The class is similarly able to persist the template and predefined list.</body></comment><class><name>StaticJavaLangReflectProxy</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangReflectProxy</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.reflect.Proxy and provide access to its class-side methods.</body></comment><class><name>JavaListingMethodGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMethodGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector entries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaListingMethodGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaIoOutputStream</name><environment>JNIPort</environment><super>JNIPort.JavaWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaIoOutputStream</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.io.OutputStream</body></comment><class><name>JavaEnumerationAdaptor</name><environment>JNIPort</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaEnumerationAdaptor</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgOne of thise will wrap any JavaInstance which implements the java.util.Enumeration interface.  It acts as an adaptor to allow the wrappee to look like a ReadStream.Note: this uses the wrapper-style messages, #hasMoreElements_null and #nextElement_null, to call the Java methods.</body></comment><class><name>JavaGhostFieldSetterGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaFieldSetterGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JavaGhostFieldSetterGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JNIHelperLibrary</name><environment>JNIPort</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private JNIPort.JNIHelperLibraryDictionary.*			</imports><category>JNIPort-JNIHelper</category><attributes><includeFiles><item>DolphinJNIHelper.h</item></includeFiles><includeDirectories><item>include</item></includeDirectories><libraryFiles><item>DolphinJNIHelper.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>JNIPort-JNIHelper</package></attributes></class><comment><class-id>JNIPort.JNIHelperLibrary</class-id><body>Wrapper for the DolphinJNIHelper DLL.</body></comment><class><name>JavaMethodSignature</name><environment>JNIPort</environment><super>JNIPort.JavaSignature</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterTypes returnType methodName smalltalkSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaMethodSignature</class-id><body>A JavaMethodSignature represents the signature of a java.lang.reflect.Method.Instance Variables:	methodName	&lt;String&gt;	fully qualified name of the method	parameterTypes	&lt;(SequenceableCollection of: String)&gt;	type names of the method's parameters	returnType	&lt;String&gt;	name of the method's return type	smalltalkSelector	&lt;Symbol&gt;	cache for a Smalltalk selector derived from the signature</body></comment><class><name>JavaConstructorSignature</name><environment>JNIPort</environment><super>JNIPort.JavaMethodSignature</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaConstructorSignature</class-id><body>A JavaMethodSignature represents the signature of a java.lang.reflect.Constructor.</body></comment><class><name>SupplementaryClassloader</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name path parentName classloaderClass classloader isEnabled containingTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.SupplementaryClassloader</class-id><body>jCopyright © Chris Uppal, 2005.chris.uppal@metagnostic.orgThese are part of the framework for manipulating Java classloaders within JNIPort.  Instances are arranged into trees (as elements of SupplementaryClasspathTree).  Each instance corresponds to one, lazily created, instance of java.lang.Classsloader, and uses that to load "local" classes.  See the SupplementaryClasspathTree class comment for a more complete discussion.Note that, although we conform to &lt;javaClassFinder&gt;, we actually implement it by delegating to our actual classloader (since the logic has to live somewhere, I thought it better to add it to JavaLangClassloader where it can be used independently of this part of the framework).These should only exist as entries on a list maintained by a SupplementaryClassloaderTree, and so should not be created independently.NB: currently the entire supplementary classloader framework lacks proper mutex protection.  This needs to be addressed !</body></comment><class><name>StaticJavaLangByte</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangByte</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Byte and provide access to its class-side methods and fields.</body></comment><class><name>JavaRuntimeSettings</name><environment>JNIPort</environment><super>JNIPort.JVMSubSettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars>options </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaRuntimeSettings</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgOne of these holds settings that are passed to the JNI runtime.  The options are essentially the same as the arguments that can be passed to the "java" command (or rather, it's the other way around, since the arguments to "java" are just packaged up into runtime options for the JVM).</body></comment><class><name>JavaGhostClassGeneratorSettings</name><environment>JNIPort</environment><super>JNIPort.JavaWrapperGeneratorSettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JavaGhostClassGeneratorSettings</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgOne of these holds the options to control how ghost classes are generated.  The system-wide instance in the current JVM-settings is used for every ghost class generated.</body></comment><class><name>JNIMethodID</name><environment>JNIPort</environment><super>JNIPort.JNIPortExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIMethodID</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgEquivalent to the JNI opaque pointer type, jmethodID.</body></comment><class><name>JavaIoReader</name><environment>JNIPort</environment><super>JNIPort.JavaReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaIoReader</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.io.Reader</body></comment><class><name>JavaFieldGetterGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaFieldAccessorGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaFieldGetterGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaGhostFieldGetterGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaFieldGetterGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JavaGhostFieldGetterGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JNIValueArray</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bytes pointers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIValueArray</class-id><body>One of these acts like an UninterpretedBytes of JNIValues. It also has direct write access to the typed fields at each index.  Hence inserting values into an argument array is significantly more efficient since temporary JNIValue wrapper objects are not created on each access.</body></comment><class><name>JavaPrimitiveInstance</name><environment>JNIPort</environment><super>JNIPort.JavaInstance</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveInstance</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgThis class is never instantiated, but it makes the rest of the code more regular if we have it around.</body></comment><class><name>NoJavaSuperclassException</name><environment>JNIPort</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.NoJavaSuperclassException</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgThrown if you send #super to a JavaClassInstance that is an instance of java.lang.Object (and so has no 'super').  Also see the class comment for JavaNonvirtual.</body></comment><class><name>JavaLongArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLongArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java arrays of long.</body></comment><class><name>JNIPortSettings</name><environment>JNIPort</environment><super>JNIPort.JVMSubSettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jvmClass jniLibraryFilename watcherClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JNIPortSettings</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgOne of these holds the basic settings that configure JNIPort and the way it talks to the JNI library.</body></comment><class><name>JavaUtilIterator</name><environment>JNIPort</environment><super>JNIPort.JavaExternalIterator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilIterator</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.Iterator</body></comment><class><name>JavaUtilListIterator</name><environment>JNIPort</environment><super>JNIPort.JavaUtilIterator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilListIterator</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.ListIterator</body></comment><class><name>JNIPortJavaVMInitArgs</name><environment>JNIPort</environment><super>JNIPort.JNIPortExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>options optionPointer stringPointers ignoreUnrecognized version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIPortJavaVMInitArgs</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgWrapper for JNI's JavaVMInitArgs type.</body></comment><class><name>StaticJavaLangDouble</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.StaticJavaLangDouble</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances reify the Java class java.lang.Double and provide access to its class-side methods and fields.</body></comment><class><name>JavaFieldSignature</name><environment>JNIPort</environment><super>JNIPort.JavaSignature</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaFieldSignature</class-id><body>A JavaFieldSignature represents the signature of a java.lang.reflect.Field.Instance Variables:	name	&lt;String&gt;	name of the field	type	&lt;String&gt;	name of the field's type</body></comment><class><name>JNIClass</name><environment>JNIPort</environment><super>JNIPort.JNIObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodIDCache fieldIDCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIClass</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgEquivalent to the JNI opaque pointer type, jclass.</body></comment><class><name>JNIError</name><environment>JNIPort</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIError</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgSpecial error subclass used for errors detected in JNI.  Note, these are *not* used to wrap Java exceptions.</body></comment><class><name>JavaDoubleArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaDoubleArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java double arrays.</body></comment><class><name>JavaLangRuntime</name><environment>JNIPort</environment><super>JNIPort.JavaLangObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaLangRuntime</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.Runtime</body></comment><class><name>JavaGhostJVMMethodGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMethodGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jvm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-GhostClasses</category><attributes><package>JNIPort-Java-GhostClasses</package></attributes></class><comment><class-id>JNIPort.JavaGhostJVMMethodGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaUtilSortedMap</name><environment>JNIPort</environment><super>JNIPort.JavaUtilMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-AdditionalWrappers</category><attributes><package>JNIPort-Java-AdditionalWrappers</package></attributes></class><comment><class-id>JNIPort.JavaUtilSortedMap</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.util.SortedMap</body></comment><class><name>JavaPrimitiveBooleanStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveBooleanStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaBooleanArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaBooleanArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java boolean arrays.</body></comment><class><name>JNIPortDeadJNIEnv</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIPortDeadJNIEnv</class-id><body>Copyright © Chris Uppal, 2001-2007.chris.uppal@metagnostic.orgThese things implement the "release resource" bit of the protocol understood by JNIEnv, they can be useful for keeping shutdown/cleanup code clean, since they can avoid the necessity for a load of #isNil checks.</body></comment><class><name>JavaEventTrigger</name><environment>JNIPort</environment><super>JNIPort.JavaCallbackHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.JavaEventTrigger</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgThis class is designed to help with writing callback handlers for the case where an event is to be triggered off (the proxy for) the orgininator and  the parameter is a (Java) array of arguments to the event.</body></comment><class><name>StaticJNIPortSmalltalkNotifierThread</name><environment>JNIPort</environment><super>JNIPort.StaticJavaLangThread</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Callbacks</category><attributes><package>JNIPort-Java-Callbacks</package></attributes></class><comment><class-id>JNIPort.StaticJNIPortSmalltalkNotifierThread</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.orgInstances reify the Java class jniport.SmalltalkNotifierThread and provide access to its class-side methods.</body></comment><class><name>JNIPortSubsystem</name><environment>JNIPort</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-VW-Compatibility</category><attributes><package>JNIPort-VW-Compatibility</package></attributes></class><comment><class-id>JNIPort.JNIPortSubsystem</class-id><body>The JNIPortSubsystem is responsible for initializing the JNI Interface upon image startup, and shut down Java VMs upon image shutdown.</body></comment><class><name>JavaLangClass</name><environment>JNIPort</environment><super>JNIPort.JavaLangReflectAccessibleObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classStatic </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangClass</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgWrapper for java.lang.Class.  Intstances are *always* paired with a JavaStatic.  See the comment on that class for details.  The class static can be reached by sending #classStatic to instances.  (Don't send #static, that will return the class static for the Java class java.lang.Class, of which we are an instance, rather than the Java class we represent.)BTW. java.lang.Class isn't actually a subclass of java,lang.reflect.AccessibleObject, but it is convenient to treat it as if it were since we can then just inherit rather than duplicate the methods from that class.  In fact java.lang.Class is *supposed* to implement an interface which is shared with the other reflection objects, but -- as of J2SDK1.4 beta3 -- it doesn't.</body></comment><class><name>JNIWeakGlobalReference</name><environment>JNIPort</environment><super>JNIPort.JNIObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-JNI</category><attributes><package>JNIPort-JNI</package></attributes></class><comment><class-id>JNIPort.JNIWeakGlobalReference</class-id><body>A JNIWeakGlobalReference is the equivalent for a jweak. It represents a weak global reference to a Java object. It can only be created by calling the JNI function NewWeakGlobalRef and can be released by calling DeleteWeakGlobalRef. The Java object can be garbage collected. You can detect if it still exists by comparing it to NULL using the JNI function IsSameObject. See the JNI documentation for more detail.</body></comment><class><name>JavaPrimitiveFloatStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveFloatStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaFloatArray</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaFloatArray</class-id><body>Copyright © Chris Uppal, 2001-2006.chris.uppal@metagnostic.orgInstances wrap references to Java float arrays.</body></comment><class><name>JavaAmbiguousSelectorGenerator</name><environment>JNIPort</environment><super>JNIPort.JavaMethodGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector entries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-WrapperGeneration</category><attributes><package>JNIPort-Java-WrapperGeneration</package></attributes></class><comment><class-id>JNIPort.JavaAmbiguousSelectorGenerator</class-id><body>Copyright © Chris Uppal, 2002, 2003.chris.uppal@metagnostic.org</body></comment><class><name>JavaLangReflectField</name><environment>JNIPort</environment><super>JNIPort.JavaLangReflectAccessibleObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCache signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaLangReflectField</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.orgInstances wrap references to instances of the Java class java.lang.reflect.Field</body></comment><class><name>JavaPrimitiveByteStatic</name><environment>JNIPort</environment><super>JNIPort.JavaPrimitiveStatic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-Java-Base</category><attributes><package>JNIPort-Java-Base</package></attributes></class><comment><class-id>JNIPort.JavaPrimitiveByteStatic</class-id><body>Copyright © Chris Uppal, 2001-2003.chris.uppal@metagnostic.org</body></comment><shared-variable><name>PrototypeSources</name><environment>JNIPort.JavaGhostMethodGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>PrototypeMethods</name><environment>JNIPort.JavaGhostMethodGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>Prototypes</name><environment>JNIPort.JavaGhostMethodGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>InstancesStarted</name><environment>JNIPort.JVM</environment><private>true</private><constant>false</constant><category>accessing</category><initializer>0</initializer><attributes><package>JNIPort-Java-Base</package></attributes></shared-variable><shared-variable><name>RunningInstances</name><environment>JNIPort.JVM</environment><private>true</private><constant>false</constant><category>accessing</category><initializer>OrderedCollection new</initializer><attributes><package>JNIPort-Java-Base</package></attributes></shared-variable><shared-variable><name>Default</name><environment>JNIPort.JVM</environment><private>true</private><constant>false</constant><category>accessing</category><attributes><package>JNIPort-Java-Base</package></attributes></shared-variable><shared-variable><name>NativeTypes</name><environment>JNIPort.JavaSignature</environment><private>false</private><constant>false</constant><category>types</category><initializer></initializer><attributes><package>JNIPort-Java-Base</package></attributes></shared-variable><shared-variable><name>JNITypes</name><environment>JNIPort.JavaSignature</environment><private>false</private><constant>false</constant><category>types</category><initializer></initializer><attributes><package>JNIPort-Java-Base</package></attributes></shared-variable><shared-variable><name>Default</name><environment>JNIPort.JNIHelperLibrary</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>JNIPort-JNIHelper</package></attributes></shared-variable><shared-variable><name>RegisteredJNIHelpers</name><environment>JNIPort.JNIHelperLibrary</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>HandleRegistry new</initializer><attributes><package>JNIPort-JNIHelper</package></attributes></shared-variable><shared-variable><name>PrototypeSources</name><environment>JNIPort.JavaGhostFieldGetterGenerator</environment><private>true</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>PrototypeMethods</name><environment>JNIPort.JavaGhostFieldGetterGenerator</environment><private>true</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>Prototypes</name><environment>JNIPort.JavaGhostFieldGetterGenerator</environment><private>true</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>Current</name><environment>JNIPort.JNIPortJNIInterface</environment><private>true</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>JNIPort-JNI</package></attributes></shared-variable><shared-variable><name>JNIPortJNIInterfaceForMacOSXDictionary</name><environment>JNIPort</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>JNIPort-JNI</package></attributes></shared-variable><shared-variable><name>JNIHelperLibraryDictionary</name><environment>JNIPort</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>JNIPort-JNIHelper</package></attributes></shared-variable><shared-variable><name>JNIPortJNIInterfaceDictionary</name><environment>JNIPort</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>JNIPort-JNI</package></attributes></shared-variable><shared-variable><name>PrototypeSources</name><environment>JNIPort.JavaGhostConstructorGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>PrototypeMethods</name><environment>JNIPort.JavaGhostConstructorGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>Prototypes</name><environment>JNIPort.JavaGhostConstructorGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>PrototypeSources</name><environment>JNIPort.JavaGhostFieldSetterGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>PrototypeMethods</name><environment>JNIPort.JavaGhostFieldSetterGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><shared-variable><name>Prototypes</name><environment>JNIPort.JavaGhostFieldSetterGenerator</environment><private>false</private><constant>false</constant><category>prototypes</category><initializer>Dictionary new</initializer><attributes><package>JNIPort-Java-GhostClasses</package></attributes></shared-variable><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>procedures</category><body package="JNIPort-JNI">JNI_CreateJavaVM: pvm with: penv with: args	&lt;C: jint __stdcall  JNI_CreateJavaVM(JavaVM * * pvm, void * * penv, void * args)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_GetCreatedJavaVMs: arg1 with: arg2 with: arg3	&lt;C: jint __stdcall  JNI_GetCreatedJavaVMs(JavaVM * * , jsize, jsize * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_GetDefaultJavaVMInitArgs: args	&lt;C: jint __stdcall  JNI_GetDefaultJavaVMInitArgs(void * args)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_OnLoad: vm with: reserved	&lt;C: jint __stdcall  JNI_OnLoad(JavaVM * vm, void * reserved)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_OnUnload: vm with: reserved	&lt;C: void __stdcall  JNI_OnUnload(JavaVM * vm, void * reserved)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>JNIPort.JNIPortJNIInterfaceForMacOSX</class-id> <category>procedures</category><body package="JNIPort-JNI">JNI_CreateJavaVM: pvm with: penv with: args	&lt;C: jint __stdcall  JNI_CreateJavaVM_Impl(JavaVM * * pvm, void * * penv, void * args)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_GetCreatedJavaVMs: arg1 with: arg2 with: arg3	&lt;C: jint __stdcall  JNI_GetCreatedJavaVMs_Impl(JavaVM * * , jsize, jsize * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_GetDefaultJavaVMInitArgs: args	&lt;C: jint __stdcall  JNI_GetDefaultJavaVMInitArgs_Impl(void * args)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_OnLoad: vm with: reserved	&lt;C: jint __stdcall  JNI_OnLoad_Impl(JavaVM * vm, void * reserved)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNI">JNI_OnUnload: vm with: reserved	&lt;C: void __stdcall  JNI_OnUnload_Impl(JavaVM * vm, void * reserved)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>JNIPort.JNIHelperLibrary</class-id> <category>procedures</category><body package="JNIPort-JNIHelper">AvailableHelpers	&lt;C: unsigned int __stdcall  AvailableHelpers(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">CallbackQueueLength: arg	&lt;C: unsigned int __stdcall  CallbackQueueLength(DolphinJNIHelper * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">GetJNIHelper	&lt;C: DolphinJNIHelper *  __stdcall  GetJNIHelper(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">MaxCallbackQueueLength: arg	&lt;C: unsigned int __stdcall  MaxCallbackQueueLength(DolphinJNIHelper * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">MaxHelpers	&lt;C: unsigned int __stdcall  MaxHelpers(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">ReleaseJNIHelper: arg	&lt;C: void __stdcall  ReleaseJNIHelper(DolphinJNIHelper * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">TestJNIHelperAbort: arg	&lt;C: void __stdcall  TestJNIHelperAbort(DolphinJNIHelper * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">TestJNIHelperExit: arg	&lt;C: void __stdcall  TestJNIHelperExit(DolphinJNIHelper * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">TestJNIHelperVFPrintf: arg	&lt;C: void __stdcall  TestJNIHelperVFPrintf(DolphinJNIHelper * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="JNIPort-JNIHelper">VFDBPrintf: _arg1 with: _arg2 with: args	&lt;C: long __stdcall  VFDBPrintf(FILE * _arg1, const char * _arg2, va_list args)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Core.Integer</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	^self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	"Answer a C-String with encoding #JavaModifiedUTF8 which can be used as input for a JNI library function.	This should be		^self gcCopyToHeapEncoding: #JavaModifiedUTF8	but as on a lower level, the method String&gt;&gt;copyToHeap:encoding: uses the encoding to produce the terminating null bytes of the string:		null := (ByteString new: 1) asByteArrayEncoding: encoding.	It would insert #[192 128] instead of a null byte at the end of the string. That's probably a bug, but I don't want to override the system method here. When copyToHeap:encoding: is fixed, this method can be simplified."	| aPointer size bytes |	"Performance optimization: Use a predefined encoding stream. Creating a new one is really expensive and slows down JNI function calls with String parameters by 50% when there is a single String parameter."	bytes := JavaModifiedUTF8StreamEncoder encode: self.	size := bytes size.	aPointer := bytes baseCType referentType malloc: size + 1.	aPointer 		copyAt: 0		from: bytes		size: size		startingAt: 1.	aPointer 		copyAt: size		from: #[0]		size: 1		startingAt: 1.	aPointer beGarbageCollectable.	^aPointer</body></methods><methods><class-id>Core.Object</class-id> <category>*JNIPort-JNI</category><body package="JNIPort-JNI">mustFreeJNIParameter	^true</body></methods><methods><class-id>Core.Character class</class-id> <category>*JNIPort-JNI</category><body package="JNIPort-JNI">newFromJNIDatum: anInteger	^self value: anInteger</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	^self asInteger</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	"Copies the receiver to the heap and answers the pointer to its location. This method adds an additional null byte at the end of the copy on the heap, as the bytes may be used as the bytes of a Java string, and the String creation methods in Java have no other means of determining the end of the string than to look for a null byte, as they don't take the length of the ByteArray as an argument.This method could also be implemented as	^(self , #[0]) gcCopyToHeap"	| aPointer size |	size := self size.	aPointer := self baseCType referentType malloc: size + 1.	aPointer 		copyAt: 0		from: self		size: size		startingAt: 1.	aPointer 		copyAt: size		from: #[0]		size: 1		startingAt: 1.	aPointer beGarbageCollectable.	^aPointer</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	^self</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	^self</body></methods><methods><class-id>Core.Boolean class</class-id> <category>*JNIPort-JNI</category><body package="JNIPort-JNI">newFromJNIDatum: aBoolean 	^aBoolean</body></methods><methods><class-id>Core.Boolean</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	^self</body></methods><methods><class-id>External.CDatum</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	"answer the receiver in a form suitable for passing to an ExternalLibrary call"	^self</body></methods><methods><class-id>External.CType</class-id> <category>instance creation</category><body package="JNIPort-JNI">newFromJNIDatum: aPointer	"This is needed for compatibility with Pharo/Squeak, where pointers don't know about their type, such that a type object is needed to correctly retrieve the data referenced by the pointer."	^aPointer contents</body></methods><methods><class-id>External.CType</class-id> <category>operations</category><body package="JNIPort-JNI">newPointerTo: anObject	| bufferPointer |	self validateValue: anObject.	bufferPointer := self malloc.	bufferPointer contents: anObject.	^bufferPointer</body><body package="JNIPort-JNI">newPointerToCopyOf: aSequenceableCollection from: aStartIndex to: aStopIndex	| copyIndex copy |	aStartIndex to: aStopIndex		do: [:index | self validateValue: (aSequenceableCollection at: index)].	copy := self gcCalloc: aStopIndex - aStartIndex + 1.	copyIndex := 0.	aStartIndex to: aStopIndex		do: 			[:i |			copy at: copyIndex put: (aSequenceableCollection at: i) asJNIParameter.			copyIndex := copyIndex + 1].	^copy</body><body package="JNIPort-JNI">newPointerToCopyOf: aSequenceableCollection from: aStartIndex to: aStopIndex convertElementsWith: aBlock	| copyIndex copy |	aStartIndex to: aStopIndex		do: [:index | self validateValue: (aSequenceableCollection at: index)].	copy := self gcCalloc: aStopIndex - aStartIndex + 1.	copyIndex := 0.	aStartIndex to: aStopIndex		do: 			[:i |			copy at: copyIndex				put: (aBlock value: (aSequenceableCollection at: i)) asJNIParameter.			copyIndex := copyIndex + 1].	^copy</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	^self asString asJNIParameter</body></methods><methods><class-id>Core.String</class-id> <category>*JNIPort-Java-Base</category><body package="JNIPort-Java-Base">asJavaByteArray: aJVM	"Answer a JavaByteArray object which is owned by aJVM."	^JavaByteArray fromString: self jvm: aJVM.</body><body package="JNIPort-Java-Base">asJavaCharArray: aJVM	"Answer a JavaCharArray object which is owned by aJVM."	^JavaCharArray fromString: self jvm: aJVM.</body><body package="JNIPort-Java-Base">asJavaConstructorSignature	^JavaConstructorSignature fromString: self</body><body package="JNIPort-Java-Base">asJavaFieldSignature	^JavaFieldSignature fromString: self</body><body package="JNIPort-Java-Base">asJavaMethodSignature	^JavaMethodSignature fromString: self</body><body package="JNIPort-Java-Base">asJavaString: aJVM	"Answer a JavaLangString object which is owned by aJVM"	^JavaLangString fromString: self jvm: aJVM.</body><body package="JNIPort-Java-Base">asJNIClassName	"On the assumption that the receiver is the name of a Java class in JNI format (xxx/yyy/zzz/Class),	or Java format (xxx.yyy.zzz.Class), answer the equvalent String name in JNI format."	"try to identify cases where we're OK already quickly"	self isEmpty ifTrue: [^ self].	(self includes: $/) ifTrue: [^ self].	"check for array sufixes, [] -- arrays are given the JNI signature name (for some reason)"	(self endsWith: '[]') ifTrue: [^ self asJNISignature].	"there is nothing we can do about the names of primitives that are not in arrays, since JNI won't	let you look them up by name at all"		"note that this won't handle nested class names properly -- you have to use $ not ."	^ self copyReplacing: $. withObject: $/.</body><body package="JNIPort-Java-Base">asJNISignature	"On the assumption that the receiver is the name of a Java class in JNI format (xxx/yyy/zzz/Class),	or Java format (xxx.yyy.zzz.Class), or a JNI signature string, then answer the equvalent String in JNI	signature format."	"try to identify the cases where it's already in JNI signature format quickly"	| stem depth stream map |	self isEmpty ifTrue: [^self].	self last = $; ifTrue: [^self].	self first = $[ ifTrue: [^self].	(self size = 1 and: ['BCDFIJLSVZ' includes: self first]) ifTrue: [^self].	stream := (String new: self size + 2) writeStream.	"check for strings in JNI classname but not JNI signature format"	(self includes: $/)		ifTrue: 			[^stream				nextPut: $L;				nextPutAll: self;				nextPut: $;;				contents].	"handle as many layers of array nesting as are needed"	stem := self.	depth := self occurrencesOf: $[.	depth &gt; 0		ifTrue: 			[stream next: depth put: $[.			stem := stem copyUpTo: $[].	"check for primitive types"	map := (Dictionary new: 10)				at: 'byte' put: $B;				at: 'char' put: $C;				at: 'double' put: $D;				at: 'float' put: $F;				at: 'int' put: $I;				at: 'long' put: $J;				at: 'short' put: $S;				at: 'void' put: $V;				at: 'boolean' put: $Z;				yourself.	map at: stem		ifPresent: 			[:code |			stream nextPut: code.			^stream contents].	stream nextPut: $L.	stem		do: [:each | each = $. ifTrue: [stream nextPut: $/] ifFalse: [stream nextPut: each]].	stream nextPut: $;.	^stream contents</body></methods><methods><class-id>Core.Collection</class-id> <category>*JNIPort-Java-Base</category><body package="JNIPort-Java-Base">asJavaArrayOf: aJavaStatic	"Answer a Java array object with element type defined by aJavaStatic and holding	the elements of the receiver."	^ aJavaStatic newArrayWithAll: self.</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*JNIPort-Java-Base</category><body package="JNIPort-Java-Base">asJavaByteArray: aJVM	"Answer a JavaByteArray object which is owned by aJVM."	"nil is a valid java object corresponding to Java null, and since null is of type byte[],	it follows that nil is a valid Java byte[]"	^ self.</body><body package="JNIPort-Java-Base">asJavaCharArray: aJVM	"Answer a JavaCharArray object which is owned by aJVM."	"nil is a valid java object corresponding to Java null, and since null is of type char[],	it follows that nil is a valid Java char[]"	^ self.</body><body package="JNIPort-Java-Base">asJavaObject: aJVM	"answer a managed JavaObject which corresponds to the same underlying	object as the receiver and which is managed by aJVM"	"nil is a valid java object corresponding to Java null"	^ self.</body><body package="JNIPort-Java-Base">asJavaString: aJVM	"Answer a JavaLangString object which is owned by aJVM."	"nil is a valid java object corresponding to Java null, and since null is of type java.lang.String,	it follows that nil is a valid Java string"	^ self.</body></methods><methods><class-id>Core.ByteArray</class-id> <category>*JNIPort-Java-Base</category><body package="JNIPort-Java-Base">asJavaByteArray: aJVM	"Answer a JavaByteArray object which is owned by aJVM."	^JavaByteArray fromByteArray: self jvm: aJVM.</body><body package="JNIPort-Java-Base">asJavaCharArray: aJVM	"Answer a JavaCharArray object which is owned by aJVM."	^JavaCharArray fromByteArray: self jvm: aJVM.</body><body package="JNIPort-Java-Base">asJavaString: aJVM	"Answer a JavaLangString object which is owned by aJVM."	^JavaLangString fromByteArray: self jvm: aJVM.</body></methods><methods><class-id>JNIPort.JavaClassWrapperGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-WrapperGeneration">removeHiddenFieldsFrom: aCollectionOfFields	"private -- given the collection of JavaLangReflectField objects, answer a copy without any	that are hidden by others"	^ aCollectionOfFields reject: [:each | aCollectionOfFields anySatisfy: [:other | other ~~ each and: [other hides: each]]].</body><body package="JNIPort-Java-WrapperGeneration">resolveNameClashesBetween: aCollection	"private -- given a collection of generators that all generate the same selector, try to force them	to use longer forms to avoid ambiguity"	| names |	"first pass, make them use long typenames in the selector keywords"	aCollection do: [:each | each generateLongKeywords: true].	"second pass, make any that remain ambiguous include the type as well"	names := Bag withAll: (aCollection collect: [:each | each selector]).	(aCollection select: [:each | (names occurrencesOf: each selector) &gt; 1])		do: [:each | each includeTypeInSelector: true].	"of course, it's still not *guaranteed* that there's no ambiguity left, but that's the best we can do"</body><body package="JNIPort-Java-WrapperGeneration">resolveNameClashesIn: aCollection	"private -- attempt to ensure that aCollection contains no two generators that will produce methods with the	same name.	NB: updates the collection in place"	| map dummies |	#CUtodo.  "this should be dummy-setter-aware"	#CUtodo. "if we cannot resolve ambiguity then should not generate that wrapper at all"	map := IdentityDictionary new.	aCollection do: [:each | (map at: each selector ifAbsentPut: [OrderedCollection new]) add: each].	dummies := OrderedCollection new.	map keysAndValuesDo:		[:selector :generators |		generators size &gt; 1 ifTrue:			[self resolveNameClashesBetween: generators.			dummies add: (JavaAmbiguousSelectorGenerator						selector: selector						entries: (generators collect: [:each | each selector])						targetClass: targetClass)]].	aCollection addAll: dummies.</body><body package="JNIPort-Java-WrapperGeneration">settersFromGetters: aCollectionOfGetters	"private -- given the collection of getters, answer a Collection of JavaLangReflectField objects for	which we should generate setter wrappers"	"we want the ones that are not final, or for which the target class inherits an implementation of	the corresponding selector"	^ aCollectionOfGetters reject: [:each | each isFinal and: [(self targetInheritsSetterFor: each) not]].</body><body package="JNIPort-Java-WrapperGeneration">targetInheritsSetterFor: aJavaField	"private -- answer whether the taget class inherits an implementation of the	method that would be generated if we generated a setter for the given field"	| tmp |	#CUtodo.  "ugh!"	tmp := installer setterGeneratorFor: aJavaField.	^ targetClass superclass canUnderstand: tmp selector.</body></methods><methods><class-id>JNIPort.JavaClassWrapperGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">addListingMethodGeneratorsTo: aCollection	"private -- add listing-method generators to the given collection of member generators"	aCollection add: (JavaListingMethodGenerator				selector: #generatedConstructorSelectors				entries: ((aCollection select: [:each | each isConstructor])						collect: [:each | each selector])				targetClass: targetClass class).	aCollection add: (JavaListingMethodGenerator				selector: #generatedGetterSelectors				entries: ((aCollection select: [:each | each isGetter])						collect: [:each | each selector])				targetClass: targetClass class).	aCollection add: (JavaListingMethodGenerator				selector: #generatedSetterSelectors				entries: ((aCollection select: [:each | each isSetter])						collect: [:each | each selector])				targetClass: targetClass class).	aCollection add: (JavaListingMethodGenerator				selector: #generatedWrapperSelectors				entries: ((aCollection select: [:each | each isWrapper])						collect: [:each | each selector])				targetClass: targetClass class)</body><body package="JNIPort-Java-WrapperGeneration">addSNIConstructorGeneratorsTo: aCollection	"private -- add dummy constructors for generated constuctors that we inherit but which	our Java class does not actually define"	| inherited defined dummies |	inherited := targetClass inheritedConstructorSelectors.	defined := (aCollection select: [:each | each isConstructor])				collect: [:each | each selector].	dummies := (inherited reject: [:each | defined includes: each])				collect: [:each | JavaSNIConstructorGenerator selector: each targetClass: targetClass].	aCollection addAll: dummies</body><body package="JNIPort-Java-WrapperGeneration">addStandardMethodGeneratorsTo: aCollection	"private -- add method generators for the 'standard' method #javaClassName	and, possibly, #jvm"	aCollection add: (JavaClassNameMethodGenerator				className: classStatic name				targetClass: targetClass class).	installer addExtraMethodGeneratorsTo: aCollection.</body><body package="JNIPort-Java-WrapperGeneration">memberMethodGenerators	"private -- answer a Collection of wrapper method generators for every member that we are targetting"	| constructors wrappers getters setters |	constructors := self constructors.	wrappers := self wrappers.	getters := self getters.	"on the whole, it's better to remove fields that are hidden"	getters := self removeHiddenFieldsFrom: getters.	"NB: do this *after* filtering since otherwise we could have getter and setter referring to different fields!"	setters := self settersFromGetters: getters.	^ (OrderedCollection new)		addAll: (constructors collect: [:each | installer constructorGeneratorFor: each]);		addAll: (wrappers collect: [:each | installer methodGeneratorFor: each]);		addAll: (getters collect: [:each | installer getterGeneratorFor: each]);		addAll: (setters collect: [:each | installer setterGeneratorFor: each]);		yourself.</body><body package="JNIPort-Java-WrapperGeneration">methodGenerators	"answer a Collection of wrapper method generators for every member that we are targetting plus	the 'standard' and 'listing' methods"	| answer settings |	settings := installer settings.	"start with the real methods"	answer := self memberMethodGenerators.	"filter out the unwanted stuff"	answer := settings selectGeneratorsFrom: answer.	"avoid inheriting constructors that the target class doesn't actually have"	settings generateSNIConstructors ifTrue:		[self addSNIConstructorGeneratorsTo: answer].	"force long-form selectors where necessary to (try to) ensure we have no name clashes"	self resolveNameClashesIn: answer.	"add in the various housekeeping methods"	self addListingMethodGeneratorsTo: answer.	self addStandardMethodGeneratorsTo: answer.	^ answer.</body></methods><methods><class-id>JNIPort.JavaClassWrapperGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">classStatic: aJavaStatic	"private -- set the Java class static we will use"	classStatic := aJavaStatic.</body><body package="JNIPort-Java-WrapperGeneration">installer: aJavaClassWrapperInstaller	"private -- set the JavaClassWrapperInstaller that will drive us"	installer := aJavaClassWrapperInstaller.</body><body package="JNIPort-Java-WrapperGeneration">targetClass: aClass	"private -- set the Smalltalk class we are going to populate"	targetClass := aClass.</body></methods><methods><class-id>JNIPort.JavaClassWrapperGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">classStatic	"answer the class static we are working from"	^ classStatic.</body><body package="JNIPort-Java-WrapperGeneration">constructors	"answer a Collection of JavaLangReflectConstructor objects for which we should generate wrappers"	self subclassResponsibility.</body><body package="JNIPort-Java-WrapperGeneration">getters	"answer a Collection of JavaLangReflectField objects for which we should generate getter wrappers"	self subclassResponsibility.</body><body package="JNIPort-Java-WrapperGeneration">targetClass	"answer the Smalltalk class we are going to populate"	^ targetClass.</body><body package="JNIPort-Java-WrapperGeneration">wrappers	"answer a Collection of JavaLangReflectMethod objects for which we should generate wrappers"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaClassWrapperGenerator</class-id> <category>printing</category><body package="JNIPort-Java-WrapperGeneration">printOn: aStream	"append a developer-centric description of ourselves to aStream"	super printOn: aStream.	aStream		nextPutAll: ' for: ';		print: classStatic.</body></methods><methods><class-id>JNIPort.JavaClassWrapperGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">for: aJavaStatic target: aClass installer: aJavaClassWrapperInstaller	"answer a new instance which will generate code to wrap the Java class represented by aJavaStatic	in the Smalltalk class, aClass, and which is 'driven' by aJavaClassWrapperInstaller"	^ (self new)		classStatic: aJavaStatic;		targetClass: aClass;		installer: aJavaClassWrapperInstaller;		yourself.</body><body package="JNIPort-Java-WrapperGeneration">new	"private -- use #for:target:installer:"	^ (super new)		initialize;		yourself.</body></methods><methods><class-id>JNIPort.JavaClassWrapperInstaller</class-id> <category>helpers</category><body package="JNIPort-Java-WrapperGeneration">addExtraMethodGeneratorsTo: aCollection	"private -- invoked by the class generator as it constructs its list of method generators.	This gives us the chance to add extra methods before the class generator does name	reolution, etc.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	"nothing to do"</body><body package="JNIPort-Java-WrapperGeneration">constructorGeneratorFor: aJavaLangConstructor	"private -- answer a JavaConstructorWrapperGenerator for the given Java constructor	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaConstructorWrapperGenerator for: aJavaLangConstructor targetClass: destination.</body><body package="JNIPort-Java-WrapperGeneration">getterGeneratorFor: aJavaLangField	"private -- answer a JavaFieldGetterGenerator for the given Java method	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaFieldGetterGenerator for: aJavaLangField targetClass: destination.</body><body package="JNIPort-Java-WrapperGeneration">methodGeneratorFor: aJavaLangMethod	"private -- answer a JavaMethodWrapperGenerator for the given Java method	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaMethodWrapperGenerator for: aJavaLangMethod targetClass: destination.</body><body package="JNIPort-Java-WrapperGeneration">setterGeneratorFor: aJavaLangField	"private -- answer a JavaFieldSetterGenerator for the given Java method	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaFieldSetterGenerator for: aJavaLangField targetClass: destination.</body></methods><methods><class-id>JNIPort.JavaClassWrapperInstaller</class-id> <category>operations</category><body package="JNIPort-Java-WrapperGeneration">install	"generate wrapper methods as specified by our settings and install them in our	destination class"	self classGenerator methodGenerators do: 			[:each |			[installed add: (self installFromMethodGenerator: each)]				on: JNIPortUtility exceptionsWithoutNotifications				do: 					[:ex |					problems add: ex.					ex toTrace]]</body><body package="JNIPort-Java-WrapperGeneration">installFromMethodGenerator: aJavaMethodGenerator 	"cause aJavaMethodGenerator to install itself, answers the installed method"	^aJavaMethodGenerator generateMethod</body></methods><methods><class-id>JNIPort.JavaClassWrapperInstaller</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">classGenerator	"answer the JavaClassWrapperGenerator that will actually generate our wrappers"	^ classGeneratorClass for: source target: destination installer: self.</body><body package="JNIPort-Java-WrapperGeneration">classGeneratorClass: aClass	classGeneratorClass := aClass</body><body package="JNIPort-Java-WrapperGeneration">destination: aClass	"set the Smalltalk class to which we will add wrapper methods"	destination := aClass</body><body package="JNIPort-Java-WrapperGeneration">installed	"answer an OrderedCollection of the methods generated during installation"	^ installed.</body><body package="JNIPort-Java-WrapperGeneration">problems	"answer an OrderedCollection of the Exceptions signalled during installation"	^ problems.</body><body package="JNIPort-Java-WrapperGeneration">settings	"answer the JavaWrapperGeneratorSettings that controls what members we will generate	wrappers for"	^ settings.</body><body package="JNIPort-Java-WrapperGeneration">settings: aJavaWrapperGeneratorSettings	"set the JavaWrapperGeneratorSettings that controls what members we will generate	wrappers for"	settings := aJavaWrapperGeneratorSettings</body><body package="JNIPort-Java-WrapperGeneration">source	"answer the JavaStatic that we are generating wrapper methods for"	^ source.</body></methods><methods><class-id>JNIPort.JavaClassWrapperInstaller</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">initialize	"private -- establish a coherent initial state"	installed := OrderedCollection new.	problems := OrderedCollection new.</body><body package="JNIPort-Java-WrapperGeneration">source: aJavaStatic	"private -- set the Java class whose members we will generate and install	wrappers for"	source := aJavaStatic.</body></methods><methods><class-id>JNIPort.JavaClassWrapperInstaller class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">forClassSideOf: aJavaStatic destination: aClass settings: aJVMWrapperGeneratorSettings	"answer a new instance which will generate methods to wrap the class-side members and	constructors of the Java class represented by aJavaStatic, and install them in the given Smalltalk	class under the control of the given settings.	NB: aClass should normally be a subclass of JavaStatic"	^ (self new)		source: aJavaStatic;		destination: aClass;		settings: aJVMWrapperGeneratorSettings;		classGeneratorClass: JavaStaticWrapperGenerator;		yourself.</body><body package="JNIPort-Java-WrapperGeneration">forInstanceSideOf: aJavaStatic destination: aClass settings: aJVMWrapperGeneratorSettings	"answer a new instance which will generate methods to wrap the instance-side members	of the Java class represented by aJavaStatic, and install them in the given Smalltalk class	under the control of the given settings.	NB: aClass should normally be a subclass of JavaInstance"	^ (self new)		source: aJavaStatic;		destination: aClass;		settings: aJVMWrapperGeneratorSettings;		classGeneratorClass: JavaInstanceClassWrapperGenerator;		yourself.</body><body package="JNIPort-Java-WrapperGeneration">new	"private -- use #for:[instanceClass:][staticClass:]"	^ (super new)		initialize;		yourself.</body></methods><methods><class-id>JNIPort.JavaClassWrapperInstaller class</class-id> <category>actions</category><body package="JNIPort-Java-WrapperGeneration">installWrapperFor: javaClassName in: class forStatic: aBoolean	"Utility method for installing wrapper methods for the Java class named javaClassName in aClass. Install wrapper methods for static fields and methods if aBoolean is true, otherwise install wrappers for instance fields and methods. Use the current JVM to access the Java class. The wrapperGeneratorSettings are taken from the running JVM, too. If there is no current running JVM, this method will do nothing."		| installer jvm javaClass settings |	jvm := JVM currentIfNone: [^self].	settings := jvm settings wrapperGeneratorSettings.	javaClass := jvm findClass: javaClassName.	installer := aBoolean		ifTrue: [self forClassSideOf: javaClass destination: class settings: settings]		ifFalse: [self forInstanceSideOf: javaClass destination: class settings: settings].	installer install</body></methods><methods><class-id>JNIPort.JavaGhostClassInstaller</class-id> <category>operations</category><body package="JNIPort-Java-GhostClasses">installFromMethodGenerator: aJavaMethodGenerator 	"cause aJavaMethodGenerator to install itself, answers the installed method or	throws an Error exception if there is some problem"	| keepSource |	keepSource := self settings retainMethodSource 				and: [JNIPortUtility isRuntime not].	^aJavaMethodGenerator generateGhostMethodKeepSource: keepSource</body></methods><methods><class-id>JNIPort.JavaGhostClassInstaller</class-id> <category>helpers</category><body package="JNIPort-Java-GhostClasses">addExtraMethodGeneratorsTo: aCollection	"private -- invoked by the class generator as it constructs its list of method generators.	This gives us the chance to add extra methods before the class generator does name	reolution, etc.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	"if the target class doesn't already inherits a ghost implementation of #jvm then	add one now"	(destination superclass isGhostClass) ifFalse:		[aCollection add: (JavaGhostJVMMethodGenerator					jvm: source jvm					targetClass: destination)].</body><body package="JNIPort-Java-GhostClasses">constructorGeneratorFor: aJavaLangConstructor	"private -- answer a JavaConstructorWrapperGenerator for the given Java constructor	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaGhostConstructorGenerator for: aJavaLangConstructor targetClass: destination.</body><body package="JNIPort-Java-GhostClasses">getterGeneratorFor: aJavaLangField	"private -- answer a JavaFieldGetterGenerator for the given Java method	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaGhostFieldGetterGenerator for: aJavaLangField targetClass: destination.</body><body package="JNIPort-Java-GhostClasses">methodGeneratorFor: aJavaLangMethod	"private -- answer a JavaMethodWrapperGenerator for the given Java method	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaGhostMethodGenerator for: aJavaLangMethod targetClass: destination.</body><body package="JNIPort-Java-GhostClasses">setterGeneratorFor: aJavaLangField	"private -- answer a JavaFieldSetterGenerator for the given Java method	that will generate a method to live in our destination class.	This is factored out from JavaClassWrapperGenerator to eliminate the need	for duplicate ghost subclasses of Java{InstanceClass/Static}WrapperGenerator"	^ JavaGhostFieldSetterGenerator for: aJavaLangField targetClass: destination.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>Java field access</category><body package="JNIPort-Java-Base">findField: aStringName signature: aJNISignature	"answer the JavaFieldID corresponding to our Java object's field named aStringName,	with signature defined by aJNISignature"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getBooleanFID: aFieldID	"get the value of the field defined by aFieldID"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getBooleanField: aStringName	"answer the value of the boolean field of our Java object that is named by	aStringName"	^ self getBooleanFID: (self findField: aStringName signature: 'Z').</body><body package="JNIPort-Java-Base">getByteFID: aFieldID	"get the value of the field defined by aFieldID"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getByteField: aStringName	"answer the value of the byte field of our Java object that is named by	aStringName"	^ self getByteFID: (self findField: aStringName signature: 'B').</body><body package="JNIPort-Java-Base">getCharFID: aFieldID	"get the value of the field defined by aFieldID."	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getCharField: aStringName	"answer the value of the char field of our Java object that is named by	aStringName."	^ self getCharFID: (self findField: aStringName signature: 'C').</body><body package="JNIPort-Java-Base">getDoubleFID: aFieldID	"get the value of the field defined by aFieldID"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getDoubleField: aStringName	"answer the value of the double field of our Java object that is named by	aStringName"	^ self getDoubleFID: (self findField: aStringName signature: 'D').</body><body package="JNIPort-Java-Base">getFloatFID: aFieldID	"get the value of the field defined by aFieldID"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getFloatField: aStringName	"answer the value of the float field of our Java object that is named by	aStringName"	^ self getFloatFID: (self findField: aStringName signature: 'F').</body><body package="JNIPort-Java-Base">getIntFID: aFieldID	"get the value of the field defined by aFieldID"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getIntField: aStringName	"answer the value of the int field of our Java object that is named by	aStringName"	^ self getIntFID: (self findField: aStringName signature: 'I').</body><body package="JNIPort-Java-Base">getLongFID: aFieldID	"get the value of the field defined by aFieldID"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getLongField: aStringName	"answer the value of the long field of our Java object that is named by	aStringName"	^ self getLongFID: (self findField: aStringName signature: 'J').</body><body package="JNIPort-Java-Base">getObjectFID: aFieldID	"get the value of the field defined by aFieldID"	^ self		getObjectFID: aFieldID		wrapperFactory: self jvm.</body><body package="JNIPort-Java-Base">getObjectFID: aFieldID wrapperFactory: aJVMOrJavaStatic	"get the value of the field defined by aFieldID.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getObjectField: aStringName	"get the value of the java.lang.Object-valued field of our Java object that is named by aStringName"	^ self getObjectFID: (self findField: aStringName signature: 'Ljava/lang/Object;').</body><body package="JNIPort-Java-Base">getObjectField: aStringName signature: aJNISignature	"get the value of the field of our Java object that is named by aStringName"	^ self getObjectFID: (self findField: aStringName signature: aJNISignature).</body><body package="JNIPort-Java-Base">getShortFID: aFieldID	"get the value of the field defined by aFieldID"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">getShortField: aStringName	"answer the value of the short field of our Java object that is named by	aStringName"	^ self getShortFID: (self findField: aStringName signature: 'S').</body><body package="JNIPort-Java-Base">getStringField: aStringName	"get the value of the java.lang.String-valued field of our Java object that is named by aStringName"	^ self getObjectFID: (self findField: aStringName signature: 'Ljava/lang/String;').</body><body package="JNIPort-Java-Base">setBooleanFID: aFieldID to: aBool	"set the value of the field defined by aFieldID to aBool"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setBooleanField: aStringName to: aBool	"set the value of the boolean field of our Java object that is named by	aStringName to aBool"	^ self setBooleanFID: (self findField: aStringName signature: 'Z') to: aBool.</body><body package="JNIPort-Java-Base">setByteFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setByteField: aStringName to: anInteger	"set the value of the byte field of our Java object that is named by	aStringName to anInteger"	^ self setByteFID: (self findField: aStringName signature: 'B') to: anInteger.</body><body package="JNIPort-Java-Base">setCharFID: aFieldID to: aCharacterOrInteger	"set the value of the field defined by aFieldID to aCharacterOrInteger"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setCharField: aStringName to: aCharacterOrInteger	"set the value of the char field of our Java object that is named by	aStringName to aCharacterOrInteger"	^ self setCharFID: (self findField: aStringName signature: 'C') to: aCharacterOrInteger.</body><body package="JNIPort-Java-Base">setDoubleFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setDoubleField: aStringName to: aFloat	"set the value of the double field of our Java object that is named by	aStringName to aFloat"	^ self setDoubleFID: (self findField: aStringName signature: 'D') to: aFloat.</body><body package="JNIPort-Java-Base">setField: aStringName signature: aJNISignature to: anObject	"set the value of the field named by aStringName and the given signature to anObject"	| type fid |	fid := self findField: aStringName signature: aJNISignature.	type := aJNISignature last.	"Smalltalk has no need of a case-switch.  Yeah right..."	type = $; ifTrue: [^ self setObjectFID: fid to: anObject].	type = $I ifTrue: [^ self setIntFID: fid to: anObject].	type = $Z ifTrue: [^ self setBooleanFID: fid to: anObject].	type = $C ifTrue: [^ self setCharFID: fid to: anObject].	type = $F ifTrue: [^ self setFloatFID: fid to: anObject].	type = $J ifTrue: [^ self setLongFID: fid to: anObject].	type = $D ifTrue: [^ self setDoubleFID: fid to: anObject].	type = $B ifTrue: [^ self setByteFID: fid to: anObject].	type = $S ifTrue: [^ self setShortFID: fid to: anObject].	Error signal: 'Unrecognised JNI signature' with: aJNISignature.</body><body package="JNIPort-Java-Base">setFloatFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setFloatField: aStringName to: aFloat	"set the value of the float field of our Java object that is named by	aStringName to aFloat"	^ self setFloatFID: (self findField: aStringName signature: 'F') to: aFloat.</body><body package="JNIPort-Java-Base">setIntFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setIntField: aStringName to: anInteger	"set the value of the int field of our Java object that is named by	aStringName to anInteger"	^ self setIntFID: (self findField: aStringName signature: 'I') to: anInteger.</body><body package="JNIPort-Java-Base">setLongFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setLongField: aStringName to: anInteger	"set the value of the long field of our Java object that is named by	aStringName to anInteger"	^ self setLongFID: (self findField: aStringName signature: 'J') to: anInteger.</body><body package="JNIPort-Java-Base">setObjectFID: aFieldID to: aJavaObjectOrNil	"set the value of the field defined by aFieldID to aJavaObjectOrNil"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setObjectField: aStringName signature: aJNISignature to: aJavaObjectOrNil	"set the value of the object field of our Java object that is named by	aStringName to aJavaObjectOrNil"	^ self setObjectFID: (self findField: aStringName signature: aJNISignature) to: aJavaObjectOrNil.</body><body package="JNIPort-Java-Base">setObjectField: aStringName to: aJavaObjectOrNil	"set the value of the java.lang.Object-valued field of our Java object that is named by	aStringName to aJavaObjectOrNil"	^ self		setObjectFID: (self findField: aStringName signature: 'Ljava/lang/Object;')		to: aJavaObjectOrNil.</body><body package="JNIPort-Java-Base">setShortFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">setShortField: aStringName to: anInteger	"set the value of the short field of our Java object that is named by	aStringName to anInteger"	^ self setShortFID: (self findField: aStringName signature: 'S') to: anInteger.</body><body package="JNIPort-Java-Base">setStringField: aStringName to: aStringOrSimilar	"set the value of the java.lang.String-valued field of our Java object that is named by	aStringName to aJavaObjectOrNil.	Note that this method will accept Smalltalk as well as Java strings as the	value to be assigned"	^ self		setObjectFID: (self findField: aStringName signature: 'Ljava/lang/String;')		to: (aStringOrSimilar asJavaString: self jvm).</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>accessing</category><body package="JNIPort-Java-Base">allFields	"answer an OrderedCollection of JavaLangReflectField objects for each of our Java object's instance-side	fields, this includes fields inherited from superclasses.  Fields from superclasses appear before those	from derived classes, but are not otherwise in any special order"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">allMethods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of our Java object's instance-side	methods, this includes methods inherited from superclasses.  Methods from superclasses appear before those	from derived classes, but are not otherwise in any special order"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">allRealFields	"answer an OrderedCollection of JavaLangReflectField objects for each of our Java object's instance-side	fields, this includes fields *genuinely* inherited from superclasses.  Fields from superclasses appear before those	from derived classes, but are not otherwise in any special order"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">classIndex	"answer the JavaClassIndex wherin the receiver's class *may be* lodged"	^ self jvm classIndex.</body><body package="JNIPort-Java-Base">classRegistry	"answer the JavaClassRegistry wherin the receiver's class is lodged"	^ self jvm classRegistry.</body><body package="JNIPort-Java-Base">fields	"answer an OrderedCollection of JavaLangReflectField objects for each of our Java object's instance-side	fields, this does not includes fields inherited from superclasses.  They are in no special order"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">javaVM	"answer the receiver's JavaVM"	^ self jvm javaVM.</body><body package="JNIPort-Java-Base">jniEnv	"answer the receiver's (current) JNIEnv"	^ self jvm jniEnv.</body><body package="JNIPort-Java-Base">jniObject	"answer the JNIObject which is our real handle on the underlying Java object"	^ self managedInstance jniObject.</body><body package="JNIPort-Java-Base">jvm	"answer the receiver's owning JVM"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">jvmSettings	"answer the receiver's JVM's settings"	^ self jvm settings.</body><body package="JNIPort-Java-Base">managedInstance	"answer the managed object (a JavaClassInstance) which really owns the javaObject we wrap"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">methods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of our Java object's instance-side	methods, this does not includes methods inherited from superclasses.  They are in no special order"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">sharedMutex	"answer the JVM-wide mutex"	^ self jvm sharedMutex.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>Java method calls</category><body package="JNIPort-Java-Base">callBooleanMID: aMethodID	"invoke the zero-argument, boolean-valued, method named by aMethodID on our Java object"	^ self		callBooleanMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callBooleanMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callBooleanMethod: aStringName	"invoke the zero-argument, boolean-valued, method named by aStringName on our Java object"	^ self callBooleanMID: (self findMethod: aStringName signature: '()Z').</body><body package="JNIPort-Java-Base">callBooleanMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the boolean-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callBooleanMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callByteMID: aMethodID	"invoke the zero-argument, byte-valued, method named by aMethodID on our Java object"	^ self		callByteMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callByteMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callByteMethod: aStringName	"invoke the zero-argument, byte-valued, method named by aStringName on our Java object"	^ self callByteMID: (self findMethod: aStringName signature: '()B').</body><body package="JNIPort-Java-Base">callByteMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the byte-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callByteMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callCharMID: aMethodID	"invoke the zero-argument, char-valued, method named by aMethodID on our Java object."	^ self		callCharMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callCharMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments."	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callCharMethod: aStringName	"invoke the zero-argument, char-valued, method named by aStringName on our Java object."	^ self callCharMID: (self findMethod: aStringName signature: '()C').</body><body package="JNIPort-Java-Base">callCharMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the char-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments."	^ self		callCharMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callDoubleMID: aMethodID	"invoke the zero-argument, double-valued, method named by aMethodID on our Java object"	^ self		callDoubleMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callDoubleMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callDoubleMethod: aStringName	"invoke the zero-argument, double-valued, method named by aStringName on our Java object"	^ self callDoubleMID: (self findMethod: aStringName signature: '()D').</body><body package="JNIPort-Java-Base">callDoubleMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the double-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callDoubleMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callFloatMID: aMethodID	"invoke the zero-argument, float-valued, method named by aMethodID on our Java object"	^ self		callFloatMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callFloatMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callFloatMethod: aStringName	"invoke the zero-argument, float-valued, method named by aStringName on our Java object"	^ self callFloatMID: (self findMethod: aStringName signature: '()F').</body><body package="JNIPort-Java-Base">callFloatMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the float-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callFloatMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callIntMID: aMethodID	"invoke the zero-argument, int-valued, method named by aMethodID on our Java object"	^ self		callIntMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callIntMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callIntMethod: aStringName	"invoke the zero-argument, int-valued, method named by aStringName on our Java object"	^ self callIntMID: (self findMethod: aStringName signature: '()I').</body><body package="JNIPort-Java-Base">callIntMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the int-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callIntMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callLongMID: aMethodID	"invoke the zero-argument, long-valued, method named by aMethodID on our Java object"	^ self		callLongMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callLongMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callLongMethod: aStringName	"invoke the zero-argument, long-valued, method named by aStringName on our Java object"	^ self callLongMID: (self findMethod: aStringName signature: '()J').</body><body package="JNIPort-Java-Base">callLongMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the long-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callLongMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callMethod: aStringName signature: aJNISignature	"invoke the zero-argument method defined by aStringName and aJNISignature on our Java object,	 with the given JNIValueArray of arguments.	Note that we use the signature to induce which method to call"	| type mid |	type := aJNISignature last.	mid := self findMethod: aStringName signature: aJNISignature.	"Smalltalk has no need of a case-switch.  Yeah right..."	type = $; ifTrue: [^ self callObjectMID: mid].	type = $I ifTrue: [^ self callIntMID: mid].	type = $V ifTrue: [^ self callVoidMID: mid].	type = $Z ifTrue: [^ self callBooleanMID: mid].	type = $C ifTrue: [^ self callCharMID: mid].	type = $F ifTrue: [^ self callFloatMID: mid].	type = $J ifTrue: [^ self callLongMID: mid].	type = $D ifTrue: [^ self callDoubleMID: mid].	type = $B ifTrue: [^ self callByteMID: mid].	type = $S ifTrue: [^ self callShortMID: mid].	Error signal: 'Unrecognised JNI signature' with: aJNISignature.</body><body package="JNIPort-Java-Base">callMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the method defined by aStringName and aJNISignature on our Java object,	 with the given JNIValueArray of arguments.	Note that we use the signature to induce which method to call"	| type mid |	type := aJNISignature last.	mid := self findMethod: aStringName signature: aJNISignature.	"Smalltalk has no need of a case-switch.  Yeah right..."	type = $; ifTrue: [^ self callObjectMID: mid withArguments: aJNIValueArray].	type = $I ifTrue: [^ self callIntMID: mid withArguments: aJNIValueArray].	type = $V ifTrue: [^ self callVoidMID: mid withArguments: aJNIValueArray].	type = $Z ifTrue: [^ self callBooleanMID: mid withArguments: aJNIValueArray].	type = $C ifTrue: [^ self callCharMID: mid withArguments: aJNIValueArray].	type = $F ifTrue: [^ self callFloatMID: mid withArguments: aJNIValueArray].	type = $J ifTrue: [^ self callLongMID: mid withArguments: aJNIValueArray].	type = $D ifTrue: [^ self callDoubleMID: mid withArguments: aJNIValueArray].	type = $B ifTrue: [^ self callByteMID: mid withArguments: aJNIValueArray].	type = $S ifTrue: [^ self callShortMID: mid withArguments: aJNIValueArray].	Error signal: 'Unrecognised JNI signature' with: aJNISignature.</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID	"invoke the zero-argument, object-valued, method named by aMethodID on our Java object"	^ self		callObjectMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self		callObjectMID: aMethodID		withArguments: aJNIValueArray		wrapperFactory: self jvm.</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID withArguments: aJNIValueArray wrapperFactory: aJVMOrJavaStatic	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID wrapperFactory: aJVMOrJavaStatic	"invoke the zero-argument, object-valued, method named by aMethodID on our Java object.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	^ self		callObjectMID: aMethodID		withArguments: JNIValueArray null		wrapperFactory: aJVMOrJavaStatic.</body><body package="JNIPort-Java-Base">callObjectMethod: aStringName	"invoke the java.lang.Object-valued, zero-argument, method named by aStringName on our Java object"	^ self callObjectMID: (self findMethod: aStringName signature: '()Ljava/lang/Object;').</body><body package="JNIPort-Java-Base">callObjectMethod: aStringName signature: aJNISignature	"invoke the zero-argument, object-valued, method named by aStringName on our Java object"	^ self callObjectMID: (self findMethod: aStringName signature: aJNISignature).</body><body package="JNIPort-Java-Base">callObjectMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the object-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callObjectMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callObjectMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray wrapperFactory: aJVMOrJavaStatic	"invoke the object-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	^ self		callObjectMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray		wrapperFactory: aJVMOrJavaStatic.</body><body package="JNIPort-Java-Base">callObjectMethod: aStringName signature: aJNISignature wrapperFactory: aJVMOrJavaStatic	"invoke the zero-argument, object-valued, method named by aStringName on our Java object.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	^ self		callObjectMID: (self findMethod: aStringName signature: aJNISignature)		wrapperFactory: aJVMOrJavaStatic.</body><body package="JNIPort-Java-Base">callShortMID: aMethodID	"invoke the zero-argument, short-valued, method named by aMethodID on our Java object"	^ self		callShortMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callShortMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callShortMethod: aStringName	"invoke the zero-argument, short-valued, method named by aStringName on our Java object"	^ self callShortMID: (self findMethod: aStringName signature: '()S').</body><body package="JNIPort-Java-Base">callShortMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the short-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callShortMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">callStringMethod: aStringName	"invoke the java.lang.String-valued, zero-argument, method named by aStringName on our Java object"	^ self callObjectMID: (self findMethod: aStringName  signature: '()Ljava/lang/String;').</body><body package="JNIPort-Java-Base">callVoidMID: aMethodID	"invoke the zero-argument, void-valued, method named by aMethodID on our Java object"	^ self		callVoidMID: aMethodID		withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callVoidMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callVoidMethod: aStringName	"invoke the zero-argument, void-valued, method named by aStringName on our Java object"	^ self callVoidMID: (self findMethod: aStringName signature: '()V').</body><body package="JNIPort-Java-Base">callVoidMethod: aStringName signature: aJNISignature withArguments: aJNIValueArray	"invoke the void-valued method named by aStringName on our Java object with the given	JNIValueArray of arguments"	^ self		callVoidMID: (self findMethod: aStringName signature: aJNISignature)		withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">findMethod: aStringName signature: aJNISignature	"answer the JavaMethodID corresponding to our Java object's method named aString,	and signature defined by aJNISignature"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>testing</category><body package="JNIPort-Java-Base">isDead	"answer whether this instance no longer represents a live connection to an object in a Java Virtual Machine"	^ self jniObject isNil or: [self jvm isDead].</body><body package="JNIPort-Java-Base">isGlobalRef	"answer true if we are wrapping a JNI global ref"	^ self isLive and: [self jniObject isGlobalRef].</body><body package="JNIPort-Java-Base">isLive	"answer whether this instance still represents a live connection to a Java Virtual Machine"	^ self jniObject notNil.</body><body package="JNIPort-Java-Base">isLocalRef	"answer true if we are wrapping a JNI local ref"	^ self isLive and: [self jniObject isLocalRef].</body><body package="JNIPort-Java-Base">mustFreeJNIParameter	^false</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">isOwnedBy: aJVM	"answer whether our owning JVM is that given"	^ self jvm == aJVM.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">initialize	"Do nothing. Just a stub to prevent errors from 'super initialize' in subclasses."</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>printing</category><body package="JNIPort-Java-Base">displayString	^self printString</body><body package="JNIPort-Java-Base">printOn: aStream	"write a developer oriented representation of the receiver to aStream"	self isDead		ifTrue: 			[aStream				nextPutAll: 'a dead ';				print: self class]		ifFalse: 			[super printOn: aStream.			aStream				nextPut: $(;				print: self jniObject;				nextPut: $)]</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>comparing</category><body package="JNIPort-Java-Base">isSameAs: aJavaObjectOrJNIObject	"answer whether the receiver is = (in Java terms, i.e. this is an identity comparison) to aJavaObjectOrJNIObject"	^ self jvm is: self identicalTo: aJavaObjectOrJNIObject.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>private-events</category><body package="JNIPort-Java-Base">myEventTable	^eventHandlers</body><body package="JNIPort-Java-Base">myEventTable: anEventTable	eventHandlers := anEventTable</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>copying</category><body package="JNIPort-Java-Base">copy	"overridden since instances have no properly mutable state, hence a copy would be	pointless"	^ self.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>synchronising</category><body package="JNIPort-Java-Base">monitorEnter	"acquire on the current object.  Note it is better -- by far -- to use	the #synchronized: method, since that will look after unlocking automatically"	self jniEnv 		MonitorEnter_obj: self jniObject 		onException: [:jex | self jvm throwJavaException: jex]</body><body package="JNIPort-Java-Base">monitorExit	"remove any lock on the current object.  Note it is better -- by far -- to use	the #synchronized: method, since that will look after unlocking automatically"	self jniEnv		MonitorExit_obj: self jniObject 		onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">synchronized: a0Block	"answer the result of evaluating a0Block while holding the Java	lock on the underyling object.	NB: Caution is advised -- the thread models of Java (typically) and	Smalltalk are very different, this may give rise to unexpected consequences.	In particular, all Smalltalk code runs on the same OS thread, so	Java will not stop two Smalltalk Processes from accessing	a locked object at the same time"	self monitorEnter.	^ a0Block ensure: [self monitorExit].</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>converting</category><body package="JNIPort-Java-Base">asJNIParameter	"answer the receiver in a form suitable for passing to an ExternalLibrary call,	i.e. the ExternalAddress of our underlying Java object"	^ self jniObject asJNIParameter.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-WrapperGeneration">ambiguousJavaMethod: aSelector alternatives: aCollection	"private -- trigger an AmbiguousJavaMethodError to say that an automatically	generated method could have referred to one of several Java methods.	aCollection is an Array of Selectors of 'long form' generated methods with	the same short form as the erroneous one"	AmbiguousJavaMethodError		signal: (aSelector , ' is ambiguous')		with: aSelector -&gt; aCollection.</body></methods><methods><class-id>JNIPort.JavaObject</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">beNotAGhost	"private -- used during clean-up.  Stop being an instance of a ghost class"	self isGhost ifTrue: [self becomeA: self class ghostClassRoot].</body><body package="JNIPort-Java-GhostClasses">isGhost	"answer whether this instance is a member of a 'ghost class'"	^ self class isGhostClass.</body></methods><methods><class-id>JNIPort.JavaObject class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated (including ghost methods)	methods which wrap Java constructors..	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated (including ghost methods)	Java field getters.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedSelectors	"answer an OrderedCollection of the selectors of automatically generated (including ghost methods)	methods which wrap Java methods, constructors, and fields.	Note that this does not include inherited selectors"	^ (OrderedCollection new)		addAll: self generatedConstructorSelectors;		addAll: self generatedGetterSelectors;		addAll: self generatedSetterSelectors;		addAll: self generatedWrapperSelectors;		yourself.</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated (including ghost methods)	Java field setters.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated (including ghost methods)	methods which wrap Java methods.	Note that this does not include inherited selectors"	^ #().</body></methods><methods><class-id>JNIPort.JavaObject class</class-id> <category>testing</category><body package="JNIPort-Java-Base">isWrapperClass	"answer whether this class is intended to correspond to some particular Java class"	^ self class includesSelector: #javaClassName.</body><body package="JNIPort-Java-Base">shouldRegisterWithJVM: aJVM	"answer whether this class should be registered as a wrapper class with the given JVM"	^ self isWrapperClass and: [self supplementaryClassloaderNames isEmpty].</body><body package="JNIPort-Java-Base">shouldRegisterWithSupplementaryClassloader: aSupplementaryClassloader	"answer whether this class should be registered as a wrapper class with the given	SupplementaryClassloader.	Note, it is a logic error to answer true to both this and #shouldRegisterWithJVM: since if	the latter answers true, the receiver will be loaded by the main JVM directly rather than	via a custom classloader, and so no classloaders that are created subsequently will	ever have a chance to load (and hence control) that class"	^ self isWrapperClass and: [self supplementaryClassloaderNames includes: aSupplementaryClassloader name].</body></methods><methods><class-id>JNIPort.JavaObject class</class-id> <category>registering wrapper classes</category><body package="JNIPort-Java-Base">registerWith: aClassFinder	"this is called as JVM is initialised, or with a SupplementaryClassloader, and gives	us the chance (should we wish to accept it) to register ourself with it as a wrapper	class"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">registerWithJVM: aJVM	"this is called as JVM is initialised and gives us the chance (should we wish to accept it)	to register ourself with it as a wrapper class."	"most subclass classes don't care what sort of &lt;javaClassFinder&gt; they are registering with	so the default is to pass it on to a more generic implementation"	(self shouldRegisterWithJVM: aJVM) ifTrue: [self registerWith: aJVM]</body><body package="JNIPort-Java-Base">registerWithSupplementaryClassloader: aSupplementaryClassloader	"this is called with a SupplementaryClassloader, and gives us the chance	(should we wish to accept it) to register ourself with it as a wrapper class.	NB: this is only called if #shouldRegisterWithSupplementaryClassloader	answers true"	"most subclass classes don't care what sort of &lt;javaClassFinder&gt; they are registering with	so the default is to pass it on to a more generic implementation"	self registerWith: aSupplementaryClassloader.</body><body package="JNIPort-Java-Base">registerWrapperClassesWithJVM: aJVM	"called during JVM initialisation, gives us a chance to register our subclasses"	aJVM classRegistry suspendRegistrationNotificationsWhile:		[self allSubclassesPreOrderDo:			[:each | (each shouldRegisterWithJVM: aJVM) ifTrue:				[each registerWithJVM: aJVM]]].</body><body package="JNIPort-Java-Base">registerWrapperClassesWithSupplementaryClassloader: aSupplementaryClassloader	"called when aSupplementaryClassloader is activated, gives us a chance to register	any subclasses with it that want to be registered"	aSupplementaryClassloader jvm classRegistry suspendRegistrationNotificationsWhile:		[self allSubclassesPreOrderDo:			[:each | (each shouldRegisterWithSupplementaryClassloader: aSupplementaryClassloader)				ifTrue: [each registerWithSupplementaryClassloader: aSupplementaryClassloader]]].</body></methods><methods><class-id>JNIPort.JavaObject class</class-id> <category>constants</category><body package="JNIPort-Java-Base">supplementaryClassloaderNames	"answer the names of any 'local classpath' entry that we wish to register	with in preference to being registered globablly as the JVM starts up.	See the class comment for SupplementaryClassloaderTree for an	explanation of why we might want to do that"	"by default we do not wish to do so"	^ #().</body></methods><methods><class-id>JNIPort.JavaObject class</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">instancesOwnedBy: aJVM do: aBlock	"evaluate aBlock for all the (sub) instances that are owned by aJVM"	self allSubInstancesDo: [:each | (each isOwnedBy: aJVM) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>JNIPort.JavaObject class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-WrapperGeneration">addInheritedConstructorSelectorsTo: aCollection	self == JavaObject		ifFalse: [ 			aCollection addAll: self superclass generatedConstructorSelectors.			self superclass addInheritedConstructorSelectorsTo: aCollection ].	^aCollection</body><body package="JNIPort-Java-WrapperGeneration">inheritedConstructorSelectors	"answer an IdentitySet of the selectors of our inherited automatically generated (including ghost methods)	methods which wrap Java constructors.	Note that this does not include our own selectors"	| answer |	answer := IdentitySet new.	self addInheritedConstructorSelectorsTo: answer .	^ answer.</body></methods><methods><class-id>JNIPort.JavaObject class</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">clearGhostsOwnedBy: aJVM	"private -- make sure no ghost instances remain that are owned by aJVM"	self instancesOwnedBy: aJVM do: [ :each | each beNotAGhost ].	self allSubclassesDo: [ :subclass | JNIPortUtility removeGhostClassIfNeeded: subclass ]</body><body package="JNIPort-Java-GhostClasses">definition	"Answer a string that defines the receiver. If the receiver is a ghost class, it is not possible to compute a definition message in the same way as for a normal Smalltalk class (there will be exceptions, because the receiver is not found in it's environment). Therefore, answer the name of the receiver if it's a ghost class."	^self isGhostClass ifTrue: [self name] ifFalse: [super definition]</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>accessing</category><body package="JNIPort-Java-Base">allFields	"answer an OrderedCollection of JavaLangReflectField objects for each of our Java object's instance-side	fields, this includes fields inherited from superclasses.  Fields from superclasses appear before those	from derived classes, but are not otherwise in any special order"	^ static allInstanceFields.</body><body package="JNIPort-Java-Base">allMethods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of our Java object's instance-side	methods, this includes methods inherited from superclasses.  Methods from superclasses appear before those	from derived classes, but are not otherwise in any special order"	^ static allInstanceMethods.</body><body package="JNIPort-Java-Base">allRealFields	"answer an OrderedCollection of JavaLangReflectField objects for each of our Java object's instance-side	fields, this includes fields *genuinely* inherited from superclasses.  Fields from superclasses appear before those	from derived classes, but are not otherwise in any special order"	"instances only have 'real' fields, and all inherited fields are real, so..."	^ self allFields.</body><body package="JNIPort-Java-Base">fields	"answer an OrderedCollection of JavaLangReflectField objects for each of our Java object's instance-side	fields, this does not includes fields inherited from superclasses.  They are in no special order"	^ static instanceFields.</body><body package="JNIPort-Java-Base">getClass	"answer the JavaLangClass representing the receiver's Java class.  This is just exposing the	Java getClass() method (and note that it answers the class object, not the corresponding	class static).  For Instances of JavaClassInstance, that will be the same as #javaClassObject,	but for interface instances and non-virtuals, it will answer the real class of the underlying	Java object, not the class that the adaptor object is 'pretending' to be.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	^self callObjectMethod: 'getClass' signature: '()Ljava/lang/Class;'</body><body package="JNIPort-Java-Base">javaClassObject	"answer the JavaLangClass representing the receiver's Java class"	^ static classObject.</body><body package="JNIPort-Java-Base">jniEnv	"answer the receiver's (current) JNIEnv"	"overridden for speed"	^ static jniEnv.</body><body package="JNIPort-Java-Base">jvm	"answer the receiver's owning JVM"	^ static jvm.</body><body package="JNIPort-Java-Base">methods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of our Java object's instance-side	methods, this does not includes methods inherited from superclasses.  They are in no special order"	^ static instanceMethods.</body><body package="JNIPort-Java-Base">static	"answer the JavaStatic representing the receiver's Java class"	^ static.</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>converting</category><body package="JNIPort-Java-Base">asA: aJavaClassName	"answer a JavaInterfaceInstance wrapping the same underling object as ourselves, but with	the class given by JavaClassName..	NB: there is no check that our underlyng object actually implements the interface defined	by the Java class.  In particular, if the Java class is an interface (the normal case) then we	don't check that the object formally implements that interface.  In fact if it does not, but still	happens to define the relevant methods, then this will still work OK (i.e. we take a Smalltalk	style approach to type-checking!)"	^ self asInstanceOf: (self jvm findClass: aJavaClassName).</body><body package="JNIPort-Java-Base">asAn: aJavaClassName	"many of my friends, and even some of my *best* friends, are pedants"	^ self asA: aJavaClassName.</body><body package="JNIPort-Java-Base">asInstanceOf: aJavaStatic	"answer a JavaInterfaceInstance wrapping the same underling object as ourselves, but with	the given Java class static.  I.e. appearing to have a different Java class -- typically a Java interface	class object.	Note: this won't allow you to convert a JavaInterfaceInstance back to a JavaClassInstance	since that would evade the management machinery, use #asYourself for that"	^ aJavaStatic instanceClass		wrap: self managedInstance		asStatic: aJavaStatic.</body><body package="JNIPort-Java-Base">asYourself	"answer the real JavaObject underlying whatever view we have of it"	^ self managedInstance.</body><body package="JNIPort-Java-Base">super	"answer a non-virtual 'view' of our subject from the point-of-view of the superclass of the class	we actually belong to.	Note that you can navigate further up the hierarchy by doing:		anObject super super.	and so on.  (Or just create a JavaNonvirtual with the desired JavaStatic directly).	Throws a NoJavaSuperclassException if the receiver has no superclass"	^ JavaNonvirtual		wrap: (self managedInstance)		asStatic: (static javaSuperclassIfNone: [NoJavaSuperclassException signal: 'No superclass' with: static]).</body><body package="JNIPort-Java-Base">toString	"answer the result of invoking our Java object's toString() method"	^self callObjectMethod: 'toString' signature: '()Ljava/lang/String;'</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>comparing</category><body package="JNIPort-Java-Base">= aJavaInstance	"answer whether the receiver's underlying Java object is identical to that of aJavaInstance"	self == aJavaInstance ifTrue: [^ true].	self isDead ifTrue: [^ false].	"NB: we don't have the usual class comparsion here because the mapping from Java objects to	Smalltalk classes is not straightforward"	(aJavaInstance isKindOf: JavaInstance) ifFalse: [^ false].	self static = aJavaInstance static ifFalse: [^ false].	^ self isSameAs: aJavaInstance.</body><body package="JNIPort-Java-Base">equals: aJavaObject	"answer the result of invoking our Java object's equals() method with aJavaObject	as it's argument"	"pick up the ghost implementation if it is installed (faster)"	^ self equals_Object: aJavaObject.</body><body package="JNIPort-Java-Base">hash	"answer the underlying javaObject's identity hash"	javaIdentityHash ifNotNil: [^javaIdentityHash].	^self isDead 		ifTrue: [super hash]		ifFalse: [javaIdentityHash := self jvm identityHash: self]</body><body package="JNIPort-Java-Base">hashCode	"answer the result of calling the receiver's public native hashCode() Java method.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	^self callIntMethod: 'hashCode'</body><body package="JNIPort-Java-Base">javaIdentityHash	"Answer the cached value of the receiver's Java identityHashCode()"	^javaIdentityHash</body><body package="JNIPort-Java-Base">javaIdentityHash: anInteger	"Set the cached value of the receiver's Java identityHashCode()"	javaIdentityHash := anInteger</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">equals_Object: aJavaObject	"answer the result of calling the receiver's public equals(java.lang.Object) Java method.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aJavaObject.			self				callBooleanMethod: 'equals'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">notify	"invoke the receiver's public final native notify() Java method.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	self callVoidMethod: 'notify'.</body><body package="JNIPort-Java-Base">notifyAll	"invoke the receiver's public final native notifyAll() Java method.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	self callVoidMethod: 'notifyAll'.</body><body package="JNIPort-Java-Base">wait	"invoke the receiver's public final wait() Java method.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	self callVoidMethod: 'wait'.</body><body package="JNIPort-Java-Base">wait_long: anInteger	"invoke the receiver's public final native wait(long) Java method.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: anInteger.			self callVoidMethod: 'wait' signature: '(J)V' withArguments: args]</body><body package="JNIPort-Java-Base">wait_long: anInteger int: anotherInteger	"invoke the receiver's public final wait(long, int) Java method.	Provided here, rather than on JavaLangObject so that everything can respond to the	basic Java Object methods (as happens in Java)."	JNIValueArray new: 2		freeAfter: 			[:args |			args				longAt: 1 put: anInteger;				intAt: 2 put: anotherInteger.			self callVoidMethod: 'wait' signature: '(JI)V' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>initializing</category><body package="JNIPort-Java-Base">static: aJavaStatic	"private -- set the pointer to the JavaStatic object representing our Java class"	static := aJavaStatic.</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>modes</category><body package="JNIPort-Java-Base">beNotCanonical	"ensure that this instance is not 'canonical'"	"only JavaClassInstances can be canonical, so we can ignore this"</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>printing</category><body package="JNIPort-Java-Base">printOn: aStream	"append a user-oriented representation of our underlying Java object to aStream"	"actually, this isn't all that 'user-oriented' since Java programmers typically use toString()	more like our #printString; but that's life..."	self isDead		ifTrue: [aStream nextPutAll: '&lt;dead&gt;']		ifFalse: [aStream nextPutAll: self toString].</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>testing</category><body package="JNIPort-Java-Base">isInstanceOf: aJavaStatic	"answer whether we are an instance of any class whish is derived from the Java class or interface	represented by aJavaStatic"	^ aJavaStatic classObject isInstance: self.</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">isCanonical	"answer true iff this instance is 'canonical' -- i.e. is the sole object that will be	used to represent the underlying Java object"	"only JavaClassInstances can be canonical"	^ false.</body></methods><methods><class-id>JNIPort.JavaInstance</class-id> <category>*JNIPort-Java-AdditionalWrappers</category><body package="JNIPort-Java-AdditionalWrappers">asAList	"answer a JavaUtilSet wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.List"	^ self asA: #'java.util.List'.</body><body package="JNIPort-Java-AdditionalWrappers">asAListIterator	"answer a JavaUtilListIterator wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.ListIterator"	^ self asA: #'java.util.ListIterator'.</body><body package="JNIPort-Java-AdditionalWrappers">asAMap	"answer a JavaUtilMap wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.Map"	^ self asA: #'java.util.Map'.</body><body package="JNIPort-Java-AdditionalWrappers">asASet	"answer a JavaUtilSet wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.Set"	^ self asA: #'java.util.Set'.</body><body package="JNIPort-Java-AdditionalWrappers">asASortedMap	"answer a JavaUtilSortedMap wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.SortedMap"	^ self asA: #'java.util.SortedMap'.</body><body package="JNIPort-Java-AdditionalWrappers">asASortedSet	"answer a JavaUtilSortedSet wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.SortedSet"	^ self asA: #'java.util.SortedSet'.</body><body package="JNIPort-Java-AdditionalWrappers">asAnEnumeration	"answer a JavaUtilEnumeration wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.Enumeration"	^ self asA: #'java.util.Enumeration'.</body><body package="JNIPort-Java-AdditionalWrappers">asAnIterator	"answer a JavaUtilIterator wrapping the same underling object as ourselves.	NB: there is no check that our underlyng object formally implements java.util.Iterator"	^ self asA: #'java.util.Iterator'.</body></methods><methods><class-id>JNIPort.JavaInstance class</class-id> <category>registering wrapper classes</category><body package="JNIPort-Java-Base">registerWith: aClassFinder	"this is called as JVM is initialised, or with a SupplementaryClassloader, and gives	us the chance (should we wish to accept it) to register ourself with it as a wrapper	class"	"set the instance class associated with our Java name to this class"	[(aClassFinder findClass: self javaClassName) changeInstanceClassTo: self]		on: JavaException		do: [:ex | ex jniportNotify].</body></methods><methods><class-id>JNIPort.JavaInstance class</class-id> <category>constants</category><body package="JNIPort-Java-Base">hasCanonicalInstancesByDefault	"answer whether we should have canonical instances at startup.	Override in subclasses, to force this"	"we don't have any real instances; overriden in JavaClassInstance and below"	^ false.</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>Java field access</category><body package="JNIPort-Java-Base">findField: aStringName signature: aJNISignature 	"answer the JavaFieldID corresponding to our Java object's field named aStringName,	with signature defined by aJNISignature"	| classObject |	classObject := self javaClassObject.	^classObject 		fieldIDFor: aStringName		signature: aJNISignature		ifAbsentPut: 			[self jniEnv 				GetFieldID_class: classObject				name: aStringName				sig: aJNISignature				onException: [:ex | self jvm throwJavaException: ex]]</body><body package="JNIPort-Java-Base">getBooleanFID: aFieldID 	"get the value of the field defined by aFieldID"	^self jniEnv 		GetBooleanField_obj: jniObject		fieldID: aFieldID		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">getByteFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetByteField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getCharFID: aFieldID	"get the value of the field defined by aFieldID."	| answer |	answer := self jniEnv			GetCharField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].	^answer ifNotNil: [answer asCharacter]</body><body package="JNIPort-Java-Base">getDoubleFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetDoubleField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getFloatFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetFloatField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getIntFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetIntField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getLongFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetLongField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getObjectFID: aFieldID	"get the value of the field defined by aFieldID"	| answer |	answer := self jniEnv			GetObjectField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].	^ answer asJavaObject: self jvm.</body><body package="JNIPort-Java-Base">getObjectFID: aFieldID wrapperFactory: aJVMOrJavaStatic	"get the value of the field defined by aFieldID.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	| answer |	answer := self jniEnv			GetObjectField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].	^ aJVMOrJavaStatic wrapJNIObject: answer.</body><body package="JNIPort-Java-Base">getShortFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetShortField_obj: jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">setBooleanFID: aFieldID to: aBool	"set the value of the field defined by aFieldID to aBool"	self jniEnv			SetBooleanField_obj: jniObject			fieldID: aFieldID			val: aBool			onException: [:ex | self jvm throwJavaException: ex].	^ aBool.</body><body package="JNIPort-Java-Base">setByteFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetByteField_obj: jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setCharFID: aFieldID to: aCharacterOrInteger	"set the value of the field defined by aFieldID to aCharacterOrInteger"	self jniEnv			SetCharField_obj: jniObject			fieldID: aFieldID			val: aCharacterOrInteger asInteger			onException: [:ex | self jvm throwJavaException: ex].	^ aCharacterOrInteger.</body><body package="JNIPort-Java-Base">setDoubleFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	| double |	double := aFloat asDouble.	self jniEnv		SetDoubleField_obj: jniObject		fieldID: aFieldID		val: double		onException: [:ex | self jvm throwJavaException: ex].	^double</body><body package="JNIPort-Java-Base">setFloatFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	| float |	float := aFloat asFloat.	self jniEnv		SetFloatField_obj: jniObject		fieldID: aFieldID		val: float		onException: [:ex | self jvm throwJavaException: ex].	^float</body><body package="JNIPort-Java-Base">setIntFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetIntField_obj: jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setLongFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetLongField_obj: jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setObjectFID: aFieldID to: aJavaObjectOrNil	"set the value of the field defined by aFieldID to aJavaObjectOrNil"	self jniEnv		SetObjectField_obj: jniObject		fieldID: aFieldID		val: aJavaObjectOrNil		onException: [:ex | self jvm throwJavaException: ex].	^aJavaObjectOrNil</body><body package="JNIPort-Java-Base">setShortFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetShortField_obj: jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>testing</category><body package="JNIPort-Java-Base">isDead	"answer whether this instance no longer represents a live connection to an object in a Java Virtual Machine"	^ jniObject isNil or: [static isDead].</body><body package="JNIPort-Java-Base">isGlobalRef	"answer true if we are wrapping a JNI global ref"	^ jniObject notNil and: [jniObject isGlobalRef].</body><body package="JNIPort-Java-Base">isLive	"answer whether this instance still represents a live connection to a Java Virtual Machine"	^ jniObject notNil and: [static isDead not].</body><body package="JNIPort-Java-Base">isLocalRef	"answer true if we are wrapping a JNI local ref"	^ jniObject notNil and: [jniObject isLocalRef].</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniObject	"answer the JNIObject which is our real handle on the underlying Java object"	^ jniObject.</body><body package="JNIPort-Java-Base">key	"VisualWorks-specific: Answers a unique key suitable for registering the receiver in a HandleRegistry. We can use the numerical value of the JNIObject's externalData pointer which is our real handle on the underlying Java object."	^jniObject asJNIParameter key</body><body package="JNIPort-Java-Base">managedInstance	"answer the managed object (a JavaClassInstance) which really owns the javaObject we wrap"	"we are that object"	^ self.</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>Java method calls</category><body package="JNIPort-Java-Base">callBooleanMID: aMethodID withArguments: aJNIValueArray 	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv 		CallBooleanMethodA_obj: jniObject		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callByteMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallByteMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callCharMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments."	| answer |	answer := self jniEnv			CallCharMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].	^answer ifNotNil: [answer asCharacter]</body><body package="JNIPort-Java-Base">callDoubleMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv			CallDoubleMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callFloatMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallFloatMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callIntMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallIntMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callLongMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallLongMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID withArguments: aJNIValueArray wrapperFactory: aJVMOrJavaStatic	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM, however if you know for	sure (and *don't* get it wrong!) what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	| answer |	answer := self jniEnv			CallObjectMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].	^ aJVMOrJavaStatic wrapJNIObject: answer.</body><body package="JNIPort-Java-Base">callShortMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallShortMethodA_obj: jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callVoidMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self jniEnv		CallVoidMethodA_obj: jniObject		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">findMethod: aStringName signature: aJNISignature 	"answer the JavaMethodID corresponding to our Java object's method named aStringName,	and signature defined by aJNISignature"	| classObject |	classObject := self javaClassObject.	^classObject 		methodIDFor: aStringName		signature: aJNISignature		ifAbsentPut: 			[self jniEnv 				GetMethodID_class: classObject				name: aStringName				sig: aJNISignature				onException: [:ex | self jvm throwJavaException: ex]]</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>finalizing</category><body package="JNIPort-Java-Base">free	"if we are not already free'd then tell our manager that we are no longer wanted and	then die.	NB: there's an argument that we should remove canonicalness at this point,	however I think that would put too much load on the finaliser (remember	that nearly all JavaClassInstaces reach here via finalisation), and in the	vast bulk of cases we either won't be canonicial anyway, or will already	have been removed from the (weak) collection of canonicial instances.	Hence it is the caller's responsibility to de-canonicalise objects that are	explicitly #free-d"	self isLive 		ifTrue: 			[self jvm disown: self.			jniObject ifNotNil: 					[:it | 					[it releaseRef: self jniEnv onException: [:jex | ]] 						on: Error						do: [:ex | ]]].	self die</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>modes</category><body package="JNIPort-Java-Base">beNotCanonical	"ensure that this instance is not 'canonical'"	static makeNotCanonical: self.</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization.	Also makes sure that the jniObject's external data are not released prematurely."	jniObject ifNotNil: [jniObject beUnfinalizable].	eventHandlers := nil</body><body package="JNIPort-Java-Base">executor	"Answer an object representing the receiver's executor; used during finalization."	| executor |	executor := super executor.	executor actAsExecutor.	^executor</body><body package="JNIPort-Java-Base">finalize	"private -- called to let us clean up (if necessary) when we die"	self free.</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">beCanonical	"set that this instance is 'canonical' -- i.e. is the sole object that will be	used to represent the underlying Java object.  Turning on canonicalness	does not affect any previously existing instances that also represent the	same object.  If a previous canoncial object existed that is not this one, then	it will be replaced as the canon.	The Object registry will hold a *weak* reference to this object, so canonicalness	will vanish after the last reference to this object has gone away"	static makeCanonical: self.</body><body package="JNIPort-Java-Base">die	"called when our underlying Java object is no longer valid"	"discard the reference"	jniObject := nil.	"we no longer have any responsibility for cleaning up after ourselves"	"self beUnfinalizable."</body><body package="JNIPort-Java-Base">isCanonical	"answer true iff this instance is 'canonical' -- i.e. is the sole object that will be	used to represent the underlying Java object"	^ static isCanonical: self.</body><body package="JNIPort-Java-Base">jniObject: aJNIObject static: aJavaStatic	"private -- initialise ourselves to wrap aJNIObject and be of the given Java class"	self static: aJavaStatic.	jniObject := aJNIObject.	"self beFinalizable."	aJavaStatic jvm own: self.</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>copying</category><body package="JNIPort-Java-Base">copy	"overridden since we stand in a 1-1 relationship to our wrapped JNIObject"	^ self.</body></methods><methods><class-id>JNIPort.JavaClassInstance</class-id> <category>converting</category><body package="JNIPort-Java-Base">asYourself	"answer the real JavaObject underlying whatever view we have of it"	"we are that instance"	^ self.</body><body package="JNIPort-Java-Base">beGlobalRef	"if we are not already representing a global reference, change our underlying reference to global"	| new old |	self isLocalRef ifFalse: [^ self].	new := jniObject		getGlobalRef: self jniEnv		onException: [:jex | self jvm throwJavaException: jex].	old := jniObject.	jniObject := new.	self jvm notifyNowGlobal: self.	"note: if this throws then we've changed anyway"	old		releaseRef: self jniEnv		onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">beLocalRef	"if we are not already representing a JNI local reference, change our underlying reference to local"	| new old |	self isGlobalRef ifFalse: [^ self].	new := jniObject		getLocalRef: self jniEnv		onException: [:jex | self jvm throwJavaException: jex].	old := jniObject.	jniObject := new.	self jvm notifyNowLocal: self.	"note: if this throws then we've changed anyway"	old		releaseRef: self jniEnv		onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">toString	"answer the result of invoking our Java object's toString() method"	| answer |	answer := self jniEnv		CallObjectMethodA_obj: jniObject		methodID: (self findMethod: 'toString' signature: '()Ljava/lang/String;')		args: JNIValueArray null		onException: [ :ex | self jvm throwJavaException: ex ].	^ answer isNull		ifTrue: [nil]		ifFalse: [(self jvm findClass: #'java.lang.String') wrapJNIObject: answer]</body></methods><methods><class-id>JNIPort.JavaClassInstance class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">jniObject: aJNIObject static: aJavaStatic	"private -- instances should only be created by sending #asJavaObject: to a JNIObject, or #wrapJNIObject: to	some object capable of wrapping it.	Answer a new instance wrapping the underlying Java object pointer, aJNIObject, and of the	specified Java class, and owned by aJVM.	Note that this is the only way that managed objects get created (except for a couple during bootstrapping),	the object will use its JavaStatic to reach its owning JVM at need"	^ (self basicNew)		initialize;		jniObject: aJNIObject static: aJavaStatic;		yourself.</body><body package="JNIPort-Java-Base">new	"private -- these should only be created by a JVM or by sending #asJavaClassInstance: to	a JNIObject or by sending #as: to an existing instance"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">wrap: aJavaInstance asStatic: aJavaStatic	"private -- if this is called it is because someone has attempted to use the #as: mechanism to get a view of	aJavaInstance.  However this is illegal since JavaClassInstance is the root of the tree of managed	objects and it is Just Not On to convert non-managed objects into managed ones (e,g, the underlying	jniObject would get released more than once).	To get from an JavaInterfaceInstance or JavaNonvirtual back to the real managed object, use #asYourself,	or -- if you prefer -- #managedInstance"	self shouldNotImplement.</body></methods><methods><class-id>JNIPort.JavaClassInstance class</class-id> <category>constants</category><body package="JNIPort-Java-Base">hasCanonicalInstancesByDefault	"answer whether we should have canonical instances at startup.	(if not then it can always be turned on later).	Override in subclasses, to force this"	"default is no"	^ false.</body></methods><methods><class-id>JNIPort.JavaClassInstance class</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">freeInstancesOwnedBy: aJVM	"private -- called by aJVM as it closes down to ensure that no instances still think they are alive"	self instancesOwnedBy: aJVM do: [:each | each free].</body><body package="JNIPort-Java-Base">killInstancesOwnedBy: aJVM	"private -- called by aJVM as it closes down to ensure that no instances still think they are alive"	self instancesOwnedBy: aJVM do: [:each | each die].</body></methods><methods><class-id>JNIPort.JavaLangObject class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	"these are all, in fact, inherited from JavaInstance, but we may as well list them here"	^ #(		#equals_Object:		#getClass		#hashCode		#notify		#notifyAll		#toString		#wait_long:		#wait_long:int:		#wait	).</body></methods><methods><class-id>JNIPort.JavaLangObject class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Object'.</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest</class-id> <category>notifying</category><body package="JNIPort-Java-Callbacks">notifyAnswer: aJavaObject	"tell the request, and any waiting (Java) threads that an answer is now	available"	self		notifyCompleted_Object: aJavaObject		Throwable: nil.</body><body package="JNIPort-Java-Callbacks">notifyError: aJavaException	"tell the request, and any waiting (Java) threads that an error occured"	self		notifyCompleted_Object: nil		Throwable: aJavaException tag.</body><body package="JNIPort-Java-Callbacks">notifyIgnored: aString	"tell this request, and anywaiting (Java) threads that it has not been handled	because there is no registered handler for it's tag"	self notifyIgnored_String: aString.</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest</class-id> <category>converting</category><body package="JNIPort-Java-Callbacks">toString	"answer the result of calling the receiver's public toString() Java method"	^ self callObjectMethod: 'toString' signature: '()Ljava/lang/String;'.</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest</class-id> <category>Java-methods</category><body package="JNIPort-Java-Callbacks">enqueue	"invoke the receiver's public enqueue() Java method"	self callVoidMethod: 'enqueue'.</body><body package="JNIPort-Java-Callbacks">getOriginator	"answer the result of calling the receiver's public getOriginator() Java method"	^ self callObjectMethod: 'getOriginator' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-Callbacks">getParameter	"answer the result of calling the receiver's public getParameter() Java method"	^ self callObjectMethod: 'getParameter' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-Callbacks">getTag	"answer the result of calling the receiver's public getTag() Java method"	^ self callObjectMethod: 'getTag' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-Callbacks">isNotificationOnly	"answer the result of calling the receiver's public isNotificationOnly() Java method"	^ self callBooleanMethod: 'isNotificationOnly'.</body><body package="JNIPort-Java-Callbacks">isStarted	"answer the result of calling the receiver's public synchronized isStarted() Java method"	^ self callBooleanMethod: 'isStarted'.</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">originator	"answer the originator of this request"	^ self getOriginator.</body><body package="JNIPort-Java-Callbacks">parameter	"answer the parameter object of this request"	^ self getParameter.</body><body package="JNIPort-Java-Callbacks">requiresAcknowledgement	"answer whether this request requres an answer"	^ self isNotificationOnly not.</body><body package="JNIPort-Java-Callbacks">tag	"answer the identifying tag object of this request"	^ self getTag.</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest</class-id> <category>auto generated</category><body package="JNIPort-Java-Callbacks">notifyCompleted_Object: anObject1 Throwable: aThrowable1	"invoke the receiver's  notifyCompleted(java.lang.Object, java.lang.Throwable) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				objectAt: 2 put: aThrowable1.			self				callVoidMethod: 'notifyCompleted'				signature: '(Ljava/lang/Object;Ljava/lang/Throwable;)V'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">notifyIgnored	"Tell this request, and any waiting (Java) threads that it has not been handled	because there is no registered handler for its tag.	Invoke the receiver's  notifyIgnored() Java method"	self callVoidMethod: 'notifyIgnored'.</body><body package="JNIPort-Java-Callbacks">notifyIgnored_String: aString1	"invoke the receiver's  notifyIgnored(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'notifyIgnored'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Callbacks">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#enqueue		#getOriginator		#getParameter		#getTag		#isNotificationOnly		#isStarted		#notifyCompleted_Object:Throwable:		#notifyIgnored		#notifyIgnored_String:		#toString	).</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest class</class-id> <category>testing</category><body package="JNIPort-Java-Callbacks">shouldRegisterWithJVM: aJVM 	^aJVM supportsCallbacks and: [super shouldRegisterWithJVM: aJVM]</body></methods><methods><class-id>JNIPort.JNIPortAbstractSmalltalkRequest class</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'jniport.AbstractSmalltalkRequest'.</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkRequest</class-id> <category>Java-methods</category><body package="JNIPort-Java-Callbacks">checkForException	"answer the result of calling the receiver's public checkForException() Java method"	^ self callBooleanMethod: 'checkForException'.</body><body package="JNIPort-Java-Callbacks">getException	"answer the result of calling the receiver's public getException() Java method"	^ self callObjectMethod: 'getException' signature: '()Ljava/lang/Throwable;'.</body><body package="JNIPort-Java-Callbacks">getReturnValue	"answer the result of calling the receiver's public getReturnValue() Java method"	^ self callObjectMethod: 'getReturnValue' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-Callbacks">isComplete	"answer the result of calling the receiver's public synchronized isComplete() Java method"	^ self callBooleanMethod: 'isComplete'.</body><body package="JNIPort-Java-Callbacks">isNotificationOnly	"answer the result of calling the receiver's public isNotificationOnly() Java method"	^ self callBooleanMethod: 'isNotificationOnly'.</body><body package="JNIPort-Java-Callbacks">startEvaluation	"invoke the receiver's public startEvaluation() Java method"	self callVoidMethod: 'startEvaluation'.</body><body package="JNIPort-Java-Callbacks">value	"answer the result of calling the receiver's public value() Java method"	^ self callObjectMethod: 'value' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-Callbacks">waitForResponse	"invoke the receiver's public synchronized waitForResponse() Java method"	self callVoidMethod: 'waitForResponse'.</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkRequest</class-id> <category>converting</category><body package="JNIPort-Java-Callbacks">toString	"answer the result of calling the receiver's public toString() Java method"	^ self callObjectMethod: 'toString' signature: '()Ljava/lang/String;'.</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkRequest</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">requiresAcknowledgement	"answer whether this request requres an answer"	"overridden 'cos we already know the answer"	^ true.</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkRequest class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Callbacks">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#checkForException		#getException		#getReturnValue		#isComplete		#isNotificationOnly		#startEvaluation		#toString		#value		#waitForResponse	).</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkRequest class</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'jniport.SmalltalkRequest'.</body></methods><methods><class-id>JNIPort.JavaLangThread</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">checkAccess	"invoke the receiver's public final checkAccess() Java method"	self callVoidMethod: 'checkAccess'.</body><body package="JNIPort-Java-Base">countStackFrames	"answer the result of calling the receiver's public native countStackFrames() Java method"	^ self callIntMethod: 'countStackFrames'.</body><body package="JNIPort-Java-Base">destroy	"invoke the receiver's public destroy() Java method"	self callVoidMethod: 'destroy'.</body><body package="JNIPort-Java-Base">getContextClassLoader	"answer the result of calling the receiver's public getContextClassLoader() Java method"	^ self callObjectMethod: 'getContextClassLoader' signature: '()Ljava/lang/ClassLoader;'.</body><body package="JNIPort-Java-Base">getName	"answer the result of calling the receiver's public final getName() Java method"	^ self callObjectMethod: 'getName' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">getPriority	"answer the result of calling the receiver's public final getPriority() Java method"	^ self callIntMethod: 'getPriority'.</body><body package="JNIPort-Java-Base">getThreadGroup	"answer the result of calling the receiver's public final getThreadGroup() Java method"	^ self callObjectMethod: 'getThreadGroup' signature: '()Ljava/lang/ThreadGroup;'.</body><body package="JNIPort-Java-Base">interrupt	"invoke the receiver's public interrupt() Java method"	self callVoidMethod: 'interrupt'.</body><body package="JNIPort-Java-Base">isAlive	"answer the result of calling the receiver's public final native isAlive() Java method"	^ self callBooleanMethod: 'isAlive'.</body><body package="JNIPort-Java-Base">isDaemon	"answer the result of calling the receiver's public final isDaemon() Java method"	^ self callBooleanMethod: 'isDaemon'.</body><body package="JNIPort-Java-Base">isInterrupted	"answer the result of calling the receiver's public isInterrupted() Java method"	^ self callBooleanMethod: 'isInterrupted'.</body><body package="JNIPort-Java-Base">join	"invoke the receiver's public final join() Java method"	self callVoidMethod: 'join'.</body><body package="JNIPort-Java-Base">join_long: long1	"invoke the receiver's public final synchronized join(long) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callVoidMethod: 'join' signature: '(J)V' withArguments: args]</body><body package="JNIPort-Java-Base">join_long: long1 int: int1	"invoke the receiver's public final synchronized join(long, int) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				longAt: 1 put: long1;				intAt: 2 put: int1.			self callVoidMethod: 'join' signature: '(JI)V' withArguments: args]</body><body package="JNIPort-Java-Base">resume	"invoke the receiver's public final resume() Java method"	self callVoidMethod: 'resume'.</body><body package="JNIPort-Java-Base">run	"invoke the receiver's public run() Java method"	self callVoidMethod: 'run'.</body><body package="JNIPort-Java-Base">setContextClassLoader_ClassLoader: aClassLoader1	"invoke the receiver's public setContextClassLoader(java.lang.ClassLoader) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClassLoader1.			self				callVoidMethod: 'setContextClassLoader'				signature: '(Ljava/lang/ClassLoader;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setDaemon_boolean: boolean1	"invoke the receiver's public final setDaemon(boolean) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args booleanAt: 1 put: boolean1.			self callVoidMethod: 'setDaemon' signature: '(Z)V' withArguments: args]</body><body package="JNIPort-Java-Base">setName_String: aString1	"invoke the receiver's public final setName(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'setName'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setPriority_int: int1	"invoke the receiver's public final setPriority(int) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callVoidMethod: 'setPriority' signature: '(I)V' withArguments: args]</body><body package="JNIPort-Java-Base">start	"invoke the receiver's public synchronized native start() Java method"	self callVoidMethod: 'start'.</body><body package="JNIPort-Java-Base">stop	"invoke the receiver's public final stop() Java method"	self callVoidMethod: 'stop'.</body><body package="JNIPort-Java-Base">stop_Throwable: aThrowable1	"invoke the receiver's public final synchronized stop(java.lang.Throwable) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aThrowable1.			self				callVoidMethod: 'stop'				signature: '(Ljava/lang/Throwable;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">suspend	"invoke the receiver's public final suspend() Java method"	self callVoidMethod: 'suspend'.</body></methods><methods><class-id>JNIPort.JavaLangThread</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">getId	"answer the result of calling the receiver's public getId() Java method"	^ self callLongMethod: 'getId'.</body><body package="JNIPort-Java-Base">getStackTrace	"answer the result of calling the receiver's public getStackTrace() Java method"	^ self callObjectMethod: 'getStackTrace' signature: '()[Ljava/lang/StackTraceElement;'.</body><body package="JNIPort-Java-Base">getState	"answer the result of calling the receiver's public getState() Java method"	^ self callObjectMethod: 'getState' signature: '()Ljava/lang/Thread$State;'.</body><body package="JNIPort-Java-Base">getUncaughtExceptionHandler	"answer the result of calling the receiver's public getUncaughtExceptionHandler() Java method"	^ self callObjectMethod: 'getUncaughtExceptionHandler' signature: '()Ljava/lang/Thread$UncaughtExceptionHandler;'.</body><body package="JNIPort-Java-Base">setUncaughtExceptionHandler_Thread_UncaughtExceptionHandler: anUncaughtExceptionHandler1	"invoke the receiver's public setUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anUncaughtExceptionHandler1.			self				callVoidMethod: 'setUncaughtExceptionHandler'				signature: '(Ljava/lang/Thread$UncaughtExceptionHandler;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangThread class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#checkAccess		#countStackFrames		#destroy		#getContextClassLoader		#getId		#getName		#getPriority		#getStackTrace		#getState		#getThreadGroup		#getUncaughtExceptionHandler		#interrupt		#isAlive		#isDaemon		#isInterrupted		#join_long:		#join_long:int:		#join		#resume		#run		#setContextClassLoader_ClassLoader:		#setDaemon_boolean:		#setName_String:		#setPriority_int:		#setUncaughtExceptionHandler_Thread_UncaughtExceptionHandler:		#start		#stop		#stop_Throwable:		#suspend		#toString	).</body></methods><methods><class-id>JNIPort.JavaLangThread class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Thread'.</body></methods><methods><class-id>JNIPort.JavaInstanceClassWrapperGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">constructors	"answer a Collection of JavaLangReflectConstructor objects for which we should generate wrappers"	^ #().</body><body package="JNIPort-Java-WrapperGeneration">getters	"answer a Collection of JavaLangReflectField objects for which we should generate getter wrappers"	^ installer settings includeAllSuperclasses				ifTrue: [classStatic allInstanceFields]				ifFalse: [classStatic instanceFields].</body><body package="JNIPort-Java-WrapperGeneration">wrappers	"answer a Collection of JavaLangReflectMethod objects for which we should generate wrappers"	| settings methods abstract |	settings := installer settings.	"start with just the concrete methods"	methods := settings includeAllSuperclasses				ifTrue: [classStatic allInstanceMethods]				ifFalse: [classStatic instanceMethods].	settings includeAbstractMethods ifFalse: [^ methods].	"the rest of this method is diabolically slow, fortunately its only used for	interactive generation (not ghosts) so that doesn't really matter"	"we pick up (abstract) methods inherited from directly implemented interfaces,	even if 'includeAllSuperclasses is false"	abstract := settings includeAllSuperclasses			ifTrue: [classStatic allAbstractMethods]			ifFalse: [classStatic abstractMethodsPlusInterfaceMethods].	"only add in the ones that are not already defined concretely"	methods addAll: (abstract reject: [:each | methods anySatisfy: [:other | other overrides: each]]).	^ methods.</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id> <category>testing</category><body package="JNIPort-Java-Base">declaredIn: aJavaStatic	"answer whether we were declared in the given class static"	^ self declaredIn == aJavaStatic.</body><body package="JNIPort-Java-Base">isAbstract	"answer whether the receiver represents a abstract member"	^self modifiers allMask: self modifierAbstract</body><body package="JNIPort-Java-Base">isAnInterface	"answer whether the receiver represents an interface"	^self modifiers allMask: self modifierInterface</body><body package="JNIPort-Java-Base">isDefaultAccess	"answer whether the receiver represents a protected member"	^self modifiers anyMask: self modifierProtected | self modifierPrivate | self modifierPublic</body><body package="JNIPort-Java-Base">isFinal	"answer whether the receiver represents a final member"	^self modifiers allMask: self modifierFinal</body><body package="JNIPort-Java-Base">isNative	"answer whether the receiver represents a native method"	^self modifiers allMask: self modifierNative</body><body package="JNIPort-Java-Base">isPrivate	"answer whether the receiver represents a private member"	^self modifiers allMask: self modifierPrivate</body><body package="JNIPort-Java-Base">isProtected	"answer whether the receiver represents a protected member"	^self modifiers allMask: self modifierProtected</body><body package="JNIPort-Java-Base">isPublic	"answer whether the receiver represents a public member"	^self modifiers allMask: self modifierPublic</body><body package="JNIPort-Java-Base">isStatic	"answer whether the receiver represents a static member"	^self modifiers allMask: self modifierStatic</body><body package="JNIPort-Java-Base">isStaticOrPrivate	"answer whether the receiver represents a static or private member"	^self modifiers anyMask: self modifierStatic | self modifierPrivate</body><body package="JNIPort-Java-Base">isStrict	"answer whether the receiver represents a strict member"	^self modifiers allMask: self modifierStrict</body><body package="JNIPort-Java-Base">isSynchronized	"answer whether the receiver represents a synchronized memthod.	(NB: this concept is an error in the Java language, synchronized is properly	seen as a property of the code inside the method, not of the method itself)"	^self modifiers allMask: self modifierSynchronized</body><body package="JNIPort-Java-Base">isSynthetic	"answer whether we are deemed to be 'synthetic'	Note that this method is essentially useless because the Java compiler	is lax (to say the least) about setting the appropriate flag"	"the method doesn't exist pre-Java 5"	^ self jvm hasJava5Extensions and: [self callBooleanMethod: 'isSynthetic'].</body><body package="JNIPort-Java-Base">isTransient	"answer whether the receiver represents a transient member"	^self modifiers allMask: self modifierTransient</body><body package="JNIPort-Java-Base">isVolatile	"answer whether the receiver represents a volatile member"	^self modifiers allMask: self modifierVolatile</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id> <category>constants</category><body package="JNIPort-Java-Base">modifierAbstract	^1024</body><body package="JNIPort-Java-Base">modifierFinal	^16</body><body package="JNIPort-Java-Base">modifierInterface	^512</body><body package="JNIPort-Java-Base">modifierNative	^256</body><body package="JNIPort-Java-Base">modifierPrivate	^2</body><body package="JNIPort-Java-Base">modifierProtected	^4</body><body package="JNIPort-Java-Base">modifierPublic	^1</body><body package="JNIPort-Java-Base">modifierStatic	^8</body><body package="JNIPort-Java-Base">modifierStrict	^2048</body><body package="JNIPort-Java-Base">modifierSynchronized	^32</body><body package="JNIPort-Java-Base">modifierTransient	^128</body><body package="JNIPort-Java-Base">modifierVolatile	^64</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id> <category>accessing</category><body package="JNIPort-Java-Base">declaredIn	"answer the class static corresponding to our the Java getDeclaringClass() method"	declaredInCache isNil ifTrue:		[declaredInCacheIsValid = true ifFalse:			[declaredInCache := self getDeclaringClass ifNotNil: [:it | it classStatic].			declaredInCacheIsValid := true.	"since declaredIn may be nil, even after being computed"]].	^ declaredInCache.</body><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this member"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">modifiers	"answer the result of calling the Java method getModifiers)"	modifiersCache isNil ifTrue: [modifiersCache := self getModifiers].	^ modifiersCache.</body><body package="JNIPort-Java-Base">modifiersString	"answer a String describing our modifier flags"	^ ((self jvm findClass: #'java.lang.reflect.Modifier') toString_int: self getModifiers) asString.</body><body package="JNIPort-Java-Base">name	"answer the name of the member as a String"	nameCache isNil ifTrue: [nameCache := self getName asString].	^ nameCache.</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization."	super actAsExecutor.	nameCache := declaredInCache := declaredInCacheIsValid := modifiersCache := nil</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id> <category>displaying</category><body package="JNIPort-Java-Base">description	"answer a short textual description of this object, suitable for use as, say, an info tip"	^ self isDead		ifTrue: ['']		ifFalse: [self toString asString].</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id> <category>Java-public</category><body package="JNIPort-Java-Base">getDeclaringClass	"answer the result of calling the receiver's public getDeclaringClass() Java method"	| answer |	answer := self jniEnv		CallObjectMethodA_obj: jniObject		methodID: (self findMethod: 'getDeclaringClass' signature: '()Ljava/lang/Class;')		args: JNIValueArray null		onException: [ :ex | self jvm throwJavaException: ex ].	^ answer isNull		ifTrue: [nil]		ifFalse: [(self jvm findClass: #'java.lang.Class') wrapJNIObject: answer]</body><body package="JNIPort-Java-Base">getModifiers	"answer the result of calling the receiver's public getModifiers() Java method"	^ self callIntMethod: 'getModifiers'.</body><body package="JNIPort-Java-Base">getName	"answer the result of calling the receiver's public getName() Java method"	| answer |	answer := self jniEnv		CallObjectMethodA_obj: jniObject		methodID: (self findMethod: 'getName' signature: '()Ljava/lang/String;')		args: JNIValueArray null		onException: [ :ex | self jvm throwJavaException: ex ].	^ answer isNull		ifTrue: [nil]		ifFalse: [(self jvm findClass: #'java.lang.String') wrapJNIObject: answer]</body><body package="JNIPort-Java-Base">isAccessible	"answer the result of calling the receiver's public isAccessible() Java method"	^ self callBooleanMethod: 'isAccessible'.</body><body package="JNIPort-Java-Base">setAccessible_boolean: boolean1	"invoke the receiver's public setAccessible(boolean) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args booleanAt: 1 put: boolean1.			self callVoidMethod: 'setAccessible' signature: '(Z)V' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">getAnnotation_Class: aClass1	"answer the result of calling the receiver's public getAnnotation(java.lang.Class) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClass1.			self				callObjectMethod: 'getAnnotation'				signature: '(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;'				withArguments: args]</body><body package="JNIPort-Java-Base">getAnnotations	"answer the result of calling the receiver's public getAnnotations() Java method"	^ self callObjectMethod: 'getAnnotations' signature: '()[Ljava/lang/annotation/Annotation;'.</body><body package="JNIPort-Java-Base">getDeclaredAnnotations	"answer the result of calling the receiver's public getDeclaredAnnotations() Java method"	^ self callObjectMethod: 'getDeclaredAnnotations' signature: '()[Ljava/lang/annotation/Annotation;'.</body><body package="JNIPort-Java-Base">isAnnotationPresent_Class: aClass1	"answer the result of calling the receiver's public isAnnotationPresent(java.lang.Class) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClass1.			self				callBooleanMethod: 'isAnnotationPresent'				signature: '(Ljava/lang/Class;)Z'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#getAnnotations		#getAnnotation_Class:		#getDeclaredAnnotations		#getDeclaringClass		#getModifiers		#getName		#isAccessible		#isAnnotationPresent_Class:		#isSynthetic		#setAccessible_boolean:	).</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.reflect.AccessibleObject'.</body></methods><methods><class-id>JNIPort.JavaLangReflectAccessibleObject class</class-id> <category>constants</category><body package="JNIPort-Java-Base">hasCanonicalInstancesByDefault	"answer whether we should have canonical instances at startup.	Overriden to force this for all reflections"	"this is true for all subclasses, but nor for ourself (we don't need	canonical instances 'cos we don't never have any)"	^ self ~~ JavaLangReflectAccessibleObject.</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod</class-id> <category>Java-public</category><body package="JNIPort-Java-Base">getExceptionTypes	"answer the result of calling the receiver's public getExceptionTypes() Java method"	^ self callObjectMethod: 'getExceptionTypes' signature: '()[Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getParameterTypes	"answer the result of calling the receiver's public getParameterTypes() Java method"	^ self callObjectMethod: 'getParameterTypes' signature: '()[Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getReturnType	"answer the result of calling the receiver's public getReturnType() Java method"	^ self callObjectMethod: 'getReturnType' signature: '()Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">invoke_Object: anObject1 ObjectArray: anObjects1	"answer the result of calling the receiver's public invoke(java.lang.Object, java.lang.Object[]) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				objectAt: 2 put: anObjects1.			self				callObjectMethod: 'invoke'				signature: '(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod</class-id> <category>testing</category><body package="JNIPort-Java-Base">hasSameSignatureAs: aMethod	"answer whether the method we stand takes the same list of parameters, and return	the same value, as aMethod"	^self signature isSameAs: aMethod signature</body><body package="JNIPort-Java-Base">isBridge	"answer whether we are one of the new Java5 'bridge' methods"	"the method doesn't exist pre-Java 5"	^self jvm hasJava5Extensions and: [self callBooleanMethod: 'isBridge']</body><body package="JNIPort-Java-Base">isStaticOrAbstract	"answer whether the receiver represents a static or abstract member"	^self signature isStaticOrAbstract</body><body package="JNIPort-Java-Base">isStaticOrPrivate	"answer whether the receiver represents a static or abstract member"	^self signature isStaticOrPrivate</body><body package="JNIPort-Java-Base">isVarArgs	"answer whether we are one of the Java5 'varargs' methods.	(which /actually/ just take an array as their last parameter).	The method doesn't exist pre-Java 5"	^self jvm hasJava5Extensions and: [self callBooleanMethod: 'isVarArgs']</body><body package="JNIPort-Java-Base">isVoidReturn	"answer whether the method we stand for returns void"	^ self type isVoid.</body><body package="JNIPort-Java-Base">overrides: aMethod	"answer whether the method we stand for overrides aMethod"	self isStaticOrPrivate ifTrue: [^ false].	aMethod isStaticOrPrivate ifTrue: [^ false].	(self declaredIn isDerivedFrom: aMethod declaredIn) ifFalse: [^ false].	(self name = aMethod name) ifFalse: [^ false].	(self hasSameSignatureAs: aMethod) ifFalse: [^ false].	^ true.</body><body package="JNIPort-Java-Base">overridesOrDuplicates: aMethod	"answer whether the method we stand for overrides aMethod.  This is different from	#overrides: in that two identical methods defined in unrelated interfaces are considered	to duplicate each other"	| ourClass theirClass |	self isStaticOrPrivate ifTrue: [^ false].	aMethod isStaticOrPrivate ifTrue: [^ false].	ourClass := self declaredIn.	theirClass := aMethod declaredIn.	((ourClass isAnInterface and: [theirClass isAnInterface]) or: [ourClass isDerivedFrom: theirClass]) ifFalse: [^ false].	(self name = aMethod name) ifFalse: [^ false].	(self hasSameSignatureAs: aMethod) ifFalse: [^ false].	^ true.</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod</class-id> <category>reflection</category><body package="JNIPort-Java-Base">exceptionTypes	"answer an Array of class statics corresponding to the resut of the getParameterTypes() Java method"	"this is not often called so we don't cache the result"	^ self getExceptionTypes collect: [:each | each classStatic].</body><body package="JNIPort-Java-Base">parameterTypes	"answer an Array of class statics corresponding to the resut of the getParameterTypes() Java method"	parameterTypesCache isNil ifTrue:		[parameterTypesCache := self getParameterTypes collect: [:each | each classStatic]].	^ parameterTypesCache.</body><body package="JNIPort-Java-Base">signature	"answer whether the method we generate a wrapper for returns void"	signature isNil ifTrue: [signature := self toString asJavaMethodSignature].	^signature</body><body package="JNIPort-Java-Base">type	"answer the class static corresponding to our getReturnType() Java method"	typeCache isNil ifTrue: [typeCache := self getReturnType classStatic].	^ typeCache.</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod</class-id> <category>accessing</category><body package="JNIPort-Java-Base">argumentCount	"answer how many arguments this method takes"	^self signature parameterCount</body><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this member"	^self signature jniSignatureString</body><body package="JNIPort-Java-Base">methodID	"answer a JNIMethodID for this field"	^self jniEnv		FromReflectedMethod_method: jniObject		onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">modifiersString	"answer a String describing our modifier flags"	^self signature modifiersString</body><body package="JNIPort-Java-Base">name	"answer the name of the member as a String"	nameCache isNil 		ifTrue: [nameCache := self signature unqualifiedJavaMethodName].	^nameCache</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">getDefaultValue	"answer the result of calling the receiver's public getDefaultValue() Java method"	^ self callObjectMethod: 'getDefaultValue' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-Base">getGenericExceptionTypes	"answer the result of calling the receiver's public getGenericExceptionTypes() Java method"	^ self callObjectMethod: 'getGenericExceptionTypes' signature: '()[Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">getGenericParameterTypes	"answer the result of calling the receiver's public getGenericParameterTypes() Java method"	^ self callObjectMethod: 'getGenericParameterTypes' signature: '()[Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">getGenericReturnType	"answer the result of calling the receiver's public getGenericReturnType() Java method"	^ self callObjectMethod: 'getGenericReturnType' signature: '()Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">getParameterAnnotations	"answer the result of calling the receiver's public getParameterAnnotations() Java method"	^ self callObjectMethod: 'getParameterAnnotations' signature: '()[[Ljava/lang/annotation/Annotation;'.</body><body package="JNIPort-Java-Base">getTypeParameters	"answer the result of calling the receiver's public getTypeParameters() Java method"	^ self callObjectMethod: 'getTypeParameters' signature: '()[Ljava/lang/reflect/TypeVariable;'.</body><body package="JNIPort-Java-Base">toGenericString	"answer the result of calling the receiver's public toGenericString() Java method"	^ self callObjectMethod: 'toGenericString' signature: '()Ljava/lang/String;'.</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization."	super actAsExecutor.	typeCache := parameterTypesCache := signature := nil</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod</class-id> <category>*JNIPort-Java-Callbacks</category><body package="JNIPort-Java-Callbacks">asynchronousEventForwarder: aSymbol	"answer an instance of a temporary Java class that will implement this	method, assumed to be a notification event, by triggering aSymbol off	the  (Smalltalk proxy for the)source of the event. Tthe handler will be	asynchronous, i.e. there is no guarantee that the notification will have	been handled in Smalltalk before the event method return in Java.	Note that the source of the event had better have been made canonical	or else the event will be triggered off an ephemeral JavaInstance, and you	won't be able to listen for it.	Note also that you can't have more than one asynchronousEventForwarder	or eventForwarder active for the same Java method at the same time"	| proxy |	"we can only use java.lang.reflect.proxy on interface classes"	self jniAssert: [self declaredIn isAnInterface].	"we require that the method takes 1 argument, and that that is a subtype of	java.util.EventObject"	self jniAssert: [self parameterTypes size = 1].	self jniAssert: 			[self parameterTypes first				isDerivedFrom: (self jvm findClass: #'java.util.EventObject')].	"we requre that the event's return type is void"	self jniAssert: [self type isVoid].	"create the proxy"	proxy := JNIValueArray new: 2				freeAfter: 					[:args |					args						objectAt: 1 put: self;						booleanAt: 2 put: true.					(self jvm findClass: #'jniport.EventForwarder')						callObjectMethod: 'forwarderFor'						signature: '(Ljava/lang/reflect/Method;Z)Ljava/lang/Object;'						withArguments: args].	"ensure that the callback is registered"	self jvm callbackRegistry setCallback: self triggerWithOneArgument: aSymbol.	^proxy</body><body package="JNIPort-Java-Callbacks">eventForwarder: aSymbol	"answer an instance of a temporary Java class that will implement this	method, assumed to be a notification event, by triggering aSymbol off	the (Smalltalk proxy for the) source of the event.	Note that the source of the event had better have been made canonical	or else the event will be triggered off an ephemeral JavaInstance, and you	won't be able to listen for it.	Note also that you can't have more than one asynchronousEventForwarder	or eventForwarder active for the same Java method at the same time"	| proxy |	"we can only use java.lang.reflect.proxy on interface classes"	self jniAssert: [self declaredIn isAnInterface].	"we require that the method takes 1 argument, and that that is a subtype of	java.util.EventObject"	self jniAssert: [self parameterTypes size = 1].	self jniAssert: 			[self parameterTypes first				isDerivedFrom: (self jvm findClass: #'java.util.EventObject')].	"create the proxy"	proxy := JNIValueArray new: 2				freeAfter: 					[:args |					args						objectAt: 1 put: self;						booleanAt: 2 put: false.					(self jvm findClass: #'jniport.EventForwarder')						callObjectMethod: 'forwarderFor'						signature: '(Ljava/lang/reflect/Method;Z)Ljava/lang/Object;'						withArguments: args].	"ensure that the callback is registered"	self jvm callbackRegistry setCallback: self triggerWithOneArgument: aSymbol.	^proxy</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#equals_Object:		#getAnnotation_Class:		#getDeclaredAnnotations		#getDeclaringClass		#getDefaultValue		#getExceptionTypes		#getGenericExceptionTypes		#getGenericParameterTypes		#getGenericReturnType		#getModifiers		#getName		#getParameterAnnotations		#getParameterTypes		#getReturnType		#getTypeParameters		#hashCode		#invoke_Object:ObjectArray:		#isBridge		#isSynthetic		#isVarArgs		#toGenericString		#toString	).</body></methods><methods><class-id>JNIPort.JavaLangReflectMethod class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.reflect.Method'.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state"	super initialize.	instanceClass := self defaultInstanceClass.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>Java class hierarchy</category><body package="JNIPort-Java-Base">allJavaSuperclasses	"answer an OrderedCollection of this class's Java super classes in order"	| classes |	classes := OrderedCollection new.	self allJavaSuperclassesDo: [:c | classes addLast: c].	^ classes.</body><body package="JNIPort-Java-Base">allJavaSuperclassesDo: a1Block	"evaluate a1Block for each of this class's Java superclasses in order"	^ self javaSuperclassDo: [:it | it withAllJavaSuperclassesDo: a1Block].</body><body package="JNIPort-Java-Base">interfaces	"answer an OrderedCollection of JavaInterfaceStatic objects for each interface this Java	class directly declares itself to implement, in the order in which the were declared.	(Java interfaces actually use the keyword 'extends' rather than 'implements', but it comes	to the same thing)"	^ (classObject declaredInterfaces collect: [:each | each classStatic]) asOrderedCollection.</body><body package="JNIPort-Java-Base">isDerivedFrom: aJavaStatic	"answer whether this class or interface is derived from (is a subclass of, or implements	the interface defined by) aJavaStatic"	^ classObject isDerivedFrom: aJavaStatic classObject.</body><body package="JNIPort-Java-Base">javaSuperclassDo: a1Block	"if we have a Java superclass then answer the result of evaluating a1Block with it	as the parameter"	^ javaSuperclass isNil ifTrue: [nil] ifFalse: [a1Block value: javaSuperclass].</body><body package="JNIPort-Java-Base">javaSuperclassIfNone: a0Block	"answer the JavaStatic corresponding to our Java superclass, or the result of evaluating	the &lt;niladicValuable&gt;, a0Block, if there isn't one"	^ javaSuperclass ifNil: [a0Block value].</body><body package="JNIPort-Java-Base">knownDirectJavaSubclasses	"answer an OrderedCollection of all the *known* direct subclasses of this class"	^ self classRegistry knownDirectSubclassesOf: self.</body><body package="JNIPort-Java-Base">knownJavaSubclasses	"answer an OrderedCollection of all the *known* subclasses of this class"	^ self classRegistry knownSubclassesOf: self.</body><body package="JNIPort-Java-Base">withAllJavaSuperclasses	"answer an OrderedCollection of this class followed by any Java super classes in order"	| classes |	classes := OrderedCollection new.	self withAllJavaSuperclassesDo: [:c | classes addLast: c].	^ classes.</body><body package="JNIPort-Java-Base">withAllJavaSuperclassesDo: a1Block	"evaluate a1Block for this class followed by each Java superclass in order"	a1Block value: self.	^ self allJavaSuperclassesDo: a1Block.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultInstanceClass	"answer the Smalltalk class to use by default for objects representing instances of our Java class"	^ self class defaultInstanceClass.</body><body package="JNIPort-Java-Base">hasCanonicalInstancesByDefault	"answer whether we should have canonical instances at startup.	(if not then it can always be turned on later)"	"we never have instances; overriden in subclasses that do"	^ false.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>accessing</category><body package="JNIPort-Java-Base">allFields	"answer an OrderedCollection of JavaLangReflectField objects for each of this Java class's class-side fields,	this includes fields 'inherited' (technically, just 'in scope') from superclasses and interfaces.	The order is undefined for fields within an class or interface, but otherwise follows the order:		fields inherited from interfaces of our root class		fields inherited from our root class		...		fields inherited from interfaces of our superclass		fields inherited from our superclass		fields inherited from our interfaces (including their super-interfaces)		our own declared fields	Fields that are inherited several times (from an interface being included more than	once) are included in the *last* relevant position"	| fields |	fields := javaSuperclass isNil			ifTrue: [OrderedCollection new]			ifFalse: [javaSuperclass allFields].	self fieldsPlusInterfaceFields do:		[:field | fields				remove: field ifAbsent: [];				addLast: field].	^ fields.</body><body package="JNIPort-Java-Base">allMethods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of this Java class's class-side	methods, this includes methods 'inherited' (technically, just 'in scope') from superclasses.	The order is undefined for methods within a class, but otherwise is ordered with methods from superclasses	before those from derived classes"	| methods |	methods := javaSuperclass isNil			ifTrue: [OrderedCollection new]			ifFalse: [javaSuperclass allMethods].	methods addAll: self methods.	^ methods.</body><body package="JNIPort-Java-Base">allRealFields	"answer an OrderedCollection of JavaLangReflectField objects for each of this Java class's class-side fields,	plus those *genuinely* inherited from superclasses (i.e. none)."	^ self fields.</body><body package="JNIPort-Java-Base">classObject	"answer the JavaLangClass instance corresponding to this Java class"	^ classObject.</body><body package="JNIPort-Java-Base">classRegistry	"answer the JavaClassRegistry wherin the receiver is lodged"	^ jvm classRegistry.</body><body package="JNIPort-Java-Base">classloader	"answer the classloader that loaded our class"	^ classObject classloader.</body><body package="JNIPort-Java-Base">fields	"answer an OrderedCollection of JavaLangReflectField objects for each of this Java class's class-side fields"	^ (classObject declaredFields select: [:each | each isStatic]) asOrderedCollection.</body><body package="JNIPort-Java-Base">instanceClass	"answer the Smalltalk class to use for objects representing instances	of our Java class"	^ instanceClass.</body><body package="JNIPort-Java-Base">javaSuperclass	"answer the JavaStatic corresponding to our Java superclass or nil	if we don't have one"	^ javaSuperclass.</body><body package="JNIPort-Java-Base">jniEnv	"answer the receiver's (current) JNIEnv"	"overridden for speed"	^ jvm jniEnv.</body><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class.	(note that this is a fairly expensive operation)"	^ self name asJNISignature.</body><body package="JNIPort-Java-Base">jvm	"answer the receiver's owning JVM"	^ jvm.</body><body package="JNIPort-Java-Base">managedInstance	"answer the managed object (a JavaClassInstance) which really owns the javaObject we wrap"	^ classObject.</body><body package="JNIPort-Java-Base">methods	"answer a OrderedCollection of JavaLangReflectMethod objects for each of this Java class's class-side	methods"	^ (classObject declaredMethods select: [:each | each isStatic]) asOrderedCollection.</body><body package="JNIPort-Java-Base">name	"answer the name of this class (Note that names are not necessarily	unique, even within one JVM)"	^ classObject name.</body><body package="JNIPort-Java-Base">static	"this is provided to allow class statics to look as much as possible like ordinary objects.	It always answers the JavaStatic corresponding to java.lang.Class"	^ classObject static.</body><body package="JNIPort-Java-Base">super	"this is provided to allow class statics to look as much as possible like ordinary objects.	See JavaInstance&gt;&gt;super.	Throws a NoJavaSuperclassException if the receiver has no superclass"	^ self javaSuperclassIfNone: [NoJavaSuperclassException signal: 'No superclass' with: self].</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>copying</category><body package="JNIPort-Java-Base">copy	"overridden since we stand in a 1-1 relationship to our wrapped JavaLangClass"	^ self.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>arrays</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ self class arrayClass.</body><body package="JNIPort-Java-Base">newArray: size	"answer a new array of instances of this Java class with all elements set to the default value	(i.e. some flavour of zero or null)"	^ self arrayClass new: size elementClass: self.</body><body package="JNIPort-Java-Base">newArrayWith: anObject	"answer a new array of instances of this Java class with 1 element which is anObject"	^ self arrayClass newWith: anObject elementClass: self.</body><body package="JNIPort-Java-Base">newArrayWith: anObject1 with: anObject2	"answer a new array of instances of this Java class with the given elements"	^ self arrayClass newWith: anObject1 with: anObject2 elementClass: self.</body><body package="JNIPort-Java-Base">newArrayWith: anObject1 with: anObject2 with: anObject3	"answer a new array of instances of this Java class with the given elements"	^ self arrayClass newWith: anObject1 with: anObject2  with: anObject3 elementClass: self.</body><body package="JNIPort-Java-Base">newArrayWithAll: aList	"answer a new array of instances of this Java class with the given elements"	^ self arrayClass newWithAll: aList elementClass: self.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>Java field access</category><body package="JNIPort-Java-Base">findField: aStringName signature: aJNISignature 	"answer the JavaFieldID corresponding to our Java object's field named aStringName,	with signature defined by aJNISignature"	^self jniObject 		fieldIDFor: aStringName		signature: aJNISignature		ifAbsentPut: 			[self jniEnv 				GetStaticFieldID_class: self jniObject				name: aStringName				sig: aJNISignature				onException: [:ex | jvm throwJavaException: ex]]</body><body package="JNIPort-Java-Base">getBooleanFID: aFieldID 	"get the value of the field defined by aFieldID"	^self jniEnv 		GetStaticBooleanField_class: self jniObject		fieldID: aFieldID		onException: [:ex | jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">getByteFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetStaticByteField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getCharFID: aFieldID	"get the value of the field defined by aFieldID"	| answer |	answer := self jniEnv			GetStaticCharField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].	^answer asCharacter</body><body package="JNIPort-Java-Base">getDoubleFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetStaticDoubleField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getFloatFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetStaticFloatField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getIntFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetStaticIntField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getLongFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetStaticLongField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getObjectFID: aFieldID wrapperFactory: aJavaStatic	"get the value of the field defined by aFieldID.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	| answer |	answer := self jniEnv			GetStaticObjectField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].	^ aJavaStatic wrapJNIObject: answer.</body><body package="JNIPort-Java-Base">getShortFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetStaticShortField_class: self jniObject			fieldID: aFieldID			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">setBooleanFID: aFieldID to: aBool	"set the value of the field defined by aFieldID to aBoolean"	self jniEnv			SetStaticBooleanField_class: self jniObject			fieldID: aFieldID			val: aBool			onException: [:ex | jvm throwJavaException: ex].	^ aBool.</body><body package="JNIPort-Java-Base">setByteFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetStaticByteField_class: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setCharFID: aFieldID to: aCharacterOrInteger	"set the value of the field defined by aFieldID to aCharOrInteger"	self jniEnv			SetStaticCharField_class: self jniObject			fieldID: aFieldID			val: aCharacterOrInteger asInteger			onException: [:ex | jvm throwJavaException: ex].	^ aCharacterOrInteger.</body><body package="JNIPort-Java-Base">setDoubleFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	| double |	double := aFloat asDouble.	self jniEnv		SetStaticDoubleField_class: self jniObject		fieldID: aFieldID		val: double		onException: [:ex | jvm throwJavaException: ex].	^double</body><body package="JNIPort-Java-Base">setFloatFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	| float |	float := aFloat asFloat.	self jniEnv		SetStaticFloatField_class: self jniObject		fieldID: aFieldID		val: float		onException: [:ex | jvm throwJavaException: ex].	^float</body><body package="JNIPort-Java-Base">setIntFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetStaticIntField_class: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setLongFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetStaticLongField_class: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setObjectFID: aFieldID to: aJavaObjectOrNil	"set the value of the field defined by aFieldID to aJavaObjectOrNil"	self jniEnv		SetStaticObjectField_class: self jniObject		fieldID: aFieldID		val: aJavaObjectOrNil		onException: [:ex | jvm throwJavaException: ex].	^aJavaObjectOrNil</body><body package="JNIPort-Java-Base">setShortFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetStaticShortField_class: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | jvm throwJavaException: ex].	^ anInteger.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>testing</category><body package="JNIPort-Java-Base">couldBeSubstituted	"answer false if we represent a class for which the JVM rules do not allow any other	to be substituted at runtime (e.g. final classes)"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">isAPrimitive	"answer whether we stand for an Java primitive class (int, float, etc)"	"overridden in JavaPrimitiveStatic"	^ false.</body><body package="JNIPort-Java-Base">isAbstract	"answer whether we stand for an abstract class"	^ classObject isAbstract.</body><body package="JNIPort-Java-Base">isAnInterface	"answer whether we stand for an Java interface 'class'"	"overridden in JavaInterfaceStatic"	^ false.</body><body package="JNIPort-Java-Base">isArrayClass	"answer whether we stand for an array class"	"overridden in JavaArrayClassStatic"	^ false.</body><body package="JNIPort-Java-Base">isFinal	"answer whether we stand for an final class"	^ classObject isFinal.</body><body package="JNIPort-Java-Base">isStrict	"answer whether we stand for an strict FP class"	^ classObject isStrict.</body><body package="JNIPort-Java-Base">isSubclassOf: aJavaStatic	"answer whether this Java class includes the Java class defined by aJavaStatic in	its inheritance chain.	Note: this does *not* include interfaces"	"default implementation, overridden for real classes"	^ false.</body><body package="JNIPort-Java-Base">isUnresolved	"answer whether we are an unresolved proxy for a class static"	^ false.</body><body package="JNIPort-Java-Base">isVoid	"answer whether we stand for the Java primitive type void"	"overridden in JavaPrimitiveVoidStatic"	^ false.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>displaying</category><body package="JNIPort-Java-Base">description	"answer a short textual description of this class, suitable for use as, say, an info tip"	| stream |	classObject isDead ifTrue: [^ ''].	stream := String new writeStream.	self writeDescriptionOn: stream.	^ stream contents.</body><body package="JNIPort-Java-Base">inheritanceString	"answer a short textual description of this classes inheritance"	| stream |	classObject isDead ifTrue: [^ ''].	stream := String new writeStream.	self writeInheritanceOn: stream.	^ stream contents.</body><body package="JNIPort-Java-Base">inheritanceStringWithStatus	"answer a short textual description of this classes inheritance and current status"	| stream |	classObject isDead ifTrue: [^ ''].	stream := String new writeStream.	self writeStatusOn: stream.	self writeInheritanceOn: stream.	^ stream contents.</body><body package="JNIPort-Java-Base">nameAndModifiers	"answer a String consisting of the name and modifiers of our Java class"	| mods |	mods := classObject modifiersString.	^ mods isEmpty		ifTrue: [self name]		ifFalse: [mods , ' ' , self name].</body><body package="JNIPort-Java-Base">writeDescriptionOn: aStream	"write a short description of our methods on aStream"	aStream nextPutAll: self nameAndModifiers.	aStream cr.	aStream nextPutAll: 'Instance class:'; space; print: instanceClass.	instanceClass isGhostClass ifTrue:		[aStream nextPutAll: ' (ghost, '; print: instanceClass methodDictionary size; nextPutAll: ' methods)'].	aStream cr.	aStream nextPutAll: 'Static class:'; space; print: self class.	self class isGhostClass ifTrue:		[aStream nextPutAll: ' (ghost, '; print: self class methodDictionary size; nextPutAll: ' methods)'].</body><body package="JNIPort-Java-Base">writeInheritanceOn: aStream	"write a formatted description of our inheritance on aStream"	aStream nextPutAll: 'Java class:'; cr.	self withAllJavaSuperclassesDo:		[:each |		aStream tab; nextPutAll: each nameAndModifiers.		aStream cr].	aStream cr.	aStream nextPutAll: 'Smalltalk instance class:'; cr.	self instanceClass withAllSuperclassesDo:		[:each |		aStream tab; nextPutAll: each name.		each isGhostClass ifTrue:			[aStream nextPutAll: ' (ghost class, '; print: each methodDictionary size; nextPutAll: ' methods)'].		aStream cr].	aStream cr.	aStream nextPutAll: 'Smalltalk class static class:'; cr.	self class withAllSuperclassesDo:		[:each |		aStream tab; nextPutAll: each name.		each isGhostClass ifTrue:			[aStream nextPutAll: ' (ghost class, '; print: each methodDictionary size; nextPutAll: ' methods)'].		aStream cr].</body><body package="JNIPort-Java-Base">writeStatusOn: aStream	"write a formatted description of our status on aStream"	"currently, only instantialble classes have any status"</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>mutating</category><body package="JNIPort-Java-Base">changeInstanceClassTo: aClass	"private -- change to using the given class as our instance class.	This is called during bootstrapping (as classes register themselves)	and as ghost classes are created"	self sharedMutex critical: [self unsafeChangeInstanceClassTo: aClass].</body><body package="JNIPort-Java-Base">changeStaticClassTo: aClass	"private -- change to using the given class as our static class.	This is called during bootstrapping (as classes register themselves)	and as ghost classes are created.	NB: since we are an instance of the class that's being changed, this will	change our class"	self sharedMutex critical: [self unsafeChangeStaticClassTo: aClass].</body><body package="JNIPort-Java-Base">replaceInstanceClass: anOldClass by: aNewClass	"private -- if we are using anOld class as our instance class, then change to use aNewClass"	"remember our new instance class"	instanceClass == anOldClass ifTrue:		[instanceClass := aNewClass].	"NB: it is arguable that we should send becomeA: to all our known instances at this point; however	the only class with instances that mutates in this way is java.lang.Class (and only during bootstrapping	at that) so that case is handled separately, see the override in StaticJavaLangClass)""	(anOldClass allInstances		select: [:each | each javaClass == self])			do: [:each | each becomeA: aNewClass].		"</body><body package="JNIPort-Java-Base">replaceStaticClass: anOldClass by: aNewClass	"private -- if we are using anOld class as our class static class (i.e. if we	are an instance of it), then change be an instance of aNewClass instead"	self class == anOldClass ifTrue:		[self swappingBecome: (aNewClass newAsCopyOf: self)].</body><body package="JNIPort-Java-Base">resolve	"if we are some sort of lazy stub (such as are used in lazy ghost classes) then	resolve and replace ourself with the real thing.	Answer the resolved reciever (which may not be the original reciever!)"	"we are the real thing, so ignore it..."</body><body package="JNIPort-Java-Base">unsafeChangeInstanceClassTo: aClass	"private -- change to using the given class as our instance class.	This is called during bootstrapping (as classes register themselves)	and as ghost classes are created"	| oldClass |	instanceClass == aClass ifTrue: [^ self].	oldClass := instanceClass.	"remember our new instance class; we also have to update any other class statics	which copied their instance class from this class"	self replaceInstanceClass: oldClass by: aClass.	self knownJavaSubclasses do: [:each | each replaceInstanceClass: oldClass by: aClass].</body><body package="JNIPort-Java-Base">unsafeChangeStaticClassTo: aClass	"private -- change to using the given class as our static class.	This is called during bootstrapping (as classes register themselves)	and as ghost classes are created.	NB: since we are an instance of the class that's being changed, this will	change our class"	| oldClass |	self class == aClass ifTrue: [^ self].	oldClass := self class.	"change our class to the new one, but we also have to change any other	class statics which copied their class from us"	self replaceStaticClass: oldClass by: aClass.	self knownJavaSubclasses do: [:each | each replaceStaticClass: oldClass by: aClass].</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>Java method calls</category><body package="JNIPort-Java-Base">callBooleanMID: aMethodID withArguments: aJNIValueArray 	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv 		CallStaticBooleanMethodA_class: self jniObject		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callByteMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallStaticByteMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callCharMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	| answer |	answer := self jniEnv			CallStaticCharMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].	^answer asCharacter</body><body package="JNIPort-Java-Base">callDoubleMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallStaticDoubleMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callFloatMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallStaticFloatMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callIntMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallStaticIntMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callLongMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallStaticLongMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID withArguments: aJNIValueArray wrapperFactory: aJVMOrJavaStatic	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	| answer |	answer := self jniEnv			CallStaticObjectMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].	^ aJVMOrJavaStatic wrapJNIObject: answer.</body><body package="JNIPort-Java-Base">callShortMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv			CallStaticShortMethodA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callVoidMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self jniEnv		CallStaticVoidMethodA_class: self jniObject		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">findInstanceMethod: aStringName signature: aJNISignature	"answer the JavaMethodID corresponding to our Java class object's instance method	named aStringName, and signature defined by aJNISignature"	^ self jniEnv		GetMethodID_class: self jniObject		name: aStringName		sig: aJNISignature		onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">findMethod: aStringName signature: aJNISignature 	"answer the JavaMethodID corresponding to our Java class object's static method	named aStringName, and signature defined by aJNISignature"	^self jniObject 		methodIDFor: aStringName		signature: aJNISignature		ifAbsentPut: 			[self jniEnv 				GetStaticMethodID_class: self jniObject				name: aStringName				sig: aJNISignature				onException: [:ex | jvm throwJavaException: ex]]</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">abstractMethods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of this Java class's	abstract methods"	^ (classObject declaredMethods select: [:each | each isAbstract]) asOrderedCollection.</body><body package="JNIPort-Java-Base">abstractMethodsPlusInterfaceMethods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of this Java class's abstract methods,	this includes (abstract) methods inherited from our declared interfaces (and their superinterfaces).	It does not includes methods inherited from our superclass.	The answer is in no particular order.	P.S: Sorry about the method name !"	| methods |	methods := self abstractMethods.	"want to be carefull to avoid duplicates"	self interfaces do:		[:interface | interface abstractMethodsPlusInterfaceMethods do:			[:method | (methods anySatisfy: [:each | each overridesOrDuplicates: method])					ifFalse: [methods add: method]]].	^ methods.</body><body package="JNIPort-Java-Base">allAbstractMethods	"answer an OrderedCollection of JavaLangReflectMethd objects for each of this Java class's abstract methods,	including those inherited from our superclasses, and interfaces.	Note that this does NOT exclude abstract methods that have been implemented in some sub-(or super)-class.	The result is in no special order"	| methods |	methods := self abstractMethodsPlusInterfaceMethods.	javaSuperclass isNil ifTrue: [^ methods].	"want to be carefull to avoid duplicates"	javaSuperclass allAbstractMethods do:		[:method | (methods anySatisfy: [:each | each overridesOrDuplicates: method])				ifFalse: [methods add: method]].	^ methods.</body><body package="JNIPort-Java-Base">allInstanceFields	"answer an OrderedCollection of JavaLangReflectField objects for each of this Java class's instance-side fields,	this includes fields 'inherited' from superclasses.  Note that we include private fields, even though these are, technically,	not inherited.	The order is undefined for fields within a class, but otherwise is ordered with fields from superclasses	before those from derived classes"	| fields |	fields := javaSuperclass isNil			ifTrue: [OrderedCollection new]			ifFalse: [javaSuperclass allInstanceFields].	fields addAll: self instanceFields.	^ fields.</body><body package="JNIPort-Java-Base">allInstanceMethods	"answer an OrderedCollection of JavaLangReflectMethod objects for each of this Java class's concrete instance-side	methods, this includes methods inherited from superclasses.  Note that we include private methods, even though	these are, technically, not inherited.	Methods from superclasses that are overriden in subclasses are NOT included.	Please note: this does *not* include abstract methods.	The order is undefined for methods within a class, but otherwise is ordered with methods from superclasses	before those from derived classes"	| methods |	methods := self instanceMethods.	javaSuperclass isNil ifTrue: [^ methods].	methods addAll: (javaSuperclass allInstanceMethods reject: [:each | methods anySatisfy: [:other | other overrides: each]]).	^ methods reverse.</body><body package="JNIPort-Java-Base">allInterfaces	"answer an OrderedCollection of JavaLangClass objects for each interface this Java class implements	including those inherited from superclasses.  They are in no special order"	| interfaces |	interfaces := Set new.	self withAllJavaSuperclassesDo: [:each | interfaces addAll: each interfacesWithAllSuperinterfaces].	^ interfaces asOrderedCollection.</body><body package="JNIPort-Java-Base">allUndefinedMethods	"answer an OrderedCollection of JavaLangReflectMethd objects for each of this Java class's abstract methods,	including those inherited from our superclasses and interfaces, that have not been given a concrete implementation	in this class or one of our supers.	The result is in no special order"	| abstract concrete |	abstract := self allAbstractMethods.	abstract isEmpty ifTrue: [^ abstract].	concrete := self allInstanceMethods.	^ abstract reject: [:each | concrete anySatisfy: [:other | other overrides: each]].</body><body package="JNIPort-Java-Base">constructors	"answer a OrderedCollection of JavaLangReflectConstructor objects for each of the Java class's constructors.	NB: since constructors are not inherited, there is no #allConstructors method"	^ OrderedCollection withAll: classObject declaredConstructors.</body><body package="JNIPort-Java-Base">fieldsPlusInterfaceFields	"answer an OrderedCollection of JavaLangReflectField objects for each of this Java class's class-side fields,	this includes fields 'inherited' (technically, just 'in scope') from our declared interfaces (and their superinterfaces).	It does not includes fields inherited from our superclass.	Fields inherited from our interfaces appear before our own fields, but the order is otherwise undefined.	P.S: Sorry about the method name !"	| fields |	fields := OrderedCollection new.	self interfaces do:		[:interface | interface allFields do:			[:field | fields					remove: field ifAbsent: [];					addLast: field]].	fields addAll: self fields.	^ fields.</body><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the field of this type defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field.  We are overriden in	the primitive classes)"	^ aJavaObject getObjectFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">instanceFields	"answer a Collection of JavaLangReflectField objects for each of this Java class's instance-side fields"	^ (classObject declaredFields select: [:each | each isStatic not]) asOrderedCollection.</body><body package="JNIPort-Java-Base">instanceMethods	"answer a Collection of JavaLangReflectMethod objects for each of this Java class's concrete	instance-side methods.	Please note: this does *not* include abstract methods"	^ (classObject declaredMethods select: [:each | each isStaticOrAbstract not]) asOrderedCollection.</body><body package="JNIPort-Java-Base">interfacesWithAllSuperinterfaces	"answer an OrderedCollection of JavaLangClass objects for each interface this Java class implements	directly or inherits via one of those interfaces.  They are in no special order"	| interfaces |	interfaces := Set new.	self interfaces do: [:each | interfaces					add: each;					addAll: each interfacesWithAllSuperinterfaces].	^ interfaces asOrderedCollection.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: anObject	"private -- set the field of this type defined by JNIFieldID it aJavaObject to anObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field.  We are overriden in	the primitive classes)"	aJavaObject setObjectFID: aJNIFieldID to: anObject.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">hasAnyCanonicalInstances	"answer whether any instances are currently canonical.	(Also see #hasCanonicalInstances)"	"we don't have instances!"	^ false.</body><body package="JNIPort-Java-Base">hasCanonicalInstances	"answer whether *all* instances are automatically made canonical.	(Also see #hasAnyCanonicalInstances)"	"we don't have instances!"	^ false.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>initializing</category><body package="JNIPort-Java-Base">classObject: aJavaLangClass	"private -- set the JavaLangClass that defines the Java class we stand for"	classObject := aJavaLangClass.</body><body package="JNIPort-Java-Base">initializeFrom: aJavaStatic	"private -- copy as much data as possible from aJavaStatic.	This is called during bootstrapping and conversion of clases to ghosts, so aJavaStatic	will typically be of a *superclass* of the receiver.	Should be overriden by subclasses that may need to copy extra data"	self initialize.	jvm := aJavaStatic jvm.	classObject := aJavaStatic classObject.	javaSuperclass := aJavaStatic javaSuperclass.	instanceClass := aJavaStatic instanceClass.</body><body package="JNIPort-Java-Base">instanceClass: aSubclassOfJavaClassInstance	"private -- set the Smaltalk class to use to represent objects which are instance of this	Java class"	instanceClass := aSubclassOfJavaClassInstance.</body><body package="JNIPort-Java-Base">javaSuperclass: aJavaStatic	"private -- set the record of our Java superclass"	javaSuperclass := aJavaStatic.	javaSuperclass notNil ifTrue: [instanceClass := javaSuperclass instanceClass].</body><body package="JNIPort-Java-Base">jvm: aJVM	"private -- set the JVM that we, and all our 'instances' will use"	jvm := aJVM.</body><body package="JNIPort-Java-Base">notifyRegistered	"this is called by the class registry once we have been fully initialised.	Normally that means that the instance class and static class are both	correct and stable (will not change unless you, the programmer, manually	create and register a new wrapper class that is more appropriate for the	Java class we represent.  If ghost classes are in use then we are fully	populated with ghost methods by the time this is called too"	"default is not to be interested"</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>converting</category><body package="JNIPort-Java-Base">asJavaLangClass	"answer the receiver converted to a class object"	^ classObject.</body><body package="JNIPort-Java-Base">asStatic	"answer the receiver converted to a class static"	^ self.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>purging</category><body package="JNIPort-Java-Base">canBePurged	"private -- answer whether the receiver is purgeable"	^ true.</body><body package="JNIPort-Java-Base">purge	"private -- remove this class object from the main registries"	self isLive ifFalse: [^ self].	#CUtodo.  "should we #free the class object ?"	#CUtodo.  "should we #free our instances (and similar) ?"	self knownDirectJavaSubclasses do: [:each | each purge].	self jvm classIndex purge: self.	self classRegistry purge: self.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>comparing</category><body package="JNIPort-Java-Base">= aJavaStatic	"answer whether the receiver is = (in Java terms, this is an identity comparison) to aJavaStatic"	self == aJavaStatic ifTrue: [^ true].	self isDead ifTrue: [^ false].	"NB: we don't have the usual class comparsion here because the mapping from Java objects to	Smalltalk classes is not straightforward"	(aJavaStatic isKindOf: JavaStatic) ifFalse: [^ false].	^ self classObject = aJavaStatic classObject.</body><body package="JNIPort-Java-Base">hash	"answer the underlying javaObject's identity hash"	^ classObject hash.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>printing</category><body package="JNIPort-Java-Base">displayString	"append a user-oriented representation of our underlying Java object to aStream"	^classObject isDead ifTrue: [self printString] ifFalse: [self name]</body><body package="JNIPort-Java-Base">printOn: aStream	"append a user-oriented representation of our underlying Java object to aStream"	^classObject isDead ifTrue: [super printOn: aStream] ifFalse: [self writeDescriptionOn: aStream]</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-WrapperGeneration">genericTypeName	"answer one of Boolean, Byte, ... Object, Short, or, Void according to our type"	^ self class genericTypeName.</body><body package="JNIPort-Java-WrapperGeneration">isJavaLangString	"answer whether we stand for the class java.lang.String"	^ self == (self jvm findClass: #'java.lang.String').</body><body package="JNIPort-Java-WrapperGeneration">keywordBase	"private -- answer a suitable String to use for a keyword for parameter of this type without the :.	Replace the $ character by _ which is allowed in selectors"	^ self name copyReplacing: $$ withObject: $_.</body><body package="JNIPort-Java-WrapperGeneration">keywordName: useLongForm	"answer a suitable name to use for a keyword for parameter of this type; if the Bool	useLongForm is true then a longer form will be used that is less likely to be ambiguous.	NB: the terminating ':' is *not* included"	| base |	base := self keywordBase.	^useLongForm		ifTrue: [base reject: [:each | '$.' includes: each]]		ifFalse: [base allButFirst: ((base lastIndexOf: $.) max: (base lastIndexOf: $$))]</body><body package="JNIPort-Java-WrapperGeneration">parameterBase	"private -- answer a suitable String to use for a base for the name of a parameter of this type"	| name |	"drop any package name or enclosing classname prefix"	name := self name.	^ name allButFirst: ((name lastIndexOf: $.) max: (name lastIndexOf: $$)).</body><body package="JNIPort-Java-WrapperGeneration">parameterName: anInteger	"answer a suitable name to use for a parameter of this type, if anInteger is &gt; 0 then this is	one of several parameters of the same type"	| base str |	base := self parameterBase.	str := String new writeStream.	base first isLowercase ifFalse:		[str nextPutAll: (base first isVowel ifTrue: ['an'] ifFalse: ['a'])].	str nextPutAll: base.	anInteger &gt; 0 ifTrue: [str print: anInteger].	^ str contents.</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">conversionToJavaStringFor: aParameterName wrapperFactoryString: aString	^aParameterName</body><body package="JNIPort-Java-GhostClasses">conversionToSmalltalkStringFor: aString wrapperFactoryString: wrapperFactoryString	^ wrapperFactoryString , ' wrapJNIObject: ' , aString.</body><body package="JNIPort-Java-GhostClasses">ghostClassSettings	"answer the subcollection of settings for ghost classes"	^ self jvmSettings ghostClassSettings.</body><body package="JNIPort-Java-GhostClasses">hasGhostInstanceClass	"answer whether we are using a ghost class for instances.	NB: this is more subtle than just asking if the instance class	is a ghost class, since we may just be inheriting a ghost instance	class from our Java superclass without yet having a proper	ghost instance class dedicated to the Java class that we wrap"	instanceClass isGhostClass ifFalse: [^ false].	self javaSuperclassDo: [:it | it instanceClass = instanceClass ifTrue: [^ false]].	^ true.</body><body package="JNIPort-Java-GhostClasses">hasGhostStaticClass	"answer whether we are an instance of a ghost static class.	NB: this is more subtle than just checking whether we're ghost	since we may just be inheriting a ghost static class from our Java	superclass without yet having a proper ghost class dedicated to	the Java class that we wrap"	self isGhost ifFalse: [^ false].	self javaSuperclassDo: [:it | it class = self class ifTrue: [^ false]].	^ true.</body><body package="JNIPort-Java-GhostClasses">makeGhostInstanceClass	"private -- answer a new class to use as our ghost instance class"	^ instanceClass makeGhostClass: self name.</body><body package="JNIPort-Java-GhostClasses">makeGhostInstanceClassInstaller	"private -- answer a new JavaGhostClassInstaller that will populate our ghost instance class.	Should be overriden by subclasses that wish to modify the default settings"	| settings |	settings := self ghostClassSettings deepCopy.	"if the our superclass is not a ghost class, then we'll have to generate	all the wrappers up to java.lang.Object, since they will not be inherited"	settings includeAllSuperclasses: (instanceClass superclass isGhostClass not).	^ JavaGhostClassInstaller		forInstanceSideOf: self		destination: instanceClass		settings: settings.</body><body package="JNIPort-Java-GhostClasses">makeGhostStaticClass	"private -- answer a new class to use as our ghost static class"	^ self class makeGhostClass: (self name , '.static').</body><body package="JNIPort-Java-GhostClasses">makeGhostStaticClassInstaller	"private -- answer a new JavaGhostClassInstaller that will populate our own ghost static class.	Should be overriden by subclasses that wish to modify the default settings"	| settings |	settings := self ghostClassSettings deepCopy.	"if the our superclass is not a ghost class, then we'll have to generate	all the wrappers up to java.lang.Object, since they will not be inherited"	settings includeAllSuperclasses: (self class superclass isGhostClass not).	"make sure we inherit no constructors"	settings generateSNIConstructors: true.	^ JavaGhostClassInstaller		forClassSideOf: self		destination: self class		settings: settings.</body><body package="JNIPort-Java-GhostClasses">needsGhostInstanceClass	"answer whether the receiver needs a ghost class for instances.	NB: this is more subtle than just asking if the instance class	is a ghost class, since we may just be inheriting a ghost instance	class from our Java superclass without yet having a proper	ghost instance class dedicated to the Java class that we wrap"		^self instanceClass javaClassName ~= self name asSymbol		and:			[javaSuperclass isNil or: [javaSuperclass instanceClass = instanceClass]]</body><body package="JNIPort-Java-GhostClasses">needsGhostStaticClass	"answer whether the receiver needs an instance of a ghost static class.	NB: this is more subtle than just checking whether we're ghost	since we may just be inheriting a ghost static class from our Java	superclass without yet having a proper ghost class dedicated to	the Java class that we wrap"		^self class javaClassName ~= self name asSymbol</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostInstanceClass 	"private -- answer whether we should use a ghost class for our instances"	self subclassResponsibility.</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostStaticClass 	"private -- answer whether we should use a ghost class static"	self subclassResponsibility.</body><body package="JNIPort-Java-GhostClasses">useGhostClasses	"If there is no instance class for the receiver's class, then generate a ghost class for it. If there is no static class for the receiver's class, then generate a ghost class for the static. This method is executed during initialization of the JVM. It ensures that there is a instance or static class in the case where only one of the pair of wrapper classes has been implemented as a predefined Smalltalk class."		self javaSuperclassDo: [:it | it useGhostClasses].	(self shouldHaveGhostInstanceClass and: [self needsGhostInstanceClass])		ifTrue:			[self changeInstanceClassTo: self makeGhostInstanceClass.			self makeGhostInstanceClassInstaller install].	(self shouldHaveGhostStaticClass and: [self needsGhostStaticClass])		ifTrue:			[self changeStaticClassTo: self makeGhostStaticClass.			self makeGhostStaticClassInstaller install]</body></methods><methods><class-id>JNIPort.JavaStatic</class-id> <category>*JNIPort-Java-Callbacks</category><body package="JNIPort-Java-Callbacks">implementNative: aJavaLangReflectMethod by: a0Block	"register the &lt;niladicValuable&gt;, a0Block as the implementation of the given	native method.  Note that we are unable to handle native methods that take	any parameters or return any value (and so we cannot handle non-static	methods either)"	|  jniMethod itsName itsSignature itsCallback |	"this could screw up quite easily, so..."	self jniAssert: [self jvm supportsCallbacks].	self jniAssert: [aJavaLangReflectMethod declaredIn: self].	self jniAssert: [aJavaLangReflectMethod isNative].	self jniAssert: [aJavaLangReflectMethod isStatic].	self jniAssert: [aJavaLangReflectMethod type isVoid].	self jniAssert: [aJavaLangReflectMethod argumentCount = 0].	"create the JNIMethod struct; note that we hold onto references to the name, etc,	so they are protected against GC"	itsName := aJavaLangReflectMethod name.	itsSignature := "aJavaLangReflectMethod jniSignature" '()V'.	itsCallback := self makeCallbackInvoking: a0Block.	jniMethod := (JNINativeMethod new)				name: itsName;				signature: itsSignature;				callback: itsCallback;				yourself.	"technically we should pass an array of JNINativeMethods, but we only need one"	self jniEnv		RegisterNatives_class: self jniObject		methods: jniMethod		nMethods: 1		onException: [:ex | jvm throwJavaException: ex].	"maybe, with luck, we haven't now crashed or destabilised Smalltalk..."	"get our owning JVM to hold onto the external callback to prevent it getting GCed"	self jvm rememberExternalCallback: itsCallback.</body><body package="JNIPort-Java-Callbacks">makeCallbackInvoking: a0Block 	"private -- make an external callback that will result in us invoking	aBlock with no arguments"	"IMPORTANT: we are obliged to tell the JVM that it has to use a new JNIEnv, but we cannot	tell it to use the one supplied, since that may have been produced by the JVM running on a	different OS thread, and transferred over to this one by the Smalltalk VM.	For that reason, the jniObject ref supplied with the callback *must* be ignored, since it can	only be accessed from the thread that *originated* the callback (its local to the supplied	JNIEnv).	Thus, in turn, we can only supply native implementations of static void Java methods with	no parameters"	^JNIPortCallback do: 			[:jniEnv :jniObject | 			self jvm asCallbackDo: a0Block.			nil]		ofType: JNIPortJNIInterface current callback</body></methods><methods><class-id>JNIPort.JavaStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">defaultInstanceClass	"answer the Smalltalk class to use by default for objects representing instances of our Java class"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">registryCapacity	"answer the initial capacity to give registries used by instances"	^ 200.</body><body package="JNIPort-Java-Base">registryClass	"answer the kind of Object registry used by instances"	^ JavaObjectRegistry.</body></methods><methods><class-id>JNIPort.JavaStatic class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"private -- these should never be created except as a side effect of creating a JavaLangClass"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">newAsCopyOf: aJavaStatic	"private -- answer a new instance that copies as much data as possible from	aJavaStatic.	This is called during bootstrapping and conversion of clases to ghosts, so aJavaStatic	will typically be of an instance of a *superclass* of the receiver"	^ (self basicNew)		initializeFrom: aJavaStatic;		yourself.</body><body package="JNIPort-Java-Base">newWithJVM: aJVM	"private -- these should never be created except as a side effect of registering a JavaLangClass"	^ (self basicNew)		initialize;		jvm: aJVM;		yourself.</body></methods><methods><class-id>JNIPort.JavaStatic class</class-id> <category>registering wrapper classes</category><body package="JNIPort-Java-Base">registerWith: aClassFinder	"this is called as JVM is initialised, or with a SupplementaryClassloader, and gives	us the chance (should we wish to accept it) to register ourself with it as a wrapper	class"	"set the static class associated with our Java name to this class"	[(aClassFinder findClass: self javaClassName) changeStaticClassTo: self]		on: JavaException		do: [:ex | ex jniportNotify].</body></methods><methods><class-id>JNIPort.JavaStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-WrapperGeneration">genericTypeName	"answer one of Boolean, Byte, ... Object, Short, or, Void according to our type"	^ 'Object'.</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>helpers</category><body package="JNIPort-Java-Base">objectRegistry	"private -- answer the registry of canoncial instances that we hold.	Will be null if (as is typical) we do not have canoncial instances"	^ registry.</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>canonical instances</category><body package="JNIPort-Java-Base">ensureRegistryInstalled	"private -- ensure we have an Object registry for holding canonical instances"	self sharedMutex critical:		[registry isNil ifTrue: [registry := self makeRegistry]].</body><body package="JNIPort-Java-Base">isCanonical: anInstance	"answer whether the given instance is the canonical instance"	^ registry		ifNil: [false]		ifNotNil: [:it | it includes: anInstance].</body><body package="JNIPort-Java-Base">makeCanonical: anInstance	"make the given instance be the canonical instance (evicting	any previous encumbent)"	"install a registry if we don't already have one but don't set the	allInstancesAreCanonical flag, since we don't want to make *all*	instances canonical"	self ensureRegistryInstalled.	"if the registry already contained a different JavaInstance that	refers to the same Java object as anInstance, then it'll be	replaced"	registry add: anInstance.</body><body package="JNIPort-Java-Base">makeNotCanonical: anInstance	"make the given instance not be the canonical instance.	NB: should normally only be used for instances that are about	to be #free-d explicitly (very much the exepctional case)"	registry ifNotNil: [:it | it purge: anInstance].</body><body package="JNIPort-Java-Base">makeRegistry	"private -- answer  a new JavaObjectRegistry"	^ self class registryClass		new: self class registryCapacity		withJVM: self jvm.</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initializeFrom: aJavaStatic	"private -- copy as much data as possible from aJavaStatic.	This is called during bootstrapping and conversion of clases to ghosts, so aJavaStatic	will typically be of a *superclass* of the receiver.	Should be overriden by subclasses that may need to copy extra data"	super initializeFrom: aJavaStatic.	"this is strictly unecessary since we should not reach here before we get	#notifyRegistered (which is where we initialise this data), but just to be	clear and clean..."	registry := aJavaStatic objectRegistry.	allInstancesAreCanonical := aJavaStatic hasCanonicalInstances.</body><body package="JNIPort-Java-Base">notifyRegistered	"this is called by the class registry once we have been fully initialised.	Normally that means that the instance class and static class are both	correct and stable (will not change unless you, the programmer, manually	create and register a new wrapper class that is more appropriate for the	Java class we represent).  If ghost classes are in use then we are fully	populated with ghost methods by the time this is called too"	super notifyRegistered.	"we postpone this to here so that we can be sure that the instance	class is correct"	allInstancesAreCanonical := false.	self hasCanonicalInstancesByDefault		ifTrue: [self haveCanonicalInstances].</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">callConstructor	"answer a JavaObject wrapping a newly created instance of the Java class we represent"	^ self callConstructorMID: (self findConstructor: '()V').</body><body package="JNIPort-Java-Base">callConstructorMID: aMethodID	"answer a JavaObject wrapping a newly created instance of the Java class we represent"	^ self callConstructorMID: aMethodID withArguments: JNIValueArray null.</body><body package="JNIPort-Java-Base">callConstructorMID: aMethodID withArguments: aJNIValueArray	"answer a JavaObject wrapping a newly created instance of the Java class we represent"	| answer |	answer := self jniEnv			NewObjectA_class: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:jex | jvm throwJavaException: jex].	"since we know the precise type of the generated object, we can wrap it directly here,	which is faster"	^ self wrapJNIObject: answer.</body><body package="JNIPort-Java-Base">callConstructorSignature: aJNISignatureString withArguments: aJNIValueArray	"answer a JavaObject wrapping a newly created instance of the Java class we represent"	^ self callConstructorMID: (self findConstructor: aJNISignatureString) withArguments: aJNIValueArray.</body><body package="JNIPort-Java-Base">findConstructor: aString	"answer the JavaMethodID corresponding to our Java object's constructor with	signature defined by anotherString"	^ self jniEnv		GetMethodID_class: self jniObject		name: '&lt;init&gt;'		sig: aString		onException: [:ex | jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">new	"answer the result of trying to call this classes default contructor"	^ self callConstructor.</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>modes</category><body package="JNIPort-Java-Base">canonicalInstances	"answer a list of all our canonical instances.	NB: this isn't really threadsafe"	^ registry 		ifNil: [#()]		ifNotNil: [:it | it contents].</body><body package="JNIPort-Java-Base">haveCanonicalInstances	"set that all subsequently created instances will be made canonical.	There is intentionally no way to reverse the effect of this request"	allInstancesAreCanonical ifFalse:		[self ensureRegistryInstalled.		allInstancesAreCanonical := true].</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">basicWrapJNIObject: aJNIObject	"private -- answer a new instance of our instance class which wraps aJNIObject and which is not	initially canonical (though it may be made so later).  Note we assume that aJNIObject is not Null"	^ instanceClass		jniObject: aJNIObject		static: self.</body><body package="JNIPort-Java-Base">hasAnyCanonicalInstances	"answer whether any instances are currently canonical.	(Also see #hasCanonicalInstances)"	^ registry		ifNil: [false]		ifNotNil: [:it | it notEmpty].</body><body package="JNIPort-Java-Base">hasCanonicalInstances	"answer whether *all* instances are automatically made canonical.	(Also see #hasAnyCanonicalInstances)"	^ allInstancesAreCanonical.</body><body package="JNIPort-Java-Base">wrapJNIObject: aJNIObject	"answer a new instance of our instance class which wraps aJNIObject.  If there	was a previously existing instance that represents the same Java object, and which has	been made canonical, then free the JNI object and answer the canonical instance"	^ aJNIObject isNull		ifTrue: [nil]		ifFalse: [registry isNil			ifTrue: [self basicWrapJNIObject: aJNIObject]			ifFalse: [allInstancesAreCanonical				ifTrue: [registry findOrRelease: aJNIObject ifAbsentPut: [self basicWrapJNIObject: aJNIObject]]				ifFalse: [registry findOrRelease: aJNIObject ifAbsent: [self basicWrapJNIObject: aJNIObject]]]].</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state"	super initialize.	"minor note: this will immediately be overwritten in nearly all cases, the	only exceptions are the four instances created 'illegally' during bootstrapping.	See JavaClassRegistry&gt;&gt;registerSystemClasses"	allInstancesAreCanonical := false.</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>displaying</category><body package="JNIPort-Java-Base">writeDescriptionOn: aStream	"write a short description of our methods on aStream"	super writeDescriptionOn: aStream.	registry isNil ifTrue: [^ self].	aStream		cr;		nextPutAll: (self hasCanonicalInstances ifTrue: ['Canonical ('] ifFalse: ['Partly canonical (']);		print: registry tableSize;		nextPutAll: ' registered)'.</body><body package="JNIPort-Java-Base">writeStatusOn: aStream	"write a formatted description of our status on aStream"	registry isNil ifTrue: [^ self].	aStream		nextPutAll: (self hasCanonicalInstances ifTrue: ['All'] ifFalse: ['Some']);		nextPutAll: ' instances are canonical (';		print: registry tableSize;		nextPutAll: ' currently registered)';		cr; cr.</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>exception filtering</category><body package="JNIPort-Java-Base">, anExceptionFilter	"answer a new ExceptionSet containing the receiver and anExceptionFilter (typically a Class	under Exception"	^(ExceptionSet new)		add: self;		add: anExceptionFilter;		yourself</body><body package="JNIPort-Java-Base">handles: anException	"answer whether the receiver matches anException.	This is provided so that instances of JavaException can be caught	with exception on: blocks using *INSTANCES* of javaLangClass"	^ (JavaException handles: anException)		and: [(anException parameter isKindOf: JavaLangThrowable)			and: [classObject isInstance: anException parameter]].</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the field of this type defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field.  We are overriden in	the primitive classes)"	"overridden because we may be able to use the optimised version"	^ aJavaObject		getObjectFID: aJNIFieldID		wrapperFactory: (self couldBeSubstituted ifTrue: [self jvm] ifFalse: [self]).</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>constants</category><body package="JNIPort-Java-Base">hasCanonicalInstancesByDefault	"answer whether we should have canonical instances at startup.	(if not then it can always be turned on later).	Override in subclasses, to force this"	"default is just to ask our instance class what it thinks"	^ instanceClass hasCanonicalInstancesByDefault.</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>testing</category><body package="JNIPort-Java-Base">couldBeSubstituted	"answer false if we represent a class for which the JVM rules do not allow any other	to be substituted at runtime (e.g. final classes)"	^ classObject isFinal not.</body><body package="JNIPort-Java-Base">isSubclassOf: aJavaStatic	"answer whether this Java class includes the Java class defined by aJavaStatic in	its inheritance chain.	Note: this does *not* include interfaces"	^javaSuperclass notNil		and: [javaSuperclass == aJavaStatic or: [javaSuperclass isSubclassOf: aJavaStatic]].</body></methods><methods><class-id>JNIPort.JavaClassStatic</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">conversionToJavaStringFor: aParameterName wrapperFactoryString: aString	^ self isJavaLangString		ifTrue: ['(' , aParameterName , ' asJavaString: ' , aString , ')']		ifFalse: [aParameterName].</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostInstanceClass 	"private -- answer whether we should use a ghost class for our instances"	^ self ghostClassSettings useGhostInstances.</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostStaticClass 	"private -- answer whether we should use a ghost class static"	^ self ghostClassSettings useGhostStatics.</body></methods><methods><class-id>JNIPort.JavaClassStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaObjectArray.</body><body package="JNIPort-Java-Base">defaultInstanceClass	"answer the Smalltalk class to use by default for objects representing instances of our Java class"	^ JavaLangObject.</body></methods><methods><class-id>JNIPort.StaticJavaLangObject</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer the result of calling the receiver's public default Java constructor"	^ self callConstructor.</body></methods><methods><class-id>JNIPort.StaticJavaLangObject class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Object'.</body></methods><methods><class-id>JNIPort.StaticJavaLangObject class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body></methods><methods><class-id>JNIPort.JavaException</class-id> <category>accessing</category><body package="JNIPort-Java-Base">cause	"answer the underlying exception's 'cause' (i.e. the previous exception	in the backchain).  NB: only available with J2SDK1.4 and later JVMs"	^self parameter cause</body><body package="JNIPort-Java-Base">javaStackTrace	"answer the underlying exception's array of java.lang.StackTraceElements.	NB: only available with J2SDK1.4 and later JVMs"	^self parameter stackTrace</body><body package="JNIPort-Java-Base">shortMessage	"answer the underlying exception's so-called: 'short message'"	^self parameter message</body></methods><methods><class-id>JNIPort.JavaException</class-id> <category>printing</category><body package="JNIPort-Java-Base">description	^super description , ': ' , ([self parameter displayString] on: Error				do: [:error | error return: '(Error printing parameter)'])</body></methods><methods><class-id>JNIPort.JavaAggregate</class-id> <category>converting</category><body package="JNIPort-Java-Base">asArray	"shorthand for:"	^ self asCollection asArray.</body><body package="JNIPort-Java-Base">asBag	"shorthand for:"	^ self asCollection asBag.</body><body package="JNIPort-Java-Base">asCollection	"answer an adaptor which makes this Java aggregate object look like something from the Smalltalk	Collection hierarchy.	In fact, for these classes we answer a ArrayAdaptor wrapped around the aggregate.	It acts in all (maybe!) ways like a SequenceableCollection"	adaptorCache isNil ifTrue: [adaptorCache := ArrayAdaptor for: self].	^ adaptorCache.</body><body package="JNIPort-Java-Base">asIdentitySet	"shorthand for:"	^IdentitySet withAll: self asCollection</body><body package="JNIPort-Java-Base">asOrderedCollection	"shorthand for:"	^ self asCollection asOrderedCollection.</body><body package="JNIPort-Java-Base">asSet	"shorthand for:"	^ self asCollection asSet.</body><body package="JNIPort-Java-Base">asSortedCollection	"shorthand for:"	^ self asCollection asSortedCollection.</body><body package="JNIPort-Java-Base">asSortedCollection: sortBlock	"shorthand for:"	^ self asCollection asSortedCollection: sortBlock.</body><body package="JNIPort-Java-Base">readStream	"shorthand for:"	^ self asCollection readStream.</body><body package="JNIPort-Java-Base">writeStream	"shorthand for:"	^ self asCollection writeStream.</body></methods><methods><class-id>JNIPort.JavaAggregate</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">allSatisfy: a1Block	"shorthand for:"	^ self asCollection allSatisfy: a1Block.</body><body package="JNIPort-Java-Base">anySatisfy: a1Block	"shorthand for:"	^ self asCollection anySatisfy: a1Block.</body><body package="JNIPort-Java-Base">collect: a1Block	"shorthand for:"	^ self asCollection collect: a1Block.</body><body package="JNIPort-Java-Base">do: a1Block	"shorthand for:"	^ self asCollection do: a1Block.</body><body package="JNIPort-Java-Base">inject: anObject into: a2Block	"shorthand for:"	^ self asCollection inject: anObject into: a2Block.</body><body package="JNIPort-Java-Base">reject: a1Block	"shorthand for:"	^ self asCollection reject: a1Block.</body><body package="JNIPort-Java-Base">select: a1Block	"shorthand for:"	^ self asCollection select: a1Block.</body></methods><methods><class-id>JNIPort.JavaAggregate</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anInteger	"one of the root methods for &lt;SequenceableCollection&gt;"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">at: anIndex put: anObject	"one of the root methods for &lt;SequenceableCollection&gt;"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">size	"answer the number of elements in the underlying Java aggregate"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaAggregate</class-id> <category>searching</category><body package="JNIPort-Java-Base">detect: a1Block	"shorthand for:"	^ self asCollection detect: a1Block.</body><body package="JNIPort-Java-Base">detect: a1Block ifNone: a0Block	"shorthand for:"	^ self asCollection detect: a1Block ifNone: a0Block.</body><body package="JNIPort-Java-Base">includes: anObject	"shorthand for:"	^ self asCollection includes: anObject.</body></methods><methods><class-id>JNIPort.JavaAggregate</class-id> <category>replacing</category><body package="JNIPort-Java-Base">replaceFrom: aStartIndex to: aStopIndex with: replacementElements	"shorthand for:"	^ self asCollection replaceFrom: aStartIndex to: aStopIndex with: replacementElements.</body></methods><methods><class-id>JNIPort.JavaAggregate</class-id> <category>testing</category><body package="JNIPort-Java-Base">isEmpty	"answer whether the receiver contains no elements."	^ self size == 0.</body><body package="JNIPort-Java-Base">notEmpty	"answer whether the receiver contains any elements"	^ self isEmpty not.</body></methods><methods><class-id>JNIPort.JavaAggregate</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization."	super actAsExecutor.	adaptorCache := sizeCache := nil</body></methods><methods><class-id>JNIPort.JavaPrimitiveArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anInteger	"one of the root methods for &lt;SequenceableCollection&gt;"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">at: anIndex put: anObject	"one of the root methods for &lt;SequenceableCollection&gt;"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">elementCType	^self subclassResponsibility</body><body package="JNIPort-Java-Base">elementClass	"answer the class static for the type of our elements"	^ static elementClass.</body><body package="JNIPort-Java-Base">setElements: anExternalArray offset: anOffset length: anInteger	"copy anInteger elements from anExternalArray into our Java array,	starting at the zero-based anOffset in the target"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">size	"answer the number of elements in the underlying Java array"	sizeCache isNil ifFalse: [^ sizeCache].	sizeCache := self jniEnv				GetArrayLength_array: jniObject				onException: [:jex | self jvm throwJavaException: jex].	^ sizeCache.</body></methods><methods><class-id>JNIPort.JavaPrimitiveArray</class-id> <category>replacing</category><body package="JNIPort-Java-Base">copyForReplace: aSequenceableCollection from: aStartIndex to: aStopIndex	"private -- answer a a pointer to an external array with the 'same' data as the closed sub-interval of aCollection"	^self elementCType		newPointerToCopyOf: aSequenceableCollection		from: aStartIndex		to: aStopIndex</body><body package="JNIPort-Java-Base">replaceFrom: aStartIndex to: aStopIndex with: replacementElements startingAt: aReplacementIndex	"destructively replace the elements of our Java array  in the range [aStartIndex, aStopIndex]	with the values contained in the Smalltalk &lt;sequencedReadableCollection&gt;, replacementElements,	starting at aReplacementIndex.	For compatibility with the Collection implementation, this allows overlapping moves (easy since we	make a copy of the replacement anyway), and replacement of empty ranges ourside the limits of	the receiver.	Answers the receiver"	| arrayPointer |	aStartIndex &gt; aStopIndex ifTrue: [^self].	arrayPointer := self				copyForReplace: replacementElements				from: aReplacementIndex				to: aReplacementIndex + aStopIndex - aStartIndex.		[self		setElements: arrayPointer		offset: aStartIndex - 1		length: aStopIndex - aStartIndex + 1]			ensure: [arrayPointer free]</body></methods><methods><class-id>JNIPort.JavaPrimitiveArray</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">clone	"answer the result of calling the (public for arrays) Java method clone()"	^ self callObjectMethod: 'clone' signature: '()Ljava/lang/Object;'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block	"one of the root methods for &lt;SequenceableCollection&gt;, note that the indexes are Smalltalk	indexes and, as such, 1-based"	| stop |	aStartIndex &gt; aStopIndex ifTrue: [^self].	aStartIndex &lt; 1 ifTrue: [self errorSubscriptBounds: aStartIndex].	aStartIndex &gt; self size ifTrue: [self errorSubscriptBounds: aStartIndex].	stop := self size min: aStopIndex.	self withElementsDo: 			[:pointer |			pointer				from: aStartIndex				to: stop				keysAndValuesDo: a2Block				elementType: self elementCType].	stop &lt; aStopIndex ifTrue: [self errorSubscriptBounds: stop + 1]</body><body package="JNIPort-Java-Base">withElementsDo: aOneArgumentBlock	self subclassResponsibility</body></methods><methods><class-id>JNIPort.JavaPrimitiveArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaPrimitiveArray class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">from: aList jvm: aJVM	"answer a new JavaObject wrapping an array initialised by copying the elements of aList"	| new |	new := self new: aList size jvm: aJVM.	new replaceFrom: 1 to: aList size with: aList.	^ new.</body><body package="JNIPort-Java-Base">new: length elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and the elements are initalised to nil.  This is provided for consistancy with JavaObjectArray,	and -- in fact -- the class static argument is ignored except to define the JVM to use"	^ self new: length jvm: aJavaStatic jvm.</body><body package="JNIPort-Java-Base">newWith: anObject elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding anObject.	This is provided for consistancy with JavaObjectArray"	^ (self new: 1 jvm: aJavaStatic)		at: 1 put: anObject;		yourself.</body><body package="JNIPort-Java-Base">newWith: anObject1 with: anObject2 elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding the given JavaObjects.	This is provided for consistancy with JavaObjectArray"	^ (self new: 2 jvm: aJavaStatic)		at: 1 put: anObject1;		at: 2 put: anObject2;		yourself.</body><body package="JNIPort-Java-Base">newWith: anObject1 with: anObject2 with: anObject3 elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding the given JavaObjects.	This is provided for consistancy with JavaObjectArray"	^ (self new: 3 jvm: aJavaStatic)		at: 1 put: anObject1;		at: 2 put: anObject2;		at: 3 put: anObject3; 		yourself.</body><body package="JNIPort-Java-Base">newWithAll: aList elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding the given Objects.	This is provided for consistancy with JavaObjectArray"	^ self from: aList jvm: aJavaStatic jvm.</body></methods><methods><class-id>JNIPort.JavaPrimitiveArray class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#clone	).</body></methods><methods><class-id>JNIPort.JavaIntArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[self jniEnv		GetIntArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	self elementCType newFromJNIDatum: bufferPointer]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: anInteger	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType newPointerTo: anInteger.		[self jniEnv		SetIntArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jint</body><body package="JNIPort-Java-Base">setElements: aSDWORDArray offset: anOffset length: anInteger	"copy anInteger elements from SDWORDArray into our Java array,	starting at the zero-based anOffset in the target"	self jniEnv			SetIntArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: aSDWORDArray			onException: [:jex | self jvm throwJavaException: jex].</body></methods><methods><class-id>JNIPort.JavaIntArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary SDWORDArray.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetIntArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseIntArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaIntArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[I'.</body></methods><methods><class-id>JNIPort.JavaIntArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewIntArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>canonical instances</category><body package="JNIPort-Java-Base">makeNotCanonical: anInstance	"overriden to avoid accidents"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">makeRegistry	"private -- answer  a new JavaObjectRegistry.	Overridden because the JVM creates the system-wide JavaClassRegistry before we are	created ourself"	"if we get here then something's gone wrong"	^ self shouldNotImplement.</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>initializing</category><body package="JNIPort-Java-Base">jvm: aJVM	"private -- set the JVM that we, and all our 'instances' will use.	Overriden to pick up the class registry"	super jvm: aJVM.	registry := aJVM classRegistry.</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>constants</category><body package="JNIPort-Java-Base">hasCanonicalInstancesByDefault	"answer whether we should have canonical instances at startup.	Overriden to force this"	"actually we have a JavaClassRegistry rather than the normal JavaObjectRegistry"	^ true.</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">basicWrapJNIObject: aJNIClass	"private -- answer a new instance of our instance class which wraps aJNIClass and which is not	initially canonical (though it will be made so later).  Note we assume that aJNIClass is not Null.	Overriden superclass def to create/assign a new class static too"	| newClassObject newStatic |	"create a new class static and class object.	NB: the order here is subtle -- we cannot use the aJNIClass ref at any time	after it has been wrapped since that might have invalidated the reference as	a side-effect (of converting it to a global)"	#CUtodo.  "remove this fragility"	newStatic := self classStaticFor: aJNIClass.	newClassObject := super basicWrapJNIObject: aJNIClass.	"tie them together"	newStatic classObject: newClassObject.	newClassObject classStatic: newStatic.	^ newClassObject.</body><body package="JNIPort-Java-Base">classStaticFor: aJNIClass	"private -- answer a new class static which is appropriate to aJNIClass.  We assume	that no class static has yet been registered for aJNIClass"	| superclassStatic classStaticClass |	"find out what sort of class static to use for the new class.  We use different class statics for	array clases, normal classes, and interface classes.  For normal classes the class static's	class is usualy the same as was used for its superclass (StaticJavaLangObject for	java.lang.Object). however this may be overridden if a more specialised class static is registered.	(Note that we do not end up in this code if a specialisation *is* registered).	Logically we should also test for primitive types, but they are all dealt with during bootstrapping	so there is no actual need for a test	We use the raw JNI interfaces for speed, also assume no exception checking is necessary here"	((self jniEnv GetSuperclass_sub: aJNIClass) asJavaObject: jvm)		ifNil: [ 			"interfaces have no superclass. NB: java.lang.Object is registered during bootstrap"			classStaticClass := (jvm isInterfaceClass: aJNIClass)				ifTrue: [ JavaInterfaceStatic ] 				ifFalse: [ StaticJavaLangClass ]]		ifNotNil: [ :superclassObject |			superclassStatic := superclassObject classStatic.			"array classes are subclasses of java.lang.Object"			classStaticClass := ( jvm isArrayClass: aJNIClass )				ifTrue: [ JavaArrayClassStatic ]				ifFalse: [ superclassStatic class ]].	^ (classStaticClass newWithJVM: self jvm)		javaSuperclass: superclassStatic;		yourself</body><body package="JNIPort-Java-Base">wrapJNIObject: aJNIClass 	"answer a (possibly, but not usually, new) class object which wraps aJNIClass.	Overriden superclass def to avoid some tests (this is called *A LOT*)"	^aJNIClass isNull 		ifTrue: [nil]		ifFalse: 			[| jniClass |			jniClass := aJNIClass asJNIClass.			registry findOrRelease: jniClass				ifAbsentPut: [self basicWrapJNIObject: jniClass]]</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">forName: aJavaString initialize: aBool classloader: aJavaObject	"answer the result of calling java.lang.Class.forName(String, boolean, ClassLoader)"	^ self forName_String: aJavaString boolean: aBool ClassLoader: aJavaObject.</body><body package="JNIPort-Java-Base">forName_String: aString1 boolean: boolean1 ClassLoader: aClassLoader1	"answer the result of calling the receiver's public static forName(java.lang.String, boolean, java.lang.ClassLoader) Java method"	^JNIValueArray new: 3		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				booleanAt: 2 put: boolean1;				objectAt: 3 put: aClassLoader1.			self				callObjectMethod: 'forName'				signature: '(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>mutating</category><body package="JNIPort-Java-Base">replaceInstanceClass: anOldClass by: aNewClass	"private -- if we are using anOld class as our instance class, then change to use aNewClass.	This will be called during bootstrapping if it turns out that we have to change the Smalltalk	class used to represent java.lang.Class instances.  Unless ghost classes are used (or something	similar) there will be no need for this (since the class registry bootstrap ensures we start off	correct).	The main difference from the superclass implementation is that we must ensure that our instances	(since we know we have some) are changed too"	"purposly don't supersend"	instanceClass == anOldClass ifFalse: [^ self].	"remember our new instance class"	instanceClass := aNewClass.	"convert our existing instances.	This use of #becomeA: is *probably* not fragile since we only hit here if we are	being converted to use ghost classes, in which case the old and new classes	must have the same shape"	(anOldClass allInstances		select: [:each | each static == self])			do: [:each | each becomeA: aNewClass].</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">forName: aJavaString	"answer the result of calling java.lang.Class.forName()"	^ self forName_String: aJavaString.</body></methods><methods><class-id>JNIPort.StaticJavaLangClass</class-id> <category>Java-static</category><body package="JNIPort-Java-Base">forName_String: aString1	"answer the result of calling the receiver's public static forName(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'forName'				signature: '(Ljava/lang/String;)Ljava/lang/Class;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangClass class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#forName_String:		#forName_String:boolean:ClassLoader:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangClass class</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultInstanceClass	"answer the Smalltalk class to use by default for objects representing instances of our Java class"	^ JavaLangClass</body><body package="JNIPort-Java-Base">registryCapacity	"answer the initial capacity to give registries used by instances.	This is not, in fact, ever called, since the JVM creates the class	registry for JavaLangClass during bootstrap"	^ 200.</body><body package="JNIPort-Java-Base">registryClass	"answer the kind of Object registry used by instances.	This is not, in fact, ever called, since the JVM creates the class	registry for JavaLangClass during bootstrap"	^ JavaClassRegistry.</body></methods><methods><class-id>JNIPort.StaticJavaLangClass class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.Class'.</body></methods><methods><class-id>JNIPort.JavaStaticWrapperGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">constructors	"answer a Collection of JavaLangReflectConstructor objects for which we should generate wrappers"	"we don't bother with constructors for abstract classes, since they can only every be used	by subclasses -- which we aren't ever going to be..."	^ classStatic isAbstract		ifTrue: [#()]		ifFalse: [classStatic constructors].</body><body package="JNIPort-Java-WrapperGeneration">getters	"answer a Collection of JavaLangReflectField objects for which we should generate getter wrappers"	"note that we always pick up static fields inherited from directly implemented interfaces, even if	'includeAllSuperclasses is false"	^ installer settings includeAllSuperclasses				ifTrue: [classStatic allFields]				ifFalse: [classStatic fieldsPlusInterfaceFields]</body><body package="JNIPort-Java-WrapperGeneration">wrappers	"answer a Collection of JavaLangReflectMethod objects for which we should generate wrappers"	^ installer settings includeAllSuperclasses				ifTrue: [classStatic allMethods]				ifFalse: [classStatic methods].</body></methods><methods><class-id>JNIPort.StaticJavaLangNumber class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body></methods><methods><class-id>JNIPort.StaticJavaLangNumber class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Number'.</body></methods><methods><class-id>JNIPort.StaticJavaLangLong</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">bitCount_long: long1	"answer the result of calling the receiver's public static bitCount(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callIntMethod: 'bitCount' signature: '(J)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">get_SIZE	"answer the value of the receiver's public static final SIZE Java field"	^ self getIntField: 'SIZE'.</body><body package="JNIPort-Java-AdditionalWrappers">highestOneBit_long: long1	"answer the result of calling the receiver's public static highestOneBit(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callLongMethod: 'highestOneBit' signature: '(J)J' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">lowestOneBit_long: long1	"answer the result of calling the receiver's public static lowestOneBit(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callLongMethod: 'lowestOneBit' signature: '(J)J' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">numberOfLeadingZeros_long: long1	"answer the result of calling the receiver's public static numberOfLeadingZeros(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callIntMethod: 'numberOfLeadingZeros'				signature: '(J)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">numberOfTrailingZeros_long: long1	"answer the result of calling the receiver's public static numberOfTrailingZeros(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callIntMethod: 'numberOfTrailingZeros'				signature: '(J)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">reverseBytes_long: long1	"answer the result of calling the receiver's public static reverseBytes(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callLongMethod: 'reverseBytes' signature: '(J)J' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">reverse_long: long1	"answer the result of calling the receiver's public static reverse(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callLongMethod: 'reverse' signature: '(J)J' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">rotateLeft_long: long1 int: int1	"answer the result of calling the receiver's public static rotateLeft(long, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				longAt: 1 put: long1;				intAt: 2 put: int1.			self callLongMethod: 'rotateLeft' signature: '(JI)J' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">rotateRight_long: long1 int: int1	"answer the result of calling the receiver's public static rotateRight(long, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				longAt: 1 put: long1;				intAt: 2 put: int1.			self callLongMethod: 'rotateRight' signature: '(JI)J' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">signum_long: long1	"answer the result of calling the receiver's public static signum(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callIntMethod: 'signum' signature: '(J)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_long: long1	"answer the result of calling the receiver's public static valueOf(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callObjectMethod: 'valueOf'				signature: '(J)Ljava/lang/Long;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangLong</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">decode_String: aString1	"answer the result of calling the receiver's public static decode(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'decode'				signature: '(Ljava/lang/String;)Ljava/lang/Long;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">getLong_String: aString1	"answer the result of calling the receiver's public static getLong(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getLong'				signature: '(Ljava/lang/String;)Ljava/lang/Long;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">getLong_String: aString1 Long: aLong1	"answer the result of calling the receiver's public static getLong(java.lang.String, java.lang.Long) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: aLong1.			self				callObjectMethod: 'getLong'				signature: '(Ljava/lang/String;Ljava/lang/Long;)Ljava/lang/Long;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">getLong_String: aString1 long: long1	"answer the result of calling the receiver's public static getLong(java.lang.String, long) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				longAt: 2 put: long1.			self				callObjectMethod: 'getLong'				signature: '(Ljava/lang/String;J)Ljava/lang/Long;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseLong_String: aString1	"answer the result of calling the receiver's public static parseLong(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callLongMethod: 'parseLong'				signature: '(Ljava/lang/String;)J'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseLong_String: aString1 int: int1	"answer the result of calling the receiver's public static parseLong(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callLongMethod: 'parseLong'				signature: '(Ljava/lang/String;I)J'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toBinaryString_long: long1	"answer the result of calling the receiver's public static toBinaryString(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callObjectMethod: 'toBinaryString'				signature: '(J)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toHexString_long: long1	"answer the result of calling the receiver's public static toHexString(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callObjectMethod: 'toHexString'				signature: '(J)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toOctalString_long: long1	"answer the result of calling the receiver's public static toOctalString(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callObjectMethod: 'toOctalString'				signature: '(J)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_long: long1	"answer the result of calling the receiver's public static toString(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callObjectMethod: 'toString'				signature: '(J)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_long: long1 int: int1	"answer the result of calling the receiver's public static toString(long, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				longAt: 1 put: long1;				intAt: 2 put: int1.			self				callObjectMethod: 'toString'				signature: '(JI)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1	"answer the result of calling the receiver's public static valueOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;)Ljava/lang/Long;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1 int: int1	"answer the result of calling the receiver's public static valueOf(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;I)Ljava/lang/Long;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangLong</class-id> <category>Java-constructors</category><body package="JNIPort-Java-AdditionalWrappers">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">new_long: long1	"answer the result of calling the receiver's public new(long) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callConstructorSignature: '(J)V' withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangLong</class-id> <category>Java-static</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_VALUE	"answer the value of the receiver's public static final MAX_VALUE Java field"	^ self getLongField: 'MAX_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_VALUE	"answer the value of the receiver's public static final MIN_VALUE Java field"	^ self getLongField: 'MIN_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_TYPE	"answer the value of the receiver's public static final TYPE Java field"	^ self getObjectField: 'TYPE' signature: 'Ljava/lang/Class;'.</body></methods><methods><class-id>JNIPort.StaticJavaLangLong class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new_long:		#new_String:	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_MAX_VALUE		#get_MIN_VALUE		#get_SIZE		#get_TYPE	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#bitCount_long:		#decode_String:		#getLong_String:		#getLong_String:Long:		#getLong_String:long:		#highestOneBit_long:		#lowestOneBit_long:		#numberOfLeadingZeros_long:		#numberOfTrailingZeros_long:		#parseLong_String:		#parseLong_String:int:		#reverseBytes_long:		#reverse_long:		#rotateLeft_long:int:		#rotateRight_long:int:		#signum_long:		#toBinaryString_long:		#toHexString_long:		#toOctalString_long:		#toString_long:		#toString_long:int:		#valueOf_long:		#valueOf_String:		#valueOf_String:int:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangLong class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Long'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic</class-id> <category>testing</category><body package="JNIPort-Java-Base">couldBeSubstituted	"answer false if we represent a class for which the JVM rules do not allow any other	to be substituted at runtime (e.g. final classes)"	^ false.</body><body package="JNIPort-Java-Base">isAPrimitive	"answer whether we stand for an Java primitive class (int, float, etc)"	^ true.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic</class-id> <category>constants</category><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	self class wrapperJavaClassName.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ self class jniSignature.</body><body package="JNIPort-Java-Base">name	"answer the name of the member as a String"	^ self class javaTypeName.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-WrapperGeneration">parameterBase	"private -- answer a suitable String to use for a parameter of this type"	^ self name.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">conversionToSmalltalkStringFor: aString wrapperFactoryString: wrapperFactoryString	^aString</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostInstanceClass 	"private -- answer whether we should use a ghost class for our instances"	^ false.</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostStaticClass 	"private -- answer whether we should use a ghost class static"	^ false.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic class</class-id> <category>testing</category><body package="JNIPort-Java-Base">isWrapperClass	"answer whether this class is intended to correspond to some particular Java class"	^ self class includesSelector: #javaTypeName.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultInstanceClass	"answer the Smalltalk class to use by default for objects representing instances of our Java class"	^ JavaPrimitiveInstance.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaPrimitiveStatic class</class-id> <category>registering wrapper classes</category><body package="JNIPort-Java-Base">registerWith: aClassFinder	"this is called as JVM is initialised, or with a SupplementaryClassloader, and gives	us the chance (should we wish to accept it) to register ourself with it as a wrapper	class"	"we cannot treat JVMs and local classpath entries eqivalently, so we don't try..."	self shouldNotImplement.</body><body package="JNIPort-Java-Base">registerWithJVM: aJVM	"this is called as JVM is initialised and gives us the chance (should we wish to accept it)	to register ourself with it as a wrapper class.	NB: this is only called if #shouldRegisterWithJVM answers true"	|  wrapperClass classObject classStatic |	self isWrapperClass ifFalse: [ ^self ].	"this is all just a little too wierd.	The twisted logic is ultimately because JNI findClass() won't work with any form of the names of	the primitive types, so we have to go via the Java primitive wrapper classes (java.lang.Integer,	java.lang.Boolean, etc) .  We can /almost/ do it via the Array class names, '[I', '[F', and so on	(which do work), but that won't do for void since void[] is not a legal class.	Grrr..."	"start from the wrapper class ('wrapper' in this case meaning the java.lang.Integer or similar	Java class that 'wraps' the primiive type)"	wrapperClass := aJVM findClass: self wrapperJavaClassName.	"the primitive type is the value of the wrapper class's static TYPE field; it'll be registered	as a side effect of being returned by #getObjectField:signature:"	classObject := wrapperClass getObjectField: 'TYPE' signature: 'Ljava/lang/Class;'.	self jniAssert: [classObject notNil].	classStatic := classObject classStatic.	"the class registry doesn't automatically ensure that JavaLangClass objects corresponding to	primitive types are created with class statics that are JavaPrimitiveStatics (since there's no point	in doing a relatively slow test for every class loaded when there is a fixed, small number of primitive	types which can be handled specially during startup), so we have to make the correction here"	classStatic		changeInstanceClassTo: JavaPrimitiveInstance;		changeStaticClassTo: self.	"and finally we can add it to the class index"	aJVM classIndex addClass: classStatic.</body><body package="JNIPort-Java-Base">registerWithSupplementaryClassloader: aSupplementaryClassloader	"this is called with a SupplementaryClassloader, and gives us the chance	(should we wish to accept it) to register ourself with it as a wrapper class.	NB: this is only called if #shouldRegisterWithSupplementaryClassloader	answers true"	| classStatic |	"we /must/ be known to the main JVM already, so find our class static there"	classStatic := aSupplementaryClassloader jvm findClass: self wrapperJavaClassName.	"and add it to the classloader's class index"	aSupplementaryClassloader classIndex addClass: classStatic.</body></methods><methods><class-id>JNIPort.JavaPrimitiveDoubleStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the double field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getDoubleFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: aFloat	"private -- set the double field defined by JNIFieldID it aJavaObject to aFloat.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^aJavaObject setDoubleFID: aJNIFieldID to: aFloat.</body></methods><methods><class-id>JNIPort.JavaPrimitiveDoubleStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #double.</body></methods><methods><class-id>JNIPort.JavaPrimitiveDoubleStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaDoubleArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Double'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveDoubleStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'D'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveDoubleStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Double'</body></methods><methods><class-id>JNIPort.JavaIteratorAdaptor</class-id> <category>initializing</category><body package="JNIPort-Java-AdditionalWrappers">subject: aJavaClassInstance	"private -- set the object to which we forward the basic Java iteration messages"	subject := aJavaClassInstance.</body></methods><methods><class-id>JNIPort.JavaIteratorAdaptor</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">atEnd	"one of the root methods for &lt;ReadStream&gt;"	^ subject hasNext not.</body><body package="JNIPort-Java-AdditionalWrappers">isReadable	"one of the root methods for &lt;ReadStream&gt;"	^ true.</body><body package="JNIPort-Java-AdditionalWrappers">isWritable	"one of the root methods for &lt;ReadStream&gt;"	^ false.</body></methods><methods><class-id>JNIPort.JavaIteratorAdaptor</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">next	"one of the root methods for &lt;ReadStream&gt;"	^ subject next.</body></methods><methods><class-id>JNIPort.JavaIteratorAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-Java-AdditionalWrappers">for: aJavaClassInstance	"answer a new instance which wraps aJavaClassInstance (which is assumed to be of a class which	implments java.util.Iterator), and makes it act like ReadStream"	^ (self basicNew)		subject: aJavaClassInstance;		yourself.</body></methods><methods><class-id>JNIPort.JNIPortVTableClient</class-id> <category>actions</category><body package="JNIPort-JNI">call: aFunctionSymbol with: anArgument	^self call: aFunctionSymbol withArguments: (Array with: anArgument)</body><body package="JNIPort-JNI">call: aFunctionSymbol with: arg1 with: arg2	^self call: aFunctionSymbol withArguments: (Array with: arg1 with: arg2)</body><body package="JNIPort-JNI">call: aFunctionSymbol with: arg1 with: arg2 with: arg3	^self call: aFunctionSymbol withArguments: (Array with: arg1 with: arg2 with: arg3)</body><body package="JNIPort-JNI">call: aFunctionSymbol with: arg1 with: arg2 with: arg3 with: arg4	^self call: aFunctionSymbol		withArguments: ((Array new: 4)				at: 1 put: arg1;				at: 2 put: arg2;				at: 3 put: arg3;				at: 4 put: arg4;				yourself)</body><body package="JNIPort-JNI">call: aFunctionSymbol with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self call: aFunctionSymbol		withArguments: ((Array new: 5)				at: 1 put: arg1;				at: 2 put: arg2;				at: 3 put: arg3;				at: 4 put: arg4;				at: 5 put: arg5;				yourself)</body><body package="JNIPort-JNI">call: aFunctionSymbol withArguments: anArray	"Call the function named aFuncionSymbol in the receiver's vtable with the arguments stored in anArray. Note that the elements in anArray will be replaced by the result of sending them asJNIParameter. Senders must make sure that anArray isn't reused after executing call:withArguments:."	1 to: anArray size do: [:index | anArray at: index put: (anArray at: index) asJNIParameter].	^(vtable at: aFunctionSymbol) call: anArray</body></methods><methods><class-id>JNIPort.JNIPortVTableClient</class-id> <category>private</category><body package="JNIPort-JNI">functionNames	^self class baseCType baseReferentType memberNames</body><body package="JNIPort-JNI">populateVTable	| typeMapping |	vtable := IdentityDictionary new: self vtableSize.	typeMapping := self typeMapping.	self functionNames do: 			[ :name |			| functionPointer |			functionPointer := self externalData contents memberAt: name.			functionPointer type referentType isProcedure				ifTrue: 					[ | method |					method := JNIVTableMethod cProcedurePointer: functionPointer.					method resultClass: ( typeMapping at: method resultType ifAbsent: [ nil ] ).					vtable at: name put: method ] ]</body><body package="JNIPort-JNI">typeMapping	| interface mapping |	interface := JNIPortJNIInterface current.	mapping := IdentityDictionary new.	mapping		at: interface jboolean put: Boolean;		at: interface jchar put: Character;		at: interface jobject put: JNIObject;		at: interface jclass put: JNIClass;		at: interface jmethodID put: JNIMethodID;		at: interface jfieldID put: JNIFieldID;		at: interface jthrowable put: JNIObject;		at: interface jstring put: JNIObject;		at: interface jweak put: JNIWeakGlobalReference;		at: interface jbooleanArray put: JNIObject;		at: interface jbyteArray put: JNIObject;		at: interface jcharArray put: JNIObject;		at: interface jshortArray put: JNIObject;		at: interface jintArray put: JNIObject;		at: interface jlongArray put: JNIObject;		at: interface jfloatArray put: JNIObject;		at: interface jdoubleArray put: JNIObject;		at: interface jobjectArray put: JNIObject;		at: CPointerType defaultPointer put: JNIPortExternalStructure.	^mapping</body><body package="JNIPort-JNI">vtableSize	^10</body></methods><methods><class-id>JNIPort.JNIPortVTableClient class</class-id> <category>instance creation</category><body package="JNIPort-JNI">on: aCDatum	^(super on: aCDatum)		populateVTable;		yourself</body></methods><methods><class-id>JNIPort.JNIPortJavaVM</class-id> <category>raw JNI functions</category><body package="JNIPort-JNI">AttachCurrentThreadAsDaemon_penv: argument1 threadArgs: argument2	^self		call: #AttachCurrentThreadAsDaemon		with: self		with: argument1		with: argument2</body><body package="JNIPort-JNI">AttachCurrentThread_penv: argument1 threadArgs: argument2	^self		call: #AttachCurrentThread		with: self		with: argument1		with: argument2</body><body package="JNIPort-JNI">DestroyJavaVM	^self call: #DestroyJavaVM with: self</body><body package="JNIPort-JNI">DetachCurrentThread	^self call: #DetachCurrentThread with: self</body><body package="JNIPort-JNI">GetEnv_penv: aJNIEnv version: anInteger	^self		call: #GetEnv		with: self		with: aJNIEnv		with: anInteger</body><body package="JNIPort-JNI">destroy	"invoke the underlying destroy operation, checking for errors"	| return |	return := self DestroyJavaVM.	self checkReturnCode: return.</body><body package="JNIPort-JNI">newJNIEnvVersion: anInteger	"answer a new JNIEnv instance with the given version if that is supported or nil	if not"	| jniEnv return envPointer |	envPointer := JNIPortJNIInterface current JNIEnv pointerType gcCalloc.	return := self GetEnv_penv: envPointer version: anInteger.	"check for version not supported"	return = JNIPortJNIInterface current JNI_EVERSION ifTrue: [^ nil].		self checkReturnCode: return.		jniEnv := JNIPortJNIEnv on: envPointer contents.	jniEnv javaVM: self.	^ jniEnv.</body></methods><methods><class-id>JNIPort.JNIPortJavaVM</class-id> <category>helpers</category><body package="JNIPort-JNI">checkReturnCode: aNumber	"private -- check the return code from a JNI call, and -- if it is not OK -- throw a corresponding JNIError"	JNIPortJNIInterface current checkReturnCode: aNumber</body></methods><methods><class-id>JNIPort.JNIPortJavaVM</class-id> <category>exceptions</category><body package="JNIPort-JNI">errorClass	"private -- answer the class of Exception to use to signal JNI errors"	^ JNIError.</body></methods><methods><class-id>JNIPort.JNIPortJavaVM class</class-id> <category>external accessing</category><body package="JNIPort-JNI">baseCType	^JNIPortJNIInterface current JavaVM</body></methods><methods><class-id>JNIPort.JavaMethodGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">methodName	"answer the 'Class&gt;&gt;selector' style name of the method we are to generate"	^self targetClass name , '&gt;&gt;' , self selector.</body><body package="JNIPort-Java-WrapperGeneration">methodSource	"answer the source to a Smalltalk method provides access to the member (which may be	public or private) we target"	| answer |	output := String new writeStream.	self writeMethodPattern.	generateComment ifTrue: [self writeMethodComment].	self writeMethodBody.	answer := output contents.	output := nil.	"finished with it, nil it to prevent accidents"	^ answer.</body><body package="JNIPort-Java-WrapperGeneration">selector	"answer the selector of the method we are going to generate"	self subclassResponsibility.</body><body package="JNIPort-Java-WrapperGeneration">targetClass	"answer the Smalltalk class we are going to populate"	^ targetClass</body></methods><methods><class-id>JNIPort.JavaMethodGenerator</class-id> <category>testing</category><body package="JNIPort-Java-WrapperGeneration">isConstructor	"answer true iff we are a constuctor method generator"	^ false.</body><body package="JNIPort-Java-WrapperGeneration">isDangerousOverwrite	"answer true iff executing the receiver would cause it to overwrite	an exisiting method that was not marked 'OK to overwrite' by putting it in the	auto generated category"	| category |	category := self targetClass whichCategoryIncludesSelector: self selector.	^category notNil and: [self autoCategoryName ~= category]</body><body package="JNIPort-Java-WrapperGeneration">isGetter	"answer true iff we are a getter method generator"	^ false.</body><body package="JNIPort-Java-WrapperGeneration">isSetter	"answer true iff we are a setter method generator"	^ false.</body><body package="JNIPort-Java-WrapperGeneration">isUnary	"answer whether the generated method will take no arguments"	"this is only acceptable because we never generate binary methods"	^ (self selector includes: $:) not.</body><body package="JNIPort-Java-WrapperGeneration">isWrapper	"answer true iff we are a wrapper method generator"	^ false.</body></methods><methods><class-id>JNIPort.JavaMethodGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">generateMethod	"cause aJavaMethodGenerator to install itself, answers the installed method"	| method methodSource |	self isDangerousOverwrite		ifTrue: 			[Error signal: self methodName						, ' was not generated because the previous version has been removed from the ''auto generated'' category'				with: self].	methodSource := self methodSource.	method := self targetClass compile: methodSource classified: self autoCategoryName.	method isNil		ifTrue: [Error signal: self methodName , ' not generated because it won''t compile' with: self -&gt; methodSource].	^method</body><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	self subclassResponsibility.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"#subclassResponsibility.		"default is just to leave a blank line"	output cr.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodPattern	"private -- write a 'method pattern' (header) to our output stream"	| i |	self isUnary ifTrue:		[output			nextPutAll: self selector;			cr.		^ self].	i := 0.	self selector keywords		do: [:each | output				nextPutAll: each;				nextPutAll: ' arg';				print: (i := i + 1)]		separatedBy: [output space].	output cr.</body></methods><methods><class-id>JNIPort.JavaMethodGenerator</class-id> <category>constants</category><body package="JNIPort-Java-WrapperGeneration">autoCategoryName	"answer the name of the method category used to mark automatically-generated	methods"	^ #'auto generated'.</body><body package="JNIPort-Java-WrapperGeneration">jniObjectString	"answer the String which we use for accessing the underlying JNIObject from a method"	"if we are generating a subclass of JavaClassInstance, then we can access	the instance's jniObject field directly"	^(self targetClass includesBehavior: JavaClassInstance)		ifTrue: ['jniObject']		ifFalse: ['self jniObject'].</body><body package="JNIPort-Java-WrapperGeneration">jvmString	"answer the String which we use for accessing the JVM from a method"	^ 'self jvm'.</body></methods><methods><class-id>JNIPort.JavaMethodGenerator</class-id> <category>printing</category><body package="JNIPort-Java-WrapperGeneration">printOn: aStream	"append a developer-centric description of ourselves to aStream"	super printOn: aStream.	aStream		nextPutAll: ' for: ';		print: self methodName.</body></methods><methods><class-id>JNIPort.JavaMethodGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">targetClass: aClass	"private -- set the Smalltalk class we are going to populate"	targetClass := aClass.	generateComment := true.</body></methods><methods><class-id>JNIPort.JavaMethodGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">generateGhostMethodKeepSource: aBoolean	| method prototype methodSource |	self jniAssert: [self targetClass isGhostClass].	generateComment := aBoolean.	methodSource := self methodSource.	prototype := self prototypeMethodFor: methodSource.	method := GhostMethod newAsCopyOf: prototype in: self targetClass.	aBoolean ifTrue: [method sourceDescriptor: methodSource].	self literalsMap ifNotNil: [:map | method replaceSymbolLiteralsUsing: map].	self targetClass addSelector: self selector withGhostMethod: method.	^method</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	"we don't use a literals map"	^ nil.</body><body package="JNIPort-Java-GhostClasses">prototypeMethodFor: methodSource	^self targetClass compilePrototypeMethod: methodSource</body></methods><methods><class-id>JNIPort.JavaMethodGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">new	"private -- use #targetClass: instead"	^ (super new)		initialize;		yourself.</body><body package="JNIPort-Java-WrapperGeneration">targetClass: aClass	"answer a new instance which will generate code and add it to aClass"	^ (self new)		targetClass: aClass;		yourself.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">computeParameters	"private -- answer a list #(keyword parameterName parameterType) triples for the method"	self subclassResponsibility.</body><body package="JNIPort-Java-WrapperGeneration">computeUnarySelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	self subclassResponsibility.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodPattern	"private -- write a 'method pattern' (header) to our output stream"	self isUnary ifTrue: [output nextPutAll: self selector; cr. ^ self].	self		parametersDo: [:eachKeyword :eachName :eachType | output nextPutAll: eachKeyword; space; nextPutAll: eachName]		separatedBy: [output space].	output cr.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>constants</category><body package="JNIPort-Java-WrapperGeneration">accessFlags	"private -- answer the bit flags, from JavaWrapperConstants, corresponding to the type of this member"	^ reflection isPublic		ifTrue: [JavaWrapperGeneratorSettings wrapAnyPublicMask]		ifFalse: [reflection isProtected			ifTrue: [JavaWrapperGeneratorSettings wrapAnyProtectedMask]			ifFalse: [reflection isPrivate				ifTrue: [JavaWrapperGeneratorSettings wrapAnyPrivateMask]				ifFalse: [JavaWrapperGeneratorSettings wrapAnyDefaultMask]]].</body><body package="JNIPort-Java-WrapperGeneration">wrapperFactoryString	"private -- answer the String which we use for indicating the best object to wrap the returned JNIObject"	^ self jvmString.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">generateLongKeywords	"answer whether we generate long keywords (using the full type name, not just it's last segment)"	^ generateLongKeywords.</body><body package="JNIPort-Java-WrapperGeneration">generateLongKeywords: aBool	"set whether we generate long keywords (using the full type name, not just it's last segment)"	generateLongKeywords = aBool ifTrue: [^ self].	generateLongKeywords := aBool.	"discard any cached info that depends on this setting"	selectorCache := parametersCache := nil.</body><body package="JNIPort-Java-WrapperGeneration">genericTypeName	"answer one of Boolean, Byte, ... Object, Short, or, Void according to our type"	genericTypeNameCache isNil ifTrue: [genericTypeNameCache := self type genericTypeName].	^ genericTypeNameCache.</body><body package="JNIPort-Java-WrapperGeneration">includeTypeInSelector	"answer whether we mention the type of this member in the generated selector"	^ includeTypeInSelector.</body><body package="JNIPort-Java-WrapperGeneration">includeTypeInSelector: aBool	"set whether we mention the type of this member in the generated selector"	includeTypeInSelector = aBool ifTrue: [^ self].	includeTypeInSelector := aBool.	"discard any cached info that depends on this setting"	selectorCache := parametersCache := nil.</body><body package="JNIPort-Java-WrapperGeneration">jniSignature	"answer the JNI signature of the member we will generate method to wrap"	jniSignatureCache isNil ifTrue: [jniSignatureCache := reflection jniSignature].	^ jniSignatureCache.</body><body package="JNIPort-Java-WrapperGeneration">jvm	"answer the JVM instance for which we are generating methods"	^ reflection jvm.</body><body package="JNIPort-Java-WrapperGeneration">name	"answer the name of the target object (which is also our own name)"	^ name.</body><body package="JNIPort-Java-WrapperGeneration">parameter: anInteger	"answer the anInteger-th parameter of the method we will generate.	The answer is a #(keyword name type) triple"	^ self parameters at: anInteger.</body><body package="JNIPort-Java-WrapperGeneration">parameterCount	"answer how many paramers the generated method will take"	^ self parameters size.</body><body package="JNIPort-Java-WrapperGeneration">parameterName: anInteger	"answer the name of anInteger-th parameter of the method we will generate"	^ (self parameter: anInteger) at: 2.</body><body package="JNIPort-Java-WrapperGeneration">parameterType: anInteger	"answer the type of anInteger-th parameter of the method we will generate"	^(self parameters at: anInteger) at: 3</body><body package="JNIPort-Java-WrapperGeneration">parameters	"answer an Array of #(keyword name type) triples for the method that will be generated"	parametersCache isNil ifTrue: [parametersCache := self computeParameters].	^ parametersCache.</body><body package="JNIPort-Java-WrapperGeneration">selector	"answer the selector for the generated method"	selectorCache isNil ifTrue: [selectorCache := self computeSelector asSymbol].	^ selectorCache.</body><body package="JNIPort-Java-WrapperGeneration">type	"answer the Static for the type of our target"	^ reflection type.</body><body package="JNIPort-Java-WrapperGeneration">typeFlags	"private -- answer the bit flags corresponding to the type of this member"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-WrapperGeneration">combineName: expandedName with: typeName	^expandedName , '_' , typeName</body><body package="JNIPort-Java-WrapperGeneration">computeSelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	| str |	self isUnary ifTrue: [^ self computeUnarySelector].	str := String new writeStream.	self parametersDo: [:eachKeyword :eachName :eachType | str nextPutAll: eachKeyword].	^ str contents.</body><body package="JNIPort-Java-WrapperGeneration">expandedName	"private -- answer the base part of the name to use for the method"	| expandedName |	expandedName := self name copyReplacing: $$ withObject: $_.	^includeTypeInSelector		ifTrue: 			[self combineName: expandedName				with: (self type keywordName: generateLongKeywords)]		ifFalse: [expandedName]</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>enumerating</category><body package="JNIPort-Java-WrapperGeneration">parametersDo: a3Block	"private -- evaluate a3Block for each parameter of our method.	The arguments to the block are respectively the keyword, name, and	type of the parameter"	^ self parameters do: [:each | a3Block valueWithArguments: each].</body><body package="JNIPort-Java-WrapperGeneration">parametersDo: a3Block separatedBy: a0Block	"private -- evaluate a1Block for each parameter of our method.	The arguments to the first block are respectively the keyword, name,	and type of the parameter"	^ self parameters		do: [:each | a3Block valueWithArguments: each]		separatedBy: a0Block.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>displaying</category><body package="JNIPort-Java-WrapperGeneration">description	"answer a short String description of the member we wrap"	^ reflection description.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>testing</category><body package="JNIPort-Java-WrapperGeneration">isSelectedBy: aGeneratorSettings	"private -- answer whether we satisfy the criteria defined by aGeneratorSettings"	| mask |	"default is just to filter on access flags"	mask := self accessFlags bitAnd: self typeFlags.	"we want the intersection of the two bitsets"	^ aGeneratorSettings allFlagsSet: mask.</body><body package="JNIPort-Java-WrapperGeneration">isUnary	"answer whether the generated method will take no arguments"	^ self parameterCount = 0.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>printing</category><body package="JNIPort-Java-WrapperGeneration">printOn: aStream	"append a developer-centric description of ourselves to aStream"	super printOn: aStream.	aStream		nextPutAll: ' for: ';		print: reflection.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">initialize	"private -- establish a coherent initial state"	super initialize.	generateLongKeywords := false.	includeTypeInSelector := false.</body><body package="JNIPort-Java-WrapperGeneration">reflection: aJavaReflection	"private -- set the reflection object we will use"	reflection := aJavaReflection.	name := aJavaReflection name.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">convertToSmalltalkString: aString	"answer aString, which is an expression decorated with code to	coerce it into Smalltalk"	^self type conversionToSmalltalkStringFor: aString wrapperFactoryString: self wrapperFactoryString</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (IdentityDictionary new)		at: #JVM put: self jvm;		at: #WrapperFactory put: self type;		yourself.</body></methods><methods><class-id>JNIPort.JavaMemberWrapperGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">for: aJavaReflection targetClass: aClass	"answer a new instance which will generate code to wrap the given Java	reflection object (a java.lang.Class or java.lang.reflect.AccessibleObject)	and add it to aClass"	^ (self targetClass: aClass)		reflection: aJavaReflection;		yourself.</body></methods><methods><class-id>JNIPort.JavaFieldAccessorGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">typeFlags	"private -- answer the bit flags corresponding to the type of this member"	^JavaWrapperGeneratorSettings wrapAnyFieldsMask.</body></methods><methods><class-id>JNIPort.JavaFieldAccessorGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-WrapperGeneration">combineName: expandedName with: typeName	^typeName , '_' , expandedName</body></methods><methods><class-id>JNIPort.JavaFieldAccessorGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">ghostFieldIDString	"answer the String which we use for accessing the fieldID from a ghost class method"	"the resulting literal will be replaced in the CompliledMethod's literal frame by a direct reference to	the appropriate JNIFieldID"	^ '#FieldID'.</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (super literalsMap)		at: #FieldID put: reflection fieldID;		yourself.</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>comparing</category><body package="JNIPort-Java-Base">compare: aJavaObjectOrJNIObject with: anotherJavaObjectOrJNIObject	"private -- compare two Java objects for identity. Needed for the objectRegistry."	^ jvm is: aJavaObjectOrJNIObject identicalTo: anotherJavaObjectOrJNIObject.</body><body package="JNIPort-Java-Base">hashFor: aJavaObjectOrJNIObject 	"private -- answer the hash value to use for a Java object when inserting it in the objectRegistry."	^jvm isLive ifTrue: [jvm identityHash: aJavaObjectOrJNIObject] ifFalse: [1]</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>testing</category><body package="JNIPort-Java-Base">isDead	"answer whether we are associated with a dead JVM"	^ jvm isDead.</body><body package="JNIPort-Java-Base">isEmpty	"answer whether we have no instances registered"	^ self tableSize = 0.</body><body package="JNIPort-Java-Base">isLive	"answer whether we are associated with a live JVM"	^ jvm isLive.</body><body package="JNIPort-Java-Base">notEmpty	"answer whether we have any instances registered"	^ self tableSize &gt; 0.</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>helpers</category><body package="JNIPort-Java-Base">makeRegistry: aCapacity	"private -- answer a new registry table of the stated capacity"	^(self class registryContainerClass new: aCapacity)		hashBlock: [:object | self hashFor: object];		equalBlock: [:object1 :object2 | self compare: object1 with: object2];		yourself</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>accessing</category><body package="JNIPort-Java-Base">basicFindOrRelease: aJNIObject ifAbsent: a0Block	"private -- look for an entry in the registry that refers to the same Java object as	aJNIObject, if one exists then release aJNIObject and answer the incumbent.	Otherwise answer the result of evaluating a0Block.  This is the guts of the	implementation of #findOrRelease:ifAbsent:"	| previous |	previous := registry findElement: aJNIObject ifAbsent: [nil].	previous isNil		ifTrue: [previous := a0Block value]		ifFalse: [aJNIObject releaseRef: jvm jniEnv].	^ previous.</body><body package="JNIPort-Java-Base">basicFindOrRelease: aJNIObject ifAbsentPut: a0Block	"private -- look for an entry in the registry that refers to the same Java object as	aJNIObject, if one exists then release aJNIObject and answer the incumbent.	Otherwise add and answer the result of evaluating a0Block.  This is the guts of the	implementation of #findOrRelease:ifAbsentPut:"	| previous |	previous := registry findElement: aJNIObject ifAbsent: [nil].	previous isNil		ifTrue: [registry add: (previous := a0Block value)]		ifFalse: [aJNIObject releaseRef: jvm jniEnv].	^ previous.</body><body package="JNIPort-Java-Base">contents	"answer an OrderedCollection with the same contents as our collection"	^ sharedMutex critical: [OrderedCollection withAll: registry].</body><body package="JNIPort-Java-Base">findOrRelease: aJNIObject ifAbsent: a0Block	"look for an entry in the registry that refers to the same Java object as	aJNIObject, if one exists then release aJNIObject and answer the incumbent.	Otherwise answer the result of evaluating a0Block.  Note that the whole	method is executed under our shared mutex, and so is atomic"	^ sharedMutex critical: [self basicFindOrRelease: aJNIObject ifAbsent: a0Block].</body><body package="JNIPort-Java-Base">findOrRelease: aJNIObject ifAbsentPut: a0Block	"look for an entry in the registry that refers to the same Java object as	aJNIObject, if one exists then release aJNIObject and answer the incumbent.	Otherwise add and answer the result of evaluating a0Block.  Note that the whole	method is executed under our shared mutex, and so is atomic"	^ sharedMutex critical: [self basicFindOrRelease: aJNIObject ifAbsentPut: a0Block].</body><body package="JNIPort-Java-Base">tableSize	"answer how many classes have been registered"	^ sharedMutex critical: [registry size].</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initialize: aCapacity	"private -- establish a coherent initial state"	registry := self makeRegistry: aCapacity.</body><body package="JNIPort-Java-Base">jvm: aJVM	"private -- set the JVM and shared Mutex we will use.	We pick up the mutex from the JVM in order to avoid deadlocks"	jvm := aJVM.	sharedMutex := aJVM sharedMutex.</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>removing</category><body package="JNIPort-Java-Base">purge: aJavaObject	"ensure that the given object is no longer in the registry"	sharedMutex critical: [registry remove: aJavaObject ifAbsent: []].</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>searching</category><body package="JNIPort-Java-Base">includes: aJavaObject	"answer whether the registry includes aJavaObject"	^ sharedMutex critical: [registry includes: aJavaObject].</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>measuring</category><body package="JNIPort-Java-Base">tableLoad	"answer the &lt;Float&gt; percentage load on the registry"	^ sharedMutex critical: [registry size * 100.0 / registry basicSize].</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">select: a1Block	"answer a collection of the entries that satisfy the given condition"	^ self contents select: a1Block.</body></methods><methods><class-id>JNIPort.JavaObjectRegistry</class-id> <category>adding</category><body package="JNIPort-Java-Base">add: aJavaObject	"add a java object to the registry, replacing the existing incumbent, if any"	sharedMutex critical: [registry					remove: aJavaObject ifAbsent: [];					add: aJavaObject].</body></methods><methods><class-id>JNIPort.JavaObjectRegistry class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"private -- use #newWithJVM:mutex:"	^self new: self defaultCapacity</body><body package="JNIPort-Java-Base">new: aCapacity	"private -- use #new:withJVM:mutex"	^ (self basicNew)		initialize: aCapacity;		yourself.</body><body package="JNIPort-Java-Base">new: aCapacity withJVM: aJVM	"answer a new instance which uses aJVM to determine object hashes, etc"	^ (self new: aCapacity)		jvm: aJVM;		yourself.</body><body package="JNIPort-Java-Base">newWithJVM: aJVM	"answer a new instance which uses aJVM to determine object hashes, etc"	^ (self new)		jvm: aJVM;		yourself.</body></methods><methods><class-id>JNIPort.JavaObjectRegistry class</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultCapacity	"private -- answer the default capacity to use for instances"	^ 10.</body><body package="JNIPort-Java-Base">registryContainerClass	"private -- answer the kind of container used to hold elements"	^PluggableThreadSafeWeakSet</body></methods><methods><class-id>JNIPort.JavaLangThrowable</class-id> <category>signalling</category><body package="JNIPort-Java-Base">signal	"cause ourself to be thrown as an exception within Smalltalk.	If this is invoked from within a callback, and is not caught within	the callback, then this exception object will be thrown in the Java	space"	JavaException		signal: 'Uncaught Java exception'		with: self.</body></methods><methods><class-id>JNIPort.JavaLangThrowable</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">fillInStackTrace	"answer the result of calling the receiver's public synchronized native fillInStackTrace() Java method"	^ self callObjectMethod: 'fillInStackTrace' signature: '()Ljava/lang/Throwable;'.</body><body package="JNIPort-Java-Base">getCause	"answer the result of calling the receiver's public getCause() Java method"	^ self callObjectMethod: 'getCause' signature: '()Ljava/lang/Throwable;'.</body><body package="JNIPort-Java-Base">getLocalizedMessage	"answer the result of calling the receiver's public getLocalizedMessage() Java method"	^ self callObjectMethod: 'getLocalizedMessage' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">getMessage	"answer the result of calling the receiver's public getMessage() Java method"	^ self callObjectMethod: 'getMessage' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">getStackTrace	"answer the result of calling the receiver's public getStackTrace() Java method"	^ self callObjectMethod: 'getStackTrace' signature: '()[Ljava/lang/StackTraceElement;'.</body><body package="JNIPort-Java-Base">initCause_Throwable: aThrowable1	"answer the result of calling the receiver's public synchronized initCause(java.lang.Throwable) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aThrowable1.			self				callObjectMethod: 'initCause'				signature: '(Ljava/lang/Throwable;)Ljava/lang/Throwable;'				withArguments: args]</body><body package="JNIPort-Java-Base">printStackTrace	"invoke the receiver's public printStackTrace() Java method"	self callVoidMethod: 'printStackTrace'.</body><body package="JNIPort-Java-Base">printStackTrace_PrintStream: aPrintStream1	"invoke the receiver's public printStackTrace(java.io.PrintStream) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aPrintStream1.			self				callVoidMethod: 'printStackTrace'				signature: '(Ljava/io/PrintStream;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">printStackTrace_PrintWriter: aPrintWriter1	"invoke the receiver's public printStackTrace(java.io.PrintWriter) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aPrintWriter1.			self				callVoidMethod: 'printStackTrace'				signature: '(Ljava/io/PrintWriter;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setStackTrace_StackTraceElementArray: aStackTraceElements1	"invoke the receiver's public setStackTrace(java.lang.StackTraceElement[]) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aStackTraceElements1.			self				callVoidMethod: 'setStackTrace'				signature: '([Ljava/lang/StackTraceElement;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangThrowable</class-id> <category>accessing</category><body package="JNIPort-Java-Base">cause	"answer the 'cause' (another exception -- see the Java doc) associated with this exception"	^ self getCause.</body><body package="JNIPort-Java-Base">message	"answer the String associated with this exception"	^ self getMessage asString.</body><body package="JNIPort-Java-Base">stackTrace	"answer the result of invoking the Java getStackTrace() method as a Smalltalk collection"	^ self getStackTrace asCollection.</body></methods><methods><class-id>JNIPort.JavaLangThrowable class</class-id> <category>exception filtering</category><body package="JNIPort-Java-Base">, anExceptionFilter	"answer a new ExceptionSet containing the receiver and anExceptionFilter (typically a Class	under Exception"	^(ExceptionSet new)		add: self;		add: anExceptionFilter;		yourself</body><body package="JNIPort-Java-Base">handles: anException 	"answer whether the receiver matches anException.	This is provided so that instances of JavaException can be caught	with exception on: blocks using this class or its subclasses"	^(JavaException handles: anException) 		and: [anException parameter isKindOf: self]</body></methods><methods><class-id>JNIPort.JavaLangThrowable class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#fillInStackTrace		#getCause		#getLocalizedMessage		#getMessage		#getStackTrace		#initCause_Throwable:		#printStackTrace		#printStackTrace_PrintStream:		#printStackTrace_PrintWriter:		#setStackTrace_StackTraceElementArray:		#toString	).</body></methods><methods><class-id>JNIPort.JavaLangThrowable class</class-id> <category>testing</category><body package="JNIPort-Java-Base">isExceptionHandler	"Answer if the receiver responds to the #handles: message	 as required by the exception-handling machinery."	^true</body></methods><methods><class-id>JNIPort.JavaLangThrowable class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.Throwable'.</body></methods><methods><class-id>JNIPort.JavaLangError class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.Error'.</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem</class-id> <category>accessing</category><body package="JNIPort-Java-Base">currentTimeMillis	"answer the result of calling the receiver's public static native currentTimeMillis() Java method"	^self callLongMethod: 'currentTimeMillis'</body><body package="JNIPort-Java-Base">err	"answer the java.lang.System.err object"	^ self get_err.</body><body package="JNIPort-Java-Base">err: aJavaObject	"call java.lang.System.setErr()"	self setErr_PrintStream: aJavaObject.</body><body package="JNIPort-Java-Base">in	"answer the java.lang.System.in object"	^ self get_in.</body><body package="JNIPort-Java-Base">out	"answer the java.lang.System.out object"	^ self get_out.</body><body package="JNIPort-Java-Base">out: aJavaObject	"call java.lang.System.setOut()"	self setOut_PrintStream: aJavaObject</body><body package="JNIPort-Java-Base">properties	"answer the result of calling java.lang.System.getProperties()"	^ self getProperties.</body><body package="JNIPort-Java-Base">properties: aJavaObject	"call java.lang.System.setProperties()"	self setProperties_Properties: aJavaObject.</body><body package="JNIPort-Java-Base">propertyAt: aJavaString	"answer the result of calling java.lang.System.getProperty(String)"	^ self getProperty_String: aJavaString.</body><body package="JNIPort-Java-Base">propertyAt: aJavaString put: anotherJavaString	"answer the result of calliing java.lang.System.setProperty(String, String)"	^ self setProperty_String: aJavaString String: anotherJavaString</body><body package="JNIPort-Java-Base">securityManager	"answer the result of calling java.lang.System.securityManager()"	^ self getSecurityManager.</body><body package="JNIPort-Java-Base">securityManager: aJavaObject	"call java.lang.System.setSecurityManager()"	self setSecurityManager_SecurityManager: aJavaObject.</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">arraycopy_Object: anObject1 int: int1 Object: anObject2 int: int2 int: int3	"invoke the receiver's public static native arraycopy(java.lang.Object, int, java.lang.Object, int, int) Java method"	JNIValueArray new: 5		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				intAt: 2 put: int1;				objectAt: 3 put: anObject2;				intAt: 4 put: int2;				intAt: 5 put: int3.			self				callVoidMethod: 'arraycopy'				signature: '(Ljava/lang/Object;ILjava/lang/Object;II)V'				withArguments: args]</body><body package="JNIPort-Java-Base">exit_int: int1	"invoke the receiver's public static exit(int) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callVoidMethod: 'exit' signature: '(I)V' withArguments: args]</body><body package="JNIPort-Java-Base">gc	"invoke the receiver's public static gc() Java method"	self callVoidMethod: 'gc'.</body><body package="JNIPort-Java-Base">getProperties	"answer the result of calling the receiver's public static getProperties() Java method"	^ self callObjectMethod: 'getProperties' signature: '()Ljava/util/Properties;'.</body><body package="JNIPort-Java-Base">getProperty_String: aString1	"answer the result of calling the receiver's public static getProperty(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getProperty'				signature: '(Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">getProperty_String: aString1 String: aString2	"answer the result of calling the receiver's public static getProperty(java.lang.String, java.lang.String) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 javaString2 |			javaString1 := aString1 asJavaString: self jvm.			javaString2 := aString2 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: javaString2.			self				callObjectMethod: 'getProperty'				signature: '(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">getSecurityManager	"answer the result of calling the receiver's public static getSecurityManager() Java method"	^ self callObjectMethod: 'getSecurityManager' signature: '()Ljava/lang/SecurityManager;'.</body><body package="JNIPort-Java-Base">getenv_String: aString1	"answer the result of calling the receiver's public static getenv(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getenv'				signature: '(Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">identityHashCode_Object: anObject1	"answer the result of calling the receiver's public static native identityHashCode(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callIntMethod: 'identityHashCode'				signature: '(Ljava/lang/Object;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">in: aJavaObject	"call java.lang.System.setIn()"	self setIn_InputStream: aJavaObject.</body><body package="JNIPort-Java-Base">loadLibrary_String: aString1	"invoke the receiver's public static loadLibrary(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'loadLibrary'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">load_String: aString1	"invoke the receiver's public static load(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'load'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">mapLibraryName_String: aString1	"answer the result of calling the receiver's public static native mapLibraryName(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'mapLibraryName'				signature: '(Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">runFinalization	"invoke the receiver's public static runFinalization() Java method"	self callVoidMethod: 'runFinalization'.</body><body package="JNIPort-Java-Base">runFinalizersOnExit_boolean: boolean1	"invoke the receiver's public static runFinalizersOnExit(boolean) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args booleanAt: 1 put: boolean1.			self				callVoidMethod: 'runFinalizersOnExit'				signature: '(Z)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setErr_PrintStream: aPrintStream1	"invoke the receiver's public static setErr(java.io.PrintStream) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aPrintStream1.			self				callVoidMethod: 'setErr'				signature: '(Ljava/io/PrintStream;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setIn_InputStream: anInputStream1	"invoke the receiver's public static setIn(java.io.InputStream) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anInputStream1.			self				callVoidMethod: 'setIn'				signature: '(Ljava/io/InputStream;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setOut_PrintStream: aPrintStream1	"invoke the receiver's public static setOut(java.io.PrintStream) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aPrintStream1.			self				callVoidMethod: 'setOut'				signature: '(Ljava/io/PrintStream;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setProperties_Properties: aProperties1	"invoke the receiver's public static setProperties(java.util.Properties) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aProperties1.			self				callVoidMethod: 'setProperties'				signature: '(Ljava/util/Properties;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setProperty_String: aString1 String: aString2	"answer the result of calling the receiver's public static setProperty(java.lang.String, java.lang.String) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 javaString2 |			javaString1 := aString1 asJavaString: self jvm.			javaString2 := aString2 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: javaString2.			self				callObjectMethod: 'setProperty'				signature: '(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">setSecurityManager_SecurityManager: aSecurityManager1	"invoke the receiver's public static setSecurityManager(java.lang.SecurityManager) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aSecurityManager1.			self				callVoidMethod: 'setSecurityManager'				signature: '(Ljava/lang/SecurityManager;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem</class-id> <category>operations</category><body package="JNIPort-Java-Base">exit: anInteger	"call java.lang.System.exit()."	self exit_int: anInteger.</body><body package="JNIPort-Java-Base">load: aString	"call java.lang.System.load()"	self load_String: aString.</body><body package="JNIPort-Java-Base">loadLibrary: aString	"call java.lang.System.loadLibrary()"	self loadLibrary_String: aString.</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">clearProperty_String: aString1	"answer the result of calling the receiver's public static clearProperty(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'clearProperty'				signature: '(Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">console	"answer the result of calling the receiver's public static console() Java method"	^ self callObjectMethod: 'console' signature: '()Ljava/io/Console;'.</body><body package="JNIPort-Java-Base">getenv	"answer the result of calling the receiver's public static getenv() Java method"	^ self callObjectMethod: 'getenv' signature: '()Ljava/util/Map;'.</body><body package="JNIPort-Java-Base">inheritedChannel	"answer the result of calling the receiver's public static inheritedChannel() Java method"	^ self callObjectMethod: 'inheritedChannel' signature: '()Ljava/nio/channels/Channel;'.</body><body package="JNIPort-Java-Base">nanoTime	"answer the result of calling the receiver's public static native nanoTime() Java method"	^ self callLongMethod: 'nanoTime'.</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem</class-id> <category>Java-static</category><body package="JNIPort-Java-Base">get_err	"answer the value of the receiver's public static final err Java field"	^ self getObjectField: 'err' signature: 'Ljava/io/PrintStream;'.</body><body package="JNIPort-Java-Base">get_in	"answer the value of the receiver's public static final in Java field"	^ self getObjectField: 'in' signature: 'Ljava/io/InputStream;'.</body><body package="JNIPort-Java-Base">get_out	"answer the value of the receiver's public static final out Java field"	^ self getObjectField: 'out' signature: 'Ljava/io/PrintStream;'.</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem</class-id> <category>helpers</category><body package="JNIPort-Java-Base">identityHashCode: aJavaObject	"answer the result of calling java.lang.System.identityHashCode()"	^ self identityHashCode_Object: aJavaObject</body><body package="JNIPort-Java-Base">mapLibraryName: aString	"answer the result of calling java.lang.System.mapLibraryName()"	^ self mapLibraryName_String: aString.</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_err		#get_in		#get_out	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#arraycopy_Object:int:Object:int:int:		#clearProperty_String:		#console		#currentTimeMillis		#exit_int:		#gc		#getenv		#getenv_String:		#getProperties		#getProperty_String:		#getProperty_String:String:		#getSecurityManager		#identityHashCode_Object:		#inheritedChannel		#loadLibrary_String:		#load_String:		#mapLibraryName_String:		#nanoTime		#runFinalization		#runFinalizersOnExit_boolean:		#setErr_PrintStream:		#setIn_InputStream:		#setOut_PrintStream:		#setProperties_Properties:		#setProperty_String:String:		#setSecurityManager_SecurityManager:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangSystem class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.System'.</body></methods><methods><class-id>JNIPort.JavaLangClassLoader</class-id> <category>purging</category><body package="JNIPort-Java-Base">dependentClasses	"private -- answer a collection of the *known* dependent classes"	^ self classRegistry allClasses select: [:each | each classloader = self].</body><body package="JNIPort-Java-Base">dependentClassloaders	"private -- answer a collection of the *known* dependent classloaders"	^ self static canonicalInstances select: [:each | each parentClassloader = self].</body><body package="JNIPort-Java-Base">purge	"purge this classloader; remove any classes from the main class registries that are owned	by this classloader.	The idea is that we remove all refernces to this classloader from JNIPort, and so it can be reclaimed	(and its classes unloaded) by the Java GC.	NB: it is the caller's responsibility to ensure that any relevant callbacks have been cleared first"	"remove dependent classes and classloaders -- the loop is because tracking down	dependencies may cause new clasees or loaders to be registered"	[self purgeDependents &gt; 0] whileTrue.	"remove ourself from the canonical list"	self beNotCanonical.	"we might as well discard our class index"	self sharedMutex critical: [classIndex := nil].	"and lastly relase our own reference"	self free.</body><body package="JNIPort-Java-Base">purgeDependentClasses	"private -- purge any classes from the class registry and index that are owned	by this classloader.	Answer how many were removed"	| dependents |	dependents := self dependentClasses.	dependents do: [:each | each purge].	^ dependents size.</body><body package="JNIPort-Java-Base">purgeDependentClassloaders	"private -- purge any classloader from the canonical list that are dependent on	this classloader.	Answer how many were removed"	| dependents |	dependents := self dependentClassloaders.	dependents do: [:each | each purge].	^ dependents size.</body><body package="JNIPort-Java-Base">purgeDependents	"private -- purge any classes from the class registry and index that are owned	by this classloader.	Answer how many were removed"	"NB: the order is important here -- we must purge the classloaders	first since they may themselves of a class that is dependent on this	classloader, and hence which is just about to be discarded"	^ self purgeDependentClassloaders + self purgeDependentClasses.</body></methods><methods><class-id>JNIPort.JavaLangClassLoader</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">clearAssertionStatus	"invoke the receiver's public synchronized clearAssertionStatus() Java method"	self callVoidMethod: 'clearAssertionStatus'.</body><body package="JNIPort-Java-Base">getParent	"answer the result of calling the receiver's public final getParent() Java method"	^ self callObjectMethod: 'getParent' signature: '()Ljava/lang/ClassLoader;'.</body><body package="JNIPort-Java-Base">getResourceAsStream_String: aString1	"answer the result of calling the receiver's public getResourceAsStream(java.lang.String) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args objectAt: 1 put: javaString1.			self				callObjectMethod: 'getResourceAsStream'				signature: '(Ljava/lang/String;)Ljava/io/InputStream;'				withArguments: args]</body><body package="JNIPort-Java-Base">getResource_String: aString1	"answer the result of calling the receiver's public getResource(java.lang.String) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args objectAt: 1 put: javaString1.			self				callObjectMethod: 'getResource'				signature: '(Ljava/lang/String;)Ljava/net/URL;'				withArguments: args]</body><body package="JNIPort-Java-Base">getResources_String: aString1	"answer the result of calling the receiver's public getResources(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getResources'				signature: '(Ljava/lang/String;)Ljava/util/Enumeration;'				withArguments: args]</body><body package="JNIPort-Java-Base">loadClass_String: aString1	"answer the result of calling the receiver's public loadClass(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'loadClass'				signature: '(Ljava/lang/String;)Ljava/lang/Class;'				withArguments: args]</body><body package="JNIPort-Java-Base">setClassAssertionStatus_String: aString1 boolean: boolean1	"invoke the receiver's public synchronized setClassAssertionStatus(java.lang.String, boolean) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				booleanAt: 2 put: boolean1.			self				callVoidMethod: 'setClassAssertionStatus'				signature: '(Ljava/lang/String;Z)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setDefaultAssertionStatus_boolean: boolean1	"invoke the receiver's public synchronized setDefaultAssertionStatus(boolean) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args booleanAt: 1 put: boolean1.			self				callVoidMethod: 'setDefaultAssertionStatus'				signature: '(Z)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setPackageAssertionStatus_String: aString1 boolean: boolean1	"invoke the receiver's public synchronized setPackageAssertionStatus(java.lang.String, boolean) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				booleanAt: 2 put: boolean1.			self				callVoidMethod: 'setPackageAssertionStatus'				signature: '(Ljava/lang/String;Z)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangClassLoader</class-id> <category>accessing</category><body package="JNIPort-Java-Base">classIndex	"answer the class index that we use to cache class lookups in	our role as a &lt;javaClassFinder&gt;"	^ self sharedMutex critical:		[classIndex ifNil: [classIndex := JavaClassIndex newFor: self]].</body><body package="JNIPort-Java-Base">classloader	"answer the actual JavaLangClassLoader used by this &lt;javaClassFinder&gt;"	"we are that classloader"	^ self.</body><body package="JNIPort-Java-Base">parentClassloader	"answer the parent classloader -- that is to say, the one that the	.java.lang.Classloader instace we correspond to condsiders to be	its parent (and hence will delagate to).	May be nil"	^ self getParent.</body></methods><methods><class-id>JNIPort.JavaLangClassLoader</class-id> <category>Java classes</category><body package="JNIPort-Java-Base">defineClass: aString fromBytes: aByteArray	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	Answers a Class Static corresponding to the newly defined class.	The class will 'know' that it was loaded by this classloader.	Will throw an error if the class definition does not define a class named by	aString (which can be in JNI or Java format)."	^ self jvm defineClass: aString fromBytes: aByteArray classloader: self.</body><body package="JNIPort-Java-Base">defineClassFromBytes: aByteArray	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	Answers a Class Static corresponding to the newly defined class.	The class will 'know' that it was loaded by this classloader"	^ self jvm defineClassFromBytes: aByteArray classloader: self.</body><body package="JNIPort-Java-Base">findClass: aStringOrSymbol	"answer a JavaStatic object corresponding to aString, it will be loaded	and/or looked up via this class loader.	NB: the argument should be a *Smalltalk* string"	"this will bounce back to our own #findClassObject: if the index doesn't have it already"	^ self classIndex findClass: aStringOrSymbol.</body><body package="JNIPort-Java-Base">findClassObject: aJNIClassName	"answer JavaLangClass object corresponding to aJNIClassName -- the name will be looked up in the	normal Java way startng at our Java classloader, but delagating /first/ to its parent	classloader and the system classloaders"	"NB1: loadClass(String) doesn't work for array classes (unless they have already	been loaded by a different route).  It's not clear whether it's safe to use that	interface for non-array classes, but I prefer not to take the risk.  So instead we	use 		java.lang.Class.forName(String, boolean, ClassLoader)	"	"NB2: since classloaders don't use normal Java class names, /nor/ do they	use JNI format names, we choose to accept JNI names as our parameter	and hack it into acceptable shape here"	| hackedName |	"this hack works for both array and non-array classes and with either	ClassLoader.loadClass() or Class.forName().	The expected format is to use normal Java class names (remembering that nested	classes have names with $ in them, not dots as they appear in the Java source),	but uses JNI format, but with dots instead of slashes, to mark array classes.	Makes it slow, and its kinda 	kludgy, but that's Java for you..."	hackedName := aJNIClassName copyReplacing: $/ withObject: $..	^ self classRegistry javaLangClass 			forName_String: hackedName			boolean: false			ClassLoader: self.	"	^ self loadClass_String: hackedName.	"</body></methods><methods><class-id>JNIPort.JavaLangClassLoader</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization."	super actAsExecutor.	classIndex := nil</body></methods><methods><class-id>JNIPort.JavaLangClassLoader class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#clearAssertionStatus		#getParent		#getResource_String:		#getResourceAsStream_String:		#getResources_String:		#loadClass_String:		#setClassAssertionStatus_String:boolean:		#setDefaultAssertionStatus_boolean:		#setPackageAssertionStatus_String:boolean:	).</body></methods><methods><class-id>JNIPort.JavaLangClassLoader class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.ClassLoader'.</body></methods><methods><class-id>JNIPort.JavaNetURLClassLoader</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">findResource_String: aString1	"answer the result of calling the receiver's public findResource(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'findResource'				signature: '(Ljava/lang/String;)Ljava/net/URL;'				withArguments: args]</body><body package="JNIPort-Java-Base">findResources_String: aString1	"answer the result of calling the receiver's public findResources(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'findResources'				signature: '(Ljava/lang/String;)Ljava/util/Enumeration;'				withArguments: args]</body><body package="JNIPort-Java-Base">getURLs	"answer the result of calling the receiver's public getURLs() Java method"	^ self callObjectMethod: 'getURLs' signature: '()[Ljava/net/URL;'.</body></methods><methods><class-id>JNIPort.JavaNetURLClassLoader class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#findResource_String:		#findResources_String:		#getURLs	).</body></methods><methods><class-id>JNIPort.JavaNetURLClassLoader class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.net.URLClassLoader'.</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>accessing</category><body package="JNIPort-Java-Base">classFinder	"answer the &lt;javaClassFinder&gt; which which we are associated, and	for which we act as a lookup cache"	^ classFinder.</body><body package="JNIPort-Java-Base">javaLangClass	"answer the JavaStatic corresponding to java.lang.Class"	"the class registry knows about this anyway, so let it do the work"	^ classFinder classRegistry javaLangClass.</body><body package="JNIPort-Java-Base">javaLangString	"answer the JavaStatic corresponding to java.lang.String"	"the class registry knows about this anyway, so let it do the work"	^ classFinder classRegistry javaLangString.</body><body package="JNIPort-Java-Base">jvm	"answer the JVM which, ultimately, owns us"	^ classFinder jvm.</body><body package="JNIPort-Java-Base">names	"answer an OrderedCollection of all the names in the index"	^ sharedMutex critical: [index keys asOrderedCollection].</body><body package="JNIPort-Java-Base">tableSize	"answer how many class names have been indexed"	^ sharedMutex critical: [index size].</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>initializing</category><body package="JNIPort-Java-Base">classFinder: aClassFinder	"private -- set the &lt;javaClassFinder&gt; we will use"	sharedMutex := aClassFinder sharedMutex.	classFinder := aClassFinder.</body><body package="JNIPort-Java-Base">initialize: aCapacity	"private -- establish a coherent initial state"	index := self makeIndex: aCapacity.</body><body package="JNIPort-Java-Base">jvm: aJVM	"private -- set the JVM we will use"	classFinder := aJVM.</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>adding</category><body package="JNIPort-Java-Base">addClass: aClassStatic	"add aClassStatic to our index, note that the name used	will be the class static's own idea of its name"	| name |	name := aClassStatic name asSymbol.	sharedMutex critical: [index at: name put: aClassStatic].</body><body package="JNIPort-Java-Base">findClass: aClassName	"answer a JavaStatic object corresponding to aClassName or throw a Java	ClassNotFound exception if no such class can be loaded.	This looks in the index first (if necessary converting aClassName to a Symbol), and	only if the name is not found there does it go back to the class finder to lookup the name	(converting it to a JNI class name if necessary).  Once discovered it'll be entered	into the index under the orginal name (as a Symbol).	This interface is only suitable for finding classes with no explicit class loader, and so	there can only be one class found *through this interface* with any given name"	| symbol classStatic |	"NB: we've got to be a bit careful with the logic here, since we don't want ClassNotFound	exceptions to be thrown while we've got either mutex locked"	"see if we've already got it indexed"	symbol := aClassName asSymbol.	classStatic := sharedMutex critical: [index at: symbol ifAbsent: [nil]].	classStatic notNil ifTrue: [^classStatic].	"no, have to go back to the class finder for it"	classStatic := (classFinder findClassObject: aClassName asJNIClassName) classStatic.	"OK, the class is now known, and must be in the registry.  We now add it to the index;	since we've been running outside the index mutex, it is quite possible (albeit unlikely)	that someone's already added it, but if so then we'll just overwrite the existing record	with the same data"	sharedMutex critical: [index at: symbol put: classStatic].	^ classStatic.</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>measuring</category><body package="JNIPort-Java-Base">tableLoad	"answer the &lt;Float&gt; percentage load on the index table"	^ sharedMutex critical: [index size * 100.0 / index basicSize].</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>removing</category><body package="JNIPort-Java-Base">purge: aJavaStatic	"private -- do *NOT* call this!"	sharedMutex critical: 			[| keys |			keys := index keys select: [:each | (index at: each) == aJavaStatic].			keys do: [:k | index removeKey: k]]</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>operations</category><body package="JNIPort-Java-Base">shutdown	"private -- called by our owning JVM when it shuts down"	sharedMutex critical: [index := self makeIndex: 0].</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>helpers</category><body package="JNIPort-Java-Base">makeIndex: aCapacity	"private -- answer a new index table of the stated capacity"	^ IdentityDictionary new: aCapacity.</body></methods><methods><class-id>JNIPort.JavaClassIndex</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">namesAndClassesDo: a2Block	"evaluate a2Block for each object in the index"	^ sharedMutex critical: [index keysAndValuesDo: a2Block].</body></methods><methods><class-id>JNIPort.JavaClassIndex class</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultCapacity	"private -- answer the default capacity to use for instances"	^50</body></methods><methods><class-id>JNIPort.JavaClassIndex class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"private -- use #newFor:"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">new: aCapacity for: aClassFinder	"answer a new instance which uses aClassFinder to find previously unknown classes,	and which has the given initial capacity"	^ (self basicNew)		initialize: aCapacity;		classFinder: aClassFinder;		yourself.</body><body package="JNIPort-Java-Base">newFor: aClassFinder	"answer a new instance which uses aJVM to find previously unknown classes"	^ self new: self defaultCapacity for: aClassFinder.</body></methods><methods><class-id>JNIPort.JavaInterfaceInstance</class-id> <category>Java field access</category><body package="JNIPort-Java-Base">findField: aStringName signature: aJNISignature	"answer the JavaFieldID corresponding to our Java object's field named aStringName,	with signature defined by aJNISignature"	"Java interfaces can't have non-static fields"	self shouldNotImplement.</body></methods><methods><class-id>JNIPort.JavaInterfaceInstance</class-id> <category>initializing</category><body package="JNIPort-Java-Base">subject: aJavaClassInstance	"private -- set the subject JavaClassInstance we wrap"	subject := aJavaClassInstance.</body></methods><methods><class-id>JNIPort.JavaInterfaceInstance</class-id> <category>Java method calls</category><body package="JNIPort-Java-Base">callBooleanMID: aMethodID withArguments: aJNIValueArray 	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv 		CallBooleanMethodA_obj: self jniObject		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callByteMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallByteMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callCharMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	| answer |	answer := self jniEnv			CallCharMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].	^answer asCharacter</body><body package="JNIPort-Java-Base">callDoubleMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv			CallDoubleMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callFloatMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallFloatMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callIntMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallIntMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callLongMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallLongMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID withArguments: aJNIValueArray wrapperFactory: aJVMOrJavaStatic	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	| answer |	answer := self jniEnv			CallObjectMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].	^ aJVMOrJavaStatic wrapJNIObject: answer.</body><body package="JNIPort-Java-Base">callShortMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^ self jniEnv			CallShortMethodA_obj: self jniObject			methodID: aMethodID			args: aJNIValueArray			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">callVoidMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self jniEnv		CallVoidMethodA_obj: self jniObject		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">findMethod: aStringName signature: aJNISignature 	"answer the JavaMethodID corresponding to our Java object's method named aStringName,	and signature defined by aJNISignature"	| classObject |	classObject := self javaClassObject.	^classObject 		methodIDFor: aStringName		signature: aJNISignature		ifAbsentPut: 			[self jniEnv 				GetMethodID_class: classObject				name: aStringName				sig: aJNISignature				onException: [:ex | self jvm throwJavaException: ex]]</body></methods><methods><class-id>JNIPort.JavaInterfaceInstance</class-id> <category>accessing</category><body package="JNIPort-Java-Base">managedInstance	"answer the managed object (a JavaClassInstance) which really owns the javaObject we wrap"	^ subject.</body></methods><methods><class-id>JNIPort.JavaInterfaceInstance class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">jniObject: aJNIObject static: aJavaStatic	"private -- overridden since the only time this should ever be called is if the system is	totally buggered"	^ self shouldNotImplement.</body><body package="JNIPort-Java-Base">new	"private -- these should only be created by sending #as: to an existing JavaInstance"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">wrap: aJavaInstance asStatic: aJavaStatic	"answer a new instance which wraps the same underlying object as aJavaInstance but which treats	it as belonging to the given Java class.  The point is that the class is typically an interface and so it would	never normally have any instances"	^ (self basicNew)		initialize;		subject: aJavaInstance;		static: aJavaStatic;		yourself.</body></methods><methods><class-id>JNIPort.JavaExternalIterator</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">atEnd	"part of the normal &lt;ReadStream&gt; protocol"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaExternalIterator</class-id> <category>streaming</category><body package="JNIPort-Java-AdditionalWrappers">next	"part of the normal &lt;ReadStream&gt; protocol"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaExternalIterator</class-id> <category>converting</category><body package="JNIPort-Java-AdditionalWrappers">asReadStream	"answer an adaptor which makes this Java aggregate object look like something from the Smalltalk	Stream hierarchy"	adaptor isNil ifTrue: [adaptor := ReadStreamAdaptor for: self].	^ adaptor.</body></methods><methods><class-id>JNIPort.JavaUtilEnumeration</class-id> <category>streaming</category><body package="JNIPort-Java-AdditionalWrappers">do: a1Block	"core method for iterables"	| testMID getMID last |	"overrriden to gain efficiency by not repeatedly looking up the method IDs"	testMID := self findMethod: 'hasMoreElements' signature: '()Z'.	getMID := self findMethod: 'nextElement' signature: '()Ljava/lang/Object;'.	"we cache the MethodIDs for the durarion of the loop to avoid needless inefficiency"	[self callBooleanMID: testMID]		whileTrue: [last := a1Block value: (self callObjectMID: getMID)].	^ last.</body><body package="JNIPort-Java-AdditionalWrappers">next	"part of the normal &lt;ReadStream&gt; protocol"	^ self nextElement.</body></methods><methods><class-id>JNIPort.JavaUtilEnumeration</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">hasMoreElements	"answer the result of calling the receiver's public abstract hasMoreElements() Java method"	^ self callBooleanMethod: 'hasMoreElements'.</body><body package="JNIPort-Java-AdditionalWrappers">nextElement	"answer the result of calling the receiver's public abstract nextElement() Java method"	^ self callObjectMethod: 'nextElement' signature: '()Ljava/lang/Object;'.</body></methods><methods><class-id>JNIPort.JavaUtilEnumeration</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">atEnd	"part of the normal &lt;ReadStream&gt; protocol"	^ self hasMoreElements not.</body></methods><methods><class-id>JNIPort.JavaUtilEnumeration class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#hasMoreElements		#nextElement	).</body></methods><methods><class-id>JNIPort.JavaUtilEnumeration class</class-id> <category>constants</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.Enumeration'.</body></methods><methods><class-id>JNIPort.JavaClassNameMethodGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	output		tab;		nextPutAll: '^ #''';		nextPutAll: className;		nextPutAll: '''.';		cr.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: 'answer the Symbol name of the Java class we stand for';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaClassNameMethodGenerator</class-id> <category>displaying</category><body package="JNIPort-Java-WrapperGeneration">description	"answer a short String description of the member we wrap"	^ 'Answer the name of the wrapped Java class'.</body></methods><methods><class-id>JNIPort.JavaClassNameMethodGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">className	"answer the Java class name that our generated method will answer"	^ className.</body><body package="JNIPort-Java-WrapperGeneration">selector	"answer the selector of the method we are going to generate"	^ #javaClassName.</body></methods><methods><class-id>JNIPort.JavaClassNameMethodGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">className: aString	"private -- set the Java class name that our generated method will answer"	className := aString.</body></methods><methods><class-id>JNIPort.JavaClassNameMethodGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">className: aString targetClass: aClass	"answer a new instance which will generate code for a #javaClassName method that will	answer aString"	^ (self targetClass: aClass)		className: aString;		yourself.</body></methods><methods><class-id>JNIPort.StaticJavaLangInteger</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">bitCount_int: int1	"answer the result of calling the receiver's public static bitCount(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'bitCount' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">get_SIZE	"answer the value of the receiver's public static final SIZE Java field"	^ self getIntField: 'SIZE'.</body><body package="JNIPort-Java-AdditionalWrappers">highestOneBit_int: int1	"answer the result of calling the receiver's public static highestOneBit(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'highestOneBit' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">lowestOneBit_int: int1	"answer the result of calling the receiver's public static lowestOneBit(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'lowestOneBit' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">numberOfLeadingZeros_int: int1	"answer the result of calling the receiver's public static numberOfLeadingZeros(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callIntMethod: 'numberOfLeadingZeros'				signature: '(I)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">numberOfTrailingZeros_int: int1	"answer the result of calling the receiver's public static numberOfTrailingZeros(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callIntMethod: 'numberOfTrailingZeros'				signature: '(I)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">reverseBytes_int: int1	"answer the result of calling the receiver's public static reverseBytes(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'reverseBytes' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">reverse_int: int1	"answer the result of calling the receiver's public static reverse(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'reverse' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">rotateLeft_int: int1 int: int2	"answer the result of calling the receiver's public static rotateLeft(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self callIntMethod: 'rotateLeft' signature: '(II)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">rotateRight_int: int1 int: int2	"answer the result of calling the receiver's public static rotateRight(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self callIntMethod: 'rotateRight' signature: '(II)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">signum_int: int1	"answer the result of calling the receiver's public static signum(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'signum' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_int: int1	"answer the result of calling the receiver's public static valueOf(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'valueOf'				signature: '(I)Ljava/lang/Integer;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangInteger</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">decode_String: aString1	"answer the result of calling the receiver's public static decode(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'decode'				signature: '(Ljava/lang/String;)Ljava/lang/Integer;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">getInteger_String: aString1	"answer the result of calling the receiver's public static getInteger(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getInteger'				signature: '(Ljava/lang/String;)Ljava/lang/Integer;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">getInteger_String: aString1 Integer: anInteger1	"answer the result of calling the receiver's public static getInteger(java.lang.String, java.lang.Integer) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: anInteger1.			self				callObjectMethod: 'getInteger'				signature: '(Ljava/lang/String;Ljava/lang/Integer;)Ljava/lang/Integer;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">getInteger_String: aString1 int: int1	"answer the result of calling the receiver's public static getInteger(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callObjectMethod: 'getInteger'				signature: '(Ljava/lang/String;I)Ljava/lang/Integer;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseInt_String: aString1	"answer the result of calling the receiver's public static parseInt(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callIntMethod: 'parseInt'				signature: '(Ljava/lang/String;)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseInt_String: aString1 int: int1	"answer the result of calling the receiver's public static parseInt(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callIntMethod: 'parseInt'				signature: '(Ljava/lang/String;I)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toBinaryString_int: int1	"answer the result of calling the receiver's public static toBinaryString(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'toBinaryString'				signature: '(I)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toHexString_int: int1	"answer the result of calling the receiver's public static toHexString(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'toHexString'				signature: '(I)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toOctalString_int: int1	"answer the result of calling the receiver's public static toOctalString(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'toOctalString'				signature: '(I)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_int: int1	"answer the result of calling the receiver's public static toString(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'toString'				signature: '(I)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_int: int1 int: int2	"answer the result of calling the receiver's public static toString(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self				callObjectMethod: 'toString'				signature: '(II)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1	"answer the result of calling the receiver's public static valueOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;)Ljava/lang/Integer;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1 int: int1	"answer the result of calling the receiver's public static valueOf(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;I)Ljava/lang/Integer;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangInteger</class-id> <category>Java-static</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_VALUE	"answer the value of the receiver's public static final MAX_VALUE Java field"	^ self getIntField: 'MAX_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_VALUE	"answer the value of the receiver's public static final MIN_VALUE Java field"	^ self getIntField: 'MIN_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_TYPE	"answer the value of the receiver's public static final TYPE Java field"	^ self getObjectField: 'TYPE' signature: 'Ljava/lang/Class;'.</body></methods><methods><class-id>JNIPort.StaticJavaLangInteger</class-id> <category>Java-constructors</category><body package="JNIPort-Java-AdditionalWrappers">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">new_int: int1	"answer the result of calling the receiver's public new(int) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callConstructorSignature: '(I)V' withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangInteger class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new_int:		#new_String:	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_MAX_VALUE		#get_MIN_VALUE		#get_SIZE		#get_TYPE	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#bitCount_int:		#decode_String:		#getInteger_String:		#getInteger_String:int:		#getInteger_String:Integer:		#highestOneBit_int:		#lowestOneBit_int:		#numberOfLeadingZeros_int:		#numberOfTrailingZeros_int:		#parseInt_String:		#parseInt_String:int:		#reverseBytes_int:		#reverse_int:		#rotateLeft_int:int:		#rotateRight_int:int:		#signum_int:		#toBinaryString_int:		#toHexString_int:		#toOctalString_int:		#toString_int:		#toString_int:int:		#valueOf_int:		#valueOf_String:		#valueOf_String:int:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangInteger class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Integer'.</body></methods><methods><class-id>JNIPort.JavaFieldSetterGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">parameter	"answer the name of the single parameter our method will take"	^ self parameter: 1.</body><body package="JNIPort-Java-WrapperGeneration">parameterCount	"answer how many paramers the generated method will take"	^1</body></methods><methods><class-id>JNIPort.JavaFieldSetterGenerator</class-id> <category>testing</category><body package="JNIPort-Java-WrapperGeneration">isDummy	"private -- answer whether we will generate dummy, #shouldNotImplement, setter	method.  This is used whenever we are asked to generate a setter for a final field	(NB: the class generation will attempt to filter our final fields, so that dummy setters	will not be generated unless they are needed to hide a superclass implementation)"	^ reflection isFinal.</body><body package="JNIPort-Java-WrapperGeneration">isSetter	"answer true iff we are a setter method generator"	^ true.</body><body package="JNIPort-Java-WrapperGeneration">isUnary	^false</body></methods><methods><class-id>JNIPort.JavaFieldSetterGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-WrapperGeneration">computeSelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	^self setterPrefix , self expandedName , ':'</body></methods><methods><class-id>JNIPort.JavaFieldSetterGenerator</class-id> <category>constants</category><body package="JNIPort-Java-WrapperGeneration">setterPrefix	"private -- answer the prefix to use for setter methods"	^ 'set_'.</body></methods><methods><class-id>JNIPort.JavaFieldSetterGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">computeParameters	"private -- answer a list #(keyword parameterName parameterType) triples for the method"	| triple |	triple := Array		with: (self setterPrefix , self expandedName , ':')		with: (self type parameterName: 0)		with: (self type).	^ Array with: triple.</body><body package="JNIPort-Java-WrapperGeneration">writeDummyMethodBody	"private -- write a method body to our output stream that will trigger an error	becuase the corresponding Java field is final"	output		tab;		nextPutAll: '^ self shouldNotImplement.';		cr.</body><body package="JNIPort-Java-WrapperGeneration">writeDummyMethodComment	"private -- write a method comment to our output stream explaining that it is a	dummy method"	output		tab;		nextPut: $";		nextPutAll: 'trigger a ShouldNotImplement error because the receiver''s ';		nextPutAll: reflection modifiersString;		space;		nextPutAll: self name;		nextPutAll: ' Java field is final';		nextPut: $";		cr; cr.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	| noSignature typeName |	self isDummy ifTrue: [^ self writeDummyMethodBody].	self type isJavaLangString		ifTrue:			[noSignature := true.			typeName := 'String']		ifFalse:			[noSignature := self type isAPrimitive.			typeName := self genericTypeName].	output		tab;		nextPutAll: '^ self set';		nextPutAll: typeName;		nextPutAll: 'Field: ';		nextPut: $';		nextPutAll: self name;		nextPut: $'.	noSignature ifFalse:		[output			nextPutAll: ' signature: ';			nextPut: $';			nextPutAll: self type jniSignature;			nextPut: $'].	output		nextPutAll: ' to: ';		nextPutAll: (self parameterName: 1);		nextPut: $.;		cr</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	self isDummy ifTrue: [^ self writeDummyMethodComment].	output		tab;		nextPut: $";		nextPutAll: 'set the value of the receiver''s ';		nextPutAll: reflection modifiersString;		space;		nextPutAll: self name;		nextPutAll: ' Java field to ';		nextPutAll: (self parameterName: 1);		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaClassRegistry</class-id> <category>initializing</category><body package="JNIPort-Java-Base">registerSystemClasses	"private -- called during initialisation.  Create wrappers for the raw JNIClass objects, and add them	to the class registry.  Note that this *must* happen before any other classes are registered or else an	infinite loop will occurr"	| rawJavaLangObject rawJavaLangClass rawJavaLangString rawJavaLangThrowable |	rawJavaLangObject := jvm jniEnv FindClass_name: 'java/lang/Object'.	self  jniAssert: [rawJavaLangObject notNull].	rawJavaLangClass := jvm jniEnv FindClass_name: 'java/lang/Class'.	self  jniAssert: [rawJavaLangClass notNull].	rawJavaLangString := jvm jniEnv FindClass_name: 'java/lang/String'.	self  jniAssert: [rawJavaLangString notNull].	rawJavaLangThrowable := jvm jniEnv FindClass_name: 'java/lang/Throwable'.	self  jniAssert: [rawJavaLangThrowable notNull].	"note that the Java class of java.lang.Class is itself, that it is a subclass of java.lang.Object, and	that the class of java.lang.Object is an instance of java.lang.Class.  Hence we have to be careful	about the order we do things here..."	"start by creating (normally illegal) blank class static object for the classes"	javaLangObject := StaticJavaLangObject newWithJVM: jvm.	javaLangClass := StaticJavaLangClass newWithJVM: jvm.	javaLangString := StaticJavaLangObject newWithJVM: jvm.	javaLangThrowable := StaticJavaLangThrowable newWithJVM: jvm.	"can now finish creating java.lang.Object"	javaLangObject		instanceClass: JavaLangObject;	"not necessary ?"		classObject: ((JavaLangClass jniObject: rawJavaLangObject static: javaLangClass)					classStatic: javaLangObject;					yourself).	"and java.lang.Class"	javaLangClass		javaSuperclass: javaLangObject;		instanceClass: JavaLangClass;		classObject: ((JavaLangClass jniObject: rawJavaLangClass static: javaLangClass)					classStatic: javaLangClass;					yourself).	"and now do java.lang.String"	javaLangString		javaSuperclass: javaLangObject;		instanceClass: JavaLangString;		classObject: ((JavaLangClass jniObject: rawJavaLangString static: javaLangClass)					classStatic: javaLangString;					yourself).	"and lastly: java.lang.Throwable"	javaLangThrowable		javaSuperclass: javaLangObject;		instanceClass: JavaLangThrowable;		classObject: ((JavaLangClass jniObject: rawJavaLangThrowable static: javaLangClass)					classStatic: javaLangThrowable;					yourself).	"add them to the registry"	self addToRegistry: javaLangObject classObject.	self addToRegistry: javaLangClass classObject.	self addToRegistry: javaLangString classObject.	self addToRegistry: javaLangThrowable classObject.	"NB: deliberately don't send the notifications that #registerClassObject: does, since	we're not bootstrapped yet"</body><body package="JNIPort-Java-Base">shutdown	"private -- called by our owning JVM when it shuts down"	"intentionally do not super-send"	javaLangClass := javaLangObject := javaLangString :=  javaLangThrowable := nil.	notificationQueue := nil.	sharedMutex critical: [registry := self makeRegistry: 0].</body></methods><methods><class-id>JNIPort.JavaClassRegistry</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">allArrayClasses	"answer an OrderedCollection of all the registered classes that stand for Java interfaces"	^ self allClassesSelect: [:each | each isArrayClass].</body><body package="JNIPort-Java-Base">allClassObjects	"answer an OrderedCollection of all the registered classes' class objects"	^ self contents.</body><body package="JNIPort-Java-Base">allClasses	"answer an OrderedCollection of all the registered classes"	^ self contents collect: [:each | each classStatic].</body><body package="JNIPort-Java-Base">allClassesSelect: aBlock	"answer an OrderedCollection of all the registered classes satisfying	the condition given by aBlock"	^sharedMutex critical: 			[| result |			result := OrderedCollection new: 10.			registry do: 					[:each |					| classStatic |					classStatic := each classStatic.					(aBlock value: classStatic) ifTrue: [result add: classStatic]].			result]</body><body package="JNIPort-Java-Base">allInterfaces	"answer an OrderedCollection of all the registered classes that stand for Java interfaces"	^ self allClassesSelect: [:each | each isAnInterface].</body><body package="JNIPort-Java-Base">allPrimitiveTypes	"answer an OrderedCollection of all the registered classes that stand for Java primitive types"	^ self allClassesSelect: [:each | each isAPrimitive].</body><body package="JNIPort-Java-Base">allRootClasses	"answer an OrderedCollection of all the registered classes that are normal classes without parents	(i.e, in fact, just java.lang.Object)"	^self allClassesSelect: 			[:each |			(each isArrayClass or: [each isAPrimitive or: [each isAnInterface or: [each javaSuperclass notNil]]]) not]</body><body package="JNIPort-Java-Base">knownDirectSubclassesOf: aJavaStatic	"answer an OrderedCollection of all the *known* direct subclasses of aJavaStatic.	NB: by subclass we *mean* subclass, interfaces don't count"	^ self allClassesSelect: [:each | each javaSuperclass == aJavaStatic].</body><body package="JNIPort-Java-Base">knownSubclassesOf: aJavaStatic	"answer an OrderedCollection of all the *known* subclasses of aJavaStatic.	NB: by subclass we *mean* subclass, interfaces don't count"	^ self allClassesSelect: [:each | each isSubclassOf: aJavaStatic].</body></methods><methods><class-id>JNIPort.JavaClassRegistry</class-id> <category>accessing</category><body package="JNIPort-Java-Base">findOrRelease: aJNIClass ifAbsentPut: a0Block	"look for an entry in the registry that refers to the same Java object as	aJNIObject, if one exists then release aJNIObject and answer the incumbent.	Otherwise add and answer the result of evaluating a0Block.  This is overridden	so as not to hold onto locks for too long"	| previous |	"this is called *A LOT*, so the test has to be quick.	NB: we are deliberately not yet using the shared mutex, see #addToRegistry for more detail"	previous := registry findElement: aJNIClass ifAbsent: [nil].	previous isNil		ifTrue: [previous := self registerClassObject: a0Block value]		ifFalse: [aJNIClass releaseRef: jvm jniEnv].	^ previous.</body><body package="JNIPort-Java-Base">javaLangClass	"answer the JavaStatic corresponding to java.lang.Class"	"the JVM needs fast access to this, so we cache it in an instvar"	^ javaLangClass.</body><body package="JNIPort-Java-Base">javaLangObject	"answer the JavaStatic corresponding to java.lang.Object"	"the JVM needs fast access to this, so we cache it in an instvar"	^ javaLangObject.</body><body package="JNIPort-Java-Base">javaLangString	"answer the JavaStatic corresponding to java.lang.String"	"the JVM needs fast access to this, so we cache it in an instvar"	^ javaLangString.</body><body package="JNIPort-Java-Base">javaLangThrowable	"answer the JavaStatic corresponding to java.lang.Throwable"	"the JVM needs fast access to this, so we cache it in an instvar"	#CUtodo.  "actually, it doesn't need fast access to this -- or even use it at all -- so far..."	^ javaLangThrowable.</body><body package="JNIPort-Java-Base">registry	^registry</body></methods><methods><class-id>JNIPort.JavaClassRegistry</class-id> <category>adding</category><body package="JNIPort-Java-Base">add: aJavaObject	"add a java object to the registry, replacing the existing incumbent, if any"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">addToRegistry: aJavaLangClass	"private -- add aJavaObject to the registry.	Assumes that it is called under the protection of the sharedMutex, and that aJavaLangClass	is not already present in the registry"	| new |	"NB: we are trying to allow read access to the old registry while we are constructing the new	one.  This is more expensive in the relatively rare case where an object is added to the registry	but avoids the cost of a lock on every read access -- of which there are *LOTS*"	"reduce the load on the local pool"	aJavaLangClass beGlobalRef.	"registered classes should not be finalisable; see the class comment for more info.	Note we can't make it unfinalisable until now when we are *sure* we are going to add it to the	registry"	"aJavaLangClass beUnfinalizable."	"make a copy of the registry with the new class added"	new := (self makeRegistry: 2 * registry size + 1)		"force low occupancy for speed"			addAll: registry;			add: aJavaLangClass;			yourself.	"swap over.  Hopefully this is atomic from the POV of other theads which may be	reading (but not modifying) the registry at the same time, and which are *NOT*	under the shared mutex"	registry := new.</body><body package="JNIPort-Java-Base">registerClassObject: aJavaLangClass	"private -- add a new class object to the registry.  It is assumed that aJNIClass is not normally	already present in the registry, however we do need to double-check.	Answers the added object or the previous resident if there turned out to be one"	sharedMutex critical:		[| it |		it := registry findElement: aJavaLangClass ifAbsent: [nil].		it isNil ifFalse: [^ it].		self addToRegistry: aJavaLangClass].	self notifyRegistered: aJavaLangClass classStatic.	^ aJavaLangClass.</body></methods><methods><class-id>JNIPort.JavaClassRegistry</class-id> <category>removing</category><body package="JNIPort-Java-Base">purge: aJavaStatic	"private -- do *NOT* call this!"	self trigger: #classPurged: with: aJavaStatic.	jvm notifyClassPurged: aJavaStatic.	sharedMutex critical:		[| new |		new := self makeRegistry: 2 * registry size.		"force low occupancy for speed"		registry do: [:each | each classStatic == aJavaStatic ifFalse: [new add: each]].		registry := new].	"aJavaStatic classObject beFinalizable."</body></methods><methods><class-id>JNIPort.JavaClassRegistry</class-id> <category>private-events</category><body package="JNIPort-Java-Base">myEventTable	^eventHandlers</body><body package="JNIPort-Java-Base">myEventTable: anEventTable	eventHandlers := anEventTable</body></methods><methods><class-id>JNIPort.JavaClassRegistry</class-id> <category>notifying</category><body package="JNIPort-Java-Base">notifyRegistered: aClassStatic	"private -- send out, or add to the pending queue, notification to the effect that aClassStatic has been	registered"	#CUtodo. "use the mutex ?"	notificationQueue ifNotNil: [:it | it addLast: aClassStatic. ^ self].	"tell the various interested parties; the JVM must be told first since it may have	interested Watchers (e.g. waiting to convert the class into a ghost)"	jvm notifyClassRegistered: aClassStatic.	aClassStatic notifyRegistered.	self trigger: #classRegistered: with: aClassStatic.</body><body package="JNIPort-Java-Base">releaseRegistrationNotifications	"private -- stop enqueing registration notifications, and send any pending notifications	that have been enqueued"	notificationQueue ifNotNil:		[:them |		notificationQueue := nil.		them do: [:each | self notifyRegistered: each]].</body><body package="JNIPort-Java-Base">suspendRegistrationNotifications	"private -- arrange to enqueue all registration notifications until such time	as #releaseRegistrationNotifications is called"	notificationQueue isNil ifTrue: [notificationQueue := OrderedCollection new].</body><body package="JNIPort-Java-Base">suspendRegistrationNotificationsWhile: a0Block	"evaluate a0Block in an environment where registration notifications	are suspended until the block has completed"	self suspendRegistrationNotifications.	^ a0Block ensure: [self releaseRegistrationNotifications].</body></methods><methods><class-id>JNIPort.JavaClassRegistry class</class-id> <category>private-events</category><body package="JNIPort-Java-Base">constructEventsTriggered	^(super constructEventsTriggered)		add: #classRegistered:;	"parameter is the new class static"		add: #classPurged:;		"parameter is the newly purged class static"		yourself</body></methods><methods><class-id>JNIPort.JavaClassRegistry class</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultCapacity	"private -- answer the default capacity to use for instances"	^ 200.</body><body package="JNIPort-Java-Base">registryContainerClass	"private -- answer the kind of container used to hold elements"	"overriden because we hold strong refs to objects"	^PluggableSet</body></methods><methods><class-id>JNIPort.JavaCodeWrapperGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">computeParameters	"private -- answer a list #(keyword parameterName parameterType) triples for the method"	| bag pfx params answer |	params := reflection parameterTypes.	answer := OrderedCollection new: params size.	bag := Bag new.	pfx := self expandedName , '_'.	params do:		[:each | | triple |		bag add: each.		triple := Array				with: (pfx , (each keywordName: generateLongKeywords) , ':')				with: (each parameterName: (bag occurrencesOf: each))				with: each.		answer addLast: triple.		pfx := ''].	^ answer.</body><body package="JNIPort-Java-WrapperGeneration">computeUnarySelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	^ self expandedName</body><body package="JNIPort-Java-WrapperGeneration">writeParameterAssembly: aString	"private -- write the declaration and assembly of a variable holding our parameters.	This is complicated by the need to assign temporary java.lang.String objects to variables	before putting them in the JNIValueArray"	output		tab;		nextPutAll: '| ';		nextPutAll: aString.	1 to: self parameterCount		do: 			[:i |			(self parameterType: i) isJavaLangString				ifTrue: 					[output						nextPutAll: (self parameterName: i);						nextPutAll: 'Ref ']].	output		nextPutAll: '|';		cr</body><body package="JNIPort-Java-WrapperGeneration">writeParameterDeclarationJavaStyle	"private -- write a Java-style list of our parameter types to our output stream"	output nextPut: $(.	reflection signature parameterTypes 		do: [:eachName | output nextPutAll: eachName]		separatedBy: [output nextPutAll: ', '].	output nextPut: $)</body><body package="JNIPort-Java-WrapperGeneration">writeParameterInitialization: aString	1 to: self parameterCount		do: 			[:i |			(self parameterType: i) isJavaLangString				ifTrue: 					[output						tab;						nextPutAll: (self parameterName: i);						nextPutAll: 'Ref := ';						nextPutAll: (self parameterName: i);						nextPutAll: ' asJavaString: ';						nextPutAll: self jvmString;						nextPutAll: '.';						cr]].	output tab.	aString isEmpty		ifFalse: 			[output				nextPutAll: aString;				nextPutAll: ' := '].	output		nextPutAll: 'JNIValueArray new: ';		print: self parameterCount;		nextPutAll: ' freeAfter: [:args |';		cr;		tab: 2;		nextPutAll: 'args'.	1 to: self parameterCount		do: 			[:i |			output				cr;				tab: 3;				nextPutAll: (self parameterType: i) genericTypeName asLowercase;				nextPutAll: 'At: ';				print: i;				nextPutAll: ' put: ';				nextPutAll: (self parameterName: i);				nextPutAll: ((self parameterType: i) isJavaLangString							ifTrue: ['Ref;']							ifFalse: [';'])].	output		cr;		tab: 3;		nextPutAll: 'yourself.';		cr</body></methods><methods><class-id>JNIPort.JavaCodeWrapperGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">ghostMethodIDString	"answer the String which we use for accessing the methodID from a ghost class method"	"the resulting literal will be replaced in the CompliledMethod's literal frame by a direct reference to	the appropriate JNIMethodID"	^ '#MethodID'.</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (super literalsMap)		at: #MethodID put: reflection methodID;		yourself.</body></methods><methods><class-id>JNIPort.JavaConstructorWrapperGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">name	"answer the name of the target object (which is also our own name)"	^ 'new'.</body><body package="JNIPort-Java-WrapperGeneration">typeFlags	"private -- answer the bit flags corresponding to the type of this member"	^JavaWrapperGeneratorSettings wrapAnyConstructorsMask.</body></methods><methods><class-id>JNIPort.JavaConstructorWrapperGenerator</class-id> <category>testing</category><body package="JNIPort-Java-WrapperGeneration">isConstructor	"answer true iff we are a constuctor method generator"	^ true.</body></methods><methods><class-id>JNIPort.JavaConstructorWrapperGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	self isUnary		ifFalse: 			[self writeParameterAssembly: ''.			self writeParameterInitialization: ''].	output tab.	self isUnary ifTrue: [output nextPutAll: 'answer := '].	output nextPutAll: 'self callConstructor'.	self isUnary		ifFalse: 			[output				nextPutAll: 'Signature: ';				nextPut: $';				nextPutAll: self jniSignature;				nextPut: $';				nextPutAll: ' withArguments: args'].	self isUnary ifFalse: [output nextPut: $]].	output		nextPut: $.;		cr</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: 'answer the result of calling the receiver''s ';		nextPutAll: reflection modifiersString;		space.	self isUnary		ifTrue: [output nextPutAll: 'default']		ifFalse: [output nextPutAll: 'new'. self writeParameterDeclarationJavaStyle].	output		nextPutAll: ' Java constructor';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaGhostConstructorGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-GhostClasses">computeSelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	^generateLongKeywords | includeTypeInSelector 		ifTrue: [super computeSelector]		ifFalse: [reflection signature smalltalkSelector]</body></methods><methods><class-id>JNIPort.JavaGhostConstructorGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (super literalsMap)		at: #JavaClass put: self type jniObject;		yourself.</body><body package="JNIPort-VW-Compatibility">methodSource	^PrototypeSources at: reflection signature prototypeMethodKey		ifAbsentPut: [super methodSource]</body><body package="JNIPort-Java-GhostClasses">parameterCount	"answer how many paramers the generated method will take"	^reflection argumentCount</body><body package="JNIPort-Java-GhostClasses">parameterName: anInteger 	"answer the name of anInteger-th parameter of the method we will generate"	^'t' , anInteger printString</body></methods><methods><class-id>JNIPort.JavaGhostConstructorGenerator</class-id> <category>constants</category><body package="JNIPort-Java-GhostClasses">convertToSmalltalkString: aString 	"answer aString, which is an expression decorated with code to	coerce it into Smalltalk"	^self wrapperFactoryString , ' wrapJNIObject: ' , aString</body><body package="JNIPort-Java-GhostClasses">jniObjectString	"answer the String which we use for accessing the underlying JNIObject from a method"	"overridden so as to hardwire the class object we are talking about, and thus	prevent mis-inheritance of constructors"	^ '#JavaClass'.</body><body package="JNIPort-Java-GhostClasses">jvmString	"answer the String which we use for accessing the JVM from a method"	^'#JVM'</body><body package="JNIPort-Java-GhostClasses">wrapperFactoryString	"private -- answer the String which we use for indicating the best object to wrap the returned JNIObject"	"since we always know *exactly* the type of the returned object, we can always use the optimised form"	^'#WrapperFactory'.</body></methods><methods><class-id>JNIPort.JavaGhostConstructorGenerator</class-id> <category>generating</category><body package="JNIPort-Java-GhostClasses">writeMethodBody	"private -- write a method body to our output stream"	"since this will be generated code, and hardly ever seen (except in the debugger),	we can drop right to the lowest level to gain speed.  However the big gain is that	the JVM, and especially the JNIMethodID will be embedded directly in the generated	method's literal frame"	self writeParameterAssembly: 'answer '.	self isUnary ifFalse: [self writeParameterInitialization: 'answer '].	output tab.	self isUnary		ifTrue: [output nextPutAll: 'answer := ']		ifFalse: [output tab].	output		nextPutAll: 'self jniEnv';		cr;		tab: 3;		nextPutAll: 'NewObjectA_class: ';		nextPutAll: self jniObjectString;		cr;		tab: 3;		nextPutAll: 'methodID: ';		nextPutAll: self ghostMethodIDString;		cr;		tab: 3;		nextPutAll: 'args: ';		nextPutAll: (self isUnary ifTrue: ['JNIValueArray null'] ifFalse: ['args']);		cr;		tab: 3;		nextPutAll: 'onException: [:jex | ^';		nextPutAll: self jvmString;		nextPutAll: ' throwJavaException: jex]'.	self isUnary ifFalse: [output nextPut: $]].	output nextPut: $..	output		crtab;		nextPutAll: '^ ';		nextPutAll: (self convertToSmalltalkString: 'answer');		nextPut: $.;		cr</body><body package="JNIPort-Java-GhostClasses">writeMethodPattern	"private -- write a 'method pattern' (header) to our output stream"	| i |	self isUnary 		ifTrue: 			[output				nextPutAll: self selector;				cr.			^self].	i := 1.	self selector keywords do: 			[:keyword | 			output				nextPutAll: keyword;				space;				nextPut: $t;				print: i]		separatedBy: 			[output space.			i := i + 1].	output cr</body><body package="JNIPort-Java-GhostClasses">writeParameterAssembly: aString	"private -- write the declaration and assembly of a variable holding our parameters.	This is complicated by the need to assign temporary java.lang.String objects to variables	before putting them in the JNIValueArray"	output		tab;		nextPutAll: '| ';		nextPutAll: aString.	1 to: self parameterCount		do: 			[:i |			(reflection signature hasStringParameterAt: i)				ifTrue: 					[output						nextPutAll: (self parameterName: i);						nextPutAll: 'Ref ']].	output		nextPutAll: '|';		cr</body><body package="JNIPort-Java-GhostClasses">writeParameterInitialization: aString	1 to: self parameterCount		do: 			[:i |			(reflection signature hasStringParameterAt: i)				ifTrue: 					[output						tab;						nextPutAll: (self parameterName: i);						nextPutAll: 'Ref := ';						nextPutAll: (self parameterName: i);						nextPutAll: ' asJavaString: ';						nextPutAll: self jvmString;						nextPutAll: '.';						cr]].	aString isEmpty		ifFalse: 			[output				nextPutAll: aString;				nextPutAll: ' := '].	output		nextPutAll: 'JNIValueArray new: ';		print: self parameterCount;		nextPutAll: ' freeAfter: [:args |';		cr;		tab: 2;		nextPutAll: 'args'.	1 to: self parameterCount		do: 			[:i |			output				cr;				tab: 3;				nextPutAll: (reflection signature genericParameterTypeNameAt: i)							asLowercase;				nextPutAll: 'At: ';				print: i;				nextPutAll: ' put: ';				nextPutAll: (self parameterName: i);				nextPutAll: ((reflection signature hasStringParameterAt: i)							ifTrue: ['Ref;']							ifFalse: [';'])].	output		cr;		tab: 3;		nextPutAll: 'yourself.';		cr;		cr</body></methods><methods><class-id>JNIPort.JavaGhostConstructorGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-VW-Compatibility">prototypeMethodFor: methodSource	^Prototypes at: reflection signature prototypeMethodKey		ifAbsentPut: [super prototypeMethodFor: methodSource]</body></methods><methods><class-id>JNIPort.JavaGhostConstructorGenerator class</class-id> <category>class initialization</category><body package="JNIPort-Java-GhostClasses">initialize	self resetPrototypes</body><body package="JNIPort-Java-GhostClasses">resetPrototypes	"self resetPrototypes"	PrototypeSources := Dictionary new.	PrototypeMethods := Dictionary new</body></methods><methods><class-id>JNIPort.JNIHelper</class-id> <category>accessing</category><body package="JNIPort-JNIHelper">abort_callback	"Answer the receiver's abort_callback field as a Smalltalk object."	^self externalData memberAt: #abort_callback</body><body package="JNIPort-JNIHelper">abort_callback: anExternalCallback 	"set the receiver's abort_callback field to (the address of) anExternalCallback"	self externalData memberAt: #abort_callback put: anExternalCallback</body><body package="JNIPort-JNIHelper">abort_handler	"Answer the receiver's abort_handler field as a Smalltalk object."	^self externalData memberAt: #abort_handler</body><body package="JNIPort-JNIHelper">exit_callback	"Answer the receiver's exit_callback field as a Smalltalk object."	^self externalData memberAt: #exit_callback</body><body package="JNIPort-JNIHelper">exit_callback: anExternalCallback	"set the receiver's exit_callback field to (the address of) anExternalCallback"	self externalData memberAt: #exit_callback put: anExternalCallback</body><body package="JNIPort-JNIHelper">exit_handler	"Answer the receiver's exit_handler field as a Smalltalk object."	^self externalData memberAt: #exit_handler</body><body package="JNIPort-JNIHelper">key	^self externalData key</body><body package="JNIPort-JNIHelper">maxQueueLength	"answer the maximum length of the callback queue"	"use the accessor function, rather than read the field directly, since the function is threadsafe"	^ library isNil		ifTrue: [0]		ifFalse: [library MaxCallbackQueueLength: self].</body><body package="JNIPort-JNIHelper">max_queue_length	"Answer the receiver's max_queue_length field as a Smalltalk object."	^self externalData memberAt: #max_queue_length</body><body package="JNIPort-JNIHelper">queueLength	"answer the current length of the queue"	"use the accessor function, rather than read the field directly, since the function is threadsafe"	^ library isNil		ifTrue: [0]		ifFalse: [library CallbackQueueLength: self].</body><body package="JNIPort-JNIHelper">queue_length	"Answer the receiver's queue_length field as a Smalltalk object."	^self externalData memberAt: #queue_length</body><body package="JNIPort-JNIHelper">redirectedAbortCallback: aCallback	"answer a new function pointer that can be passed to external libraries (specifically JNI)	in place of aCallback, and arrange that when the library code uses the new one, from any	thread, then aCallback will be invoked on the main Smalltalk thread"	self abort_callback: aCallback.	^ self abort_handler.</body><body package="JNIPort-JNIHelper">redirectedExitCallback: aCallback	"answer a new function pointer that can be passed to external libraries (specifically JNI)	in place of aCallback, and arrange that when the library code uses the new one, from any	thread, then aCallback will be invoked on the main Smalltalk thread"	self exit_callback: aCallback.	^ self exit_handler.</body><body package="JNIPort-JNIHelper">redirectedVFPrintfCallback: aCallback	"answer a new function pointer that can be passed to external libraries (specifically JNI)	in place of aCallback, and arrange that when the library code uses the new one, from any	thread, then aCallback will be invoked on the main Smalltalk thread"	self vfprintf_callback: aCallback.	^ self vfprintf_handler.</body><body package="JNIPort-JNIHelper">systemDebugVFPrintfCallback	"answer a new function pointer that can be passed to external libraries (specifically JNI)	that has the same signature as VFPrintf() and which sends the text to the Windows debug	stream.  Note, this never calls back into Smalltalk at all, and so can be used as a less fragile	(but less usefull) destination for JNI output"	^ library getVFDBPrintf.</body><body package="JNIPort-JNIHelper">thread_id	"Answer the receiver's thread_id field as a Smalltalk object."	^self externalData memberAt: #thread_id</body><body package="JNIPort-JNIHelper">vfprintf_callback	"Answer the receiver's vfprintf_callback field as a Smalltalk object."	^self externalData memberAt: #vfprintf_callback</body><body package="JNIPort-JNIHelper">vfprintf_callback: anExternalCallback 	"set the receiver's vfprintf_callback field to (the address of) anExternalCallback"	self externalData memberAt: #vfprintf_callback put: anExternalCallback</body><body package="JNIPort-JNIHelper">vfprintf_handler	"Answer the receiver's vfprintf_handler field as a Smalltalk object."	^self externalData memberAt: #vfprintf_handler</body></methods><methods><class-id>JNIPort.JNIHelper</class-id> <category>initialize-release</category><body package="JNIPort-JNIHelper">library: aJNIHelperLibrary 	"private -- set the owning library of this object"	library := aJNIHelperLibrary</body><body package="JNIPort-JNIHelper">release	(library notNil and: [self externalData isValid])		ifTrue: 			[[library ReleaseJNIHelper: self externalData] on: ExternalAccessFailed				do: [:ex | ].			library := nil].	super release</body></methods><methods><class-id>JNIPort.JNIHelper</class-id> <category>finalization</category><body package="JNIPort-JNIHelper">finalize	"release the resources we represent"	self release.	super finalize</body></methods><methods><class-id>JNIPort.JNIHelper class</class-id> <category>external accessing</category><body package="JNIPort-JNIHelper">baseCType	^JNIHelperLibrary default DolphinJNIHelper</body></methods><methods><class-id>JNIPort.JavaInterfaceStatic</class-id> <category>testing</category><body package="JNIPort-Java-Base">couldBeSubstituted	"answer false if we represent a class for which the JVM rules do not allow any other	to be substituted at runtime (e.g. final classes)"	^ true.</body><body package="JNIPort-Java-Base">isAnInterface	"answer whether we stand for an Java interface 'class'"	^ true.</body></methods><methods><class-id>JNIPort.JavaInterfaceStatic</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">makeGhostInstanceClassInstaller	"private -- answer a new JavaGhostClassInstaller that will populate our ghost instance class.	Should be overriden by subclasses that wish to modify the default settings"	| installer |	installer := super makeGhostInstanceClassInstaller.	"there's normally no point in wrapping abstract methods in ghost classes, since the concrete	subclass will also be wrapped.  However that doesn't apply to interface wrappers"	installer settings includeAbstractMethods: true.	^ installer.</body><body package="JNIPort-Java-GhostClasses">needsGhostInstanceClass	"answer whether the receiver needs a ghost class for instances."		^self hasGhostInstanceClass not</body><body package="JNIPort-Java-GhostClasses">needsGhostStaticClass	"answer whether the receiver needs an instance of a ghost static class.	NB: this is more subtle than just checking whether we're ghost	since we may just be inheriting a ghost static class from our Java	superclass without yet having a proper ghost class dedicated to	the Java class that we wrap"		^self hasGhostStaticClass not</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostInstanceClass 	"private -- answer whether we should use a ghost class for our instances"	^ self ghostClassSettings useGhostInstancesForInterfaces.</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostStaticClass 	"private -- answer whether we should use a ghost class static"	^ self ghostClassSettings useGhostStaticsForInterfaces.</body></methods><methods><class-id>JNIPort.JavaInterfaceStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaObjectArray.</body><body package="JNIPort-Java-Base">defaultInstanceClass	"answer the Smalltalk class to use by default for objects representing instances of our Java class"	^ JavaInterfaceInstance.</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree</class-id> <category>events</category><body package="JNIPort-Java-Base">notifyAdded: aSupplementaryClassloader	"private -- trigger change notification to say that the given entry has been added"	self trigger: #supplementaryClassloaderAdded: with: aSupplementaryClassloader.</body><body package="JNIPort-Java-Base">notifyChanged: aSupplementaryClassloader	"private -- trigger change notification say that the given entry has changed status in	some way"	self trigger: #supplementaryClassloaderChanged: with: aSupplementaryClassloader.</body><body package="JNIPort-Java-Base">notifyRemoved: aSupplementaryClassloader	"private -- trigger change notification to say that the given entry has been removed"	self trigger: #supplementaryClassloaderRemoved: with: aSupplementaryClassloader.</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree</class-id> <category>initializing</category><body package="JNIPort-Java-Base">configureFrom: aLocalJavaClasspathSettings	"private -- add entries corresponding to those defined in aLocalJavaClasspathSettings"	aLocalJavaClasspathSettings entries do: [:each | self addCopyOfEntry: each].</body><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state"	entriesByName := IdentityDictionary new.</body><body package="JNIPort-Java-Base">jvm: aJVM	"set our owning JVM"	jvm := aJVM.</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree</class-id> <category>accessing</category><body package="JNIPort-Java-Base">addCopyOfEntry: aSupplementaryClassloader	"private -- add a new entry configured by copying the data in aSupplementaryClassloader.	Answers the new entry"	^ (self addEntryNamed: aSupplementaryClassloader nameOrPath)		copyFrom: aSupplementaryClassloader;		yourself.</body><body package="JNIPort-Java-Base">addEntryNamed: aString	"add a blank new entry to our list, it will have the given name (which /must/ not	be modified thereafter) and be otherwise blank.	Answers the new entry"	| new |	new := (SupplementaryClassloader new)			name: aString	owner: self;			yourself.	entriesByName at: new name put: new.	self notifyAdded: new.	^ new.</body><body package="JNIPort-Java-Base">entryNamed: aStringOrSymbol	"answer the entry named by aStringOrSymbol"	^ self entryNamed: aStringOrSymbol ifAbsent: [self errorNotFound: aStringOrSymbol].</body><body package="JNIPort-Java-Base">entryNamed: aStringOrSymbol ifAbsent: a0Block	"answer the entry named by aStringOrSymbol or the result of evaluating a0Block if there is no	such entry"	^ entriesByName at: aStringOrSymbol asSymbol ifAbsent: a0Block.</body><body package="JNIPort-Java-Base">entryWithClassloader: aJavaLangClassloader	"answer the entry that uses the given JavaLangClassloader or throw an error if there isn't one"	^ entriesByName detect: [:each | each classloaderIs: aJavaLangClassloader].</body><body package="JNIPort-Java-Base">entryWithClassloader: aJavaLangClassloader ifNone: a0Block	"answer the entry that uses the given JavaLangClassloader, or the result	of evaluating a0Block if there isn't one"	^ entriesByName		detect: [:each | each classloaderIs: aJavaLangClassloader]		ifNone: a0Block.</body><body package="JNIPort-Java-Base">jvm	"answer our owning JVM"	^ jvm.</body><body package="JNIPort-Java-Base">removeEntry: aSupplementaryClassloader	"ensure we have no entry named by aString"	self removeEntryNamed: aSupplementaryClassloader name.</body><body package="JNIPort-Java-Base">removeEntryNamed: aString	"ensure we have no entry named by aString"	| gone |	gone := entriesByName removeKey: aString asSymbol ifAbsent: [^ self].	gone purge.	self notifyRemoved: gone.</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree</class-id> <category>purging</category><body package="JNIPort-Java-Base">purge	"purge all of our entries"	entriesByName do: [:each | each purge].</body><body package="JNIPort-Java-Base">shutdown	"private -- called when the JVM is shutting down.	All we do is discard any runtime information, we don't attempt anything	meaningfull in the way of cleaning up"	entriesByName do: [:each | each shutdown].</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree</class-id> <category>hierarchy</category><body package="JNIPort-Java-Base">childrenOfEntry: aSupplementaryClassloader	"answer a collection of the immediate dependents of the given entry"	| name |	name := aSupplementaryClassloader name.	^ entriesByName asArray select: [:each | each parentName == name].</body><body package="JNIPort-Java-Base">entryHasChildren: aSupplementaryClassloader	"answer whether the given entry has any dependent entries"	| name |	name := aSupplementaryClassloader name.	^ entriesByName anySatisfy: [:each | each parentName == name].</body><body package="JNIPort-Java-Base">rootEntries	"answer a list of the entries with no parents"	^ entriesByName values asArray reject: [:each | each hasParent].</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree</class-id> <category>private-events</category><body package="JNIPort-Java-Base">myEventTable	^eventHandlers</body><body package="JNIPort-Java-Base">myEventTable: anEventTable	eventHandlers := anEventTable</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree</class-id> <category>Java classes</category><body package="JNIPort-Java-Base">findClass: aClassName in: aName	"answer a JavaStatic object for the class named by the String or Symbol aClassName,	the classloader asked to find it will be the one corresponding to the given local	classpath entry named by the String or Symbol aName"	^ (self entryNamed: aName) findClass: aClassName.</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">forJVM: aJVM	"private -- answer a new instance which is owned by the given JVM and	initially configured from its settings"	^ (self jvm: aJVM)		configureFrom: aJVM settings supplementaryClassloaders;		yourself.</body><body package="JNIPort-Java-Base">jvm: aJVM	"answer a new instance which is owned by the given 	JVM and which has no	entries"	^ (self new)		jvm: aJVM;		yourself.</body><body package="JNIPort-Java-Base">new	"private -- use #jvm:"	^ (self basicNew)		initialize;		yourself.</body></methods><methods><class-id>JNIPort.SupplementaryClassloaderTree class</class-id> <category>private-events</category><body package="JNIPort-Java-Base">constructEventsTriggered	"answers a Set of Symbols that describe the published events triggered	by instances of the receiver."		^ (super constructEventsTriggered)		add: #supplementaryClassloaderAdded;		add: #supplementaryClassloaderChanged;		add: #supplementaryClassloaderRemoved;		yourself.</body></methods><methods><class-id>JNIPort.JavaReadStream</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">isBinary	"answer whether we read bytes rather than chars"	self subclassResponsibility.</body><body package="JNIPort-Java-AdditionalWrappers">isReadable	"answer whether we can be read from"	^ true.</body><body package="JNIPort-Java-AdditionalWrappers">isWritable	"answer whether we can be written to"	^ false.</body></methods><methods><class-id>JNIPort.JavaReadStream</class-id> <category>Java-public</category><body package="JNIPort-Java-AdditionalWrappers">close	"invoke the receiver's public close() Java method"	self callVoidMethod: 'close'.</body><body package="JNIPort-Java-AdditionalWrappers">markSupported	"answer the result of calling the receiver's public markSupported() Java method"	^ self callBooleanMethod: 'markSupported'.</body><body package="JNIPort-Java-AdditionalWrappers">mark_int: int1	"invoke the receiver's public mark(int) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callVoidMethod: 'mark' signature: '(I)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">read	"answer the result of calling the receiver's public read() Java method"	^ self callIntMethod: 'read'.</body><body package="JNIPort-Java-AdditionalWrappers">skip_long: long1	"answer the result of calling the receiver's public skip(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callLongMethod: 'skip' signature: '(J)J' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaReadStream</class-id> <category>operations</category><body package="JNIPort-Java-AdditionalWrappers">mark: anInteger	"invoke the receiver's mark() Java method"	self mark_int: anInteger.</body><body package="JNIPort-Java-AdditionalWrappers">skip: anInteger	"answer the result of calling the receiver's skip() Java method"	^ self skip_long: anInteger.</body></methods><methods><class-id>JNIPort.JavaReadStream</class-id> <category>reading</category><body package="JNIPort-Java-AdditionalWrappers">next	"answer the next element of the stream"	self subclassResponsibility.</body><body package="JNIPort-Java-AdditionalWrappers">next: anInteger	"answer the next anInteger elements of the stream.	The array will either be a String or a ByteArray depending on the type of the stream"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaReadStream</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">reset	"invoke the receiver's public synchronized reset() Java method"	self callVoidMethod: 'reset'.</body></methods><methods><class-id>JNIPort.JavaReadStream</class-id> <category>streaming</category><body package="JNIPort-Java-AdditionalWrappers">upToEnd	"answer an Array of the remaining elements of the stream.	The array will either be a String or a ByteArray depending on the type of the stream"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JavaReadStream class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#close		#mark_int:		#markSupported		#read		#reset		#skip_long:	).</body></methods><methods><class-id>JNIPort.JavaIoInputStream</class-id> <category>reading</category><body package="JNIPort-Java-AdditionalWrappers">next	"answer the next byte from the stream"	^ self read.</body><body package="JNIPort-Java-AdditionalWrappers">next: anInteger	"answer a ByteArray of the next anInteger elements of the stream"	| buffer offset |	buffer := JavaByteArray new: anInteger jvm: self jvm.	offset := 0.	[offset &lt; anInteger] whileTrue:		[| read |		read := self read_byteArray: buffer int: offset int: anInteger-offset.		read &lt;= 0 ifTrue: [^JNIPortUtility signalEndOfStream: self].		offset := offset + read].	^ buffer asByteArray.</body><body package="JNIPort-Java-AdditionalWrappers">read: aJavaByteArray	"answer the result of calling the receiver's read() Java method"	^ self read_byteArray: aJavaByteArray.</body><body package="JNIPort-Java-AdditionalWrappers">read: aJavaByteArray from: aStartIndex to: aStopIndex	"answer the result of calling the receiver's read() Java method.	Note that the indexes are Smalltalk-style, so the start and stop positions	are 1-based, and aStopIndex *is* included in the range unlike the underlying	Java method"	^ self		read_byteArray: aJavaByteArray		int: aStartIndex - 1		int: aStopIndex - aStartIndex + 1.</body></methods><methods><class-id>JNIPort.JavaIoInputStream</class-id> <category>streaming</category><body package="JNIPort-Java-AdditionalWrappers">upToEnd	"answer a ByteArray of the remaining elements of the stream"	| gulp buffer ostream read |	gulp := 16 * 1024.	buffer := JavaByteArray new: gulp jvm: self jvm.	ostream := (ByteArray new: gulp) writeStream.		[read := self read_byteArray: buffer int: 0 int: gulp.	read &lt;= 0 ifTrue: [^ostream contents].	ostream		next: read		putAll: buffer asByteArray		startingAt: 1]			repeat</body></methods><methods><class-id>JNIPort.JavaIoInputStream</class-id> <category>Java-public</category><body package="JNIPort-Java-AdditionalWrappers">available	"answer the result of calling the receiver's public available() Java method"	^ self callIntMethod: 'available'.</body><body package="JNIPort-Java-AdditionalWrappers">read_byteArray: bytes1	"answer the result of calling the receiver's public read(byte[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: bytes1.			self callIntMethod: 'read' signature: '([B)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">read_byteArray: bytes1 int: int1 int: int2	"answer the result of calling the receiver's public read(byte[], int, int) Java method"	^JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: bytes1;				intAt: 2 put: int1;				intAt: 3 put: int2.			self callIntMethod: 'read' signature: '([BII)I' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaIoInputStream</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">isBinary	"answer whether we read bytes rather than chars"	^ true.</body></methods><methods><class-id>JNIPort.JavaIoInputStream class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ super generatedWrapperSelectors , #(		#available		#read_byteArray:		#read_byteArray:int:int:	).</body></methods><methods><class-id>JNIPort.JavaIoInputStream class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.io.InputStream'.</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectModifier</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">isAbstract_int: int1	"answer the result of calling the receiver's public static isAbstract(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isAbstract' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isFinal_int: int1	"answer the result of calling the receiver's public static isFinal(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isFinal' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isInterface_int: int1	"answer the result of calling the receiver's public static isInterface(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isInterface' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isNative_int: int1	"answer the result of calling the receiver's public static isNative(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isNative' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isPrivate_int: int1	"answer the result of calling the receiver's public static isPrivate(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isPrivate' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isProtected_int: int1	"answer the result of calling the receiver's public static isProtected(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isProtected' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isPublic_int: int1	"answer the result of calling the receiver's public static isPublic(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isPublic' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isStatic_int: int1	"answer the result of calling the receiver's public static isStatic(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isStatic' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isStrict_int: int1	"answer the result of calling the receiver's public static isStrict(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isStrict' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isSynchronized_int: int1	"answer the result of calling the receiver's public static isSynchronized(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callBooleanMethod: 'isSynchronized'				signature: '(I)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">isTransient_int: int1	"answer the result of calling the receiver's public static isTransient(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isTransient' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">isVolatile_int: int1	"answer the result of calling the receiver's public static isVolatile(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callBooleanMethod: 'isVolatile' signature: '(I)Z' withArguments: args]</body><body package="JNIPort-Java-Base">toString_int: int1	"answer the result of calling the receiver's public static toString(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'toString'				signature: '(I)Ljava/lang/String;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectModifier</class-id> <category>Java-static</category><body package="JNIPort-Java-Base">get_ABSTRACT	"answer the value of the receiver's public static final ABSTRACT Java field"	^ self getIntField: 'ABSTRACT'.</body><body package="JNIPort-Java-Base">get_FINAL	"answer the value of the receiver's public static final FINAL Java field"	^ self getIntField: 'FINAL'.</body><body package="JNIPort-Java-Base">get_INTERFACE	"answer the value of the receiver's public static final INTERFACE Java field"	^ self getIntField: 'INTERFACE'.</body><body package="JNIPort-Java-Base">get_NATIVE	"answer the value of the receiver's public static final NATIVE Java field"	^ self getIntField: 'NATIVE'.</body><body package="JNIPort-Java-Base">get_PRIVATE	"answer the value of the receiver's public static final PRIVATE Java field"	^ self getIntField: 'PRIVATE'.</body><body package="JNIPort-Java-Base">get_PROTECTED	"answer the value of the receiver's public static final PROTECTED Java field"	^ self getIntField: 'PROTECTED'.</body><body package="JNIPort-Java-Base">get_PUBLIC	"answer the value of the receiver's public static final PUBLIC Java field"	^ self getIntField: 'PUBLIC'.</body><body package="JNIPort-Java-Base">get_STATIC	"answer the value of the receiver's public static final STATIC Java field"	^ self getIntField: 'STATIC'.</body><body package="JNIPort-Java-Base">get_STRICT	"answer the value of the receiver's public static final STRICT Java field"	^ self getIntField: 'STRICT'.</body><body package="JNIPort-Java-Base">get_SYNCHRONIZED	"answer the value of the receiver's public static final SYNCHRONIZED Java field"	^ self getIntField: 'SYNCHRONIZED'.</body><body package="JNIPort-Java-Base">get_TRANSIENT	"answer the value of the receiver's public static final TRANSIENT Java field"	^ self getIntField: 'TRANSIENT'.</body><body package="JNIPort-Java-Base">get_VOLATILE	"answer the value of the receiver's public static final VOLATILE Java field"	^ self getIntField: 'VOLATILE'.</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectModifier</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer the result of calling the receiver's public default Java constructor"	^ self callConstructor.</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectModifier class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.reflect.Modifier'.</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectModifier class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_ABSTRACT		#get_FINAL		#get_INTERFACE		#get_NATIVE		#get_PRIVATE		#get_PROTECTED		#get_PUBLIC		#get_STATIC		#get_STRICT		#get_SYNCHRONIZED		#get_TRANSIENT		#get_VOLATILE	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#isAbstract_int:		#isFinal_int:		#isInterface_int:		#isNative_int:		#isPrivate_int:		#isProtected_int:		#isPublic_int:		#isStatic_int:		#isStrict_int:		#isSynchronized_int:		#isTransient_int:		#isVolatile_int:		#toString_int:	).</body></methods><methods><class-id>JNIPort.JVMSubSettings</class-id> <category>accessing</category><body package="JNIPort-Java-Base">allFlagsSet: anInteger	"answer true iff all the bits that are set in anInteger are also set in our flags mask"	^ flags allMask: anInteger.</body><body package="JNIPort-Java-Base">anyFlagsSet: anInteger	"answer true iff alny bits that are set in anInteger are also set in our flags mask"	^ flags anyMask: anInteger.</body><body package="JNIPort-Java-Base">clearFlags: anInteger	"turn off any bits in our flags mask that are set in anInteger"	flags := flags bitAnd: anInteger bitInvert</body><body package="JNIPort-Java-Base">setFlags: anInteger	"turn on any bits in our flags mask that are set in anInteger"	flags := flags bitOr: anInteger</body><body package="JNIPort-Java-Base">setFlags: anInteger to: aBool	"turn on/off any bits in our flags mask that are set in anInteger"	flags := flags mask: anInteger set: aBool.</body></methods><methods><class-id>JNIPort.JVMSubSettings</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state"	flags := self class defaultFlags.</body></methods><methods><class-id>JNIPort.JVMSubSettings</class-id> <category>copying</category><body package="JNIPort-Java-Base">deepCopy	^self copy</body></methods><methods><class-id>JNIPort.JVMSubSettings</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">loadClassFromRegistryUnder: aRegKey ifNone: a0Block 	"private -- answer the class that is referenced by the data in the registry under the given key"	"guid"	| name |	name := aRegKey at: 'name' ifAbsent: [nil].	"guid := aRegKey valueAt: 'guid' ifAbsent: [nil]."	name isNil 		ifFalse: 			[(BindingReference simpleName: name in: self class environment) 				ifDefinedDo: [:aClass | ^aClass]].	JNIPortNotification raiseSignal: 'Warning: found no class called ' , name.	", ' trying GUID'"	"guid isNil ifFalse: [guid := GUID fromBytes: guid. Class allClasses do: [:each | each guid = guid ifTrue: [^ each]]]."	^a0Block value</body><body package="JNIPort-Configuration">loadFromRegistryUnder: aRegKey	"load our state from the registry under the given key.  Answer whether	we found an acceptable minimum of data there.	NB: we are, in fact, exceedingly forgiving about missing data"	self class booleanAspectNames do:		[:each || value |		value := aRegKey at: each ifAbsent: [nil].		value isNil ifFalse: [self perform: (each , ':') asSymbol with: value ~= 0]].	self class integerAspectNames do:		[:each || value |		value := aRegKey at: each ifAbsent: [nil].		value isNil ifFalse: [self perform: (each , ':') asSymbol with: value]].	self class stringAspectNames do:		[:each || value |		"use 77 as a magic cookie, since we want to allow nil strings"		value := aRegKey at: each ifAbsent: [77].		value == 77 ifFalse: [self perform: (each , ':') asSymbol with: value]].	^ self loadOtherAspectsFromRegistryUnder: aRegKey.</body><body package="JNIPort-Configuration">loadOtherAspectsFromRegistryUnder: aRegKey	"private -- load our non-standard state from the registry under the given key.	Answer true iff we found an acceptable minumum of data"	"default is to do nothing"	#subclassResponsibility.	^ true.</body><body package="JNIPort-Configuration">saveClass: aClass toRegistryUnder: aRegKey	"private -- save a reference to the given class  to the registry under the given key"	aRegKey		at: 'name' put: aClass name";		valueAt: 'guid' put: aClass guid."</body><body package="JNIPort-Configuration">saveOtherAspectsToRegistryUnder: aRegKey	"private -- save our non-standard state to the registry under the given key"	"default is to do nothing"	#subclassResponsibility.</body><body package="JNIPort-Configuration">saveToRegistryUnder: aRegKey	"save our state to the registry under the given key"	self class booleanAspectNames do:		[:each || value |		value := (self perform: each) ifTrue: [1] ifFalse: [0].		aRegKey at: each put: value].	self class integerAspectNames do:		[:each | aRegKey at: each put: (self perform: each)].	self class stringAspectNames do:		[:each | aRegKey at: each put: ((self perform: each) ifNil: [String new])].	self saveOtherAspectsToRegistryUnder: aRegKey.</body></methods><methods><class-id>JNIPort.JVMSubSettings class</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultFlags	"answer the collection of flags that are set by default"	^ 0.</body></methods><methods><class-id>JNIPort.JVMSubSettings class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer a new, default initialised instance"	^ (super new)		initialize;		yourself.</body></methods><methods><class-id>JNIPort.JVMSubSettings class</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">booleanAspectNames	"private -- answer an Array of the names of boolean aspects of instances"	^ #().</body><body package="JNIPort-Configuration">integerAspectNames	"private -- answer an Array of the names of integer aspects of instances"	^ #().</body><body package="JNIPort-Configuration">stringAspectNames	"private -- answer an Array of the names of string aspects of instances"	^ #().</body></methods><methods><class-id>JNIPort.SupplementaryClassloadersSettings</class-id> <category>accessing</category><body package="JNIPort-Java-Base">addEntry: aSupplementaryClassLoader	entries addLast: aSupplementaryClassLoader</body><body package="JNIPort-Java-Base">entries	"answer the list of SupplementaryClassloaders that JVMs may define as they start up	(and which can be modified thereafter).	Note, this answers an OrderedCollection of SupplementaryClassloaders, not a SupplementaryClassloaderTree"	^ entries ifNil: [OrderedCollection new].</body><body package="JNIPort-Java-Base">entries: aCollection	"set the list of SupplementaryClassloaders that JVMs may define as they start up	(and which can be modified thereafter).	Note, this takes an OrderedCollection of SupplementaryClassloaders, not a SupplementaryClassloaderTree"	entries:= aCollection.</body><body package="JNIPort-Java-Base">removeEntry: aSupplementaryClassLoader	entries remove: aSupplementaryClassLoader</body><body package="JNIPort-Java-Base">useAtStartup: aBool	"answer whether the JVM will set up any supplementary classloaders that we	call for during its intialisation (if not then they can be initialised later explicitly)"	self setFlags: self useAtStartupMask to: aBool</body></methods><methods><class-id>JNIPort.SupplementaryClassloadersSettings</class-id> <category>testing</category><body package="JNIPort-Java-Base">useAtStartup	"answer whether the JVM will set up any supplementary classloaders that we	call for during its intialisation (if not then they can be initialised later explicitly)"	^self allFlagsSet: self useAtStartupMask</body><body package="JNIPort-Java-Base">useAtStartupMask	^16r0001</body></methods><methods><class-id>JNIPort.SupplementaryClassloadersSettings</class-id> <category>copying</category><body package="JNIPort-Java-Base">postCopy	super postCopy.	entries := entries copy</body></methods><methods><class-id>JNIPort.SupplementaryClassloadersSettings</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initialize	"private -- establish a default initial state.	NB: this is only used for creating a new 'default' (template) instance.  Subsequent	instances are created by cloning that"	super initialize.	entries := OrderedCollection new.</body></methods><methods><class-id>JNIPort.SupplementaryClassloadersSettings</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">loadOtherAspectsFromRegistryUnder: aRegKey	"private -- load our non-standard state from the registry under the given key.	Answer true iff we found an acceptable minumum of data"	| count |	count := aRegKey at: 'entry count' ifAbsent: [0].	entries := OrderedCollection new: count.	1 to: count do:		[:i || key subkey entry |		key := 'entry ' , (NumberPrintPolicy print: i using: '00').		subkey := aRegKey subKeyNamed: key ifAbsent: [^ true].		entry := SupplementaryClassloader newFromRegistryUnder: subkey ifNone: [^ true].		entries addLast: entry].	^ true.</body><body package="JNIPort-Configuration">saveOtherAspectsToRegistryUnder: aRegKey	"private -- save our non-standard state to the registry under the given key"	#CUtodo.  "we should remove the old ones"	aRegKey at: 'entry count' put: self entries size.	self entries keysAndValuesDo:		[:i :each || subkey |		subkey := aRegKey subKeyNamed: 'entry ' , (NumberPrintPolicy print: i using: '00').		each saveToRegistryUnder: subkey].</body></methods><methods><class-id>JNIPort.SupplementaryClassloadersSettings class</class-id> <category>class initialization</category><body package="JNIPort-Java-Base">initializeSettingsTemplate	"private -- class initialization.		self initializeSettingsTemplate.	"	JVMSettings addToTemplate: self new name: #supplementaryClassloaders.</body><body package="JNIPort-Java-Base">uninitialize	"private -- class-side tear-down.		self uninitialize.	"	| settingsClass |	settingsClass := 'JVMSettings' asClassOrNilIn: self environment.	settingsClass ifNotNil: [settingsClass removeFromTemplate: #supplementaryClassloaders].</body></methods><methods><class-id>JNIPort.SupplementaryClassloadersSettings class</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">booleanAspectNames	"private -- answer an Array of the names of boolean aspects of instances"	^ super booleanAspectNames		, #(			#useAtStartup		).</body></methods><methods><class-id>JNIPort.StaticJavaLangShort</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">decode_String: aString1	"answer the result of calling the receiver's public static decode(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'decode'				signature: '(Ljava/lang/String;)Ljava/lang/Short;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseShort_String: aString1	"answer the result of calling the receiver's public static parseShort(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callShortMethod: 'parseShort'				signature: '(Ljava/lang/String;)S'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseShort_String: aString1 int: int1	"answer the result of calling the receiver's public static parseShort(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callShortMethod: 'parseShort'				signature: '(Ljava/lang/String;I)S'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_short: short1	"answer the result of calling the receiver's public static toString(short) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args shortAt: 1 put: short1.			self				callObjectMethod: 'toString'				signature: '(S)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1	"answer the result of calling the receiver's public static valueOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;)Ljava/lang/Short;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1 int: int1	"answer the result of calling the receiver's public static valueOf(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;I)Ljava/lang/Short;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangShort</class-id> <category>Java-static</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_VALUE	"answer the value of the receiver's public static final MAX_VALUE Java field"	^ self getShortField: 'MAX_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_VALUE	"answer the value of the receiver's public static final MIN_VALUE Java field"	^ self getShortField: 'MIN_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_TYPE	"answer the value of the receiver's public static final TYPE Java field"	^ self getObjectField: 'TYPE' signature: 'Ljava/lang/Class;'.</body></methods><methods><class-id>JNIPort.StaticJavaLangShort</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">get_SIZE	"answer the value of the receiver's public static final SIZE Java field"	^ self getIntField: 'SIZE'.</body><body package="JNIPort-Java-AdditionalWrappers">reverseBytes_short: short1	"answer the result of calling the receiver's public static reverseBytes(short) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args shortAt: 1 put: short1.			self callShortMethod: 'reverseBytes' signature: '(S)S' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_short: short1	"answer the result of calling the receiver's public static valueOf(short) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args shortAt: 1 put: short1.			self				callObjectMethod: 'valueOf'				signature: '(S)Ljava/lang/Short;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangShort</class-id> <category>Java-constructors</category><body package="JNIPort-Java-AdditionalWrappers">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">new_short: short1	"answer the result of calling the receiver's public new(short) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args shortAt: 1 put: short1.			self callConstructorSignature: '(S)V' withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangShort class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new_short:		#new_String:	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_MAX_VALUE		#get_MIN_VALUE		#get_SIZE		#get_TYPE	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#decode_String:		#parseShort_String:		#parseShort_String:int:		#reverseBytes_short:		#toString_short:		#valueOf_short:		#valueOf_String:		#valueOf_String:int:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangShort class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Short'.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>accessing</category><body package="JNIPort-Java-Base">callbackDepth	"answer how deeply nested we are in callbacks"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callbackRegistry	"answer our registry of callbacks or nil if we don't support callbacks"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">callbacks	"answer how many callbacks have been serviced"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">classIndex	"answer our index of known-by-name classes"	^ classIndex.</body><body package="JNIPort-Java-Base">classRegistry	"answer our registry of known classes"	^ classRegistry.</body><body package="JNIPort-Java-Base">classloader	"alias provided so that we can act more polymorphically with other &lt;javaClassFinder&gt;s"	^ self systemClassloader.</body><body package="JNIPort-Java-Base">javaRuntime	"answer a/the java.lang.Runtime object for this JVM"	^ (self findClass: #'java.lang.Runtime') callObjectMethod: 'getRuntime' signature: '()Ljava/lang/Runtime;'.</body><body package="JNIPort-Java-Base">javaVM	"answer the receiver's JavaVM"	^ jniEnv javaVM.</body><body package="JNIPort-Java-Base">jniEnv	"answer the receiver's currently active jniEnv (a JNIEnv)"	^ jniEnv.</body><body package="JNIPort-Java-Base">jniHelper	"answer our jniHelper if we have one"	^ jniHelper.</body><body package="JNIPort-Java-Base">jvm	"implemented so #jvm can be part of the &lt;javaClassFinder&gt; and  &lt;javaWrapperFactory&gt;	protocols"	^ self.</body><body package="JNIPort-Java-Base">library	"answer which JavaRuntimeLibrary created us"	^ library.</body><body package="JNIPort-Java-Base">name	"answer the name of this instance"	^ name.</body><body package="JNIPort-Java-Base">name: aString	"set the name of this instance"	name := aString.</body><body package="JNIPort-Java-Base">objectRegistry	^objectRegistry</body><body package="JNIPort-Java-Base">settings	"answer the JVMSettings object that we use"	^ settings.</body><body package="JNIPort-Java-Base">sharedMutex	"answer the JVM-wide mutex"	^ sharedMutex.</body><body package="JNIPort-Java-Base">status	"answer one of #(Dead Initializing Running ShuttingDown) to indicate our current status.	Unfortunately, the status names do not match the names of the events used for status	change norifications.  Sorry..."	^ status</body><body package="JNIPort-Java-Base">systemClassloader	"answer the system java.lang.ClassLoader object for this JVM.	This is also known as the application classloader, since it is the one used by default	to load application classes (i.e. on the %CLASSPATH%, or whatever, rather than being	supplied as an integral part of the Java platform)"	^ (self findClass: #'java.lang.ClassLoader') getSystemClassLoader.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>events</category><body package="JNIPort-Java-Base">addWatcher: aJVMWatcher	"ensure that aJVMWatcher is on our list of watchers"	(watchers identityIncludes: aJVMWatcher) ifFalse:		[watchers add: aJVMWatcher.		aJVMWatcher onWatchingJvm: self].</body><body package="JNIPort-Java-Base">die	"tell the JVM that it's underlying Java VM has already been shutdown, and so that	it should clean up.	Note that this can be called in several ways:	-	explicity by client code (though it's a bad idea unless you know something has gone pear-shaped).	-	implicitly as a result of the JVM telling us that it has closed.	-	implictly at Smalltalk system startup.	The difference between this and #shutdown, is that this is called when there is reason	to expect that the JNI library is already dead, whereas #shutdown is called when we think	it is still in working order"	"NB: there's a hole here.  Any objects which are finalised between the point where the JNI library actually	stopped working, and the time we enter this mutex, will try to #free themselves, and will fail in whatever	manner happens to appeal to the JNI implementation.  There's nothing we can do to stop that"	sharedMutex critical: 			[JavaClassInstance killInstancesOwnedBy: self.			self basicShutdown].	self notifyDead</body><body package="JNIPort-Java-Base">notifyClassPurged: aJavaStatic	"tell any Watchers that are interested that a class is about to be purged from out registry"	watchers do: [:each | each onClassPurged: aJavaStatic].</body><body package="JNIPort-Java-Base">notifyClassRegistered: aJavaStatic	"tell any Watchers that are interested that we have registered a new class"	watchers do: [:each | each onClassRegistered: aJavaStatic].</body><body package="JNIPort-Java-Base">removeWatcher: aJVMWatcher	"ensure that aJVMWatcher is not on our list of watchers"	| index |	index := watchers identityIndexOf: aJVMWatcher.	index &gt; 0 ifTrue:		[watchers removeAtIndex: index.		aJVMWatcher onNotWatchingJvm: self].</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>JVM hooks</category><body package="JNIPort-Java-Base">handleJVMAbort	"private -- this is our onAbort() hook for the JVM"	JNIPortNotification raiseSignal: 'JVM abort() -- closing down'.	self die.	self trigger: #JVMAbort.</body><body package="JNIPort-Java-Base">handleJVMExit: anInteger	"private -- this is our onExit() hook for the JVM"	JNIPortNotification raiseSignal: 'JVM exit() -- closing down'.	self die.	self trigger: #JVMExit: with: anInteger.</body><body package="JNIPort-Java-Base">handleVFPrintf: aCPointer format: aString args: aVaList	"private -- this is our vfprintf() hook for the JVM"	| string |	"NB: some JNI libraries trigger this for *each character* of text to be output, don't	assume that you'll see a whole message in one go"	string := aString vsnprintfWithArguments: aVaList.	self		trigger: #JVMMessage:address:		with: string		with: aCPointer.	^ string size.</body><body package="JNIPort-Java-Base">makeAbortHook	"private -- answer a new Callback suitable for use as an abort handler"	^JNIPortCallback do: 			[self handleJVMAbort.			nil]		ofType: library abortCallback</body><body package="JNIPort-Java-Base">makeExitHook	"private -- answer a new Callback suitable for use as an exit handler"	^JNIPortCallback do: 			[:code | 			self handleJVMExit: code.			nil]		ofType: library exitCallback</body><body package="JNIPort-Java-Base">makeVFPrintfHook	"private -- answer a new Callback suitable for use as an vfprintf handler"	^JNIPortCallback do: 			[:fp :format :args | 			self 				handleVFPrintf: fp				format: format copyCStringFromHeap				args: args]		ofType: library vfprintfCallback</body><body package="JNIPort-Java-Base">rememberExternalCallback: anExternalCallback	"add anExternalCallback to a collection that we hold to prevent them being GCed"	externalCallbacks add: anExternalCallback.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>initializing</category><body package="JNIPort-Java-Base">addJVMHookOptionsTo: aJVMInitArgs	"private -- add options to aJVMInitArgs which will allow us to handle the defined JVM hooks"	| jniPortSettings hook |	jniPortSettings := settings jniPortSettings.	jniPortSettings useExitHook ifTrue:		[hook := self makeExitHook.		self rememberExternalCallback: hook.		jniHelper isNil ifFalse: [hook := jniHelper redirectedExitCallback: hook].		aJVMInitArgs addExitHook: hook].	jniPortSettings useAbortHook ifTrue:		[hook := self makeAbortHook.		self rememberExternalCallback: hook.		jniHelper isNil ifFalse: [hook := jniHelper redirectedAbortCallback: hook].		aJVMInitArgs addAbortHook: hook].	jniPortSettings useVFPrintfHook ifTrue:		[hook := self makeVFPrintfHook.		self rememberExternalCallback: hook.		jniHelper isNil ifFalse: [hook := (jniPortSettings useVFPrintfRedirection							ifTrue: [jniHelper systemDebugVFPrintfCallback]							ifFalse: [jniHelper redirectedVFPrintfCallback: hook])].		aJVMInitArgs addVFPrintfHook: hook].</body><body package="JNIPort-Java-Base">arrangeForCleanup	"private -- called during initialisation.  Arrange to be able to clean up adequately"	"self beFinalizable."</body><body package="JNIPort-Java-Base">findSystemClasses	"private -- called during initialisation.  Pre-locate the JNIClass object we need to before we can start registering	classes"	| class |	#CUtodo.  "what the hell are we supposed to do to signal these potential errors -- we can't even trace them...?"	class := jniEnv FindClass_name: 'java/lang/Object'.	rawJavaLangObject := class getGlobalRef: jniEnv onException: [:ex | self jniAssert: [false]].	class releaseRef: jniEnv.	self jniAssert: [rawJavaLangObject notNull].	class := jniEnv FindClass_name: 'java/lang/Class'.	rawJavaLangClass := class getGlobalRef: jniEnv onException: [:ex | self jniAssert: [false]].	jniEnv DeleteLocalRef_obj: class.	self jniAssert: [rawJavaLangClass notNull].	class := jniEnv FindClass_name: 'java/lang/System'.	rawJavaLangSystem := class getGlobalRef: jniEnv onException: [:ex | self jniAssert: [false]].	jniEnv DeleteLocalRef_obj: class.	self jniAssert: [rawJavaLangSystem notNull].</body><body package="JNIPort-Java-Base">findSystemMethods	"private -- called during initialisation.  Pre-locate the MethodIDs we need to before we can start registering	classes"	isArrayMethodID := jniEnv					GetMethodID_class: rawJavaLangClass					name: 'isArray'					sig: '()Z'.	self jniAssert: [isArrayMethodID notNull].	isInterfaceMethodID := jniEnv					GetMethodID_class: rawJavaLangClass					name: 'isInterface'					sig: '()Z'.	self jniAssert: [isInterfaceMethodID notNull].	identityHashCodeMethodID := jniEnv					GetStaticMethodID_class: rawJavaLangSystem					name: 'identityHashCode'					sig: '(Ljava/lang/Object;)I'.	self jniAssert: [identityHashCodeMethodID notNull].	"from this point on, the #isArrayClass:, #isInterfaceClass:, and #jniObjectIdentityHash: methods will work,	which are prerequisites for class registration"	equalsMethodID := jniEnv				GetMethodID_class: rawJavaLangObject				name: 'equals'				sig: '(Ljava/lang/Object;)Z'.	self jniAssert: [equalsMethodID notNull].	hashCodeMethodID := jniEnv					GetMethodID_class: rawJavaLangObject					name: 'hashCode'					sig: '()I'.	self jniAssert: [hashCodeMethodID notNull].	"this is slightly hacky, but it's much simpler than checking for the existence of	the reflective methods we are /really/ interested in"	hasJava5Extensions := (jniEnv					GetMethodID_class: rawJavaLangClass					name: 'isSynthetic'					sig: '()Z'					onException: [:ex | nil]) isNull not.</body><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state"	jniEnv := JNIPortDeadJNIEnv new.	status := #Dead.	sharedMutex := Mutex new.	externalCallbacks := OrderedCollection new.</body><body package="JNIPort-Java-Base">initializeCallbackRegistry	"private -- called during initialisation.  We are now sufficiently initialized for a callback registry	to work; if we want one then set one up now"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">initializeClassIndex	"private -- called during initialisation.  We are now sufficiently initialized for a class index to work;	set one up now"	classIndex := JavaClassIndex newFor: self.</body><body package="JNIPort-Java-Base">initializeClassRegistry	"private -- called during initialisation.  We are now sufficiently initialized for a class registry to work;	set one up now"	classRegistry := JavaClassRegistry newWithJVM: self.	"this must not be called until after the assignment to classRegistry"	classRegistry registerSystemClasses.</body><body package="JNIPort-Java-Base">initializeClasses	"private -- called during initialisation.  Pre-locate any system classes and methods we need to operate"	self findSystemClasses.	self findSystemMethods.</body><body package="JNIPort-Java-Base">initializeFromSettings: aJVMSettings	"private -- initialise ourselves from the given JVMSettings"	settings :=  aJVMSettings deepCopy.	"we don't want settings changed on us after we've started running"	self		initializeObjectCounts;		initializeObjectRegistry;		initializeLibrary;		initializeName;		initializeJNIHelper;		initializeJNI;		initializeLocalCapacity;		initializeClasses;		initializeClassRegistry;		initializeClassIndex;		initializeCallbackRegistry;		notifyBorn;		"*after* we're mostly ready"		initializeWatchers;		initializeWrapperClasses;		initializeSupplementaryClassloaders;		arrangeForCleanup;		notifyLive.</body><body package="JNIPort-Java-Base">initializeJNI	"private -- initialise our JNI structures"	| javaVMInitArgs |	javaVMInitArgs :=  settings runtimeSettings javaVMInitArgs.	self addJVMHookOptionsTo: javaVMInitArgs.	jniEnv := library createFirstJNIEnv: javaVMInitArgs.	javaVM := jniEnv javaVM</body><body package="JNIPort-Java-Base">initializeJNIHelper	"private -- allocate ourselves new JNIHelper, if we are configured to use one"	jniHelper		ifNotNil: 			[jniHelper release.			jniHelper := nil].	settings jniPortSettings useJNIHelperLibrary ifFalse: [^self].	jniHelper := JNIHelperLibrary default makeJNIHelper</body><body package="JNIPort-Java-Base">initializeLibrary	"private -- initialise ours JNI library"	library := settings jniPortSettings jniInterface</body><body package="JNIPort-Java-Base">initializeLocalCapacity	"private -- ensure we've got some initial local capacity (must be at least large enough for us to complete	basic initialisation before it has to be expanded)"	| answer |	localCapacity := self initialLocalCapacity.	answer := jniEnv EnsureLocalCapacity_capacity: localCapacity.	self jniAssert: [answer = 0].</body><body package="JNIPort-Java-Base">initializeName	"private -- initialise our name"	name := self makeUniqueName: settings name</body><body package="JNIPort-Java-Base">initializeObjectCounts	"private -- initialise ours tallies of object references"	localCount := globalCount := objectsCreated := objectsReleased := 0.</body><body package="JNIPort-Java-Base">initializeObjectRegistry	objectRegistry := JNIPortWeakRegistry new: 1000</body><body package="JNIPort-Java-Base">initializeWatchers	"private -- initialise our watcher list"	watchers := OrderedCollection new.	settings jniPortSettings watcherClasses do: [:each | each onJvmStartup: self].</body><body package="JNIPort-Java-Base">initializeWrapperClasses	"private -- called during initialisation.  We now have both a class registry and class index, so	get classes to register themselves as the 'preferred' wrappers"	JavaObject registerWrapperClassesWithJVM: self.</body><body package="JNIPort-Java-Base">notifyBorn	"private -- tell anyone who is interested that we have been born"	status := #Initializing.	self class addRunningInstance: self.	self trigger: #JVMIsBorn.</body><body package="JNIPort-Java-Base">notifyLive	"private -- tell anyone who is interested that we are now live"	status := #Running.	watchers do: [:each | each onJmvInitialized: self].	self trigger: #JVMIsLive.</body><body package="JNIPort-Java-Base">shutdownJavaCallbacks</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>Java classes</category><body package="JNIPort-Java-Base">defineClass: aString fromBytes: aByteArray	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	Answers a Class Static corresponding to the newly defined class.	Will throw an error if the class definition does not define a class named by	aString (which can be in JNI or Java format)."	| answer |	answer := self			defineClassObject: aString			fromBytes: aByteArray			classloader: nil.	^ answer ifNotNil: [:it | it classStatic].</body><body package="JNIPort-Java-Base">defineClass: aString fromBytes: aByteArray classloader: aJavaClassLoader	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	Answers a class Static corresponding to the newly defined class, which will have	aJavaClassLoader as its class loader.	Will throw an error if the class definition does not define a class named by	aString (which can be in JNI or Java format)."	| answer |	answer := self			defineClassObject: aString			fromBytes: aByteArray			classloader: aJavaClassLoader.	^ answer ifNotNil: [:it | it classStatic].</body><body package="JNIPort-Java-Base">defineClassFromBytes: aByteArray	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	defining the class named by aJNIClassName.	Answers a class Static corresponding to the newly defined class"	| answer |	answer := self			defineClassObject: nil			fromBytes: aByteArray			classloader: nil.	^ answer ifNotNil: [:it | it classStatic].</body><body package="JNIPort-Java-Base">defineClassFromBytes: aByteArray classloader: aJavaClassLoader	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	Answers a class Static corresponding to the newly defined class, which will have	aJavaClassLoader as its class loader"	| answer |	answer := self			defineClassObject: nil			fromBytes: aByteArray			classloader: aJavaClassLoader.	^ answer ifNotNil: [:it | it classStatic].</body><body package="JNIPort-Java-Base">defineClassObject: aJNIClassName fromBytes: aByteArray classloader: aJavaClassLoader	"private -- passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	defining the class named by aJNIClassName.	Answers a JavaLangClass corresponding to the newly defined class.	The name may be left nil, in which case the JVM will not check the supplied name against	that in the definition.	If the JavaObject aJavaClassLoader is not nil, then it is expect to be a Java object	of a subclass of java.lang.ClassLoader, and it will be assigned as the classloader of the new class,	otherwise the JVM will supply a default (possibly nil -- I can't find any doc for this)"	| answer |	answer := jniEnv				DefineClass_name: aJNIClassName				loader: aJavaClassLoader				buf: aByteArray				len: aByteArray size				onException: [:jex | self throwJavaException: jex].	^answer asJavaObject: self</body><body package="JNIPort-Java-Base">findClass: aString	"answer a JavaStatic object corresponding to aString -- note that this does	not allow lookup in user-installed classloaders"	"this will bounce back to our own #findClassObject: if the registry doesn't have it already"	^ classIndex findClass: aString.</body><body package="JNIPort-Java-Base">findClassObject: aJNIClassName	"answer a JavaLangClass object corresponding to aJNIClassName -- note that this does	not allow lookup in user-installed classloaders"	| answer |	answer := jniEnv FindClass_name: aJNIClassName				onException: [:jex | self throwJavaException: jex].	^answer ifNotNil: [self wrapJNIClass: answer asJNIClass]</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>managed objects</category><body package="JNIPort-Java-Base">basicDisown: aJavaInstance	"private -- clean up after aJavaInstance has no further role to play in the world.	This is the implementation of #disown: except that it is called under the protection	of our shared mutex"	objectsReleased := objectsReleased + 1.	aJavaInstance isGlobalRef		ifTrue: [globalCount := globalCount - 1]		ifFalse: [localCount := localCount - 1].</body><body package="JNIPort-Java-Base">basicNotifyNowGlobal: aJavaInstance	"private -- aJavaInstance has just become a global ref, adjust the counts accordingly.	This is the implementation of #notifyNowGlobal: except that it is called under the protection	of our shared mutex"	globalCount := globalCount + 1.	localCount := localCount - 1.</body><body package="JNIPort-Java-Base">basicNotifyNowLocal: aJavaInstance	"private -- aJavaInstance has just become a local ref, adjust the counts accordingly.	This is the implementation of #notifyNowLocal: except that it is called under the protection	of our shared mutex"	globalCount := globalCount - 1.	localCount := localCount + 1.	localCount &gt;= localCapacity ifTrue: [self increaseLocalCapacity].</body><body package="JNIPort-Java-Base">basicOwn: aJavaInstance	"private -- aJavaInstance has just been born, keep track of it from now on.	This is the implementation of #own: except that it is called under the protection	of our shared mutex"	objectsCreated := objectsCreated + 1.	aJavaInstance isGlobalRef		ifTrue:			[globalCount := globalCount + 1]		ifFalse:			[localCount := localCount + 1.			localCount &gt;= localCapacity ifTrue: [self increaseLocalCapacity]].</body><body package="JNIPort-Java-Base">basicShutdown	"private -- shutdown the JVM and release any resources it holds.  aBool tells us whether we were apparently	still alive when we entered this code.	Note that this can be called in several ways:	-	explicity by client code (via #shutdown).	-	implicitly via finalization (via #shutdown).	-	implictly at Smalltalk system startup (via #die).	-	implicitly as a result of the JVM telling us that it has closed  (via #die).	See #initializeFrom: for the sequence of initialisation steps that we have to unwind.	This code is executed as a critical section protected by our mutex.	Note that the callback registry #shutdownJava happens in our caller, if at all (since we don't want to	be talking to the Java world from inside our mutex)"	"kill our refs to a now non-operative library,  JNIEnv, etc"	library := javaVM := nil.	jniEnv := JNIPortDeadJNIEnv new.	jniHelper		ifNotNil: 			[jniHelper release.			jniHelper := nil].	"we can't be entirely certain that the JNI library won't use the callbacks	we set (threads and race conditions), so we don't dare discard them"	"externalCallbacks := nil."	"don't want the watchers anymore"	watchers := nil.	"we close down the registries, but keep handles to them"	supplementaryClassloaders notNil		ifTrue: [supplementaryClassloaders shutdown].	classIndex notNil ifTrue: [classIndex shutdown].	classRegistry notNil ifTrue: [classRegistry shutdown].	self shutdownCallbackRegistry.	"discard our handles on various Java objects"	rawJavaLangSystem 		:= rawJavaLangClass 		:= rawJavaLangObject 		:= isArrayMethodID 		:= isInterfaceMethodID 		:= identityHashCodeMethodID 		:= hashCodeMethodID 		:= equalsMethodID 		:= nil.	"the system keeps a cache of compilation results, which can result in	old references to (with all our resulting machinery) being kept around for	much longer than you'd expect.  This is a brutal, but	effective way of stopping it"	JNIPortUtility flushVMmethodCache</body><body package="JNIPort-Java-Base">disown: aJavaInstance	"private -- clean up after aJavaInstance has no further role to play in the world"	sharedMutex critical: [self basicDisown: aJavaInstance].</body><body package="JNIPort-Java-Base">findClassFor: aJNIObject	"private -- find/make the JavaStatic that will wrap aJNIObject"	^ (self wrapJNIClass: (jniEnv GetObjectClass_obj: aJNIObject)) classStatic.</body><body package="JNIPort-Java-Base">globalRefCount	"answer how many global managed objects our JVM is aware of at this time"	^ globalCount.</body><body package="JNIPort-Java-Base">localRefCount	"answer how many local managed objects our JVM is aware of at this time"	^ localCount.</body><body package="JNIPort-Java-Base">notifyNowGlobal: aJavaInstance	"private -- aJavaInstance has just become a global ref, adjust the counts accordingly"	sharedMutex critical: [self basicNotifyNowGlobal: aJavaInstance].</body><body package="JNIPort-Java-Base">notifyNowLocal: aJavaInstance	"private -- aJavaInstance has just become a local ref, adjust the counts accordingly"	sharedMutex critical: [self basicNotifyNowLocal: aJavaInstance].</body><body package="JNIPort-Java-Base">objectRefCount	"answer how many managed objects our JVM is aware of at this time"	^ localCount + globalCount.</body><body package="JNIPort-Java-Base">objectsCreated	"answer how many objects our JVM has ever created"	^ objectsCreated.</body><body package="JNIPort-Java-Base">objectsReleased	"answer how many objects our JVM ever released"	^ objectsReleased.</body><body package="JNIPort-Java-Base">own: aJavaInstance	"private -- aJavaInstance has just been born, keep track of it from now on"	"Register aJavaInstance in the receiver's objectRegistry such that	it is sent #finalize after being garbage collected. It is *not* necessary to remove aJavaInstance	from the objectRegistry in #disown:. The objectRegistry first removes dead 	instances, then sends #finalize to them, which in turn sends #disown: to the JVM."	self objectRegistry registerValueOf: 			[sharedMutex critical: 					[self basicOwn: aJavaInstance.					aJavaInstance]]</body><body package="JNIPort-Java-Base">wrapJNIClass: aJNIClass	"answer a JavaInstance, owned by the receiver, for the JNI object, aJNIClass	or nil if it is a null pointer"	"ask the special class static for classes to create a wrapper object"	^ classRegistry javaLangClass wrapJNIObject: aJNIClass.</body><body package="JNIPort-Java-Base">wrapJNIObject: aJNIObject	"answer a JavaInstance, owned by the receiver, for the JNI object, aJNIObject	or nil if it is a null pointer"	"this is invoked for new object refs where the Java class is not already known	before the ref is created, so we just lookup the class and then ask it to wrap	the object"	^ aJNIObject isNull		ifTrue: [nil]		ifFalse: [(self findClassFor: aJNIObject) wrapJNIObject: aJNIObject].</body><body package="JNIPort-Java-Base">wrapJNIString: aJNIObject	"answer a JavaInstance, owned by the receiver, for the JNI object, aJNIObject	or nil if it is a null pointer.  This *MUST NEVER* be called with any object that is not, in	fact, a java.lang.String (specifically the java.lang.String created by the primordial class	loader)"	"ask the known class static for java.lang.String to create a wrapper object, this	saves about half the time it takes to import a String, since we don't need to mess	around checking its actual class"	^ classRegistry javaLangString wrapJNIObject: aJNIObject.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>supplementary classloaders</category><body package="JNIPort-Java-Base">findClass: aString in: aStringOrSymbol	"answer a JavaStatic object corresponding to aString, loaded	via the named supplementary classloader entry (i.e. ultimately by a specially created	Java classloader).	Will throw an exceptioin if we are not using an enabled supplementary classloader	with the given name"	^ supplementaryClassloaders findClass: aString in: aStringOrSymbol.</body><body package="JNIPort-Java-Base">initializeSupplementaryClassloaders	"private -- called during initialisation.  We now have set up the global	wrapper classes (the ones that register directly with the JVM) so it's now	time to set up any supplementary classloaders"	self useSupplementaryClassloaders: (settings supplementaryClassloaders useAtStartup).</body><body package="JNIPort-Java-Base">notifySupplementaryClassloadersChanged	"private -- tell anyone who is interested that we have a different tree of supplementary	classloaders (if you need to see changes /to/ that tree then you'll have to register for	its own change events)"	#CUtodo.  "is there any value in telling the watchers too ?"	self trigger: #JVMSupplementaryClassloadersChanged.</body><body package="JNIPort-Java-Base">supplementaryClassloaderNamed: aStringOrSymbol	"if we are using supplementary classloaders, then answer the one with the given	name, throw an exception otherwise"	^ supplementaryClassloaders		ifNil: [self errorNotFound: aStringOrSymbol]		ifNotNil: [:it | it entryNamed: aStringOrSymbol].</body><body package="JNIPort-Java-Base">supplementaryClassloaders	"answer our tree of supplementary classloaders if we are using them, or nil otherwise"	^ supplementaryClassloaders.</body><body package="JNIPort-Java-Base">useSupplementaryClassloaders: aBool	"set whether we should use our collection of supplementary classloaders.	If this is turned off while we are running then the supplementary classloaders	will all be purged.  Otherwise it can be turned on while we are running at	which time any wrapper classes will be given a chance to get themselves	loaded by the supplementary classloader(s) of their choice"#CUtodo.  "should we protect the supplementatry classloaders list with our mutex ?"	self usingSupplementaryClassloaders = aBool ifTrue: [^ self].	aBool		ifTrue: [supplementaryClassloaders := SupplementaryClassloaderTree forJVM: self]		ifFalse: [supplementaryClassloaders purge.  supplementaryClassloaders := nil].	self notifySupplementaryClassloadersChanged.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>locals pool</category><body package="JNIPort-Java-Base">increaseLocalCapacity	"private -- ask the JNI library to increase the amount of local reference space it allows us.	NB: only called under the protection of our shared mutex"	localCapacity := localCapacity + self localCapacityIncrement.	jniEnv		EnsureLocalCapacity_capacity: localCapacity + self localCapacitySlop		onException: [:jex | self throwJavaException: jex].</body><body package="JNIPort-Java-Base">initialLocalCapacity	"private -- answer how many slots of local references we will demand of the JVM"	"must be at least big enough for us to bootstrap the system without calling #increaseLocalCapacity"	^ 100.	"the JNI default is only 16 !"</body><body package="JNIPort-Java-Base">localCapacityIncrement	"private -- answer how many more slots of local references we will ask for if we	discover that we're runnig out"	^ 50.</body><body package="JNIPort-Java-Base">localCapacitySlop	"private -- answer how many extra slots of local references we ask for in addition	to our formal capacity"	^ 10.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>comparing</category><body package="JNIPort-Java-Base">equalityHash: aJavaObjectOrJNIObject 	"answer the aJNIObjectOrJavaObject's Java hashCode().	Note that this method is optimised, and does *not* require the managed object	machinery (javaClass etc) to be set up"	^jniEnv 		CallIntMethodA_obj: aJavaObjectOrJNIObject		methodID: hashCodeMethodID		args: nil		onException: [:jex | self throwJavaException: jex]</body><body package="JNIPort-Java-Base">identityHash: aJavaObjectOrJNIObject	"answer the aJNIObjectOrJavaObject's Java identityHashCode().	Note that this method is optimised, and does *not* require the managed object	machinery (javaClass etc) to be set up"	| identityHash |	aJavaObjectOrJNIObject javaIdentityHash notNil		ifTrue: [^aJavaObjectOrJNIObject javaIdentityHash].	identityHash := JNIValueArray withJavaObject: aJavaObjectOrJNIObject		freeAfter: 			[:args |			jniEnv				CallStaticIntMethodA_class: rawJavaLangSystem				methodID: identityHashCodeMethodID				args: args				onException: [:jex | ^self throwJavaException: jex]].	aJavaObjectOrJNIObject javaIdentityHash: identityHash.	^identityHash</body><body package="JNIPort-Java-Base">is: aJavaObjectOrJNIObject equalTo: anotherJavaObjectOrJNIObject	"answer whether the two Java objects are equal in the sense of the java.lang.Object.equals() method.	Note that this method is optimised, and does *not* require the managed object	machinery (javaClass etc) to be set up.	Note also, that since we are calling a method on the first object it cannot be nil, the second object can"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anotherJavaObjectOrJNIObject.			jniEnv				CallBooleanMethodA_obj: aJavaObjectOrJNIObject				methodID: equalsMethodID				args: args				onException: [:jex | self throwJavaException: jex]]</body><body package="JNIPort-Java-Base">is: aJavaObjectOrJNIObject identicalTo: anotherJavaObjectOrJNIObject	"answer whether the two Java objects are identical.	Note that this method is optimised, and does *not* require the managed object	machinery (javaClass etc) to be set up"	^aJavaObjectOrJNIObject == anotherJavaObjectOrJNIObject or: 			[aJavaObjectOrJNIObject javaIdentityHash = anotherJavaObjectOrJNIObject javaIdentityHash and: 						[jniEnv IsSameObject_obj1: aJavaObjectOrJNIObject							obj2: anotherJavaObjectOrJNIObject]]</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>event handling</category><body package="JNIPort-Java-Base">onExit	"private -- called as an image exits, clean up gracefully"	"not really worth the effort, so commented out"	"self shutdown."</body><body package="JNIPort-Java-Base">onStartup	"private -- called as an image starts, ensure we know we are in an uninitialised state"	self die.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>copying</category><body package="JNIPort-Java-Base">copy	"overridden since we stand in a singleton-like relationship to the wrapped JNI structures"	^ self.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>helpers</category><body package="JNIPort-Java-Base">javaLangSystem	"answer the class static for java.lang.System"	^ self findClass: #'java.lang.System'.</body><body package="JNIPort-Java-Base">makeUniqueName: aString	"private -- answer a unique name based on aString"	| i |	(self class runningInstances anySatisfy: [:each | each name = aString]) ifFalse: [^ aString].	i := 1.	[| candidate |	candidate := (String new writeStream)				nextPutAll: aString;				nextPutAll: ' (';				print: (i := i + 1);				nextPut: $);				contents.	(self class runningInstances anySatisfy: [:each | each name = candidate]) ifFalse: [^ candidate]]		repeat.</body><body package="JNIPort-Java-Base">stderr	"answer the java.lang.System.err PrintStream"	^ self javaLangSystem err.</body><body package="JNIPort-Java-Base">stdin	"answer the java.lang.System.in InputStream"	^ self javaLangSystem in.</body><body package="JNIPort-Java-Base">stdout	"answer the java.lang.System.out PrintStream"	^ self javaLangSystem out.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>printing</category><body package="JNIPort-Java-Base">printOn: aStream 	"write a developer oriented representation of the receiver to aStream"	self isDead 		ifTrue: 			[aStream				nextPutAll: 'a dead ';				print: self class name]		ifFalse: [super printOn: aStream].	name ifNotNil: 			[aStream				nextPut: $(;				print: name;				nextPut: $)]</body><body package="JNIPort-Java-Base">storeOn: aStream	"A JVM cannot be stored on a Stream. Writes an expression which answers the default JVM when evaluated."	aStream nextPutAll: '(JVM default)'</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>private-events</category><body package="JNIPort-Java-Base">myEventTable	^eventHandlers</body><body package="JNIPort-Java-Base">myEventTable: anEventTable	eventHandlers := anEventTable</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>testing</category><body package="JNIPort-Java-Base">hasJava5Extensions	"answer whether we think our Java runtime has the Java 5 extensions.	(this is needed for ghost method generation, specifically the JavaLangReflectMethod&gt;&gt;isBridge	test)"	^ hasJava5Extensions</body><body package="JNIPort-Java-Base">isArrayClass: aJNIClass 	"answer true if aJNIClass stands for an array class.	Note that this method is optimised, and does *not* require the managed object	machinery (javaClass etc) to be set up -- indeed it is a needed by that machinery"	^jniEnv 		CallBooleanMethodA_obj: aJNIClass		methodID: isArrayMethodID		args: JNIValueArray null		onException: [:jex | self throwJavaException: jex]</body><body package="JNIPort-Java-Base">isDead	"answer whether this instance no longer represents a live connection to a Java Virtual Machine"	^ jniEnv isDead.</body><body package="JNIPort-Java-Base">isInterfaceClass: aJNIClass 	"answer true if aJNIClass stands for an interface class.	Note that this method is optimised, and does *not* require the managed object	machinery (javaClass etc) to be set up -- indeed it is a needed by that machinery"	^jniEnv 		CallBooleanMethodA_obj: aJNIClass		methodID: isInterfaceMethodID		args: JNIValueArray null		onException: [:jex | self throwJavaException: jex]</body><body package="JNIPort-Java-Base">isLive	"answer whether this instance still represents a live connection to a Java Virtual Machine"	^ jniEnv isDead not.</body><body package="JNIPort-Java-Base">isRunning	"answer whether we are in our normal running state	(which is not the same as #isLive since that starts being true early-on	in our initialisation sequence, whereas this doesn't become true until	we are fully initialised)"	^ status = #Running.</body><body package="JNIPort-Java-Base">usingSupplementaryClassloaders	"answer whether we are current using a collection of supplementary classloaders	(even if this answers true the collection itself may be empty)"	^ supplementaryClassloaders notNil.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>finalization</category><body package="JNIPort-Java-Base">finalize	"private -- we are no longer referenced, so shutdown"	self isLive ifTrue: [self shutdown].</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>finalizing</category><body package="JNIPort-Java-Base">shutdown	"shutdown the JVM and release any resources it holds.	Note that this can be called in several ways:	-	explicity by client code.	-	implicitly via finalization (abnormal case).	The difference between this and #die, is that #die is called when there is reason	to expect that the JNI library is already dead, whereas this is called when we think	it is still in working order"	self notifyShutdownStarting.	"give the callback registry -- if any --  a chance to shutdown stuff in the Java space"	self shutdownJavaCallbacks.	sharedMutex critical: 			["discard our local object refs and clean up with JNI"			watchers do: [:each | each onJvmShutdown: self].			JavaClassInstance freeInstancesOwnedBy: self.			rawJavaLangSystem notNull ifTrue: [rawJavaLangSystem releaseRef: jniEnv].			rawJavaLangClass notNull ifTrue: [rawJavaLangClass releaseRef: jniEnv].			rawJavaLangObject notNull ifTrue: [rawJavaLangObject releaseRef: jniEnv].			self javaVM destroy.			self basicShutdown].	self notifyDead</body><body package="JNIPort-Java-Base">shutdownCallbackRegistry	"private -- shutdown any callback registry we have"	self subclassResponsibility.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>monitoring</category><body package="JNIPort-Java-Base">localPoolCapacity	"answer the amount of space we have pre-allocated in the local reference pool"	^ localCapacity.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>Java callbacks</category><body package="JNIPort-Java-Base">asCallbackDo: a0Block	"answer the result of evaluating a0Block in an environment where we have	replaced the current JNIEnv with the currently valid one"	self subclassResponsibility.</body><body package="JNIPort-Java-Base">supportsCallbacks	"answer whether this JVM supports callbacks from Java into Smalltalk"	^false</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>shutting down</category><body package="JNIPort-Java-Base">notifyDead	"private -- tell anyone who is interested that we have died"	status := #Dead.	self trigger: #JVMIsDead.	self class removeRunningInstance: self.</body><body package="JNIPort-Java-Base">notifyShutdownStarting	"private -- tell anyone who is interested that we are about to shut down"	status := #ShuttingDown.	self trigger: #JVMShutdownStarting.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>exceptions</category><body package="JNIPort-Java-Base">throwJavaException: aJNIThrowable	"wrap a JNIThrowable object first in a JavaClassInstance and then throw a corresponding	Smaltalk Exception"	(aJNIThrowable asJavaObject: self) signal.</body></methods><methods><class-id>JNIPort.JVM</class-id> <category>ghost classes</category><body package="JNIPort-Java-Base">usesGhostClasses	"answer whether we are using ghost classes"	^ watchers anySatisfy: [:each | each usesGhostClasses].</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>event handling</category><body package="JNIPort-Java-Base">onStartup	"private -- called as an image starts, zero our count of running instances"	InstancesStarted := 0.</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>instances</category><body package="JNIPort-Java-Base">addRunningInstance: aJVM	"private -- add aJVM to the list of instances we know about"	InstancesStarted := InstancesStarted + 1.	RunningInstances add: aJVM.	self trigger: #JVMAdded: with: aJVM.</body><body package="JNIPort-Java-Base">current	"answer an arbitrarily selected running instance		self current.	"	^ self currentIfNone: [nil]</body><body package="JNIPort-Java-Base">currentIfNone: a0Block	"answer an arbitrarily selected running instance or the result of evaluating a0block if there	aren't any"	^RunningInstances		ifNil: a0Block		ifNotNil: [RunningInstances detect: [:each | each isLive] ifNone: a0Block]</body><body package="JNIPort-Java-Base">default	"answer an arbitrarily selected running instance, or start a new one (with the default settings)	if there isn't one running already.		self default.	"	^(Default notNil and: [Default isLive])		ifTrue: [Default]		ifFalse: [Default := self currentIfNone: [self newWithDefaultSettings]]</body><body package="JNIPort-Java-Base">hasRunningInstancesForSettingsNamed: aString	| jvmSettings |	jvmSettings := JVMSettings named: aString.	^jvmSettings notNil		and: [self runningInstances anySatisfy: [:jvm | jvm settings name = jvmSettings name]]</body><body package="JNIPort-Java-Base">removeRunningInstance: aJVM	"private -- remove aJVM from the list of instances we know about"	RunningInstances remove: aJVM ifAbsent: [].	Default == aJVM ifTrue: [Default := nil].	self trigger: #JVMRemoved: with: aJVM.</body><body package="JNIPort-Java-Base">runningInstances	"answer a collection of all the running instances		self runningInstances.	"	^RunningInstances ifNil: [OrderedCollection new]		ifNotNil: [:instances | instances select: [:each | each isLive]]</body><body package="JNIPort-Java-Base">runningInstancesForSettingsNamed: aString 	^self runningInstances select: [:jvm | jvm settings name = aString]</body><body package="JNIPort-Java-Base">shutdownInstancesForSettings: aJVMSettings 	(self runningInstancesForSettingsNamed: aJVMSettings name) 		do: [:each | each shutdown]</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">newWithDefaultSettings	"answer a new instance which uses the default settings.	NB: the actual instance answered will be of some subclass of JVM	determined by the default settings"	^ self newWithSettings: JVMSettings default.</body><body package="JNIPort-Java-Base">newWithSettings: aJVMSettings	"answer a new instance which  is initialised from the given JVMSettings.	NB: the actual instance answered will be of some subclass of JVM	determined by the given settings"	"I haven't moved responsibility for creating and initialising instances onto the	JVMSettings object, where it would seem to belong given that it knows what	class of JVM to use, because I'm far from convinced that the #jvmClass setting	will continue to exist.  Hence we leave public responsibility for being the JVM	factory with JVM class"	^ (aJVMSettings jniPortSettings jvmClass new)		initialize;		initializeFromSettings: aJVMSettings;		yourself.</body><body package="JNIPort-Java-Base">newWithSettingsNamed: aString	"answer a new instance which  is initialised from the named JVMSettings"	^ self newWithSettings: (JVMSettings named: aString).</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>private-events</category><body package="JNIPort-Java-Base">constructEventsTriggered	"answer a Set of Symbols that describe the published events triggered	by JVM instances.	NB: this does *not* include the notification messages sent to Watchers	registered via the #addWatcher: mechanism"	^ (super constructEventsTriggered)		add: #JVMIsBorn;		add: #JVMIsLive;		add: #JVMIsDead;		add: #JVMShutdownStarting;		add: #JVMAbort;		add: #JVMExit:;			"parameter is the exit code"		add: #JVMMessage:address:;	"parameters are the text of the message and the ExternalAddress of the VM FILE* stream"		add: #JVMSupplementaryClassloadersChanged;		yourself.</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>class initialization</category><body package="JNIPort-Java-Base">initialize	"private -- class initialisation.		self initialize.	"	InstancesStarted := 0.	RunningInstances := OrderedCollection new</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>documentation</category><body package="JNIPort-Java-Base">bugs	"answer a String describing the less than outstanding work"	^'-- Fundamental --   JavaLangString&gt;&gt;asByteArray is almost certanly mis-specified.   Smalltalk callbacks are not thread-safety aware (probably not fixable without help from the VM).   Shouldn''t generate wrapper methods at all if we can''t make them unambiguous. -- Deadlocks --   Calling java.lang.System.exit() while hooking JVM exit() (causes runtime error in 1.4.1 or later).-- Cosmetic --   Status page doesn''t seem to refresh properly on #refresh/F5.   #JVMIsDead doesn''t seem to be reaching the status monitor reliably.   History status page gives all intervals the same display width even after update interval is changed (misleading).   Classes page doesn''t update as new methods are generated.   Ghost method counts can be misleading (they include #jvm if it''s defined).'.</body><body package="JNIPort-Java-Base">todo	"answer a String describing the outstanding work"	^'-- General Functional Improvements --   Move ghost class activation into the #ghostClassSettings,   Write some tests for the new sruff.   Update all packages'' versions to 2.00.   Update documentation, write new page on classloaders.   Provide easier access to nested classes (access via ghost methods too ?).   Should be more aggressive about not generating unnecessary overriding methods.   Add properly wrapped access for the direct byte functions (added in JNI 1.4).-- IDE/GUI Support --   Add some monitoring of "lazy" ghost numbers.  *Supplementary classloaders page: finish it.   Wrapper wizard: allow user to select which methods are generated individually.   Wrapper wizard: allow user to regenerate only the pre-existing wrappers.   Wrapper wizard: should be SupplementaryClassloaders-aware.   Status page: should be cleverer about displaying the status of configurable features.   Console page: add stdin ?-- Things to Ponder --   What is JavaLangString&gt;&gt;asByteArray really supposed to answer ?   What else do we need to allow deployment of Java-based apps ?   For Java 5, automagically:               convert float params to java.lang.Float, etc ?               convert Smalltalk collections passed to varadic methods ?.               generate extension methods (doSomething:[withObject:[withObject:[...]]]) for varadic methods ?.   How to handle STB-ing  (possibly link to Java serialization) ?   How to handle Uncode better ?   Add a #minimumJNIVersion to the jniPort settings ?   Throw out use of JNI local references altogether ?'.</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>initializing</category><body package="JNIPort-Java-Base">uninitialize	"private -- class initialisation.		self uninitialize.	"	self runningInstances do: [:each | each shutdown].	RunningInstances := nil</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">instancesStarted	"answer how many instances have been started since the begining of this session"	^ InstancesStarted.</body></methods><methods><class-id>JNIPort.JVM class</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">obsolete	self uninitialize.	super obsolete</body></methods><methods><class-id>JNIPort.JavaWriteStream</class-id> <category>writing</category><body package="JNIPort-Java-AdditionalWrappers">cr	"add the platform specific line delimeter sequence (not the &lt;CR&gt; character)"	^ self nextPutAll: String lineDelimiter.</body><body package="JNIPort-Java-AdditionalWrappers">crtab	"add a line-delimiter and a tab"	self cr; tab.</body><body package="JNIPort-Java-AdditionalWrappers">crtab: anInteger	"add a line-delimiter and the given number of tabs"	self cr; tab: anInteger.</body><body package="JNIPort-Java-AdditionalWrappers">next: anInteger put: anObject	"repeatedly add anObject. 	Answers anObject."	anInteger timesRepeat: [self nextPut: anObject].	^ anObject.</body><body package="JNIPort-Java-AdditionalWrappers">next: aSize putAll: aSequenceableCollection startingAt: anIndex	"add aSize elements of aSequenceableCollection from anIndex.	Answers aSequenceableCollection"	"slow default implementation"	anIndex to: anIndex + aSize do: [:i | self nextPut: (aSequenceableCollection at: i)].	^ aSequenceableCollection.</body><body package="JNIPort-Java-AdditionalWrappers">nextPut: aCharacterOrInteger	"write aCharacterOrInteger answering aCharacterOrInteger"	self write_int: aCharacterOrInteger asInteger.	^ aCharacterOrInteger.</body><body package="JNIPort-Java-AdditionalWrappers">nextPutAll: aSequenceableCollection	"add aSequenceableCollection.	Answers aSequenceableCollection"	^ self		next: aSequenceableCollection size		putAll: aSequenceableCollection		startingAt: 1.</body><body package="JNIPort-Java-AdditionalWrappers">print: anObject	"tell anObject to print itself on us"	^ anObject printOn: self.</body><body package="JNIPort-Java-AdditionalWrappers">space	"add a space character"	^ self nextPut: Character space.</body><body package="JNIPort-Java-AdditionalWrappers">tab	"add a tab character"	^ self nextPut: Character tab.</body><body package="JNIPort-Java-AdditionalWrappers">tab: anInteger	"add the given number of tabs"	anInteger timesRepeat: [self tab].</body><body package="JNIPort-Java-AdditionalWrappers">write: aCharacterOrInteger	"invoke the receiver's write() Java method"	self write_int: aCharacterOrInteger asInteger.</body></methods><methods><class-id>JNIPort.JavaWriteStream</class-id> <category>Java-public</category><body package="JNIPort-Java-AdditionalWrappers">close	"invoke the receiver's public close() Java method"	self callVoidMethod: 'close'.</body><body package="JNIPort-Java-AdditionalWrappers">flush	"invoke the receiver's public flush() Java method"	self callVoidMethod: 'flush'.</body><body package="JNIPort-Java-AdditionalWrappers">write_int: int1	"invoke the receiver's public write(int) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callVoidMethod: 'write' signature: '(I)V' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaWriteStream</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">isBinary	"answer whether we write bytes rather than chars"	self subclassResponsibility.</body><body package="JNIPort-Java-AdditionalWrappers">isReadable	"answer whether we can be read from"	^ false.</body><body package="JNIPort-Java-AdditionalWrappers">isWritable	"answer whether we can be written to"	^ true.</body></methods><methods><class-id>JNIPort.JavaWriteStream class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#close		#flush		#write_int:	).</body></methods><methods><class-id>JNIPort.JNIVTableMethod</class-id> <category>accessing</category><body package="JNIPort-JNI">resultClass	^resultClass</body><body package="JNIPort-JNI">resultClass: aClassOrNil	resultClass := aClassOrNil</body></methods><methods><class-id>JNIPort.JNIVTableMethod</class-id> <category>calling</category><body package="JNIPort-JNI">call: arguments 	| result |	result := super call: arguments.	^resultClass isNil 		ifTrue: [result]		ifFalse: [resultClass newFromJNIDatum: result]</body></methods><methods><class-id>JNIPort.StaticJavaLangFloat</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">compare_float: float1 float: float2	"answer the result of calling the receiver's public static compare(float, float) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				floatAt: 1 put: float1;				floatAt: 2 put: float2.			self callIntMethod: 'compare' signature: '(FF)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">floatToIntBits_float: float1	"answer the result of calling the receiver's public static floatToIntBits(float) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self callIntMethod: 'floatToIntBits' signature: '(F)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">floatToRawIntBits_float: float1	"answer the result of calling the receiver's public static native floatToRawIntBits(float) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self				callIntMethod: 'floatToRawIntBits'				signature: '(F)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">intBitsToFloat_int: int1	"answer the result of calling the receiver's public static native intBitsToFloat(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callFloatMethod: 'intBitsToFloat' signature: '(I)F' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">isInfinite_float: float1	"answer the result of calling the receiver's public static isInfinite(float) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self callBooleanMethod: 'isInfinite' signature: '(F)Z' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">isNaN_float: float1	"answer the result of calling the receiver's public static isNaN(float) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self callBooleanMethod: 'isNaN' signature: '(F)Z' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseFloat_String: aString1	"answer the result of calling the receiver's public static parseFloat(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callFloatMethod: 'parseFloat'				signature: '(Ljava/lang/String;)F'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_float: float1	"answer the result of calling the receiver's public static toString(float) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self				callObjectMethod: 'toString'				signature: '(F)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1	"answer the result of calling the receiver's public static valueOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;)Ljava/lang/Float;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangFloat</class-id> <category>Java-constructors</category><body package="JNIPort-Java-AdditionalWrappers">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">new_double: double1	"answer the result of calling the receiver's public new(double) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self callConstructorSignature: '(D)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">new_float: float1	"answer the result of calling the receiver's public new(float) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self callConstructorSignature: '(F)V' withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangFloat</class-id> <category>Java-static</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_VALUE	"answer the value of the receiver's public static final MAX_VALUE Java field"	^ self getFloatField: 'MAX_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_VALUE	"answer the value of the receiver's public static final MIN_VALUE Java field"	^ self getFloatField: 'MIN_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_NEGATIVE_INFINITY	"answer the value of the receiver's public static final NEGATIVE_INFINITY Java field"	^ self getFloatField: 'NEGATIVE_INFINITY'.</body><body package="JNIPort-Java-AdditionalWrappers">get_NaN	"answer the value of the receiver's public static final NaN Java field"	^ self getFloatField: 'NaN'.</body><body package="JNIPort-Java-AdditionalWrappers">get_POSITIVE_INFINITY	"answer the value of the receiver's public static final POSITIVE_INFINITY Java field"	^ self getFloatField: 'POSITIVE_INFINITY'.</body><body package="JNIPort-Java-AdditionalWrappers">get_TYPE	"answer the value of the receiver's public static final TYPE Java field"	^ self getObjectField: 'TYPE' signature: 'Ljava/lang/Class;'.</body></methods><methods><class-id>JNIPort.StaticJavaLangFloat</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_EXPONENT	"answer the value of the receiver's public static final MAX_EXPONENT Java field"	^ self getIntField: 'MAX_EXPONENT'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_EXPONENT	"answer the value of the receiver's public static final MIN_EXPONENT Java field"	^ self getIntField: 'MIN_EXPONENT'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_NORMAL	"answer the value of the receiver's public static final MIN_NORMAL Java field"	^ self getFloatField: 'MIN_NORMAL'.</body><body package="JNIPort-Java-AdditionalWrappers">get_SIZE	"answer the value of the receiver's public static final SIZE Java field"	^ self getIntField: 'SIZE'.</body><body package="JNIPort-Java-AdditionalWrappers">toHexString_float: float1	"answer the result of calling the receiver's public static toHexString(float) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self				callObjectMethod: 'toHexString'				signature: '(F)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_float: float1	"answer the result of calling the receiver's public static valueOf(float) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args floatAt: 1 put: float1.			self				callObjectMethod: 'valueOf'				signature: '(F)Ljava/lang/Float;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangFloat class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new_double:		#new_float:		#new_String:	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_MAX_EXPONENT		#get_MAX_VALUE		#get_MIN_EXPONENT		#get_MIN_NORMAL		#get_MIN_VALUE		#get_NaN		#get_NEGATIVE_INFINITY		#get_POSITIVE_INFINITY		#get_SIZE		#get_TYPE	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#compare_float:float:		#floatToIntBits_float:		#floatToRawIntBits_float:		#intBitsToFloat_int:		#isInfinite_float:		#isNaN_float:		#parseFloat_String:		#toHexString_float:		#toString_float:		#valueOf_float:		#valueOf_String:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangFloat class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Float'.</body></methods><methods><class-id>JNIPort.JavaMethodWrapperGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">typeFlags	"private -- answer the bit flags corresponding to the type of this member"	^JavaWrapperGeneratorSettings wrapAnyMethodsMask.</body></methods><methods><class-id>JNIPort.JavaMethodWrapperGenerator</class-id> <category>testing</category><body package="JNIPort-Java-WrapperGeneration">isSelectedBy: aGeneratorSettings	"private -- answer whether we satisfy the criteria defined by aGeneratorSettings"	"overriden to check for abstract methods too"	^ (super isSelectedBy: aGeneratorSettings)		and: [(reflection isAbstract not or: [aGeneratorSettings includeAbstractMethods])			and: [reflection isBridge not or: [aGeneratorSettings includeBridgeMethods]]].</body><body package="JNIPort-Java-WrapperGeneration">isVoid	"answer whether the method we generate a wrapper for returns void"	^ reflection isVoidReturn.</body><body package="JNIPort-Java-WrapperGeneration">isWrapper	"answer true iff we are a wrapper method generator"	^ true.</body></methods><methods><class-id>JNIPort.JavaMethodWrapperGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	self isVoid		ifTrue: 			[self isUnary				ifFalse: 					[self writeParameterAssembly: ''.					self writeParameterInitialization: '']]		ifFalse: 			[self writeParameterAssembly: 'answer '.			self isUnary ifFalse: [self writeParameterInitialization: 'answer'].			output tab].	(self isUnary and: [self isVoid not])		ifTrue: [output nextPutAll: 'answer := ']		ifFalse: [output tab].	output		nextPutAll: 'self call';		nextPutAll: self genericTypeName;		nextPutAll: 'Method: ';		nextPut: $';		nextPutAll: self name;		nextPut: $'.	(self type isAPrimitive and: [self isUnary])		ifFalse: 			[output				nextPutAll: ' signature: ';				nextPut: $';				nextPutAll: self jniSignature;				nextPut: $'].	self isUnary		ifTrue: [output nextPut: $.]		ifFalse: [output nextPutAll: ' withArguments: args].'].	self isVoid		ifFalse: 			[output				crtab;				nextPutAll: '^answer']</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: (self isVoid ifTrue: ['invoke'] ifFalse: ['answer the result of calling']);		nextPutAll: ' the receiver''s ';		nextPutAll: reflection modifiersString;		space;		nextPutAll: self name.	self writeParameterDeclarationJavaStyle.	output		nextPutAll: ' Java method';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator</class-id> <category>generating</category><body package="JNIPort-Java-GhostClasses">writeMethodBody	"private -- write a method body to our output stream"	"since this will be generated code, and hardly ever seen (except in the debugger),	we can drop right to the lowest level to gain speed.  However the big gain is that	the JVM, and especially the JNIMethodID will be embedded directly in the generated	method's literal frame"	| isStatic tabs |	isStatic := reflection signature isStatic.	self isVoid		ifTrue: 			[self isUnary				ifFalse: 					[self writeParameterAssembly: ''.					self writeParameterInitialization: '']]		ifFalse: 			[self writeParameterAssembly: 'answer '.			self isUnary ifFalse: [self writeParameterInitialization: 'answer']].	output tab.	tabs := 3.	(self isUnary and: [self isVoid not])		ifTrue: [output nextPutAll: 'answer := ']		ifFalse: 			[output tab.			tabs := tabs + 1].	output		nextPutAll: 'self jniEnv';		crtab: tabs;		nextPutAll: (isStatic ifTrue: ['CallStatic'] ifFalse: ['Call']);		nextPutAll: self genericTypeName;		nextPutAll: (isStatic ifTrue: ['MethodA_class: '] ifFalse: ['MethodA_obj: ']);		nextPutAll: self jniObjectString;		crtab: tabs;		nextPutAll: 'methodID: ';		nextPutAll: self ghostMethodIDString;		crtab: tabs;		nextPutAll: 'args: ';		nextPutAll: (self isUnary ifTrue: ['JNIValueArray null'] ifFalse: ['args']);		crtab: tabs;		nextPutAll: 'onException: [:jex | ^';		nextPutAll: self jvmString;		nextPutAll: ' throwJavaException: jex]'.	self isUnary ifFalse: [output nextPut: $]].	output nextPut: $..	self isVoid ifTrue: [^self].	output		crtab;		nextPutAll: '^ ';		nextPutAll: (self convertToSmalltalkString: 'answer');		nextPut: $.;		cr</body><body package="JNIPort-Java-GhostClasses">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: (self isVoid 					ifTrue: ['invoke']					ifFalse: ['answer the result of calling']);		nextPutAll: ' the receiver''s ';		nextPutAll: reflection signature modifiersString;		space;		nextPutAll: self name.	self writeParameterDeclarationJavaStyle.	output		nextPutAll: ' Java method';		nextPut: $";		cr;		cr</body><body package="JNIPort-Java-GhostClasses">writeMethodPattern	"private -- write a 'method pattern' (header) to our output stream"	| i |	self isUnary 		ifTrue: 			[output				nextPutAll: self selector;				cr.			^self].	i := 1.	self selector keywords do: 			[:keyword | 			output				nextPutAll: keyword;				space;				nextPut: $t;				print: i]		separatedBy: 			[output space.			i := i + 1].	output cr</body><body package="JNIPort-Java-GhostClasses">writeParameterAssembly: aString	"private -- write the declaration and assembly of a variable holding our parameters.	This is complicated by the need to assign temporary java.lang.String objects to variables	before putting them in the JNIValueArray"	output		tab;		nextPutAll: '| ';		nextPutAll: aString.	1 to: self parameterCount		do: 			[:i |			(reflection signature hasStringParameterAt: i)				ifTrue: 					[output						nextPutAll: (self parameterName: i);						nextPutAll: 'Ref ']].	output		nextPutAll: '|';		cr</body><body package="JNIPort-Java-GhostClasses">writeParameterInitialization: aString	1 to: self parameterCount		do: 			[:i |			(reflection signature hasStringParameterAt: i)				ifTrue: 					[output						tab;						nextPutAll: (self parameterName: i);						nextPutAll: 'Ref := ';						nextPutAll: (self parameterName: i);						nextPutAll: ' asJavaString: ';						nextPutAll: self jvmString;						nextPutAll: '.';						cr]].	output tab.	aString isEmpty		ifFalse: 			[output				nextPutAll: aString;				nextPutAll: ' := '].	output		nextPutAll: 'JNIValueArray new: ';		print: self parameterCount;		nextPutAll: ' freeAfter: [:args |';		cr;		tab: 2;		nextPutAll: 'args'.	1 to: self parameterCount		do: 			[:i |			output				cr;				tab: 3;				nextPutAll: (reflection signature genericParameterTypeNameAt: i)							asLowercase;				nextPutAll: 'At: ';				print: i;				nextPutAll: ' put: ';				nextPutAll: (self parameterName: i);				nextPutAll: ((reflection signature hasStringParameterAt: i)							ifTrue: ['Ref;']							ifFalse: [';'])].	output		cr;		tab: 3;		nextPutAll: 'yourself.';		cr</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-GhostClasses">genericTypeName	"answer one of Boolean, Byte, ... Object, Short, or, Void according to our type"	genericTypeNameCache isNil 		ifTrue: 			[genericTypeNameCache := reflection signature genericReturnTypeName 						capitalized].	^genericTypeNameCache</body><body package="JNIPort-Java-GhostClasses">jniSignature	"answer the JNI signature of the member we will generate method to wrap"	jniSignatureCache isNil 		ifTrue: [jniSignatureCache := reflection signature jniSignatureString].	^jniSignatureCache</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (IdentityDictionary new)		at: #JVM put: self jvm;		at: #MethodID put: reflection methodID;		yourself.</body><body package="JNIPort-VW-Compatibility">methodSource	^PrototypeSources at: reflection signature prototypeMethodKey		ifAbsentPut: [super methodSource]</body><body package="JNIPort-Java-GhostClasses">parameterCount	"answer how many paramers the generated method will take"	^reflection argumentCount</body><body package="JNIPort-Java-GhostClasses">parameterName: anInteger 	"answer the name of anInteger-th parameter of the method we will generate"	^'t' , anInteger printString</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator</class-id> <category>testing</category><body package="JNIPort-Java-GhostClasses">isSelectedBy: aGeneratorSettings 	"private -- answer whether we satisfy the criteria defined by aGeneratorSettings"	"overriden to check for abstract methods too"	^(super isSelectedBy: aGeneratorSettings) and: 			[(reflection signature isAbstract not 				or: [aGeneratorSettings includeAbstractMethods]) 					and: [reflection isBridge not or: [aGeneratorSettings includeBridgeMethods]]]</body><body package="JNIPort-Java-GhostClasses">isVoid	"answer whether the method we generate a wrapper for returns void"	^reflection signature isVoidReturn</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-GhostClasses">reflection: aJavaReflection	"private -- set the reflection object we will use"	reflection := aJavaReflection.	"Avoid the additional roundtrip to Java for calling the name() method, get it from the signature instead."	name := aJavaReflection signature shortMethodName.</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-GhostClasses">computeSelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	^generateLongKeywords | includeTypeInSelector 		ifTrue: [super computeSelector]		ifFalse: [reflection signature smalltalkSelector]</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator</class-id> <category>constants</category><body package="JNIPort-Java-GhostClasses">convertToSmalltalkString: aString 	"answer aString, which is an expression decorated with code to	coerce it into Smalltalk"	^ reflection signature isOfPrimitiveType		ifTrue: [ 			reflection signature isOfCharType				ifTrue: [ aString , ' asCharacter' ]				ifFalse: [ aString ] ]		ifFalse: [ self wrapperFactoryString , ' wrapJNIObject: ' , aString ]</body><body package="JNIPort-Java-GhostClasses">jvmString	"answer the String which we use for accessing the JVM from a method"	^'#JVM'</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-VW-Compatibility">prototypeMethodFor: methodSource	^PrototypeMethods at: reflection signature prototypeMethodKey		ifAbsentPut: [super prototypeMethodFor: methodSource]</body></methods><methods><class-id>JNIPort.JavaGhostMethodGenerator class</class-id> <category>class initialization</category><body package="JNIPort-Java-GhostClasses">initialize	self resetPrototypes</body><body package="JNIPort-Java-GhostClasses">resetPrototypes	"self resetPrototypes"	PrototypeSources := Dictionary new.	PrototypeMethods := Dictionary new</body></methods><methods><class-id>JNIPort.JNIFieldID</class-id> <category>accessing</category><body package="JNIPort-JNI">signature	^signature</body><body package="JNIPort-JNI">signature: aString	signature := aString</body></methods><methods><class-id>JNIPort.JNIFieldID class</class-id> <category>external accessing</category><body package="JNIPort-JNI">baseCType	^JNIPortJNIInterface current jfieldID</body></methods><methods><class-id>JNIPort.JavaNonvirtual</class-id> <category>Java field access</category><body package="JNIPort-Java-Base">findField: aStringName signature: aJNISignature 	"answer the JavaFieldID corresponding to our Java object's field named aStringName,	with signature defined by aJNISignature"	| classObject |	classObject := self javaClassObject.	^classObject 		fieldIDFor: aStringName		signature: aJNISignature		ifAbsentPut: 			[self jniEnv 				GetFieldID_class: classObject				name: aStringName				sig: aJNISignature				onException: [:ex | self jvm throwJavaException: ex]]</body><body package="JNIPort-Java-Base">getBooleanFID: aFieldID 	"get the value of the field defined by aFieldID"	^self jniEnv 		GetBooleanField_obj: self jniObject		fieldID: aFieldID		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">getByteFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetByteField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getCharFID: aFieldID	"get the value of the field defined by aFieldID"	| answer |	answer := self jniEnv			GetCharField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].	^answer asCharacter</body><body package="JNIPort-Java-Base">getDoubleFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetDoubleField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getFloatFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetFloatField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getIntFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetIntField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getLongFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetLongField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">getObjectFID: aFieldID	"get the value of the field defined by aFieldID"	| answer |	answer := self jniEnv			GetObjectField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].	^ answer asJavaObject: self jvm.</body><body package="JNIPort-Java-Base">getObjectFID: aFieldID wrapperFactory: aJVMOrJavaStatic	"get the value of the field defined by aFieldID.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	| answer |	answer := self jniEnv			GetObjectField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].	^ aJVMOrJavaStatic wrapJNIObject: answer.</body><body package="JNIPort-Java-Base">getShortFID: aFieldID	"get the value of the field defined by aFieldID"	^ self jniEnv			GetShortField_obj: self jniObject			fieldID: aFieldID			onException: [:ex | self jvm throwJavaException: ex].</body><body package="JNIPort-Java-Base">setBooleanFID: aFieldID to: aBool	"set the value of the field defined by aFieldID to aBool"	self jniEnv			SetBooleanField_obj: self jniObject			fieldID: aFieldID			val: aBool			onException: [:ex | self jvm throwJavaException: ex].	^ aBool.</body><body package="JNIPort-Java-Base">setByteFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetByteField_obj: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setCharFID: aFieldID to: aCharacterOrInteger	"set the value of the field defined by aFieldID to aCharacterOrInteger"	self jniEnv			SetCharField_obj: self jniObject			fieldID: aFieldID			val: aCharacterOrInteger asInteger			onException: [:ex | self jvm throwJavaException: ex].	^ aCharacterOrInteger.</body><body package="JNIPort-Java-Base">setDoubleFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	| double |	double := aFloat asDouble.	self jniEnv		SetDoubleField_obj: self jniObject		fieldID: aFieldID		val: double		onException: [:ex | self jvm throwJavaException: ex].	^double</body><body package="JNIPort-Java-Base">setFloatFID: aFieldID to: aFloat	"set the value of the field defined by aFieldID to aFloat"	| float |	float := aFloat asFloat.	self jniEnv		SetFloatField_obj: self jniObject		fieldID: aFieldID		val: float		onException: [:ex | self jvm throwJavaException: ex].	^float</body><body package="JNIPort-Java-Base">setIntFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetIntField_obj: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setLongFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetLongField_obj: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body><body package="JNIPort-Java-Base">setObjectFID: aFieldID to: aJavaObjectOrNil	"set the value of the field defined by aFieldID to aJavaObjectOrNil"	self jniEnv		SetObjectField_obj: self jniObject		fieldID: aFieldID		val: aJavaObjectOrNil		onException: [:ex | self jvm throwJavaException: ex].	^aJavaObjectOrNil</body><body package="JNIPort-Java-Base">setShortFID: aFieldID to: anInteger	"set the value of the field defined by aFieldID to anInteger"	self jniEnv			SetShortField_obj: self jniObject			fieldID: aFieldID			val: anInteger			onException: [:ex | self jvm throwJavaException: ex].	^ anInteger.</body></methods><methods><class-id>JNIPort.JavaNonvirtual</class-id> <category>accessing</category><body package="JNIPort-Java-Base">managedInstance	"answer the managed object (a JavaClassInstance) which really owns the javaObject we wrap"	^ subject.</body></methods><methods><class-id>JNIPort.JavaNonvirtual</class-id> <category>Java method calls</category><body package="JNIPort-Java-Base">callBooleanMID: aMethodID withArguments: aJNIValueArray 	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv 		CallNonvirtualBooleanMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callByteMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv		CallNonvirtualByteMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callCharMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments."	| answer |	answer := self jniEnv		CallNonvirtualCharMethodA_obj: self jniObject		class: static 		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex].	^answer asCharacter</body><body package="JNIPort-Java-Base">callDoubleMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv		CallNonvirtualDoubleMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callFloatMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv		CallNonvirtualFloatMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callIntMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv		CallNonvirtualIntMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callLongMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv		CallNonvirtualLongMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callObjectMID: aMethodID withArguments: aJNIValueArray wrapperFactory: aJVMOrJavaStatic	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments.	The last argument is an object that will be capable of wrapping (#wrapJNIObject:) the resulting	object reference.  Normally this should just be the appropriate JVM (and *don't* get it wrong!),	however if you know *for sure* what the class static of the result will be, then you can pass that	as the last argument, which saves quite a lot of logic (around half the method call overhead)	of discovering what class static to use to generate the wrapper for the result"	| answer |	answer := self jniEnv				CallNonvirtualObjectMethodA_obj: self jniObject				class: static				methodID: aMethodID				args: aJNIValueArray				onException: [:ex | self jvm throwJavaException: ex].	^aJVMOrJavaStatic wrapJNIObject: answer</body><body package="JNIPort-Java-Base">callShortMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	^self jniEnv		CallNonvirtualShortMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">callVoidMID: aMethodID withArguments: aJNIValueArray	"invoke the method defined by aMethodID on our Java object with the given	JNIValueArray of arguments"	self jniEnv		CallNonvirtualVoidMethodA_obj: self jniObject		class: static		methodID: aMethodID		args: aJNIValueArray		onException: [:ex | self jvm throwJavaException: ex]</body><body package="JNIPort-Java-Base">findMethod: aStringName signature: aJNISignature 	"answer the JavaMethodID corresponding to our Java object's method named aStringName,	and signature defined by aJNISignature"	^static jniObject		methodIDFor: aStringName		signature: aJNISignature		ifAbsentPut: 			[self jniEnv 				GetMethodID_class: static jniObject				name: aStringName				sig: aJNISignature				onException: [:ex | self jvm throwJavaException: ex]]</body></methods><methods><class-id>JNIPort.JavaNonvirtual</class-id> <category>initializing</category><body package="JNIPort-Java-Base">subject: aJavaClassInstance	"private -- set the subject JavaClassInstance we wrap"	subject := aJavaClassInstance.</body></methods><methods><class-id>JNIPort.JavaNonvirtual class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">jniObject: aJNIObject static: aJavaStatic	"private -- overridden since the only time this should ever be called is if the system is	totally buggered"	^ self shouldNotImplement.</body><body package="JNIPort-Java-Base">new	"private -- these should only be created by sending #as: to an existing JavaInstance"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">wrap: aJavaInstance asStatic: aJavaStatic	"answer a new instance which wraps the same underlying object as aJavaInstance but which treats	it as belonging to aJavaLangClass"	^ (self basicNew)		initialize;		subject: aJavaInstance;		static: aJavaStatic;		yourself.</body></methods><methods><class-id>JNIPort.JavaSignature</class-id> <category>accessing</category><body package="JNIPort-Java-Base">modifiers	^modifiers</body><body package="JNIPort-Java-Base">modifiersString	| stream |	stream := (String new: 30) writeStream.	self modifiers do: [:modifier | stream nextPutAll: modifier] separatedBy: [stream space].	^stream contents</body><body package="JNIPort-Java-Base">type	^self subclassResponsibility</body></methods><methods><class-id>JNIPort.JavaSignature</class-id> <category>private</category><body package="JNIPort-Java-Base">genericTypeNameFor: type 	^(JNITypes includesKey: type asSymbol) ifTrue: [type] ifFalse: ['Object']</body></methods><methods><class-id>JNIPort.JavaSignature</class-id> <category>testing</category><body package="JNIPort-Java-Base">isAbstract	^self modifiers includes: 'abstract'</body><body package="JNIPort-Java-Base">isFinal	^self modifiers includes: 'final'</body><body package="JNIPort-Java-Base">isOfCharType	^self type asSymbol == #char</body><body package="JNIPort-Java-Base">isOfPrimitiveType	^JNITypes includesKey: self type asSymbol</body><body package="JNIPort-Java-Base">isPrivate	^self modifiers includes: 'private'</body><body package="JNIPort-Java-Base">isStatic	^self modifiers includes: 'static'</body><body package="JNIPort-Java-Base">isStaticOrAbstract	^self isStatic or: [self isAbstract]</body><body package="JNIPort-Java-Base">isStaticOrPrivate	^self isStatic or: [self isPrivate]</body></methods><methods><class-id>JNIPort.JavaSignature</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">fromString: aString 	self subclassResponsibility</body></methods><methods><class-id>JNIPort.JavaSignature</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">prototypeMethodKeyFor: aTypeName 	^aTypeName = 'java.lang.String' 		ifTrue: ['String']		ifFalse: [self genericTypeNameFor: aTypeName]</body></methods><methods><class-id>JNIPort.JavaSignature class</class-id> <category>instance-creation</category><body package="JNIPort-Java-Base">fromString: aString	^ self new fromString: aString</body></methods><methods><class-id>JNIPort.JavaSignature class</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">initialize	" Sets the types "	JNITypes := IdentityDictionary new.	NativeTypes :=  IdentityDictionary new.		JNITypes at: #boolean put: 'Z'.	NativeTypes at: #Z put: 'boolean'.	JNITypes at: #byte put: 'B'.	NativeTypes at: #B put: 'byte'.	JNITypes at: #char put: 'C'.	NativeTypes at: #C put: 'char'.	JNITypes at: #short put: 'S'.	NativeTypes at: #S put: 'short'.	JNITypes at: #int put: 'I'.	NativeTypes at: #I put: 'int'.	JNITypes at: #long put: 'J'.	NativeTypes at: #J put: 'long'.	JNITypes at: #float put: 'F'.	NativeTypes at: #F put: 'float'.	JNITypes at: #double put: 'D'.	NativeTypes at: #D put: 'double'.	JNITypes at: #void put: 'V'.	NativeTypes at: #V put: 'void'.</body></methods><methods><class-id>JNIPort.JavaByteArray</class-id> <category>converting</category><body package="JNIPort-Java-Base">asByteArray	"answer a Smalltalk ByteArray with the same bytes (but interpreted as unsigned)	as the Java byte[] we stand for"	^self withBytesDo: [:byteArray | byteArray]</body><body package="JNIPort-Java-Base">asString	"answer a Smalltalk String with the same bytes (but interpreted as characters)	as the Java byte[] we stand for"	^self withBytesDo: [:byteArray | byteArray asString]</body></methods><methods><class-id>JNIPort.JavaByteArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[self jniEnv		GetByteArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	self elementCType newFromJNIDatum: bufferPointer]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: anInteger	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based, and that the integer should	be representable as a signed byte (i.e. in the range [-128, 127])"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType newPointerTo: anInteger.		[self jniEnv		SetByteArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jbyte</body><body package="JNIPort-Java-Base">setElements: anSBYTEArray offset: anOffset length: anInteger	"copy anInteger elements from anSBYTEArray into our Java array,	starting at the zero-based anOffset in the target.  (Actually this will	also work any byte object such as a ByteArray or String)"	self jniEnv			SetByteArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: anSBYTEArray			onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">withBytesDo: a1Block	"answer the result of evaluating a1Block, passing it a temporary BYTEArray.	Changes made to the array will be copied back into Java space.	NB: these are unsigned bytes, not Java's signed bytes.	DO NOT KEEP A REFERENCE TO THE ARRAY"		| length ptr |	length := self size.	length = 0 ifTrue: [^a1Block value: #[]].	ptr := self jniEnv		GetByteArrayElements_array: jniObject		isCopy: self jvm library nullPointer		onException: [:jex | self jvm throwJavaException: jex].	^[| bytes |	"Force interpretation as unsigned bytes."	bytes := ByteArray fromAddress: ptr length: length.	a1Block value: bytes]		ensure:			[self jniEnv				ReleaseByteArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaByteArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary SBYTEArray.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetByteArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseByteArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaByteArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[B'.</body></methods><methods><class-id>JNIPort.JavaByteArray class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">fromByteArray: aByteArray jvm: aJVM 	"answer a new JavaObject wrapping a byte[] which has been created by copying the bytes	in aByteArray"	^self from: aByteArray jvm: aJVM</body><body package="JNIPort-Java-Base">fromString: aString jvm: aJVM 	"answer a new JavaObject wrapping a java.lang.String which has been created by copying the characters	in aString"	^self from: aString jvm: aJVM</body></methods><methods><class-id>JNIPort.JavaByteArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewByteArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.JavaContainerInterface</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">clear	"invoke the receiver's public abstract clear() Java method"	self callVoidMethod: 'clear'.</body><body package="JNIPort-Java-AdditionalWrappers">remove_Object: anObject1	"answer the result of calling the receiver's public abstract remove(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'remove'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">size	"answer the result of calling the receiver's public abstract size() Java method"	^ self callIntMethod: 'size'.</body></methods><methods><class-id>JNIPort.JavaContainerInterface</class-id> <category>replacing</category><body package="JNIPort-Java-AdditionalWrappers">replaceFrom: aStartIndex to: aStopIndex with: replacementElements	"shorthand for:"	^ self asCollection replaceFrom: aStartIndex to: aStopIndex with: replacementElements.</body></methods><methods><class-id>JNIPort.JavaContainerInterface</class-id> <category>enumerating</category><body package="JNIPort-Java-AdditionalWrappers">allSatisfy: a1Block	"shorthand for:"	^ self asCollection allSatisfy: a1Block.</body><body package="JNIPort-Java-AdditionalWrappers">anySatisfy: a1Block	"shorthand for:"	^ self asCollection anySatisfy: a1Block.</body><body package="JNIPort-Java-AdditionalWrappers">collect: a1Block	"shorthand for:"	^ self asCollection collect: a1Block.</body><body package="JNIPort-Java-AdditionalWrappers">do: a1Block	"one of the root methods for &lt;Collection&gt;"	self subclassResponsibility.</body><body package="JNIPort-Java-AdditionalWrappers">inject: anObject into: a2Block	"shorthand for:"	^ self asCollection inject: anObject into: a2Block.</body><body package="JNIPort-Java-AdditionalWrappers">reject: a1Block	"shorthand for:"	^ self asCollection reject: a1Block.</body><body package="JNIPort-Java-AdditionalWrappers">select: a1Block	"shorthand for:"	^ self asCollection select: a1Block.</body></methods><methods><class-id>JNIPort.JavaContainerInterface</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">isEmpty	"answer whether the receiver contains no elements."	"we don't use:		^ self size = 0.	since size may not be a constant-time operation"	^self callBooleanMethod: 'isEmpty'</body><body package="JNIPort-Java-AdditionalWrappers">notEmpty	"answer whether the receiver contains any elements"	^ self isEmpty not.</body></methods><methods><class-id>JNIPort.JavaContainerInterface</class-id> <category>converting</category><body package="JNIPort-Java-AdditionalWrappers">asArray	"shorthand for:"	^ self asCollection asArray.</body><body package="JNIPort-Java-AdditionalWrappers">asBag	"shorthand for:"	^ self asCollection asBag.</body><body package="JNIPort-Java-AdditionalWrappers">asCollection	"answer an adaptor which makes this Java aggregate object look like something from the Smalltalk	Collection hierarchy.	In fact, for these classes we answer a CollectionAdaptor wrapped around the object.  It acts like a	proper Collection"	adaptorCache isNil ifTrue: [adaptorCache := CollectionAdaptor for: self].	^ adaptorCache.</body><body package="JNIPort-Java-AdditionalWrappers">asIdentitySet	"shorthand for:"	^IdentitySet withAll: self asCollection</body><body package="JNIPort-Java-AdditionalWrappers">asOrderedCollection	"shorthand for:"	^ self asCollection asOrderedCollection.</body><body package="JNIPort-Java-AdditionalWrappers">asSet	"shorthand for:"	^ self asCollection asSet.</body><body package="JNIPort-Java-AdditionalWrappers">asSortedCollection	"shorthand for:"	^ self asCollection asSortedCollection.</body><body package="JNIPort-Java-AdditionalWrappers">asSortedCollection: sortBlock	"shorthand for:"	^ self asCollection asSortedCollection: sortBlock.</body></methods><methods><class-id>JNIPort.JavaContainerInterface</class-id> <category>searching</category><body package="JNIPort-Java-AdditionalWrappers">detect: a1Block	"shorthand for:"	^ self asCollection detect: a1Block.</body><body package="JNIPort-Java-AdditionalWrappers">detect: a1Block ifNone: a0Block	"shorthand for:"	^ self asCollection detect: a1Block ifNone: a0Block.</body><body package="JNIPort-Java-AdditionalWrappers">includes: anObject 	^self subclassResponsibility</body></methods><methods><class-id>JNIPort.JavaContainerInterface</class-id> <category>removing</category><body package="JNIPort-Java-AdditionalWrappers">removeAll	"remove all the elements of the underlying container"	self clear.</body></methods><methods><class-id>JNIPort.JavaContainerInterface class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#clear		#isEmpty		#remove_Object:		#size	).</body></methods><methods><class-id>JNIPort.JavaUtilMap</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">asASet	"answer the result of calling the receiver's entrySet() Java method.	Note that the answer is already wrapped in a JavaUtilSet"	^ self entrySet asASet.</body><body package="JNIPort-Java-AdditionalWrappers">at: aKey ifAbsent: a0Block	"one of the root methods for &lt;Dictionary&gt;"	| answer |	"first try the lookup, if that returns null then the result *may* mean that the key wasn't present, or it	may mean that the value was null.  We only check to see if the key was present in the (hopefully	rarer) case where the lookup has already failed"	answer := self get_Object: aKey.	answer isNil ifFalse: [^ answer].	^ (self containsKey_Object: aKey)		ifTrue: [answer]		ifFalse: [a0Block value].</body><body package="JNIPort-Java-AdditionalWrappers">at: aKey put: anObject	"one of the root methods for &lt;Dictionary&gt;"	^ self put_Object: aKey Object: anObject.</body><body package="JNIPort-Java-AdditionalWrappers">keysAsSet	"answer the result of calling the receiver's keySet() Java method.	Note that the answer is already wrapped in a JavaUtilSet"	^ self keySet asASet.</body><body package="JNIPort-Java-AdditionalWrappers">valuesAsCollection	"answer the result of calling the receiver's values() Java method.	Note that the result is already wrapped in a JavaUtilCollection"	^ self values asA: #'java.util.Collection'.</body></methods><methods><class-id>JNIPort.JavaUtilMap</class-id> <category>searching</category><body package="JNIPort-Java-AdditionalWrappers">includes: anObject 	"one of the root methods for &lt;Dictionary&gt;"	^self containsValue_Object: anObject</body><body package="JNIPort-Java-AdditionalWrappers">includesKey: aKey	"one of the root methods for &lt;Dictionary&gt;"	^ self containsKey_Object: aKey.</body></methods><methods><class-id>JNIPort.JavaUtilMap</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">containsKey_Object: anObject1	"answer the result of calling the receiver's public abstract containsKey(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'containsKey'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">containsValue_Object: anObject1	"answer the result of calling the receiver's public abstract containsValue(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'containsValue'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">entrySet	"answer the result of calling the receiver's public abstract entrySet() Java method"	^ self callObjectMethod: 'entrySet' signature: '()Ljava/util/Set;'.</body><body package="JNIPort-Java-AdditionalWrappers">get_Object: anObject1	"answer the result of calling the receiver's public abstract get(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'get'				signature: '(Ljava/lang/Object;)Ljava/lang/Object;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">keySet	"answer the result of calling the receiver's public abstract keySet() Java method"	^ self callObjectMethod: 'keySet' signature: '()Ljava/util/Set;'.</body><body package="JNIPort-Java-AdditionalWrappers">putAll_Map: aMap1	"invoke the receiver's public abstract putAll(java.util.Map) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aMap1.			self				callVoidMethod: 'putAll'				signature: '(Ljava/util/Map;)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">put_Object: anObject1 Object: anObject2	"answer the result of calling the receiver's public abstract put(java.lang.Object, java.lang.Object) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				objectAt: 2 put: anObject2.			self				callObjectMethod: 'put'				signature: '(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">values	"answer the result of calling the receiver's public abstract values() Java method"	^ self callObjectMethod: 'values' signature: '()Ljava/util/Collection;'.</body></methods><methods><class-id>JNIPort.JavaUtilMap</class-id> <category>enumerating</category><body package="JNIPort-Java-AdditionalWrappers">do: a1Block	"shorthand for:"	^ self asCollection do: a1Block.</body><body package="JNIPort-Java-AdditionalWrappers">keysAndValuesDo: a2Block	"one of the root methods for &lt;Dictionary&gt;"	^ self keysAsSet do: [:each | a2Block value: each value: (self at: each ifAbsent: [])].</body></methods><methods><class-id>JNIPort.JavaUtilMap</class-id> <category>removing</category><body package="JNIPort-Java-AdditionalWrappers">removeKey: aKey ifAbsent: a0Block	"one of the root methods for &lt;Dictionary&gt;"	"have to do the pre-check since there's no way of telling whether a return value of null from the remove	means that it wasn't there or that it was there but had a null value"	(self containsKey_Object: aKey)		ifFalse: [^ a0Block value].	^ self remove_Object: aKey.</body></methods><methods><class-id>JNIPort.JavaUtilMap</class-id> <category>converting</category><body package="JNIPort-Java-AdditionalWrappers">asCollection	"answer an adaptor which makes this Java aggregate object look like something from the Smalltalk	Collection hierarchy.	In fact, for these classes we answer a DictionaryAdaptor wrapped around the object.  It acts pretty	much like a proper Dictionary (the adaptor is limited by the poor internal design of the classic	Smalltalk Collections hierarchy)"	adaptorCache isNil ifTrue: [adaptorCache := DictionaryAdaptor for: self].	^ adaptorCache.</body></methods><methods><class-id>JNIPort.JavaUtilMap class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ super generatedWrapperSelectors , #(		#clear		#containsKey_Object:		#containsValue_Object:		#entrySet		#equals_Object:		#get_Object:		#hashCode		#isEmpty		#keySet		#put_Object:Object:		#putAll_Map:		#remove_Object:		#size		#values	).</body></methods><methods><class-id>JNIPort.JavaUtilMap class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.Map'.</body></methods><methods><class-id>JNIPort.JVMWithoutCallbacks</class-id> <category>accessing</category><body package="JNIPort-Java-Base">callbackDepth	"answer how deeply nested we are in callbacks"	"we don't do callbacks, so there can't be any outstanding..."	^ 0.</body><body package="JNIPort-Java-Base">callbackRegistry	"answer our registry of callbacks, or rather answer nil since we don't support	callbacks"	^ nil.</body><body package="JNIPort-Java-Base">callbacks	"answer how many callbacks have been serviced"	"we don't do callbacks, so there can't have been any..."	^ 0.</body></methods><methods><class-id>JNIPort.JVMWithoutCallbacks</class-id> <category>locals pool</category><body package="JNIPort-Java-Base">initialLocalCapacity	"private -- answer how many slots of local references we will demand of the JVM"	"must be at least big enough for us to initialise the system without calling #increaseLocalCapacity,	actually we go for a much larger figure than that"	^ 1000.	"the JNI default is only 16 !"</body><body package="JNIPort-Java-Base">localCapacityIncrement	"private -- answer how many more slots of local references we will ask for if we	discover that we're runnig out"	^ 500.</body></methods><methods><class-id>JNIPort.JVMWithoutCallbacks</class-id> <category>Java callbacks</category><body package="JNIPort-Java-Base">asCallbackDo: a0Block	"answer the result of evaluating a0Block in an environment where we have	replaced the current JNIEnv with the currently valid one"	"we don't support callbacks, if we reach this point then we are probably buggered"	self jniAssert: [false].</body></methods><methods><class-id>JNIPort.JVMWithoutCallbacks</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initializeCallbackRegistry	"private -- called during initialisation.  We are now sufficiently initialized for a callback registry	to work; if we want one then set one up now"	"we don't"</body></methods><methods><class-id>JNIPort.JVMWithoutCallbacks</class-id> <category>finalizing</category><body package="JNIPort-Java-Base">shutdownCallbackRegistry	"private -- shutdown any callback registry we have"	"nothing to do"</body></methods><methods><class-id>JNIPort.JavaUtilCollection</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">addAll_Collection: aCollection1	"answer the result of calling the receiver's public abstract addAll(java.util.Collection) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCollection1.			self				callBooleanMethod: 'addAll'				signature: '(Ljava/util/Collection;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">add_Object: anObject1	"answer the result of calling the receiver's public abstract add(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'add'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">containsAll_Collection: aCollection1	"answer the result of calling the receiver's public abstract containsAll(java.util.Collection) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCollection1.			self				callBooleanMethod: 'containsAll'				signature: '(Ljava/util/Collection;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">contains_Object: anObject1	"answer the result of calling the receiver's public abstract contains(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'contains'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">iterator	"answer the result of calling the receiver's public abstract iterator() Java method"	^ self callObjectMethod: 'iterator' signature: '()Ljava/util/Iterator;'.</body><body package="JNIPort-Java-AdditionalWrappers">removeAll_Collection: aCollection1	"answer the result of calling the receiver's public abstract removeAll(java.util.Collection) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCollection1.			self				callBooleanMethod: 'removeAll'				signature: '(Ljava/util/Collection;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">retainAll_Collection: aCollection1	"answer the result of calling the receiver's public abstract retainAll(java.util.Collection) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCollection1.			self				callBooleanMethod: 'retainAll'				signature: '(Ljava/util/Collection;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toArray	"answer the result of calling the receiver's public abstract toArray() Java method"	^ self callObjectMethod: 'toArray' signature: '()[Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">toArray_ObjectArray: anObjects1	"answer the result of calling the receiver's public abstract toArray(java.lang.Object[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObjects1.			self				callObjectMethod: 'toArray'				signature: '([Ljava/lang/Object;)[Ljava/lang/Object;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaUtilCollection</class-id> <category>enumerating</category><body package="JNIPort-Java-AdditionalWrappers">do: a1Block	"one of the root methods for &lt;Collection&gt;"	^ self asAnIterator do: a1Block.</body></methods><methods><class-id>JNIPort.JavaUtilCollection</class-id> <category>searching</category><body package="JNIPort-Java-AdditionalWrappers">includes: aJavaObject	"answer whether the container contains aJavaObject"	^ self contains_Object: aJavaObject.</body></methods><methods><class-id>JNIPort.JavaUtilCollection</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">add: aJavaObject	"one of the root methods for &lt;Collection&gt;"	self add_Object: aJavaObject.	"discard useful return value from the Java method, and instead	answer this useless datum"	^ aJavaObject.</body><body package="JNIPort-Java-AdditionalWrappers">asAnIterator	"answer the result of calling the receiver's iterator() Java method.	Note that the answer is already wrapped in a JavaUtilIterator"	^ self iterator asAnIterator.</body></methods><methods><class-id>JNIPort.JavaUtilCollection</class-id> <category>removing</category><body package="JNIPort-Java-AdditionalWrappers">remove: aJavaObject ifAbsent: a0Block	"one of the root methods for &lt;Collection&gt;"	^ (self remove_Object: aJavaObject)		ifTrue: [aJavaObject]		ifFalse: [a0Block value].</body></methods><methods><class-id>JNIPort.JavaUtilCollection class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ super generatedWrapperSelectors , #(		#add_Object:		#addAll_Collection:		#contains_Object:		#containsAll_Collection:		#iterator		#removeAll_Collection:		#retainAll_Collection:		#toArray		#toArray_ObjectArray:	).</body></methods><methods><class-id>JNIPort.JavaUtilCollection class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.Collection'.</body></methods><methods><class-id>JNIPort.JavaUtilSet</class-id> <category>converting</category><body package="JNIPort-Java-AdditionalWrappers">asCollection	"answer an adaptor which makes this Java aggregate object look like something from the Smalltalk	Collection hierarchy.	In fact, for these classes we answer a SetAdaptor wrapped around the object.  It acts pretty much	like a proper Set (the adaptor is limited by the poor internal design of the classic Smalltalk Collections	hierarchy)"	adaptorCache isNil ifTrue: [adaptorCache := SetAdaptor for: self].	^ adaptorCache.</body></methods><methods><class-id>JNIPort.JavaUtilSet class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.Set'.</body></methods><methods><class-id>JNIPort.JavaUtilSet class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body></methods><methods><class-id>JNIPort.JavaPrimitiveVoidStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the field of this type defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: aFloat	"private -- set the field of this type defined by JNIFieldID it aJavaObject to aFloat.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	self shouldNotImplement.</body></methods><methods><class-id>JNIPort.JavaPrimitiveVoidStatic</class-id> <category>testing</category><body package="JNIPort-Java-Base">isVoid	"answer whether we stand for the primitive Java type void"	^ true.</body></methods><methods><class-id>JNIPort.JavaPrimitiveVoidStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	"can't have arrays of void!"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Void'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveVoidStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #void.</body></methods><methods><class-id>JNIPort.JavaPrimitiveVoidStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'V'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveVoidStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Void'</body></methods><methods><class-id>JNIPort.JavaCallbackHandler</class-id> <category>evaluating</category><body package="JNIPort-Java-Callbacks">executeOn: anObject withArguments: anArray	"private -- implement the heart of our function"	self subclassResponsibility.</body><body package="JNIPort-Java-Callbacks">value: aJavaObject value: aJavaArrayOrNil	"implement this part of the &lt;dyadicValueable&gt; protocol by interpretting	our symbol (in a way defined by the subclass) with aJavaObject as its	targer and with arguments from aJavaArrayOrNil.	Answers the result"	| params |	params := aJavaArrayOrNil			ifNil: [#()]			ifNotNil: [:it | it asArray].	^ self		executeOn: aJavaObject		withArguments: params.</body></methods><methods><class-id>JNIPort.JavaCallbackHandler</class-id> <category>initializing</category><body package="JNIPort-Java-Callbacks">symbol: aSymbol	"private -- set the symbol that we hold.  The use of the symbol is determined by the subclass"	symbol :=  aSymbol.</body></methods><methods><class-id>JNIPort.JavaCallbackHandler</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">symbol	"answer the Symbol we 'use'"	^ symbol.</body></methods><methods><class-id>JNIPort.JavaCallbackHandler</class-id> <category>printing</category><body package="JNIPort-Java-Callbacks">printOn: aStream 	"append a developer-centric description of ourself to aStream"	super printOn: aStream.	aStream		nextPutAll: ' selector: ';		print: symbol</body></methods><methods><class-id>JNIPort.JavaCallbackHandler class</class-id> <category>instance creation</category><body package="JNIPort-Java-Callbacks">symbol: aSymbol	"answer a new instance that holds the given symbol.  What it does with it is	determined by the subclass"	^ (self new)		symbol: aSymbol;		yourself.</body></methods><methods><class-id>JNIPort.JavaUtilSortedSet</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">comparator	"answer the result of calling the receiver's public abstract comparator() Java method"	^ self callObjectMethod: 'comparator' signature: '()Ljava/util/Comparator;'.</body><body package="JNIPort-Java-AdditionalWrappers">first	"answer the result of calling the receiver's public abstract first() Java method"	^ self callObjectMethod: 'first' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">headSet_Object: anObject1	"answer the result of calling the receiver's public abstract headSet(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'headSet'				signature: '(Ljava/lang/Object;)Ljava/util/SortedSet;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">last	"answer the result of calling the receiver's public abstract last() Java method"	^ self callObjectMethod: 'last' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">subSet_Object: anObject1 Object: anObject2	"answer the result of calling the receiver's public abstract subSet(java.lang.Object, java.lang.Object) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				objectAt: 2 put: anObject2.			self				callObjectMethod: 'subSet'				signature: '(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/SortedSet;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">tailSet_Object: anObject1	"answer the result of calling the receiver's public abstract tailSet(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'tailSet'				signature: '(Ljava/lang/Object;)Ljava/util/SortedSet;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaUtilSortedSet</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">asAComparator	"answer the result of calling the receiver's comparator() Java method.	Note that the result is already wrapped in a JavaUtilComparator"	^ self comparator ifNotNil: [:it | it asA: #'java.util.Comparator'].</body><body package="JNIPort-Java-AdditionalWrappers">headSet: aJavaObject	"answer the result of calling the receiver's headSet() Java method.	The result is already wrapped in a JavaUtilSortedSet"	^ (self headSet_Object: aJavaObject) asASortedSet.</body><body package="JNIPort-Java-AdditionalWrappers">subSet: aJavaObject upTo: anotherJavaObject	"answer the result of calling the receiver's subSet() Java method.	The result is already wrapped in a JavaUtilSortedSet"	^ (self subSet_Object: aJavaObject Object: anotherJavaObject) asASortedSet.</body><body package="JNIPort-Java-AdditionalWrappers">tailSet: aJavaObject	"answer the result of calling the receiver's tailSet() Java method.	The result is already wrapped in a JavaUtilSortedSet"	^ (self tailSet_Object: aJavaObject) asASortedSet.</body></methods><methods><class-id>JNIPort.JavaUtilSortedSet class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#comparator		#first		#headSet_Object:		#last		#subSet_Object:Object:		#tailSet_Object:	).</body></methods><methods><class-id>JNIPort.JavaUtilSortedSet class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.SortedSet'.</body></methods><methods><class-id>JNIPort.JavaLangNumber</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">doubleValue	"answer the result of calling the receiver's public abstract doubleValue() Java method"	^ self callDoubleMethod: 'doubleValue'.</body><body package="JNIPort-Java-AdditionalWrappers">floatValue	"answer the result of calling the receiver's public abstract floatValue() Java method"	^ self callFloatMethod: 'floatValue'.</body><body package="JNIPort-Java-AdditionalWrappers">intValue	"answer the result of calling the receiver's public abstract intValue() Java method"	^ self callIntMethod: 'intValue'.</body><body package="JNIPort-Java-AdditionalWrappers">longValue	"answer the result of calling the receiver's public abstract longValue() Java method"	^ self callLongMethod: 'longValue'.</body></methods><methods><class-id>JNIPort.JavaLangNumber</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">byteValue	"answer the result of calling the receiver's public byteValue() Java method"	^ self callByteMethod: 'byteValue'.</body><body package="JNIPort-Java-AdditionalWrappers">shortValue	"answer the result of calling the receiver's public shortValue() Java method"	^ self callShortMethod: 'shortValue'.</body></methods><methods><class-id>JNIPort.JavaLangNumber class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#byteValue		#doubleValue		#floatValue		#intValue		#longValue		#shortValue	).</body></methods><methods><class-id>JNIPort.JavaLangNumber class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Number'.</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>accessing</category><body package="JNIPort-JNI">isGlobalRef	"answer whether the receiver represents a JNI global reference"	^self isLocalRef not</body><body package="JNIPort-JNI">isLocalRef	"answer whether the receiver represents a JNI local reference"	^isLocalRef</body><body package="JNIPort-JNI">javaIdentityHash	^javaIdentityHash</body><body package="JNIPort-JNI">javaIdentityHash: anInteger	javaIdentityHash := anInteger</body><body package="JNIPort-JNI">jniObject	^self</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>operations</category><body package="JNIPort-JNI">getGlobalRef: aJNIEnv onException: a1Block 	"create a new JNIGlobalRef of the appropriate sub-class corresponding to our own, note that the existing ref is *not* cleared. Answers a NULL pointer if the receiver is a weak global reference and our object has been garbage collected."	^aJNIEnv NewGlobalRef_obj: self onException: a1Block</body><body package="JNIPort-JNI">getLocalRef: aJNIEnv onException: a1Block 	"create a new JNILocalRef of the appropriate sub-class corresponding to our own,	note that the existing ref is *not* cleared. Answers a NULL pointer if the receiver is a weak global reference and our object has been garbage collected."	^aJNIEnv NewLocalRef_obj: self onException: a1Block</body><body package="JNIPort-JNI">getWeakGlobalRef: aJNIEnv onException: a1Block	"create a new JNIWeakGlobalRef pointing to the same Java object as we do,	note that the existing ref is *not* cleared. Answers a NULL pointer if the receiver is a weak global reference and our object has been garbage collected."	^ aJNIEnv		NewWeakGlobalRef_obj: self		onException: a1Block.</body><body package="JNIPort-JNI">releaseLocalRef: aJNIEnv	"release the JNI lobal reference we represent"	isReleased := true.	externalData beNonGarbageCollectable.	aJNIEnv DeleteLocalRef_obj: self onException: [:exception | ]</body><body package="JNIPort-JNI">releaseRef: aJNIEnv	"release the JNI global reference we represent"	"Avoid race conditions where finalization and an explicit shutdown of the JVM compete for releasing the reference."	isReleased ifTrue: [^self].	isReleased := true.	externalData beNonGarbageCollectable.	self isLocalRef		ifTrue: [aJNIEnv DeleteLocalRef_obj: self]		ifFalse: [aJNIEnv DeleteGlobalRef_obj: self]</body><body package="JNIPort-JNI">releaseRef: aJNIEnv onException: a1Block	"release the JNI global reference we represent"	"Avoid race conditions where finalization and an explicit shutdown of the JVM compete for releasing the reference."	isReleased ifTrue: [^self].	isReleased := true.	externalData beNonGarbageCollectable.	self isLocalRef		ifTrue: [aJNIEnv DeleteLocalRef_obj: self onException: a1Block]		ifFalse: [aJNIEnv DeleteGlobalRef_obj: self onException: a1Block]</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>private</category><body package="JNIPort-JNI">myDependents	"Answer nil - JNIObjects don't have dependents."	^nil</body><body package="JNIPort-JNI">myDependents: dependentsOrNil	"Do nothing - JNIObjects don't have dependents."</body><body package="JNIPort-JNI">myEventTable	"Answer nil - JNIObjects don't raise events."	^nil</body><body package="JNIPort-JNI">myEventTable: anObject 	"Do nothing - JNIObjects don't raise events."</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>system primitives</category><body package="JNIPort-JNI">become: anObject 	"Overridden for optimization. JNIObjects don't have dependents or eventTables, so swapping them is not necessary."	self primBecome: anObject.	^self</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>initialize-release</category><body package="JNIPort-JNI">beGlobal	isLocalRef := false</body><body package="JNIPort-JNI">beLocal	isLocalRef := true</body><body package="JNIPort-JNI">initialize	isLocalRef := true.	isReleased := false</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIClass	^JNIClass newFrom: self</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>examples</category><body package="JNIPort-JNI">equals: aJNIReference jniEnv: aJNIEnv	"use aJNIEnv to answer the result of calling the equals() Java method with aJNIObject as its parameter.	This is provided mainly as an illustration of the kinds of things you have to do to use raw JNI"	| class mid byte |	aJNIReference isNull ifTrue: [^self isNull].	"note that this implementation doesn't even make use of the few convenience	features defined in this package"	^	["get the class"	class := aJNIEnv GetObjectClass_obj: self onException: [:jex | ^nil].	"find the method ID"	mid := aJNIEnv				GetMethodID_class: class				name: 'equals'				sig: '(Ljava/lang/Object;)Z'				onException: [:jex | ^nil].	"create the argument array"	byte := JNIValueArray withJavaObject: aJNIReference				freeAfter: 					[:args |					"call the method"					aJNIEnv						CallBooleanMethodA_obj: self						methodID: mid						args: args						onException: [:jex | nil]].	"the result is already decoded"	byte]			ensure: [class isNil ifFalse: [aJNIEnv DeleteLocalRef_obj: class]]</body><body package="JNIPort-JNI">toString: aJNIEnv 	"use aJNIEnv to convert the receiver to a Smalltalk String.	This is provided mainly as an illustration of the kinds of things you have to	do to use raw JNI"	| class mid jstring length bytes byteArray |	self isNull ifTrue: [^nil].	"note that this implementation doesn't even make use of the few convenience	features defined in this package"	^	["get the class"	class := aJNIEnv GetObjectClass_obj: self onException: [:jex | ^nil].	"find the method ID"	mid := aJNIEnv 				GetMethodID_class: class				name: 'toString'				sig: '()Ljava/lang/String;'				onException: [:jex | ^nil].	"call the method (it has no args which makes it simpler)"	jstring := aJNIEnv 				CallObjectMethodA_obj: self				methodID: mid				args: nil				onException: [:jex | ^nil].	"get the length of the string in bytes"	length := aJNIEnv GetStringUTFLength_str: jstring				onException: [:jex | ^nil].	length = 0 ifTrue: [^''].	"fish out the bytes from the jstring; note that we must remember to give them back later"	bytes := aJNIEnv 				GetStringUTFChars_str: jstring				isCopy: nil				onException: [:jex | ^nil].	"and turn them into a Smalltalk string -- the bytes are encoded in Java modified UTF-8"	byteArray := ByteArray fromAddress: bytes length: length.	String fromJavaModifiedUTF8EncodedByteArray: byteArray] 			ensure: 				[bytes isNil 					ifFalse: 						[aJNIEnv 							ReleaseStringUTFChars_str: jstring							chars: bytes							onException: [:jex | ]].				jstring isNil ifFalse: [aJNIEnv DeleteLocalRef_obj: jstring].				class isNil ifFalse: [aJNIEnv DeleteLocalRef_obj: class]]</body></methods><methods><class-id>JNIPort.JNIObject</class-id> <category>*JNIPort-Java-Base</category><body package="JNIPort-Java-Base">asJavaObject: aJVM	"answer a managed JavaObject which corresponds to the same underlying	object as the receiver and which is managed by aJVM.	Note that it is an error for a managed object to be owned by more than one	JVM or to change JVMs"	^ aJVM wrapJNIObject: self.</body></methods><methods><class-id>JNIPort.JNIObject class</class-id> <category>external accessing</category><body package="JNIPort-JNI">baseCType	^JNIPortJNIInterface current jobject</body></methods><methods><class-id>JNIPort.JNIObject class</class-id> <category>analysing</category><body package="JNIPort-JNI">refsInUse	"answer a count of how many non-null instances still exist		JNIObject refsInUse. 		JNIClass refsInUse. 		JNIWeakGlobalReference refsInUse. 	"	| count |	count := 0.	self allSubInstancesDo: [:each | each isNull ifFalse: [count := count + 1]].	^count</body></methods><methods><class-id>JNIPort.JNIObject class</class-id> <category>instance creation</category><body package="JNIPort-JNI">new	^super new initialize</body></methods><methods><class-id>JNIPort.JavaMessageSend</class-id> <category>evaluating</category><body package="JNIPort-Java-Callbacks">executeOn: anObject withArguments: anArray	"private -- implement the heart of our function"	^ anObject perform: symbol withArguments: anArray.</body></methods><methods><class-id>JNIPort.JavaIoWriter</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">write_charArray: chars1 int: int1 int: int2	"invoke the receiver's public abstract write(char[], int, int) Java method"	JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: chars1;				intAt: 2 put: int1;				intAt: 3 put: int2.			self callVoidMethod: 'write' signature: '([CII)V' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaIoWriter</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">append_CharSequence: aCharSequence1	"answer the result of calling the receiver's public append(java.lang.CharSequence) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCharSequence1.			self				callObjectMethod: 'append'				signature: '(Ljava/lang/CharSequence;)Ljava/io/Writer;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">append_CharSequence: aCharSequence1 int: int1 int: int2	"answer the result of calling the receiver's public append(java.lang.CharSequence, int, int) Java method"	^JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: aCharSequence1;				intAt: 2 put: int1;				intAt: 3 put: int2.			self				callObjectMethod: 'append'				signature: '(Ljava/lang/CharSequence;II)Ljava/io/Writer;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">append_char: char1	"answer the result of calling the receiver's public append(char) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args charAt: 1 put: char1.			self				callObjectMethod: 'append'				signature: '(C)Ljava/io/Writer;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaIoWriter</class-id> <category>writing</category><body package="JNIPort-Java-AdditionalWrappers">next: aSize putAll: aSequenceableCollection startingAt: anIndex	"add aSize elements of aSequenceableCollection from anIndex.	Answers aSequenceableCollection"	"ugly, should double-dispatch this"	((aSequenceableCollection isKindOf: JavaCharArray) or: [aSequenceableCollection isKindOf: Array])		ifTrue: [self writeChars: aSequenceableCollection from: anIndex to: anIndex + aSize]		ifFalse: [self writeString: aSequenceableCollection from: anIndex to: anIndex + aSize].	^ aSequenceableCollection.</body><body package="JNIPort-Java-AdditionalWrappers">nextPutAll: aSequenceableCollection	"add aSequenceableCollection.	Answers aSequenceableCollection"	"ugly, should double-dispatch this"	((aSequenceableCollection isKindOf: JavaCharArray) or: [aSequenceableCollection isKindOf: Array])		ifTrue: [self writeChars: aSequenceableCollection]		ifFalse: [self writeString: aSequenceableCollection].	^ aSequenceableCollection.</body><body package="JNIPort-Java-AdditionalWrappers">writeChars: aCharacterArray	"invoke the receiver's write() Java method; the argument can be a Java char[], a	Smalltalk ByteArray, or a String"	self write_charArray: (aCharacterArray asJavaCharArray: self jvm).</body><body package="JNIPort-Java-AdditionalWrappers">writeChars: aCharArray from: aStartIndex to: aStopIndex	"invoke the receiver's write() Java method, the argument can be a Java char[], a Smalltalk	ByteArray, or a String.  Note that the start and stop positions are 1-based, and that aStopIndex	*is* included in the range unlike the real Java method"	self		write_charArray: (aCharArray asJavaCharArray: self jvm)		int: aStartIndex - 1		int: aStopIndex - aStartIndex + 1.</body><body package="JNIPort-Java-AdditionalWrappers">writeString: aJavaString	"invoke the receiver's write() Java method, the argument can be a Java String, a	Smalltalk ByteArray, or a String"	self write_String: aJavaString.</body><body package="JNIPort-Java-AdditionalWrappers">writeString: aJavaString from: aStartIndex to: aStopIndex	"invoke the receiver's write() Java method, the argument can be a Java String, a Smalltalk	ByteArray, or a String.  Note that the start and stop positions are 1-based, and that aStopIndex	*is* included in the range unlike the real Java method"	self		write_String: aJavaString		int: aStartIndex - 1		int: aStopIndex - aStartIndex + 1.</body></methods><methods><class-id>JNIPort.JavaIoWriter</class-id> <category>Java-public</category><body package="JNIPort-Java-AdditionalWrappers">write_String: aString1	"invoke the receiver's public write(java.lang.String) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args objectAt: 1 put: javaString1.			self				callVoidMethod: 'write'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">write_String: aString1 int: int1 int: int2	"invoke the receiver's public write(java.lang.String, int, int) Java method"	JNIValueArray new: 3		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1;				intAt: 3 put: int2.			self				callVoidMethod: 'write'				signature: '(Ljava/lang/String;II)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">write_charArray: chars1	"invoke the receiver's public write(char[]) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: chars1.			self callVoidMethod: 'write' signature: '([C)V' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaIoWriter</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">isBinary	"answer whether we write bytes rather than chars"	^ false.</body></methods><methods><class-id>JNIPort.JavaIoWriter class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#append_char:		#append_CharSequence:		#append_CharSequence:int:int:		#close		#flush		#write_charArray:		#write_charArray:int:int:		#write_int:		#write_String:		#write_String:int:int:	).</body></methods><methods><class-id>JNIPort.JavaIoWriter class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.io.Writer'.</body></methods><methods><class-id>JNIPort.JavaUtilComparator</class-id> <category>comparing</category><body package="JNIPort-Java-AdditionalWrappers">compare: aJavaObject with: anotherJavaObject	"answer the result of calling the receiver's compare() Java method"	^ self compare_Object: aJavaObject Object: anotherJavaObject.</body></methods><methods><class-id>JNIPort.JavaUtilComparator</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">compare_Object: anObject1 Object: anObject2	"answer the result of calling the receiver's public abstract compare(java.lang.Object, java.lang.Object) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				objectAt: 2 put: anObject2.			self				callIntMethod: 'compare'				signature: '(Ljava/lang/Object;Ljava/lang/Object;)I'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaUtilComparator class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#compare_Object:Object:	).</body></methods><methods><class-id>JNIPort.JavaUtilComparator class</class-id> <category>constants</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.util.Comparator'.</body></methods><methods><class-id>JNIPort.StaticJavaLangClassLoader</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">getSystemClassLoader	"answer the result of calling the receiver's public static getSystemClassLoader() Java method"	^ self callObjectMethod: 'getSystemClassLoader' signature: '()Ljava/lang/ClassLoader;'.</body><body package="JNIPort-Java-Base">getSystemResourceAsStream_String: aString1	"answer the result of calling the receiver's public static getSystemResourceAsStream(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getSystemResourceAsStream'				signature: '(Ljava/lang/String;)Ljava/io/InputStream;'				withArguments: args]</body><body package="JNIPort-Java-Base">getSystemResource_String: aString1	"answer the result of calling the receiver's public static getSystemResource(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getSystemResource'				signature: '(Ljava/lang/String;)Ljava/net/URL;'				withArguments: args]</body><body package="JNIPort-Java-Base">getSystemResources_String: aString1	"answer the result of calling the receiver's public static getSystemResources(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getSystemResources'				signature: '(Ljava/lang/String;)Ljava/util/Enumeration;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangClassLoader</class-id> <category>constants</category><body package="JNIPort-Java-Base">hasCanonicalInstancesByDefault	"answer whether we should have canonical instances at startup.	(if not then it can always be turned on later)"	"since our instances can hold some local data it best to make them canonical"	^ true.</body></methods><methods><class-id>JNIPort.StaticJavaLangClassLoader class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.ClassLoader'.</body></methods><methods><class-id>JNIPort.StaticJavaLangClassLoader class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#getSystemClassLoader		#getSystemResource_String:		#getSystemResourceAsStream_String:		#getSystemResources_String:	).</body></methods><methods><class-id>JNIPort.StaticJavaNetURLClassLoader</class-id> <category>helpers</category><body package="JNIPort-Java-Base">asURL: aString 	"private -- answer a String which represents the given string filename, directory name, or URL converted	into an URL.	Note that this only works with Smalltalk strings"	| stream answer |	#CUtodo.	"this is seriously hacky..."	"does it look like an URL already ?"	(aString indexOf: $:) &gt; 2 ifTrue: [^aString].	stream := (String new writeStream)				nextPutAll: 'file:///';				yourself.	aString do: 			[:ch | 			(ch isAlphaNumeric or: ['.-/?' includes: ch]) 				ifTrue: [stream nextPut: ch]				ifFalse: 					[ch = $\ 						ifTrue: [stream nextPut: $/]						ifFalse: 							[stream nextPut: $%.							ch asInteger &lt; 16r10 ifTrue: [stream nextPut: $0].							ch asInteger printOn: stream base: 16]]].	answer := stream contents.	((answer endsWith: '/') or: [answer asLowercase endsWith: '.jar']) 		ifFalse: [answer := answer , '/'].	^answer</body><body package="JNIPort-Java-Base">splitPath: aString	"private -- answer a search path derived by parsing the ;-separated list of URLs, filenames, or	directory names"	aString isNil ifTrue: [^#()].	^((aString subStrings: ';') select: [:each | each notEmpty])		collect: [:each | self asURL: each]</body></methods><methods><class-id>JNIPort.StaticJavaNetURLClassLoader</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer a new instance of java.net.URLClassLoader that has no explicit parent	classloader and no URLs to search (usefull for holding dynamically generated	classes)"	^ self newURLs: #() parent: nil.</body><body package="JNIPort-Java-Base">newParent: aJavaLangClassLoader	"answer a new instance of java.net.URLClassLoader that has the given	aJavaLangClassLoader parent but no collection of URLs to search"	^ self newURLs: #() parent: aJavaLangClassLoader.</body><body package="JNIPort-Java-Base">newPath: aString parent: aJavaLangClassLoader	"answer a new instance of java.net.URLClassLoader that has the given	aJavaLangClassLoader parent and a search path derived by parsing the	given ;-separated list of URLs, filenames or directory names.	NB: we have to be a bit, um, heuristic about how we recognise and convert file/dir names"	^ self		newURLs: (self splitPath: aString)		parent: aJavaLangClassLoader.</body><body package="JNIPort-Java-Base">newURLs: aCollectionOfStrings	"answer a new instance of java.net.URLClassLoader that has no explicit parent	classloader and the given collection of URLs to search"	^ self newURLs: aCollectionOfStrings parent: nil.</body><body package="JNIPort-Java-Base">newURLs: aCollectionOfStrings parent: aJavaLangClassLoader	"answer a new instance of java.net.URLClassLoader that has the given	aJavaLangClassLoader parent and the given collection of URLs to search"	| urlClass urls |	#CUtodo.  "should we be trying to use our own classloader ?"	urlClass := self jvm findClass: #'java.net.URL'.	urls := aCollectionOfStrings			ifNil: [#()]			ifNotNil: [:them | them collect: [:each | urlClass new_String: each]].	urls := urlClass newArrayWithAll: urls.	"needless to say, the more general form of the method /isn't/ more general..."	^ aJavaLangClassLoader		ifNil: [self newInstance_URLArray: urls]		ifNotNil: [:it | self newInstance_URLArray: urls ClassLoader: it].</body></methods><methods><class-id>JNIPort.StaticJavaNetURLClassLoader</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">newInstance_URLArray: anURLs1	"answer the result of calling the receiver's public static newInstance(java.net.URL[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anURLs1.			self				callObjectMethod: 'newInstance'				signature: '([Ljava/net/URL;)Ljava/net/URLClassLoader;'				withArguments: args]</body><body package="JNIPort-Java-Base">newInstance_URLArray: anURLs1 ClassLoader: aClassLoader1	"answer the result of calling the receiver's public static newInstance(java.net.URL[], java.lang.ClassLoader) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anURLs1;				objectAt: 2 put: aClassLoader1.			self				callObjectMethod: 'newInstance'				signature: '([Ljava/net/URL;Ljava/lang/ClassLoader;)Ljava/net/URLClassLoader;'				withArguments: args]</body><body package="JNIPort-Java-Base">new_URLArray: anURLs1	"answer the result of calling the receiver's public new(java.net.URL[]) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anURLs1.			self callConstructorSignature: '([Ljava/net/URL;)V' withArguments: args]</body><body package="JNIPort-Java-Base">new_URLArray: anURLs1 ClassLoader: aClassLoader1	"answer the result of calling the receiver's public new(java.net.URL[], java.lang.ClassLoader) Java constructor"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anURLs1;				objectAt: 2 put: aClassLoader1.			self callConstructorSignature: '([Ljava/net/URL;Ljava/lang/ClassLoader;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">new_URLArray: anURLs1 ClassLoader: aClassLoader1 URLStreamHandlerFactory: anURLStreamHandlerFactory1	"answer the result of calling the receiver's public new(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory) Java constructor"	^JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: anURLs1;				objectAt: 2 put: aClassLoader1;				objectAt: 3 put: anURLStreamHandlerFactory1.			self				callConstructorSignature: '([Ljava/net/URL;Ljava/lang/ClassLoader;Ljava/net/URLStreamHandlerFactory;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaNetURLClassLoader class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new_URLArray:		#new_URLArray:ClassLoader:		#new_URLArray:ClassLoader:URLStreamHandlerFactory:	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#newInstance_URLArray:		#newInstance_URLArray:ClassLoader:	).</body></methods><methods><class-id>JNIPort.StaticJavaNetURLClassLoader class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.net.URLClassLoader'.</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv</class-id> <category>checked JNI functions</category><body package="JNIPort-JNI">AllocObject_class: argument1 onException: a1Block	"mechanically generated method to invoke #AllocObject:class: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #AllocObject with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallBooleanMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallBooleanMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallBooleanMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallByteMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallByteMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallByteMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallCharMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallCharMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallCharMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallDoubleMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallDoubleMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallDoubleMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallFloatMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallFloatMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallFloatMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallIntMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallIntMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallIntMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallLongMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallLongMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallLongMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualBooleanMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualBooleanMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualBooleanMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualByteMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualByteMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualByteMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualCharMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualCharMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualCharMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualDoubleMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualDoubleMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualDoubleMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualFloatMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualFloatMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualFloatMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualIntMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualIntMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualIntMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualLongMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualLongMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualLongMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualObjectMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualObjectMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualObjectMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualShortMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualShortMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualShortMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallNonvirtualVoidMethodA_obj: argument1 class: argument2 methodID: argument3 args: argument4 onException: a1Block	"mechanically generated method to invoke #CallNonvirtualVoidMethodA:obj:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #CallNonvirtualVoidMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallObjectMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallObjectMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallObjectMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallShortMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallShortMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallShortMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">CallStaticBooleanMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticBooleanMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticBooleanMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticByteMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticByteMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticByteMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticCharMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticCharMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticCharMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticDoubleMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticDoubleMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticDoubleMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticFloatMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticFloatMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticFloatMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticIntMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticIntMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticIntMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticLongMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticLongMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticLongMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticObjectMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticObjectMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticObjectMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticShortMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticShortMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticShortMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallStaticVoidMethodA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallStaticVoidMethodA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #CallStaticVoidMethodA		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">CallVoidMethodA_obj: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #CallVoidMethodA:obj:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #CallVoidMethodA with: parameters onException: a1Block</body><body package="JNIPort-JNI">DefineClass_name: argument1 loader: argument2 buf: argument3 len: argument4 onException: a1Block	"mechanically generated method to invoke #DefineClass:name:loader:buf:len: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #DefineClass with: parameters onException: a1Block</body><body package="JNIPort-JNI">DeleteGlobalRef_obj: argument1 onException: a1Block	"mechanically generated method to invoke #DeleteGlobalRef:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #DeleteGlobalRef with: parameters onException: a1Block</body><body package="JNIPort-JNI">DeleteLocalRef_obj: argument1 onException: a1Block	"mechanically generated method to invoke #DeleteLocalRef:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #DeleteLocalRef with: parameters onException: a1Block</body><body package="JNIPort-JNI">DeleteWeakGlobalRef_obj: argument1 onException: a1Block	"mechanically generated method to invoke #DeleteWeakGlobalRef:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self		checkedCall: #DeleteWeakGlobalRef		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">EnsureLocalCapacity_capacity: argument1 onException: a1Block	"mechanically generated method to invoke #EnsureLocalCapacity:capacity: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self		checkedCall: #EnsureLocalCapacity		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">FatalError_msg: argument1 onException: a1Block	"mechanically generated method to invoke #FatalError:msg: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #FatalError with: parameters onException: a1Block</body><body package="JNIPort-JNI">FindClass_name: argument1 onException: a1Block	"mechanically generated method to invoke #FindClass:name: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #FindClass with: parameters onException: a1Block</body><body package="JNIPort-JNI">FromReflectedField_field: argument1 onException: a1Block	"mechanically generated method to invoke #FromReflectedField:field: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #FromReflectedField with: parameters onException: a1Block</body><body package="JNIPort-JNI">FromReflectedMethod_method: argument1 onException: a1Block	"mechanically generated method to invoke #FromReflectedMethod:method: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self		checkedCall: #FromReflectedMethod		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetArrayLength_array: argument1 onException: a1Block	"mechanically generated method to invoke #GetArrayLength:array: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #GetArrayLength with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetBooleanArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetBooleanArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetBooleanArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetBooleanArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetBooleanArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #GetBooleanArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetBooleanField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetBooleanField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetBooleanField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetByteArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetByteArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetByteArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetByteArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetByteArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #GetByteArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetByteField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetByteField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetByteField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetCharArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetCharArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetCharArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetCharArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetCharArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #GetCharArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetCharField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetCharField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetCharField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetDirectBufferAddress_buf: argument1 onException: a1Block	"mechanically generated method to invoke #GetDirectBufferAddress:buf: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self		checkedCall: #GetDirectBufferAddress		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetDirectBufferCapacity_buf: argument1 onException: a1Block	"mechanically generated method to invoke #GetDirectBufferCapacity:buf: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self		checkedCall: #GetDirectBufferCapacity		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetDoubleArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetDoubleArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetDoubleArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetDoubleArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetDoubleArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #GetDoubleArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetDoubleField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetDoubleField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetDoubleField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetFieldID_class: argument1 name: argument2 sig: argument3 onException: a1Block	"mechanically generated method to invoke #GetFieldID:class:name:sig: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #GetFieldID with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetFloatArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetFloatArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetFloatArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetFloatArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetFloatArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #GetFloatArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetFloatField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetFloatField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetFloatField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetIntArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetIntArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetIntArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetIntArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetIntArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #GetIntArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetIntField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetIntField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetIntField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetJavaVM_vm: argument1 onException: a1Block	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #GetJavaVM with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetLongArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetLongArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetLongArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetLongArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetLongArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #GetLongArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetLongField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetLongField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetLongField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetMethodID_class: argument1 name: argument2 sig: argument3 onException: a1Block	"mechanically generated method to invoke #GetMethodID:class:name:sig: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #GetMethodID with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetObjectArrayElement_array: argument1 index: argument2 onException: a1Block	"mechanically generated method to invoke #GetObjectArrayElement:array:index: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetObjectArrayElement		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetObjectClass_obj: argument1 onException: a1Block	"mechanically generated method to invoke #GetObjectClass:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #GetObjectClass with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetObjectField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetObjectField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetObjectField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetObjectRefType_obj: argument1 onException: a1Block	"mechanically generated method to invoke #GetObjectField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #GetObjectRefType with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetPrimitiveArrayCritical_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetPrimitiveArrayCritical:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetPrimitiveArrayCritical		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetShortArrayElements_array: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetShortArrayElements:array:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetShortArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetShortArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetShortArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #GetShortArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetShortField_obj: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetShortField:obj:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetShortField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStaticBooleanField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticBooleanField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetStaticBooleanField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetStaticByteField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticByteField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetStaticByteField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStaticCharField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticCharField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetStaticCharField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStaticDoubleField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticDoubleField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetStaticDoubleField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetStaticFieldID_class: argument1 name: argument2 sig: argument3 onException: a1Block	"mechanically generated method to invoke #GetStaticFieldID:class:name:sig: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #GetStaticFieldID with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStaticFloatField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticFloatField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetStaticFloatField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetStaticIntField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticIntField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetStaticIntField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStaticLongField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticLongField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetStaticLongField with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStaticMethodID_class: argument1 name: argument2 sig: argument3 onException: a1Block	"invoke #GetStaticMethodID and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #GetStaticMethodID with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStaticObjectField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticObjectField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetStaticObjectField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetStaticShortField_class: argument1 fieldID: argument2 onException: a1Block	"mechanically generated method to invoke #GetStaticShortField:class:fieldID: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #GetStaticShortField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">GetStringChars_str: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetStringChars:str:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetStringChars with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStringCritical_str: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetStringCritical:str:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetStringCritical with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStringLength_str: argument1 onException: a1Block	"mechanically generated method to invoke #GetStringLength:str: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #GetStringLength with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStringRegion_str: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetStringRegion:str:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #GetStringRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStringUTFChars_str: argument1 isCopy: argument2 onException: a1Block	"mechanically generated method to invoke #GetStringUTFChars:str:isCopy: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #GetStringUTFChars with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStringUTFLength_str: argument1 onException: a1Block	"mechanically generated method to invoke #GetStringUTFLength:str: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #GetStringUTFLength with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetStringUTFRegion_str: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #GetStringUTFRegion:str:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #GetStringUTFRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">GetSuperclass_sub: argument1 onException: a1Block	"mechanically generated method to invoke #GetSuperclass:sub: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #GetSuperclass with: parameters onException: a1Block</body><body package="JNIPort-JNI">IsAssignableFrom_sub: argument1 sup: argument2 onException: a1Block	"mechanically generated method to invoke #IsAssignableFrom:sub:sup: and then check for exceptions"	| parameters |	(argument1 == argument2 or: [argument1 asJNIParameter = argument2 asJNIParameter])		ifTrue: [^true].	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #IsAssignableFrom with: parameters onException: a1Block</body><body package="JNIPort-JNI">IsInstanceOf_obj: argument1 class: argument2 onException: a1Block	"mechanically generated method to invoke #IsInstanceOf:obj:class: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #IsInstanceOf with: parameters onException: a1Block</body><body package="JNIPort-JNI">IsSameObject_obj1: argument1 obj2: argument2 onException: a1Block	"mechanically generated method to invoke #IsSameObject:obj:obj: and then check for exceptions"	| parameters |	(argument1 == argument2		or: [argument1 asJNIParameter = argument2 asJNIParameter]) ifTrue: [^true].	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #IsSameObject with: parameters onException: a1Block</body><body package="JNIPort-JNI">MonitorEnter_obj: argument1 onException: a1Block	"mechanically generated method to invoke #MonitorEnter:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #MonitorEnter with: parameters onException: a1Block</body><body package="JNIPort-JNI">MonitorExit_obj: argument1 onException: a1Block	"mechanically generated method to invoke #MonitorExit:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #MonitorExit with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewBooleanArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewBooleanArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewBooleanArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewByteArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewByteArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewByteArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewCharArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewCharArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewCharArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewDirectByteBuffer_address: argument1 capacity: argument2 onException: a1Block	"mechanically generated method to invoke #NewDirectByteBuffer:address:capacity: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #NewDirectByteBuffer		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">NewDoubleArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewDoubleArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewDoubleArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewFloatArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewFloatArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewFloatArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewGlobalRef_obj: argument1 onException: a1Block	"mechanically generated method to invoke #NewGlobalRef:obj: and then check for exceptions"	| jniObject parameters |	parameters := Array with: externalData with: argument1.	jniObject := self				checkedCall: #NewGlobalRef				with: parameters				onException: a1Block.	jniObject beGlobal.	^jniObject</body><body package="JNIPort-JNI">NewIntArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewIntArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewIntArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewLocalRef_obj: argument1 onException: a1Block	"mechanically generated method to invoke #NewLocalRef:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewLocalRef with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewLongArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewLongArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewLongArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewObjectA_class: argument1 methodID: argument2 args: argument3 onException: a1Block	"mechanically generated method to invoke #NewObjectA:class:methodID:args: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #NewObjectA with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewObjectArray_len: argument1 class: argument2 init: argument3 onException: a1Block	"mechanically generated method to invoke #NewObjectArray:len:class:init: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #NewObjectArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewShortArray_len: argument1 onException: a1Block	"mechanically generated method to invoke #NewShortArray:len: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewShortArray with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewStringUTF_utf: argument1 onException: a1Block	"mechanically generated method to invoke #NewStringUTF:utf: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewStringUTF with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewString_unicode: argument1 len: argument2 onException: a1Block	"mechanically generated method to invoke #NewString:unicode:len: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #NewString with: parameters onException: a1Block</body><body package="JNIPort-JNI">NewWeakGlobalRef_obj: argument1 onException: a1Block	"invoke #NewWeakGlobalRef:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #NewWeakGlobalRef with: parameters onException: a1Block</body><body package="JNIPort-JNI">PopLocalFrame_result: argument1 onException: a1Block	"mechanically generated method to invoke #PopLocalFrame:result: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #PopLocalFrame with: parameters onException: a1Block</body><body package="JNIPort-JNI">PushLocalFrame_capacity: argument1 onException: a1Block	"mechanically generated method to invoke #PushLocalFrame:capacity: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #PushLocalFrame with: parameters onException: a1Block</body><body package="JNIPort-JNI">RegisterNatives_class: argument1 methods: argument2 nMethods: argument3 onException: a1Block	"mechanically generated method to invoke #RegisterNatives:class:methods:nMethods: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #RegisterNatives with: parameters onException: a1Block</body><body package="JNIPort-JNI">ReleaseBooleanArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseBooleanArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseBooleanArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseByteArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseByteArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseByteArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseCharArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseCharArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseCharArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseDoubleArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseDoubleArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseDoubleArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseFloatArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseFloatArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseFloatArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseIntArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseIntArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseIntArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseLongArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseLongArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseLongArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleasePrimitiveArrayCritical_array: argument1 carray: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleasePrimitiveArrayCritical:array:carray:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleasePrimitiveArrayCritical		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseShortArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"mechanically generated method to invoke #ReleaseShortArrayElements:array:elems:mode: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #ReleaseShortArrayElements		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseStringChars_str: argument1 chars: argument2 onException: a1Block	"mechanically generated method to invoke #ReleaseStringChars:str:chars: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #ReleaseStringChars with: parameters onException: a1Block</body><body package="JNIPort-JNI">ReleaseStringCritical_str: argument1 cstring: argument2 onException: a1Block	"mechanically generated method to invoke #ReleaseStringCritical:str:cstring: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #ReleaseStringCritical		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">ReleaseStringUTFChars_str: argument1 chars: argument2 onException: a1Block	"mechanically generated method to invoke #ReleaseStringUTFChars:str:chars: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self		checkedCall: #ReleaseStringUTFChars		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetBooleanArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetBooleanArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #SetBooleanArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetBooleanField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetBooleanField:obj:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #SetBooleanField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetByteArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetByteArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #SetByteArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetByteField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetByteField:obj:fieldID:val: and then check for exceptions"	| parameters |	self byteType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetByteField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetCharArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetCharArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #SetCharArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetCharField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetCharField:obj:fieldID:val: and then check for exceptions"	| parameters |	self charType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetCharField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetDoubleArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetDoubleArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #SetDoubleArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetDoubleField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetDoubleField:obj:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #SetDoubleField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetFloatArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetFloatArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #SetFloatArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetFloatField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetFloatField:obj:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #SetFloatField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetIntArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetIntArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #SetIntArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetIntField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetIntField:obj:fieldID:val: and then check for exceptions"	| parameters |	self intType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetIntField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetLongArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetLongArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self checkedCall: #SetLongArrayRegion with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetLongField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetLongField:obj:fieldID:val: and then check for exceptions"	| parameters |	self longType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetLongField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetObjectArrayElement_array: argument1 index: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetObjectArrayElement:array:index:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #SetObjectArrayElement		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetObjectField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetObjectField:obj:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #SetObjectField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetShortArrayRegion_array: argument1 start: argument2 len: argument3 buf: argument4 onException: a1Block	"mechanically generated method to invoke #SetShortArrayRegion:array:start:len:buf: and then check for exceptions"	| parameters |	parameters := Array new: 5.	parameters		at: 1 put: self;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3;		at: 5 put: argument4.	^self		checkedCall: #SetShortArrayRegion		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetShortField_obj: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetShortField:obj:fieldID:val: and then check for exceptions"	| parameters |	self shortType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetShortField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetStaticBooleanField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticBooleanField:class:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #SetStaticBooleanField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetStaticByteField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticByteField:class:fieldID:val: and then check for exceptions"	| parameters |	self byteType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetStaticByteField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetStaticCharField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticCharField:class:fieldID:val: and then check for exceptions"	| parameters |	self charType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetStaticCharField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetStaticDoubleField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticDoubleField:class:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #SetStaticDoubleField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetStaticFloatField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticFloatField:class:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #SetStaticFloatField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetStaticIntField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticIntField:class:fieldID:val: and then check for exceptions"	| parameters |	self intType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetStaticIntField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetStaticLongField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticLongField:class:fieldID:val: and then check for exceptions"	| parameters |	self longType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetStaticLongField with: parameters onException: a1Block</body><body package="JNIPort-JNI">SetStaticObjectField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticObjectField:class:fieldID:val: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self		checkedCall: #SetStaticObjectField		with: parameters		onException: a1Block</body><body package="JNIPort-JNI">SetStaticShortField_class: argument1 fieldID: argument2 val: argument3 onException: a1Block	"mechanically generated method to invoke #SetStaticShortField:class:fieldID:val: and then check for exceptions"	| parameters |	self shortType validateValue: argument3.	parameters := Array new: 4.	parameters		at: 1 put: externalData;		at: 2 put: argument1;		at: 3 put: argument2;		at: 4 put: argument3.	^self checkedCall: #SetStaticShortField with: parameters onException: a1Block</body><body package="JNIPort-JNI">ThrowNew_class: argument1 msg: argument2 onException: a1Block	"mechanically generated method to invoke #ThrowNew:class:msg: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2.	^self checkedCall: #ThrowNew with: parameters onException: a1Block</body><body package="JNIPort-JNI">Throw_obj: argument1 onException: a1Block	"mechanically generated method to invoke #Throw:obj: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #Throw with: parameters onException: a1Block</body><body package="JNIPort-JNI">ToReflectedField_cls: argument1 fieldID: argument2 isStatic: argument3 onException: a1Block	"mechanically generated method to invoke #ToReflectedField:class:fieldID:isStatic: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #ToReflectedField with: parameters onException: a1Block</body><body package="JNIPort-JNI">ToReflectedMethod_cls: argument1 methodID: argument2 isStatic: argument3 onException: a1Block	"mechanically generated method to invoke #ToReflectedMethod:class:methodID:isStatic: and then check for exceptions"	| parameters |	parameters := Array				with: externalData				with: argument1				with: argument2				with: argument3.	^self checkedCall: #ToReflectedMethod with: parameters onException: a1Block</body><body package="JNIPort-JNI">UnregisterNatives_class: argument1 onException: a1Block	"mechanically generated method to invoke #UnregisterNatives:class: and then check for exceptions"	| parameters |	parameters := Array with: externalData with: argument1.	^self checkedCall: #UnregisterNatives with: parameters onException: a1Block</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv</class-id> <category>accessing</category><body package="JNIPort-JNI">byteType	^JNIPortJNIInterface current jbyte</body><body package="JNIPort-JNI">charType	^JNIPortJNIInterface current jchar</body><body package="JNIPort-JNI">intType	^JNIPortJNIInterface current jint</body><body package="JNIPort-JNI">javaVM	"answer the receiver's owning JavaVM instance"	^ javaVM.</body><body package="JNIPort-JNI">javaVM: aJavaVM	"private -- set the receiver's owning JavaVM instance"	javaVM := aJavaVM.</body><body package="JNIPort-JNI">jniVersion	^ jniVersion ifNil: [ jniVersion := self primGetVersion ]</body><body package="JNIPort-JNI">longType	^JNIPortJNIInterface current jlong</body><body package="JNIPort-JNI">shortType	^JNIPortJNIInterface current jshort</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv</class-id> <category>private</category><body package="JNIPort-JNI">functionNames	| functionNames |	functionNames := super functionNames.	functionNames removeAll: (JNIPortJNIInterface current 				functionsNamesIntroducedAfter: self primGetVersion).	^functionNames</body><body package="JNIPort-JNI">populateVTable	super populateVTable.	exceptionCheckFunction := vtable at: #ExceptionCheck</body><body package="JNIPort-JNI">primGetVersion	"Directly calls the GetVersion function, circumventing the vtable of the receiver. This is needed during setup of the vtable, because the version determines which functions are present in the vtable."	^(self externalData contents memberAt: #GetVersion) 		callWith: self asJNIParameter</body><body package="JNIPort-JNI">vtableSize	^250</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv</class-id> <category>raw JNI functions</category><body package="JNIPort-JNI">DeleteGlobalRef_obj: argument1	"mechanically generated method to go via our vtable to invoke #DeleteGlobalRef:obj:."	^self call: #DeleteGlobalRef with: self with: argument1</body><body package="JNIPort-JNI">DeleteLocalRef_obj: argument1	"mechanically generated method to go via our vtable to invoke #DeleteLocalRef:obj:."	^self call: #DeleteLocalRef with: self with: argument1</body><body package="JNIPort-JNI">DeleteWeakGlobalRef_obj: argument1	"mechanically generated method to go via our vtable to invoke #DeleteWeakGlobalRef:obj:."	^self call: #DeleteWeakGlobalRef with: self with: argument1</body><body package="JNIPort-JNI">EnsureLocalCapacity_capacity: argument1	"mechanically generated method to go via our vtable to invoke #EnsureLocalCapacity:capacity:."	^self call: #EnsureLocalCapacity with: self with: argument1</body><body package="JNIPort-JNI">ExceptionCheck	"invoke #ExceptionCheck. Optimized to produce as little overhead as possible, as this method is executed with every JNI function call."	^exceptionCheckFunction call: (Array with: externalData)</body><body package="JNIPort-JNI">ExceptionClear	"mechanically generated method to go via our vtable to invoke #ExceptionClear:."	^self call: #ExceptionClear with: self</body><body package="JNIPort-JNI">ExceptionDescribe	"mechanically generated method to go via our vtable to invoke #ExceptionDescribe:."	^self call: #ExceptionDescribe with: self</body><body package="JNIPort-JNI">ExceptionOccurred	"mechanically generated method to go via our vtable to invoke #ExceptionOccurred:."	^self call: #ExceptionOccurred with: self</body><body package="JNIPort-JNI">FindClass_name: argument1	"mechanically generated method to go via our vtable to invoke #FindClass:name:."	^self call: #FindClass with: self with: argument1</body><body package="JNIPort-JNI">GetMethodID_class: argument1 name: argument2 sig: argument3	"mechanically generated method to go via our vtable to invoke #GetMethodID:class:name:sig:."	^self		call: #GetMethodID		with: self		with: argument1		with: argument2		with: argument3</body><body package="JNIPort-JNI">GetObjectClass_obj: argument1	"mechanically generated method to go via our vtable to invoke #GetObjectClass:obj:."	^self call: #GetObjectClass with: self with: argument1</body><body package="JNIPort-JNI">GetStaticMethodID_class: argument1 name: argument2 sig: argument3	"mechanically generated method to go via our vtable to invoke #GetStaticMethodID:class:name:sig:."	^self		call: #GetStaticMethodID		with: self		with: argument1		with: argument2		with: argument3</body><body package="JNIPort-JNI">GetSuperclass_sub: argument1	"mechanically generated method to go via our vtable to invoke #GetSuperclass:sub:."	^self call: #GetSuperclass with: self with: argument1</body><body package="JNIPort-JNI">GetVersion	^self call: #GetVersion with: self</body><body package="JNIPort-JNI">IsSameObject_obj1: argument1 obj2: argument2	"mechanically generated method to go via our vtable to invoke #IsSameObject:obj:obj:."	^self call: #IsSameObject withArguments: (Array with: externalData with: argument1 with: argument2)</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv</class-id> <category>testing</category><body package="JNIPort-JNI">isDead	"answer whether we know ourself to be dead.  Since we don't	actually know anything ;-) we always answer false (it is the responsibility	of the environment to replace the live JNIEnv with a DeadJNIEnv as	appropriate)"	^ false.</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv</class-id> <category>actions</category><body package="JNIPort-JNI">checkedCall: aFunctionSymbol with: parameters onException: a1Block	"Call the function named aFuncionSymbol in the receiver's vtable with the arguments stored in anArray. Note that the elements in anArray will be replaced by the result of sending them asJNIParameter. Senders must make sure that anArray isn't reused after executing checkedCall:with:onException:."	| answer |	answer := self call: aFunctionSymbol withArguments: parameters.	^self ExceptionCheck		ifTrue: 			[| jex |			jex := self ExceptionOccurred.			self ExceptionClear.			a1Block value: jex]		ifFalse: [answer]</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv class</class-id> <category>instance creation</category><body package="JNIPort-JNI">newWithJavaVM: aJavaVM	"answer a new instance owned by the given JavaVM"	^ (self new)		javaVM: aJavaVM;		yourself.</body></methods><methods><class-id>JNIPort.JNIPortJNIEnv class</class-id> <category>external accessing</category><body package="JNIPort-JNI">baseCType	^JNIPortJNIInterface current JNIEnv</body></methods><methods><class-id>JNIPort.JavaShortArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[self jniEnv		GetShortArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	self elementCType newFromJNIDatum: bufferPointer]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: anInteger	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType newPointerTo: anInteger.		[self jniEnv		SetShortArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jshort</body><body package="JNIPort-Java-Base">setElements: aSWORDArray offset: anOffset length: anInteger	"copy anInteger elements from SWORDArray into our Java array,	starting at the zero-based anOffset in the target"	self jniEnv			SetShortArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: aSWORDArray			onException: [:jex | self jvm throwJavaException: jex].</body></methods><methods><class-id>JNIPort.JavaShortArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary SWORDArray.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetShortArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseShortArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaShortArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[S'.</body></methods><methods><class-id>JNIPort.JavaShortArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewShortArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.StaticJavaLangThread</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer the result of calling the receiver's public default Java constructor"	^ self callConstructor.</body></methods><methods><class-id>JNIPort.StaticJavaLangThread</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">activeCount	"answer the result of calling the receiver's public static activeCount() Java method"	^ self callIntMethod: 'activeCount'.</body><body package="JNIPort-Java-Base">currentThread	"answer the result of calling the receiver's public static native currentThread() Java method"	^ self callObjectMethod: 'currentThread' signature: '()Ljava/lang/Thread;'.</body><body package="JNIPort-Java-Base">dumpStack	"invoke the receiver's public static dumpStack() Java method"	self callVoidMethod: 'dumpStack'.</body><body package="JNIPort-Java-Base">enumerate_ThreadArray: aThreads1	"answer the result of calling the receiver's public static enumerate(java.lang.Thread[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aThreads1.			self				callIntMethod: 'enumerate'				signature: '([Ljava/lang/Thread;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">holdsLock_Object: anObject1	"answer the result of calling the receiver's public static native holdsLock(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'holdsLock'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">interrupted	"answer the result of calling the receiver's public static interrupted() Java method"	^ self callBooleanMethod: 'interrupted'.</body><body package="JNIPort-Java-Base">sleep_long: long1	"invoke the receiver's public static native sleep(long) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self callVoidMethod: 'sleep' signature: '(J)V' withArguments: args]</body><body package="JNIPort-Java-Base">sleep_long: long1 int: int1	"invoke the receiver's public static sleep(long, int) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				longAt: 1 put: long1;				intAt: 2 put: int1.			self callVoidMethod: 'sleep' signature: '(JI)V' withArguments: args]</body><body package="JNIPort-Java-Base">yield	"invoke the receiver's public static native yield() Java method"	self callVoidMethod: 'yield'.</body></methods><methods><class-id>JNIPort.StaticJavaLangThread</class-id> <category>Java-constructors</category><body package="JNIPort-Java-Base">new_Runnable: aRunnable1	"answer the result of calling the receiver's public new(java.lang.Runnable) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aRunnable1.			self callConstructorSignature: '(Ljava/lang/Runnable;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">new_Runnable: aRunnable1 String: aString1	"answer the result of calling the receiver's public new(java.lang.Runnable, java.lang.String) Java constructor"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: aRunnable1;				objectAt: 2 put: javaString1.			self callConstructorSignature: '(Ljava/lang/Runnable;Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-Base">new_ThreadGroup: aThreadGroup1 Runnable: aRunnable1	"answer the result of calling the receiver's public new(java.lang.ThreadGroup, java.lang.Runnable) Java constructor"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: aThreadGroup1;				objectAt: 2 put: aRunnable1.			self				callConstructorSignature: '(Ljava/lang/ThreadGroup;Ljava/lang/Runnable;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">new_ThreadGroup: aThreadGroup1 Runnable: aRunnable1 String: aString1	"answer the result of calling the receiver's public new(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String) Java constructor"	^JNIValueArray new: 3		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: aThreadGroup1;				objectAt: 2 put: aRunnable1;				objectAt: 3 put: javaString1.			self				callConstructorSignature: '(Ljava/lang/ThreadGroup;Ljava/lang/Runnable;Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">new_ThreadGroup: aThreadGroup1 Runnable: aRunnable1 String: aString1 long: long1	"answer the result of calling the receiver's public new(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long) Java constructor"	^JNIValueArray new: 4		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: aThreadGroup1;				objectAt: 2 put: aRunnable1;				objectAt: 3 put: javaString1;				longAt: 4 put: long1.			self				callConstructorSignature: '(Ljava/lang/ThreadGroup;Ljava/lang/Runnable;Ljava/lang/String;J)V'				withArguments: args]</body><body package="JNIPort-Java-Base">new_ThreadGroup: aThreadGroup1 String: aString1	"answer the result of calling the receiver's public new(java.lang.ThreadGroup, java.lang.String) Java constructor"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: aThreadGroup1;				objectAt: 2 put: javaString1.			self				callConstructorSignature: '(Ljava/lang/ThreadGroup;Ljava/lang/String;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangThread</class-id> <category>Java-static</category><body package="JNIPort-Java-Base">get_MAX_PRIORITY	"answer the value of the receiver's public static final MAX_PRIORITY Java field"	^ self getIntField: 'MAX_PRIORITY'.</body><body package="JNIPort-Java-Base">get_MIN_PRIORITY	"answer the value of the receiver's public static final MIN_PRIORITY Java field"	^ self getIntField: 'MIN_PRIORITY'.</body><body package="JNIPort-Java-Base">get_NORM_PRIORITY	"answer the value of the receiver's public static final NORM_PRIORITY Java field"	^ self getIntField: 'NORM_PRIORITY'.</body></methods><methods><class-id>JNIPort.StaticJavaLangThread</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">getAllStackTraces	"answer the result of calling the receiver's public static getAllStackTraces() Java method"	^ self callObjectMethod: 'getAllStackTraces' signature: '()Ljava/util/Map;'.</body><body package="JNIPort-Java-Base">getDefaultUncaughtExceptionHandler	"answer the result of calling the receiver's public static getDefaultUncaughtExceptionHandler() Java method"	^ self callObjectMethod: 'getDefaultUncaughtExceptionHandler' signature: '()Ljava/lang/Thread$UncaughtExceptionHandler;'.</body><body package="JNIPort-Java-Base">setDefaultUncaughtExceptionHandler_Thread_UncaughtExceptionHandler: anUncaughtExceptionHandler1	"invoke the receiver's public static setDefaultUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anUncaughtExceptionHandler1.			self				callVoidMethod: 'setDefaultUncaughtExceptionHandler'				signature: '(Ljava/lang/Thread$UncaughtExceptionHandler;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangThread class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Thread'.</body></methods><methods><class-id>JNIPort.StaticJavaLangThread class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new		#new_Runnable:		#new_Runnable:String:		#new_String:		#new_ThreadGroup:Runnable:		#new_ThreadGroup:Runnable:String:		#new_ThreadGroup:Runnable:String:long:		#new_ThreadGroup:String:	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_MAX_PRIORITY		#get_MIN_PRIORITY		#get_NORM_PRIORITY	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#activeCount		#currentThread		#dumpStack		#enumerate_ThreadArray:		#getAllStackTraces		#getDefaultUncaughtExceptionHandler		#holdsLock_Object:		#interrupted		#setDefaultUncaughtExceptionHandler_Thread_UncaughtExceptionHandler:		#sleep_long:		#sleep_long:int:		#yield	).</body></methods><methods><class-id>JNIPort.JVMWatcher</class-id> <category>event handling</category><body package="JNIPort-Java-Base">onClassPurged: aJavaStatic	"notification recieved when a class is about to be removed from the JVM's	registry.  Since the class is in an iffy state, we should refrain from sending it	any messages that will be forwarded to the real Java runtime"</body><body package="JNIPort-Java-Base">onClassRegistered: aJavaStatic	"notification recieved when a class has been added to the JVM's	registry (the owning JVM can be found via the class object).	Note that this will be called for each wrapper class during JVM	bootstrap, *before* we recieve notification that the initialisation	is complete"</body><body package="JNIPort-Java-Base">onJmvInitialized: aJVM	"notification recieved when the given JVM has finished initialisation"	jvmIsInitialized := true.</body><body package="JNIPort-Java-Base">onJvmShutdown: aJVM	"notification recieved when the given JVM is about to shutdown.  There's not much that	can safely be assumed about its state at this point"	jvmIsInitialized := false.</body><body package="JNIPort-Java-Base">onNotWatchingJvm: aJVM	"notification recieved when we have been from the JVM's watchlist.	This is only called if someone explicitly removes us from its list, there is	no automatic way that this happens"</body><body package="JNIPort-Java-Base">onWatchingJvm: aJVM	"notification recieved when we have been added to the JVM's watchlist.	Note that this is called *before* the JVM has finished initialisation if we are	added though the normal configuration mechanism.	Specifically, this is called before the JVM has registered any wrapper classes	(although it has bootstrapped the class registry)"</body></methods><methods><class-id>JNIPort.JVMWatcher</class-id> <category>testing</category><body package="JNIPort-Java-Base">jvmIsInitialized	"answer whether our JVM has been initialized (and not yet shotdown)"	^ jvmIsInitialized.</body><body package="JNIPort-Java-Base">usesGhostClasses	"answer whether we use ghost class wrappers"	^ false.</body></methods><methods><class-id>JNIPort.JVMWatcher</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state"	jvmIsInitialized := false.</body></methods><methods><class-id>JNIPort.JVMWatcher class</class-id> <category>testing</category><body package="JNIPort-Java-Base">usesGhostClasses	^false</body></methods><methods><class-id>JNIPort.JVMWatcher class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer a default initialized instance"	^ (super new)		initialize;		yourself.</body></methods><methods><class-id>JNIPort.JVMWatcher class</class-id> <category>event handling</category><body package="JNIPort-Java-Base">onJvmStartup: aJVM	"this is called whenever a JVM is started with settngs that include this class on	its list of watcher classes"	"default response is to add an instance to the JVM's list of watchers"	aJVM addWatcher: self new.</body></methods><methods><class-id>JNIPort.JVMGhostClassMaker</class-id> <category>event handling</category><body package="JNIPort-Java-GhostClasses">onClassRegistered: aJavaStatic	"notification recieved when a class has been added to the JVM's	registry (the owning JVM can be found via the class object).	Note that this will be called for each wrapper class during JVM	bootstrap, *before* we recieve notification that the initialisation	is complete"	self jvmIsInitialized ifTrue: [self enghost: aJavaStatic].</body><body package="JNIPort-Java-GhostClasses">onJmvInitialized: aJVM	"notification recieved when the given JVM has finished initialisation"	super onJmvInitialized: aJVM.	self enghostAll: aJVM.</body><body package="JNIPort-Java-GhostClasses">onJvmShutdown: aJVM	"notification recieved when the given JVM is about to shutdown.  There's not much that	can safely be assumed about its state at this point"	super onJvmShutdown: aJVM.	JavaObject clearGhostsOwnedBy: aJVM</body></methods><methods><class-id>JNIPort.JVMGhostClassMaker</class-id> <category>ghost classes</category><body package="JNIPort-Java-GhostClasses">enghost: aJavaStatic	"ensure that aJavaStatic has appropriate ghost classes generated for it"	"you might expect that, since this class is responsible for making ghost classes (hence	its name!), we would now create a JavaGhostClass installer, and start using it, rather than	passing everything back onto the target class.  Indeed I have tried several times to make	it work that way, but although the *reponsibility* for setting up the ghost class clearly lies	here, the actual *code* wants to live in JavaStatic.  What's more, it insists on it so strongly	that I've had to give in to it (not without a fight).  So in the end this class doesn't actually *do*	very much"	"NB: for threadsafetly we require that ghost class creation is idempotent"	aJavaStatic useGhostClasses.</body><body package="JNIPort-Java-GhostClasses">enghostAll: aJVM	"ensure that all currently registered Java classes are ghosts (to the degree	determined by our settings)"	aJVM classRegistry allClasses do: [:each | self enghost: each].</body></methods><methods><class-id>JNIPort.JVMGhostClassMaker</class-id> <category>testing</category><body package="JNIPort-Java-GhostClasses">usesGhostClasses	"answer whether we use ghost class wrappers"	^ true.</body></methods><methods><class-id>JNIPort.JVMGhostClassMaker class</class-id> <category>testing</category><body package="JNIPort-Java-GhostClasses">usesGhostClasses	^true</body></methods><methods><class-id>JNIPort.JVMGhostClassMaker class</class-id> <category>event handling</category><body package="JNIPort-Java-GhostClasses">onJvmStartup: aJVM	"this is called whenever a JVM is started with settngs that include this class on	its list of watcher classes"	"check that the current system includes enough stuff"	self jniAssert: [('Compiler' asClassOrNilIn: self environment) notNil].	self jniAssert: [('JavaClassWrapperGenerator' asClassOrNilIn: self environment) notNil].	super onJvmStartup: aJVM.</body></methods><methods><class-id>JNIPort.JavaLangException class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.Exception'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveCharStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the char field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getCharFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: aCharacterOrInteger	"private -- set the char field defined by JNIFieldID it aJavaObject to aCharacterOrInteger.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	aJavaObject setCharFID: aJNIFieldID to: aCharacterOrInteger.</body></methods><methods><class-id>JNIPort.JavaPrimitiveCharStatic</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">conversionToJavaStringFor: aParameterName wrapperFactoryString: aString	^ '(' , aParameterName , ' asInteger)'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveCharStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'C'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveCharStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaCharArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Character'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveCharStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #char.</body></methods><methods><class-id>JNIPort.JavaPrimitiveCharStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Char'</body></methods><methods><class-id>JNIPort.JNINativeMethod</class-id> <category>accessing</category><body package="JNIPort-JNI">callback: anExternalCallback 	"set the receiver's callback field anExternalCallback"	self externalData memberAt: #fnPtr put: anExternalCallback referentAddress</body><body package="JNIPort-JNI">name	"answer our String name"	^(self externalData memberAt: #name) copyJavaModifiedUTF8StringFromHeap</body><body package="JNIPort-JNI">name: aString 	"set the receiver's name field to aString"	"remember a reference to the external String to prevent it from being garbage collected"	name := aString asJNIParameter.	self externalData memberAt: #name put: name</body><body package="JNIPort-JNI">signature	"answer our String signature"	^(self externalData memberAt: #signature) copyJavaModifiedUTF8StringFromHeap</body><body package="JNIPort-JNI">signature: aString 	"set the receiver's signature field aString"	"remember a reference to the external String to prevent it from being garbage collected"	signature := aString asJNIParameter.	self externalData memberAt: #signature put: signature</body></methods><methods><class-id>JNIPort.JNINativeMethod class</class-id> <category>external accessing</category><body package="JNIPort-JNI">baseCType	^JNIPortJNIInterface current JNINativeMethod</body></methods><methods><class-id>JNIPort.JVMWithCallbacks</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">callbackDepth	"answer how deeply nested we are in callbacks"	^ jniEnvStack size.</body><body package="JNIPort-Java-Callbacks">callbackRegistry	"answer our registry of callbacks.	Note that this gets set quite late in the bootstrap sequence, after class registration for instance,	so if callbackRegistry is nil, then you are probably trying to use callbacks before bootstrap is complete"	^ callbackRegistry.</body><body package="JNIPort-Java-Callbacks">callbacks	"answer how many callbacks have been serviced"	^ callbackRegistry requestsCompleted.</body></methods><methods><class-id>JNIPort.JVMWithCallbacks</class-id> <category>Java callbacks</category><body package="JNIPort-Java-Callbacks">asCallbackDo: a0Block	"answer the result of evaluating a0Block in an environment where we have	replaced the current JNIEnv with the currently valid one.  This is used -- this *MUST*	be used to implement callbacks/native methods"	"Note: this isn't really reliable, and I don't see any way to make it so, since	this is called *after* we've entered the callback, and there may already have	been some other Process using the superseeded JNIEnv.  Similarly as we	leave the callback, so other process may use the reinstated JNIEnv before	we actually do leave the callback"	"JG: It seems that VisualWorks handles callbacks in a way which makes replacing	the JNIEnv unnecessary. Actually, the callbacks fail if the JNIEnv is replaced."	^JNIPortUtility executesForeignCallbacksInSmalltalkThread		ifTrue: [a0Block value]		ifFalse: 			[self pushJniEnv.			a0Block ensure: [self popJniEnv]]</body><body package="JNIPort-Java-Callbacks">popJniEnv	"private -- we are just about to leave a callback, so reinstate the old	JNIEnv as quickly as possible"	[javaVM isNil ifTrue: [^ self].	jniEnv := jniEnvStack removeLast]		valueUnpreemptively.</body><body package="JNIPort-Java-Callbacks">pushJniEnv	"private -- we have just been told that we are in a callback, so get a valid new	JNIEnv as quickly as possible"	[javaVM isNil ifTrue: [^ self].	jniEnvStack addLast: jniEnv.	jniEnv := javaVM newJNIEnvVersion: jniEnv jniVersion]		valueUnpreemptively.</body><body package="JNIPort-Java-Callbacks">supportsCallbacks	"answer whether this JVM supports callbacks from Java into Smalltalk"	^true</body></methods><methods><class-id>JNIPort.JVMWithCallbacks</class-id> <category>initializing</category><body package="JNIPort-Java-Callbacks">initializeCallbackRegistry	"private -- called during initialisation.  We are now sufficiently initialized for a callback registry	to work; set one up now.	NB: at this point the class registry etc, have been set up but the wrapper classes have not"	jniEnvStack := OrderedCollection new: 10.	callbackRegistry := JavaCallbackRegistry withJvm: self.</body><body package="JNIPort-Java-Callbacks">shutdownJavaCallbacks	self callbackRegistry ifNotNil: [:it | it shutdownJava]</body></methods><methods><class-id>JNIPort.JVMWithCallbacks</class-id> <category>managed objects</category><body package="JNIPort-Java-Callbacks">basicOwn: aJavaInstance	"private -- aJavaInstance has just been born, keep track of it from now on.	This is the implementation of #own: except that it is called under the protection	of our shared mutex"	super basicOwn: aJavaInstance.	"ensure that the instance is global"	aJavaInstance beGlobalRef.</body><body package="JNIPort-Java-Callbacks">notifyNowLocal: aJavaInstance	"private -- aJavaInstance has just become a global ref, adjust the counts accordingly"	"we don't support local references"	self jniAssert: [false].</body><body package="JNIPort-Java-Callbacks">wrapJNIObject: aJNIObject	"answer a JavaInstance, owned by the receiver, for the JNI object, aJNIObject	or nil if it is a null pointer"	"This is invoked for new object refs where the Java class is not already known	before the ref is created, so we just lookup the class and then ask it to wrap	the object. If the class is not yet registered in the class registry, 	that might take considerable time during which callbacks might happen	(especially if new ghost classes have to be constructed). Therefore suspend	callbacks until the class is found and the JavaInstance has been created."	^ aJNIObject isNull		ifTrue: [ nil ]		ifFalse: [ callbackRegistry suspendCallbacksWhile: [ (self findClassFor: aJNIObject) wrapJNIObject: aJNIObject ] ]</body></methods><methods><class-id>JNIPort.JVMWithCallbacks</class-id> <category>finalizing</category><body package="JNIPort-Java-Callbacks">shutdownCallbackRegistry	"private -- shutdown any callback registry we have"	jniEnvStack := OrderedCollection new.	"we close down the registry, but keep a handle on it (I can't remember why,	but there must have been a reason once)"	callbackRegistry notNil ifTrue: [callbackRegistry shutdown].</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkNotification</class-id> <category>Java-methods</category><body package="JNIPort-Java-Callbacks">send	"invoke the receiver's public send() Java method"	self callVoidMethod: 'send'.</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkNotification</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">requiresAcknowledgement	"answer whether this request requres an answer"	"overridden 'cos we already know the answer"	^ false.</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkNotification class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Callbacks">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#send	).</body></methods><methods><class-id>JNIPort.JNIPortSmalltalkNotification class</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'jniport.SmalltalkNotification'.</body></methods><methods><class-id>JNIPort.StaticJavaLangThrowable</class-id> <category>testing</category><body package="JNIPort-Java-Base">isExceptionHandler	"Answer if the receiver responds to the #handles: messages as required by the exception-handling machinery."	^true</body></methods><methods><class-id>JNIPort.StaticJavaLangThrowable</class-id> <category>Java-constructors</category><body package="JNIPort-Java-Base">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-Base">new_String: aString1 Throwable: aThrowable1	"answer the result of calling the receiver's public new(java.lang.String, java.lang.Throwable) Java constructor"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: aThrowable1.			self				callConstructorSignature: '(Ljava/lang/String;Ljava/lang/Throwable;)V'				withArguments: args]</body><body package="JNIPort-Java-Base">new_Throwable: aThrowable1	"answer the result of calling the receiver's public new(java.lang.Throwable) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aThrowable1.			self callConstructorSignature: '(Ljava/lang/Throwable;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangThrowable</class-id> <category>raising</category><body package="JNIPort-Java-Base">signal	"throw a new instance of this class.  Will generate a Smalltalk exception wrapping	the new Java object"	self new signal.</body><body package="JNIPort-Java-Base">signal: aString	"throw a new instance of this class with the given message.  The message is held in the Java object.	Will generate a Smalltalk exception wrapping the new Java object"	(self new_String: aString) signal.</body></methods><methods><class-id>JNIPort.StaticJavaLangThrowable</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer the result of calling the receiver's public default Java constructor"	^ self callConstructor.</body></methods><methods><class-id>JNIPort.StaticJavaLangThrowable class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new		#new_String:		#new_String:Throwable:		#new_Throwable:	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body></methods><methods><class-id>JNIPort.StaticJavaLangThrowable class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Throwable'.</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>operations</category><body package="JNIPort-Java-Callbacks">clearCallback: aJavaTagObject	"remove the registered callback for aJavaTagObject.	Any attempt to invoke this callback from Java space will henceforth trigger a	RequestNotHandledException in the caller"	mutex critical:		[self isDead ifTrue: [^ self].		callbacks removeKey: aJavaTagObject ifAbsent: []].</body><body package="JNIPort-Java-Callbacks">dispatch: aRequest to: a2Block	"private -- handle the given jniport.SmalltalkRequest object	by passing its originator and parameter to a2Block.  Note that trapping	exceptions is implemented in our caller (#safeDispatch:to:)"	| answer |	self trace: aRequest with: 'dispatch -- enter'.	answer := a2Block			value: aRequest originator			value: aRequest parameter.	aRequest requiresAcknowledgement ifTrue:		["this assert will cause a RequestNotHandledException to be triggered in		the Java caller.		Possibly someday we could coece integers etc, automatically"		self jniAssert: [answer isNil or: [answer isKindOf: JavaObject]].		self trace: answer with: 'dispatch -- answer'.		aRequest notifyAnswer: answer].	self trace: aRequest with: 'dispatch -- exit'.</body><body package="JNIPort-Java-Callbacks">handleOutstandingRequests	"check the queue of requests in Java space and handle any that are outstanding.	This can be called directly, but is normally called when the notifier Java	thread determines that it is necessary"	| requests |	self trace: 'handleOutstandingRequests -- enter'.	[self isConnected and: [(requests := queueClass nextRequests: 100) notNil]]		whileTrue: [self handleRequests: requests].	self trace: 'handleOutstandingRequests -- exit'.</body><body package="JNIPort-Java-Callbacks">handleRequest: aRequest	"private -- handle the given jniport.SmalltalkRequest object"	| handler |	self trace: aRequest with: 'handleRequest -- enter'.	handler := mutex critical: [callbacks at: aRequest tag ifAbsent: [nil]].	handler isNil		ifTrue: [aRequest notifyIgnored]		ifFalse: [self safeDispatch: aRequest to: handler].	self trace: aRequest with: 'handleRequest -- exit'.</body><body package="JNIPort-Java-Callbacks">handleRequests: aJavaArray	"private -- handle the given jniport.SmalltalkRequest object"	self trace: 'handleRequests -- enter'.	aJavaArray do: [:each | self handleRequest: each].	aJavaArray free.	"it seems that these don't get scavenged very efficiently, but we know we can				dispose of this array manually here"	self trace: 'handleRequests -- exit'.</body><body package="JNIPort-Java-Callbacks">safeDispatch: aRequest to: a2Block	"private -- invoke the handler for aRequest in an environment that will ensure that	some sort of response is always sent back to the requester.  This is *vital* since otherwise	we will almost certainly deadlock ourselves"	[		[[self dispatch: aRequest to: a2Block]			on: JavaException			do: [:err | aRequest notifyError: err]]			on: JNIPortUtility exceptionsWithoutNotifications			do: [:err | aRequest notifyIgnored: 'The Smalltalk handler threw a non-Java exception (', err printString , ')']	] ifCurtailed: [aRequest notifyIgnored: 'The Smalltalk handler did not complete normally'].</body><body package="JNIPort-Java-Callbacks">setCallback: aJavaTagObject handler: a2Block	"add/change the registered callback for aJavaTagObject.  Here, aJavaObject is	the 'tag' supplied with an jniport.SmalltalkRequest object.	The &lt;diadicValuable&gt; will be evaluated with the request's 'originator' as its first argument,	and the 'parameter' (a single Java object that might be an Array, or nil) as its second.	If any exception is thrown from a2Block, then (provided it is a Java exception) that	will be passed back to the caller in Java space.	Note that we hold onto a *strong* reference to aJavaTagObject"	"ensure we are connected"	self beConnected.	mutex critical:		[self isDead ifTrue: [^ self].		callbacks at: aJavaTagObject put: a2Block].</body><body package="JNIPort-Java-Callbacks">setCallback: aJavaTagObject performWithArguments: aSelector	"add/change the registered callback for aJavaTagObject.  This convenience	operator just arranges that aSelector will be sent to the 'originator' object	of the request with the parameter object interpretted as an array of arguments	to the message send.	This may not be much use unless a 'canonical' has been 	set, since it'll send aSelector	to the ephemeral JavaInstance created to wrap the 'originator' field.	Note that we hold onto a *strong* reference to aJavaTagObject"	self setCallback: aJavaTagObject handler: (JavaMessageSend symbol: aSelector).</body><body package="JNIPort-Java-Callbacks">setCallback: aJavaTagObject performWithNoArguments: aSelector	"add/change the registered callback for aJavaTagObject.  This convenience	operator just arranges that aSelector will be sent	to the 'originator' object	of the request ignoring the parameter object.	This may not be much use unless a 'canonical' has been 	set, since it'll send aSelector	to the ephemeral JavaInstance created to wrap the 'originator' field.	Note that we hold onto a *strong* reference to aJavaTagObject"	self setCallback: aJavaTagObject handler: [:originator :parameter | originator perform: aSelector].</body><body package="JNIPort-Java-Callbacks">setCallback: aJavaTagObject performWithOneArgument: aSelector	"add/change the registered callback for aJavaTagObject.  This convenience	operator just arranges that aSelector will be sent	to the 'originator' object	of the request with the parameter object interpretted as the single argument	to the message send.	This may not be much use unless a 'canonical' has been 	set, since it'll send aSelector	to the ephemeral JavaInstance created to wrap the 'originator' field.	Note that we hold onto a *strong* reference to aJavaTagObject"	self setCallback: aJavaTagObject handler: [:originator :parameter | originator perform: aSelector with: parameter].</body><body package="JNIPort-Java-Callbacks">setCallback: aJavaTagObject triggerWithArguments: aSymbol	"add/change the registered callback for aJavaTagObject.  This convenience	operator just arranges that aSymbol will be triggered off the 'originator' object of the	request, and interpreting the parameter as an array of arguments to the event.	Note that this is no use at all unless a 'canonical' has been set, since it'd	just trigger off the ephemeral JavaObject created to wrap the 'originator' field, and	(by definition) no one will be listening to that object.	Note that we hold onto a *strong* reference to aJavaTagObject"	self setCallback: aJavaTagObject handler: (JavaEventTrigger symbol: aSymbol).</body><body package="JNIPort-Java-Callbacks">setCallback: aJavaTagObject triggerWithNoArguments: aSymbol	"add/change the registered callback for aJavaTagObject.  This convenience	operator just arranges that aSymbol will be triggered off the 'originator' object of the	request ignoring the parameter.	Note that this is no use at all unless a 'canonical' has been set, since it'd	just trigger off the ephemeral JavaObject created to wrap the 'originator' field, and	(by definition) no one will be listening to that object.	Note that we hold onto a *strong* reference to aJavaTagObject"	self setCallback: aJavaTagObject handler: [:originator :parameter | originator trigger: aSymbol].</body><body package="JNIPort-Java-Callbacks">setCallback: aJavaTagObject triggerWithOneArgument: aSymbol	"add/change the registered callback for aJavaTagObject.  This convenience	operator just arranges that aSymbol will be triggered off the 'originator' object of the	request, with the parameter interpreted as the single argument to the event.	Note that this is no use at all unless a 'canonical' has been set, since it'd	just trigger off the ephemeral JavaObject created to wrap the 'originator' field, and	(by definition) no one will be listening to that object.	Note that we hold onto a *strong* reference to aJavaTagObject"	self setCallback: aJavaTagObject handler: [:originator :parameter | originator trigger: aSymbol with: parameter].</body><body package="JNIPort-Java-Callbacks">suspendCallbacksWhile: aBlock	^ mutex critical: [ aBlock value ]</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">maxQueueLength	"answer how long the queue of requests has ever been"	^ self isConnected		ifTrue: [queueClass requestQueueMax]		ifFalse: [-1].</body><body package="JNIPort-Java-Callbacks">queueLength	"answer how long the queue of requests is"	^ self isConnected		ifTrue: [queueClass requestQueueLength]		ifFalse: [-1].</body><body package="JNIPort-Java-Callbacks">registeredCallbackCount	"answer how many callbacks are registered"	^ self isConnected		ifTrue: [callbacks size]		ifFalse: [-1].</body><body package="JNIPort-Java-Callbacks">registeredCallbacks	"answer the dictionary mapping JavaObject 'tags' to handler blocks"	^ callbacks.</body><body package="JNIPort-Java-Callbacks">requestsCompleted	"answer how many requests have been completed"	^ self isConnected		ifTrue: [queueClass requestsCompleted]		ifFalse: [-1].</body><body package="JNIPort-Java-Callbacks">tableSize	"answer how many callbacks are registered"	^ mutex critical: [callbacks size].</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>tracing</category><body package="JNIPort-Java-Callbacks">stopTracing	self traceTo: nil.</body><body package="JNIPort-Java-Callbacks">trace: anObject	trace notNil ifTrue:		[trace			print: jvm callbackDepth;			nextPutAll: '[';			nextPutAll: Processor activeProcess printString;			nextPutAll: '] ';			print: anObject;			cr].</body><body package="JNIPort-Java-Callbacks">trace: anObject with: aString	trace notNil ifTrue:		[trace			print: jvm callbackDepth;			nextPutAll: '[';			nextPutAll: Processor activeProcess printString;			nextPutAll: '] ';			nextPutAll: aString;			nextPutAll: ': ';			print: anObject;			cr].</body><body package="JNIPort-Java-Callbacks">traceTo: aWriteStream	trace := aWriteStream.</body><body package="JNIPort-Java-Callbacks">traceToDebug	"self traceTo: (Smalltalk at: #Trace)."	self traceToTranscript</body><body package="JNIPort-Java-Callbacks">traceToTranscript	self traceTo: Transcript.</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>initializing</category><body package="JNIPort-Java-Callbacks">beConnected	"private -- ensure that we are connected to the jniport.SmalltalkRequest system"	mutex critical: [connected ifTrue: [^ self]].	"this stuff can be slow, so we do it outside the mutex; it may	end up getting done twice, but it's idempotent so it doesn't matter.	Also note that if this fails with a class-not-found exception then we	leave ourselves in a state where the next attempt to connect will	cause another attempt to find the class"	notifierClass := self findNotifierClass.	queueClass := self findRequestQueueClass.	"now try to connect (may be a nullop)"	mutex critical: [connected ifFalse: [self connectToNotifierClass]].</body><body package="JNIPort-Java-Callbacks">connectToNotifierClass	"private -- establish our connection to the notifier thread.	NB: is only called under the protection of our mutex"	connected := true.	"tell the notifier class which thread we are on"	notifierClass setSmalltalkNativeThread.	"set up the basic callback"	notifierClass implementNotifierMethodBy: self makeHandlerBlock.</body><body package="JNIPort-Java-Callbacks">initialize	"private -- establish a coherent initial state"	"note that this uses #= and #hash for comparison, i.e. it is comparing Java objects	by identity (two JavaInstances are #= iff they refer to the same Java object)"	callbacks := Dictionary new.#CUtodo.  "can this Mutex cause deadlocks with the main shared mutex (in the JVM) ?"	mutex := Mutex new.	connected := false</body><body package="JNIPort-Java-Callbacks">jvm: aJVM	"private -- set the JVM that we will organise callbacks for"	jvm := aJVM.</body><body package="JNIPort-Java-Callbacks">makeHandlerBlock	"private -- answer the &lt;niladicValuable&gt; that we will install	as the hook for notifications from Java"	^ [self handleOutstandingRequests].</body><body package="JNIPort-Java-Callbacks">shutdown	"private -- discard any connection to the JVM and unload any callbacks"	mutex critical:		[jvm := nil.		callbacks := nil.		queueClass := notifierClass := nil.		connected := false].</body><body package="JNIPort-Java-Callbacks">shutdownJava	"private -- close down any runnng code in the Java space -- this is called just	before our JVM closes down, and it may help to reduce problems caused by	pending callbacks"	mutex critical:		[self isConnected ifTrue: [queueClass shutdown].		connected := false].</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>private-events</category><body package="JNIPort-Java-Callbacks">myEventTable	^eventHandlers</body><body package="JNIPort-Java-Callbacks">myEventTable: anEventTable	eventHandlers := anEventTable</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>testing</category><body package="JNIPort-Java-Callbacks">isConnected	"answer whether we are connected to the runtime system"	^ self isLive and: [connected].</body><body package="JNIPort-Java-Callbacks">isDead	"answer whether we are in doornail mode"	^ jvm isNil or: [jvm isDead].</body><body package="JNIPort-Java-Callbacks">isLive	"answer whether we are still alive"	^ jvm notNil and: [jvm isLive].</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>measuring</category><body package="JNIPort-Java-Callbacks">averageProbesPerElement	"answer the &lt;Float&gt; average number of probes to find an item already in the callback table"	^ mutex critical: [callbacks averageProbesPerElement].</body><body package="JNIPort-Java-Callbacks">tableLoad	"answer the &lt;Float&gt; percentage load on the callbacks table"	^ mutex critical: [callbacks size * 100.0 / callbacks basicSize].</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>printing</category><body package="JNIPort-Java-Callbacks">printOn: aStream	"write a developer oriented representation of the receiver to aStream"	aStream nextPutAll: 'a '.	self isDead		ifTrue: [aStream nextPutAll: 'dead ']		ifFalse: [connected ifFalse: [aStream nextPutAll: 'disconnected ']].	aStream nextPutAll: self class name.</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry</class-id> <category>helpers</category><body package="JNIPort-Java-Callbacks">findNotifierClass	"private -- find and answer the SmalltalkNotifierThread class static"	^ jvm findClass: self class notifierClassName.</body><body package="JNIPort-Java-Callbacks">findRequestQueueClass	"private -- find and answr the class static for the SmalltalkRequestQueue class"	^ jvm findClass: self class requestQueueClassName.</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry class</class-id> <category>instance creation</category><body package="JNIPort-Java-Callbacks">new	"private -- create a new instance unconnected to any JVM"	^ (super new)		initialize;		yourself.</body><body package="JNIPort-Java-Callbacks">withJvm: aJVM	"private -- create a new instance connected to the given JVM"	^ (self new)		jvm: aJVM;		yourself.</body></methods><methods><class-id>JNIPort.JavaCallbackRegistry class</class-id> <category>constants</category><body package="JNIPort-Java-Callbacks">notifierClassName	"answer the (Java) class of the method that instances 'hook' to in	order to handle callback requests"	^ #'jniport.SmalltalkNotifierThread'.</body><body package="JNIPort-Java-Callbacks">requestQueueClassName	"answer the (Java) class of the callback request queues"	^ #'jniport.SmalltalkRequestQueue'.</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">charAt_int: int1	"answer the result of calling the receiver's public charAt(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callCharMethod: 'charAt' signature: '(I)C' withArguments: args]</body><body package="JNIPort-Java-Base">codePointAt_int: int1	"answer the result of calling the receiver's public codePointAt(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'codePointAt' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-Base">compareToIgnoreCase_String: aString1	"answer the result of calling the receiver's public compareToIgnoreCase(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callIntMethod: 'compareToIgnoreCase'				signature: '(Ljava/lang/String;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">compareTo_Object: anObject1	"answer the result of calling the receiver's public compareTo(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callIntMethod: 'compareTo'				signature: '(Ljava/lang/Object;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">compareTo_String: aString1	"answer the result of calling the receiver's public compareTo(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callIntMethod: 'compareTo'				signature: '(Ljava/lang/String;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">concat_String: aString1	"answer the result of calling the receiver's public concat(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'concat'				signature: '(Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">contentEquals_StringBuffer: aStringBuffer1	"answer the result of calling the receiver's public contentEquals(java.lang.StringBuffer) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aStringBuffer1.			self				callBooleanMethod: 'contentEquals'				signature: '(Ljava/lang/StringBuffer;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">endsWith_String: aString1	"answer the result of calling the receiver's public endsWith(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callBooleanMethod: 'endsWith'				signature: '(Ljava/lang/String;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">equalsIgnoreCase_String: aString1	"answer the result of calling the receiver's public equalsIgnoreCase(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callBooleanMethod: 'equalsIgnoreCase'				signature: '(Ljava/lang/String;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">getBytes	"answer the result of calling the receiver's public getBytes() Java method"	^ self callObjectMethod: 'getBytes' signature: '()[B'.</body><body package="JNIPort-Java-Base">getBytes_String: aString1	"answer the result of calling the receiver's public getBytes(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'getBytes'				signature: '(Ljava/lang/String;)[B'				withArguments: args]</body><body package="JNIPort-Java-Base">getBytes_int: int1 int: int2 byteArray: bytes1 int: int3	"invoke the receiver's public getBytes(int, int, byte[], int) Java method"	JNIValueArray new: 4		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2;				objectAt: 3 put: bytes1;				intAt: 4 put: int3.			self callVoidMethod: 'getBytes' signature: '(II[BI)V' withArguments: args]</body><body package="JNIPort-Java-Base">getChars_int: int1 int: int2 charArray: chars1 int: int3	"invoke the receiver's public getChars(int, int, char[], int) Java method"	JNIValueArray new: 4		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2;				objectAt: 3 put: chars1;				intAt: 4 put: int3.			self callVoidMethod: 'getChars' signature: '(II[CI)V' withArguments: args]</body><body package="JNIPort-Java-Base">indexOf_String: aString1	"answer the result of calling the receiver's public indexOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callIntMethod: 'indexOf'				signature: '(Ljava/lang/String;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">indexOf_String: aString1 int: int1	"answer the result of calling the receiver's public indexOf(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callIntMethod: 'indexOf'				signature: '(Ljava/lang/String;I)I'				withArguments: args]</body><body package="JNIPort-Java-Base">indexOf_int: int1	"answer the result of calling the receiver's public indexOf(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'indexOf' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-Base">indexOf_int: int1 int: int2	"answer the result of calling the receiver's public indexOf(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self callIntMethod: 'indexOf' signature: '(II)I' withArguments: args]</body><body package="JNIPort-Java-Base">intern	"answer the result of calling the receiver's public native intern() Java method"	^ self callObjectMethod: 'intern' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">lastIndexOf_String: aString1	"answer the result of calling the receiver's public lastIndexOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callIntMethod: 'lastIndexOf'				signature: '(Ljava/lang/String;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">lastIndexOf_String: aString1 int: int1	"answer the result of calling the receiver's public lastIndexOf(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callIntMethod: 'lastIndexOf'				signature: '(Ljava/lang/String;I)I'				withArguments: args]</body><body package="JNIPort-Java-Base">lastIndexOf_int: int1	"answer the result of calling the receiver's public lastIndexOf(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'lastIndexOf' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-Base">lastIndexOf_int: int1 int: int2	"answer the result of calling the receiver's public lastIndexOf(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self callIntMethod: 'lastIndexOf' signature: '(II)I' withArguments: args]</body><body package="JNIPort-Java-Base">length	"answer the result of calling the receiver's public length() Java method"	^ self callIntMethod: 'length'.</body><body package="JNIPort-Java-Base">matches_String: aString1	"answer the result of calling the receiver's public matches(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callBooleanMethod: 'matches'				signature: '(Ljava/lang/String;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">regionMatches_boolean: boolean1 int: int1 String: aString1 int: int2 int: int3	"answer the result of calling the receiver's public regionMatches(boolean, int, java.lang.String, int, int) Java method"	^JNIValueArray new: 5		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				booleanAt: 1 put: boolean1;				intAt: 2 put: int1;				objectAt: 3 put: javaString1;				intAt: 4 put: int2;				intAt: 5 put: int3.			self				callBooleanMethod: 'regionMatches'				signature: '(ZILjava/lang/String;II)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">regionMatches_int: int1 String: aString1 int: int2 int: int3	"answer the result of calling the receiver's public regionMatches(int, java.lang.String, int, int) Java method"	^JNIValueArray new: 4		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				intAt: 1 put: int1;				objectAt: 2 put: javaString1;				intAt: 3 put: int2;				intAt: 4 put: int3.			self				callBooleanMethod: 'regionMatches'				signature: '(ILjava/lang/String;II)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">replaceAll_String: aString1 String: aString2	"answer the result of calling the receiver's public replaceAll(java.lang.String, java.lang.String) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 javaString2 |			javaString1 := aString1 asJavaString: self jvm.			javaString2 := aString2 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: javaString2.			self				callObjectMethod: 'replaceAll'				signature: '(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">replaceFirst_String: aString1 String: aString2	"answer the result of calling the receiver's public replaceFirst(java.lang.String, java.lang.String) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 javaString2 |			javaString1 := aString1 asJavaString: self jvm.			javaString2 := aString2 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: javaString2.			self				callObjectMethod: 'replaceFirst'				signature: '(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">replace_char: char1 char: char2	"answer the result of calling the receiver's public replace(char, char) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				charAt: 1 put: char1;				charAt: 2 put: char2.			self				callObjectMethod: 'replace'				signature: '(CC)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">split_String: aString1	"answer the result of calling the receiver's public split(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'split'				signature: '(Ljava/lang/String;)[Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">split_String: aString1 int: int1	"answer the result of calling the receiver's public split(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callObjectMethod: 'split'				signature: '(Ljava/lang/String;I)[Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">startsWith_String: aString1	"answer the result of calling the receiver's public startsWith(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callBooleanMethod: 'startsWith'				signature: '(Ljava/lang/String;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">startsWith_String: aString1 int: int1	"answer the result of calling the receiver's public startsWith(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callBooleanMethod: 'startsWith'				signature: '(Ljava/lang/String;I)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">subSequence_int: int1 int: int2	"answer the result of calling the receiver's public subSequence(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self				callObjectMethod: 'subSequence'				signature: '(II)Ljava/lang/CharSequence;'				withArguments: args]</body><body package="JNIPort-Java-Base">substring_int: int1	"answer the result of calling the receiver's public substring(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'substring'				signature: '(I)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">substring_int: int1 int: int2	"answer the result of calling the receiver's public substring(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self				callObjectMethod: 'substring'				signature: '(II)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">toCharArray	"answer the result of calling the receiver's public toCharArray() Java method"	^ self callObjectMethod: 'toCharArray' signature: '()[C'.</body><body package="JNIPort-Java-Base">toLowerCase	"answer the result of calling the receiver's public toLowerCase() Java method"	^ self callObjectMethod: 'toLowerCase' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">toLowerCase_Locale: aLocale1	"answer the result of calling the receiver's public toLowerCase(java.util.Locale) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aLocale1.			self				callObjectMethod: 'toLowerCase'				signature: '(Ljava/util/Locale;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">toUpperCase	"answer the result of calling the receiver's public toUpperCase() Java method"	^ self callObjectMethod: 'toUpperCase' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">toUpperCase_Locale: aLocale1	"answer the result of calling the receiver's public toUpperCase(java.util.Locale) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aLocale1.			self				callObjectMethod: 'toUpperCase'				signature: '(Ljava/util/Locale;)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-Base">trim	"answer the result of calling the receiver's public trim() Java method"	^ self callObjectMethod: 'trim' signature: '()Ljava/lang/String;'.</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>converting</category><body package="JNIPort-Java-Base">asByteArray	"Answer an instance of ByteArray whose elements are the elements of the receiver	after converting it to a Smalltalk String. The result is platform dependent. In VisualWorks	and Dolphin, this will fail with an Error if the receiver contains two-byte characters."	^self asString asByteArray</body><body package="JNIPort-Java-Base">asJavaConstructorSignature	^self asString asJavaConstructorSignature</body><body package="JNIPort-Java-Base">asJavaFieldSignature	^self asString asJavaFieldSignature</body><body package="JNIPort-Java-Base">asJavaMethodSignature	^self asString asJavaMethodSignature</body><body package="JNIPort-Java-Base">asJavaString: aJVM	"answer a JavaLangString object which is owned by aJVM"	^ aJVM == self jvm		ifTrue: [self]		ifFalse: [self asString asJavaString: aJVM].</body><body package="JNIPort-Java-Base">asString	"answer a Smalltalk String with the same characters as the Java String we stand for"	^self		withBytesDo: [:bytes | String fromJavaModifiedUTF8EncodedByteArray: bytes]</body><body package="JNIPort-Java-Base">toString	"answer the result of invoking our Java object's toString() method.	Overriden to avoid creating too many objects while displaying strings"	^ self.</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>printing</category><body package="JNIPort-Java-Base">printOn: aStream 	"append a user-oriented representation of our underlying Java object to aStream"	"we check liveness here (although it's usually not necessary) since it stops problems	with debuging in the presence of a dead JVM"	self isLive ifTrue: [aStream nextPutAll: self asString]</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">codePointBefore_int: int1	"answer the result of calling the receiver's public codePointBefore(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callIntMethod: 'codePointBefore' signature: '(I)I' withArguments: args]</body><body package="JNIPort-Java-Base">codePointCount_int: int1 int: int2	"answer the result of calling the receiver's public codePointCount(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self callIntMethod: 'codePointCount' signature: '(II)I' withArguments: args]</body><body package="JNIPort-Java-Base">contains_CharSequence: aCharSequence1	"answer the result of calling the receiver's public contains(java.lang.CharSequence) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCharSequence1.			self				callBooleanMethod: 'contains'				signature: '(Ljava/lang/CharSequence;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">contentEquals_CharSequence: aCharSequence1	"answer the result of calling the receiver's public contentEquals(java.lang.CharSequence) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCharSequence1.			self				callBooleanMethod: 'contentEquals'				signature: '(Ljava/lang/CharSequence;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">getBytes_Charset: aCharset1	"answer the result of calling the receiver's public getBytes(java.nio.charset.Charset) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCharset1.			self				callObjectMethod: 'getBytes'				signature: '(Ljava/nio/charset/Charset;)[B'				withArguments: args]</body><body package="JNIPort-Java-Base">offsetByCodePoints_int: int1 int: int2	"answer the result of calling the receiver's public offsetByCodePoints(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self				callIntMethod: 'offsetByCodePoints'				signature: '(II)I'				withArguments: args]</body><body package="JNIPort-Java-Base">replace_CharSequence: aCharSequence1 CharSequence: aCharSequence2	"answer the result of calling the receiver's public replace(java.lang.CharSequence, java.lang.CharSequence) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: aCharSequence1;				objectAt: 2 put: aCharSequence2.			self				callObjectMethod: 'replace'				signature: '(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based	Answers a Character"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := JNIPortJNIInterface current jchar calloc.	^	[self jniEnv		GetStringRegion_str: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	(JNIPortJNIInterface current jchar newFromJNIDatum: bufferPointer)		asCharacter]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: aCharacterOrInteger	"one of the root methods for &lt;SequenceableCollection&gt;"	"strings are immutable"	self shouldNotImplement.</body><body package="JNIPort-Java-Base">size	"answer the number of chars in the Java string"	sizeCache isNil ifFalse: [^ sizeCache].	sizeCache := self jniEnv				GetStringLength_str: jniObject				onException: [:jex | self jvm throwJavaException: jex].	^ sizeCache.</body><body package="JNIPort-Java-Base">withBytesDo: a1Block	"answer the result of evaluating a1Block, passing it a temporary ByteArray	of bytes in Java's modified UTF8 format.	NB: these are unsigned bytes, not Java's signed bytes.	DO NOT KEEP A REFERENCE TO THE ARRAY"		| length ptr |	"can't use #size because that's the size in characters"	length := self jniEnv		GetStringUTFLength_str: jniObject		onException: [:jex | self jvm throwJavaException: jex].	length = 0 ifTrue: [^a1Block value: #[]].	ptr := self jniEnv		GetStringUTFChars_str: jniObject		isCopy: self jvm library nullPointer		onException: [:jex | self jvm throwJavaException: jex].	^[| bytes |	bytes := ByteArray fromAddress: ptr length: length.	a1Block value: bytes]		ensure:			[self jniEnv				ReleaseStringUTFChars_str: jniObject				chars: ptr				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>operations</category><body package="JNIPort-Java-Base">writeOn: aStream	"write the characters from the Java String onto aStream"	aStream nextPutAll: self asString.</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">do: a1Block	"shorthand for:"	^ self from: 1 to: self size keysAndValuesDo: [ :index :char | a1Block value: char ].</body><body package="JNIPort-Java-Base">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block	"one of the root methods for &lt;SequenceableCollection&gt;, note that the indexes are Smalltalk	indexes and, as such, 1-based"	| stop |	aStartIndex &gt; aStopIndex ifTrue: [^self].	aStartIndex &lt; 1 ifTrue: [self errorSubscriptBounds: aStartIndex].	aStartIndex &gt; self size ifTrue: [self errorSubscriptBounds: aStartIndex].	stop := self size min: aStopIndex.	self withElementsDo: 			[:pointer |			pointer				from: aStartIndex				to: stop				keysAndValuesDo: [:key :value | a2Block value: key value: value asCharacter]				elementType: JNIPortJNIInterface current jchar].	stop &lt; aStopIndex ifTrue: [self errorSubscriptBounds: stop + 1]</body><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary WORDArray	of chars (unsigned 16bit words) in Java's native format as its parameter.	DO NOT KEEP A REFERENCE TO THE ARRAY.	Note: as of Java 5, the format is defined to be UTF-16"	| ptr |	ptr := self jniEnv 				GetStringChars_str: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseStringChars_str: jniObject				chars: ptr				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>replacing</category><body package="JNIPort-Java-Base">replaceFrom: aStartIndex to: aStopIndex with: replacementElements startingAt: aReplacementIndex	"one of the root methods for &lt;SequenceableCollection&gt;"	"Java Strings are immutable"	self shouldNotImplement.</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>displaying</category><body package="JNIPort-Java-Base">displayOn: aStream	"append a user-oriented representation of our underlying Java object to aStream"	"we check liveness here (although it's usually not necessary) since it stops problems	with debuging in the presence of a dead JVM"	self isLive ifTrue: [self writeOn: aStream].</body></methods><methods><class-id>JNIPort.JavaLangString</class-id> <category>testing</category><body package="JNIPort-Java-Base">isEmpty	"answer the result of calling the receiver's public isEmpty() Java method"	^ self callBooleanMethod: 'isEmpty'.</body></methods><methods><class-id>JNIPort.JavaLangString class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#charAt_int:		#codePointAt_int:		#codePointBefore_int:		#codePointCount_int:int:		#compareToIgnoreCase_String:		#compareTo_Object:		#compareTo_String:		#concat_String:		#contains_CharSequence:		#contentEquals_CharSequence:		#contentEquals_StringBuffer:		#endsWith_String:		#equalsIgnoreCase_String:		#equals_Object:		#getBytes_Charset:		#getBytes_int:int:byteArray:int:		#getBytes		#getBytes_String:		#getChars_int:int:charArray:int:		#hashCode		#indexOf_int:		#indexOf_int:int:		#indexOf_String:		#indexOf_String:int:		#intern		#isEmpty		#lastIndexOf_int:		#lastIndexOf_int:int:		#lastIndexOf_String:		#lastIndexOf_String:int:		#length		#matches_String:		#offsetByCodePoints_int:int:		#regionMatches_boolean:int:String:int:int:		#regionMatches_int:String:int:int:		#replaceAll_String:String:		#replaceFirst_String:String:		#replace_char:char:		#replace_CharSequence:CharSequence:		#split_String:		#split_String:int:		#startsWith_String:		#startsWith_String:int:		#subSequence_int:int:		#substring_int:		#substring_int:int:		#toCharArray		#toLowerCase_Locale:		#toLowerCase		#toString		#toUpperCase_Locale:		#toUpperCase		#trim	).</body></methods><methods><class-id>JNIPort.JavaLangString class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">fromByteArray: aByteArray jvm: aJVM	"answer a new JavaObject wrapping a java.lang.String which has been created by copying the 'characters'	in aByteArray	NB: this will only work properly (i.e give the chars you expect) if aByteArray is encoded in the modified version	of UTF8 that the JVM uses"	| answer |	answer := aJVM jniEnv NewStringUTF_utf: aByteArray				onException: [:jex | aJVM throwJavaException: jex].	"since we know the return type exactly, we can use the accelerated form	of wrapper-creation for strings here"	^aJVM wrapJNIString: answer</body><body package="JNIPort-Java-Base">fromString: aString jvm: aJVM	"answer a new JavaObject wrapping a java.lang.String which has been created by copying the characters	in aString"	| answer |	answer := aJVM jniEnv 				NewStringUTF_utf: aString 				onException: [:jex | aJVM throwJavaException: jex].	"since we know the return type exactly, we can use the accelerated form	of wrapper-creation for strings here"	^aJVM wrapJNIString: answer</body></methods><methods><class-id>JNIPort.JavaLangString class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.String'.</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>types</category><body package="JNIPort-JNI">FILE	&lt;C: typedef struct _iobuf FILE&gt;</body><body package="JNIPort-JNI">JDK1_1AttachArgs	"This type has been removed from the JNI in Java SE 6 / JNI 1.6."	&lt;C: typedef struct __JDK1_1AttachArgs JDK1_1AttachArgs&gt;</body><body package="JNIPort-JNI">JDK1_1InitArgs	"This type has been removed from the JNI in Java SE 6 / JNI 1.6."	&lt;C: typedef struct __JDK1_1InitArgs JDK1_1InitArgs&gt;</body><body package="JNIPort-JNI">JNIEnv	&lt;C: typedef const struct JNINativeInterface_ * JNIEnv &gt;</body><body package="JNIPort-JNI">JNINativeMethod	&lt;C: typedef struct {			char * name;			char * signature;			void * fnPtr;		} JNINativeMethod&gt;</body><body package="JNIPort-JNI">JNIObject	&lt;C: typedef void * JNIObject&gt;</body><body package="JNIPort-JNI">JavaVM	&lt;C: typedef const struct JNIInvokeInterface_ * JavaVM &gt;</body><body package="JNIPort-JNI">JavaVMAttachArgs	&lt;C: typedef struct __JavaVMAttachArgs JavaVMAttachArgs&gt;</body><body package="JNIPort-JNI">JavaVMInitArgs	&lt;C: typedef struct __JavaVMInitArgs JavaVMInitArgs&gt;</body><body package="JNIPort-JNI">JavaVMOption	&lt;C: typedef struct __JavaVMOption JavaVMOption&gt;</body><body package="JNIPort-JNI">fpos_t	&lt;C: typedef struct __fpos_t fpos_t&gt;</body><body package="JNIPort-JNI">jarray	&lt;C: typedef jobject jarray&gt;</body><body package="JNIPort-JNI">jboolean	&lt;C: typedef __bool char jboolean&gt;</body><body package="JNIPort-JNI">jbooleanArray	&lt;C: typedef jarray jbooleanArray&gt;</body><body package="JNIPort-JNI">jbyte	&lt;C: typedef char jbyte&gt;</body><body package="JNIPort-JNI">jbyteArray	&lt;C: typedef jarray jbyteArray&gt;</body><body package="JNIPort-JNI">jchar	&lt;C: typedef unsigned short jchar&gt;</body><body package="JNIPort-JNI">jcharArray	&lt;C: typedef jarray jcharArray&gt;</body><body package="JNIPort-JNI">jclass	&lt;C: typedef jobject jclass&gt;</body><body package="JNIPort-JNI">jdouble	&lt;C: typedef double jdouble&gt;</body><body package="JNIPort-JNI">jdoubleArray	&lt;C: typedef jarray jdoubleArray&gt;</body><body package="JNIPort-JNI">jfieldID	&lt;C: typedef struct _jfieldID * jfieldID&gt;</body><body package="JNIPort-JNI">jfloat	&lt;C: typedef float jfloat&gt;</body><body package="JNIPort-JNI">jfloatArray	&lt;C: typedef jarray jfloatArray&gt;</body><body package="JNIPort-JNI">jint	&lt;C: typedef int jint&gt;</body><body package="JNIPort-JNI">jintArray	&lt;C: typedef jarray jintArray&gt;</body><body package="JNIPort-JNI">jlong	&lt;C: typedef long long jlong&gt;</body><body package="JNIPort-JNI">jlongArray	&lt;C: typedef jarray jlongArray&gt;</body><body package="JNIPort-JNI">jmethodID	&lt;C: typedef struct _jmethodID * jmethodID&gt;</body><body package="JNIPort-JNI">jobject	&lt;C: typedef struct _jobject * jobject&gt;</body><body package="JNIPort-JNI">jobjectArray	&lt;C: typedef jarray jobjectArray&gt;</body><body package="JNIPort-JNI">jshort	&lt;C: typedef short jshort&gt;</body><body package="JNIPort-JNI">jshortArray	&lt;C: typedef jarray jshortArray&gt;</body><body package="JNIPort-JNI">jsize	&lt;C: typedef jint jsize&gt;</body><body package="JNIPort-JNI">jstring	&lt;C: typedef jobject jstring&gt;</body><body package="JNIPort-JNI">jthrowable	&lt;C: typedef jobject jthrowable&gt;</body><body package="JNIPort-JNI">jvalue	&lt;C: typedef union __jvalue jvalue&gt;</body><body package="JNIPort-JNI">jweak	&lt;C: typedef jobject jweak&gt;</body><body package="JNIPort-JNI">size_t	&lt;C: typedef unsigned int size_t&gt;</body><body package="JNIPort-JNI">va_list	&lt;C: typedef char * va_list&gt;</body><body package="JNIPort-JNI">vtable	&lt;C: typedef void * * vtable&gt;</body><body package="JNIPort-JNI">wchar_t	&lt;C: typedef unsigned short wchar_t&gt;</body><body package="JNIPort-JNI">wctype_t	&lt;C: typedef wchar_t wctype_t&gt;</body><body package="JNIPort-JNI">wint_t	&lt;C: typedef wchar_t wint_t&gt;</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>defines</category><body package="JNIPort-JNI">BUFSIZ	&lt;C: #define BUFSIZ 512	&gt;</body><body package="JNIPort-JNI">EOF	&lt;C: #define EOF (-1)	&gt;</body><body package="JNIPort-JNI">FILENAME_MAX	&lt;C: #define FILENAME_MAX 260	&gt;</body><body package="JNIPort-JNI">FOPEN_MAX	&lt;C: #define FOPEN_MAX 20	&gt;</body><body package="JNIPort-JNI">JDK1_2	&lt;C: #define JDK1_2 	&gt;</body><body package="JNIPort-JNI">JDK1_4	&lt;C: #define JDK1_4 	&gt;</body><body package="JNIPort-JNI">JNICALL	&lt;C: #define JNICALL __stdcall	&gt;</body><body package="JNIPort-JNI">JNIEXPORT	&lt;C: #define JNIEXPORT 	&gt;</body><body package="JNIPort-JNI">JNIGlobalRefType	&lt;C: #define JNIGlobalRefType 2	&gt;</body><body package="JNIPort-JNI">JNIIMPORT	&lt;C: #define JNIIMPORT 	&gt;</body><body package="JNIPort-JNI">JNIInvalidRefType	&lt;C: #define JNIInvalidRefType 0	&gt;</body><body package="JNIPort-JNI">JNILocalRefType	&lt;C: #define JNILocalRefType 1	&gt;</body><body package="JNIPort-JNI">JNIWeakGlobalRefType	&lt;C: #define JNIWeakGlobalRefType 3	&gt;</body><body package="JNIPort-JNI">JNI_ABORT	&lt;C: #define JNI_ABORT 2	&gt;</body><body package="JNIPort-JNI">JNI_COMMIT	&lt;C: #define JNI_COMMIT 1	&gt;</body><body package="JNIPort-JNI">JNI_EDETACHED	&lt;C: #define JNI_EDETACHED (-2)	&gt;</body><body package="JNIPort-JNI">JNI_EEXIST	&lt;C: #define JNI_EEXIST (-5)	&gt;</body><body package="JNIPort-JNI">JNI_EINVAL	&lt;C: #define JNI_EINVAL (-6)	&gt;</body><body package="JNIPort-JNI">JNI_ENOMEM	&lt;C: #define JNI_ENOMEM (-4)	&gt;</body><body package="JNIPort-JNI">JNI_ERR	&lt;C: #define JNI_ERR (-1)	&gt;</body><body package="JNIPort-JNI">JNI_EVERSION	&lt;C: #define JNI_EVERSION (-3)	&gt;</body><body package="JNIPort-JNI">JNI_FALSE	&lt;C: #define JNI_FALSE 0	&gt;</body><body package="JNIPort-JNI">JNI_OK	&lt;C: #define JNI_OK 0	&gt;</body><body package="JNIPort-JNI">JNI_TRUE	&lt;C: #define JNI_TRUE 1	&gt;</body><body package="JNIPort-JNI">JNI_VERSION_1_1	&lt;C: #define JNI_VERSION_1_1 0x00010001	&gt;</body><body package="JNIPort-JNI">JNI_VERSION_1_2	&lt;C: #define JNI_VERSION_1_2 0x00010002	&gt;</body><body package="JNIPort-JNI">JNI_VERSION_1_4	&lt;C: #define JNI_VERSION_1_4 0x00010004	&gt;</body><body package="JNIPort-JNI">JNI_VERSION_1_6	&lt;C: #define JNI_VERSION_1_6 0x00010006	&gt;</body><body package="JNIPort-JNI">L_tmpnam	&lt;C: #define L_tmpnam sizeof(_P_tmpdir)+12	&gt;</body><body package="JNIPort-JNI">NULL	&lt;C: #define NULL ((void*)0)	&gt;</body><body package="JNIPort-JNI">SEEK_CUR	&lt;C: #define SEEK_CUR 1	&gt;</body><body package="JNIPort-JNI">SEEK_END	&lt;C: #define SEEK_END 2	&gt;</body><body package="JNIPort-JNI">SEEK_SET	&lt;C: #define SEEK_SET 0	&gt;</body><body package="JNIPort-JNI">TMP_MAX	&lt;C: #define TMP_MAX 32767	&gt;</body><body package="JNIPort-JNI">WEOF	&lt;C: #define WEOF (wint_t)(65535)	&gt;</body><body package="JNIPort-JNI">_CRTAPI1	&lt;C: #define _CRTAPI1 	&gt;</body><body package="JNIPort-JNI">_CRTIMP	&lt;C: #define _CRTIMP 	&gt;</body><body package="JNIPort-JNI">_FILE_DEFINED	&lt;C: #define _FILE_DEFINED 	&gt;</body><body package="JNIPort-JNI">_FPOS_T_DEFINED	&lt;C: #define _FPOS_T_DEFINED 	&gt;</body><body package="JNIPort-JNI">_INC_STDARG	&lt;C: #define _INC_STDARG 	&gt;</body><body package="JNIPort-JNI">_INC_STDIO	&lt;C: #define _INC_STDIO 	&gt;</body><body package="JNIPort-JNI">_IOEOF	&lt;C: #define _IOEOF 0x0010	&gt;</body><body package="JNIPort-JNI">_IOERR	&lt;C: #define _IOERR 0x0020	&gt;</body><body package="JNIPort-JNI">_IOFBF	&lt;C: #define _IOFBF 0x0000	&gt;</body><body package="JNIPort-JNI">_IOLBF	&lt;C: #define _IOLBF 0x0040	&gt;</body><body package="JNIPort-JNI">_IOMYBUF	&lt;C: #define _IOMYBUF 0x0008	&gt;</body><body package="JNIPort-JNI">_IONBF	&lt;C: #define _IONBF 0x0004	&gt;</body><body package="JNIPort-JNI">_IOREAD	&lt;C: #define _IOREAD 0x0001	&gt;</body><body package="JNIPort-JNI">_IORW	&lt;C: #define _IORW 0x0080	&gt;</body><body package="JNIPort-JNI">_IOSTRG	&lt;C: #define _IOSTRG 0x0040	&gt;</body><body package="JNIPort-JNI">_IOWRT	&lt;C: #define _IOWRT 0x0002	&gt;</body><body package="JNIPort-JNI">_JAVASOFT_JNI_H_	&lt;C: #define _JAVASOFT_JNI_H_ 	&gt;</body><body package="JNIPort-JNI">_JAVASOFT_JNI_MD_H_	&lt;C: #define _JAVASOFT_JNI_MD_H_ 	&gt;</body><body package="JNIPort-JNI">_JNI_IMPORT_OR_EXPORT_	&lt;C: #define _JNI_IMPORT_OR_EXPORT_ JNIIMPORT	&gt;</body><body package="JNIPort-JNI">_NFILE	&lt;C: #define _NFILE _NSTREAM_	&gt;</body><body package="JNIPort-JNI">_NSTREAM_	&lt;C: #define _NSTREAM_ 20	&gt;</body><body package="JNIPort-JNI">_SIZE_T_DEFINED	&lt;C: #define _SIZE_T_DEFINED 	&gt;</body><body package="JNIPort-JNI">_STDIO_DEFINED	&lt;C: #define _STDIO_DEFINED 	&gt;</body><body package="JNIPort-JNI">_SYS_OPEN	&lt;C: #define _SYS_OPEN 20	&gt;</body><body package="JNIPort-JNI">_VA_LIST_DEFINED	&lt;C: #define _VA_LIST_DEFINED 	&gt;</body><body package="JNIPort-JNI">_WCHAR_T_DEFINED	&lt;C: #define _WCHAR_T_DEFINED 	&gt;</body><body package="JNIPort-JNI">_WCTYPE_T_DEFINED	&lt;C: #define _WCTYPE_T_DEFINED 	&gt;</body><body package="JNIPort-JNI">_WSTDIO_DEFINED	&lt;C: #define _WSTDIO_DEFINED 	&gt;</body><body package="JNIPort-JNI">__cdecl	&lt;C: #define __cdecl 	&gt;</body><body package="JNIPort-JNI">_wP_tmpdir	&lt;C: #define _wP_tmpdir L "\\"	&gt;</body><body package="JNIPort-JNI">stderr	&lt;C: #define stderr (&amp;_iob[2])	&gt;</body><body package="JNIPort-JNI">stdin	&lt;C: #define stdin (&amp;_iob[0])	&gt;</body><body package="JNIPort-JNI">stdout	&lt;C: #define stdout (&amp;_iob[1])	&gt;</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>structs</category><body package="JNIPort-JNI">JNIEnv_	&lt;C: struct JNIEnv_ {			const struct JNINativeInterface_ * functions;		}&gt;</body><body package="JNIPort-JNI">JNIInvokeInterface_	&lt;C: struct JNIInvokeInterface_ {			void * reserved0;			void * reserved1;			void * reserved2;			jint ( __stdcall * DestroyJavaVM)(JavaVM * vm);			jint ( __stdcall * AttachCurrentThread)(JavaVM * vm, void * * penv, void * args);			jint ( __stdcall * DetachCurrentThread)(JavaVM * vm);			jint ( __stdcall * GetEnv)(JavaVM * vm, void * * penv, jint version);			jint ( __stdcall * AttachCurrentThreadAsDaemon)(JavaVM * vm, void * * penv, void * args);		}&gt;</body><body package="JNIPort-JNI">JNINativeInterface_	&lt;C: struct JNINativeInterface_ {			void * reserved0;			void * reserved1;			void * reserved2;			void * reserved3;			jint ( __stdcall * GetVersion)(JNIEnv * env);			jclass ( __stdcall * DefineClass)(JNIEnv * env, const char * name, jobject loader, const jbyte * buf, jsize len);			jclass ( __stdcall * FindClass)(JNIEnv * env, const char * name);			jmethodID ( __stdcall * FromReflectedMethod)(JNIEnv * env, jobject method);			jfieldID ( __stdcall * FromReflectedField)(JNIEnv * env, jobject field);			jobject ( __stdcall * ToReflectedMethod)(JNIEnv * env, jclass cls, jmethodID methodID, jboolean isStatic);			jclass ( __stdcall * GetSuperclass)(JNIEnv * env, jclass sub);			jboolean ( __stdcall * IsAssignableFrom)(JNIEnv * env, jclass sub, jclass sup);			jobject ( __stdcall * ToReflectedField)(JNIEnv * env, jclass cls, jfieldID fieldID, jboolean isStatic);			jint ( __stdcall * Throw)(JNIEnv * env, jthrowable obj);			jint ( __stdcall * ThrowNew)(JNIEnv * env, jclass clazz, const char * msg);			jthrowable ( __stdcall * ExceptionOccurred)(JNIEnv * env);			void ( __stdcall * ExceptionDescribe)(JNIEnv * env);			void ( __stdcall * ExceptionClear)(JNIEnv * env);			void ( __stdcall * FatalError)(JNIEnv * env, const char * msg);			jint ( __stdcall * PushLocalFrame)(JNIEnv * env, jint capacity);			jobject ( __stdcall * PopLocalFrame)(JNIEnv * env, jobject result);			jobject ( __stdcall * NewGlobalRef)(JNIEnv * env, jobject lobj);			void ( __stdcall * DeleteGlobalRef)(JNIEnv * env, jobject gref);			void ( __stdcall * DeleteLocalRef)(JNIEnv * env, jobject obj);			jboolean ( __stdcall * IsSameObject)(JNIEnv * env, jobject obj1, jobject obj2);			jobject ( __stdcall * NewLocalRef)(JNIEnv * env, jobject ref);			jint ( __stdcall * EnsureLocalCapacity)(JNIEnv * env, jint capacity);			jobject ( __stdcall * AllocObject)(JNIEnv * env, jclass clazz);			jobject ( __stdcall * NewObject)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jobject ( __stdcall * NewObjectV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jobject ( __stdcall * NewObjectA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jclass ( __stdcall * GetObjectClass)(JNIEnv * env, jobject obj);			jboolean ( __stdcall * IsInstanceOf)(JNIEnv * env, jobject obj, jclass clazz);			jmethodID ( __stdcall * GetMethodID)(JNIEnv * env, jclass clazz, const char * name, const char * sig);			jobject ( __stdcall * CallObjectMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jobject ( __stdcall * CallObjectMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jobject ( __stdcall * CallObjectMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jboolean ( __stdcall * CallBooleanMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jboolean ( __stdcall * CallBooleanMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jboolean ( __stdcall * CallBooleanMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jbyte ( __stdcall * CallByteMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jbyte ( __stdcall * CallByteMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jbyte ( __stdcall * CallByteMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jchar ( __stdcall * CallCharMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jchar ( __stdcall * CallCharMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jchar ( __stdcall * CallCharMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jshort ( __stdcall * CallShortMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jshort ( __stdcall * CallShortMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jshort ( __stdcall * CallShortMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jint ( __stdcall * CallIntMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jint ( __stdcall * CallIntMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jint ( __stdcall * CallIntMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jlong ( __stdcall * CallLongMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jlong ( __stdcall * CallLongMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jlong ( __stdcall * CallLongMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jfloat ( __stdcall * CallFloatMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jfloat ( __stdcall * CallFloatMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jfloat ( __stdcall * CallFloatMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jdouble ( __stdcall * CallDoubleMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			jdouble ( __stdcall * CallDoubleMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			jdouble ( __stdcall * CallDoubleMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			void ( __stdcall * CallVoidMethod)(JNIEnv * env, jobject obj, jmethodID methodID, ...);			void ( __stdcall * CallVoidMethodV)(JNIEnv * env, jobject obj, jmethodID methodID, va_list args);			void ( __stdcall * CallVoidMethodA)(JNIEnv * env, jobject obj, jmethodID methodID, const jvalue * args);			jobject ( __stdcall * CallNonvirtualObjectMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jobject ( __stdcall * CallNonvirtualObjectMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jobject ( __stdcall * CallNonvirtualObjectMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jboolean ( __stdcall * CallNonvirtualBooleanMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jboolean ( __stdcall * CallNonvirtualBooleanMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jboolean ( __stdcall * CallNonvirtualBooleanMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jbyte ( __stdcall * CallNonvirtualByteMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jbyte ( __stdcall * CallNonvirtualByteMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jbyte ( __stdcall * CallNonvirtualByteMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jchar ( __stdcall * CallNonvirtualCharMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jchar ( __stdcall * CallNonvirtualCharMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jchar ( __stdcall * CallNonvirtualCharMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jshort ( __stdcall * CallNonvirtualShortMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jshort ( __stdcall * CallNonvirtualShortMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jshort ( __stdcall * CallNonvirtualShortMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jint ( __stdcall * CallNonvirtualIntMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jint ( __stdcall * CallNonvirtualIntMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jint ( __stdcall * CallNonvirtualIntMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jlong ( __stdcall * CallNonvirtualLongMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jlong ( __stdcall * CallNonvirtualLongMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jlong ( __stdcall * CallNonvirtualLongMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jfloat ( __stdcall * CallNonvirtualFloatMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jfloat ( __stdcall * CallNonvirtualFloatMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jfloat ( __stdcall * CallNonvirtualFloatMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jdouble ( __stdcall * CallNonvirtualDoubleMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			jdouble ( __stdcall * CallNonvirtualDoubleMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			jdouble ( __stdcall * CallNonvirtualDoubleMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			void ( __stdcall * CallNonvirtualVoidMethod)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, ...);			void ( __stdcall * CallNonvirtualVoidMethodV)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, va_list args);			void ( __stdcall * CallNonvirtualVoidMethodA)(JNIEnv * env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);			jfieldID ( __stdcall * GetFieldID)(JNIEnv * env, jclass clazz, const char * name, const char * sig);			jobject ( __stdcall * GetObjectField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jboolean ( __stdcall * GetBooleanField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jbyte ( __stdcall * GetByteField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jchar ( __stdcall * GetCharField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jshort ( __stdcall * GetShortField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jint ( __stdcall * GetIntField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jlong ( __stdcall * GetLongField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jfloat ( __stdcall * GetFloatField)(JNIEnv * env, jobject obj, jfieldID fieldID);			jdouble ( __stdcall * GetDoubleField)(JNIEnv * env, jobject obj, jfieldID fieldID);			void ( __stdcall * SetObjectField)(JNIEnv * env, jobject obj, jfieldID fieldID, jobject val);			void ( __stdcall * SetBooleanField)(JNIEnv * env, jobject obj, jfieldID fieldID, jboolean val);			void ( __stdcall * SetByteField)(JNIEnv * env, jobject obj, jfieldID fieldID, jbyte val);			void ( __stdcall * SetCharField)(JNIEnv * env, jobject obj, jfieldID fieldID, jchar val);			void ( __stdcall * SetShortField)(JNIEnv * env, jobject obj, jfieldID fieldID, jshort val);			void ( __stdcall * SetIntField)(JNIEnv * env, jobject obj, jfieldID fieldID, jint val);			void ( __stdcall * SetLongField)(JNIEnv * env, jobject obj, jfieldID fieldID, jlong val);			void ( __stdcall * SetFloatField)(JNIEnv * env, jobject obj, jfieldID fieldID, jfloat val);			void ( __stdcall * SetDoubleField)(JNIEnv * env, jobject obj, jfieldID fieldID, jdouble val);			jmethodID ( __stdcall * GetStaticMethodID)(JNIEnv * env, jclass clazz, const char * name, const char * sig);			jobject ( __stdcall * CallStaticObjectMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jobject ( __stdcall * CallStaticObjectMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jobject ( __stdcall * CallStaticObjectMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jboolean ( __stdcall * CallStaticBooleanMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jboolean ( __stdcall * CallStaticBooleanMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jboolean ( __stdcall * CallStaticBooleanMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jbyte ( __stdcall * CallStaticByteMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jbyte ( __stdcall * CallStaticByteMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jbyte ( __stdcall * CallStaticByteMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jchar ( __stdcall * CallStaticCharMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jchar ( __stdcall * CallStaticCharMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jchar ( __stdcall * CallStaticCharMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jshort ( __stdcall * CallStaticShortMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jshort ( __stdcall * CallStaticShortMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jshort ( __stdcall * CallStaticShortMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jint ( __stdcall * CallStaticIntMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jint ( __stdcall * CallStaticIntMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jint ( __stdcall * CallStaticIntMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jlong ( __stdcall * CallStaticLongMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jlong ( __stdcall * CallStaticLongMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jlong ( __stdcall * CallStaticLongMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jfloat ( __stdcall * CallStaticFloatMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jfloat ( __stdcall * CallStaticFloatMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jfloat ( __stdcall * CallStaticFloatMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			jdouble ( __stdcall * CallStaticDoubleMethod)(JNIEnv * env, jclass clazz, jmethodID methodID, ...);			jdouble ( __stdcall * CallStaticDoubleMethodV)(JNIEnv * env, jclass clazz, jmethodID methodID, va_list args);			jdouble ( __stdcall * CallStaticDoubleMethodA)(JNIEnv * env, jclass clazz, jmethodID methodID, const jvalue * args);			void ( __stdcall * CallStaticVoidMethod)(JNIEnv * env, jclass cls, jmethodID methodID, ...);			void ( __stdcall * CallStaticVoidMethodV)(JNIEnv * env, jclass cls, jmethodID methodID, va_list args);			void ( __stdcall * CallStaticVoidMethodA)(JNIEnv * env, jclass cls, jmethodID methodID, const jvalue * args);			jfieldID ( __stdcall * GetStaticFieldID)(JNIEnv * env, jclass clazz, const char * name, const char * sig);			jobject ( __stdcall * GetStaticObjectField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jboolean ( __stdcall * GetStaticBooleanField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jbyte ( __stdcall * GetStaticByteField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jchar ( __stdcall * GetStaticCharField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jshort ( __stdcall * GetStaticShortField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jint ( __stdcall * GetStaticIntField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jlong ( __stdcall * GetStaticLongField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jfloat ( __stdcall * GetStaticFloatField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			jdouble ( __stdcall * GetStaticDoubleField)(JNIEnv * env, jclass clazz, jfieldID fieldID);			void ( __stdcall * SetStaticObjectField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jobject value);			void ( __stdcall * SetStaticBooleanField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jboolean value);			void ( __stdcall * SetStaticByteField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jbyte value);			void ( __stdcall * SetStaticCharField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jchar value);			void ( __stdcall * SetStaticShortField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jshort value);			void ( __stdcall * SetStaticIntField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jint value);			void ( __stdcall * SetStaticLongField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jlong value);			void ( __stdcall * SetStaticFloatField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jfloat value);			void ( __stdcall * SetStaticDoubleField)(JNIEnv * env, jclass clazz, jfieldID fieldID, jdouble value);			jstring ( __stdcall * NewString)(JNIEnv * env, const jchar * unicode, jsize len);			jsize ( __stdcall * GetStringLength)(JNIEnv * env, jstring str);			const jchar *  ( __stdcall * GetStringChars)(JNIEnv * env, jstring str, jboolean * isCopy);			void ( __stdcall * ReleaseStringChars)(JNIEnv * env, jstring str, const jchar * chars);			jstring ( __stdcall * NewStringUTF)(JNIEnv * env, const char * utf);			jsize ( __stdcall * GetStringUTFLength)(JNIEnv * env, jstring str);			const char *  ( __stdcall * GetStringUTFChars)(JNIEnv * env, jstring str, jboolean * isCopy);			void ( __stdcall * ReleaseStringUTFChars)(JNIEnv * env, jstring str, const char * chars);			jsize ( __stdcall * GetArrayLength)(JNIEnv * env, jarray array);			jobjectArray ( __stdcall * NewObjectArray)(JNIEnv * env, jsize len, jclass clazz, jobject init);			jobject ( __stdcall * GetObjectArrayElement)(JNIEnv * env, jobjectArray array, jsize index);			void ( __stdcall * SetObjectArrayElement)(JNIEnv * env, jobjectArray array, jsize index, jobject val);			jbooleanArray ( __stdcall * NewBooleanArray)(JNIEnv * env, jsize len);			jbyteArray ( __stdcall * NewByteArray)(JNIEnv * env, jsize len);			jcharArray ( __stdcall * NewCharArray)(JNIEnv * env, jsize len);			jshortArray ( __stdcall * NewShortArray)(JNIEnv * env, jsize len);			jintArray ( __stdcall * NewIntArray)(JNIEnv * env, jsize len);			jlongArray ( __stdcall * NewLongArray)(JNIEnv * env, jsize len);			jfloatArray ( __stdcall * NewFloatArray)(JNIEnv * env, jsize len);			jdoubleArray ( __stdcall * NewDoubleArray)(JNIEnv * env, jsize len);			jboolean *  ( __stdcall * GetBooleanArrayElements)(JNIEnv * env, jbooleanArray array, jboolean * isCopy);			jbyte *  ( __stdcall * GetByteArrayElements)(JNIEnv * env, jbyteArray array, jboolean * isCopy);			jchar *  ( __stdcall * GetCharArrayElements)(JNIEnv * env, jcharArray array, jboolean * isCopy);			jshort *  ( __stdcall * GetShortArrayElements)(JNIEnv * env, jshortArray array, jboolean * isCopy);			jint *  ( __stdcall * GetIntArrayElements)(JNIEnv * env, jintArray array, jboolean * isCopy);			jlong *  ( __stdcall * GetLongArrayElements)(JNIEnv * env, jlongArray array, jboolean * isCopy);			jfloat *  ( __stdcall * GetFloatArrayElements)(JNIEnv * env, jfloatArray array, jboolean * isCopy);			jdouble *  ( __stdcall * GetDoubleArrayElements)(JNIEnv * env, jdoubleArray array, jboolean * isCopy);			void ( __stdcall * ReleaseBooleanArrayElements)(JNIEnv * env, jbooleanArray array, jboolean * elems, jint mode);			void ( __stdcall * ReleaseByteArrayElements)(JNIEnv * env, jbyteArray array, jbyte * elems, jint mode);			void ( __stdcall * ReleaseCharArrayElements)(JNIEnv * env, jcharArray array, jchar * elems, jint mode);			void ( __stdcall * ReleaseShortArrayElements)(JNIEnv * env, jshortArray array, jshort * elems, jint mode);			void ( __stdcall * ReleaseIntArrayElements)(JNIEnv * env, jintArray array, jint * elems, jint mode);			void ( __stdcall * ReleaseLongArrayElements)(JNIEnv * env, jlongArray array, jlong * elems, jint mode);			void ( __stdcall * ReleaseFloatArrayElements)(JNIEnv * env, jfloatArray array, jfloat * elems, jint mode);			void ( __stdcall * ReleaseDoubleArrayElements)(JNIEnv * env, jdoubleArray array, jdouble * elems, jint mode);			void ( __stdcall * GetBooleanArrayRegion)(JNIEnv * env, jbooleanArray array, jsize start, jsize l, jboolean * buf);			void ( __stdcall * GetByteArrayRegion)(JNIEnv * env, jbyteArray array, jsize start, jsize len, jbyte * buf);			void ( __stdcall * GetCharArrayRegion)(JNIEnv * env, jcharArray array, jsize start, jsize len, jchar * buf);			void ( __stdcall * GetShortArrayRegion)(JNIEnv * env, jshortArray array, jsize start, jsize len, jshort * buf);			void ( __stdcall * GetIntArrayRegion)(JNIEnv * env, jintArray array, jsize start, jsize len, jint * buf);			void ( __stdcall * GetLongArrayRegion)(JNIEnv * env, jlongArray array, jsize start, jsize len, jlong * buf);			void ( __stdcall * GetFloatArrayRegion)(JNIEnv * env, jfloatArray array, jsize start, jsize len, jfloat * buf);			void ( __stdcall * GetDoubleArrayRegion)(JNIEnv * env, jdoubleArray array, jsize start, jsize len, jdouble * buf);			void ( __stdcall * SetBooleanArrayRegion)(JNIEnv * env, jbooleanArray array, jsize start, jsize l, const jboolean * buf);			void ( __stdcall * SetByteArrayRegion)(JNIEnv * env, jbyteArray array, jsize start, jsize len, const jbyte * buf);			void ( __stdcall * SetCharArrayRegion)(JNIEnv * env, jcharArray array, jsize start, jsize len, const jchar * buf);			void ( __stdcall * SetShortArrayRegion)(JNIEnv * env, jshortArray array, jsize start, jsize len, const jshort * buf);			void ( __stdcall * SetIntArrayRegion)(JNIEnv * env, jintArray array, jsize start, jsize len, const jint * buf);			void ( __stdcall * SetLongArrayRegion)(JNIEnv * env, jlongArray array, jsize start, jsize len, const jlong * buf);			void ( __stdcall * SetFloatArrayRegion)(JNIEnv * env, jfloatArray array, jsize start, jsize len, const jfloat * buf);			void ( __stdcall * SetDoubleArrayRegion)(JNIEnv * env, jdoubleArray array, jsize start, jsize len, const jdouble * buf);			jint ( __stdcall * RegisterNatives)(JNIEnv * env, jclass clazz, const JNINativeMethod * methods, jint nMethods);			jint ( __stdcall * UnregisterNatives)(JNIEnv * env, jclass clazz);			jint ( __stdcall * MonitorEnter)(JNIEnv * env, jobject obj);			jint ( __stdcall * MonitorExit)(JNIEnv * env, jobject obj);			jint ( __stdcall * GetJavaVM)(JNIEnv * env, JavaVM * * vm);			void ( __stdcall * GetStringRegion)(JNIEnv * env, jstring str, jsize start, jsize len, jchar * buf);			void ( __stdcall * GetStringUTFRegion)(JNIEnv * env, jstring str, jsize start, jsize len, char * buf);			void *  ( __stdcall * GetPrimitiveArrayCritical)(JNIEnv * env, jarray array, jboolean * isCopy);			void ( __stdcall * ReleasePrimitiveArrayCritical)(JNIEnv * env, jarray array, void * carray, jint mode);			const jchar *  ( __stdcall * GetStringCritical)(JNIEnv * env, jstring string, jboolean * isCopy);			void ( __stdcall * ReleaseStringCritical)(JNIEnv * env, jstring string, const jchar * cstring);			jweak ( __stdcall * NewWeakGlobalRef)(JNIEnv * env, jobject obj);			void ( __stdcall * DeleteWeakGlobalRef)(JNIEnv * env, jweak ref);			jboolean ( __stdcall * ExceptionCheck)(JNIEnv * env);			jobject ( __stdcall * NewDirectByteBuffer)(JNIEnv * env, void * address, jlong capacity);			void *  ( __stdcall * GetDirectBufferAddress)(JNIEnv * env, jobject buf);			jlong ( __stdcall * GetDirectBufferCapacity)(JNIEnv * env, jobject buf);			unsigned int (__stdcall * GetObjectRefType)(JNIEnv* env, jobject obj);		}&gt;</body><body package="JNIPort-JNI">JavaVM_	&lt;C: struct JavaVM_ {			const struct JNIInvokeInterface_ * functions;		}&gt;</body><body package="JNIPort-JNI">__JDK1_1AttachArgs	&lt;C: struct __JDK1_1AttachArgs {			void * __padding;		}&gt;</body><body package="JNIPort-JNI">__JDK1_1InitArgs	&lt;C: struct __JDK1_1InitArgs {			jint version;			char * * properties;			jint checkSource, nativeStackSize, javaStackSize, minHeapSize, maxHeapSize, verifyMode;			char * classpath;			jint ( __stdcall * vfprintf)(FILE * fp, const char * format, va_list args);			void ( __stdcall * exit)(jint code);			void ( __stdcall * abort)(void);			jint enableClassGC, enableVerboseGC, disableAsyncGC, verbose;			jboolean debugging;			jint debugPort;		}&gt;</body><body package="JNIPort-JNI">__JavaVMAttachArgs	&lt;C: struct __JavaVMAttachArgs {			jint version;			char * name;			jobject group;		}&gt;</body><body package="JNIPort-JNI">__JavaVMInitArgs	&lt;C: struct __JavaVMInitArgs {			jint version, nOptions;			JavaVMOption * options;			jboolean ignoreUnrecognized;		}&gt;</body><body package="JNIPort-JNI">__JavaVMOption	&lt;C: struct __JavaVMOption {			char * optionString;			void * extraInfo;		}&gt;</body><body package="JNIPort-JNI">__fpos_t	&lt;C: struct __fpos_t {			unsigned int lopart;			int hipart;		}&gt;</body><body package="JNIPort-JNI">_iobuf	&lt;C: struct _iobuf {			char * _ptr;			int _cnt;			char * _base;			int _flag, _file, _charbuf, _bufsiz;			char * _tmpfname;		}&gt;</body><body package="JNIPort-JNI">_jfieldID	&lt;C: struct _jfieldID&gt;</body><body package="JNIPort-JNI">_jmethodID	&lt;C: struct _jmethodID&gt;</body><body package="JNIPort-JNI">_jobject	&lt;C: struct _jobject&gt;</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>macros</category><body package="JNIPort-JNI">_FPOSOFF: fp	&lt;C: #define _FPOSOFF(fp) ((long)(fp ).lopart)	&gt;</body><body package="JNIPort-JNI">_INTSIZEOF: n	&lt;C: #define _INTSIZEOF(n) ((sizeof(n )+sizeof(int)-1)&amp;~(sizeof(int)-1))	&gt;</body><body package="JNIPort-JNI">va_arg: ap with: t	&lt;C: #define va_arg(ap, t) (*(t *)((ap +=_INTSIZEOF(t ))-_INTSIZEOF(t )))	&gt;</body><body package="JNIPort-JNI">va_end: ap	&lt;C: #define va_end(ap) ( ap =(va_list)0)	&gt;</body><body package="JNIPort-JNI">va_start: ap with: v	&lt;C: #define va_start(ap, v) ( ap =(va_list)&amp;v +_INTSIZEOF(v ))	&gt;</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>additional types</category><body package="JNIPort-JNI">JNICallbacks	&lt;C: struct JNICallbacks {			long ( __stdcall * vfprintf_callback)(FILE * _arg1, const char * _arg2, va_list args);			void ( __stdcall * exit_callback)(long);			void ( __stdcall * abort_callback)(void);		}&gt;</body><body package="JNIPort-JNI">abortCallback	^(self JNICallbacks memberNamed: #abort_callback) value</body><body package="JNIPort-JNI">callback	&lt;C:	typedef void ( __stdcall * callback) (JNIEnv* env, JNIObject obj)&gt;</body><body package="JNIPort-JNI">constJcharPointer	^(CPointerType defaultPointer)		referentType: (CQualifiedType new beConstant type: self jchar);		yourself</body><body package="JNIPort-JNI">exitCallback	^(self JNICallbacks memberNamed: #exit_callback) value</body><body package="JNIPort-JNI">jvalueArray	^self jvalue arrayType</body><body package="JNIPort-JNI">jvalueArray: anInteger	^self jvalue arrayType: anInteger</body><body package="JNIPort-JNI">vfprintfCallback	^(self JNICallbacks memberNamed: #vfprintf_callback) value</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>unions</category><body package="JNIPort-JNI">__jvalue	&lt;C: union __jvalue {			jboolean z;			jbyte b;			jchar c;			jshort s;			jint i;			jlong j;			jfloat f;			jdouble d;			jobject l;		}&gt;</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>error handling</category><body package="JNIPort-JNI">checkReturnCode: aNumber 	"private -- check the return code from a JNI call, and -- if it is not OK -- throw a corresponding JNIError"	aNumber = self JNI_OK ifFalse: [self signalError: aNumber]</body><body package="JNIPort-JNI">errorClass	"private -- answer the class of Exception to use to signal JNI errors"	^ JNIError.</body><body package="JNIPort-JNI">initializeErrorStrings	"self initializeErrorStrings."	errorStrings := IdentityDictionary new.	errorStrings		at: self JNI_OK put: 'success';		at: self JNI_ERR put: 'unknown error';		at: self JNI_EDETACHED put: 'thread detached from the VM';		at: self JNI_EVERSION put: 'JNI version error';		at: self JNI_ENOMEM put: 'not enough memory';		at: self JNI_EEXIST put: 'VM already created';		at: self JNI_EINVAL put: 'invalid arguments'</body><body package="JNIPort-JNI">lookupErrorCode: aNumber	"answer an error string corresponding to the given JNI error code"	errorStrings ifNil: [ self initializeErrorStrings ].	^ errorStrings at: aNumber ifAbsent: [ 'undefined JNI error code' ]</body><body package="JNIPort-JNI">signalError: aNumber	"private -- throw an exception corresponding to the given JNI error code"	self errorClass		signal: (self lookupErrorCode: aNumber)		with: aNumber.</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>accessing</category><body package="JNIPort-JNI">functionsNamesIntroducedAfter: aVersionNumber 	"Answer a collection of function names which were introduced in the JNINativeInterface_ vtable after the version indicated by aVersionNumber. aVersionNumber is one of the JNI_VERSION_N_M constants defined in jni.h."	| names |	names := OrderedCollection new.	aVersionNumber &lt; self JNI_VERSION_1_6 		ifTrue: [names add: #GetObjectRefType].	aVersionNumber &lt; self JNI_VERSION_1_4 		ifTrue: 			[names 				addAll: #(#NewDirectByteBuffer #GetDirectBufferAddress #GetDirectBufferCapacity)].	^names</body><body package="JNIPort-JNI">getJavaVMs	"answer anArray holding pointers to all the JavaVMs that this JNI library knows about. The external data is wrapped in JavaVM objects."	| vms vmArrayType numberOfVMs javaVMs |	vmArrayType := self JavaVM pointerArrayType: 0.	vms := vmArrayType gcCalloc.	numberOfVMs := self getJavaVMsInto: vms bufferLength: 0.	numberOfVMs = 0 ifTrue: [^Array new].	vmArrayType := self JavaVM pointerArrayType: numberOfVMs.	vms := vmArrayType gcCalloc.	numberOfVMs := self getJavaVMsInto: vms bufferLength: numberOfVMs.	self jniAssert: [numberOfVMs = vmArrayType numElements].	javaVMs := Array new: numberOfVMs.	0 to: numberOfVMs - 1		do: 			[:index | 			javaVMs at: index + 1 put: (JNIPort.JNIPortJavaVM on: (vms at: index))].	^javaVMs</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>private</category><body package="JNIPort-JNI">getJavaVMsInto: vms bufferLength: arraySize 	| numberPointer return |	numberPointer := self jsize gcMalloc.	return := self 				JNI_GetCreatedJavaVMs: vms				with: arraySize				with: numberPointer.	self checkReturnCode: return.	^numberPointer contents</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface</class-id> <category>operations</category><body package="JNIPort-JNI">createFirstJNIEnv: aJavaVMInitArgs	"create a new JavaVM and JNIEnv pair using the given JavaVMInitArgs;	answers the JNIEnv instance (from which the JavaVM instance can be reached)"	| javaVM jniEnv jvmPointer envPointer status |	jvmPointer := self JavaVM pointerType gcCalloc.	envPointer := self JNIEnv pointerType gcCalloc.	status := self				JNI_CreateJavaVM: jvmPointer				with: envPointer				with: aJavaVMInitArgs asJNIParameter.	aJavaVMInitArgs freeExternalData.	self checkReturnCode: status.	javaVM := JNIPort.JNIPortJavaVM on: jvmPointer contents.	jniEnv := JNIPort.JNIPortJNIEnv on: envPointer contents.	jniEnv javaVM: javaVM.	^ jniEnv</body><body package="JNIPort-JNI">newJavaVMInitArgs	^JNIPort.JNIPortJavaVMInitArgs new</body><body package="JNIPort-JNI">nullPointer	"In VisualWorks, a null pointer can be substituted by nil."	^nil</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface class</class-id> <category>testing</category><body package="JNIPort-JNI">is64Bit	^ObjectMemory is64Bit</body><body package="JNIPort-JNI">supportsPlatform: aSymbol	"Answer whether the receiver can be used on the platform identified by aSymbol (which is one of the Symbols returned by 'self currentPlatformID'."	^aSymbol ~~ #osx</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface class</class-id> <category>accessing</category><body package="JNIPort-JNI">current	Current == nil ifTrue: [Current := self newForCurrentPlatform].	^Current</body><body package="JNIPort-JNI">resetCurrent	"Release the reference to the current instance. This should be executed during image startup to avoid problems when the image is started on a different platform than where it was saved."	Current := nil</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface class</class-id> <category>private</category><body package="JNIPort-JNI">libraryFilesSearchSignals	"Answer a SignalCollection used to handle exceptions raised when scanning for library files.	 The signals answered by this method will result in those signals being ignored by the	 library search machinery. Clients should not answer signals they wish to receive."	^ExternalLibraryHolder libraryNotFoundSignal</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface class</class-id> <category>instance creation</category><body package="JNIPort-JNI">concreteClassForCurrentPlatform	"We create a correct instance of the interface, depending on the platform"	^self concreteClassForPlatform: self currentPlatformID</body><body package="JNIPort-JNI">concreteClassForPlatform: aSymbol	"Answer the concrete subclass of JNIInterface which should be used for the platform identified by aSymbol."	^self withAllSubclasses		detect: [:each | each supportsPlatform: aSymbol]		ifNone: [JNIPortJNIInterface]</body><body package="JNIPort-JNI">newForCurrentPlatform	"We create a correct instance of the interface, depending on the platform"	^self concreteClassForCurrentPlatform new</body></methods><methods><class-id>JNIPort.JNIPortJNIInterface class</class-id> <category>public runtime</category><body package="JNIPort-JNI">libraryFile: aFilenameOrString 	| libraryFilename |	self resetCurrent.	libraryFilename := aFilenameOrString asFilename.	self concreteClassForCurrentPlatform		libraryDirectories: (Array with: libraryFilename head);		libraryFiles: (Array with: libraryFilename tail)</body></methods><methods><class-id>JNIPort.JNIPortJNIInterfaceForMacOSX class</class-id> <category>testing</category><body package="JNIPort-JNI">supportsPlatform: aSymbol	"Answer whether the receiver can be used on the platform identified by aSymbol (which is one of the Symbols returned by 'self currentPlatformID'."	^aSymbol == #osx</body></methods><methods><class-id>JNIPort.JavaPrimitiveIntStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the int field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getIntFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: anInteger	"private -- set the int field defined by JNIFieldID it aJavaObject to anInteger.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	aJavaObject setIntFID: aJNIFieldID to: anInteger.</body></methods><methods><class-id>JNIPort.JavaPrimitiveIntStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaIntArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Integer'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveIntStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'I'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveIntStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #int.</body></methods><methods><class-id>JNIPort.JavaPrimitiveIntStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Int'</body></methods><methods><class-id>JNIPort.JavaWriteListIteratorAdaptor</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">contents	"it's not clear that this is really part of the external contract of a writable stream	abstraction.  It seems to be appropriate only to external iterators (which 'know' that	there's an underlying container of some sort), however ANSI makes it a part of	&lt;sequencedStream&gt;, and hence &lt;WriteStream&gt;, so we'll include it here, but make	it throw an error"	self shouldNotImplement.</body><body package="JNIPort-Java-AdditionalWrappers">flush	"ignore"</body><body package="JNIPort-Java-AdditionalWrappers">next	"one of the root methods for &lt;ReadStream&gt;, overridden to remove from &lt;WriteStream&gt;"	self shouldNotImplement.</body><body package="JNIPort-Java-AdditionalWrappers">nextPut: anObject 	"one of the root methods of &lt;WriteStream&gt;"	subject hasNext 		ifTrue: [subject set_Object: anObject]		ifFalse: [subject add_Object: anObject].	^anObject</body></methods><methods><class-id>JNIPort.JavaWriteListIteratorAdaptor</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">atEnd	"one of the root methods for &lt;ReadStream&gt;"	^ subject hasNext not.</body><body package="JNIPort-Java-AdditionalWrappers">isReadable	"one of the root methods for &lt;WriteStream&gt;"	^ false.</body><body package="JNIPort-Java-AdditionalWrappers">isWritable	"one of the root methods for &lt;WriteStream&gt;"	^ true.</body></methods><methods><class-id>JNIPort.JavaWriteListIteratorAdaptor</class-id> <category>initializing</category><body package="JNIPort-Java-AdditionalWrappers">subject: aJavaClassInstance	"private -- set the object to which we forward the basic Java iteration messages"	subject := aJavaClassInstance.</body></methods><methods><class-id>JNIPort.JavaWriteListIteratorAdaptor</class-id> <category>character writing</category><body package="JNIPort-Java-AdditionalWrappers">cr	"add the platform specific line delimeter sequence (not the &lt;CR&gt; character)"	self nextPutAll: String lineDelimiter.</body></methods><methods><class-id>JNIPort.JavaWriteListIteratorAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-Java-AdditionalWrappers">for: aJavaClassInstance	"answer a new instance which wraps aJavaClassInstance (which is assumed to be of a class which	implements java.util.ListIterator), and makes it act like WriteStream"	^ (self basicNew)		subject: aJavaClassInstance;		yourself.</body></methods><methods><class-id>JNIPort.JavaCharArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based.	Answers a Character."	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[self jniEnv		GetCharArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	(self elementCType newFromJNIDatum: bufferPointer) asCharacter]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: aCharacterOrInteger	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType				newPointerTo: aCharacterOrInteger asInteger.		[self jniEnv		SetCharArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jchar</body><body package="JNIPort-Java-Base">setElements: aWORDArray offset: anOffset length: anInteger	"copy anInteger elements from aWORDArray into our Java array,	starting at the zero-based anOffset in the target"	self jniEnv			SetCharArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: aWORDArray			onException: [:jex | self jvm throwJavaException: jex].</body></methods><methods><class-id>JNIPort.JavaCharArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block	"one of the root methods for &lt;SequenceableCollection&gt;, note that the indexes are Smalltalk	indexes and, as such, 1-based"	^super		from: aStartIndex		to: aStopIndex		keysAndValuesDo: [:key :value | a2Block value: key value: value asCharacter]</body><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary WORDArray	of chars (unsigned 16bit words) in Java's native format (UTF16) as its parameter.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetCharArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseCharArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaCharArray</class-id> <category>converting</category><body package="JNIPort-Java-Base">asJavaCharArray: aJVM	"Answer a JavaCharArray object which is owned by aJVM."	^ aJVM == self jvm		ifTrue: [self]		ifFalse: [self class from: self asCollection jvm: aJVM].</body><body package="JNIPort-Java-Base">asString	"answer a Smalltalk String with the same bytes (but interpreted as characters)	as the Java byte[] we stand for"	"HACK: see the note in JavaByteArray #asString"	| string |	self size = 0 ifTrue: [^''].	string := String new: self size.	self 		from: 1		to: self size		keysAndValuesDo: [:i :each | string at: i put: each].	^string</body></methods><methods><class-id>JNIPort.JavaCharArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewCharArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.JavaCharArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[C'.</body></methods><methods><class-id>JNIPort.JavaCharArray class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">fromByteArray: aByteArray jvm: aJVM	"answer a new JavaObject wrapping a byte[] which has been created by copying the bytes	in aByteArray"	^self from: aByteArray jvm: aJVM.</body><body package="JNIPort-Java-Base">fromString: aString jvm: aJVM	"answer a new JavaObject wrapping a java.lang.String which has been created by copying the characters	in aString"	^self from: aString jvm: aJVM.</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new: size	"answer a JavaArrayObject wrapping a newly created instance of the Array class we represent"	^ self elementClass newArray: size.</body><body package="JNIPort-Java-Base">with: anObject	"answer a JavaArrayObject of size 1, wrapping a newly created instance of the Array class we represent	and holding anObject"	^ self elementClass newArrayWith: anObject.</body><body package="JNIPort-Java-Base">with: anObject1 with: anObject2	"answer a JavaArrayObject of size 2, wrapping a newly created instance of the Array class we represent	and holding the given objects"	^ self elementClass newArrayWith: anObject1 with: anObject2.</body><body package="JNIPort-Java-Base">with: anObject1 with: anObject2 with: anObject3	"answer a JavaArrayObject of size 3, wrapping a newly created instance of the Array class we represent	and holding the given objects"	^ self elementClass newArrayWith: anObject1 with: anObject2 with: anObject3.</body><body package="JNIPort-Java-Base">withAll: aList	"answer a JavaArrayObject holding the given objects"	^ self elementClass newArrayWithAll: aList.</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic</class-id> <category>accessing</category><body package="JNIPort-Java-Base">elementClass	"answer the class static for the type of our elements"	elementClassCache isNil ifTrue: [elementClassCache := classObject getComponentType classStatic].	^ elementClassCache.</body><body package="JNIPort-Java-Base">instanceElementWrapper	"answer the JVM or class static to be used by instances to wrap their elements as they are	extracted"	instanceElementWrapperCache isNil ifTrue:		[instanceElementWrapperCache := self elementClass couldBeSubstituted								ifTrue: [self jvm]								ifFalse: [self elementClass]].	^ instanceElementWrapperCache.</body><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class.	(note that this is a fairly expensive operation)"	^ '[' , self elementClass jniSignature.</body><body package="JNIPort-Java-Base">name	"answer a name to know ourselves by"	^ self elementClass name , '[]'.</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic</class-id> <category>testing</category><body package="JNIPort-Java-Base">couldBeSubstituted	"answer false if we represent a class for which the JVM rules do not allow any other	to be substituted at runtime (e.g. final classes)"	"this is the way that the JVM treats arrays -- formally odd, but..."	^ self elementClass couldBeSubstituted.</body><body package="JNIPort-Java-Base">isArrayClass	"answer whether we stand for an array class"	^ true.</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic</class-id> <category>initializing</category><body package="JNIPort-Java-Base">javaSuperclass: aJavaStatic	"private -- set the record of our Java superclass.	Overridden not to save the supeclasses instanceClass"	javaSuperclass := aJavaStatic.</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-WrapperGeneration">keywordBase	"private -- answer a suitable String to use for a keyword for parameter of this type without the :"	^ self elementClass keywordBase , 'Array'.</body><body package="JNIPort-Java-WrapperGeneration">parameterBase	"private -- answer a suitable String to use for a parameter of this type"	| base |	base := self elementClass parameterBase.	"ok, I admit this is overdone"	"not to mention Anglo-centric"	#(		('y' 'ies')		('ium' 'ia')	"	('ma' 'mata')	-- e.g. stima/stigmata, forma/formata"		('s' 'ses')		('x' 'xes')	"and if someone is using arrays of oxen... well, life's a bitch"	) do:		[:each | (base endsWith: each first) ifTrue: [^ (base allButLast: each first size) , (each at: 2)]].	^  base , 's'.</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">shouldHaveGhostInstanceClass 	"private -- answer whether we should use a ghost class for our instances"	^ self ghostClassSettings useGhostInstancesForArrays.</body><body package="JNIPort-Java-GhostClasses">shouldHaveGhostStaticClass 	"private -- answer whether we should use a ghost class static"	^ self ghostClassSettings useGhostStaticsForArrays.</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #().</body></methods><methods><class-id>JNIPort.JavaArrayClassStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">defaultInstanceClass	"answer the Smalltalk class to use by default for objects representing instances of our Java class"	^ JavaObjectArray.</body></methods><methods><class-id>JNIPort.JavaSNIConstructorGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">selector	"answer the selector of the method we are going to generate"	^ selector.</body></methods><methods><class-id>JNIPort.JavaSNIConstructorGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">selector: aSelector	"private -- set the selector of the method we are going to generate"	selector := aSelector.</body></methods><methods><class-id>JNIPort.JavaSNIConstructorGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	output		tab;		nextPutAll: '^ self shouldNotImplement.';		cr.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: 'overridden because Java constructors are not inherited, and so we must not inherit #';		nextPutAll: selector;		crtab;		nextPutAll: 'from our Smalltalk superclass';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaSNIConstructorGenerator</class-id> <category>displaying</category><body package="JNIPort-Java-WrapperGeneration">description	"answer a short String description of the member we wrap"	^ 'Override incorrectly inherited constructor wrapper to #shouldNotImplement'.</body></methods><methods><class-id>JNIPort.JavaSNIConstructorGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">selector: aString targetClass: aClass	"answer a new instance which will generate code for a 'should not implement' constructor	method named by aString"	^ (self targetClass: aClass)		selector: aString;		yourself.</body></methods><methods><class-id>JNIPort.JavaLangReflectConstructor</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">getGenericExceptionTypes	"answer the result of calling the receiver's public getGenericExceptionTypes() Java method"	^ self callObjectMethod: 'getGenericExceptionTypes' signature: '()[Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">getGenericParameterTypes	"answer the result of calling the receiver's public getGenericParameterTypes() Java method"	^ self callObjectMethod: 'getGenericParameterTypes' signature: '()[Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">getParameterAnnotations	"answer the result of calling the receiver's public getParameterAnnotations() Java method"	^ self callObjectMethod: 'getParameterAnnotations' signature: '()[[Ljava/lang/annotation/Annotation;'.</body><body package="JNIPort-Java-Base">getTypeParameters	"answer the result of calling the receiver's public getTypeParameters() Java method"	^ self callObjectMethod: 'getTypeParameters' signature: '()[Ljava/lang/reflect/TypeVariable;'.</body><body package="JNIPort-Java-Base">isVarArgs	"answer the result of calling the receiver's public isVarArgs() Java method"	^ self callBooleanMethod: 'isVarArgs'.</body><body package="JNIPort-Java-Base">toGenericString	"answer the result of calling the receiver's public toGenericString() Java method"	^ self callObjectMethod: 'toGenericString' signature: '()Ljava/lang/String;'.</body></methods><methods><class-id>JNIPort.JavaLangReflectConstructor</class-id> <category>accessing</category><body package="JNIPort-Java-Base">argumentCount	"answer how many arguments this method takes"	^self signature parameterCount</body><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this member"	| str |	str := String new writeStream.	str nextPutAll: '('.	self parameterTypes do: [:each | str nextPutAll: each jniSignature].	str nextPutAll: ')V'.	^ str contents.</body><body package="JNIPort-Java-Base">methodID	"answer a JNIMethodID for this field"	^self jniEnv		FromReflectedMethod_method: jniObject		onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">modifiersString	"answer a String describing our modifier flags"	^self signature modifiersString</body><body package="JNIPort-Java-Base">name	"answer the name of the member as a String"	nameCache isNil ifTrue: [nameCache := self signature methodName].	^nameCache</body></methods><methods><class-id>JNIPort.JavaLangReflectConstructor</class-id> <category>reflection</category><body package="JNIPort-Java-Base">exceptionTypes	"answer an Array of class statics corresponding to the resut of the getParameterTypes() Java method"	"this is not often called so we don't cache the result"	^ self getExceptionTypes collect: [:each | each classStatic].</body><body package="JNIPort-Java-Base">parameterTypes	"answer an Array of class statics corresponding to the resut of the getParameterTypes() Java method"	parameterTypesCache isNil ifTrue:		[parameterTypesCache := self getParameterTypes collect: [:each | each classStatic]].	^ parameterTypesCache.</body><body package="JNIPort-Java-Base">signature	"answer whether the method we generate a wrapper for returns void"	signature isNil ifTrue: [signature := self toString asJavaConstructorSignature].	^signature</body><body package="JNIPort-Java-Base">type	"answer the type of this constructor, ie the class static of the constructed instances.	This is actually a bit iffy since there is a real sense that Java constructors have return	type void (as seen by the JVM).  But it helps..."	^ self declaredIn.</body></methods><methods><class-id>JNIPort.JavaLangReflectConstructor</class-id> <category>Java-public</category><body package="JNIPort-Java-Base">getExceptionTypes	"answer the result of calling the receiver's public getExceptionTypes() Java method"	^ self callObjectMethod: 'getExceptionTypes' signature: '()[Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getParameterTypes	"answer the result of calling the receiver's public getParameterTypes() Java method"	^ self callObjectMethod: 'getParameterTypes' signature: '()[Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">newInstance_ObjectArray: anObjects1	"answer the result of calling the receiver's public newInstance(java.lang.Object[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObjects1.			self				callObjectMethod: 'newInstance'				signature: '([Ljava/lang/Object;)Ljava/lang/Object;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangReflectConstructor</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization."	super actAsExecutor.	parameterTypesCache := signature := nil</body></methods><methods><class-id>JNIPort.JavaLangReflectConstructor class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#equals_Object:		#getAnnotation_Class:		#getDeclaredAnnotations		#getDeclaringClass		#getExceptionTypes		#getGenericExceptionTypes		#getGenericParameterTypes		#getModifiers		#getName		#getParameterAnnotations		#getParameterTypes		#getTypeParameters		#hashCode		#isSynthetic		#isVarArgs		#newInstance_ObjectArray:		#toGenericString		#toString	).</body></methods><methods><class-id>JNIPort.JavaLangReflectConstructor class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.reflect.Constructor'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveShortStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the short field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getShortFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: anInteger	"private -- set the short field defined by JNIFieldID it aJavaObject to anInteger.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	aJavaObject setShortFID: aJNIFieldID to: anInteger.</body></methods><methods><class-id>JNIPort.JavaPrimitiveShortStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'S'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveShortStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #short.</body></methods><methods><class-id>JNIPort.JavaPrimitiveShortStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Short'</body></methods><methods><class-id>JNIPort.JavaPrimitiveShortStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaShortArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Short'.</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkRequestQueue</class-id> <category>Java-methods</category><body package="JNIPort-Java-Callbacks">dequeue	"answer the result of calling the receiver's private static synchronized dequeue() Java method"	^ self callObjectMethod: 'dequeue' signature: '()Ljniport/AbstractSmalltalkRequest;'.</body><body package="JNIPort-Java-Callbacks">dequeue_int: int1	"answer the result of calling the receiver's private static synchronized dequeue(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'dequeue'				signature: '(I)[Ljniport/AbstractSmalltalkRequest;'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">enqueue_AbstractSmalltalkRequest: anAbstractSmalltalkRequest	"invoke the receiver's static synchronized enqueue(jniport.AbstractSmalltalkRequest) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anAbstractSmalltalkRequest.			self				callVoidMethod: 'enqueue'				signature: '(Ljniport/AbstractSmalltalkRequest;)V'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">log_String: aString1	"invoke the receiver's public static log(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'log'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">log_String: aString AbstractSmalltalkRequest: anAbstractSmalltalkRequest	"invoke the receiver's public static log(java.lang.String, jniport.AbstractSmalltalkRequest) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			| javaString |			javaString := aString asJavaString: self jvm.			args				objectAt: 1 put: javaString;				objectAt: 2 put: anAbstractSmalltalkRequest.			self				callVoidMethod: 'log'				signature: '(Ljava/lang/String;Ljniport/AbstractSmalltalkRequest;)V'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">log_String: aString SmalltalkNotifierThread: aSmalltalkNotifierThread	"invoke the receiver's public static log(java.lang.String, jniport.SmalltalkNotifierThread) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			| javaString |			javaString := aString asJavaString: self jvm.			args				objectAt: 1 put: javaString;				objectAt: 2 put: aSmalltalkNotifierThread.			self				callVoidMethod: 'log'				signature: '(Ljava/lang/String;Ljniport/SmalltalkNotifierThread;)V'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">requestQueueLength	"answer the result of calling the receiver's public static synchronized requestQueueLength() Java method"	^ self callIntMethod: 'requestQueueLength'.</body><body package="JNIPort-Java-Callbacks">requestQueueMax	"answer the result of calling the receiver's public static synchronized requestQueueMax() Java method"	^ self callIntMethod: 'requestQueueMax'.</body><body package="JNIPort-Java-Callbacks">requestsCompleted	"answer the result of calling the receiver's public static synchronized requestsCompleted() Java method"	^ self callLongMethod: 'requestsCompleted'.</body><body package="JNIPort-Java-Callbacks">shutdown	"invoke the receiver's public static synchronized shutdown() Java method"	self callVoidMethod: 'shutdown'.</body><body package="JNIPort-Java-Callbacks">startLogging_PrintStream: aPrintStream1	"invoke the receiver's public static startLogging(java.io.PrintStream) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aPrintStream1.			self				callVoidMethod: 'startLogging'				signature: '(Ljava/io/PrintStream;)V'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">startLogging_String: aString1	"invoke the receiver's public static startLogging(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'startLogging'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-Callbacks">stopLogging	"invoke the receiver's public static stopLogging() Java method"	self callVoidMethod: 'stopLogging'.</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkRequestQueue</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">nextRequest	"answer the next enqueued request or nil"	^ self dequeue.</body><body package="JNIPort-Java-Callbacks">nextRequests: anInteger	"answer an array of the next anInteger requests or nil"	^ self dequeue_int: anInteger.</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkRequestQueue class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Callbacks">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#dequeue_int:		#dequeue		#enqueue_AbstractSmalltalkRequest:		#log_String:		#log_String:AbstractSmalltalkRequest:		#log_String:SmalltalkNotifierThread:		#requestQueueLength		#requestQueueMax		#requestsCompleted		#shutdown		#startLogging_PrintStream:		#startLogging_String:		#stopLogging	).</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkRequestQueue class</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'jniport.SmalltalkRequestQueue'.</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkRequestQueue class</class-id> <category>testing</category><body package="JNIPort-Java-Callbacks">shouldRegisterWithJVM: aJVM 	^aJVM supportsCallbacks and: [super shouldRegisterWithJVM: aJVM]</body></methods><methods><class-id>JNIPort.JavaUtilList</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">add: anObject afterIndex: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;"	self		add_int: anIndex		"0-based indexing in Java means we don't need to add 1"		Object: anObject.	"discard the usefull result of the above, and instead do it the silly Smalltalk way"	^ anObject.</body><body package="JNIPort-Java-AdditionalWrappers">addLast: anObject	"one of the root methods for &lt;SequenceableCollection&gt;"	self add_Object: anObject.	"discard the usefull result of the above, and instead do it the silly Smalltalk way"	^ anObject.</body><body package="JNIPort-Java-AdditionalWrappers">asAListIterator	"answer the result of calling the receiver's listIterator() Java method.	The answer is already wrapped in a JavaUtilListIterator"	^ self listIterator asAListIterator.</body><body package="JNIPort-Java-AdditionalWrappers">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;"	^ self get_int: anIndex - 1.		"0-based indexing in Java"</body><body package="JNIPort-Java-AdditionalWrappers">at: anIndex put: aJavaObject	"one of the root methods for &lt;SequenceableCollection&gt;"	self		set_int: anIndex - 1		"0-based indexing in Java"		Object: aJavaObject.	"discard useful boolean return value, and instead return this useless value!		  ...sigh"	^ aJavaObject.</body><body package="JNIPort-Java-AdditionalWrappers">listIterator: anInteger	"answer the result of calling the receiver's listIterator() Java method.	Note that the integer index is 1-based, as in Smalltalk, not 0-based as	in the underlying Java method.	The answer is already wrapped in a JavaUtilListIterator"	^ (self listIterator_int: anInteger - 1) asAListIterator.</body><body package="JNIPort-Java-AdditionalWrappers">subListFrom: aStartIndex to: aStopIndex	"answer the result of calling the receiver's subList() Java method.  Note that the	start and stop positions are 1-based, and that aStopIndex *is* included in the range	unlike the underlying Java method.	Note that the answer is already wrapped in a JavaUtilList"	^ (self subList_int: aStartIndex - 1 int: aStopIndex) asAList.</body></methods><methods><class-id>JNIPort.JavaUtilList</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">addAll_int: int1 Collection: aCollection1	"answer the result of calling the receiver's public abstract addAll(int, java.util.Collection) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				objectAt: 2 put: aCollection1.			self				callBooleanMethod: 'addAll'				signature: '(ILjava/util/Collection;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">add_int: int1 Object: anObject1	"invoke the receiver's public abstract add(int, java.lang.Object) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				objectAt: 2 put: anObject1.			self				callVoidMethod: 'add'				signature: '(ILjava/lang/Object;)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">get_int: int1	"answer the result of calling the receiver's public abstract get(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'get'				signature: '(I)Ljava/lang/Object;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">indexOf_Object: anObject1	"answer the result of calling the receiver's public abstract indexOf(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callIntMethod: 'indexOf'				signature: '(Ljava/lang/Object;)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">lastIndexOf_Object: anObject1	"answer the result of calling the receiver's public abstract lastIndexOf(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callIntMethod: 'lastIndexOf'				signature: '(Ljava/lang/Object;)I'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">listIterator	"answer the result of calling the receiver's public abstract listIterator() Java method"	^ self callObjectMethod: 'listIterator' signature: '()Ljava/util/ListIterator;'.</body><body package="JNIPort-Java-AdditionalWrappers">listIterator_int: int1	"answer the result of calling the receiver's public abstract listIterator(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'listIterator'				signature: '(I)Ljava/util/ListIterator;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">remove_int: int1	"answer the result of calling the receiver's public abstract remove(int) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self				callObjectMethod: 'remove'				signature: '(I)Ljava/lang/Object;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">set_int: int1 Object: anObject1	"answer the result of calling the receiver's public abstract set(int, java.lang.Object) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				objectAt: 2 put: anObject1.			self				callObjectMethod: 'set'				signature: '(ILjava/lang/Object;)Ljava/lang/Object;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">subList_int: int1 int: int2	"answer the result of calling the receiver's public abstract subList(int, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				intAt: 1 put: int1;				intAt: 2 put: int2.			self				callObjectMethod: 'subList'				signature: '(II)Ljava/util/List;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaUtilList</class-id> <category>converting</category><body package="JNIPort-Java-AdditionalWrappers">asCollection	"answer an adaptor which makes this Java aggregate object look like something from the Smalltalk	Collection hierarchy.	In fact, for these classes we answer a OrderedCollectionAdaptor wrapped around the	object.  It acts in all (maybe!) ways like a proper SequencedGrowableCollection"	adaptorCache isNil ifTrue: [adaptorCache := OrderedCollectionAdaptor for: self].	^ adaptorCache.</body></methods><methods><class-id>JNIPort.JavaUtilList</class-id> <category>removing</category><body package="JNIPort-Java-AdditionalWrappers">removeAtIndex: anIndex	"one of the root methods for &lt;SequencedGrowableCollection&gt;.	Answers the object that was at the index"	^ self remove_int: anIndex - 1.		"0-based indexing in Java"</body></methods><methods><class-id>JNIPort.JavaUtilList</class-id> <category>enumerating</category><body package="JNIPort-Java-AdditionalWrappers">do: a1Block	"shorthand for:"	^ self asCollection do: a1Block.</body></methods><methods><class-id>JNIPort.JavaUtilList class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#add_int:Object:		#get_int:		#hashCode		#lastIndexOf_Object:		#listIterator_int:		#listIterator		#remove_int:		#set_int:Object:		#subList_int:int:	).</body></methods><methods><class-id>JNIPort.JavaUtilList class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.List'.</body></methods><methods><class-id>JNIPort.JavaWrapperGeneratorSettings</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">generateSNIConstructors	"answer whether we generate #shouldNotImplement wrappers for constructors that are 'inherited'	in Smalltalk, but would not be in Java (and would therefore actually answer an instance of the	superclass)"	^self allFlagsSet: self class generateSNIConstructorsMask</body><body package="JNIPort-Java-WrapperGeneration">generateSNIConstructors: aBool	"set whether we generate #shouldNotImplement wrappers for constructors that are 'inherited'	in Smalltalk, but would not be in Java (and would therefore actually answer an instance of the	superclass)"	self setFlags: self class generateSNIConstructorsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeAbstractMethods	"answer whether we will generate wrapper methods for all of our target class's abstract methods"	^self allFlagsSet: self class wrapAbstractMethodsMask</body><body package="JNIPort-Java-WrapperGeneration">includeAbstractMethods: aBool	"set whether we will generate wrapper methods for all of our target class's abstract methods"	self setFlags: self class wrapAbstractMethodsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeAllSuperclasses	"answer whether we will generate wrapper methods for our target class's inherited members (by	default we only do the directly declared ones, plus public static fields picked up from interfaces)"	^self allFlagsSet: self class wrapAllSuperclassesMask</body><body package="JNIPort-Java-WrapperGeneration">includeAllSuperclasses: aBool	"set whether we will generate wrapper methods for our target class's inherited members (by	default we only do the directly declared ones, plus public static fields picked up from interfaces)"	self setFlags: self class wrapAllSuperclassesMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeBridgeMethods	"answer whether we will generate wrapper methods for all of our target class's bridge methods.	These are methods that the bloody Java compiler generates (in huge numbers) to implement	the disgusting 'covariant returns' feature.  This is off by default because they provide zero	value"	^self allFlagsSet: self class wrapBridgeMethodsMask</body><body package="JNIPort-Java-WrapperGeneration">includeBridgeMethods: aBool	"set whether we will generate wrapper methods for all of our target class's bridge methods"	self setFlags: self class wrapBridgeMethodsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeConstructors	"answer whether we generate wrappers for any constructors"	^self anyFlagsSet: self class wrapAnyConstructorsMask</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessConstructors	"answer whether we will generate wrapper methods for all of our target class's 'default access' constructors"	^self allFlagsSet: self class wrapDefaultAccessConstructorsMask</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessConstructors: aBool	"set whether we will generate wrapper methods for all of our target class's 'default access' constructors"	self setFlags: self class wrapDefaultAccessConstructorsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessFields	"answer whether we will generate wrapper methods for all of our target class's 'default access' fields"	^self allFlagsSet: self class wrapDefaultAccessFieldsMask</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessFields: aBool	"set whether we will generate wrapper methods for all of our target class's 'default access' fields"	self setFlags: self class wrapDefaultAccessFieldsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessMembers	"answer whether we will generate wrapper methods for any of our target class's 'default access' members"	^self anyFlagsSet: self class wrapAnyDefaultMask</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessMembers: aBool	"set whether we will generate wrapper methods for all of our target class's 'default access' members	(i.e. it turns contructor, methods, and fields all on/off together)"	self setFlags: self class wrapAnyDefaultMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessMethods	"answer whether we will generate wrapper methods for all of our target class's 'default access' methods"	^self allFlagsSet: self class wrapDefaultAccessMethodsMask</body><body package="JNIPort-Java-WrapperGeneration">includeDefaultAccessMethods: aBool	"set whether we will generate wrapper methods for all of our target class's 'default access' methods"	self setFlags: self class wrapDefaultAccessMethodsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeFields	"answer whether we generate wrappers for any fields"	^self anyFlagsSet: self class wrapAnyFieldsMask</body><body package="JNIPort-Java-WrapperGeneration">includeMethods	"answer whether we generate wrappers for any methods"	^self anyFlagsSet: self class wrapAnyMethodsMask</body><body package="JNIPort-Java-WrapperGeneration">includeNonPrivateMembers	"answer whether we will generate wrapper methods for any of our target class's non-private members"	^self anyFlagsSet: self class wrapNonPrivateMembersMask</body><body package="JNIPort-Java-WrapperGeneration">includeNonPrivateMembers: aBool	"set whether we will generate wrapper methods for all of our target class's non-private members	(i.e. it turns public, private, and 'default access', contructor, methods, and fields all on/off together)"	self setFlags: self class wrapNonPrivateMembersMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePrivateConstructors	"answer whether we will generate wrapper methods for all of our target class's private constructors"	^self allFlagsSet: self class wrapPrivateConstructorsMask</body><body package="JNIPort-Java-WrapperGeneration">includePrivateConstructors: aBool	"set whether we will generate wrapper methods for all of our target class's private constructors"	self setFlags: self class wrapPrivateConstructorsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePrivateFields	"answer whether we will generate wrapper methods for all of our target class's private fields"	^self allFlagsSet: self class wrapPrivateFieldsMask</body><body package="JNIPort-Java-WrapperGeneration">includePrivateFields: aBool	"set whether we will generate wrapper methods for all of our target class's private fields"	self setFlags: self class wrapPrivateFieldsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePrivateMembers	"answer whether we will generate wrapper methods for any of our target class's private members"	^self anyFlagsSet: self class wrapAnyPrivateMask</body><body package="JNIPort-Java-WrapperGeneration">includePrivateMembers: aBool	"set whether we will generate wrapper methods for all of our target class's private members	(i.e. it turns contructor, methods, and fields all on/off together)"	self setFlags: self class wrapAnyPrivateMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePrivateMethods	"answer whether we will generate wrapper methods for all of our target class's private methods"	^self allFlagsSet: self class wrapPrivateMethodsMask</body><body package="JNIPort-Java-WrapperGeneration">includePrivateMethods: aBool	"set whether we will generate wrapper methods for all of our target class's private methods"	self setFlags: self class wrapPrivateMethodsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedConstructors	"answer whether we will generate wrapper methods for all of our target class's protected constructors"	^self allFlagsSet: self class wrapProtectedConstructorsMask</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedConstructors: aBool	"set whether we will generate wrapper methods for all of our target class's protected constructors"	self setFlags: self class wrapProtectedConstructorsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedFields	"answer whether we will generate wrapper methods for all of our target class's protected fields"	^self allFlagsSet: self class wrapProtectedFieldsMask</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedFields: aBool	"set whether we will generate wrapper methods for all of our target class's protected fields"	self setFlags: self class wrapProtectedFieldsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedMembers	"answer whether we will generate wrapper methods for any of our target class's protected members"	^self anyFlagsSet: self class wrapAnyProtectedMask</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedMembers: aBool	"set whether we will generate wrapper methods for all of our target class's protected members	(i.e. it turns contructor, methods, and fields all on/off together)"	self setFlags: self class wrapAnyProtectedMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedMethods	"answer whether we will generate wrapper methods for all of our target class's protected methods"	^self allFlagsSet: self class wrapProtectedMethodsMask</body><body package="JNIPort-Java-WrapperGeneration">includeProtectedMethods: aBool	"set whether we will generate wrapper methods for all of our target class's protected methods"	self setFlags: self class wrapProtectedMethodsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePublicConstructors	"answer whether we will generate wrapper methods for all of our target class's public constructors"	^self allFlagsSet: self class wrapPublicConstructorsMask</body><body package="JNIPort-Java-WrapperGeneration">includePublicConstructors: aBool	"set whether we will generate wrapper methods for all of our target class's public constructors"	self setFlags: self class wrapPublicConstructorsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePublicFields	"answer whether we will generate wrapper methods for all of our target class's public fields"	^self allFlagsSet: self class wrapPublicFieldsMask</body><body package="JNIPort-Java-WrapperGeneration">includePublicFields: aBool	"set whether we will generate wrapper methods for all of our target class's public fields"	self setFlags: self class wrapPublicFieldsMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePublicMembers	"answer whether we will generate wrapper methods for any of our target class's public members"	^self anyFlagsSet: self class wrapAnyPublicMask</body><body package="JNIPort-Java-WrapperGeneration">includePublicMembers: aBool	"set whether we will generate wrapper methods for all of our target class's public members	(i.e. it turns contructor, methods, and fields all on/off together)"	self setFlags: self class wrapAnyPublicMask to: aBool</body><body package="JNIPort-Java-WrapperGeneration">includePublicMethods	"answer whether we will generate wrapper methods for all of our target class's public methods"	^self allFlagsSet: self class wrapPublicMethodsMask</body><body package="JNIPort-Java-WrapperGeneration">includePublicMethods: aBool	"set whether we will generate wrapper methods for all of our target class's public methods"	self setFlags: self class wrapPublicMethodsMask to: aBool</body></methods><methods><class-id>JNIPort.JavaWrapperGeneratorSettings</class-id> <category>helpers</category><body package="JNIPort-Java-WrapperGeneration">selectGeneratorsFrom: aCollectionOfMemberGenerators	"given the collection of JavaLangReflect{Field/Method} objects, answer a copy without any	that don't match our accessibility criteria"	^ aCollectionOfMemberGenerators select: [:each | each isSelectedBy: self].</body></methods><methods><class-id>JNIPort.JavaWrapperGeneratorSettings class</class-id> <category>constants</category><body package="JNIPort-Java-WrapperGeneration">defaultFlags	"answer the collection of flags that are set by default"	^ self wrapAnyPublicMask | self wrapAbstractMethodsMask.</body><body package="JNIPort-Java-WrapperGeneration">generateSNIConstructorsMask	^16r4000</body><body package="JNIPort-Java-WrapperGeneration">wrapAbstractMethodsMask	^16r1000</body><body package="JNIPort-Java-WrapperGeneration">wrapAllMembersMask	^16r0FFF</body><body package="JNIPort-Java-WrapperGeneration">wrapAllSuperclassesMask	^16r2000</body><body package="JNIPort-Java-WrapperGeneration">wrapAnyConstructorsMask	^16r0F00</body><body package="JNIPort-Java-WrapperGeneration">wrapAnyDefaultMask	^16r0222</body><body package="JNIPort-Java-WrapperGeneration">wrapAnyFieldsMask	^16r00F0</body><body package="JNIPort-Java-WrapperGeneration">wrapAnyMethodsMask	^16r000F</body><body package="JNIPort-Java-WrapperGeneration">wrapAnyPrivateMask	^16r0888</body><body package="JNIPort-Java-WrapperGeneration">wrapAnyProtectedMask	^16r0444</body><body package="JNIPort-Java-WrapperGeneration">wrapAnyPublicMask	^16r0111</body><body package="JNIPort-Java-WrapperGeneration">wrapBridgeMethodsMask	^16r8000</body><body package="JNIPort-Java-WrapperGeneration">wrapDefaultAccessConstructorsMask	^16r0200</body><body package="JNIPort-Java-WrapperGeneration">wrapDefaultAccessFieldsMask	^16r0020</body><body package="JNIPort-Java-WrapperGeneration">wrapDefaultAccessMethodsMask	^16r0002</body><body package="JNIPort-Java-WrapperGeneration">wrapNonPrivateMembersMask	^16r0777</body><body package="JNIPort-Java-WrapperGeneration">wrapPrivateConstructorsMask	^16r0800</body><body package="JNIPort-Java-WrapperGeneration">wrapPrivateFieldsMask	^16r0080</body><body package="JNIPort-Java-WrapperGeneration">wrapPrivateMethodsMask	^16r0008</body><body package="JNIPort-Java-WrapperGeneration">wrapProtectedConstructorsMask	^16r0400</body><body package="JNIPort-Java-WrapperGeneration">wrapProtectedFieldsMask	^16r0040</body><body package="JNIPort-Java-WrapperGeneration">wrapProtectedMethodsMask	^16r0004</body><body package="JNIPort-Java-WrapperGeneration">wrapPublicConstructorsMask	^16r0100</body><body package="JNIPort-Java-WrapperGeneration">wrapPublicFieldsMask	^16r0010</body><body package="JNIPort-Java-WrapperGeneration">wrapPublicMethodsMask	^16r0001</body></methods><methods><class-id>JNIPort.JavaWrapperGeneratorSettings class</class-id> <category>initialize-release</category><body package="JNIPort-Java-WrapperGeneration">obsolete	self uninitialize.	super obsolete</body></methods><methods><class-id>JNIPort.JavaWrapperGeneratorSettings class</class-id> <category>class initialization</category><body package="JNIPort-Java-WrapperGeneration">initializeSettingsTemplate	"private -- class-side intialisation.		self initialize.	"	JVMSettings addToTemplate: self new name: #wrapperGeneratorSettings.</body><body package="JNIPort-Java-WrapperGeneration">uninitialize	"private -- class-side tear-down.		self uninitialize.	"	| settingsClass |	settingsClass := 'JVMSettings' asClassOrNilIn: self environment.	settingsClass ifNotNil: [settingsClass removeFromTemplate: #wrapperGeneratorSettings].</body></methods><methods><class-id>JNIPort.JavaWrapperGeneratorSettings class</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">booleanAspectNames	"private -- answer an Array of the names of boolean aspects of instances"	^ super booleanAspectNames		, #( 			#includeAllSuperclasses			#includeAbstractMethods			#includePublicFields			#includeDefaultAccessFields			#includeProtectedFields			#includePrivateFields			#includePublicMethods			#includeDefaultAccessMethods			#includeProtectedMethods			#includePrivateMethods			#includePublicConstructors			#includeDefaultAccessConstructors			#includeProtectedConstructors			#includePrivateConstructors			#generateSNIConstructors			#includeBridgeMethods		).</body></methods><methods><class-id>JNIPort.JavaObjectArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	"since the element class is fixed for all instances of our class static, we can cache a	default 'wrapper' in the class static. The wrapper is either the jvm, or our/its element class	if that class is non-substitutable (such as String or Integer)"	| answer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	answer := self jniEnv				GetObjectArrayElement_array: jniObject				index: anIndex - 1				onException: [:jex | self jvm throwJavaException: jex].	^static instanceElementWrapper wrapJNIObject: answer</body><body package="JNIPort-Java-Base">at: anIndex put: aJavaObject	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	self jniEnv		SetObjectArrayElement_array: jniObject		index: anIndex-1		val: aJavaObject 		onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">elementClass	"answer the class static for the type of our elements"	^ static elementClass.</body><body package="JNIPort-Java-Base">size	"answer the number of elements in the underlying Java array"	sizeCache isNil ifFalse: [^ sizeCache].	sizeCache := self jniEnv				GetArrayLength_array: jniObject				onException: [:jex | self jvm throwJavaException: jex].	^ sizeCache.</body></methods><methods><class-id>JNIPort.JavaObjectArray</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">clone	"answer the result of calling the (public for arrays) Java method clone()"	"since the answer is fixed by Java semantics, and not subject to programmer vagaries,	we can assume that we know that the new object will be of exactly the same class	as ourself (this is not true of the Object.clone() method in general)"	^ self callObjectMethod: 'clone' signature: '()Ljava/lang/Object;' wrapperFactory: static.</body></methods><methods><class-id>JNIPort.JavaObjectArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">from: aStartIndex to: aStopIndex keysAndValuesDo: a2Block	"one of the root methods for &lt;SequenceableCollection&gt;, note that the indexes are Smalltalk	indexes and, as such, 1-based"	aStartIndex &gt; aStopIndex ifTrue: [^self].	aStartIndex to: aStopIndex do: [:i | a2Block value: i value: (self at: i)]</body></methods><methods><class-id>JNIPort.JavaObjectArray class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">from: aList jvm: aJVM	"answer a new JavaObject wrapping an array initialised by copying the elements of aList"	| new |	new := self new: aList size jvm: aJVM.	new asCollection replaceFrom: 1 to: aList size with: aList.	^ new.</body><body package="JNIPort-Java-Base">new: length elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and the elements are initalised to nil"	^ self		new: length		elementClass: aJavaStatic		initialValue: nil.</body><body package="JNIPort-Java-Base">new: length elementClass: aJavaStatic initialValue: aJavaObject	"answer a new object array where the element type is defined by aJavaStatic	and the elements are initalised to aJavaObject"	| answer jvm |	jvm := aJavaStatic jvm.	answer := jvm jniEnv				NewObjectArray_len: length				class: aJavaStatic				init: aJavaObject				onException: [:jex | jvm throwJavaException: jex].	^answer asJavaObject: jvm</body><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new java.lang.Object[] of the specified size and initialised to nils"	| answer |	answer := aJVM jniEnv				NewObjectArray_len: length				class: (aJVM findClass: #'java.lang.Object')				init: nil				onException: [:jex | aJVM throwJavaException: jex].	^answer asJavaObject: aJVM</body><body package="JNIPort-Java-Base">newWith: aJavaObject elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding aJavaObject"	^ self		new: 1		elementClass: aJavaStatic		initialValue: aJavaObject.</body><body package="JNIPort-Java-Base">newWith: aJavaObject1 with: aJavaObject2 elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding the given JavaObjects"	^ (self new: 2 elementClass: aJavaStatic initialValue: aJavaObject1)		at: 2 put: aJavaObject2;		yourself.</body><body package="JNIPort-Java-Base">newWith: aJavaObject1 with: aJavaObject2 with: aJavaObject3 elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding the given JavaObjects"	^ (self new: 3 elementClass: aJavaStatic initialValue: aJavaObject1)		at: 2 put: aJavaObject2;		at: 3 put: aJavaObject3; 		yourself.</body><body package="JNIPort-Java-Base">newWithAll: aList elementClass: aJavaStatic	"answer a new object array where the element type is defined by aJavaStatic	and holding the given JavaObjects"	| new |	new := self new: aList size elementClass: aJavaStatic.	new asCollection replaceFrom: 1 to: aList size with: aList.	^ new.</body></methods><methods><class-id>JNIPort.JavaObjectArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[Ljava/lang/Object;'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveLongStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the long field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getLongFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: anInteger	"private -- set the long field defined by JNIFieldID it aJavaObject to anInteger.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	aJavaObject setLongFID: aJNIFieldID to: anInteger.</body></methods><methods><class-id>JNIPort.JavaPrimitiveLongStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #long.</body></methods><methods><class-id>JNIPort.JavaPrimitiveLongStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaLongArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Long'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveLongStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'J'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveLongStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Long'</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniPortSettings	"answer the subcollection of settings for configuring the JVM object"	^ self subSettings: #jniPortSettings.</body><body package="JNIPort-Java-Base">localClasspath	"answer the subcollection of settings for setting a 'local' class path"	^ self subSettings: #localClasspath.</body><body package="JNIPort-Java-Base">name	"answer the receiver's String name"	^name 		ifNil: [self jniPortSettings jniLibraryFilename ifNil: [self printString]]</body><body package="JNIPort-Java-Base">name: aString	"set the receiver's name to aString"	name := aString.</body><body package="JNIPort-Java-Base">runtimeSettings	"answer the subcollection of settings for the JNI runtime"	^ self subSettings: #runtimeSettings.</body><body package="JNIPort-Java-Base">subSettings: aSelector	"answer the subsettings object with the given name.	NB: this is normally only called from within this class since,	by convention, any dynamically added sub-settings will also	add a selector with the same name to this class"	^ categories at: aSelector.</body><body package="JNIPort-Java-Base">supplementaryClassloaders	"answer the subcollection of settings for setting a 'local' class path"	^ self subSettings: #supplementaryClassloaders.</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>displaying</category><body package="JNIPort-Java-Base">displayOn: aStream	"append a user-oriented description of ourselves to aStream"	name displayOn: aStream</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state.	NB: this is called only once, as the 'template' instance is first created; subsequent	instances of this class are created by cloning that"	"super initialize."	categories := IdentityDictionary new.</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>printing</category><body package="JNIPort-Java-Base">printOn: aStream 	"write a developer oriented representation of the receiver to aStream"	super printOn: aStream.	name ifNotNil: 			[aStream				nextPut: $(;				print: name;				nextPut: $)]</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>operations</category><body package="JNIPort-Java-Base">addSubSettings: aSettings name: aSelector	"private -- add the object aSettings to our collection of subsettings under the given name.	This is intended to be called as subsystems install themselves, and it (when called	via our class method, #addToTemplate:definition:) allows subsystems to swap in	more-or-less dynamic extensions to the Java settings.	Note, however, that aSelector must be defined against this class too"	categories at: aSelector put: aSettings.</body><body package="JNIPort-Java-Base">removeSubSettings: aSelector	"private -- remove the named set of subsettings"	categories removeKey: aSelector ifAbsent: [].</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>copying</category><body package="JNIPort-Java-Base">deepCopy	^self copy</body><body package="JNIPort-Java-Base">postCopy	super postCopy.	categories := categories deepCopy</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-WrapperGeneration">wrapperGeneratorSettings	"answer the subcollection of settings for the wrapper class generation"	^ self subSettings: #wrapperGeneratorSettings.</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">ghostClassSettings	"answer the subcollection of settings for the ghost classes"	^ self subSettings: #ghostClassSettings.</body><body package="JNIPort-Java-GhostClasses">usesGhosts	"answer whether these settings are such that a JVM configured from	them would use ghost classes.	This intended just as a convenience method"	^self jniPortSettings watcherClasses includes: JVMGhostClassMaker</body><body package="JNIPort-Java-GhostClasses">usesGhosts: aBoolean 	"set whether these settings are such that a JVM configured from	them would use ghost classes.	This intended just as a convenience method"	| watchers |	watchers := self jniPortSettings watcherClasses.	watchers remove: JVMGhostClassMaker ifAbsent: []. "we assume that watcherClasses never contains duplicates"	aBoolean ifTrue: [watchers add: JVMGhostClassMaker]</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>*JNIPort-Java-Callbacks</category><body package="JNIPort-Java-Callbacks">supportsCallbacks	"answer whether these settings are such that a JVM configured from	them would support callbacks.	This intended just as a convenience method"	^ self jniPortSettings jvmClass = JVMWithCallbacks.</body><body package="JNIPort-Java-Callbacks">supportsCallbacks: aBool	"set whether these settings are such that a JVM configured from	them would support callbacks.	This intended just as a convenience method"	^ self jniPortSettings jvmClass: (aBool ifTrue: [JVMWithCallbacks] ifFalse: [JVMWithoutCallbacks]).</body></methods><methods><class-id>JNIPort.JVMSettings</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">loadFromRegistryUnder: aRegKey	"load our state from the registry under the given key.  Answer whether	we found an acceptable minimum of data there.	NB: we are, in fact, exceedingly forgiving about missing data"	| ok |	name := aRegKey at: 'name' ifAbsent: [''].	ok := true.	categories keysAndValuesDo:		[:key :each |		aRegKey subKeyNamed: key ifPresent: [:it | ok := ok &amp; (each loadFromRegistryUnder: it)]].	^ ok.</body><body package="JNIPort-Configuration">saveToRegistryUnder: aRegKey	"save our state to the registry under the given key"	aRegKey at: 'name' put: name.	categories keysAndValuesDo:		[:key :each || subkey |		subkey := aRegKey subKeyNamed: key.		each saveToRegistryUnder: subkey].</body></methods><methods><class-id>JNIPort.JVMSettings class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">createDefaultSettings	"self createDefaultSettings"	self predefined addFirst: (self new name: 'Default JVM')</body><body package="JNIPort-Java-Base">default	"answer the default instance which is, in fact, always the first of the predefined settings.  It	is an error if no such settings have been defined.		self default.	"	predefined isEmpty ifTrue: [self createDefaultSettings].	^ predefined first.</body><body package="JNIPort-Java-Base">initializeSettingsTemplate	"private -- class-side intialisation"	template := (super new) 	"can't call our own #new since it just clones the template"				initialize;				name: '&lt;template&gt;';				yourself.	predefined := OrderedCollection new.	JVMSubSettings allSubclasses do: [:each | each initializeSettingsTemplate].	self createDefaultSettings</body><body package="JNIPort-Java-Base">named: aString	"answer the predefined instance with the given name"	^self predefined detect: [:each | each name = aString] ifNone: [nil].</body><body package="JNIPort-Java-Base">predefined	"answer the OrderedCollection containing the predefined instances.		self predefined.	"	predefined isNil ifTrue: [self initializeSettingsTemplate].	^ predefined.</body><body package="JNIPort-Java-Base">predefined: anOrderedCollection	"set the OrderedCollection containing the predefined instances"	predefined := anOrderedCollection.</body><body package="JNIPort-Java-Base">template	"answer a the template instance which is cloned for further instance creation."	template ifNil: [self initializeSettingsTemplate].	^ template.</body></methods><methods><class-id>JNIPort.JVMSettings class</class-id> <category>adding</category><body package="JNIPort-Java-Base">addSettings: aJVMSettings	self predefined add: aJVMSettings</body><body package="JNIPort-Java-Base">addSettingsNamed: aString 	| settings |	settings := (self new)				name: aString;				yourself.	self addSettings: settings.	^settings</body><body package="JNIPort-Java-Base">addToTemplate: aTemplateObject name: aSelector	"add aTemplateObject to our template accessible via the given name.	Also adds it to any any predefined instances too"	self template addSubSettings: aTemplateObject name: aSelector.	self predefined do: [:each | each addSubSettings: aTemplateObject deepCopy name: aSelector]</body></methods><methods><class-id>JNIPort.JVMSettings class</class-id> <category>removing</category><body package="JNIPort-Java-Base">removeFromTemplate: aString	"remove the subsetting accessed via aSelector from our template and all predefined	settings"	template ifNotNil: [template removeSubSettings: aString].	predefined ifNotNil: [predefined do: [:each | each removeSubSettings: aString]].</body><body package="JNIPort-Java-Base">removeSettings: aJVMSettings	predefined ifNotNil: [predefined remove: aJVMSettings ifAbsent: []]</body><body package="JNIPort-Java-Base">removeSettingsNamed: aString 	predefined ifNil: [^self].	self removeSettings: (self named: aString)</body></methods><methods><class-id>JNIPort.JVMSettings class</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">obsolete	self uninitialize.	super obsolete</body></methods><methods><class-id>JNIPort.JVMSettings class</class-id> <category>class initialization</category><body package="JNIPort-Java-Base">uninitialize	"private -- class-side tear-down.		self uninitialize.	"	template := predefined := nil.</body></methods><methods><class-id>JNIPort.JVMSettings class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">new	"answer a new instance that is a copy of the template instance"	^ (self template deepCopy)		name: '';		yourself.</body></methods><methods><class-id>JNIPort.JVMSettings class</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">loadFromRegistry	"reload class settings (i.e. the system-wide list of pre-defined JVM configurations) from	the registry.		self loadFromRegistry.	"	self loadFromRegistryUnder: self registryEntryRoot.</body><body package="JNIPort-Configuration">loadFromRegistryUnder: aRegKey	"load our class settings (i.e. the system-wide list of pre-defined JVM configurations) from	the registry under the given key"	| count |	template := self newFromRegistryKey: 'template' under: aRegKey ifNone: [^ self].	count := aRegKey at: 'predefined count' ifAbsent: [0].	predefined := OrderedCollection new: count.	1 to: count do:		[:i || subkey |		subkey := 'predefined ' , (NumberPrintPolicy print: i using: '00').		predefined addLast: (self newFromRegistryKey: subkey under: aRegKey ifNone: [^ self])].</body><body package="JNIPort-Configuration">newFromRegistryKey: aString under: aRegKey ifNone: a0Block	"answer a new instance created (as always) by cloning our template, but then overwriting	any information in the instance with whatever data there is in the registry in the named subkey of	the given key.	If there is no reasonable minimum of such data then answer the result of evaluating a0block"	| subkey |	subkey := aRegKey subKeyNamed: aString ifAbsent: [^a0Block value].	^self newFromRegistryUnder: subkey ifNone: a0Block</body><body package="JNIPort-Configuration">newFromRegistryUnder: aRegKey ifNone: a0Block	"answer a new instance created (as always) by cloning our template, but then overwriting	any information in the instance with whatever data there is in the registry under the given key.	If there is no reasonable minimum of such data then answer the result of evaluating a0block"	| new |	new := self new.	^ (new loadFromRegistryUnder: aRegKey)		ifTrue: [new]		ifFalse: [a0Block value].</body><body package="JNIPort-Configuration">registryEntryRoot	"private -- answer a RegKey representing the root of our registry entry"	| keyClass |	keyClass := #{Registry.Key} valueOrDo: [#{WindowsRegistry.Key} bindingOrNil value].	^keyClass HKCU subKeyNamed: self registryRootName</body><body package="JNIPort-Configuration">registryRootName	"private -- answer the name of the root of our registy entry"	^#{Registry.Key} isDefined		ifTrue: ['Software\Metagnostic\JNIPort\Predefined settings']		ifFalse: ['Software\Metagnostic\JNIPort\Settings']</body><body package="JNIPort-Configuration">saveToRegistry	"save our class settings (i.e. the system-wide list of pre-defined JVM configurations) to	the registry.		self saveToRegistry.	"	self saveToRegistryUnder: self registryEntryRoot.</body><body package="JNIPort-Configuration">saveToRegistryUnder: aRegKey	"save our class settings (i.e. the system-wide list of pre-defined JVM configurations) to	the registry under the given key"	| templateKey |	templateKey := aRegKey subKeyNamed: 'template'.	template saveToRegistryUnder: templateKey.	aRegKey at: 'predefined count' put: predefined size.	predefined keysAndValuesDo: 			[:i :each |			| subkey |			subkey := aRegKey subKeyNamed: 'predefined ' , (NumberPrintPolicy print: i using: '00').			each saveToRegistryUnder: subkey]</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectProxy</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">getInvocationHandler_Object: anObject1	"answer the result of calling the receiver's public static getInvocationHandler(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'getInvocationHandler'				signature: '(Ljava/lang/Object;)Ljava/lang/reflect/InvocationHandler;'				withArguments: args]</body><body package="JNIPort-Java-Base">getProxyClass_ClassLoader: aClassLoader1 ClassArray: aClasses1	"answer the result of calling the receiver's public static getProxyClass(java.lang.ClassLoader, java.lang.Class[]) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: aClassLoader1;				objectAt: 2 put: aClasses1.			self				callObjectMethod: 'getProxyClass'				signature: '(Ljava/lang/ClassLoader;[Ljava/lang/Class;)Ljava/lang/Class;'				withArguments: args]</body><body package="JNIPort-Java-Base">isProxyClass_Class: aClass1	"answer the result of calling the receiver's public static isProxyClass(java.lang.Class) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClass1.			self				callBooleanMethod: 'isProxyClass'				signature: '(Ljava/lang/Class;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">newProxyInstance_ClassLoader: aClassLoader1 ClassArray: aClasses1 InvocationHandler: anInvocationHandler1	"answer the result of calling the receiver's public static newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler) Java method"	^JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: aClassLoader1;				objectAt: 2 put: aClasses1;				objectAt: 3 put: anInvocationHandler1.			self				callObjectMethod: 'newProxyInstance'				signature: '(Ljava/lang/ClassLoader;[Ljava/lang/Class;Ljava/lang/reflect/InvocationHandler;)Ljava/lang/Object;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectProxy class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#getInvocationHandler_Object:		#getProxyClass_ClassLoader:ClassArray:		#isProxyClass_Class:		#newProxyInstance_ClassLoader:ClassArray:InvocationHandler:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangReflectProxy class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.reflect.Proxy'.</body></methods><methods><class-id>JNIPort.JavaListingMethodGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">entries: aCollection	"private -- set the Collection of entries that our generated method will answer"	entries := aCollection.</body><body package="JNIPort-Java-WrapperGeneration">selector: aSelector	"private -- set the selector of the method we are going to generate"	selector := aSelector.</body></methods><methods><class-id>JNIPort.JavaListingMethodGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	| selectors |	"add selectors from the existing implementation, if any"	selectors := (targetClass includesSelector: selector)				ifTrue: [(IdentitySet withAll: entries)						addAll: (targetClass instanceClass perform: selector);						yourself]				ifFalse: [entries].	output		tab;		nextPutAll: '^ #(';		cr.	selectors asSortedCollection do:		[:each | output				tab: 2;				nextPut: $#;				nextPutAll: each;				cr].	output		tab;		nextPutAll: ').';		cr.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: 'answer an Array of the selectors of automatically generated methods.';		cr;		tab;		nextPutAll: 'Note that this does not include inherited selectors';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaListingMethodGenerator</class-id> <category>displaying</category><body package="JNIPort-Java-WrapperGeneration">description	"answer a short String description of the member we wrap"	^ 'List the generated methods'.</body></methods><methods><class-id>JNIPort.JavaListingMethodGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">entries	"answer the Collection of entries that our generated method will answer"	^ entries.</body><body package="JNIPort-Java-WrapperGeneration">selector	"answer the selector of the method we are going to generate"	^ selector.</body></methods><methods><class-id>JNIPort.JavaListingMethodGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">selector: aSelector entries: aCollection targetClass: aClass	"answer a new instance which will generate code for a method named by aString	that will answer aCollection"	^ (self targetClass: aClass)		selector: aSelector;		entries: aCollection;		yourself.</body></methods><methods><class-id>JNIPort.JavaIoOutputStream</class-id> <category>writing</category><body package="JNIPort-Java-AdditionalWrappers">next: aSize putAll: aSequenceableCollection startingAt: anIndex	"add aSize elements of aSequenceableCollection from anIndex.	Answers aSequenceableCollection"	self		writeBytes: aSequenceableCollection		from: anIndex		to: anIndex + aSize.	^ aSequenceableCollection.</body><body package="JNIPort-Java-AdditionalWrappers">nextPutAll: aSequenceableCollection	"add aSequenceableCollection.	Answers aSequenceableCollection"	self writeBytes: aSequenceableCollection.	^ aSequenceableCollection.</body><body package="JNIPort-Java-AdditionalWrappers">writeBytes: aByteArray	"invoke the receiver's write() Java method, the argument can be a Java byte[], a	Smalltalk ByteArray, or a String"	self write_byteArray: (aByteArray asJavaByteArray: self jvm).</body><body package="JNIPort-Java-AdditionalWrappers">writeBytes: aByteArray from: aStartIndex to: aStopIndex	"invoke the receiver's write() Java method, the argument can be a Java byte[], a Smalltalk	ByteArray, or a String.  Note that the start and stop positions are 1-based, and that aStopIndex	*is* included in the range unlike the real Java method"	self		write_byteArray: (aByteArray asJavaByteArray: self jvm)		int: aStartIndex - 1		int: aStopIndex - aStartIndex + 1.</body></methods><methods><class-id>JNIPort.JavaIoOutputStream</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">isBinary	"answer whether we write bytes rather than chars"	^ true.</body></methods><methods><class-id>JNIPort.JavaIoOutputStream</class-id> <category>Java-public</category><body package="JNIPort-Java-AdditionalWrappers">write_byteArray: bytes1	"invoke the receiver's public write(byte[]) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: bytes1.			self callVoidMethod: 'write' signature: '([B)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">write_byteArray: bytes1 int: int1 int: int2	"invoke the receiver's public write(byte[], int, int) Java method"	JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: bytes1;				intAt: 2 put: int1;				intAt: 3 put: int2.			self callVoidMethod: 'write' signature: '([BII)V' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaIoOutputStream class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.io.OutputStream'.</body></methods><methods><class-id>JNIPort.JavaIoOutputStream class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ super generatedWrapperSelectors , #(		#write_byteArray:		#write_byteArray:int:int:	).</body></methods><methods><class-id>JNIPort.JavaEnumerationAdaptor</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">next	"one of the root methods for &lt;ReadStream&gt;"	^ subject nextElement.</body></methods><methods><class-id>JNIPort.JavaEnumerationAdaptor</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">atEnd	"one of the root methods for &lt;ReadStream&gt;"	^ subject hasMoreElements not.</body><body package="JNIPort-Java-AdditionalWrappers">isReadable	"one of the root methods for &lt;ReadStream&gt;"	^ true.</body><body package="JNIPort-Java-AdditionalWrappers">isWritable	"one of the root methods for &lt;ReadStream&gt;"	^ false.</body></methods><methods><class-id>JNIPort.JavaEnumerationAdaptor</class-id> <category>initializing</category><body package="JNIPort-Java-AdditionalWrappers">subject: aJavaClassInstance	"private -- set the object to which we forward the basic Java enumeration messages"	subject := aJavaClassInstance.</body></methods><methods><class-id>JNIPort.JavaEnumerationAdaptor class</class-id> <category>instance creation</category><body package="JNIPort-Java-AdditionalWrappers">for: aJavaClassInstance	"answer a new instance which wraps aJavaClassInstance (which is assumed to be of a class which	implments java.util.Enumeration), and makes it act like ReadStream"	^ (self basicNew)		subject: aJavaClassInstance;		yourself.</body></methods><methods><class-id>JNIPort.JavaGhostFieldSetterGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-GhostClasses">genericTypeName	"answer one of Boolean, Byte, ... Object, Short, or, Void according to our type"	genericTypeNameCache isNil 		ifTrue: 			[genericTypeNameCache := reflection signature genericTypeName capitalized].	^genericTypeNameCache</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (IdentityDictionary new)		at: #JVM put: self jvm;		at: #FieldID put: reflection fieldID;		yourself.</body><body package="JNIPort-VW-Compatibility">methodSource	^PrototypeSources at: reflection signature prototypeMethodKey		ifAbsentPut: [super methodSource]</body></methods><methods><class-id>JNIPort.JavaGhostFieldSetterGenerator</class-id> <category>generating</category><body package="JNIPort-Java-GhostClasses">writeMethodBody	"private -- write a method body to our output stream"	"since this will be generated code, and hardly ever seen (except in the debugger),	we can drop right to the lowest level to gain speed.  However the big gain is that	the JVM. and especially the JNIFieldID, can be embedded directly in the	generated method's literal frame"	| isStatic valueString parameterName |	self isDummy ifTrue: [^self writeDummyMethodBody].	isStatic := reflection isStatic.	parameterName := 't1'.	valueString := reflection signature 				conversionToJavaStringFor: parameterName				wrapperFactoryString: self jvmString.	reflection signature needsBoundsChecking		ifTrue: 			[output				tab;				nextPutAll: 'self jniEnv ' , reflection signature type , 'Type validateValue: ' , parameterName							, '.';				cr].	output		tab;		nextPutAll: 'self jniEnv';		cr;		tab: 2;		nextPutAll: (isStatic ifTrue: ['SetStatic'] ifFalse: ['Set']);		nextPutAll: self genericTypeName;		nextPutAll: (isStatic ifTrue: ['Field_class: '] ifFalse: ['Field_obj: ']);		nextPutAll: self jniObjectString;		cr;		tab: 2;		nextPutAll: 'fieldID: ';		nextPutAll: self ghostFieldIDString;		cr;		tab: 2;		nextPutAll: 'val: ';		nextPutAll: valueString;		cr;		tab: 2;		nextPutAll: 'onException: [:jex | ^';		nextPutAll: self jvmString;		nextPutAll: ' throwJavaException: jex]';		nextPut: $.</body><body package="JNIPort-Java-GhostClasses">writeMethodPattern	"private -- write a 'method pattern' (header) to our output stream"	output		nextPutAll: self selector;		space;		nextPutAll: 't1';		cr</body></methods><methods><class-id>JNIPort.JavaGhostFieldSetterGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-GhostClasses">computeSelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	^generateLongKeywords | includeTypeInSelector 		ifTrue: [super computeSelector]		ifFalse: [reflection signature smalltalkSetSelector]</body></methods><methods><class-id>JNIPort.JavaGhostFieldSetterGenerator</class-id> <category>constants</category><body package="JNIPort-Java-GhostClasses">jvmString	"answer the String which we use for accessing the JVM from a method"	^'#JVM'</body></methods><methods><class-id>JNIPort.JavaGhostFieldSetterGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-VW-Compatibility">prototypeMethodFor: methodSource	^PrototypeMethods at: reflection signature prototypeMethodKey		ifAbsentPut: [super prototypeMethodFor: methodSource]</body></methods><methods><class-id>JNIPort.JavaGhostFieldSetterGenerator class</class-id> <category>class initialization</category><body package="JNIPort-Java-GhostClasses">initialize	self resetPrototypes</body><body package="JNIPort-Java-GhostClasses">resetPrototypes	"self resetPrototypes"	PrototypeSources := Dictionary new.	PrototypeMethods := Dictionary new</body></methods><methods><class-id>JNIPort.JNIHelperLibrary</class-id> <category>structs</category><body package="JNIPort-JNIHelper">__DolphinJNIHelper	&lt;C: struct __DolphinJNIHelper {			long ( __stdcall * vfprintf_handler)(FILE * _arg1, const char * _arg2, va_list args);			void ( __stdcall * exit_handler)(long);			void ( __stdcall * abort_handler)(void);			long ( __stdcall * vfprintf_callback)(FILE * _arg1, const char * _arg2, va_list args);			void ( __stdcall * exit_callback)(long);			void ( __stdcall * abort_callback)(void);			unsigned long thread_id;			unsigned int queue_length, max_queue_length;		}&gt;</body><body package="JNIPort-JNIHelper">_iobuf	&lt;C: struct _iobuf {			char * _ptr;			int _cnt;			char * _base;			int _flag, _file, _charbuf, _bufsiz;			char * _tmpfname;		}&gt;</body></methods><methods><class-id>JNIPort.JNIHelperLibrary</class-id> <category>types</category><body package="JNIPort-JNIHelper">DolphinJNIHelper	&lt;C: typedef struct __DolphinJNIHelper DolphinJNIHelper&gt;</body><body package="JNIPort-JNIHelper">FILE	&lt;C: typedef struct _iobuf FILE&gt;</body><body package="JNIPort-JNIHelper">va_list	&lt;C: typedef char * va_list&gt;</body></methods><methods><class-id>JNIPort.JNIHelperLibrary</class-id> <category>additional types</category><body package="JNIPort-JNIHelper">abortCallback	^(self DolphinJNIHelper baseType memberNamed: #abort_callback) value</body><body package="JNIPort-JNIHelper">exitCallback	^(self DolphinJNIHelper baseType memberNamed: #exit_callback) value</body><body package="JNIPort-JNIHelper">vfprintfCallback	^(self DolphinJNIHelper baseType memberNamed: #vfprintf_callback) value</body></methods><methods><class-id>JNIPort.JNIHelperLibrary</class-id> <category>must strip</category><body package="JNIPort-JNIHelper">test	"simple test that everthing's OK		self new test.	"	| helper vfprintf exit abort |	self jniAssert: [self MaxHelpers &gt; 0].	self jniAssert: [self AvailableHelpers &gt; 0].	self jniAssert: [self AvailableHelpers &lt;= self MaxHelpers].	vfprintf := JNIPortCallback do: 					[:fp :format :args | 					Transcript 						show: ('vfprintf&lt;t&gt;&lt;1s&gt;&lt;n&gt;' expandMacrosWith: (format copyCStringFromHeap 										vsnprintfWithArguments: args)).					nil]				ofType: self vfprintfCallback.	exit := JNIPortCallback do: 					[:code | 					Transcript show: ('exit&lt;t&gt;&lt;1p&gt;&lt;n&gt;' expandMacrosWith: code).					nil]				ofType: self exitCallback.	abort := JNIPortCallback do: 					[Transcript show: 'abort\' withCRs.					nil]				ofType: self abortCallback.		helper := self makeJNIHelper.	[helper		vfprintf_callback: vfprintf;		exit_callback: exit;		abort_callback: abort.	self TestJNIHelperVFPrintf: helper asJNIParameter.	self TestJNIHelperExit: helper asJNIParameter.	self TestJNIHelperAbort: helper asJNIParameter] 			ensure: [self ReleaseJNIHelper: helper asJNIParameter]</body></methods><methods><class-id>JNIPort.JNIHelperLibrary</class-id> <category>helpers</category><body package="JNIPort-JNIHelper">makeJNIHelper	"answer a new JNIHelper that is 'owned' by this library"	| new |	new := JNIHelper on: self GetJNIHelper.	new isNil 		ifFalse: 			[new library: self.			self registry register: new].	^new</body><body package="JNIPort-JNIHelper">registry	^RegisteredJNIHelpers ifNil: [RegisteredJNIHelpers := JNIPortWeakRegistry new]</body></methods><methods><class-id>JNIPort.JNIHelperLibrary</class-id> <category>accessing</category><body package="JNIPort-JNIHelper">getVFDBPrintf	"private -- answer the address of the VFDBPrintf() function"	| method |	method := self class compiledMethodAt: #VFDBPrintf:with:with:.	"This should be &lt;method mapAddress&gt;, but ExternalMethod&gt;&gt;mapAddress has a bug in earlier versions of VisualWorks."	^method class mapAddressFor: method</body></methods><methods><class-id>JNIPort.JNIHelperLibrary class</class-id> <category>accessing</category><body package="JNIPort-JNIHelper">default	Default isNil ifTrue: [Default := self new].	^Default</body></methods><methods><class-id>JNIPort.JNIHelperLibrary class</class-id> <category>private</category><body package="JNIPort-JNIHelper">libraryFilesSearchSignals	"Answer a SignalCollection used to handle exceptions raised when scanning for library files.	 The signals answered by this method will result in those signals being ignored by the	 library search machinery. Clients should not answer signals they wish to receive."	^#{LibraryNotFoundError} ifDefinedDo: 			[:libraryNotFound |			libraryNotFound , LibraryNotLoadedError , ExternalObjectNotFoundError]		elseDo: [LibraryNotLoadedError , ExternalObjectNotFoundError]</body></methods><methods><class-id>JNIPort.JavaMethodSignature</class-id> <category>accessing</category><body package="JNIPort-Java-Base">computeSmalltalkSelector	| selector |	selector := self shortMethodName.	parameterTypes size &gt; 0 ifTrue: [selector := selector , '_'].	parameterTypes do: [:paramType | selector := selector , (self shortNameOfType: paramType) , ':'].	^selector asSymbol</body><body package="JNIPort-Java-Base">genericParameterTypeNameAt: anInteger 	"return the smalltalk selector for this java signature"	^self genericTypeNameFor: (self parameterTypeAt: anInteger)</body><body package="JNIPort-Java-Base">genericReturnTypeName	"return the smalltalk selector for this java signature"	^self genericTypeNameFor: self returnType</body><body package="JNIPort-Java-Base">jniReturnType	^ self jniTypeStringOf: returnType</body><body package="JNIPort-Java-Base">jniSignatureString	| parameterTypesString |	parameterTypesString := ''.	self parameterTypes do: 			[:type | 			parameterTypesString := parameterTypesString , (self jniTypeStringOf: type)].	^'(' , parameterTypesString , ')' , self jniReturnType</body><body package="JNIPort-Java-Base">methodName	^ methodName</body><body package="JNIPort-Java-Base">parameterCount	^self parameterTypes size</body><body package="JNIPort-Java-Base">parameterTypeAt: anInteger 	^self parameterTypes at: anInteger</body><body package="JNIPort-Java-Base">parameterTypes	^ parameterTypes</body><body package="JNIPort-Java-Base">returnType	^ returnType</body><body package="JNIPort-Java-Base">shortMethodName	^self unqualifiedJavaMethodName copyReplacing: $$ withObject: $_</body><body package="JNIPort-Java-Base">smalltalkSelector	"return the smalltalk selector for this java signature"	smalltalkSelector 		ifNil: [smalltalkSelector := self computeSmalltalkSelector].	^smalltalkSelector</body><body package="JNIPort-Java-Base">type	^self returnType</body><body package="JNIPort-Java-Base">unqualifiedJavaMethodName	| dotIndex |	dotIndex := methodName lastIndexOf: $..	^methodName copyFrom: dotIndex + 1 to: methodName size</body></methods><methods><class-id>JNIPort.JavaMethodSignature</class-id> <category>comparing</category><body package="JNIPort-Java-Base">isSameAs: aJavaMethodSignature 	(self parameterCount = aJavaMethodSignature parameterCount 		and: [self returnType = aJavaMethodSignature returnType]) ifFalse: [^false].	self parameterTypes with: aJavaMethodSignature parameterTypes		do: [:ownType :otherType | ownType = otherType ifFalse: [^false]].	^true</body></methods><methods><class-id>JNIPort.JavaMethodSignature</class-id> <category>printing</category><body package="JNIPort-Java-Base">printOn: aStream	self jniSignatureString printOn: aStream</body></methods><methods><class-id>JNIPort.JavaMethodSignature</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">fromString: aString 	"Parses a simple java method header of the following format: &lt;list of modifiers&gt; &lt;return type&gt; &lt;qualified method name&gt;(&lt;list of parameter types&gt;) &lt;exception declaration&gt;	All types must be fully qualified names or native types. Exception declarations are ignored. The format is the one used in the result of by java.lang.reflect.Method.toString()."	| argumentListBeginIndex signatureString argumentListEndIndex modifiersTypeAndName |	argumentListBeginIndex := aString indexOf: $(.	argumentListEndIndex := aString indexOf: $).	modifiersTypeAndName := (aString copyFrom: 1 to: argumentListBeginIndex - 1) 				subStrings: ' '.	modifiers := modifiersTypeAndName copyFrom: 1				to: modifiersTypeAndName size - 2.	returnType := modifiersTypeAndName at: modifiersTypeAndName size - 1.	methodName := modifiersTypeAndName last.	signatureString := aString copyFrom: argumentListBeginIndex + 1				to: argumentListEndIndex - 1.	parameterTypes := signatureString isEmpty 				ifTrue: [Array new]				ifFalse: [signatureString subStrings: ',']</body></methods><methods><class-id>JNIPort.JavaMethodSignature</class-id> <category>private</category><body package="JNIPort-Java-Base">jniTypeStringOf: aType 	| jniTypeString tempType dim |	tempType := aType.	(tempType includes: $[) 		ifTrue: 			[dim := tempType occurrencesOf: $[.			jniTypeString := String new: dim withAll: $[.			tempType := tempType allButLast: dim * 2]		ifFalse: [jniTypeString := ''].	^jniTypeString , (JNITypes at: tempType asSymbol				ifAbsent: ['L',(tempType copyReplaceAll: '.' with: '/') , ';'])</body><body package="JNIPort-Java-Base">shortNameOfArrayType: aString 	| dim shortName startIndex |	dim := aString occurrencesOf: $[.	(aString includes: $.) 		ifTrue: 			[startIndex := aString lastIndexOf: $..			startIndex := startIndex + 1.			shortName := aString copyFrom: startIndex to: aString size - (dim * 2)]		ifFalse: 			[shortName := (aString copyFrom: 1 to: aString size - (dim * 2)) asSymbol].	1 to: dim do: [:i | shortName := shortName , 'Array'].	^shortName</body><body package="JNIPort-Java-Base">shortNameOfType: aString 	| shortName |	shortName := aString last = $] 				ifTrue: [self shortNameOfArrayType: aString]				ifFalse: [aString copyFrom: (aString lastIndexOf: $.) + 1 to: aString size].	^shortName copyReplacing: $$ withObject: $_</body></methods><methods><class-id>JNIPort.JavaMethodSignature</class-id> <category>testing</category><body package="JNIPort-Java-Base">hasStringParameterAt: anInteger	^(self parameterTypes at: anInteger) = 'java.lang.String'</body><body package="JNIPort-Java-Base">hasStringParameters	^self parameterTypes includes: 'java.lang.String'</body><body package="JNIPort-Java-Base">isVoidReturn	^self returnType = 'void'</body></methods><methods><class-id>JNIPort.JavaMethodSignature</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">prototypeMethodKey	| stream |	stream := (String new: 100) writeStream.	self isStatic ifTrue: [stream nextPutAll: 'static'].	stream nextPutAll: (self prototypeMethodKeyFor: self returnType).	self parameterTypes do: [:type | stream nextPutAll: (self prototypeMethodKeyFor: type)].	^stream contents</body></methods><methods><class-id>JNIPort.JavaConstructorSignature</class-id> <category>testing</category><body package="JNIPort-Java-Base">isOfPrimitiveType	"Answer false - constructors cannot return primitive types"	^false</body><body package="JNIPort-Java-Base">isVoidReturn	"Answer false - constructors cannot return void."	^false</body></methods><methods><class-id>JNIPort.JavaConstructorSignature</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">fromString: aString 	"Parses a simple java constructor header of the following format: &lt;list of modifiers&gt; &lt;return type&gt;(&lt;list of parameter types&gt;) &lt;exception declaration&gt;	All types must be fully qualified names or native types. Exception declarations are ignored. The format is the one used in the result of by java.lang.reflect.Constructor.toString()."	| argumentListBeginIndex signatureString argumentListEndIndex modifiersAndName |	argumentListBeginIndex := aString indexOf: $(.	argumentListEndIndex := aString indexOf: $).	modifiersAndName := (aString copyFrom: 1 to: argumentListBeginIndex - 1) 				subStrings: ' '.	modifiers := modifiersAndName copyFrom: 1 to: modifiersAndName size - 1.	returnType := methodName := modifiersAndName last.	signatureString := aString copyFrom: argumentListBeginIndex + 1				to: argumentListEndIndex - 1.	parameterTypes := signatureString isEmpty 				ifTrue: [Array new]				ifFalse: [signatureString subStrings: ',']</body></methods><methods><class-id>JNIPort.JavaConstructorSignature</class-id> <category>accessing</category><body package="JNIPort-Java-Base">shortMethodName	^'new'</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>accessing</category><body package="JNIPort-Java-Base">classIndex	"answer our index of known-by-name classes"	^ self classloader classIndex.</body><body package="JNIPort-Java-Base">classloader	"answer our classloader, may activate it if we are not yet active,	or answer nil if we are disabled"	"ensure that we're as active as we're alowed to be"	self activate.	^ classloader.</body><body package="JNIPort-Java-Base">classloaderClass	"answer the Symbol name of our classloader class"	^ classloaderClass ifNil: [self defaultClassloaderClass].</body><body package="JNIPort-Java-Base">classloaderClass: aString	"set our classloader classname to aString"	self jniAssert: [self isActive not].	classloaderClass := aString asSymbol.	self notifyChanged.</body><body package="JNIPort-Java-Base">jvm	"answer our owning JVM"	^ containingTree jvm.</body><body package="JNIPort-Java-Base">localClassIndex	"answer our index of known-by-name classes"	^ self classloader localClassIndex.</body><body package="JNIPort-Java-Base">name	"answer our Symbol name"	^ name ifNil: ['&lt;not set&gt;' asSymbol].</body><body package="JNIPort-Java-Base">nameOrPath	"private -- answer our #name, or if that is not set, our #path.	This is only used when a SupplementaryClassloaderTree is configuring itself	by copying the edit-omly elements in a settings object"	^ (name ifNil: [path ifNil: ['&lt;anonymous&gt;']]) asSymbol.</body><body package="JNIPort-Java-Base">parentEntry	"answer our parent, or nil if we have no declared parent"	^ (parentName isNil or: [parentName isEmpty])		ifTrue: [nil]		ifFalse: [containingTree entryNamed: parentName ifAbsent: [nil]].</body><body package="JNIPort-Java-Base">parentName	"answer our parent name, may be empty"	^ parentName ifNil: [''].</body><body package="JNIPort-Java-Base">parentName: aString	"set our parent name to aString.  This is used to link instances	up into trees"	self jniAssert: [self isActive not].	parentName := aString asSymbol.	self notifyChanged.</body><body package="JNIPort-Java-Base">path	"answer our path.  This is a slightly ill-defined concept, if our classloaderClass	is #java.lang.Classloader, then the #path is the string that will be passed to	its constructor -- a searchpath of URLs.  If the class is different then the #path	will be interpreted in whatever way is appropriate (in so far as we can make a	sensible guess about what is appropriate)"	^ path ifNil: [''].</body><body package="JNIPort-Java-Base">path: aString	"set our path.  This is a slightly ill-defined concept, if our classloaderClass	is #java.lang.Classloader, then the #path is the string that will be passed to	its constructor -- a searchpath of URLs.  If the class is different then the #path	will be interpreted in whatever way is appropriate (in so far as we can make a	sensible guess about what is appropriate)"	self jniAssert: [self isActive not].	path := aString.	self notifyChanged.</body><body package="JNIPort-Java-Base">sharedMutex	"answer the JVM-wide mutex"	^ self jvm sharedMutex.</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>testing</category><body package="JNIPort-Java-Base">classloaderIs: aJavaLangClassloader	"answer whether our classloader is the same as that given"	"we use an identity test since JavaLangClassloader has canonical instances"	^ aJavaLangClassloader == classloader.</body><body package="JNIPort-Java-Base">hasParent	"answer whether we have a parent entry"	^ self parentName notEmpty.</body><body package="JNIPort-Java-Base">isActive	"answer whether we are active"	^ classloader notNil.</body><body package="JNIPort-Java-Base">isDisabled	"answer whether we are disabled"	^ isEnabled ifNil: [false] ifNotNil: [:it | it not].</body><body package="JNIPort-Java-Base">isEnabled	"answer whether we are enabled"	^ isEnabled.</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>displaying</category><body package="JNIPort-Java-Base">displayOn: aStream 	"append a user-centric description of ourself to aStream"	aStream		print: self name;		space;		print: self path.	self hasParent 		ifTrue: 			[aStream				nextPutAll: ' [';				print: self parentName;				nextPutAll: ']']</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>purging</category><body package="JNIPort-Java-Base">isEnabled: aBool	"set whether we are enabled.  If not then we will not activate ourself lazily, but will instead throw an error.	Note that disabling an active instance will cause it to purge itself"	aBool = isEnabled ifTrue: [^ self].	self isActive ifTrue: [self purge].	isEnabled := aBool.	self notifyChanged.</body><body package="JNIPort-Java-Base">purge	"purge this classloader.  That means that we:		- purge any child classloaders we know about,		- purge and discard our own uderlying JavaLangClassloader"	self isActive ifFalse: [^ self].	(containingTree childrenOfEntry: self) do: [:each | each purge].	classloader purge.	classloader := nil.	self notifyChanged.</body><body package="JNIPort-Java-Base">shutdown	"private -- called when the JVM is shutting down.	All we do is discard any runtime information, we don't attempt anything	meaningfull in the way of cleaning up"	classloader := nil.</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>Java classes</category><body package="JNIPort-Java-Base">defineClass: aString fromBytes: aByteArray	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	Answers a Class Static corresponding to the newly defined class and loaded by our	underlying classloader.	Will throw an error if the class definition does not define a class named by	aString (which can be in JNI or Java format)."	^ self classloader defineClass: aString fromBytes: aByteArray.</body><body package="JNIPort-Java-Base">defineClassFromBytes: aByteArray	"passes the data in aByteArray to the JVM as a 'classfile' (a JVM-native class definition)	defining the class named by aJNIClassName.	Answers a Class Static corresponding to the newly defined class and loaded by our	underlying classloader"	^ self classloader defineClassFromBytes: aByteArray.</body><body package="JNIPort-Java-Base">findClass: aStringOrSymbol	"answer a JavaStatic object corresponding to aString -- the name will be looked up in the	normal Java way startng at our underlying classloader, but delagating /first/ to its parent	classloader and the system classloaders.  Note that the delagation is handled inside	the Java runtime, we don't do it ourself"	^ self classloader		ifNil: [self errorNotFound: aStringOrSymbol]		ifNotNil: [:it | it findClass: aStringOrSymbol].</body><body package="JNIPort-Java-Base">findClassObject: aJNIClassName	"answer JavaLangClass object corresponding to aJNIClassName -- the name will be looked up in the	normal Java way startng at our underlying classloader, but delagating /first/ to its parent	classloader and the system classloaders.  Note that the delagation is handled inside	the Java runtime, we don't do it ourself"	^ self classloader findClassObject: aJNIClassName.</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>registry</category><body package="JNIPort-Java-Base">loadFromRegistryUnder: aRegKey	"load our state from the registry under the given key.  Answer whether	we found an acceptable minimum of data there.	NB: we are, in fact, exceedingly forgiving about missing data"	#( #isEnabled ) do:		[:each || value |		value := aRegKey at: each ifAbsent: [nil].		value isNil ifFalse: [self perform: (each , ':') asSymbol with: value ~= 0]].	#( #name #path #parentName #classloaderClass ) do:		[:each || value |		value := aRegKey at: each ifAbsent: [nil].		value isNil ifFalse: [self perform: (each , ':') asSymbol with: value]].	^ true.</body><body package="JNIPort-Java-Base">saveToRegistryUnder: aRegKey	"save our state to the registry under the given key"	aRegKey at: 'name' put: self name.	aRegKey at: 'path' put: self path.	aRegKey at: 'parentName' put: self parentName.	aRegKey at: 'classloaderClass' put: self classloaderClass.	aRegKey at: 'isEnabled' put: (self isEnabled ifTrue: [1] ifFalse: [0]).</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>initializing</category><body package="JNIPort-Java-Base">copyFrom: aSupplementaryClassloader	"private -- copy configuration data from aSupplementaryClassloader"	path := aSupplementaryClassloader path.	parentName := aSupplementaryClassloader parentName.	classloaderClass := aSupplementaryClassloader classloaderClass.	isEnabled := aSupplementaryClassloader isEnabled.	self notifyChanged.</body><body package="JNIPort-Java-Base">defaultClassloaderClass	"private -- answer the classloader class to use by default"	^ #'java.net.URLClassLoader'.</body><body package="JNIPort-Java-Base">initialize	"private -- establish a coherent initial state"	isEnabled := false.</body><body package="JNIPort-Java-Base">name: aString	"private -- set our name to aString.	Note that it is an error to change the name of an instance after it has been added to a SupplementaryClassloaderTree.	The only reason this method exists at all is to allow instances to be created and editied in a PAE as part of a	settings object"	self jniAssert: [containingTree isNil].	name := aString asSymbol.</body><body package="JNIPort-Java-Base">name: aSymbol owner: aSupplementaryClassloaderTree	"private -- called by aSupplementaryClassloaderTree to tell what our name is and us that it owns us"	name := aSymbol.	containingTree := aSupplementaryClassloaderTree.</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>helpers</category><body package="JNIPort-Java-Base">createClassloader	"private -- answer a new JavaLangClassloader (or an instance of a subclass)	created from our #path and #classloaderClass definition"	| parent finder classStatic |	parent := self parentEntry.	finder := parent ifNil: [self jvm].	classStatic := finder findClass: self classloaderClass.	^ classStatic		newPath: self path		parent: (parent ifNotNil: [:it | it classloader]).</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>events</category><body package="JNIPort-Java-Base">notifyChanged	"private -- trigger change notification off our owner"	containingTree ifNotNil: [:it | it notifyChanged: self].</body></methods><methods><class-id>JNIPort.SupplementaryClassloader</class-id> <category>operations</category><body package="JNIPort-Java-Base">activate	"if we are enabled and not already active then activate ourself, otherwise	do nothing"#CUtodo.  "this should probably be protected by the shared mutex"	self isActive ifTrue: [^ self].	isEnabled ifFalse: [^ self].	classloader := self createClassloader.	JavaObject registerWrapperClassesWithSupplementaryClassloader: self.	self notifyChanged.</body></methods><methods><class-id>JNIPort.SupplementaryClassloader class</class-id> <category>registry</category><body package="JNIPort-Java-Base">newFromRegistryUnder: aRegKey ifNone: a0Block	"answer a new instance populated with whatever data there is in the registry under the given key.	If there is no reasonable minimum of such data then answer the result of evaluating a0block"	| new |	new := self new.	^ (new loadFromRegistryUnder: aRegKey)		ifTrue: [new]		ifFalse: [a0Block value].</body></methods><methods><class-id>JNIPort.SupplementaryClassloader class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">fromCLASSPATH	"answer a new instance initialised from the %CLASSPATH% environment variable"	^self named: 'Classpath'</body><body package="JNIPort-Java-Base">named: aString	"answer a new instance initialised from the %CLASSPATH% environment variable"	| classloader classpath |	classloader := self new.	classloader name: aString.	classpath := StandardLibInterface default getClasspath.	(classpath notNil and: [classpath isEmpty not]) ifTrue: [classloader path: classpath].	^classloader</body><body package="JNIPort-Java-Base">new	"answer a new instance with default initialisation"	^ (self basicNew)		initialize;		yourself.</body></methods><methods><class-id>JNIPort.StaticJavaLangByte</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">get_SIZE	"answer the value of the receiver's public static final SIZE Java field"	^ self getIntField: 'SIZE'.</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_byte: byte1	"answer the result of calling the receiver's public static valueOf(byte) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args byteAt: 1 put: byte1.			self				callObjectMethod: 'valueOf'				signature: '(B)Ljava/lang/Byte;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangByte</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">decode_String: aString1	"answer the result of calling the receiver's public static decode(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'decode'				signature: '(Ljava/lang/String;)Ljava/lang/Byte;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseByte_String: aString1	"answer the result of calling the receiver's public static parseByte(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callByteMethod: 'parseByte'				signature: '(Ljava/lang/String;)B'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseByte_String: aString1 int: int1	"answer the result of calling the receiver's public static parseByte(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callByteMethod: 'parseByte'				signature: '(Ljava/lang/String;I)B'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_byte: byte1	"answer the result of calling the receiver's public static toString(byte) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args byteAt: 1 put: byte1.			self				callObjectMethod: 'toString'				signature: '(B)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1	"answer the result of calling the receiver's public static valueOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;)Ljava/lang/Byte;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1 int: int1	"answer the result of calling the receiver's public static valueOf(java.lang.String, int) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				intAt: 2 put: int1.			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;I)Ljava/lang/Byte;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangByte</class-id> <category>Java-constructors</category><body package="JNIPort-Java-AdditionalWrappers">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">new_byte: byte1	"answer the result of calling the receiver's public new(byte) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args byteAt: 1 put: byte1.			self callConstructorSignature: '(B)V' withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangByte</class-id> <category>Java-static</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_VALUE	"answer the value of the receiver's public static final MAX_VALUE Java field"	^ self getByteField: 'MAX_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_VALUE	"answer the value of the receiver's public static final MIN_VALUE Java field"	^ self getByteField: 'MIN_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_TYPE	"answer the value of the receiver's public static final TYPE Java field"	^ self getObjectField: 'TYPE' signature: 'Ljava/lang/Class;'.</body></methods><methods><class-id>JNIPort.StaticJavaLangByte class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new_byte:		#new_String:	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_MAX_VALUE		#get_MIN_VALUE		#get_SIZE		#get_TYPE	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#decode_String:		#parseByte_String:		#parseByte_String:int:		#toString_byte:		#valueOf_byte:		#valueOf_String:		#valueOf_String:int:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangByte class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Byte'.</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings</class-id> <category>properties</category><body package="JNIPort-Java-Base">propertyAt: aString ifAbsent: a0Block	"answer the property named by aString, or the result of	evaluating a0Block if there isn't one"	| index |	index := self propertyIndex: aString ifAbsent: [^ a0Block value].	^ self splitProperty: aString from: (options at: index).</body><body package="JNIPort-Java-Base">propertyAt: aString put: anotherString	"set the property named by aString"	| index option |	index := self propertyIndex: aString ifAbsent: [nil].	option := self propertyLabel: aString value: anotherString.	index isNil		ifTrue: [options addLast: option]		ifFalse: [options at: index put: option].</body><body package="JNIPort-Java-Base">propertyIndex: aString ifAbsent: a0Block	"private -- answer the index of the propery named by aString, or the result	of evaluating a0Block if there isn't one"	| label |	label := self propertyLabel: aString.	options keysAndValuesDo: [:i :each | (each beginsWith: label) ifTrue: [^ i]].	^ a0Block value.</body><body package="JNIPort-Java-Base">propertyLabel: aString 	"private -- answer the label to use for the propery named by aString"	^'-D' , aString , '='</body><body package="JNIPort-Java-Base">propertyLabel: aString value: anotherString	"private -- answer the string to use for setting the propery named by aString"	^ '-D&lt;1s&gt;=&lt;2s&gt;' expandMacrosWith: aString with: anotherString.</body><body package="JNIPort-Java-Base">removePropertyAt: aString	"ensure that we do not have a property named by aString"	options removeAtIndex: (self propertyIndex: aString ifAbsent: [^ self]).</body><body package="JNIPort-Java-Base">splitProperty: aString from: anotherString	"private -- answer the String value of the property named by aString in the option	string, anotherString"	"format is '-D&lt;name&gt;=&lt;value&gt;'"	^ anotherString allButFirst: aString size + 3.</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings</class-id> <category>accessing</category><body package="JNIPort-Java-Base">classpath	"answer the receiver's classpath as ';'-separated String, or nil"	^ self		propertyAt: self classpathPropertyName		ifAbsent: [nil].</body><body package="JNIPort-Java-Base">classpath: aStringOrNil 	"set the receiver's classpath; if the argument is nil or empty then the property is removed"	(aStringOrNil isNil or: [aStringOrNil isEmpty]) 		ifTrue: [self removePropertyAt: self classpathPropertyName]		ifFalse: [self propertyAt: self classpathPropertyName put: aStringOrNil]</body><body package="JNIPort-Java-Base">javaVMInitArgs	"answer a JavaVMInitArgs instance created from our settings"	^ (JNIPortJNIInterface current newJavaVMInitArgs)		addOptions: (options select: [ :each | JNIPortUtility supportsJVMOption: each]);		yourself.</body><body package="JNIPort-Java-Base">libpath	"answer the receiver's libpath as ';'-separated String, or nil"	^ self		propertyAt: self libpathPropertyName		ifAbsent: [nil].</body><body package="JNIPort-Java-Base">libpath: aStringOrNil 	"set the receiver's libpath; if the argument is nil or empty then the property is removed"	(aStringOrNil isNil or: [aStringOrNil isEmpty]) 		ifTrue: [self removePropertyAt: self libpathPropertyName]		ifFalse: [self propertyAt: self libpathPropertyName put: aStringOrNil]</body><body package="JNIPort-Java-Base">miscellaneousOptions	| miscOptions |	miscOptions := options copy.	(self propertyIndex: self classpathPropertyName ifAbsent: [nil]) 		ifNotNil: [:index | miscOptions removeAtIndex: index].	(self propertyIndex: self libpathPropertyName ifAbsent: [nil]) 		ifNotNil: [:index | miscOptions removeAtIndex: index].	^miscOptions</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings</class-id> <category>options</category><body package="JNIPort-Java-Base">addOption: aString	"append the option given by aString to our list.  Does not remove	any previous version of the same option"	options addLast: aString.</body><body package="JNIPort-Java-Base">options	"answer the receiver's options, an OrderedCollection of Strings"	^ options.</body><body package="JNIPort-Java-Base">options: anOrderedCollection	"set the receiver's options, an OrderedCollection of Strings"	options := OrderedCollection withAll: anOrderedCollection.</body><body package="JNIPort-Java-Base">removeOption: aString	"remove the option given by aString from our list"	options remove: aString ifAbsent: [].</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings</class-id> <category>copying</category><body package="JNIPort-Java-Base">postCopy	super postCopy.	options := options copy</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings</class-id> <category>initializing</category><body package="JNIPort-Java-Base">importClasspathFromEnvironment	"attempt to set the classpath property from the %CLASSPATH% environment variable"	StandardLibInterface default getClasspath		ifNotNil: 			[:classpath |			classpath isEmpty				ifFalse: [self propertyAt: self classpathPropertyName put: classpath]]</body><body package="JNIPort-Java-Base">initialize	"private -- establish a default initial state.	NB: this is only used for creating a new 'default' (template) instance.  Subsequent	instances are created by cloning that"	options := OrderedCollection new.	self importClasspathFromEnvironment.	super initialize.</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings</class-id> <category>constants</category><body package="JNIPort-Java-Base">classpathPropertyName	"answer the name of the 'property' that controls the JVMs classpath"	^  'java.class.path'.</body><body package="JNIPort-Java-Base">libpathPropertyName	"answer the name of the 'property' that controls the JVMs libpath"	^  'java.library.path'.</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">loadOtherAspectsFromRegistryUnder: aRegKey	"private -- load our non-standard state from the registry under the given key.	Answer true iff we found an acceptable minumum of data"	| count |	count := aRegKey at: 'option count' ifAbsent: [0].	options := OrderedCollection new: count.	1 to: count do:		[:i  || subkey |		subkey := 'option ' , (NumberPrintPolicy print: i using: '000').		options addLast: (aRegKey at: subkey ifAbsent: [^ true])].	^ true.</body><body package="JNIPort-Configuration">saveOtherAspectsToRegistryUnder: aRegKey	"private -- save our state to the registry under the given key"	#CUtodo.  "we should remove the old ones"	aRegKey at: 'option count' put: options size.	options keysAndValuesDo:		[:i :each || subkey |		subkey := 'option ' , (NumberPrintPolicy print: i using: '000').		aRegKey at: subkey put: each].</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings class</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">initializeSettingsTemplate	"private -- class initialization.		self initializeSettingsTemplate.	"	JVMSettings addToTemplate: self new name: #runtimeSettings.</body><body package="JNIPort-Java-Base">obsolete	self uninitialize.	super obsolete</body><body package="JNIPort-Java-Base">uninitialize	"private -- class-side tear-down.		self uninitialize.	"	| settingsClass |	settingsClass := 'JVMSettings' asClassOrNilIn: self environment.	settingsClass ifNotNil: [settingsClass removeFromTemplate: #runtimeSettings].</body></methods><methods><class-id>JNIPort.JavaRuntimeSettings class</class-id> <category>constants</category><body package="JNIPort-Java-Base">suggestedJVMOptions	"answer an array of suggested values of options to the JVM"	| suggestions classpath |	suggestions :=		#(			"turning on verbosity"			'-verbose:jni'			'-verbose:gc'			'-verbose:class'				"turning on JNI checks"			'-Xcheck:jni'				"template for debug options (7777 is a port number)"			'-Xdebug'			'--Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7777'				"generic options"			'-Dxxx=yyy'			'-xxx' '-Xyyy'			'-XXyyy'		).	classpath := StandardLibInterface default getClasspath.	(classpath isNil or: [classpath isEmpty])		ifFalse: 			[suggestions := suggestions , (Array with: ('-Djava.class.path=' , classpath))].	^ suggestions.</body></methods><methods><class-id>JNIPort.JavaGhostClassGeneratorSettings</class-id> <category>accessing</category><body package="JNIPort-Java-GhostClasses">retainMethodSource	"answer whether we should keep the source of ghost methods"	^ self allFlagsSet: self class retainGhostMethodSourceMask.</body><body package="JNIPort-Java-GhostClasses">retainMethodSource: aBool	"set whether we should keep the source of ghost methods"	self setFlags: self class retainGhostMethodSourceMask to: aBool.</body><body package="JNIPort-Java-GhostClasses">useGhostInstances	"answer whether we should generate ghost classes for Java instances"	^ self anyFlagsSet: self class ghostInstancesMask.</body><body package="JNIPort-Java-GhostClasses">useGhostInstances: aBool	"set whether we should generate ghost classes for Java instances"	self setFlags: self class ghostInstancesMask to: aBool.</body><body package="JNIPort-Java-GhostClasses">useGhostInstancesForArrays	"answer whether we should generate ghost classes for Java arrays"	^ self anyFlagsSet: self class ghostInstancesForArraysMask.</body><body package="JNIPort-Java-GhostClasses">useGhostInstancesForArrays: aBool	"set whether we should generate ghost classes for Java arrays"	self setFlags: self class ghostInstancesForArraysMask to: aBool.</body><body package="JNIPort-Java-GhostClasses">useGhostInstancesForInterfaces	"answer whether we should generate ghost classes for Java interfaces (i.e. object known to	implement that interface)"	^ self anyFlagsSet: self class ghostInstancesForInterfacesMask.</body><body package="JNIPort-Java-GhostClasses">useGhostInstancesForInterfaces: aBool	"set whether we should generate ghost classes for Java interfaces (i.e. object known to	implement that interface)"	self setFlags: self class ghostInstancesForInterfacesMask to: aBool.</body><body package="JNIPort-Java-GhostClasses">useGhostStatics	"answer whether we should generate ghost classes for Java classes (i.e. statics)"	^ self anyFlagsSet: self class ghostStaticsMask.</body><body package="JNIPort-Java-GhostClasses">useGhostStatics: aBool	"set whether we should generate ghost classes for Java classes (i.e. statics)"	self setFlags: self class ghostStaticsMask to: aBool.</body><body package="JNIPort-Java-GhostClasses">useGhostStaticsForArrays	"answer whether we should generate ghost classes for Java Array classes (i.e. statics)"	^ self anyFlagsSet: self class ghostStaticsForArraysMask.</body><body package="JNIPort-Java-GhostClasses">useGhostStaticsForArrays: aBool	"set whether we should generate ghost classes for Java Array classes (i.e. statics)"	self setFlags: self class ghostStaticsForArraysMask to: aBool.</body><body package="JNIPort-Java-GhostClasses">useGhostStaticsForInterfaces	"answer whether we should generate ghost classes for Java interfaces (i.e. statics)"	^ self anyFlagsSet: self class ghostStaticsForInterfacesMask.</body><body package="JNIPort-Java-GhostClasses">useGhostStaticsForInterfaces: aBool	"set whether we should generate ghost classes for Java interfaces (i.e. statics)"	self setFlags: self class ghostStaticsForInterfacesMask to: aBool.</body><body package="JNIPort-Java-GhostClasses">useGhosts	"answer whether the receiver is set to require the use of Ghost classes at all"	^ self anyFlagsSet: self class ghostAnyMask.</body></methods><methods><class-id>JNIPort.JavaGhostClassGeneratorSettings class</class-id> <category>constants</category><body package="JNIPort-Java-GhostClasses">defaultFlags	"answer the collection of flags that are set by default"	^super defaultFlags		| self ghostInstancesMask		| self ghostStaticsMask		| self ghostStaticsForInterfacesMask</body><body package="JNIPort-Java-GhostClasses">ghostAnyInstancesMask	^16r0150000</body><body package="JNIPort-Java-GhostClasses">ghostAnyMask	^16r03F0000</body><body package="JNIPort-Java-GhostClasses">ghostAnyStaticsMask	^16r02A0000</body><body package="JNIPort-Java-GhostClasses">ghostInstancesForArraysMask	^16r0100000</body><body package="JNIPort-Java-GhostClasses">ghostInstancesForInterfacesMask	^16r0040000</body><body package="JNIPort-Java-GhostClasses">ghostInstancesMask	^16r0010000</body><body package="JNIPort-Java-GhostClasses">ghostStaticsForArraysMask	^16r0200000</body><body package="JNIPort-Java-GhostClasses">ghostStaticsForInterfacesMask	^16r0080000</body><body package="JNIPort-Java-GhostClasses">ghostStaticsMask	^16r0020000</body><body package="JNIPort-Java-GhostClasses">retainGhostMethodSourceMask	^16r1000000</body></methods><methods><class-id>JNIPort.JavaGhostClassGeneratorSettings class</class-id> <category>class initialization</category><body package="JNIPort-Java-GhostClasses">initialize	"private -- class-side intialisation"	self initializeSettingsTemplate</body><body package="JNIPort-Java-GhostClasses">initializeSettingsTemplate	"private -- class-side intialisation.		self initializeSettingsTemplate.	"	JVMSettings addToTemplate: self new name: #ghostClassSettings.</body><body package="JNIPort-Java-GhostClasses">uninitialize	"private -- class-side tear-down.		self uninitialize.	"	| settingsClass |	settingsClass := 'JVMSettings' asClassOrNilIn: self environment.	settingsClass ifNotNil: [settingsClass removeFromTemplate: #ghostClassSettings]</body></methods><methods><class-id>JNIPort.JavaGhostClassGeneratorSettings class</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">booleanAspectNames	"private -- answer an Array of the names of boolean aspects of instances"	"we remove some aspects because they are determined by runtime the, rather than depending on the user's choice"	| booleanAspectsForGhostClasses |	booleanAspectsForGhostClasses := super booleanAspectNames reject: 					[:each |					#(#includeAbstractMethods #includeAllSuperclasses #generateSNIConstructors)						includes: each].	^booleanAspectsForGhostClasses , #(		#useGhostInstances 		#useGhostStatics 		#useGhostInstancesForArrays 		#useGhostStaticsForArrays 		#useGhostInstancesForInterfaces 		#useGhostStaticsForInterfaces 		#retainMethodSource)</body></methods><methods><class-id>JNIPort.JNIMethodID</class-id> <category>accessing</category><body package="JNIPort-JNI">signature	^signature</body><body package="JNIPort-JNI">signature: aString	signature := aString</body></methods><methods><class-id>JNIPort.JNIMethodID class</class-id> <category>external accessing</category><body package="JNIPort-JNI">baseCType	^JNIPortJNIInterface current jmethodID</body></methods><methods><class-id>JNIPort.JavaIoReader</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">isBinary	"answer whether we read bytes rather than chars"	^ false.</body></methods><methods><class-id>JNIPort.JavaIoReader</class-id> <category>streaming</category><body package="JNIPort-Java-AdditionalWrappers">upToEnd	"answer a String of the remaining elements of the stream"	| gulp buffer ostream read |	gulp := 16 * 1024.	buffer := JavaCharArray new: gulp jvm: self jvm.	ostream := (String new: gulp) writeStream.		[read := self read_charArray: buffer int: 0 int: gulp.	read &lt;= 0 ifTrue: [^ostream contents].	ostream		next: read		putAll: buffer asByteArray		startingAt: 1]			repeat</body></methods><methods><class-id>JNIPort.JavaIoReader</class-id> <category>Java-public</category><body package="JNIPort-Java-AdditionalWrappers">read_charArray: chars1	"answer the result of calling the receiver's public read(char[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: chars1.			self callIntMethod: 'read' signature: '([C)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">ready	"answer the result of calling the receiver's public ready() Java method"	^ self callBooleanMethod: 'ready'.</body></methods><methods><class-id>JNIPort.JavaIoReader</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">read_CharBuffer: aCharBuffer1	"answer the result of calling the receiver's public read(java.nio.CharBuffer) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aCharBuffer1.			self				callIntMethod: 'read'				signature: '(Ljava/nio/CharBuffer;)I'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaIoReader</class-id> <category>reading</category><body package="JNIPort-Java-AdditionalWrappers">next	"answer the next Character of the stream"	^ Character codePoint: (self read).</body><body package="JNIPort-Java-AdditionalWrappers">next: anInteger	"answer a String of the next anInteger elements of the stream"	| buffer offset |	buffer := JavaCharArray new: anInteger jvm: self jvm.	offset := 0.	[offset &lt;= anInteger] whileTrue:		[| read |		read := self read_charArray: buffer int: offset int: anInteger-offset.		read &lt;= 0 ifTrue: [^JNIPortUtility signalEndOfStream: self].		offset := offset + read].	^ buffer asString.</body><body package="JNIPort-Java-AdditionalWrappers">read: aJavaCharArray	"answer the result of calling the receiver's read() Java method"	^ self read_charArray: aJavaCharArray.</body><body package="JNIPort-Java-AdditionalWrappers">read: aJavaCharArray  from: aStartIndex to: aStopIndex	"answer the result of calling the receiver's read() Java method.	Note that the indexes are Smalltalk-style, and so the start and stop positions	are 1-based, and aStopIndex *is* included in the range unlike the underlying	Java method"	^ self		read_charArray: aJavaCharArray		int: aStartIndex - 1		int: aStopIndex - aStartIndex + 1.</body></methods><methods><class-id>JNIPort.JavaIoReader</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">read_charArray: chars1 int: int1 int: int2	"answer the result of calling the receiver's public abstract read(char[], int, int) Java method"	^JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: chars1;				intAt: 2 put: int1;				intAt: 3 put: int2.			self callIntMethod: 'read' signature: '([CII)I' withArguments: args]</body></methods><methods><class-id>JNIPort.JavaIoReader class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#close		#markSupported		#mark_int:		#ready		#read_charArray:		#read_charArray:int:int:		#read_CharBuffer:		#read		#reset		#skip_long:	).</body></methods><methods><class-id>JNIPort.JavaIoReader class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.io.Reader'.</body></methods><methods><class-id>JNIPort.JavaFieldGetterGenerator</class-id> <category>testing</category><body package="JNIPort-Java-WrapperGeneration">isGetter	"answer true iff we are a getter method generator"	^ true.</body><body package="JNIPort-Java-WrapperGeneration">isUnary	^true</body></methods><methods><class-id>JNIPort.JavaFieldGetterGenerator</class-id> <category>constants</category><body package="JNIPort-Java-WrapperGeneration">getterPrefix	"private -- answer the prefix to use for getter methods"	^ 'get_'.</body></methods><methods><class-id>JNIPort.JavaFieldGetterGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">parameterCount	"answer how many paramers the generated method will take"	^0</body></methods><methods><class-id>JNIPort.JavaFieldGetterGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">computeParameters	"private -- answer a list #(keyword parameterName parameterType) triples for the method"	^ #().</body><body package="JNIPort-Java-WrapperGeneration">computeUnarySelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	^ self getterPrefix , self expandedName.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	| noSignature typeName |	self type isJavaLangString		ifTrue:			[noSignature := true.			typeName := 'String']		ifFalse:			[noSignature := self type isAPrimitive.			typeName := self genericTypeName].	output		tab;		nextPutAll: '^ self get';		nextPutAll: typeName;		nextPutAll: 'Field: ';		nextPut: $';		nextPutAll: self name;		nextPut: $'.	noSignature ifFalse:		[output			nextPutAll: ' signature: ';			nextPut: $';			nextPutAll: self type jniSignature;			nextPut: $'].	output		nextPut: $.;		cr.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: 'answer the value of the receiver''s ';		nextPutAll: reflection modifiersString;		space;		nextPutAll: self name;		nextPutAll: ' Java field';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaGhostFieldGetterGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-GhostClasses">genericTypeName	"answer one of Boolean, Byte, ... Object, Short, or, Void according to our type"	genericTypeNameCache isNil 		ifTrue: 			[genericTypeNameCache := reflection signature genericTypeName capitalized].	^genericTypeNameCache</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (IdentityDictionary new)		at: #JVM put: self jvm;		at: #FieldID put: reflection fieldID;		yourself.</body><body package="JNIPort-VW-Compatibility">methodSource	^PrototypeSources at: reflection signature prototypeMethodKey		ifAbsentPut: [super methodSource]</body></methods><methods><class-id>JNIPort.JavaGhostFieldGetterGenerator</class-id> <category>helpers</category><body package="JNIPort-Java-GhostClasses">computeSelector	"private -- compute the proper selector to use for the method.  Answers a String not a Symbol"	^generateLongKeywords | includeTypeInSelector 		ifTrue: [super computeSelector]		ifFalse: [reflection signature smalltalkGetSelector]</body></methods><methods><class-id>JNIPort.JavaGhostFieldGetterGenerator</class-id> <category>generating</category><body package="JNIPort-Java-GhostClasses">writeMethodBody	"private -- write a method body to our output stream"	"since this will be generated code, and hardly ever seen (except in the debugger),	we can drop right to the lowest level to gain speed.  However the big gain is that	the JVM, and especially the JNIFieldID, can be embedded directly in the generated	method's literal frame"	| isStatic |	isStatic := reflection isStatic.	output		tab;		nextPutAll: '| answer |';		cr; cr; tab;		nextPutAll: 'answer := self jniEnv';		space;		nextPutAll: (isStatic ifTrue: ['GetStatic'] ifFalse: ['Get']);		nextPutAll: self genericTypeName;		nextPutAll: (isStatic ifTrue: ['Field_class: '] ifFalse: ['Field_obj: ']);		nextPutAll: self jniObjectString;		nextPutAll: ' fieldID: ';		nextPutAll: self ghostFieldIDString;		cr; tab: 3;		nextPutAll: 'onException: [:jex | ^';		nextPutAll: self jvmString;		nextPutAll: ' throwJavaException: jex]';		nextPut: $.;		crtab;		nextPutAll: '^ ';		nextPutAll: (self convertToSmalltalkString: 'answer');		nextPut: $.;		cr.</body><body package="JNIPort-Java-GhostClasses">writeMethodPattern	"private -- write a 'method pattern' (header) to our output stream"	output		nextPutAll: self selector;		cr</body></methods><methods><class-id>JNIPort.JavaGhostFieldGetterGenerator</class-id> <category>constants</category><body package="JNIPort-Java-GhostClasses">convertToSmalltalkString: aString 	"answer aString, which is an expression decorated with code to	coerce it into Smalltalk"	^ reflection signature isOfPrimitiveType		ifTrue: [ 			reflection signature isOfCharType				ifTrue: [ aString , ' asCharacter' ]				ifFalse: [ aString ] ]		ifFalse: [ self wrapperFactoryString , ' wrapJNIObject: ' , aString ]</body><body package="JNIPort-Java-GhostClasses">jvmString	"answer the String which we use for accessing the JVM from a method"	^'#JVM'</body></methods><methods><class-id>JNIPort.JavaGhostFieldGetterGenerator</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-VW-Compatibility">prototypeMethodFor: methodSource	^PrototypeMethods at: reflection signature prototypeMethodKey		ifAbsentPut: [super prototypeMethodFor: methodSource]</body></methods><methods><class-id>JNIPort.JavaGhostFieldGetterGenerator class</class-id> <category>class initialization</category><body package="JNIPort-Java-GhostClasses">initialize	self resetPrototypes</body><body package="JNIPort-Java-GhostClasses">resetPrototypes	"self resetPrototypes"	PrototypeSources := Dictionary new.	PrototypeMethods := Dictionary new</body></methods><methods><class-id>JNIPort.JNIValueArray</class-id> <category>accessing</category><body package="JNIPort-JNI">booleanAt: anIndex put: aBool 	"set the receiver's boolean slot at anIndex to the value of aBool encoded	as 0 or 1"	bytes booleanByteAt: (self offsetForIndex: anIndex) put: aBool</body><body package="JNIPort-JNI">byteAt: anIndex put: anInteger 	"set the receiver's byte slot at anIndex to anInteger"	"setting the contents doesn't check, so we do it manually"	JNIPortJNIInterface current jbyte validateValue: anInteger.	bytes signedByteAt: (self offsetForIndex: anIndex) put: anInteger</body><body package="JNIPort-JNI">charAt: anIndex put: aCharacterOrInteger 	"set the receiver's char slot at anIndex to the value of aCharOrInteger.	Note that the integer value should fit in an unsigned 16bit word (i.e.	be a valid Java char code)"	| charValue |	charValue := aCharacterOrInteger asJNIParameter.	"setting the contents doesn't check, so we do it manually"	JNIPortJNIInterface current jchar validateValue: charValue.	bytes unsignedShortAt: (self offsetForIndex: anIndex) put: charValue</body><body package="JNIPort-JNI">doubleAt: anIndex put: aFloat 	"set the receiver's double slot at anIndex to aFloat"	bytes doubleAt: (self offsetForIndex: anIndex) put: aFloat</body><body package="JNIPort-JNI">floatAt: anIndex put: aFloat 	"set the receiver's float slot at anIndex to aFloat"	bytes floatAt: (self offsetForIndex: anIndex) put: aFloat</body><body package="JNIPort-JNI">intAt: anIndex put: anInteger 	"set the receiver's int slot at anIndex to anInteger"	"setting the contents doesn't check, so we do it manually"	JNIPortJNIInterface current jint validateValue: anInteger.	bytes longAt: (self offsetForIndex: anIndex) put: anInteger</body><body package="JNIPort-JNI">longAt: anIndex put: anInteger	"set the receiver's long slot at anIndex to anInteger"	"setting the contents doesn't check, so we do it manually"	JNIPortJNIInterface current jlong validateValue: anInteger.	bytes longLongAt: (self offsetForIndex: anIndex) put: anInteger</body><body package="JNIPort-JNI">nullAt: anIndex put: anUndefinedObject 	"set the receiver's short slot at anIndex to nil"	bytes longLongAt: (self offsetForIndex: anIndex) put: 0</body><body package="JNIPort-JNI">objectAt: anIndex put: aJNIObjectOrNil	"set the receiver's 'object' slot at anIndex to aJNIObjectOrNil.	(NB: although this isn't part of the 'JNIPort-Java-Base' package, this will	accept JavaObject's too)"	| offset pointer address |	offset := self offsetForIndex: anIndex.	aJNIObjectOrNil == nil		ifTrue: [address := 0]		ifFalse: 			[pointer := aJNIObjectOrNil asJNIParameter.			address := pointer referentAddress.			aJNIObjectOrNil mustFreeJNIParameter ifTrue: [pointers add: pointer]].	CPointerType uniqueDefaultPointer dataSize &gt; 4		ifTrue: [bytes unsignedLongLongAt: offset put: address]		ifFalse: [bytes unsignedLongAt: offset put: address]</body><body package="JNIPort-JNI">shortAt: anIndex put: anInteger 	"set the receiver's short slot at anIndex to anInteger"	"setting the contents doesn't check, so we do it manually"	JNIPortJNIInterface current jshort validateValue: anInteger.	bytes shortAt: (self offsetForIndex: anIndex) put: anInteger</body><body package="JNIPort-JNI">size	^bytes sizeInBytes / self elementSizeInBytes</body></methods><methods><class-id>JNIPort.JNIValueArray</class-id> <category>private</category><body package="JNIPort-JNI">offsetForIndex: anIndex	^anIndex &lt; 9		ifTrue: [#(1 9 17 25 33 41 49 57) at: anIndex]		ifFalse: [(anIndex - 1) * self elementSizeInBytes + 1]</body></methods><methods><class-id>JNIPort.JNIValueArray</class-id> <category>initialize-release</category><body package="JNIPort-JNI">free	pointers do: [:pointer | pointer free]</body><body package="JNIPort-JNI">freeAfter: aBlock	^[aBlock value: self] ensure: [self free]</body><body package="JNIPort-JNI">initialize: anInteger	bytes := UninterpretedBytes new: anInteger * self elementSizeInBytes.	pointers := OrderedCollection new.</body><body package="JNIPort-JNI">initializeWithJavaObject: aJavaObject	"set the receiver's first 'object' slot to aJavaObject.	(NB: although this isn't part of the 'JNIPort-Java-Base' package, this will	accept JavaObject's too)"	| pointer |	bytes := UninterpretedBytes new: self elementSizeInBytes.	aJavaObject == nil ifTrue: [ ^self ].	pointer := aJavaObject asJNIParameter.	pointer type dataSize &gt; 4		ifTrue: [bytes unsignedLongLongAt: 1 put: pointer referentAddress]		ifFalse: [bytes unsignedLongAt: 1 put: pointer referentAddress]</body></methods><methods><class-id>JNIPort.JNIValueArray</class-id> <category>constants</category><body package="JNIPort-JNI">elementSizeInBytes	"Returns the value of 		JNIInterface current jvalue dataSize	Optimized for speed."	^8</body></methods><methods><class-id>JNIPort.JNIValueArray</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	^bytes</body></methods><methods><class-id>JNIPort.JNIValueArray class</class-id> <category>instance creation</category><body package="JNIPort-JNI">new	^self new: 1</body><body package="JNIPort-JNI">new: anInteger 	^self basicNew initialize: anInteger</body><body package="JNIPort-JNI">null	^nil</body></methods><methods><class-id>JNIPort.JNIValueArray class</class-id> <category>utilities</category><body package="JNIPort-JNI">new: anInteger freeAfter: aOneArgumentBlock	"Create an instance with anInteger slots, execute aOneArgumentBlock with the instance as parameter, and free the instance afterwards."	| valueArray |	valueArray := self new: anInteger.	^valueArray freeAfter: aOneArgumentBlock</body><body package="JNIPort-JNI">withJavaObject: aJavaObject freeAfter: aBlock	"Create an instance with one element containing the address of aJavaObject, execute aOneArgumentBlock with the instance as parameter, and free the instance afterwards. The memory at the address of aJavaObject does not have to be freed. This method is an optimized shortcut for a common case where a Java method is called with just one Java object as its parameter."	| valueArray |	valueArray := self basicNew initializeWithJavaObject: aJavaObject.	"In VisualWorks, there is no need to free the valueArray because we pass UninterpretedBytes to the JNI, not CPointers."	^aBlock value: valueArray</body></methods><methods><class-id>JNIPort.JavaPrimitiveInstance class</class-id> <category>instance creation</category><body package="JNIPort-Java-Base">jniObject: aJNIObject static: aJavaStatic	"private -- overridden since the only time this should ever be called is if the system is	totally buggered"	^ self shouldNotImplement.</body><body package="JNIPort-Java-Base">wrap: aJavaInstance asStatic: aJavaStatic	"private -- overridden since the only time this should ever be called is if the system is	totally buggered"	self shouldNotImplement.</body></methods><methods><class-id>JNIPort.JavaLongArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[self jniEnv		GetLongArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	self elementCType newFromJNIDatum: bufferPointer]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: anInteger	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType newPointerTo: anInteger.		[self jniEnv		SetLongArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jlong</body><body package="JNIPort-Java-Base">setElements: aSQWORDArray offset: anOffset length: anInteger	"copy anInteger elements from SQWORDArray into our Java array,	starting at the zero-based anOffset in the target"	self jniEnv			SetLongArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: aSQWORDArray			onException: [:jex | self jvm throwJavaException: jex].</body></methods><methods><class-id>JNIPort.JavaLongArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary SQWORDArray.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetLongArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseLongArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaLongArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewLongArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.JavaLongArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[J'.</body></methods><methods><class-id>JNIPort.JNIPortSettings</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniInterface	(jniLibraryFilename notNil and: [jniLibraryFilename notEmpty]) 		ifTrue: [JNIPortJNIInterface libraryFile: jniLibraryFilename].	^JNIPortJNIInterface current</body><body package="JNIPort-Java-Base">jniLibraryFilename	"answer the receiver's jniLibraryFilename.  If this is set then it is overrides	the jni libraries default rules for finding the jvm.dll"	^ jniLibraryFilename.</body><body package="JNIPort-Java-Base">jniLibraryFilename: aStringOrNil 	"set the receiver's jniLibraryFilename to aStringOrNil"	jniLibraryFilename := aStringOrNil</body><body package="JNIPort-Java-Base">jvmClass	"answer the receiver's jvmClass, i.e. the subclass of JVM that will actually be	started to wrap/monitor the Java runtime.  At present the choice is between	JVMWithCallbacks and JVMWithoutCallbacks, which differ in whether they	support setting callbacks from Java into Smalltalk"	^ jvmClass.</body><body package="JNIPort-Java-Base">jvmClass: aSmalltalkClass	"set the receiver's jvmClass, i.e. the subclass of JVM that will actually be	started to wrap/monitor the Java runtime"	jvmClass := aSmalltalkClass.</body><body package="JNIPort-Java-Base">useAbortHook	"answer whether we will attempt to use the JNI runtime 'abort' hook;	that allows the JVM object to get notification from the Java runtime	when the runtime aborts.  It is unwise to use this unless you have a	'jni hleper' configured, since you may get deadlocks otherwise"	^self allFlagsSet: self useAbortHookMask</body><body package="JNIPort-Java-Base">useAbortHook: aBool	"set whether we will attempt to use the JNI runtime 'abort' hook.	Note that this risks almost certainly deadlocking Smalltalk unless	the JNIHelper library is also used"	self setFlags: self useAbortHookMask to: aBool.</body><body package="JNIPort-Java-Base">useExitHook	"answer whether we will attempt to use the JNI runtime 'exit' hook"	^self allFlagsSet: self useExitHookMask</body><body package="JNIPort-Java-Base">useExitHook: aBool	"set whether we will attempt to use the JNI runtime 'exit' hook.	Note that setting this will cause Smalltalk to hand (deadlock) when exiting any	of the current range of Sun JVMs"	self setFlags: self useExitHookMask to: aBool.</body><body package="JNIPort-Java-Base">useJNIHelperLibrary	"answer whether we will attempt to use the JNIHelper library"	^JNIPortJNIInterface currentPlatformID == #win		and: [self allFlagsSet: self useJNIHelperLibraryMask]</body><body package="JNIPort-Java-Base">useJNIHelperLibrary: aBool	"set whether we will attempt to use the JNIHelper library (which allows us to	hook abort() and vfprintf() without deadlocking Smalltalk -- it should allow hooking	exit() too, but that doesn't work)"	self setFlags: self useJNIHelperLibraryMask to: aBool.</body><body package="JNIPort-Java-Base">useVFPrintfHook	"answer whether we will attempt to use the JNI runtime 'vfprintf' hook"	^StandardLibInterface supportsVsnprintf and: [self allFlagsSet: self useVfprintfHookMask]</body><body package="JNIPort-Java-Base">useVFPrintfHook: aBool	"set whether we will attempt to use the JNI runtime 'vfprintf' hook.	Note that this risks almost certainly deadlocking Smalltalk unless	the JNIHelper library is also used"	self setFlags: self useVfprintfHookMask to: aBool.</body><body package="JNIPort-Java-Base">useVFPrintfRedirection	"answer whether we will attempt to set the JNI runtime 'vfprintf' hook to	redirect the JVM's debugging output to the Windows debug stream.  If this	is used (and it requires useVFPrintfHook *and* useJNIHelper), then debuging	output will go to the system output stream without touching Smalltalk at all, which	may help diagnose/avoid difficulties"	^JNIPortJNIInterface currentPlatformID == #win		and: [self allFlagsSet: self useVfprintfRedirectMask]</body><body package="JNIPort-Java-Base">useVFPrintfRedirection: aBool	"answer whether we will attempt to set the JNI runtime 'vfprintf' hook to	redirect the JVM's debugging output to the Windows debug stream.  If this	is used (and it requires useVFPrintfHook *and* useJNIHelper), then debuging	output will go to the system output stream without touching Smalltalk at all, which	may help diagnose/avoid difficulties"	self setFlags: self useVfprintfRedirectMask to: aBool.</body><body package="JNIPort-Java-Base">watcherClasses	"answer the OrderedCollection of classes that JVMs will send notifications to as they start up.	E.g. to use ghost classes you need to configure JVMGhostMaker as a watcher class"	^ watcherClasses.</body><body package="JNIPort-Java-Base">watcherClasses: aCollection	"set the OrderedCollection of classes that JVMs will send notifications to as they start up"	watcherClasses := OrderedCollection withAll: aCollection.</body></methods><methods><class-id>JNIPort.JNIPortSettings</class-id> <category>constants</category><body package="JNIPort-Java-Base">useAbortHookMask	^16r0001</body><body package="JNIPort-Java-Base">useExitHookMask	^16r0002</body><body package="JNIPort-Java-Base">useJNIHelperLibraryMask	^16r0010</body><body package="JNIPort-Java-Base">useVfprintfHookMask	^16r0004</body><body package="JNIPort-Java-Base">useVfprintfRedirectMask	^16r0008</body></methods><methods><class-id>JNIPort.JNIPortSettings</class-id> <category>copying</category><body package="JNIPort-Java-Base">postCopy	super postCopy.	watcherClasses := watcherClasses copy</body></methods><methods><class-id>JNIPort.JNIPortSettings</class-id> <category>initializing</category><body package="JNIPort-Java-Base">initialize	"private -- establish a default initial state.	NB: this is only used for creating a new 'default' (template) instance.  Subsequent	instances are created by cloning that"	super initialize.	jvmClass := JVMWithoutCallbacks.	jniLibraryFilename := nil.	watcherClasses := OrderedCollection new</body></methods><methods><class-id>JNIPort.JNIPortSettings</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">loadOtherAspectsFromRegistryUnder: aRegKey 	"private -- load our non-standard state from the registry under the given key.	Answer true iff we found an acceptable minumum of data"	| classkey count |	classkey := aRegKey subKeyNamed: 'jvmClass' ifAbsent: [^false].	jvmClass := self loadClassFromRegistryUnder: classkey ifNone: [^false].	jniLibraryFilename := aRegKey at: 'jniLibraryFilename' ifAbsent: [nil].	count := aRegKey at: 'watcherClasses count' ifAbsent: [0].	watcherClasses := OrderedCollection new: count.	1 to: count		do: 			[:i | 			| subkey |			subkey := 'watcherClasses ' , i printString.			classkey := aRegKey subKeyNamed: subkey ifAbsent: [^true].			watcherClasses 				addLast: (self loadClassFromRegistryUnder: classkey ifNone: [^true])].	^true</body><body package="JNIPort-Configuration">saveOtherAspectsToRegistryUnder: aRegKey 	"private -- save our non-standard state to the registry under the given key"	self saveClass: jvmClass toRegistryUnder: (aRegKey subKeyNamed: 'jvmClass').	aRegKey at: 'jniLibraryFilename'		put: (jniLibraryFilename ifNil: [String new]).	aRegKey at: 'watcherClasses count' put: watcherClasses size.	watcherClasses keysAndValuesDo: 			[:i :each | 			| subkey |			subkey := aRegKey subKeyNamed: 'watcherClasses ' , i printString.			self saveClass: each toRegistryUnder: subkey]</body></methods><methods><class-id>JNIPort.JNIPortSettings class</class-id> <category>class initialization</category><body package="JNIPort-Java-Base">initializeSettingsTemplate	"private -- class initialization.		self initialize.	"	JVMSettings addToTemplate: self new name: #jniPortSettings.</body><body package="JNIPort-Java-Base">uninitialize	"private -- class-side tear-down.		self uninitialize.	"	| settingsClass |	settingsClass := 'JVMSettings' asClassOrNilIn: self environment.	settingsClass ifNotNil: [settingsClass removeFromTemplate: #jniPortSettings].</body></methods><methods><class-id>JNIPort.JNIPortSettings class</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">obsolete	self uninitialize.	super obsolete</body></methods><methods><class-id>JNIPort.JNIPortSettings class</class-id> <category>*JNIPort-Configuration</category><body package="JNIPort-Configuration">booleanAspectNames	"private -- answer an Array of the names of boolean aspects of instances"	| platformDependentAspects |	platformDependentAspects := JNIPortJNIInterface currentPlatformID == #win				ifTrue: [#(#useJNIHelperLibrary #useExitHook #useAbortHook #useVFPrintfHook #useVFPrintfRedirection)]				ifFalse: [#(#useExitHook #useAbortHook #useVFPrintfRedirection)].	^super booleanAspectNames , platformDependentAspects</body><body package="JNIPort-Configuration">stringAspectNames	"answer an Array of the names of string aspects of instances"	^#(#jniLibraryFilename)</body></methods><methods><class-id>JNIPort.JavaUtilIterator</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">hasNext	"answer the result of calling the receiver's public abstract hasNext() Java method"	^ self callBooleanMethod: 'hasNext'.</body><body package="JNIPort-Java-AdditionalWrappers">next	"answer the result of calling the receiver's public abstract next() Java method"	^ self callObjectMethod: 'next' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">remove	"invoke the receiver's public abstract remove() Java method"	self callVoidMethod: 'remove'.</body></methods><methods><class-id>JNIPort.JavaUtilIterator</class-id> <category>streaming</category><body package="JNIPort-Java-AdditionalWrappers">do: a1Block	"core method for iterables"	| testMID getMID last |	"overrriden to gain efficiency by not repeatedly looking up the method IDs"	testMID := self findMethod: 'hasNext' signature: '()Z'.	getMID := self findMethod: 'next' signature: '()Ljava/lang/Object;'.	"we cache the MethodIDs for the durarion of the loop to avoid needless inefficiency"	[self callBooleanMID: testMID]		whileTrue: [last := a1Block value: (self callObjectMID: getMID)].	^ last.</body></methods><methods><class-id>JNIPort.JavaUtilIterator</class-id> <category>testing</category><body package="JNIPort-Java-AdditionalWrappers">atEnd	"part of the normal &lt;ReadStream&gt; protocol"	^ self hasNext not.</body></methods><methods><class-id>JNIPort.JavaUtilIterator class</class-id> <category>constants</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.Iterator'.</body></methods><methods><class-id>JNIPort.JavaUtilIterator class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#hasNext		#next		#remove	).</body></methods><methods><class-id>JNIPort.JavaUtilListIterator</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">add_Object: anObject1	"invoke the receiver's public abstract add(java.lang.Object) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callVoidMethod: 'add'				signature: '(Ljava/lang/Object;)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">hasNext	"answer the result of calling the receiver's public abstract hasNext() Java method"	^ self callBooleanMethod: 'hasNext'.</body><body package="JNIPort-Java-AdditionalWrappers">hasPrevious	"answer the result of calling the receiver's public abstract hasPrevious() Java method"	^ self callBooleanMethod: 'hasPrevious'.</body><body package="JNIPort-Java-AdditionalWrappers">next	"answer the result of calling the receiver's public abstract next() Java method"	^ self callObjectMethod: 'next' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">nextIndex	"answer the result of calling the receiver's public abstract nextIndex() Java method.	Note that the index is 0-based."	^ self callIntMethod: 'nextIndex'.</body><body package="JNIPort-Java-AdditionalWrappers">previous	"answer the result of calling the receiver's public abstract previous() Java method"	^ self callObjectMethod: 'previous' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">previousIndex	"answer the result of calling the receiver's public abstract previousIndex() Java method.	Note that the index is 0-based."	^ self callIntMethod: 'previousIndex'.</body><body package="JNIPort-Java-AdditionalWrappers">remove	"invoke the receiver's public abstract remove() Java method"	self callVoidMethod: 'remove'.</body><body package="JNIPort-Java-AdditionalWrappers">set_Object: anObject1	"invoke the receiver's public abstract set(java.lang.Object) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callVoidMethod: 'set'				signature: '(Ljava/lang/Object;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaUtilListIterator</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">nextPut: anObject	"one of the root methods of &lt;WriteStream&gt;"	self atEnd		ifTrue: [self add_Object: anObject]		ifFalse: [self set_Object: anObject].	^ anObject.</body></methods><methods><class-id>JNIPort.JavaUtilListIterator</class-id> <category>converting</category><body package="JNIPort-Java-AdditionalWrappers">asWriteStream	"answer an adaptor which makes this Java aggregate object look like something from the Smalltalk	Stream hierarchy"	^ WriteStreamAdaptor for: self.</body></methods><methods><class-id>JNIPort.JavaUtilListIterator</class-id> <category>operations</category><body package="JNIPort-Java-AdditionalWrappers">set: aJavaObject	"call the Java method: set()"	self set_Object: aJavaObject.</body></methods><methods><class-id>JNIPort.JavaUtilListIterator</class-id> <category>adding</category><body package="JNIPort-Java-AdditionalWrappers">add: aJavaObject	"call the Java method: add()"	self add_Object: aJavaObject.</body></methods><methods><class-id>JNIPort.JavaUtilListIterator class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#add_Object:		#hasNext		#hasPrevious		#next		#nextIndex		#previous		#previousIndex		#remove		#set_Object:	).</body></methods><methods><class-id>JNIPort.JavaUtilListIterator class</class-id> <category>constants</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.ListIterator'.</body></methods><methods><class-id>JNIPort.JNIPortJavaVMInitArgs</class-id> <category>accessing</category><body package="JNIPort-JNI">ignoreUnrecognized	"Answer the receiver's ignoreUnrecognized field as a Smalltalk object."	^ignoreUnrecognized</body><body package="JNIPort-JNI">ignoreUnrecognized: aBoolean 	"Set the receiver's ignoreUnrecognized field to aBoolean."	ignoreUnrecognized := aBoolean</body><body package="JNIPort-JNI">options	"Answer the receiver's options field as a Smalltalk object."	^options</body><body package="JNIPort-JNI">version	"Answer the receiver's version field as a Smalltalk object."	^version</body><body package="JNIPort-JNI">version: anInteger	"Set the receiver's version field to anInteger."	version := anInteger</body></methods><methods><class-id>JNIPort.JNIPortJavaVMInitArgs</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	"Answer the receiver in a form suitable for passing to an ExternalLibrary call,	i.e. the external data."	| currentPointer string interface |	interface := JNIPortJNIInterface current.	externalData := interface JavaVMInitArgs calloc.	optionPointer := interface JavaVMOption calloc: options size.	externalData		memberAt: #version put: version;		memberAt: #nOptions put: options size;		memberAt: #options put: optionPointer;		memberAt: #ignoreUnrecognized put: ignoreUnrecognized asJNIParameter.	stringPointers := OrderedCollection new.	currentPointer := optionPointer copy.	options keysAndValuesDo: 			[ :key :value |			string := key ifNotNil: [ key copyToHeap ].			string				ifNotNil: 					[ "remember a reference to the external string to prevent it from being garbage collected"					stringPointers add: string ].			currentPointer				memberAt: #optionString put: string;				memberAt: #extraInfo put: value;				+= 1 ].	^ externalData</body></methods><methods><class-id>JNIPort.JNIPortJavaVMInitArgs</class-id> <category>adding</category><body package="JNIPort-JNI">addAbortHook: anExternalCallback 	"add an option to set the abort() hook.  It should have the signature:		stdcall void	"	self addOption: 'abort' extraInfo: anExternalCallback</body><body package="JNIPort-JNI">addClassPath: aString 	"add a class path option to the set we already have"	self addProperty: 'java.class.path' value: aString</body><body package="JNIPort-JNI">addCompiler: aString	"add a compiler option to the set we already have"	self addProperty: 'java.compiler' value: aString.</body><body package="JNIPort-JNI">addExitHook: anExternalCallback 	"add an option to set the exit() hook.  It should have the signature:		stdcall void sdword	"	self addOption: 'exit' extraInfo: anExternalCallback</body><body package="JNIPort-JNI">addLibraryPath: aString 	"add a library path option to the set we already have"	self addProperty: 'java.library.path' value: aString</body><body package="JNIPort-JNI">addOption: aString	"add an option to the set we already have"	self addOption: aString extraInfo: 0.</body><body package="JNIPort-JNI">addOption: aString extraInfo: anObject 	"add an option to the set we already have"	options at: aString put: anObject asJNIParameter</body><body package="JNIPort-JNI">addOptions: aList 	"add more options to the set we already have"	aList do: [:each | options at: each put: 0]</body><body package="JNIPort-JNI">addProperties: aDictionary 	"add more options to the set we already have"	aDictionary 		keysAndValuesDo: [:key :value | options at: '-D' , key , '=' , value put: 0]</body><body package="JNIPort-JNI">addProperty: aNameString value: aValueString	"add an 'property' option to the set we already have"	self addOption: '-D' , aNameString , '=' , aValueString.</body><body package="JNIPort-JNI">addVFPrintfHook: aCallback 	"add an option to set the vfprintf() hook..  It should have the signature:		stdcall sdword void* char* void*	the third argument is a pointer to a va_list (i.e. a block of dwords where each element	contains one parameter to the varargs function).	E.g: you could use:		JNIPortCallback			do: [:fp :format :args | Transcript nextPutAll: (format vsprintfWith: args)]		ofType: JNIHelperLibrary default vfprintfCallback.	Note that the hook will be garbage-collected unless there is some other	reference to it"	self addOption: 'vfprintf' extraInfo: aCallback</body><body package="JNIPort-JNI">addVerbose: aString	"add an verbosity option to the set we already have, the verbosity is	a comma-separated list of strings.  The JNI spec defines: 'class', 'gc', and 'jni';	other (JVM-specific) values should have names starting with an X"	self addOption: ('-verbose:' , aString).</body></methods><methods><class-id>JNIPort.JNIPortJavaVMInitArgs</class-id> <category>initialize-release</category><body package="JNIPort-JNI">freeExternalData	stringPointers do: [:each | each free].	optionPointer free.	externalData free</body><body package="JNIPort-JNI">initialize	"private -- establish a coherent initial state"	self version: JNIPortJNIInterface current JNI_VERSION_1_4.	self ignoreUnrecognized: true.	options := Dictionary new</body></methods><methods><class-id>JNIPort.JNIPortJavaVMInitArgs class</class-id> <category>instance creation</category><body package="JNIPort-JNI">new	^super new initialize</body></methods><methods><class-id>JNIPort.JNIPortJavaVMInitArgs class</class-id> <category>external accessing</category><body package="JNIPort-JNI">baseCType	^JNIPortJNIInterface current JavaVMInitArgs</body></methods><methods><class-id>JNIPort.StaticJavaLangDouble</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">compare_double: double1 double: double2	"answer the result of calling the receiver's public static compare(double, double) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				doubleAt: 1 put: double1;				doubleAt: 2 put: double2.			self callIntMethod: 'compare' signature: '(DD)I' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">doubleToLongBits_double: double1	"answer the result of calling the receiver's public static doubleToLongBits(double) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self				callLongMethod: 'doubleToLongBits'				signature: '(D)J'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">doubleToRawLongBits_double: double1	"answer the result of calling the receiver's public static native doubleToRawLongBits(double) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self				callLongMethod: 'doubleToRawLongBits'				signature: '(D)J'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">isInfinite_double: double1	"answer the result of calling the receiver's public static isInfinite(double) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self callBooleanMethod: 'isInfinite' signature: '(D)Z' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">isNaN_double: double1	"answer the result of calling the receiver's public static isNaN(double) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self callBooleanMethod: 'isNaN' signature: '(D)Z' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">longBitsToDouble_long: long1	"answer the result of calling the receiver's public static native longBitsToDouble(long) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args longAt: 1 put: long1.			self				callDoubleMethod: 'longBitsToDouble'				signature: '(J)D'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">parseDouble_String: aString1	"answer the result of calling the receiver's public static parseDouble(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callDoubleMethod: 'parseDouble'				signature: '(Ljava/lang/String;)D'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">toString_double: double1	"answer the result of calling the receiver's public static toString(double) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self				callObjectMethod: 'toString'				signature: '(D)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_String: aString1	"answer the result of calling the receiver's public static valueOf(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'valueOf'				signature: '(Ljava/lang/String;)Ljava/lang/Double;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangDouble</class-id> <category>auto generated</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_EXPONENT	"answer the value of the receiver's public static final MAX_EXPONENT Java field"	^ self getIntField: 'MAX_EXPONENT'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_EXPONENT	"answer the value of the receiver's public static final MIN_EXPONENT Java field"	^ self getIntField: 'MIN_EXPONENT'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_NORMAL	"answer the value of the receiver's public static final MIN_NORMAL Java field"	^ self getDoubleField: 'MIN_NORMAL'.</body><body package="JNIPort-Java-AdditionalWrappers">get_SIZE	"answer the value of the receiver's public static final SIZE Java field"	^ self getIntField: 'SIZE'.</body><body package="JNIPort-Java-AdditionalWrappers">toHexString_double: double1	"answer the result of calling the receiver's public static toHexString(double) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self				callObjectMethod: 'toHexString'				signature: '(D)Ljava/lang/String;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">valueOf_double: double1	"answer the result of calling the receiver's public static valueOf(double) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self				callObjectMethod: 'valueOf'				signature: '(D)Ljava/lang/Double;'				withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangDouble</class-id> <category>Java-static</category><body package="JNIPort-Java-AdditionalWrappers">get_MAX_VALUE	"answer the value of the receiver's public static final MAX_VALUE Java field"	^ self getDoubleField: 'MAX_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_MIN_VALUE	"answer the value of the receiver's public static final MIN_VALUE Java field"	^ self getDoubleField: 'MIN_VALUE'.</body><body package="JNIPort-Java-AdditionalWrappers">get_NEGATIVE_INFINITY	"answer the value of the receiver's public static final NEGATIVE_INFINITY Java field"	^ self getDoubleField: 'NEGATIVE_INFINITY'.</body><body package="JNIPort-Java-AdditionalWrappers">get_NaN	"answer the value of the receiver's public static final NaN Java field"	^ self getDoubleField: 'NaN'.</body><body package="JNIPort-Java-AdditionalWrappers">get_POSITIVE_INFINITY	"answer the value of the receiver's public static final POSITIVE_INFINITY Java field"	^ self getDoubleField: 'POSITIVE_INFINITY'.</body><body package="JNIPort-Java-AdditionalWrappers">get_TYPE	"answer the value of the receiver's public static final TYPE Java field"	^ self getObjectField: 'TYPE' signature: 'Ljava/lang/Class;'.</body></methods><methods><class-id>JNIPort.StaticJavaLangDouble</class-id> <category>Java-constructors</category><body package="JNIPort-Java-AdditionalWrappers">new_String: aString1	"answer the result of calling the receiver's public new(java.lang.String) Java constructor"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self callConstructorSignature: '(Ljava/lang/String;)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">new_double: double1	"answer the result of calling the receiver's public new(double) Java constructor"	^JNIValueArray new: 1		freeAfter: 			[:args |			args doubleAt: 1 put: double1.			self callConstructorSignature: '(D)V' withArguments: args]</body></methods><methods><class-id>JNIPort.StaticJavaLangDouble class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#new_double:		#new_String:	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#get_MAX_EXPONENT		#get_MAX_VALUE		#get_MIN_EXPONENT		#get_MIN_NORMAL		#get_MIN_VALUE		#get_NaN		#get_NEGATIVE_INFINITY		#get_POSITIVE_INFINITY		#get_SIZE		#get_TYPE	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#compare_double:double:		#doubleToLongBits_double:		#doubleToRawLongBits_double:		#isInfinite_double:		#isNaN_double:		#longBitsToDouble_long:		#parseDouble_String:		#toHexString_double:		#toString_double:		#valueOf_double:		#valueOf_String:	).</body></methods><methods><class-id>JNIPort.StaticJavaLangDouble class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Double'.</body></methods><methods><class-id>JNIPort.JavaFieldSignature</class-id> <category>accessing</category><body package="JNIPort-Java-GhostClasses">conversionToJavaStringFor: aParameterName wrapperFactoryString: aString	self type = 'java.lang.String' ifTrue: [^'(' , aParameterName , ' asJavaString: ' , aString , ')'].	self type = 'char' ifTrue: [^'(' , aParameterName , ' asInteger)'].	self type = 'float' ifTrue: [^'(' , aParameterName , ' asFloat)'].	self type = 'double' ifTrue: [^'(' , aParameterName , ' asDouble)'].	^aParameterName</body><body package="JNIPort-Java-Base">genericTypeName 	^self genericTypeNameFor: self type</body><body package="JNIPort-Java-Base">name	^name</body><body package="JNIPort-Java-Base">smalltalkGetSelector	^('get_' , self unqualifiedName copyReplacing: $$ withObject: $_) asSymbol</body><body package="JNIPort-Java-Base">smalltalkSetSelector	^('set_' , self unqualifiedName , ':' copyReplacing: $$ withObject: $_) 		asSymbol</body><body package="JNIPort-Java-Base">type	^type</body><body package="JNIPort-Java-Base">unqualifiedName	^self name copyFrom: (self name lastIndexOf: $.) + 1 to: self name size</body></methods><methods><class-id>JNIPort.JavaFieldSignature</class-id> <category>initialize-release</category><body package="JNIPort-Java-Base">fromString: aString 	| subStrings |	subStrings := aString subStrings: ' '.	modifiers := subStrings copyFrom: 1 to: subStrings size - 2.	type := subStrings at: subStrings size - 1.	name := subStrings at: subStrings size</body></methods><methods><class-id>JNIPort.JavaFieldSignature</class-id> <category>testing</category><body package="JNIPort-Java-Base">needsBoundsChecking	^#('byte' 'char' 'int' 'long' 'short') includes: self type</body></methods><methods><class-id>JNIPort.JavaFieldSignature</class-id> <category>*JNIPort-Java-GhostClasses</category><body package="JNIPort-Java-GhostClasses">prototypeMethodKey	^(self isFinal ifTrue: ['final'] ifFalse: ['']) 		, (self isStatic ifTrue: ['static'] ifFalse: ['']) 			, (self prototypeMethodKeyFor: self type)</body></methods><methods><class-id>JNIPort.JNIClass</class-id> <category>initialize-release</category><body package="JNIPort-JNI">initializeFrom: aJNIReference 	isReleased := false.	externalData := aJNIReference externalData.	isLocalRef := aJNIReference isLocalRef.	methodIDCache := Dictionary new: 20.	fieldIDCache := Dictionary new</body></methods><methods><class-id>JNIPort.JNIClass</class-id> <category>operations</category><body package="JNIPort-JNI">getGlobalRef: aJNIEnv onException: a1Block 	"create a new JNIGlobalRef of the appropriate sub-class corresponding to our own,	note that the existing ref is *not* cleared"	| new |	new := super getGlobalRef: aJNIEnv onException: a1Block.	^self species newFrom: new</body><body package="JNIPort-JNI">getLocalRef: aJNIEnv onException: a1Block 	"create a new JNILocalRef of the appropriate sub-class corresponding to our own,	note that the existing ref is *not* cleared"	| new |	new := super getLocalRef: aJNIEnv onException: a1Block.	^self species newFrom: new</body></methods><methods><class-id>JNIPort.JNIClass</class-id> <category>accessing</category><body package="JNIPort-JNI">fieldIDFor: aStringName signature: aJNISignature ifAbsentPut: aBlock 	| fieldsWithMatchingName |	fieldsWithMatchingName := fieldIDCache at: aStringName				ifAbsentPut: [OrderedCollection new].	^fieldsWithMatchingName 		detect: [:fieldID | fieldID signature = aJNISignature]		ifNone: 			[| fieldID |			fieldID := aBlock value.			fieldID signature: aJNISignature.			fieldsWithMatchingName add: fieldID.			fieldID]</body><body package="JNIPort-JNI">methodIDFor: aStringName signature: aJNISignature ifAbsentPut: aBlock 	| methodsWithMatchingName |	methodsWithMatchingName := methodIDCache at: aStringName				ifAbsentPut: [OrderedCollection new].	^methodsWithMatchingName 		detect: [:methodID | methodID signature = aJNISignature]		ifNone: 			[| methodID |			methodID := aBlock value.			methodID signature: aJNISignature.			methodsWithMatchingName add: methodID.			methodID]</body></methods><methods><class-id>JNIPort.JNIClass</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIClass	^self</body></methods><methods><class-id>JNIPort.JNIClass</class-id> <category>*JNIPort-Java-Base</category><body package="JNIPort-Java-Base">asJavaObject: aJVM	"answer a managed JavaObject which corresponds to the same underlying	object as the receiver and which is managed by aJVM.	Note that it is an error for a managed object to be owned by more than one	JVM or to change JVMs"	^ aJVM wrapJNIClass: self.</body></methods><methods><class-id>JNIPort.JNIClass class</class-id> <category>instance creation</category><body package="JNIPort-JNI">newFrom: aJNIReference 	^self basicNew initializeFrom: aJNIReference</body></methods><methods><class-id>JNIPort.JNIError</class-id> <category>printing</category><body package="JNIPort-JNI">description	^'JNI Error: &lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: self parameter displayString		with: super description</body></methods><methods><class-id>JNIPort.JavaDoubleArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[self jniEnv		GetDoubleArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	self elementCType newFromJNIDatum: bufferPointer]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: aDouble	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType newPointerTo: aDouble asDouble.		[self jniEnv		SetDoubleArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jdouble</body><body package="JNIPort-Java-Base">setElements: aDOUBLEArray offset: anOffset length: anInteger	"copy anInteger elements from DOUBLEArray into our Java array,	starting at the zero-based anOffset in the target"	self jniEnv			SetDoubleArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: aDOUBLEArray			onException: [:jex | self jvm throwJavaException: jex].</body></methods><methods><class-id>JNIPort.JavaDoubleArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary DOUBLEArray.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetDoubleArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseDoubleArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaDoubleArray</class-id> <category>replacing</category><body package="JNIPort-Java-Base">copyForReplace: aSequenceableCollection from: aStartIndex to: aStopIndex	"private -- answer a a pointer to an external array with the 'same' data as the closed sub-interval of aCollection"	^self elementCType		newPointerToCopyOf: aSequenceableCollection		from: aStartIndex		to: aStopIndex		convertElementsWith: [:anObject | anObject asDouble]</body></methods><methods><class-id>JNIPort.JavaDoubleArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewDoubleArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.JavaDoubleArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[D'.</body></methods><methods><class-id>JNIPort.JavaLangRuntime</class-id> <category>Java-methods</category><body package="JNIPort-Java-AdditionalWrappers">addShutdownHook_Thread: aThread1	"invoke the receiver's public addShutdownHook(java.lang.Thread) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aThread1.			self				callVoidMethod: 'addShutdownHook'				signature: '(Ljava/lang/Thread;)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">availableProcessors	"answer the result of calling the receiver's public native availableProcessors() Java method"	^ self callIntMethod: 'availableProcessors'.</body><body package="JNIPort-Java-AdditionalWrappers">exec_String: aString1	"answer the result of calling the receiver's public exec(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	^JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callObjectMethod: 'exec'				signature: '(Ljava/lang/String;)Ljava/lang/Process;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">exec_String: aString1 StringArray: aStrings1	"answer the result of calling the receiver's public exec(java.lang.String, java.lang.String[]) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: aStrings1.			self				callObjectMethod: 'exec'				signature: '(Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">exec_String: aString1 StringArray: aStrings1 File: aFile1	"answer the result of calling the receiver's public exec(java.lang.String, java.lang.String[], java.io.File) Java method"	^JNIValueArray new: 3		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: aStrings1;				objectAt: 3 put: aFile1.			self				callObjectMethod: 'exec'				signature: '(Ljava/lang/String;[Ljava/lang/String;Ljava/io/File;)Ljava/lang/Process;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">exec_StringArray: aStrings1	"answer the result of calling the receiver's public exec(java.lang.String[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aStrings1.			self				callObjectMethod: 'exec'				signature: '([Ljava/lang/String;)Ljava/lang/Process;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">exec_StringArray: aStrings1 StringArray: aStrings2	"answer the result of calling the receiver's public exec(java.lang.String[], java.lang.String[]) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: aStrings1;				objectAt: 2 put: aStrings2.			self				callObjectMethod: 'exec'				signature: '([Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">exec_StringArray: aStrings1 StringArray: aStrings2 File: aFile1	"answer the result of calling the receiver's public exec(java.lang.String[], java.lang.String[], java.io.File) Java method"	^JNIValueArray new: 3		freeAfter: 			[:args |			args				objectAt: 1 put: aStrings1;				objectAt: 2 put: aStrings2;				objectAt: 3 put: aFile1.			self				callObjectMethod: 'exec'				signature: '([Ljava/lang/String;[Ljava/lang/String;Ljava/io/File;)Ljava/lang/Process;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">exit_int: int1	"invoke the receiver's public exit(int) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callVoidMethod: 'exit' signature: '(I)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">freeMemory	"answer the result of calling the receiver's public native freeMemory() Java method"	^ self callLongMethod: 'freeMemory'.</body><body package="JNIPort-Java-AdditionalWrappers">gc	"invoke the receiver's public native gc() Java method"	self callVoidMethod: 'gc'.</body><body package="JNIPort-Java-AdditionalWrappers">getLocalizedInputStream_InputStream: anInputStream1	"answer the result of calling the receiver's public getLocalizedInputStream(java.io.InputStream) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anInputStream1.			self				callObjectMethod: 'getLocalizedInputStream'				signature: '(Ljava/io/InputStream;)Ljava/io/InputStream;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">getLocalizedOutputStream_OutputStream: anOutputStream1	"answer the result of calling the receiver's public getLocalizedOutputStream(java.io.OutputStream) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anOutputStream1.			self				callObjectMethod: 'getLocalizedOutputStream'				signature: '(Ljava/io/OutputStream;)Ljava/io/OutputStream;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">halt_int: int1	"invoke the receiver's public halt(int) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args intAt: 1 put: int1.			self callVoidMethod: 'halt' signature: '(I)V' withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">loadLibrary_String: aString1	"invoke the receiver's public loadLibrary(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'loadLibrary'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">load_String: aString1	"invoke the receiver's public load(java.lang.String) Java method"	| javaString1 |	javaString1 := aString1 asJavaString: self jvm.	JNIValueArray withJavaObject: javaString1		freeAfter: 			[:args |			self				callVoidMethod: 'load'				signature: '(Ljava/lang/String;)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">maxMemory	"answer the result of calling the receiver's public native maxMemory() Java method"	^ self callLongMethod: 'maxMemory'.</body><body package="JNIPort-Java-AdditionalWrappers">removeShutdownHook_Thread: aThread1	"answer the result of calling the receiver's public removeShutdownHook(java.lang.Thread) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aThread1.			self				callBooleanMethod: 'removeShutdownHook'				signature: '(Ljava/lang/Thread;)Z'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">runFinalization	"invoke the receiver's public runFinalization() Java method"	self callVoidMethod: 'runFinalization'.</body><body package="JNIPort-Java-AdditionalWrappers">totalMemory	"answer the result of calling the receiver's public native totalMemory() Java method"	^ self callLongMethod: 'totalMemory'.</body><body package="JNIPort-Java-AdditionalWrappers">traceInstructions_boolean: boolean1	"invoke the receiver's public native traceInstructions(boolean) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args booleanAt: 1 put: boolean1.			self				callVoidMethod: 'traceInstructions'				signature: '(Z)V'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">traceMethodCalls_boolean: boolean1	"invoke the receiver's public native traceMethodCalls(boolean) Java method"	JNIValueArray new: 1		freeAfter: 			[:args |			args booleanAt: 1 put: boolean1.			self				callVoidMethod: 'traceMethodCalls'				signature: '(Z)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangRuntime class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#addShutdownHook_Thread:		#availableProcessors		#exec_String:		#exec_String:StringArray:		#exec_String:StringArray:File:		#exec_StringArray:		#exec_StringArray:StringArray:		#exec_StringArray:StringArray:File:		#exit_int:		#freeMemory		#gc		#getLocalizedInputStream_InputStream:		#getLocalizedOutputStream_OutputStream:		#halt_int:		#load_String:		#loadLibrary_String:		#maxMemory		#removeShutdownHook_Thread:		#runFinalization		#totalMemory		#traceInstructions_boolean:		#traceMethodCalls_boolean:	).</body></methods><methods><class-id>JNIPort.JavaLangRuntime class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'java.lang.Runtime'.</body></methods><methods><class-id>JNIPort.JavaGhostJVMMethodGenerator</class-id> <category>generating</category><body package="JNIPort-Java-GhostClasses">writeMethodBody	"private -- write a method body to our output stream"	output		tab;		nextPutAll: '^ ';		nextPutAll: self jvmString;		nextPut: $.;		cr.</body><body package="JNIPort-Java-GhostClasses">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: 'answer the receiver''s JVM';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaGhostJVMMethodGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-GhostClasses">jvm	"answer the JVM instance for which we are generating methods"	^ jvm.</body><body package="JNIPort-Java-GhostClasses">literalsMap	"answer a Dictionary mapping literals in a generated method to replacement values.	(Only used for ghost methods)"	^ (IdentityDictionary new)		at: #JVM put: self jvm;		yourself.</body><body package="JNIPort-Java-GhostClasses">selector	"answer the selector of the method we are going to generate"	^ #jvm.</body></methods><methods><class-id>JNIPort.JavaGhostJVMMethodGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-GhostClasses">jvm: aJVM	"private -- set the JVM instance for which we are generating methods"	jvm := aJVM.</body></methods><methods><class-id>JNIPort.JavaGhostJVMMethodGenerator</class-id> <category>displaying</category><body package="JNIPort-Java-GhostClasses">description	"answer a short String description of the member we wrap"	^ 'Answer the owning JVM'.</body></methods><methods><class-id>JNIPort.JavaGhostJVMMethodGenerator</class-id> <category>constants</category><body package="JNIPort-Java-GhostClasses">jvmString	"answer the String which we use for accessing the JVM from a method"	^'#JVM'</body></methods><methods><class-id>JNIPort.JavaGhostJVMMethodGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-GhostClasses">jvm: aJVM targetClass: aClass	"answer a new instance which will generate code to answer the given JVM"	^ (self targetClass: aClass)		jvm: aJVM;		yourself.</body></methods><methods><class-id>JNIPort.JavaUtilSortedMap</class-id> <category>Java-abstract</category><body package="JNIPort-Java-AdditionalWrappers">comparator	"answer the result of calling the receiver's public abstract comparator() Java method"	^ self callObjectMethod: 'comparator' signature: '()Ljava/util/Comparator;'.</body><body package="JNIPort-Java-AdditionalWrappers">firstKey	"answer the result of calling the receiver's public abstract firstKey() Java method"	^ self callObjectMethod: 'firstKey' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">headMap_Object: anObject1	"answer the result of calling the receiver's public abstract headMap(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'headMap'				signature: '(Ljava/lang/Object;)Ljava/util/SortedMap;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">lastKey	"answer the result of calling the receiver's public abstract lastKey() Java method"	^ self callObjectMethod: 'lastKey' signature: '()Ljava/lang/Object;'.</body><body package="JNIPort-Java-AdditionalWrappers">subMap_Object: anObject1 Object: anObject2	"answer the result of calling the receiver's public abstract subMap(java.lang.Object, java.lang.Object) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				objectAt: 2 put: anObject2.			self				callObjectMethod: 'subMap'				signature: '(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/SortedMap;'				withArguments: args]</body><body package="JNIPort-Java-AdditionalWrappers">tailMap_Object: anObject1	"answer the result of calling the receiver's public abstract tailMap(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'tailMap'				signature: '(Ljava/lang/Object;)Ljava/util/SortedMap;'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaUtilSortedMap</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">asAComparator	"answer the result of calling the receiver's comparator() Java method.	Note that the result is already wrapped in a JavaUtilComparator"	^ self comparator ifNotNil: [:it | it asA: #'java.util.Comparator'].</body><body package="JNIPort-Java-AdditionalWrappers">headMap: aJavaObject	"answer the result of calling the receiver's headMap() Java method.	The result is already wrapped in a JavaUtilSortedMap"	^ (self headMap_Object: aJavaObject) asASortedMap.</body><body package="JNIPort-Java-AdditionalWrappers">subMap: aJavaObject upTo: anotherJavaObject	"answer the result of calling the receiver's subMap() Java method.	The result is already wrapped in a JavaUtilSortedMap"	^ (self subMap_Object: aJavaObject Object: anotherJavaObject) asASortedMap.</body><body package="JNIPort-Java-AdditionalWrappers">tailMap: aJavaObject	"answer the result of calling the receiver's tailMap() Java method.	The result is already wrapped in a JavaUtilSortedMap"	^ (self tailMap_Object: aJavaObject) asASortedMap.</body></methods><methods><class-id>JNIPort.JavaUtilSortedMap class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-AdditionalWrappers">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-AdditionalWrappers">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#comparator		#firstKey		#headMap_Object:		#lastKey		#subMap_Object:Object:		#tailMap_Object:	).</body></methods><methods><class-id>JNIPort.JavaUtilSortedMap class</class-id> <category>accessing</category><body package="JNIPort-Java-AdditionalWrappers">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.util.SortedMap'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveBooleanStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the boolean field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getBooleanFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: aBool	"private -- set the boolean field defined by JNIFieldID it aJavaObject to aBool.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	aJavaObject setBooleanFID: aJNIFieldID to: aBool.</body></methods><methods><class-id>JNIPort.JavaPrimitiveBooleanStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaBooleanArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Boolean'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveBooleanStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #boolean.</body></methods><methods><class-id>JNIPort.JavaPrimitiveBooleanStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'Z'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveBooleanStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Boolean'</body></methods><methods><class-id>JNIPort.JavaBooleanArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[| booleanOrInteger |	self jniEnv		GetBooleanArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	booleanOrInteger := self elementCType newFromJNIDatum: bufferPointer.	booleanOrInteger isInteger		ifTrue: [booleanOrInteger ~= 0]		ifFalse: [booleanOrInteger]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: aBoolean	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType newPointerTo: aBoolean.		[self jniEnv		SetBooleanArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jboolean</body><body package="JNIPort-Java-Base">setElements: aBYTEArray offset: anOffset length: anInteger	"copy anInteger elements from BYTEArray into our Java array,	starting at the zero-based anOffset in the target.  Note that the	array should contain only the values 0 and 1"	self jniEnv			SetBooleanArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: aBYTEArray			onException: [:jex | self jvm throwJavaException: jex].</body></methods><methods><class-id>JNIPort.JavaBooleanArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary BYTEArray.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetBooleanArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseBooleanArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaBooleanArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewBooleanArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.JavaBooleanArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[Z'.</body></methods><methods><class-id>JNIPort.JNIPortDeadJNIEnv</class-id> <category>checked JNI functions</category><body package="JNIPort-JNI">DeleteGlobalRef_obj: argument1 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">DeleteLocalRef_obj: argument1 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">DeleteWeakGlobalRef_obj: argument1 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">IsSameObject_obj1: obj1 obj2: obj2 onException: a1Block	"treat as always false"	^false</body><body package="JNIPort-JNI">ReleaseBooleanArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseByteArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseCharArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseDoubleArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseFloatArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseIntArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseLongArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleasePrimitiveArrayCritical_array: array carray: carray mode: mode onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseShortArrayElements_array: argument1 elems: argument2 mode: argument3 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseStringChars_str: argument1 chars: argument2 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseStringCritical_str: argument1 cstring: argument2 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">ReleaseStringUTFChars_str: argument1 chars: argument2 onException: a1Block	"ignore"</body><body package="JNIPort-JNI">UnregisterNatives_class: argument1 onException: a1Block	"ignore"</body></methods><methods><class-id>JNIPort.JNIPortDeadJNIEnv</class-id> <category>accessing</category><body package="JNIPort-JNI">javaVM	"answer the receiver's owning JavaVM instance"	^ nil.</body></methods><methods><class-id>JNIPort.JNIPortDeadJNIEnv</class-id> <category>raw JNI functions</category><body package="JNIPort-JNI">DeleteGlobalRef_obj: argument1	"ignore"</body><body package="JNIPort-JNI">DeleteLocalRef_obj: argument1	"ignore"</body><body package="JNIPort-JNI">DeleteWeakGlobalRef_obj: argument1	"ignore"</body><body package="JNIPort-JNI">ExceptionCheck	"treat as always false"	^false.</body><body package="JNIPort-JNI">ExceptionClear	"ignore"</body><body package="JNIPort-JNI">ExceptionDescribe	"ignore"</body><body package="JNIPort-JNI">ExceptionOccurred	"ignore"	^ nil.</body><body package="JNIPort-JNI">IsSameObject_obj1: argument1 obj2: argument2	"treat as always false"	^ false</body><body package="JNIPort-JNI">ReleaseBooleanArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseByteArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseCharArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseDoubleArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseFloatArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseIntArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseLongArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleasePrimitiveArrayCritical_array: argument1 carray: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseShortArrayElements_array: argument1 elems: argument2 mode: argument3	"ignore"</body><body package="JNIPort-JNI">ReleaseStringChars_str: argument1 chars: argument2	"ignore"</body><body package="JNIPort-JNI">ReleaseStringCritical_str: argument1 cstring: argument2	"ignore"</body><body package="JNIPort-JNI">ReleaseStringUTFChars_str: argument1 chars: argument2	"ignore"</body><body package="JNIPort-JNI">UnregisterNatives_class: argument1	"ignore"</body></methods><methods><class-id>JNIPort.JNIPortDeadJNIEnv</class-id> <category>error handling</category><body package="JNIPort-JNI">doesNotUnderstand: aMessage	"sent by the VM if we do not otherwise understand aMessage"	^ (JNIPortJNIEnv canUnderstand: aMessage selector)		ifTrue: [JNIError signal: 'JNIEnv has been closed' with: -1]		ifFalse: [super doesNotUnderstand: aMessage].</body></methods><methods><class-id>JNIPort.JNIPortDeadJNIEnv</class-id> <category>testing</category><body package="JNIPort-JNI">isDead	"answer whether we know ourself to be dead.  Since we don't	actually know anything ;-) we always answer true (it is the responsibility	of the environment to replace the live JNIEnv with a DeadJNIEnv as	appropriate)"	^ true.</body></methods><methods><class-id>JNIPort.JNIPortDeadJNIEnv</class-id> <category>class membership</category><body package="JNIPort-JNI">respondsTo: aSelector	^ (super respondsTo: aSelector) or: [JNIPortJNIEnv canUnderstand: aSelector].</body></methods><methods><class-id>JNIPort.JNIPortDeadJNIEnv</class-id> <category>*JNIPort-Java-Base</category><body package="JNIPort-Java-Base">identityHashFor: aJavaObjectOrJNIObject javaLangSystem: javaLangSystem identityHashMethodID: methodID onException: exceptionBlock	^aJavaObjectOrJNIObject identityHash</body></methods><methods><class-id>JNIPort.JavaEventTrigger</class-id> <category>evaluating</category><body package="JNIPort-Java-Callbacks">executeOn: anObject withArguments: anArray	"private -- implement the heart of our function"	anObject trigger: symbol withArguments: anArray.	"we never answer anything"	^ nil.</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkNotifierThread</class-id> <category>Java-methods</category><body package="JNIPort-Java-Callbacks">getDemon	"answer the result of calling the receiver's public static synchronized getDemon() Java method"	^ self callObjectMethod: 'getDemon' signature: '()Ljniport/SmalltalkNotifierThread;'.</body><body package="JNIPort-Java-Callbacks">setSmalltalkNativeThread	"invoke the receiver's private static synchronized setSmalltalkNativeThread() Java method"	self callVoidMethod: 'setSmalltalkNativeThread'.</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkNotifierThread</class-id> <category>Java native methods</category><body package="JNIPort-Java-Callbacks">implementNotifierMethodBy: a0Block	"private -- set the implementation of our native 'notifier' method"	self		implementNative: self notifierMethod		by: a0Block.</body><body package="JNIPort-Java-Callbacks">notifierMethod	"private -- answer our native 'notifier' method"	^ self classObject		getDeclaredMethod_String: 'smalltalkNotifierMethod'		ClassArray: nil.</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkNotifierThread class</class-id> <category>testing</category><body package="JNIPort-Java-Callbacks">shouldRegisterWithJVM: aJVM 	^aJVM supportsCallbacks and: [super shouldRegisterWithJVM: aJVM]</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkNotifierThread class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Callbacks">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Callbacks">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#getDemon		#setSmalltalkNativeThread	).</body></methods><methods><class-id>JNIPort.StaticJNIPortSmalltalkNotifierThread class</class-id> <category>accessing</category><body package="JNIPort-Java-Callbacks">javaClassName	"answer the Symbol name of the Java class we stand for"	^ #'jniport.SmalltalkNotifierThread'.</body></methods><methods><class-id>JNIPort.JNIPortSubsystem</class-id> <category>default actions</category><body package="JNIPort-VW-Compatibility">setUp	super setUp.	JNIPortJNIInterface resetCurrent.	JVM runningInstances do: [:each | each onStartup].	JVM onStartup</body><body package="JNIPort-VW-Compatibility">tearDown	JVM runningInstances do: [:each | each onExit].	JNIPortJNIInterface resetCurrent.	super tearDown</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>accessing</category><body package="JNIPort-Java-Base">classStatic	"answer the JavaStatic instance corresponding to this Java class. Note that this	is *not* the same as our 'static'"	^ classStatic.</body><body package="JNIPort-Java-Base">classfileBytes	"make an attempt to supply our classfile's source byte array.	Answers nil if it can't supply"	^ (self getResourceAsStream_String: ('/' , self name asJNIClassName , '.class'))		ifNotNil: [:stream | [stream upToEnd] ensure: [stream close]].</body><body package="JNIPort-Java-Base">classfileURL	"make an attempt to supply the java.net.URL source of our classfile.	Answers nil if it can't supply"	^ self getResource_String: ('/' , self name asJNIClassName , '.class')</body><body package="JNIPort-Java-Base">classloader	"answer this class's java.lang.ClassLoader"	^ self getClassLoader.</body><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class.	(note that this is a fairly expensive operation)"	^ classStatic jniSignature.</body><body package="JNIPort-Java-Base">protectionDomain	"answer this class's java.security.ProtectionDomain"	^ self getProtectionDomain.</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>converting</category><body package="JNIPort-Java-Base">asJavaLangClass	"answer the receiver converted to a class object"	^ self.</body><body package="JNIPort-Java-Base">asStatic	"answer the receiver converted to a class static"	^ classStatic.</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">asSubclass_Class: aClass1	"answer the result of calling the receiver's public asSubclass(java.lang.Class) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClass1.			self				callObjectMethod: 'asSubclass'				signature: '(Ljava/lang/Class;)Ljava/lang/Class;'				withArguments: args]</body><body package="JNIPort-Java-Base">cast_Object: anObject1	"answer the result of calling the receiver's public cast(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'cast'				signature: '(Ljava/lang/Object;)Ljava/lang/Object;'				withArguments: args]</body><body package="JNIPort-Java-Base">getCanonicalName	"answer the result of calling the receiver's public getCanonicalName() Java method"	^ self callObjectMethod: 'getCanonicalName' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">getEnclosingClass	"answer the result of calling the receiver's public getEnclosingClass() Java method"	^ self callObjectMethod: 'getEnclosingClass' signature: '()Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getEnclosingConstructor	"answer the result of calling the receiver's public getEnclosingConstructor() Java method"	^ self callObjectMethod: 'getEnclosingConstructor' signature: '()Ljava/lang/reflect/Constructor;'.</body><body package="JNIPort-Java-Base">getEnclosingMethod	"answer the result of calling the receiver's public getEnclosingMethod() Java method"	^ self callObjectMethod: 'getEnclosingMethod' signature: '()Ljava/lang/reflect/Method;'.</body><body package="JNIPort-Java-Base">getEnumConstants	"answer the result of calling the receiver's public getEnumConstants() Java method"	^ self callObjectMethod: 'getEnumConstants' signature: '()[Ljava/lang/Object;'.</body><body package="JNIPort-Java-Base">getGenericInterfaces	"answer the result of calling the receiver's public getGenericInterfaces() Java method"	^ self callObjectMethod: 'getGenericInterfaces' signature: '()[Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">getGenericSuperclass	"answer the result of calling the receiver's public getGenericSuperclass() Java method"	^ self callObjectMethod: 'getGenericSuperclass' signature: '()Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">getSimpleName	"answer the result of calling the receiver's public getSimpleName() Java method"	^ self callObjectMethod: 'getSimpleName' signature: '()Ljava/lang/String;'.</body><body package="JNIPort-Java-Base">getTypeParameters	"answer the result of calling the receiver's public getTypeParameters() Java method"	^ self callObjectMethod: 'getTypeParameters' signature: '()[Ljava/lang/reflect/TypeVariable;'.</body><body package="JNIPort-Java-Base">isAnnotation	"answer the result of calling the receiver's public isAnnotation() Java method"	^ self callBooleanMethod: 'isAnnotation'.</body><body package="JNIPort-Java-Base">isAnonymousClass	"answer the result of calling the receiver's public isAnonymousClass() Java method"	^ self callBooleanMethod: 'isAnonymousClass'.</body><body package="JNIPort-Java-Base">isEnum	"answer the result of calling the receiver's public isEnum() Java method"	^ self callBooleanMethod: 'isEnum'.</body><body package="JNIPort-Java-Base">isLocalClass	"answer the result of calling the receiver's public isLocalClass() Java method"	^ self callBooleanMethod: 'isLocalClass'.</body><body package="JNIPort-Java-Base">isMemberClass	"answer the result of calling the receiver's public isMemberClass() Java method"	^ self callBooleanMethod: 'isMemberClass'.</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>Java class hierarchy</category><body package="JNIPort-Java-Base">isAssignableFrom: aJavaLangClass 	"answer whether aJavaLangClass is derived from the Java class or interface we stand for"	"we use the JNIEnv function directly, it's much faster"	^self jniEnv 		IsAssignableFrom_sub: aJavaLangClass		sup: jniObject		onException: [:jex | self jvm throwJavaException: jex]</body><body package="JNIPort-Java-Base">isDerivedFrom: aJavaLangClass 	"answer whether this class or interface is derived from (is a subclass of, or implements	the interface defined by) aJavaLangClass.	This is just the reverse of #isAssignableFrom: and is defined because I cannot ever work	out what #isAssignableFrom: really means"	"we use the JNIEnv function directly, it's much faster"	^self jniEnv 		IsAssignableFrom_sub: jniObject		sup: aJavaLangClass		onException: [:jex | self jvm throwJavaException: jex]</body><body package="JNIPort-Java-Base">isSubclassOf: aJavaLangClass	"answer whether this Java class includes the Java class defined by aJavaLangClass in	its inheritance chain.	Note: this does *not* include interfaces"	"ask our class static to work it out since it can do it quickly"	^ classStatic isSubclassOf: aJavaLangClass classStatic.</body><body package="JNIPort-Java-Base">javaSuperclass	"answer the JavaLangClass corresponding to our Java superclass, or nil if we haven't got one"	"ask our class static to work it out since it can do it quickly"	^ classStatic javaSuperclassDo: [:it | it classObject].</body><body package="JNIPort-Java-Base">javaSuperclassIfNone: a0Block	"answer the JavaLangClass corresponding to our Java superclass, or the result of evaluating	the &lt;niladicValuable&gt;, a0Block, if there isn't one"	"ask our class static to work it out since it can do it quickly"	classStatic javaSuperclassDo: [:it | ^ it classObject].	^  a0Block value.</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>testing</category><body package="JNIPort-Java-Base">isAPrimitive	"answer whether we stand for an Java primitive class (int, float, etc)"	"ask our class static to work it out since it can do it quickly"	^ classStatic isAPrimitive.</body><body package="JNIPort-Java-Base">isAnInterface	"answer whether we stand for an Java interface 'class'"	"ask our class static to work it out since it can do it quickly"	^ classStatic isAnInterface.</body><body package="JNIPort-Java-Base">isArrayClass	"answer whether we stand for an array class"	"ask our class static to work it out since it can do it quickly"	^ classStatic isArrayClass.</body><body package="JNIPort-Java-Base">isInstance: aJavaInstance 	"answer whether aJavaInstance is of a class derived from the Java class or interface we stand for"	"we use the JNIEnv function directly, it's much faster -- 3.7 usecs vs. 27.3 usecs on my machine"	^self jniEnv 		IsAssignableFrom_sub: aJavaInstance javaClassObject		sup: jniObject		onException: [:jex | self jvm throwJavaException: jex]</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>reflection</category><body package="JNIPort-Java-Base">declaredClasses	"answer an Array of JavaLangClasses corresponding to the result of our Java getDeclaredClasses() method"	^ self getDeclaredClasses collect: [:each | each classStatic].</body><body package="JNIPort-Java-Base">declaredConstructors	"answer an Array of JavaLangReflectConstructors corresponding to the result of our Java getDeclaredConstructors() method"	^ self getDeclaredConstructors asCollection.</body><body package="JNIPort-Java-Base">declaredFields	"answer an Array of JavaLangReflectFields corresponding to the result of our Java getDeclaredFields() method"	^ self getDeclaredFields asCollection.</body><body package="JNIPort-Java-Base">declaredInterfaces	"answer an Array of JavaLangReflectInterfaces corresponding to the result of our Java getInterfaces() method"	^ self getInterfaces asCollection.</body><body package="JNIPort-Java-Base">declaredMethods	"answer an Array of JavaLangReflectMethods corresponding to the result of our Java getDeclaredMethods() method"	^ self getDeclaredMethods asCollection.</body><body package="JNIPort-Java-Base">fieldIDFor: aStringName signature: aJNISignature ifAbsentPut: aBlock 	^self jniObject 		fieldIDFor: aStringName		signature: aJNISignature		ifAbsentPut: aBlock</body><body package="JNIPort-Java-Base">methodIDFor: aStringName signature: aJNISignature ifAbsentPut: aBlock 	^self jniObject 		methodIDFor: aStringName		signature: aJNISignature		ifAbsentPut: aBlock</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>Java-public</category><body package="JNIPort-Java-Base">desiredAssertionStatus	"answer the result of calling the receiver's public desiredAssertionStatus() Java method"	^ self callBooleanMethod: 'desiredAssertionStatus'.</body><body package="JNIPort-Java-Base">getClassLoader	"answer the result of calling the receiver's public getClassLoader() Java method"	^ self callObjectMethod: 'getClassLoader' signature: '()Ljava/lang/ClassLoader;'.</body><body package="JNIPort-Java-Base">getClasses	"answer the result of calling the receiver's public getClasses() Java method"	^ self callObjectMethod: 'getClasses' signature: '()[Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getConstructor_ClassArray: aClasses1	"answer the result of calling the receiver's public getConstructor(java.lang.Class[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClasses1.			self				callObjectMethod: 'getConstructor'				signature: '([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;'				withArguments: args]</body><body package="JNIPort-Java-Base">getConstructors	"answer the result of calling the receiver's public getConstructors() Java method"	^ self callObjectMethod: 'getConstructors' signature: '()[Ljava/lang/reflect/Constructor;'.</body><body package="JNIPort-Java-Base">getDeclaredClasses	"answer the result of calling the receiver's public getDeclaredClasses() Java method"	^ self callObjectMethod: 'getDeclaredClasses' signature: '()[Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getDeclaredConstructor_ClassArray: aClasses1	"answer the result of calling the receiver's public getDeclaredConstructor(java.lang.Class[]) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClasses1.			self				callObjectMethod: 'getDeclaredConstructor'				signature: '([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;'				withArguments: args]</body><body package="JNIPort-Java-Base">getDeclaredConstructors	"answer the result of calling the receiver's public getDeclaredConstructors() Java method"	^ self callObjectMethod: 'getDeclaredConstructors' signature: '()[Ljava/lang/reflect/Constructor;'.</body><body package="JNIPort-Java-Base">getDeclaredField_String: aString1	"answer the result of calling the receiver's public getDeclaredField(java.lang.String) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args objectAt: 1 put: javaString1.			self				callObjectMethod: 'getDeclaredField'				signature: '(Ljava/lang/String;)Ljava/lang/reflect/Field;'				withArguments: args]</body><body package="JNIPort-Java-Base">getDeclaredFields	"answer the result of calling the receiver's public getDeclaredFields() Java method"	^ self callObjectMethod: 'getDeclaredFields' signature: '()[Ljava/lang/reflect/Field;'.</body><body package="JNIPort-Java-Base">getDeclaredMethod_String: aString1 ClassArray: aClassArray	"answer the result of calling the receiver's public getDeclaredMethod(java.lang.String, java.lang.Class[]) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: aClassArray.			self				callObjectMethod: 'getDeclaredMethod'				signature: '(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;'				withArguments: args]</body><body package="JNIPort-Java-Base">getDeclaredMethods	"answer the result of calling the receiver's public getDeclaredMethods() Java method"	^ self callObjectMethod: 'getDeclaredMethods' signature: '()[Ljava/lang/reflect/Method;'.</body><body package="JNIPort-Java-Base">getField_String: aString1	"answer the result of calling the receiver's public getField(java.lang.String) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args objectAt: 1 put: javaString1.			self				callObjectMethod: 'getField'				signature: '(Ljava/lang/String;)Ljava/lang/reflect/Field;'				withArguments: args]</body><body package="JNIPort-Java-Base">getFields	"answer the result of calling the receiver's public getFields() Java method"	^ self callObjectMethod: 'getFields' signature: '()[Ljava/lang/reflect/Field;'.</body><body package="JNIPort-Java-Base">getMethod_String: aString1 ClassArray: aClasses1	"answer the result of calling the receiver's public getMethod(java.lang.String, java.lang.Class[]) Java method"	^JNIValueArray new: 2		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args				objectAt: 1 put: javaString1;				objectAt: 2 put: aClasses1.			self				callObjectMethod: 'getMethod'				signature: '(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;'				withArguments: args]</body><body package="JNIPort-Java-Base">getMethods	"answer the result of calling the receiver's public getMethods() Java method"	^ self callObjectMethod: 'getMethods' signature: '()[Ljava/lang/reflect/Method;'.</body><body package="JNIPort-Java-Base">getPackage	"answer the result of calling the receiver's public getPackage() Java method"	^ self callObjectMethod: 'getPackage' signature: '()Ljava/lang/Package;'.</body><body package="JNIPort-Java-Base">getProtectionDomain	"answer the result of calling the receiver's public getProtectionDomain() Java method"	^ self callObjectMethod: 'getProtectionDomain' signature: '()Ljava/security/ProtectionDomain;'.</body><body package="JNIPort-Java-Base">getResourceAsStream_String: aString1	"answer the result of calling the receiver's public getResourceAsStream(java.lang.String) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args objectAt: 1 put: javaString1.			self				callObjectMethod: 'getResourceAsStream'				signature: '(Ljava/lang/String;)Ljava/io/InputStream;'				withArguments: args]</body><body package="JNIPort-Java-Base">getResource_String: aString1	"answer the result of calling the receiver's public getResource(java.lang.String) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			| javaString1 |			javaString1 := aString1 asJavaString: self jvm.			args objectAt: 1 put: javaString1.			self				callObjectMethod: 'getResource'				signature: '(Ljava/lang/String;)Ljava/net/URL;'				withArguments: args]</body><body package="JNIPort-Java-Base">newInstance	"answer the result of calling the receiver's public newInstance() Java method"	^ self callObjectMethod: 'newInstance' signature: '()Ljava/lang/Object;'.</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>Java-methods</category><body package="JNIPort-Java-Base">getComponentType	"answer the result of calling the receiver's public native getComponentType() Java method"	^ self callObjectMethod: 'getComponentType' signature: '()Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getInterfaces	"answer the result of calling the receiver's public native getInterfaces() Java method"	^ self callObjectMethod: 'getInterfaces' signature: '()[Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">getSigners	"answer the result of calling the receiver's public native getSigners() Java method"	^ self callObjectMethod: 'getSigners' signature: '()[Ljava/lang/Object;'.</body><body package="JNIPort-Java-Base">getSuperclass	"answer the result of calling the receiver's public native getSuperclass() Java method"	^ self callObjectMethod: 'getSuperclass' signature: '()Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">isArray	"answer the result of calling the receiver's public native isArray() Java method"	^ self callBooleanMethod: 'isArray'.</body><body package="JNIPort-Java-Base">isAssignableFrom_Class: aClass1	"answer the result of calling the receiver's public native isAssignableFrom(java.lang.Class) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: aClass1.			self				callBooleanMethod: 'isAssignableFrom'				signature: '(Ljava/lang/Class;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">isInstance_Object: anObject1	"answer the result of calling the receiver's public native isInstance(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'isInstance'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">isInterface	"answer the result of calling the receiver's public native isInterface() Java method"	^ self callBooleanMethod: 'isInterface'.</body><body package="JNIPort-Java-Base">isPrimitive	"answer the result of calling the receiver's public native isPrimitive() Java method"	^ self callBooleanMethod: 'isPrimitive'.</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>initializing</category><body package="JNIPort-Java-Base">classStatic: aJavaStatic	"private -- set the class static which is twinned to this JavaLangClass"	classStatic := aJavaStatic.</body></methods><methods><class-id>JNIPort.JavaLangClass</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization."	super actAsExecutor.	classStatic := nil</body></methods><methods><class-id>JNIPort.JavaLangClass class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.Class'.</body></methods><methods><class-id>JNIPort.JavaLangClass class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaObjectArray.</body></methods><methods><class-id>JNIPort.JavaLangClass class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#asSubclass_Class:		#cast_Object:		#desiredAssertionStatus		#getAnnotations		#getAnnotation_Class:		#getCanonicalName		#getClasses		#getClassLoader		#getComponentType		#getConstructors		#getConstructor_ClassArray:		#getDeclaredAnnotations		#getDeclaredClasses		#getDeclaredConstructors		#getDeclaredConstructor_ClassArray:		#getDeclaredFields		#getDeclaredField_String:		#getDeclaredMethods		#getDeclaredMethod_String:ClassArray:		#getDeclaringClass		#getEnclosingClass		#getEnclosingConstructor		#getEnclosingMethod		#getEnumConstants		#getFields		#getField_String:		#getGenericInterfaces		#getGenericSuperclass		#getInterfaces		#getMethods		#getMethod_String:ClassArray:		#getModifiers		#getName		#getPackage		#getProtectionDomain		#getResourceAsStream_String:		#getResource_String:		#getSigners		#getSimpleName		#getSuperclass		#getTypeParameters		#isAnnotationPresent_Class:		#isAnnotation		#isAnonymousClass		#isArray		#isAssignableFrom_Class:		#isEnum		#isInstance_Object:		#isInterface		#isLocalClass		#isMemberClass		#isPrimitive		#isSynthetic		#newInstance		#toString	).</body></methods><methods><class-id>JNIPort.JNIWeakGlobalReference</class-id> <category>operations</category><body package="JNIPort-JNI">releaseRef: aJNIEnv 	"release the JNI global reference we represent"	"Avoid race conditions where finalization and an explicit shutdown of the JVM compete for releasing the reference."	isReleased ifTrue: [^self].	isReleased := true.	externalData beNonGarbageCollectable.	aJNIEnv DeleteWeakGlobalRef_obj: self</body><body package="JNIPort-JNI">releaseRef: aJNIEnv onException: a1Block 	"release the JNI global reference we represent"	"Avoid race conditions where finalization and an explicit shutdown of the JVM compete for releasing the reference."	isReleased ifTrue: [^self].	isReleased := true.	externalData beNonGarbageCollectable.	aJNIEnv DeleteWeakGlobalRef_obj: self onException: a1Block</body></methods><methods><class-id>JNIPort.JNIWeakGlobalReference</class-id> <category>accessing</category><body package="JNIPort-JNI">isLocalRef	"answer whether the receiver represents a JNI local reference"	^false</body></methods><methods><class-id>JNIPort.JNIWeakGlobalReference</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIClass	"This message should never be sent to a weak reference."	^self shouldNotImplement</body></methods><methods><class-id>JNIPort.JavaPrimitiveFloatStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the float field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getFloatFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: aFloat	"private -- set the float field defined by JNIFieldID it aJavaObject to aFloat.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	aJavaObject setFloatFID: aJNIFieldID to: aFloat.</body></methods><methods><class-id>JNIPort.JavaPrimitiveFloatStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'F'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveFloatStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #float.</body></methods><methods><class-id>JNIPort.JavaPrimitiveFloatStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaFloatArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Float'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveFloatStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Float'</body></methods><methods><class-id>JNIPort.JavaFloatArray</class-id> <category>accessing</category><body package="JNIPort-Java-Base">at: anIndex	"one of the root methods for &lt;SequenceableCollection&gt;, note that the index is for Smalltalk	and, as such, 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType calloc.	^	[self jniEnv		GetFloatArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex].	self elementCType newFromJNIDatum: bufferPointer]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">at: anIndex put: aFloat	"one of the root methods for &lt;SequenceableCollection&gt;,	note that the index is 1-based"	| bufferPointer |	anIndex &lt; 1 ifTrue: [self errorSubscriptBounds: anIndex].	anIndex &gt; self size ifTrue: [self errorSubscriptBounds: anIndex].	bufferPointer := self elementCType newPointerTo: aFloat asFloat.		[self jniEnv		SetFloatArrayRegion_array: jniObject		start: anIndex - 1		len: 1		buf: bufferPointer		onException: [:jex | self jvm throwJavaException: jex]]			ensure: [bufferPointer free]</body><body package="JNIPort-Java-Base">elementCType	^JNIPortJNIInterface current jfloat</body><body package="JNIPort-Java-Base">setElements: aFLOATArray offset: anOffset length: anInteger	"copy anInteger elements from FLOATArray into our Java array,	starting at the zero-based anOffset in the target"	self jniEnv			SetFloatArrayRegion_array: jniObject			start: anOffset			len: anInteger			buf: aFLOATArray			onException: [:jex | self jvm throwJavaException: jex].</body></methods><methods><class-id>JNIPort.JavaFloatArray</class-id> <category>enumerating</category><body package="JNIPort-Java-Base">withElementsDo: a1Block 	"answer the result of evaluating a1Block, passing it a temporary FLOATArray.	Changes made to the array will be copied back into Java space.	DO NOT KEEP A REFERENCE TO THE ARRAY"	| ptr |	ptr := self jniEnv 				GetFloatArrayElements_array: jniObject				isCopy: self jvm library nullPointer				onException: [:jex | self jvm throwJavaException: jex].	^[a1Block value: ptr] ensure: 			[self jniEnv 				ReleaseFloatArrayElements_array: jniObject				elems: ptr				mode: 0				onException: [:jex | self jvm throwJavaException: jex]]</body></methods><methods><class-id>JNIPort.JavaFloatArray</class-id> <category>replacing</category><body package="JNIPort-Java-Base">copyForReplace: aSequenceableCollection from: aStartIndex to: aStopIndex	"private -- answer a a pointer to an external array with the 'same' data as the closed sub-interval of aCollection"	^self elementCType		newPointerToCopyOf: aSequenceableCollection		from: aStartIndex		to: aStopIndex		convertElementsWith: [:anObject | anObject asFloat]</body></methods><methods><class-id>JNIPort.JavaFloatArray class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	"have to use the JNI name"	^ #'[F'.</body></methods><methods><class-id>JNIPort.JavaFloatArray class</class-id> <category>Java constructors</category><body package="JNIPort-Java-Base">new: length jvm: aJVM	"answer a new 'instance' of the array class we stand for, which is of the specified length"	| answer |	answer := aJVM jniEnv			NewFloatArray_len: length			onException: [:jex | aJVM throwJavaException: jex].	^ answer asJavaObject: aJVM.</body></methods><methods><class-id>JNIPort.JavaAmbiguousSelectorGenerator</class-id> <category>generating</category><body package="JNIPort-Java-WrapperGeneration">writeMethodBody	"private -- write a method body to our output stream"	output		tab;		nextPutAll: '^ self';		cr; tab: 2;		nextPutAll: 'ambiguousJavaMethod: #';		nextPutAll: self selector;		cr; tab: 2;		nextPutAll: 'alternatives: #('.	entries asSortedCollection		do: [:each | output nextPut: $#; nextPutAll: each]		separatedBy: [output space].	output		nextPutAll: ').';		cr.</body><body package="JNIPort-Java-WrapperGeneration">writeMethodComment	"private -- write a method comment to our output stream"	output		tab;		nextPut: $";		nextPutAll: 'trigger an error because more than one Java method maps to the same selector';		nextPut: $";		cr; cr.</body></methods><methods><class-id>JNIPort.JavaAmbiguousSelectorGenerator</class-id> <category>initializing</category><body package="JNIPort-Java-WrapperGeneration">entries: aCollection	"private -- set the Collection of entries that our generated method will answer"	entries := aCollection.</body><body package="JNIPort-Java-WrapperGeneration">selector: aSelector	"private -- set the selector of the method we are going to generate"	selector := aSelector.</body></methods><methods><class-id>JNIPort.JavaAmbiguousSelectorGenerator</class-id> <category>accessing</category><body package="JNIPort-Java-WrapperGeneration">entries	"answer the Collection of entries that our generated method will answer"	^ entries.</body><body package="JNIPort-Java-WrapperGeneration">selector	"answer the selector of the method we are going to generate"	^ selector.</body></methods><methods><class-id>JNIPort.JavaAmbiguousSelectorGenerator</class-id> <category>displaying</category><body package="JNIPort-Java-WrapperGeneration">description	"answer a short String description of the member we wrap"	^ 'Generate an error since this selector is ambiguous'.</body></methods><methods><class-id>JNIPort.JavaAmbiguousSelectorGenerator class</class-id> <category>instance creation</category><body package="JNIPort-Java-WrapperGeneration">selector: aString entries: aCollection targetClass: aClass	"answer a new instance which will generate code for a method named by aString	that will answer aCollection"	^ (self targetClass: aClass)		selector: aString;		entries: aCollection;		yourself.</body></methods><methods><class-id>JNIPort.JavaLangReflectField</class-id> <category>Java-public</category><body package="JNIPort-Java-Base">getBoolean_Object: anObject1	"answer the result of calling the receiver's public getBoolean(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callBooleanMethod: 'getBoolean'				signature: '(Ljava/lang/Object;)Z'				withArguments: args]</body><body package="JNIPort-Java-Base">getByte_Object: anObject1	"answer the result of calling the receiver's public getByte(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callByteMethod: 'getByte'				signature: '(Ljava/lang/Object;)B'				withArguments: args]</body><body package="JNIPort-Java-Base">getChar_Object: anObject1	"answer the result of calling the receiver's public getChar(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callCharMethod: 'getChar'				signature: '(Ljava/lang/Object;)C'				withArguments: args]</body><body package="JNIPort-Java-Base">getDouble_Object: anObject1	"answer the result of calling the receiver's public getDouble(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callDoubleMethod: 'getDouble'				signature: '(Ljava/lang/Object;)D'				withArguments: args]</body><body package="JNIPort-Java-Base">getFloat_Object: anObject1	"answer the result of calling the receiver's public getFloat(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callFloatMethod: 'getFloat'				signature: '(Ljava/lang/Object;)F'				withArguments: args]</body><body package="JNIPort-Java-Base">getInt_Object: anObject1	"answer the result of calling the receiver's public getInt(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callIntMethod: 'getInt'				signature: '(Ljava/lang/Object;)I'				withArguments: args]</body><body package="JNIPort-Java-Base">getLong_Object: anObject1	"answer the result of calling the receiver's public getLong(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callLongMethod: 'getLong'				signature: '(Ljava/lang/Object;)J'				withArguments: args]</body><body package="JNIPort-Java-Base">getShort_Object: anObject1	"answer the result of calling the receiver's public getShort(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callShortMethod: 'getShort'				signature: '(Ljava/lang/Object;)S'				withArguments: args]</body><body package="JNIPort-Java-Base">getType	"answer the result of calling the receiver's public getType() Java method"	^ self callObjectMethod: 'getType' signature: '()Ljava/lang/Class;'.</body><body package="JNIPort-Java-Base">get_Object: anObject1	"answer the result of calling the receiver's public get(java.lang.Object) Java method"	^JNIValueArray new: 1		freeAfter: 			[:args |			args objectAt: 1 put: anObject1.			self				callObjectMethod: 'get'				signature: '(Ljava/lang/Object;)Ljava/lang/Object;'				withArguments: args]</body><body package="JNIPort-Java-Base">setBoolean_Object: anObject1 boolean: boolean1	"invoke the receiver's public setBoolean(java.lang.Object, boolean) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				booleanAt: 2 put: boolean1.			self				callVoidMethod: 'setBoolean'				signature: '(Ljava/lang/Object;Z)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setByte_Object: anObject1 byte: byte1	"invoke the receiver's public setByte(java.lang.Object, byte) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				byteAt: 2 put: byte1.			self				callVoidMethod: 'setByte'				signature: '(Ljava/lang/Object;B)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setChar_Object: anObject1 char: char1	"invoke the receiver's public setChar(java.lang.Object, char) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				charAt: 2 put: char1.			self				callVoidMethod: 'setChar'				signature: '(Ljava/lang/Object;C)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setDouble_Object: anObject1 double: double1	"invoke the receiver's public setDouble(java.lang.Object, double) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				doubleAt: 2 put: double1.			self				callVoidMethod: 'setDouble'				signature: '(Ljava/lang/Object;D)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setFloat_Object: anObject1 float: float1	"invoke the receiver's public setFloat(java.lang.Object, float) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				floatAt: 2 put: float1.			self				callVoidMethod: 'setFloat'				signature: '(Ljava/lang/Object;F)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setInt_Object: anObject1 int: int1	"invoke the receiver's public setInt(java.lang.Object, int) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				intAt: 2 put: int1.			self				callVoidMethod: 'setInt'				signature: '(Ljava/lang/Object;I)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setLong_Object: anObject1 long: long1	"invoke the receiver's public setLong(java.lang.Object, long) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				longAt: 2 put: long1.			self				callVoidMethod: 'setLong'				signature: '(Ljava/lang/Object;J)V'				withArguments: args]</body><body package="JNIPort-Java-Base">setShort_Object: anObject1 short: short1	"invoke the receiver's public setShort(java.lang.Object, short) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				shortAt: 2 put: short1.			self				callVoidMethod: 'setShort'				signature: '(Ljava/lang/Object;S)V'				withArguments: args]</body><body package="JNIPort-Java-Base">set_Object: anObject1 Object: anObject2	"invoke the receiver's public set(java.lang.Object, java.lang.Object) Java method"	JNIValueArray new: 2		freeAfter: 			[:args |			args				objectAt: 1 put: anObject1;				objectAt: 2 put: anObject2.			self				callVoidMethod: 'set'				signature: '(Ljava/lang/Object;Ljava/lang/Object;)V'				withArguments: args]</body></methods><methods><class-id>JNIPort.JavaLangReflectField</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueFrom: aJavaObject	"answer the result of getting the value of the field we stand for from the	given Java object.	NB: must be in the same JVM"	self jniAssert: [self jvm == aJavaObject jvm].	^ self type		getValueOfFID: self fieldID		from: aJavaObject.</body><body package="JNIPort-Java-Base">setValueIn: aJavaObject to: anObject	"set the value of the field we stand for in the given Java object	to anObject.	NB: must be in the same JVM"	self jniAssert: [self jvm == aJavaObject jvm].	^ self type		setValueOfFID: self fieldID		in: aJavaObject		to: anObject.</body><body package="JNIPort-Java-Base">signature	"answer whether the method we generate a wrapper for returns void"	signature isNil ifTrue: [signature := self toString asJavaFieldSignature].	^signature</body><body package="JNIPort-Java-Base">type	"answer the class static corresponding to our getType() Java method"	typeCache isNil ifTrue: [typeCache := self getType classStatic].	^ typeCache.</body></methods><methods><class-id>JNIPort.JavaLangReflectField</class-id> <category>finalization</category><body package="JNIPort-Java-Base">actAsExecutor	"Removes any references from the receiver to objects which are not needed during finalization."	super actAsExecutor.	typeCache := nil</body></methods><methods><class-id>JNIPort.JavaLangReflectField</class-id> <category>accessing</category><body package="JNIPort-Java-Base">fieldID	"answer a JNIFieldID for this field"	^self jniEnv		FromReflectedField_field: jniObject		onException: [:jex | self jvm throwJavaException: jex].</body><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this member"	^ self type jniSignature.</body></methods><methods><class-id>JNIPort.JavaLangReflectField</class-id> <category>testing</category><body package="JNIPort-Java-Base">hides: aField	"answer whether the field we stand for hides aField; note that we do	NOT consider instance and class-side fields to hide each other, and	also that we consider the type of the field to be disambiguation too"	self isStatic = aField isStatic ifFalse: [^ false].	(self declaredIn isDerivedFrom: aField declaredIn) ifFalse: [^ false].	(self name = aField name) ifFalse: [^ false].	(self type = aField type) ifFalse: [^ false].	^ true.</body><body package="JNIPort-Java-Base">isFinal	^self signature isFinal</body><body package="JNIPort-Java-Base">isStatic	^self signature isStatic</body></methods><methods><class-id>JNIPort.JavaLangReflectField</class-id> <category>auto generated</category><body package="JNIPort-Java-Base">getGenericType	"answer the result of calling the receiver's public getGenericType() Java method"	^ self callObjectMethod: 'getGenericType' signature: '()Ljava/lang/reflect/Type;'.</body><body package="JNIPort-Java-Base">isEnumConstant	"answer the result of calling the receiver's public isEnumConstant() Java method"	^ self callBooleanMethod: 'isEnumConstant'.</body><body package="JNIPort-Java-Base">toGenericString	"answer the result of calling the receiver's public toGenericString() Java method"	^ self callObjectMethod: 'toGenericString' signature: '()Ljava/lang/String;'.</body></methods><methods><class-id>JNIPort.JavaLangReflectField class</class-id> <category>listing wrapper methods</category><body package="JNIPort-Java-Base">generatedConstructorSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedGetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedSetterSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(	).</body><body package="JNIPort-Java-Base">generatedWrapperSelectors	"answer an Array of the selectors of automatically generated methods.	Note that this does not include inherited selectors"	^ #(		#equals_Object:		#getAnnotation_Class:		#getBoolean_Object:		#getByte_Object:		#getChar_Object:		#getDeclaredAnnotations		#getDeclaringClass		#getDouble_Object:		#getFloat_Object:		#getGenericType		#getInt_Object:		#getLong_Object:		#getModifiers		#getName		#getShort_Object:		#getType		#get_Object:		#hashCode		#isEnumConstant		#isSynthetic		#setBoolean_Object:boolean:		#setByte_Object:byte:		#setChar_Object:char:		#setDouble_Object:double:		#setFloat_Object:float:		#setInt_Object:int:		#setLong_Object:long:		#setShort_Object:short:		#set_Object:Object:		#toGenericString		#toString	).</body></methods><methods><class-id>JNIPort.JavaLangReflectField class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">javaClassName	"answer the (JNI or Java format) name of the Java class to which we most closely correspond"	^ #'java.lang.reflect.Field'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveByteStatic</class-id> <category>reflection</category><body package="JNIPort-Java-Base">getValueOfFID: aJNIFieldID from: aJavaObject	"private -- answer the result of getting the byte field defined by JNIFieldID from aJavaObject.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	^ aJavaObject getByteFID: aJNIFieldID.</body><body package="JNIPort-Java-Base">setValueOfFID: aJNIFieldID in: aJavaObject to: anInteger	"private -- set the byte field defined by JNIFieldID it aJavaObject to anInteger.	(This is part of a double-dispatch-like pattern where the access bounces off	ourself in order to determine the correct category of field"	aJavaObject setByteFID: aJNIFieldID to: anInteger.</body></methods><methods><class-id>JNIPort.JavaPrimitiveByteStatic class</class-id> <category>accessing</category><body package="JNIPort-Java-Base">jniSignature	"answer a JNI-style signature for this class"	^ 'B'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveByteStatic class</class-id> <category>converting</category><body package="JNIPort-Java-Base">javaTypeName	"answer the Java name of primitive type to which we correspond.	It is helpful, but not obligatory, for this to be a Symbol rather than String"	^ #byte.</body></methods><methods><class-id>JNIPort.JavaPrimitiveByteStatic class</class-id> <category>constants</category><body package="JNIPort-Java-Base">arrayClass	"answer the Smalltalk wrapper class that is used for arrays of objects of the type we represent"	^ JavaByteArray.</body><body package="JNIPort-Java-Base">wrapperJavaClassName	"answer the name of the java.lang.* class which wraps the kinds of primitives we correspond to"	^ #'java.lang.Byte'.</body></methods><methods><class-id>JNIPort.JavaPrimitiveByteStatic class</class-id> <category>*JNIPort-Java-WrapperGeneration</category><body package="JNIPort-Java-Base">genericTypeName	^'Byte'</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure class</class-id> <category>*JNIPort-JNI</category><body package="JNIPort-JNI">newFromJNIDatum: aCDatum	^self on: aCDatum</body></methods><methods><class-id>JNIPort.JNIPortExternalStructure</class-id> <category>converting</category><body package="JNIPort-JNI">asJNIParameter	"answer the receiver in a form suitable for passing to an ExternalLibrary call,	i.e. the external data."	^externalData</body></methods><methods><class-id>JNIPort.JNIPortUtility class</class-id> <category>utilities</category><body package="JNIPort-Java-Base">supportsJVMOption: aString	"Answer if the JVM option given by aString is supported on the current platform. For VisualWorks, there are no known unsupported options so far."		^true</body></methods><initialize><class-id>JNIPort.JavaGhostConstructorGenerator</class-id></initialize><initialize><class-id>JNIPort.JVM</class-id></initialize><initialize><class-id>JNIPort.JavaGhostMethodGenerator</class-id></initialize><initialize><class-id>JNIPort.JavaSignature</class-id></initialize><initialize><class-id>JNIPort.JavaGhostFieldSetterGenerator</class-id></initialize><initialize><class-id>JNIPort.JavaGhostClassGeneratorSettings</class-id></initialize><initialize><class-id>JNIPort.JavaGhostFieldGetterGenerator</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>JNIPortExternalStructure</name><environment>JNIPort</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>externalData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JNIPort-External</category><attributes><package>JNIPort-External</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>CType</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specifierFlags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>PreparedCMethod</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>cProcedurePointer kinds numArgs resultType structReturnSize procedureType specifierFlags structArgSize datumClass argumentArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FastCMethodPointers</category><attributes><package>FastCMethodPointers</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>CDatum</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>theDatum type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class></st-source>