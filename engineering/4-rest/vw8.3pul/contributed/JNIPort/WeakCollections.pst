<?xml version="1.0"?><st-source><!-- Name: WeakCollectionsComment: WeakCollections contains weak collections which are not in the VisualWorks base image. Currently, it contains only WeakSet and ThreadSafeWeakSet, and two subclasses of these which allow the redefinition of the hash and equality computations by appropriate blocks. Other collection classes which hold their elements weakly may be added here.DbIdentifier: JGStoreDbTrace: 5985PackageName: WeakCollectionsParcel: #('WeakCollections')ParcelDirectory: WeakCollectionsParcelName: WeakCollectionsPrintStringCache: (5,JoachimGeidel)Version: 5Date: 9:02:46 PM March 3, 2011 --><time-stamp>From VisualWorks®, 7.8 of 18. Februar 2011 on 3. März 2011 at 21:02:46</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WeakSet</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>weakStorage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>WeakCollections</package></attributes></class><comment><class-id>Core.WeakSet</class-id><body>This Set will reference its contents weakly.  Thus, please note that WeakSets will not be able to include the SmallInteger 0.  Also, this type of weak set does not use ephemerons.The tally of a WeakSet can be much higher than the actual number of its elements, and even higher than the capacity. This is caused by the fact that adding elements will increase the tally immediately, while the VM replaces unreferenced elements by a tombstone during finalization, but the #ElementsExpired update which updates the tally may be executed after a certain delay. If you need the exact number of elements (as exact as it can be, that is), send #updateTally to the WeakSet before asking for its size.</body></comment><class><name>PluggableWeakSet</name><environment>Core</environment><super>Core.WeakSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>hashBlock equalBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WeakCollections</package></attributes></class><comment><class-id>Core.PluggableWeakSet</class-id><body>PluggableWeakSets allow the redefinition of hashing and equality by clients.Instance Variables	hashBlock	&lt;BlockContext&gt;	A one argument block used for hashing the elements.	equalBlock	&lt;BlockContext&gt;	A two argument block used for comparing the elements.</body></comment><class><name>ThreadSafeWeakSet</name><environment>Core</environment><super>Core.WeakSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>accessLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WeakCollections</category><attributes><package>WeakCollections</package></attributes></class><comment><class-id>Core.ThreadSafeWeakSet</class-id><body>ThreadSafeWeakSet is a WeakSet which uses a RecursionLock to synchronize concurrent access to the set. For example, methods which first compute an index in the hash table and then store an object at this position in the hash table must not be interrupted between these two actions by another method which alters the set.Instance Variables:	accessLock	&lt;RecursionLock&gt;	The accessLock is used to synchronize concurrent access to the set.</body></comment><class><name>PluggableThreadSafeWeakSet</name><environment>Core</environment><super>Core.ThreadSafeWeakSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>equalBlock hashBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WeakCollections</package></attributes></class><comment><class-id>Core.PluggableThreadSafeWeakSet</class-id><body>PluggableThreadSafeWeakSets allow the redefinition of hashing and equality by clients.Instance Variables	hashBlock	&lt;BlockContext&gt;	A one argument block used for hashing the elements.	equalBlock	&lt;BlockContext&gt;	A two argument block used for comparing the elements.</body></comment><methods><class-id>Core.WeakSet</class-id> <category>adding</category><body package="WeakCollections" selector="add:">add: newObject 	"Include newObject as one of the receiver's elements.  Answer newObject."	| index probe |	newObject == nil ifTrue: [^newObject].	index := self findElementOrNil: newObject.	probe := self basicAt: index.	(probe == nil or: [probe == self tombstone])		ifTrue: [self atNewIndex: index put: newObject].	^newObject</body></methods><methods><class-id>Core.WeakSet</class-id> <category>accessing</category><body package="WeakCollections" selector="any">any	"Return an arbitrary element of the receiver. Error if the receiver is empty."	1 to: self basicSize		do: 			[:index | 			| element |			element := self basicAt: index.			(element == nil or: [element == self tombstone]) ifFalse: [^element]].	self emptyCollectionError</body><body package="WeakCollections" selector="basicSize">basicSize	^self weakStorage basicSize</body><body package="WeakCollections" selector="findElementLike:ifAbsent:">findElementLike: anObject ifAbsent: aBlock	| index answer |	index := self findElementOrNil: anObject.	answer := self basicAt: index.	(answer isNil or: [answer == self tombstone]) ifTrue: [^aBlock value].	^answer</body><body package="WeakCollections" selector="size">size	"Answer how many elements the receiver contains."	"The tally may be too high temporarily. The size cannot be higher than the capacity."	^self tallySize min: self capacity</body></methods><methods><class-id>Core.WeakSet</class-id> <category>converting</category><body package="WeakCollections" selector="asArray">asArray	"Answer a new instance of Array whose elements are the elements of	the receiver.  The order in which elements are added depends on the order in	which the receiver enumerates its elements.  In the case of unordered collections,	the ordering is not necessarily the same for multiple requests for the conversion."	"Use a Stream to build the Array. &lt;self size&gt; may answer a wrong number, which would	lead to an Array which is too large and has superfluous nils at the end."	| stream |	stream := WriteStream on: (Array new: self size).	self do: [:each | stream nextPut: each].	^stream contents</body></methods><methods><class-id>Core.WeakSet</class-id> <category>private - accessing</category><body package="WeakCollections" selector="basicAt:">basicAt: anInteger	^self weakStorage basicAt: anInteger</body><body package="WeakCollections" selector="basicAt:put:">basicAt: anInteger put: anObject	^self weakStorage basicAt: anInteger put: anObject</body><body package="WeakCollections" selector="tallySize:">tallySize: anInteger	tally := anInteger</body><body package="WeakCollections" selector="weakStorage">weakStorage	^weakStorage</body><body package="WeakCollections" selector="weakStorage:">weakStorage: aWeakArray	weakStorage ifNotNil: [weakStorage removeDependent: self].	weakStorage := aWeakArray.	weakStorage addDependent: self</body></methods><methods><class-id>Core.WeakSet</class-id> <category>enumerating</category><body package="WeakCollections" selector="collect:">collect: aBlock  	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a Set that is like 	the receiver.  Answer the new Set."	"Override the general method, so that we make a big enough set and avoid growing. "	| newSet |	self tallySize = 0 ifTrue: [^Set new: 2].	newSet := Set new: (self tallySize min: self capacity "Limit the size to prohibit excessively large hash tables.") * 3 // 2.	self do: [:each | newSet add: (aBlock value: each)].	^newSet</body><body package="WeakCollections" selector="do:">do: aBlock   	"Evaluate aBlock with each of the receiver's elements as the argument."	self tallySize = 0 ifTrue: [^self].	1 to: self basicSize do: 		[:index |			| element |			element := self basicAt: index.			(element == nil or: [element == self tombstone]) ifFalse: [aBlock value: element]		]</body></methods><methods><class-id>Core.WeakSet</class-id> <category>private</category><body package="WeakCollections" selector="find:ifAbsent:">find: anObject ifAbsent: aBlock 		| index probe |	index := self findElementOrNil: anObject.	probe := self basicAt: index.	^(probe == nil or: [probe == self tombstone])		ifTrue: [aBlock value]		ifFalse: [index]</body><body package="WeakCollections" selector="findElementOrNil:">findElementOrNil: anObject 	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."	| index length probe pass indexOfTombstone |	length := self basicSize.	pass := 1.	index := self initialIndexFor: anObject hash boundedBy: length.	[		probe := self basicAt: index.		(indexOfTombstone == nil and: [probe == self tombstone]) ifTrue: [indexOfTombstone := index].		probe == nil or: [probe = anObject]	] 		whileFalse: 			[				(index := index + 1) &gt; length ifTrue: 					[						index := 1.						pass := pass + 1.						pass &gt; 2 ifTrue: [^self grow findElementOrNil: anObject]					]			].	probe ~~ nil ifTrue: [^index].	^indexOfTombstone ifNil: [index]</body><body package="WeakCollections" selector="fixCollisionsFrom:">fixCollisionsFrom: index 	| myLength oldIndex nextIndex nextObject |	oldIndex := index.	myLength := self basicSize.		[oldIndex := oldIndex \\ myLength + 1.	nextObject := self basicAt: oldIndex.	nextObject == nil] 			whileFalse: 				[nextObject == self tombstone 					ifTrue: [self basicAt: oldIndex put: nil]					ifFalse: 						[nextIndex := self findElementOrNil: nextObject.						nextIndex = oldIndex 							ifFalse: 								[self basicAt: nextIndex put: nextObject.								self basicAt: oldIndex put: nil]]]</body><body package="WeakCollections" selector="fullCheck">fullCheck	"If there is insufficient capacity in the receiver to do efficient lookups,	 then grow.  Require at least 25% free slots, or 1 free slot, whichever	 is the greater."	| cap sizePlusOne minimumFreeSlots |	cap := self capacity.	sizePlusOne := self tallySize + 1.	minimumFreeSlots := cap bitShift: -2.	cap - sizePlusOne &lt; minimumFreeSlots ifTrue: 		[			"The tally may be too high, make sure that we don't grow unnecessarily."			self updateTally.			sizePlusOne := self tallySize + 1.			cap - sizePlusOne &lt; minimumFreeSlots ifTrue: [self grow]		]</body><body package="WeakCollections" selector="setStorageSize:">setStorageSize: anInteger	self weakStorage: (WeakArray new: anInteger).	self setTally</body><body package="WeakCollections" selector="tallySize">tallySize	^super size</body><body package="WeakCollections" selector="tombstone">tombstone	"Answer the object the VM uses to mark the	collection of the object being weakly referenced"	^WeakArray tombstone</body><body package="WeakCollections" selector="trim">trim	"Adjust the receiver's capacity to fit its contents without wasting space	(but not so much as to be inefficient on lookup)."	"Leave about 33% empty slots."	self updateTally.	self changeCapacityTo: self tallySize + (self tallySize // 2)</body></methods><methods><class-id>Core.WeakSet</class-id> <category>testing</category><body package="WeakCollections" selector="includes:">includes: anObject 	"Answer whether anObject is one of the receiver's elements."	| probe |	probe := self basicAt: (self findElementOrNil: anObject).	^probe ~~ nil and: [probe ~~ self tombstone]</body></methods><methods><class-id>Core.WeakSet</class-id> <category>classification</category><body package="WeakCollections" selector="species">species	^Set</body></methods><methods><class-id>Core.WeakSet</class-id> <category>updating</category><body package="WeakCollections" selector="update:with:from:">update: aSymbol with: aParameter from: anObject	(aSymbol == #ElementExpired and: [anObject == weakStorage]) ifTrue: [^self updateTally].	^super update: aSymbol with: aParameter from: anObject</body><body package="WeakCollections" selector="updateTally">updateTally	"Update the counter which keeps track of how many elements the receiver contains."		| size |	size := 0.	self do: [:each | size := size + 1].	self tallySize: size</body></methods><methods><class-id>Core.WeakSet class</class-id> <category>instance creation</category><body package="WeakCollections" selector="new:">new: anInteger 	"Create an instance of a SimpleWeakSet."	| storageSize |	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	storageSize := self goodSizeFrom: anInteger.	^self basicNew		setStorageSize: storageSize;		yourself</body></methods><methods><class-id>Core.PluggableWeakSet</class-id> <category>accessing</category><body package="WeakCollections" selector="equalBlock">equalBlock	^equalBlock ifNil: [[:object1 :object2 | object1 = object2]]</body><body package="WeakCollections" selector="equalBlock:">equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock := aBlock</body><body package="WeakCollections" selector="hashBlock">hashBlock	^hashBlock ifNil: [[:object | object hash]]</body><body package="WeakCollections" selector="hashBlock:">hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock := aBlock</body></methods><methods><class-id>Core.PluggableWeakSet</class-id> <category>copying</category><body package="WeakCollections" selector="copyEmpty:">copyEmpty: aSize	^(super copyEmpty: aSize)		hashBlock: self hashBlock;		equalBlock: self equalBlock;		yourself</body></methods><methods><class-id>Core.PluggableWeakSet</class-id> <category>private</category><body package="WeakCollections" selector="findElementOrNil:">findElementOrNil: anObject 	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."	| index length probe pass indexOfTombstone |	length := self basicSize.	pass := 1.	index := self initialIndexFor: (self hashBlock value: anObject) boundedBy: length.	[		probe := self basicAt: index.		(indexOfTombstone == nil and: [probe == self tombstone]) ifTrue: [indexOfTombstone := index].		probe == nil or: [probe ~~ self tombstone and: [self equalBlock value: probe value: anObject]]	] 		whileFalse: 			[				(index := index + 1) &gt; length ifTrue: 					[						index := 1.						pass := pass + 1.						pass &gt; 2 ifTrue: [^self grow findElementOrNil: anObject]					]			].	probe ~~ nil ifTrue: [^index].	^indexOfTombstone ifNil: [index]</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>adding</category><body package="WeakCollections" selector="add:">add: newObject 	"Include newObject as one of the receiver's elements.  Answer newObject."	^self evaluateWithFullProtection:  [super add: newObject]</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>private</category><body package="WeakCollections" selector="changeCapacityTo:">changeCapacityTo: newCapacity 	"Change the size of the receiver to newCapacity.  The receiver will	be regrown if necessary to fit its contents."	"Note that #rehash uses this -- don't optimize the case where	the receiver doesn't change in size."	self evaluateWithFullProtection: 			[| newSelf |			newSelf := self copyEmpty: newCapacity.			"Set the accessLock of the copy before adding elements, such that the copy can't be modified by another process before we are done. That's a bit paranoid, of course."			newSelf setAccessLock: accessLock.			"deliberate super-send since we want to avoid an unecessary lock"			super do: [:each | newSelf noCheckAdd: each].			self become: newSelf]</body><body package="WeakCollections" selector="evaluateWithFullProtection:">evaluateWithFullProtection: aBlock	"Run the block in a critical section.  Also, if an exception is raised, catch it,	unwind out of the critical section, then re-raise the signal"	| exception return |	return := [accessLock critical: aBlock]		on: Error		do: [:ex |				exception := ex.				ex return: nil].	^exception == nil		ifTrue: [return]		ifFalse:			[| newException |				newException := exception copyForReraise.				exception willProceed					ifTrue: [newException raiseRequest]					ifFalse: [newException raise]]</body><body package="WeakCollections" selector="find:ifAbsent:">find: anObject ifAbsent: aBlock 	"Although this is a private method, it is used at least by MessageTally from the Advanced Tools Profiler. So it has to be thread safe by itself."	^self evaluateWithFullProtection: [super find: anObject ifAbsent: aBlock]</body><body package="WeakCollections" selector="setAccessLock:">setAccessLock: aRecursionLock 	accessLock := aRecursionLock</body><body package="WeakCollections" selector="setTally">setTally	"Initialize the number of elements to be 0."	self setAccessLock: RecursionLock new.	super setTally</body><body package="WeakCollections" selector="trim">trim	"Adjust the receiver's capacity to fit its contents without wasting space	(but not so much as to be inefficient on lookup)."		self evaluateWithFullProtection: [super trim]</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>enumerating</category><body package="WeakCollections" selector="collect:">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a Set that is like 	the receiver.  Answer the new Set."	| answer |	tally = 0 ifTrue: [^self species new: 2].	answer := self species new: self size * 3 // 2.	self do: [:each | answer add: (aBlock value: each)].	^answer</body><body package="WeakCollections" selector="do:">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	| strongCopy stream |	strongCopy := Array new: self size.	stream := strongCopy writeStream.	self fastDo: [:each | stream nextPut: each].	^ stream contents do: aBlock.</body><body package="WeakCollections" selector="fastDo:">fastDo: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	This should only be called when aBlock is certain to be very quick, since	it holds the lock throughout the operation"	"Would it be worthwhile to override the conversion methods (#asXxx) to	call this instead of #do: ?"	self evaluateWithFullProtection: [super do: aBlock]</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>accessing</category><body package="WeakCollections" selector="findElementLike:ifAbsent:">findElementLike: anObject ifAbsent: aBlock 	^self 		evaluateWithFullProtection: [super findElementLike: anObject ifAbsent: aBlock]</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>testing</category><body package="WeakCollections" selector="includes:">includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^self evaluateWithFullProtection: [super includes: anObject]</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>copying</category><body package="WeakCollections" selector="postCopy">postCopy	super postCopy.	self setAccessLock: RecursionLock new</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>removing</category><body package="WeakCollections" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock 	"Remove oldObject as one of the receiver's elements.  If several of the	elements are equal to oldObject, only one is removed. If no element is equal to	oldObject, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, oldObject."	^self evaluateWithFullProtection: 			[super remove: oldObject ifAbsent: anExceptionBlock]</body></methods><methods><class-id>Core.ThreadSafeWeakSet</class-id> <category>updating</category><body package="WeakCollections" selector="updateTally">updateTally	"Update the counter which keeps track of how many elements the receiver contains."	| size |	size := 0.	self evaluateWithFullProtection: 			[super do: [:each | size := size + 1].			self tallySize: size]</body></methods><methods><class-id>Core.PluggableThreadSafeWeakSet</class-id> <category>accessing</category><body package="WeakCollections" selector="equalBlock">equalBlock	^equalBlock ifNil: [[:object1 :object2 | object1 = object2]]</body><body package="WeakCollections" selector="equalBlock:">equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock := aBlock</body><body package="WeakCollections" selector="hashBlock">hashBlock	^hashBlock ifNil: [[:object | object hash]]</body><body package="WeakCollections" selector="hashBlock:">hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock := aBlock</body></methods><methods><class-id>Core.PluggableThreadSafeWeakSet</class-id> <category>copying</category><body package="WeakCollections" selector="copyEmpty:">copyEmpty: aSize	^(super copyEmpty: aSize)		hashBlock: self hashBlock;		equalBlock: self equalBlock;		yourself</body></methods><methods><class-id>Core.PluggableThreadSafeWeakSet</class-id> <category>private</category><body package="WeakCollections" selector="findElementOrNil:">findElementOrNil: anObject 	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."	| index length probe pass indexOfTombstone |	length := self basicSize.	pass := 1.	index := self initialIndexFor: (self hashBlock value: anObject) boundedBy: length.	[		probe := self basicAt: index.		(indexOfTombstone == nil and: [probe == self tombstone]) ifTrue: [indexOfTombstone := index].		probe == nil or: [probe ~~ self tombstone and: [self equalBlock value: probe value: anObject]]	] 		whileFalse: 			[				(index := index + 1) &gt; length ifTrue: 					[						index := 1.						pass := pass + 1.						pass &gt; 2 ifTrue: [^self grow findElementOrNil: anObject]					]			].	probe ~~ nil ifTrue: [^index].	^indexOfTombstone ifNil: [index]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>