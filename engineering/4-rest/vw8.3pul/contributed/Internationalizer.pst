<?xml version="1.0"?><st-source><!-- Name: InternationalizerNotice: Copyright 2013-2016 Cincom Systems, Inc.  All rights reserved.BundleName: InternationalizerBundleStructure: a Store.BundleForParcelComment: Internationalizer is a Bundle that contains code and tools to internationalize VisualWorks applications.  Bundle contentsI18n-Core	- the API to find user messages and strings that are not yet user messages.	- the API to read pst files and create catalog files based on that information as well as create an error report as change-file.I18n-Tools 	- the tools to find all user messages in the current image and show the found catalogs in a window	- tools to fix problems in the catalogsOverviewThe internationalizer package is based on top of Refactoring Browser technology. It uses the Rewrite engine to find user messages and strings. It also provides code transformations to convert strings to user messages, based on the refactoring framework.It uses pragmas to be easily extensible.The tools now provide a list of catalogs that are found in the system, showing problems that were found, like too long keys, invalid keys, duplicate keys, etc.The Refactoring Browser has new text-functions that appear in the context menu of the text editor. These functions allow for converting a string to a user message or to mark it as non-localizable. There's also a function to convert string concatanations to macro-expressions like 'a', 1 printString, aString => 'a1<1s>' expandMacrosWith: aString.Usage- to internationalize a string it is possible to either convert it into a user message or to mark it so that it's not localized (by sending #asIs to the string or the literal containing the string).- to exclude methods or pragmas from internationalization, define methods with the pragmas #i18nSelectorsToIgnore or #i18nPragmasToIgnore. The results of these methods are selectors or pragmas that will not be listed when non-internationalized strings are searched.- the package I18nRuntime has to become prerequisite of those pundles that refer to #asIs or to the pragmas #i18nSelectorsToIgnore and #i18nPragmasToIgnore- use the Tools Menu in the VisualLauncher to browse strings that are not internationalized or to browse all catalogs in the system to find errors or to export their user messages.DevelopmentPrerequisites: #(#(#any 'I18nRuntime' '') #(#any 'RefactoringBrowserInSubcanvas' '') #(#any 'Tools-Changes' '') #(#any 'Tools-Workspace' '') #(#any 'Assets' ''))Parcel: nilParcelName: InternationalizerPrerequisiteDescriptions: #(#(#name 'I18nRuntime' #componentType #package) #(#name 'RefactoringBrowserInSubcanvas' #componentType #package) #(#name 'Tools-Changes' #componentType #package) #(#name 'Tools-Workspace' #componentType #package) #(#name 'Assets' #componentType #package))PrerequisiteParcels: #(#('I18nRuntime' '') #('RefactoringBrowserInSubcanvas' '') #('Tools-Changes' '') #('Tools-Workspace' '') #('Assets' '') #('I18nRuntime' ''))Version: 8.2 - 3Date: 1:30:55 PM June 3, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.1) of June 3, 2016 on June 3, 2016 at 1:30:55 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>I18nTools</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private I18nCore.*			</imports><category></category><attributes><package>I18n-Tools</package></attributes></name-space><name-space><name>I18nCore</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Refactory.Browser.*			</imports><category>I18n</category><attributes><package>I18n-Core</package></attributes></name-space><class><name>I18nClassDefinitionChange</name><environment>I18nTools</environment><super>Kernel.ClassDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalFile relatedChanges cachedText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.I18nClassDefinitionChange</class-id><body>I18nClassDefinitionChange exists for the I18nPatchChangeList. It differs from ClassDefinitionChange by always answering its actual filename.The I18nClassDefinitionChange is used when the I18nPatchChangeList reads a change-file. The change list will convert all changes to i18n changes by sending #asI18nChange. The changes know their errors and after the changes were modified, the changes can be written out into seperate files based on the file they were defined in. The filename information is acquired on instance creation by asking the SourceFileManager for the file of the change's source.Instance Variables	originalFile 	&lt;EncodedStream&gt;	 	the file that this change was read from	relatedChanges &lt;Collection&gt;	cachedText 	&lt;Text&gt; 				the text of the change, cached so that it doesn't have to be read from file everytime.</body></comment><class><name>UserMessageProblem</name><environment>I18nCore</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.UserMessageProblem</class-id><body>UserMessageProblem is just an abstract superclass of the different problems that can happen during internationalization</body></comment><class><name>DuplicateKeyUserMessage</name><environment>I18nCore</environment><super>I18nCore.UserMessageProblem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stringsWithMethods catalog key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.DuplicateKeyUserMessage</class-id><body>DuplicateKeyUserMessage represents a UserMessage-key that has more than one Default Strings in a given catalog. It knows both the strings as well as the methods in which these strings are used with the key.Instance Variables	catalog				&lt;Symbol&gt;		key					&lt;Symbol&gt;		stringsWithMethods	&lt;Dictionary of: String to: (Set of: MethodDefinition)&gt;</body></comment><class><name>ProblemNavigator</name><environment>I18nTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchStringHolder methodListHolder problems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.ProblemNavigator</class-id><body>ProblemNavigator displays a list of user message problem objects. The list is displayed as part of a ProblemViewer, which displays both a problem navigator an a refactoring browser. A change in the problem navigator should update the methodListHolder and the searchStringHolder. Both values are used to update the surrounding ProblemViewer's RefactoringBrowser. The MethodDefinitions that are put into the methodListHolder are listed in the RB. The strings in searchStringHolder are used to define the highlighting in the RB.Subclasses must implement the following messages:	accessing		windowLabel			"returns the label of the window"	interface opening		connectAspects			"subclasses can now fill in the widgets' values"	testing		hasSelection			"returns true if something is selected"	updating		methodsOfProblem:			"returns the methods that are linked to a certain user message problem. 			These methods are shown in the refactoring browser"		objectsForMethods			"returns a dictionary with compiled methods to objects that refer to these methods"			updateExistingProblem:withUpdatedProblem:inMethod:			"an existingProblem was updated, apply the information of the updateProblem to the existingProblem 			and update the user interface"Instance Variables	methodListHolder	&lt;ValueModel on: Collection of: MethodDefinition&gt; 	holds the list of methods that are shown in the RB	problems			&lt;Collection of: UserMessageProplem&gt;				collection of the problems	searchStringHolder	&lt;ValueModel on: Collection of: String&gt;				holds the strings that are highlighted in the RB</body></comment><class><name>CompositeProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.ProblemNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>problemNavigators subNavigator toolbarChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.CompositeProblemNavigator</class-id><body>CompositeProblemNavigator lists multiple navigators at once so that the user can switch between different problem navigators.The selected navigator will be displayed and most responsibilities will be delegated to the sub navigator.Instance Variables	problemKinds	&lt;SelectionInList&gt;		the possible navigators	subNavigator	&lt;ProblemNavigator&gt;		the currently selected subNavigator	toobarChannel 	&lt;ValueModel&gt; 			the channel for the window's toolbar. When the selected navigator changes, the toolbar is updated.</body></comment><class><name>UserMessageNodeFinder</name><environment>I18nCore</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars>rules lastClass </class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.UserMessageNodeFinder</class-id><body>UserMessageNodeFinder finds all UserMessages in a given Method.ImplementationThe UserMessageNodeFinder uses the ParseTreeSearcher to match rewrite-tool patterns against the parse tree of a method. The patterns that it looks for are defined in class-side methods with the &lt;pattern: ''&gt; pragma. These methods not only define the pattern but they are also called with the node that matches their pattern. They then need to return the object that this node represents, or nil. In case that a user message is reported by two rules, the results are filtered according to their source position so that a user message that is part of another user message is rejected.To further filter the results it is possible to add methods with the &lt;invalidation&gt; pragma. Those methods receive the node and its result as arguments and when they return true, this node and its result are invalid and will be rejected. This functionality is used especially by the MissingI18nStringNodeFinder to filter out strings that should not be found for missing internationalization, such as strings used for ByteArray fromPackedString: or strings in methods that are too long to be handled in the refactoring browser (&gt;50k characters). Both #pattern: and #invalidation pragmas allow for custom extensions of the UserMessageNodeFinder and its subclasses. So that it is possible to find other kinds of user messages or ignore invalid strings and user messages.Usage	UserMessageNodeFinder userMessagesInMethod: aCompiledMethodInstance Variables	method  	&lt;MethodDefinition&gt; 		the method that's analyzedClass Instance Variables	rules 			&lt;Dictionary of: SBProgramNode -&gt; Symbol&gt; 		the dictionary contains the search patterns that are passed to the ParseTreeSearcher and their associated method, which converts the nodes to objects	lastClass 		&lt;Class&gt; 										the class that was scanned. It is used to trigger an increment notification so that some progress is possible when methods are searched</body></comment><class><name>ChangeWithErrors</name><environment>I18nCore</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>change errors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.ChangeWithErrors</class-id><body>ChangeWithErrors contains a Change and a dictionary of i18n errors for that change. It is used during the export of the SourceFileCatalogWriterOverviewThe errors are simply a dictionary with a name of the error and a set of strings for each error. If a change has multiple i18n errors, they all accumulate in the errors dictionary and are all combined into a comment Change."this method has multiple i18n errors, stored in a changelist, this would be one change"exampleMethod	#key1 &lt;&lt; #catalog &gt;&gt; 'string1'.	#key1 &lt;&lt; #catalog &gt;&gt; 'string2'.	#key2: &lt;&lt; #catalog &gt;&gt; 'invalid key'.	#key3:key:4 &lt;&lt; #catalog &gt;&gt; 'invalid key2'."there would be a ChangeWithErrors for this change with the following error dictionary"Dictionary new	at: 'Duplicate Key' put: #('#key1 #catalog ''string1'' ''string2''') asSet;	at: 'Invalid key' put: #(#key2: #key3:key4:) asSet;	yourselfUsage	| changeWithErrors |	changeWithErrors := ChangeWithErrors forChange: (Change new).	changeWithErrors addError: 'Invalid Key' withDescription:'#keyWithColon:'.	changeWithErrors errorCommentChange Instance Variables	change	&lt;Change&gt;										errors	&lt;(Dictionary of: String to: (Set of: String))&gt;	errors with their descriptions. for each error there can be multipe descriptions.</body></comment><class><name>BrowserCodeToolHelper</name><environment>I18nTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCodeEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.BrowserCodeToolHelper</class-id><body>BrowserCodeToolHelper is an abstract class of objects that can perform a certain text-transforming task on a BrowserCodeTool. Subclasses must implement the following messages:	action		convertSelection			use the I18nRewriter returned by #rewriter and make it perform the text transformation taskInstance Variables	sourceCodeEditor	&lt;SourceCodeEditor&gt;	</body></comment><class><name>UserMessageBuilder</name><environment>I18nTools</environment><super>I18nTools.BrowserCodeToolHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.UserMessageBuilder</class-id><body>UserMessageBuilder transforms a selected string in the Refactoring Browser into a UserMessage. The function is only available if the string is not already part of a UserMessage.Usage	select a string like in:	Dialog warn: 'Hello World'.	after the transformation is applied, the string will be replaced to a user message like:	Dialog warn: #helloWorld &lt;&lt; #dialogs &gt;&gt; 'Hello World'.</body></comment><class><name>MarkNonI18nBuilder</name><environment>I18nTools</environment><super>I18nTools.UserMessageBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.MarkNonI18nBuilder</class-id><body>The MarkNonI18nBuilder convert strings into a string that should not be internationalized by appending the message-send #asIs to it.</body></comment><class><name>RewriteNodeType</name><environment>I18nTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type replacement template validationBlock resolutionBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.RewriteNodeType</class-id><body>RewriteNodeType represents a type of a RBProgramNode and defines how this type of node should be replaced. It is used by the I18nRewriter to describe what the ParseTreeRewriter should search for and how it should replace it.OverviewRewriteNodeTypes are generated based on methods that are defined in I18nRewriter. These methods have the pragmas #templateForContext:replacement:, #defaultReplacement:, #stringContext: and #templateResolution:.The #stringContext: pragma defines the type's validation block. The #templateForContext:replacement: and #defaultReplacement: define what template should be used. The #templateResolution: pragma defines how a template is resolved with a certain object. All templates for the same replacement should always use the same indexes in the template. For a UserMessage the first paramter of the template is always the key, then the catalog and at third place the default string. The array of arguments for a template is defined in the methods with #templateResolution: pragma.Instance Variables	replacement		&lt;Symbol&gt;	description of replacement	template		&lt;String&gt;	a template-string, expanded as macro with the arguments returned by the block stored in &lt;resolution&gt;	type			&lt;Symbol&gt;	the type of node	validationBlock	&lt;Block&gt;	validates the node if this type applies to it	resolutionBlock 	&lt;Block&gt; 	a block that, when called with an object, returns the arguments for the template out of that object</body></comment><class><name>ChangeSetDependent</name><environment>I18nTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodsObjectCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.ChangeSetDependent</class-id><body>ChangeSetDependent is an application model that is a dependent of the ChangeSet. Whenever a method changes, is added or removed, it will update its data. It registers as dependent when the window opens and removes itself as dependent when it closes.Subclasses must implement the following messages:	accessing		buildMethodObjectCache			"this method has to create a Dictionary with methodDefinitions to objects. 			Subclasses may define what objects they refer to"		method: aMethodDefinition hasMissingI18nStrings: missingI18nStrings andUsesCatalogs: catalogs			"aMethodDefinition was changed and now has the MissingI18nStrings or UserMessageCatalogs			that are passed as parameters. Subclasses need to find out based on that information 			how they need to update their objects. 			This method is called when a method was added, removed or changed"Instance Variables	methodsObjectCache	&lt;Dictionary of: MethodDefinition to: (Collection of Object)&gt;	</body></comment><class><name>CatalogsUI</name><environment>I18nTools</environment><super>I18nTools.ChangeSetDependent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalogsList selectedCatalog toolbar catalogsListContextMenu menu targetDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.CatalogsUI</class-id><body>CatalogsUI lists all the UserMessageCatalogs that are found in the system. It shows how many keys each catalog has, if there're problems with the catalog, etc. It also provides means to fix those problems and allows for writing LBL &amp; IDX files for the catalogs.Instance Variables	catalogsList					&lt;MultiSelectionInList&gt;		the list of CatalogItems	catalogsListContextMenu	&lt;ValueHolder on:Menu&gt;		value holder for the menu used by the list of catalog items	menu						&lt;ValueHolder on:Menu&gt;		value holder for the window's menu	selectedCatalog				&lt;ValueModel&gt;				the selected catalog item	toolbar						&lt;ValueHolder on:Menu&gt;		the value holder for the menu that's used in the toolbar</body></comment><class><name>SourceFileCatalogWriter</name><environment>I18nCore</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoriesToIgnore parcelsToIgnore rootFolder errorChanges </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.SourceFileCatalogWriter</class-id><body>SourceFileCatalogWriter reads the visual.sou and all .pst files in a given folder, ignoring those it is told to ignore and finds out all user messages that are used, so that it can export all catalogs with their user messages into a folder.Usage	SourceFileCatalogWriter new createCatalogsInto: 'Messages' asFilename.Instance Variables	directoriesToIgnore	&lt;Collection of: String&gt;			names of the directories that should be ignored	parcelsToIgnore		&lt;Collection of: String&gt;			patterns of parcels that should be ignored. *s in the patterns must be provided explicitly.	rootFolder			&lt;Filename&gt;						the folder in which the pst files are searched. defaults to $VISUALWORKS	errorChanges 		&lt;OrderedCollection of: Change&gt;		the changes for the errors that were found during the analysis</body></comment><class><name>UserMessageCatalog</name><environment>I18nCore</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name messageMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.UserMessageCatalog</class-id><body>UserMessageCatalog represents a catalog of user messages. It has a name and knows all its UserMessages together with the methods in which they are used.Instance Variables	messageMap	&lt;Dictionary of UserMessage -&gt; (Collection of: MethodDefinition)&gt;		name			&lt;String&gt;	</body></comment><class><name>UndefinedUserMessageCatalog</name><environment>I18nCore</environment><super>I18nCore.UserMessageCatalog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>nilKey </class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.UndefinedUserMessageCatalog</class-id><body>UndefinedUserMessageCatalog represents a user message catalog whose name is nilClass Instance Variables		nilKey 		&lt;Object&gt; 	a marker for the nil catalogs. It is used as a key in a dictionary where the catalog name is used as key.</body></comment><class><name>MacroBuilder</name><environment>I18nTools</environment><super>I18nTools.BrowserCodeToolHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.MacroBuilder</class-id><body>MacroBuilder converts a selected list of concatanated strings into a macro.Usage	In the Refactoring Browser select text like:	'this ', aCar printString, ' has the color ', aCar color , '.'	and when it is converted into a macro it looks like:	'this &lt;1p&gt; has the color &lt;2s&gt;.' expandMacrosWith: aCar with: aCar color. </body></comment><class><name>UserMessageProblemWithMethods</name><environment>I18nCore</environment><super>I18nCore.UserMessageProblem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.UserMessageProblemWithMethods</class-id><body>UserMessageProblemWithMethods are user message problem that knows in which methods the problem happens.Instance Variables	methods	&lt;Set of: MethodDefinition&gt;	</body></comment><class><name>ProblemNavigatorWithMethods</name><environment>I18nTools</environment><super>I18nTools.ProblemNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>problemList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.ProblemNavigatorWithMethods</class-id><body>ProblemNavigatorWithMethods displays a list of UserMessageProblemWithMethods objects. It handles selection changes and changes to methods in order to update the problemsInstance Variables	problemList		&lt;SelectionInList&gt;	the list that displays the problems.</body></comment><class><name>UserMessageProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.ProblemNavigatorWithMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.UserMessageProblemNavigator</class-id><body>UserMessageProblemNavigator is a ProblemNavigator for UserMessageInCatalog objects</body></comment><class><name>CatalogItem</name><environment>I18nTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.CatalogItem</class-id><body>CatalogItem wraps a UserMessageCatalog for use in the CatalogsUI's dataset.Instance Variables	catalog	&lt;UserMessageCatalog&gt;	</body></comment><class><name>MissingI18nProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.ProblemNavigatorWithMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.MissingI18nProblemNavigator</class-id><body>MissingI18nProblemNavigator displays MissingI18nString objects. </body></comment><class><name>NoProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.ProblemNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.NoProblemNavigator</class-id><body>NoProblemNavigator is a dummy navigator that's used when no problems need to be displayed</body></comment><class><name>MissingI18nStringNodeFinder</name><environment>I18nCore</environment><super>I18nCore.UserMessageNodeFinder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.MissingI18nStringNodeFinder</class-id><body>MissingI18nStringNodeFinder is a UserMessageNodeFinder that searches for all strings in a method that are not part of a user message and that still need to be internationalized.ImplementationIt searches for all literals that are strings. It then invalidates all strings that are irellevant, like strings that are part of a user message or that receive an #asIs message send. It also ignores strings that are arguments to ByteArray class&gt;&gt;fromPackagedString:. It will also reject strings found in methods that have a source code with more than 50k characters. These methods are typically files and should be treated entirely different for localization.There're two phases of invalidation. The first is to searches for all user messages and rejects strings that are part of the user messages. The other invalidation is more generic and defined by class-methods that have an &lt;invalidation&gt; pragma. These methods take up to three parameters, which are a RBValueNode with a string that could be a string that's not internationalized, the second parameter is the string and the last parameter is the method. If the invalidation-method returns true, then the string is invalid and rejected. </body></comment><class><name>InvalidKeyProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.ProblemNavigatorWithMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.InvalidKeyProblemNavigator</class-id><body>InvalidKeyProblemNavigator lists InvalidKeyMessage objects</body></comment><class><name>MethodFilterMissingI18n</name><environment>I18nCore</environment><super>Tools.MethodFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.MethodFilterMissingI18n</class-id><body>MethodFilterMissingI18n is a MethodFilter that finds all methods that contain strings that are not internationalized</body></comment><class><name>InvalidCodeUserMessageProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.UserMessageProblemNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.InvalidCodeUserMessageProblemNavigator</class-id><body>InvalidCodeUserMessageProblemNavigator is a ProblemNavigator for InvalidCodeUserMessage objects.</body></comment><class><name>UserMessageInCatalog</name><environment>I18nCore</environment><super>I18nCore.UserMessageProblemWithMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key defaultString catalog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.UserMessageInCatalog</class-id><body>UserMessageInCatalog represents a UserMessage in a catalog. In addition to the normal UserMessage, it knows in which methods the user message is used.Instance Variables	catalog			&lt;Symbol&gt;		defaultString	&lt;String&gt;		key				&lt;Symbol&gt;	</body></comment><class><name>DuplicateKeyProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.ProblemNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stringsList keysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id><body>DuplicateKeyProblemNavigator lists the UserMessage keys that are used with multiple default strings.Instance Variables	duplicateKeys	&lt;OrderedCollection of: DuplicateKeyUserMessage&gt;		keysList		&lt;SelectionInList on: DuplicateKeyUserMessage&gt;		stringsList		&lt;SelectionInList on: String&gt;						</body></comment><class><name>NodeWithObject</name><environment>I18nCore</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node object finder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.NodeWithObject</class-id><body>NodeWithObject marks a possible result when searching through the parse-tree for user messages or strings. The algorithm to find user messages and strings in a parse tree is to use search patterns and convert the matching pattern into the actual string or user message. Due to the way the matching works, it can happen that multiple matches are made on the same user message. A user message with #key &lt;&lt; #catalog &gt;&gt; 'string' matches the rule for a full user message, where all three parts are given but also matches the rules for partial user messages where the key or the default string is missing. Once all matches are collected, the redundant matches are removed by testing if one node is enclosed by another node, which is also done by the NodeWithObject. Instance Variables	node	&lt;RBProgramNode&gt;			the node that describes &lt;object&gt; in code	object	&lt;String | UserMessage&gt;		the object that &lt;node&gt; represents	finder 	&lt;UserMessageNodeFinder&gt;	the finder that found this object</body></comment><class><name>I18nPatchChangeList</name><environment>I18nTools</environment><super>Tools.ChangeList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastTextSearch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>I18n</category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.I18nPatchChangeList</class-id><body>I18nPatchChangeList is a specialization of ChangeList for viewing and modifying definitions associated with an I18n catalog error report.Instance Variables	lastTextSearch	&lt;String | nil&gt;	optional string defined to search methods by </body></comment><class><name>UserMessageCreationDialog</name><environment>I18nTools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalog key defaultString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.UserMessageCreationDialog</class-id><body>UserMessageCreationDialog asks for the key and catalog of a UserMessage with a given String.Usage	UserMessageCreationDialog userMessageForString: 'This is a test'.Instance Variables	catalog			&lt;ValueModel on: String&gt;	catalog of the new user message	defaultString	&lt;ValueModel on: String&gt;	default string of the new user message	key				&lt;ValueModel on: String&gt;	key of the new user message</body></comment><class><name>MethodFilterAnyUserMessage</name><environment>I18nCore</environment><super>Tools.MethodFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.MethodFilterAnyUserMessage</class-id><body>MethodFilterAnyUserMessage is a method filter that finds all methods that have a UserMessage</body></comment><class><name>TooLongKeyProblemNavigator</name><environment>I18nTools</environment><super>I18nTools.InvalidKeyProblemNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.TooLongKeyProblemNavigator</class-id><body>TooLongKeyProblemNavigator lists TooLongKeyMessage objects</body></comment><class><name>MissingI18nString</name><environment>I18nCore</environment><super>I18nCore.UserMessageProblemWithMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.MissingI18nString</class-id><body>MissingI18nString represents a String that has not been internationalized in some methods. MissingI18nString knows the string that it represents as well as the methods in which this string is not internationalized.Instance Variables	string		&lt;String&gt;</body></comment><class><name>I18nErrorBrowser</name><environment>I18nTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeView changeList keyedErrors patchDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.I18nErrorBrowser</class-id><body>I18nErrorBrowser allows a user to view the error report of a catalog scan and view, compare, edit, or apply changes to methods. It also enables a user to load a catalog report file generated by I18N and store changes to patch files.Instance Variables	changeList	&lt;SelectionInList&gt;	catalog error selection model	changeView	&lt;I18nPatchChangeList&gt;	change list to view, edit, or apply changes for selected UserMessage error.	keyedErrors	&lt;Dictionary&gt;	method definitions keyed by catalog error</body></comment><class><name>InvalidKeyMessage</name><environment>I18nCore</environment><super>I18nCore.UserMessageProblemWithMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString catalog key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.InvalidKeyMessage</class-id><body>InvalidKeyMessage represents a user message whose Key is not valid, like in #key: &lt;&lt; #catalog &gt;&gt; 'string', where the key is not a unary selector.OverviewIt knows to which catalog the invalid key belongs and what default strings were used. It also knows in which methods the undefined key is used.Instance Variables	key 			&lt;Symbol&gt;	catalog			&lt;Symbol&gt;		defaultString	&lt;String&gt;	</body></comment><class><name>TooLongKeyMessage</name><environment>I18nCore</environment><super>I18nCore.InvalidKeyMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.TooLongKeyMessage</class-id><body>TooLongKeyMessage represents a UserMessageProblems with a key that is too long. Keys must be no longer than 53 characters.</body></comment><class><name>I18nFinder</name><environment>I18nCore</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.I18nFinder</class-id><body>I18nFinder is the starting point for finding all user message catalogs that are used by the system. ImplementationI18nFinder implements class methods to conviniently find user messages. It uses the MethodCollector to find all methods with user messages and then groups them by catalog using UserMessageCatalog objects.Usage	I18nFinder findAllCatalogs	I18nFinder findAllI18nStrings.	I18nFinder findAllI18nStringsInBundle: (Store.Registry bundleNamed:'Base VisualWorks').	I18nFinder findAllI18nStringsInPackage: (Store.Registry packageNamed:'I18n-Core')</body></comment><class><name>ProblemViewer</name><environment>I18nTools</environment><super>I18nTools.ChangeSetDependent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>browser problemNavigator methods searchStrings toolbar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.ProblemViewer</class-id><body>ProblemViewer displays a List of Problems next to a RefactoringBrowser. The List of problems is displayed by a subclass of ProblemNavigator. The ProblemNavigator works on the methods and searchStrings value models in order to set the list of methods to display by the RB. The search strings are used to tell the RB what text to highlight.Instance Variables	browser				&lt;RefactoringBrowserInSubcanvas&gt;		methods			&lt;ValueModel&gt;			the methods that are shown by the RB. 												The value is changed by the problemNavigator	problemNavigator	&lt;ProblemNavigator&gt;			searchStrings		&lt;ValueModel&gt;			the strings that should be highlighted by the RB.												The value is changed by the problemNavigator.</body></comment><class><name>I18nRewriter</name><environment>I18nTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.I18nRewriter</class-id><body>I18nRewriter is used to transform a method for internationalization. It can for example convert a string to a user message or convert a string concatanation to a macro.OverviewThe I18nRewriter is an extensible interface to the RefactoringBrowser's rewrite tool. It changes methods based on patterns that it passes to a ParseTreeRewriter object. It can convert strings to user messages or to non-i18n strings. It can also convert concatanations of strings to macros. It all works on the root instance variable which is an RBRootNameSpace that keeps track of the changes. When a transformation is finished, its changes can be accessed via the #changes method. Changes can also be directly applied by sending #applyChanges or inspected by sending #browseChanges.The rewriter can convert different kinds of things in various way. For example it can convert Strings to UserMessages in either a pragma, a literal array, in normal code or in a spec array. Likewise it can mark a String as non-i18n string.To do all that it defines some pragmas: #stringContext: and #templateForContext:replacement:. The #stringContext: is used to categorize an RBLiteralNode of a string (part of a pragma, part of a literal array, normal code, etc). The categorization is then used to decide which template should be used. The template is tagged with either the #templateForContext:replacement: pragma or with the #defaultReplacement: pragma. If a node can be categorized, the corresponding template is used. If a tag cannot be categorized, the default template is used. If no template can be found, nothing is replaced.To fill the template with data, the #templateResolution: pragma is used, its method returns a list of arguments that are passed to the template.Instance Variables	root		&lt;RBRootNameSpace&gt;	the root namespace in which the modifications are performed</body></comment><class><name>InvalidUserMessage</name><environment>I18nCore</environment><super>Kernel.UserMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.InvalidUserMessage</class-id><body>InvalidUserMessage is a UserMessage that is not valid. It represents UserMessages that are created like this: #key &gt;&gt; 'aString' &gt;&gt; #catalog. Here the #&gt;&gt; is used twice, which is actually equivalent to #key &gt;&gt; 'catalog', when it is evaluated. InvalidUserMessages are only created by the UserMessageNodeFinder, which analyzes the parse tree and doesn't evaluate the code.</body></comment><class><name>I18nMethodDefinitionChange</name><environment>I18nTools</environment><super>Kernel.MethodDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalFile relatedChanges cachedText errors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>I18n-Tools</package></attributes></class><comment><class-id>I18nTools.I18nMethodDefinitionChange</class-id><body>I18nMethodDefinitionChange exists for the I18nPatchChangeList.  It differs from MethodDefinitionChange by always answering its actual filename.The I18nMethodDefinitionChange is used when the I18nPatchChangeList reads a change-file. The change list will convert all changes to i18n changes by sending #asI18nChange. The changes know their errors and after the changes were modified, the changes can be written out into seperate files based on the file they were defined in. The filename information is acquired on instance creation by asking the SourceFileManager for the file of the change's source.Instance Variables	originalFile 	&lt;EncodedStream&gt;	 	the file that this change was read from	relatedChanges &lt;Collection&gt;	cachedText 	&lt;Text&gt; 				the text of the change, cached so that it doesn't have to be read from file everytime.	errors 		&lt;Collection of: String&gt; 	the error messages stored along the change in the changes-file. The errors are stored before the change that they belong to. </body></comment><class><name>MethodFilterUserMessage</name><environment>I18nCore</environment><super>I18nCore.MethodFilterAnyUserMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalogPattern defaultStringPattern keyPattern </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.MethodFilterUserMessage</class-id><body>MethodFilterUserMessage is a MethodFilter that finds method that contain user messages that match a certain pattern. It uses the UserMessageNodeFinder to figure out which messages are defined in a Method.The UserMessages are matched against the patterns for catalog, key and default string. If one of the patterns is nil, only user messages where these values are also nil will be found. Instance Variables	catalogPattern		&lt;nil | String&gt;		defaultStringPattern	&lt;nil | String&gt;		keyPattern			&lt;nil | String&gt;	</body></comment><class><name>InvalidCodeUserMessage</name><environment>I18nCore</environment><super>I18nCore.UserMessageInCatalog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>I18n-Core</package></attributes></class><comment><class-id>I18nCore.InvalidCodeUserMessage</class-id><body>InvalidCodeUserMessage is a user message problem for user messages that are created in an invalid way, like #key &gt;&gt; #catalog &gt;&gt; 'string', where the #&gt;&gt; selector is used twice.ImplementationThe InvalidCodeUserMessage is created for instances of InvalidUserMessage</body></comment><shared-variable><name>LastUsedCatalog</name><environment>I18nTools.UserMessageCreationDialog</environment><private>true</private><constant>false</constant><category>accessing</category><initializer>String new</initializer><attributes><package>I18n-Tools</package></attributes></shared-variable><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>testing</category><body package="I18n-Tools">isModified	^sourceCode isString</body><body package="I18n-Tools">isRelatedTo: aChange 	^self = aChange	  or: [relatedChanges notNil	  	  and: [relatedChanges includes: (aChange isDefinition 											ifTrue: [aChange]											ifFalse: [aChange myDefinition])]]</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>converting</category><body package="I18n-Tools">asI18nChange	originalFile == nil ifTrue: [self updateAfterMutation].	^self</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>file accessing</category><body package="I18n-Tools">fileName	"Return the name of the receiver's stream"	| file |	originalFile isNil		ifTrue: 			[(file := self file) == nil				ifTrue: [^#someLocalStream &lt;&lt; #i18n &gt;&gt; 'some local stream']]		ifFalse: [file := originalFile].	^file displayString copyReplaceAll: '$(VISUALWORKS)' with: 'VW'</body><body package="I18n-Tools">originalFile	^originalFile</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>source code</category><body package="I18n-Tools">cachedText: txt	cachedText := txt</body><body package="I18n-Tools">text	"Answer the text displayed by the receiver."	cachedText == nil ifFalse: [^cachedText].	^super text</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>printing</category><body package="I18n-Tools">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: (#for &lt;&lt; #i18n &gt;&gt; ' for ') asString;		nextPutAll: self checkingName</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>comparing</category><body package="I18n-Tools">= anObject	^self == anObject	 or: [self class == anObject class		and: [self parameters = anObject parameters		and: [self file = anObject file]]]</body><body package="I18n-Tools">hash	^className hash + classType hash</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>related changes</category><body package="I18n-Tools">addRelatedChange: aChange	aChange ~= self ifTrue:		[relatedChanges isNil ifTrue: [relatedChanges := Set new].		 relatedChanges add: aChange]</body><body package="I18n-Tools">addRelatedChanges: changes	relatedChanges isNil ifTrue:		[relatedChanges := Set new: changes size * 2].	changes do:		[:aChange|		aChange ~= self ifTrue:			[relatedChanges add: aChange]]</body><body package="I18n-Tools">relatedChanges	^relatedChanges notNil ifTrue: [relatedChanges] ifFalse: [#()]</body><body package="I18n-Tools">removeRelatedChange: aChange	relatedChanges notNil ifTrue:		[relatedChanges remove: aChange ifAbsent: []]</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange</class-id> <category>private</category><body package="I18n-Tools">updateAfterMutation	originalFile := self file</body></methods><methods><class-id>I18nTools.I18nClassDefinitionChange class</class-id> <category>instance creation</category><body package="I18n-Tools">fromChange: aClassDefinitionChange	| new |	new := Array new: self instSize.	new 		replaceFrom: 1		to: ClassDefinitionChange instSize		with: (aClassDefinitionChange shallowCopy changeClassTo: Array)		startingAt: 1.	self adoptInstance: new.	new updateAfterMutation.	^new</body></methods><methods><class-id>I18nCore.UserMessageProblem</class-id> <category>printing</category><body package="I18n-Core">displayString	^#aProblem &lt;&lt; #i18n &gt;&gt; 'a problem'</body><body package="I18n-Core">printOn: aStream	super printOn: aStream.	aStream		space;		nextPutAll: self displayString</body></methods><methods><class-id>I18nCore.UserMessageProblem</class-id> <category>accessing</category><body package="I18n-Core">addMethodsWithErrorToDictionary: aDictionary	| changeWithErrors |	self allMethods do: 			[:each |			changeWithErrors := aDictionary at: each name						ifAbsentPut: [ChangeWithErrors forChange: each].			changeWithErrors addError: self errorName				withDescription: self errorDescription]</body><body package="I18n-Core">allMethods	self subclassResponsibility</body><body package="I18n-Core">errorDescription	self subclassResponsibility</body><body package="I18n-Core">errorName	self subclassResponsibility</body></methods><methods><class-id>I18nCore.UserMessageProblem</class-id> <category>comparing</category><body package="I18n-Core">= anI18nString	^self class = anI18nString class</body><body package="I18n-Core">hash	^self class hash</body><body package="I18n-Core">validForWritingCatalog	"returns true if the user message can be written to an LBL file, even though this problem exists."	^false</body></methods><methods><class-id>I18nCore.UserMessageProblem class</class-id> <category>accessing</category><body package="I18n-Core">forMessage: each inCatalog: catalog	^self new</body></methods><methods><class-id>I18nCore.UserMessageProblem class</class-id> <category>instance creation</category><body package="I18n-Core">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>I18nCore.DuplicateKeyUserMessage</class-id> <category>accessing</category><body package="I18n-Core">addMethod: aMethod forString: aString	(self stringsWithMethods at: (self lookupKeyForString: aString)		ifAbsentPut: [Set new]) add: aMethod</body><body package="I18n-Core">allMethods	| methods |	methods := Set new.	self stringsWithMethods values do: [:each | methods addAll: each].	^methods</body><body package="I18n-Core">catalog	^catalog</body><body package="I18n-Core">catalog: anObject	catalog := anObject</body><body package="I18n-Core">errorDescription	| ws |	ws := String new writeStream.	ws		print: self key;		space;		print: self catalog.	self strings sorted do: 			[:each |			ws				space;				print: each].	^ws contents</body><body package="I18n-Core">errorName	^#KeyCollision &lt;&lt; #i18n &gt;&gt; 'Key Collision'</body><body package="I18n-Core">key	^key</body><body package="I18n-Core">key: anObject	key := anObject</body><body package="I18n-Core">methodsForString: aString	^self stringsWithMethods at: (self lookupKeyForString: aString)		ifAbsent: [Set new]</body><body package="I18n-Core">strings	^self stringsWithMethods keys</body><body package="I18n-Core">stringsWithMethods	^stringsWithMethods</body><body package="I18n-Core">stringsWithMethods: anObject	stringsWithMethods := anObject</body></methods><methods><class-id>I18nCore.DuplicateKeyUserMessage</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	stringsWithMethods := Dictionary new.	catalog := nil.	key := nil.	^self</body></methods><methods><class-id>I18nCore.DuplicateKeyUserMessage</class-id> <category>updating</category><body package="I18n-Core">hasMethodsForString: string	^(self methodsForString: string) isEmpty</body><body package="I18n-Core">removeMethod: aMethodDefinition forString: string	(self methodsForString: string) remove: aMethodDefinition ifAbsent: []</body><body package="I18n-Core">removeString: string	^self stringsWithMethods removeKey: string</body></methods><methods><class-id>I18nCore.DuplicateKeyUserMessage</class-id> <category>comparing</category><body package="I18n-Core">= aDuplicateKeyUserMessage	^super = aDuplicateKeyUserMessage and: 			[self key = aDuplicateKeyUserMessage key				and: [self catalog = aDuplicateKeyUserMessage catalog]]</body><body package="I18n-Core">hash	^self key hash</body><body package="I18n-Core">validForWritingCatalog	^true</body></methods><methods><class-id>I18nCore.DuplicateKeyUserMessage</class-id> <category>private</category><body package="I18n-Core">lookupKeyForString: aString	^aString		ifNil: 			["nil cannot be key in a dictionary, a 0 is not a string, hence a good alternative"			0]</body></methods><methods><class-id>I18nCore.DuplicateKeyUserMessage</class-id> <category>printing</category><body package="I18n-Core">displayString	^#userMessageWithoutDefaultStringMacro &lt;&lt; #i18n &gt;&gt; '&lt;1p&gt; %&lt;%&lt; &lt;2p&gt;'		expandMacrosWith: self key		with: self catalog</body></methods><methods><class-id>I18nTools.ProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">methodListHolder	^methodListHolder</body><body package="I18n-Tools">methodListHolder: anObject	methodListHolder := anObject</body><body package="I18n-Tools">problems	^problems</body><body package="I18n-Tools">problems: anObject	problems := anObject</body><body package="I18n-Tools">searchStringHolder	^searchStringHolder</body><body package="I18n-Tools">searchStringHolder: anObject	searchStringHolder := anObject</body><body package="I18n-Tools">toolbarChannel: aValueHolder	| menu |	menu := aValueHolder value.	self updateToolbar: menu.	aValueHolder value: menu</body><body package="I18n-Tools">updateToolbar: menu	menu		augmentFrom: self class		to: ProblemNavigator		menuName: #toolbar		for: self</body><body package="I18n-Tools">windowLabel	"returns the label of the window"	^self subclassResponsibility</body></methods><methods><class-id>I18nTools.ProblemNavigator</class-id> <category>interface opening</category><body package="I18n-Tools">connectAspects	"subclasses can now fill in the widgets' values"	self subclassResponsibility</body><body package="I18n-Tools">keepScrollPositionWhile: aBlock	| problemList scrollWrapper position |	problemList := self widgetAt: #problemList.	problemList isNil ifTrue: [^aBlock value].	scrollWrapper := problemList				findParent: [:each | each isKindOf: ScrollWrapper].	scrollWrapper isNil ifTrue: [^aBlock value].	position := scrollWrapper translation.	aBlock ensure: 			[scrollWrapper setOrigin: position.			problemList invalidate]</body><body package="I18n-Tools">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self connectAspects</body></methods><methods><class-id>I18nTools.ProblemNavigator</class-id> <category>printing</category><body package="I18n-Tools">displayString	^self problemKindClass		ifNotNil: [:cls | cls new errorName]		ifNil: [self class name]</body><body package="I18n-Tools">problemKindClass	^self class problemKind</body></methods><methods><class-id>I18nTools.ProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">method: aMethodDefinition hasMissingI18nStrings: i18nStrings andUsesCatalogs: catalogs references: problemsReferencedByMethod	| updatedObjects newObjects changedObjects removedObjects updatedObject |	self keepScrollPositionWhile: 			[updatedObjects := self updatedProblemsInCatalogs: catalogs						i18nStrings: i18nStrings.			newObjects := updatedObjects						reject: [:each | self problems includes: each].			changedObjects := self problems select: 							[:each |							(updatedObjects includes: each)								or: [(self methodsOfProblem: each) includes: aMethodDefinition]].			self problems addAll: newObjects.			changedObjects do: 					[:each |					updatedObject := updatedObjects detect: [:k | k = each] ifNone: [].					self						updateExistingProblem: each						withUpdatedProblem: updatedObject						inMethod: aMethodDefinition].			removedObjects := self problems						select: [:each | (self methodsOfProblem: each) isEmpty].			removedObjects do: [:each | self problems remove: each ifAbsent: []].			self connectAspects]</body><body package="I18n-Tools">methodsOfProblem: problem	"returns the methods that are linked to a certain user message problem. 	These methods are shown in the refactoring browser"	self subclassResponsibility</body><body package="I18n-Tools">objectsForMethods	"returns a dictionary with compiled methods to objects that refer to these methods"	self subclassResponsibility</body><body package="I18n-Tools">updateExistingProblem: existingProblem withUpdatedProblem: updatedProblem inMethod: aMethodDefinition	"an existingProblem was updated, apply the information of the updateProblem to the existingProblem 	and update the user interface"	self subclassResponsibility</body><body package="I18n-Tools">updatedProblemsInCatalogs: catalogs i18nStrings: i18nStrings	^#()</body></methods><methods><class-id>I18nTools.ProblemNavigator</class-id> <category>testing</category><body package="I18n-Tools">hasSelection	"returns true if something is selected"	^self subclassResponsibility</body></methods><methods><class-id>I18nTools.ProblemNavigator class</class-id> <category>instance creation</category><body package="I18n-Tools">forProblems: problems	^(self new)		problems: problems;		yourself</body><body package="I18n-Tools">problemKind	^nil</body></methods><methods><class-id>I18nTools.ProblemNavigator class</class-id> <category>testing</category><body package="I18n-Tools">navigatableProblemsFrom: navigatorProblems	| navigatableProblems problemKind pragmas |	navigatableProblems := #().	pragmas := Pragma allNamed: #problemKind in: self classBehavior.	pragmas anySatisfy: 			[:pragma |			problemKind := self perform: pragma selector.			navigatableProblems := navigatorProblems						select: [:problem | problem class = problemKind].			navigatableProblems notEmpty].	^navigatableProblems</body></methods><methods><class-id>I18nTools.CompositeProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">subNavigator	^subNavigator</body><body package="I18n-Tools">subNavigator: navigator	subNavigator := navigator</body><body package="I18n-Tools">toolbarChannel	^toolbarChannel</body><body package="I18n-Tools">toolbarChannel: aValueHolder	toolbarChannel := aValueHolder</body><body package="I18n-Tools">windowLabel	^self isNavigatorSelected		ifTrue: [self subNavigator windowLabel]		ifFalse: [#UserMessageBrowser &lt;&lt; #i18n &gt;&gt; 'UserMessage Browser']</body></methods><methods><class-id>I18nTools.CompositeProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">createNavigatorsForProblems	| allProblemNavigators nonEmptyNavigators |	allProblemNavigators := ProblemNavigator allSubclasses				collect: [:class | class forProblems: (class navigatableProblemsFrom: self problems)].	nonEmptyNavigators := allProblemNavigators				reject: [:each | each problems isEmpty].	nonEmptyNavigators do: 			[:each |			each				methodListHolder: self methodListHolder;				searchStringHolder: self searchStringHolder].	^nonEmptyNavigators</body><body package="I18n-Tools">method: aMethodDefinition hasMissingI18nStrings: i18nStrings andUsesCatalogs: catalogs references: problemsReferencedByMethod	^self navigators do: 			[:each |			each				method: aMethodDefinition				hasMissingI18nStrings: i18nStrings				andUsesCatalogs: catalogs				references: problemsReferencedByMethod]</body><body package="I18n-Tools">methodsOfProblem: problem	^self subNavigator methodsOfProblem: problem</body><body package="I18n-Tools">navigators	^self problemNavigators list</body><body package="I18n-Tools">objectsForMethods	^self subNavigator objectsForMethods</body><body package="I18n-Tools">updateExistingProblem: existingProblem withUpdatedProblem: updatedProblem inMethod: aMethodDefinition	^self shouldNotImplement</body></methods><methods><class-id>I18nTools.CompositeProblemNavigator</class-id> <category>interface opening</category><body package="I18n-Tools">connectAspects	self problemNavigators list: self createNavigatorsForProblems.	self navigators do: #connectAspects</body><body package="I18n-Tools">installSubNavigator	(self subNavigator)		methodListHolder: self methodListHolder;		searchStringHolder: self searchStringHolder.	(self widgetAt: #subNavigator)		client: self subNavigator		spec: #windowSpec		builder: self builder newSubBuilder.	self builder window label: self windowLabel.</body></methods><methods><class-id>I18nTools.CompositeProblemNavigator</class-id> <category>testing</category><body package="I18n-Tools">hasSelection	^self selectedNavigator hasSelection</body></methods><methods><class-id>I18nTools.CompositeProblemNavigator</class-id> <category>aspects</category><body package="I18n-Tools">problemNavigators	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^problemNavigators isNil		ifTrue:			[problemNavigators := SelectionInList new]		ifFalse:			[problemNavigators]</body></methods><methods><class-id>I18nTools.CompositeProblemNavigator</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize	super initialize.	self problemNavigators selectionHolder		onChangeSend: #selectedProblemKindChanged		to: self.	subNavigator := NoProblemNavigator new.	^self</body><body package="I18n-Tools">isNavigatorSelected	^self problemNavigators selection notNil</body><body package="I18n-Tools">selectedNavigator	^self problemNavigators selection ifNil: [NoProblemNavigator new]</body><body package="I18n-Tools">selectedProblemKindChanged	| navigator |	navigator := self selectedNavigator.	self subNavigator: navigator.	self installSubNavigator.	navigator updateToolbar: self toolbarChannel value.	self toolbarChannel changed: #value</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder</class-id> <category>processing</category><body package="I18n-Core">invalidationSelectorsForRuleAt: aSelector	^self class invalidationSelectorsForRuleAt: aSelector</body><body package="I18n-Core">isValidNode: aNode withResult: aResult andInvalidation: anInvalidationSelector	| isInvalid |	isInvalid := self class perform: anInvalidationSelector				withArguments: ((Array with: aNode with: aResult with: method) copyFrom: 1						to: anInvalidationSelector numArgs).	^isInvalid not</body><body package="I18n-Core">matchNode: aTree withRule: rule do: aBlock	"use a replace rule because there it is possible to use aBlock to control if the search should continue or stop"	| searcher |	searcher := ParseTreeSearcher new.	searcher addRule: (RBStringReplaceRule				searchForTree: rule				replaceWith: (RBLiteralNode value: nil)				when: aBlock).	searcher executeTree: aTree</body><body package="I18n-Core">nodesAndResultsInTree: aTree	| nodesAndResults patternsAndSelectors invalidationSelectors stopSearchingDeeper |	nodesAndResults := Set new.	aTree isNil ifTrue: [^nodesAndResults].	patternsAndSelectors := self rulesAndHandlerSelectors.	patternsAndSelectors keysAndValuesDo: 			[:rule :selector |			self				matchNode: aTree				withRule: rule				do: 					[:node |					stopSearchingDeeper := false.					(self class perform: selector with: node)						ifNotNil: 							[:result |							invalidationSelectors := self invalidationSelectorsForRuleAt: selector.							(invalidationSelectors allSatisfy: 									[:invalidationSelector |									self isValidNode: node withResult: result andInvalidation: invalidationSelector])								ifTrue: 									[nodesAndResults add: (NodeWithObject node: node object: result finder: self).									stopSearchingDeeper := true]].					stopSearchingDeeper]].	^nodesAndResults</body><body package="I18n-Core">rulesAndHandlerSelectors	^self class rules</body><body package="I18n-Core">searchForNodesIn: aTree	| nodesAndResults |	nodesAndResults := self nodesAndResultsInTree: aTree.	^self filterOutSubResults: nodesAndResults</body><body package="I18n-Core">searchInNode: aTree	^(self searchForNodesIn: aTree) collect: #object</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder</class-id> <category>private</category><body package="I18n-Core">filterOutSubResults: nodesAndResults	"The nodesAndResults have to be sorted by their interval, because the while-loop never removes from behind the index. It always deletes from the remaining nodes"	| nodes current enclosedNodes index |	nodes := OrderedCollection				withAll: (nodesAndResults sorted: #start ascending								, #stop descending).	index := 1.	[index &lt;= nodes size] whileTrue: 			[current := nodes at: index.			enclosedNodes := (nodes allButFirst: index)						select: [:each | current enclosesNode: each].			enclosedNodes do: [:each | nodes remove: each].			index := index + 1].	^nodes</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder</class-id> <category>accessing</category><body package="I18n-Core">method	^method</body><body package="I18n-Core">method: anObject	method := anObject</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>utility</category><body package="I18n-Core">genericInvalidationSelectors	| pragmas |	pragmas := Pragma allNamed: #invalidation in: self class.	^pragmas collect: #selector</body><body package="I18n-Core">invalidationSelectorsForRuleAt: aSymbol	| pragmas |	pragmas := (Pragma allNamed: #invalidationFor: in: self class)				select: [:each | (each argumentAt: 1) = aSymbol].	^self genericInvalidationSelectors , (pragmas collect: #selector)</body><body package="I18n-Core">isProperStringNode: stringNode	^stringNode isNil		or: [stringNode isValue and: [stringNode value isString]]</body><body package="I18n-Core">isProperSymbolNode: aSymbolNode	^aSymbolNode isNil or: 			[aSymbolNode isValue				and: [aSymbolNode value isSymbol]]</body><body package="I18n-Core">refersNode: aNode toClass: aClass	^[aNode value asQualifiedReference value = aClass] on: Error		do: [:ex | ^false]</body><body package="I18n-Core">rulesAndHandlerSelectors	"returns all pattern strings that are parameters to the #pattern: pragma, 	as well as the selector of the method that defines the pragma.	The methods that define the pragma must take one parameter, which is the node that matches the pattern. 	These Methods have to return the UserMessage that's defined by the node or nil"	| pattern pragmas result |	pragmas := Pragma allNamed: #pattern: in: self class.	result := IdentityDictionary new.	pragmas do: 			[:pragma |			pattern := pragma method attributeAt: #pattern ifAbsent: [nil].			pattern notNil				ifTrue: 					[result at: (RBParser parseRewriteExpression: pattern) put: pragma selector]].	^result</body><body package="I18n-Core">userMessageWithKey: keyNode catalog: catalogNode defaultString: stringNode	(self isProperSymbolNode: keyNode) ifFalse: [^nil].	(self isProperSymbolNode: catalogNode) ifFalse: [^nil].	catalogNode value isSymbol		ifTrue: [(catalogNode value isEmpty or: [catalogNode value precedence = 1]) ifFalse: [^nil]].	(stringNode isNil or: 			[(self isProperStringNode: stringNode)				and: [(self isProperSymbolNode: stringNode) not]])		ifFalse: [^nil].	^UserMessage		defaultString: (stringNode ifNotNil: #value)		key: (keyNode ifNotNil: #value)		catalogID: (catalogNode ifNotNil: #value)</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>instance creation</category><body package="I18n-Core">findInMethod: aCompiledMethod	| tree |	lastClass = aCompiledMethod mclass		ifFalse: 			[lastClass := aCompiledMethod mclass.			IncrementNotification raiseSignal].	tree := self parseTreeOfMethod: aCompiledMethod.	^(self forMethod: aCompiledMethod definition) searchInNode: tree</body><body package="I18n-Core">forMethod: aMethodDefinition	^(self new)		method: aMethodDefinition;		yourself</body><body package="I18n-Core">parseTreeOfMethod: aCompiledMethod	^(aCompiledMethod definition isNil		or: [aCompiledMethod definition isForSharedVariable])			ifTrue: 				[RBParser parseExpression: aCompiledMethod getSource					onError: [:aString :pos | ^nil]]			ifFalse: 				[RBParser					parseMethod: (aCompiledMethod mclass sourceCodeAt: aCompiledMethod selector)					onError: [:aString :pos | ^nil]]</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>compiling</category><body package="I18n-Core">classMethodsChanged	super classMethodsChanged.	self flushRules</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>accessing</category><body package="I18n-Core">flushRules	rules := nil</body><body package="I18n-Core">rules	^rules ifNil: [rules := self rulesAndHandlerSelectors]</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>public</category><body package="I18n-Core">addMessagesInTree: tree fromMethod: method toCatalogs: catalogs	| userMessages catalog |	userMessages := self new searchInNode: tree.	userMessages do: 			[:message |			catalog := catalogs				at: (message catalogID ifNil: [UndefinedUserMessageCatalog nilKey])				ifAbsentPut: [UserMessageCatalog named: message catalogID].			catalog addMethod: method forMessage: message]</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>class initialization</category><body package="I18n-Core">initialize	self flushRules</body></methods><methods><class-id>I18nCore.ChangeWithErrors</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	change := nil.	errors := Dictionary new.	^self</body></methods><methods><class-id>I18nCore.ChangeWithErrors</class-id> <category>accessing</category><body package="I18n-Core">addError: errorName withDescription: description	(self errors at: errorName ifAbsentPut: [Set new]) add: description</body><body package="I18n-Core">change	^change</body><body package="I18n-Core">change: anObject	change := anObject</body><body package="I18n-Core">errorCommentChange	"returns a comment Change object that contains the error message"	| writeStream |	writeStream := String new writeStream.	"for some reason the error in the old version has a space at the beginning"	writeStream space.	(self errors keys sorted: #asString ascending) do: 			[:each |			(self errors at: each) sorted do: 					[:description |					writeStream						nextPutAll: each asString;						nextPutAll: ': ' asIs;						nextPutAll: description]				separatedBy: [writeStream cr]]		separatedBy: [writeStream cr].	writeStream space.	^(OtherChange new)		text: writeStream contents;		type: #comment;		yourself</body><body package="I18n-Core">errors	^errors</body><body package="I18n-Core">errors: anObject	errors := anObject</body></methods><methods><class-id>I18nCore.ChangeWithErrors class</class-id> <category>instance creation</category><body package="I18n-Core">forChange: aChange	^(self new)		change: aChange;		yourself</body><body package="I18n-Core">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>I18nTools.BrowserCodeToolHelper</class-id> <category>accessing</category><body package="I18n-Tools">codeTool	^sourceCodeEditor evaluator</body><body package="I18n-Tools">findNode	^sourceCodeEditor selectionNode</body><body package="I18n-Tools">nodesFoundByFinder: nodeFinderClass	| tree |	tree := sourceCodeEditor parseTree.	tree isNil ifTrue: [^#()].	^(nodeFinderClass forMethod: self selectedMethod) searchForNodesIn: tree</body><body package="I18n-Tools">onSourceCodeEditor: anObject	sourceCodeEditor := anObject</body><body package="I18n-Tools">rewriter	^I18nRewriter new.</body><body package="I18n-Tools">selectedInterval	^sourceCodeEditor selectedInterval</body><body package="I18n-Tools">selectedMethod	^self codeTool definition</body><body package="I18n-Tools">text	^sourceCodeEditor text</body></methods><methods><class-id>I18nTools.BrowserCodeToolHelper</class-id> <category>action</category><body package="I18n-Tools">convertSelection	^self subclassResponsibility</body></methods><methods><class-id>I18nTools.BrowserCodeToolHelper</class-id> <category>testing</category><body package="I18n-Tools">canBeApplied	"returns true if the current selection enables this helper"	^sourceCodeEditor isAccepted and: [self findNode notNil]</body><body package="I18n-Tools">isNodeSelectedThatCanBeFoundUsing: nodeFinderClass	"The nodeFinderClass is a UserMessageNodeFinder or subclass. 	Sending #searchForNodesIn: to an instance of nodeFinderClass will return 	a dictionary that has nodes as keys and values "	| nodesAndStrings node |	nodesAndStrings := self nodesFoundByFinder: nodeFinderClass.	node := self findNode.	node isNil ifTrue: [^false].	^nodesAndStrings anySatisfy: [:each | each enclosesNode: node]</body></methods><methods><class-id>I18nTools.BrowserCodeToolHelper class</class-id> <category>instance creation</category><body package="I18n-Tools">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="I18n-Tools">onSourceCodeEditor: aCodeTool	^self new onSourceCodeEditor: aCodeTool</body></methods><methods><class-id>I18nTools.UserMessageBuilder</class-id> <category>testing</category><body package="I18n-Tools">canBeApplied	^super canBeApplied and: [self isI18nStringSelected]</body><body package="I18n-Tools">isI18nStringSelected	^self		isNodeSelectedThatCanBeFoundUsing: I18nCore.MissingI18nStringNodeFinder</body></methods><methods><class-id>I18nTools.UserMessageBuilder</class-id> <category>action</category><body package="I18n-Tools">convertSelection	| node userMessage |	node := self findNode.	(node isValue and: [node value isString and: [node value isSymbol not]])		ifFalse: [^self].	userMessage := UserMessageCreationDialog userMessageForString: node value.	userMessage isNil ifTrue: [^self].	(self rewriter)		convertStringNode: node			toUserMessage: userMessage			inMethod: self selectedMethod;		applyChanges</body></methods><methods><class-id>I18nTools.MarkNonI18nBuilder</class-id> <category>i18n</category><body package="I18n-Tools">convertSelection	| node |	node := self findNode.	(node isValue and: [node value isString and: [node value isSymbol not]])		ifFalse: [^self].	"if the selected node is indeed a string, find its top most literal node so that it can be sent the message #asIs. That's necessary because strings in literal arrays cannot receive a message, only the outmost array can"	[node parent isLiteralNode] whileTrue: [node := node parent].	(self rewriter)		markStringNode: node asNonI18nStringInMethod: self selectedMethod;		applyChanges</body></methods><methods><class-id>I18nTools.RewriteNodeType</class-id> <category>accessing</category><body package="I18n-Tools">replacement	^replacement</body><body package="I18n-Tools">replacement: anObject	replacement := anObject</body><body package="I18n-Tools">resolutionBlock	^resolutionBlock</body><body package="I18n-Tools">resolutionBlock: anObject	resolutionBlock := anObject</body><body package="I18n-Tools">sourceCodeForObject: anObject	^self template		expandMacrosWithArguments: (self resolutionBlock value: anObject)</body><body package="I18n-Tools">template	^template</body><body package="I18n-Tools">template: anObject	template := anObject</body><body package="I18n-Tools">type	^type</body><body package="I18n-Tools">type: anObject	type := anObject</body><body package="I18n-Tools">validationBlock	^validationBlock</body><body package="I18n-Tools">validationBlock: anObject	validationBlock := anObject</body></methods><methods><class-id>I18nTools.RewriteNodeType</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	type := nil.	replacement := #unknown.	template := String new.	validationBlock := [:each | true].	resolutionBlock := [:each | #()].	^self</body></methods><methods><class-id>I18nTools.RewriteNodeType</class-id> <category>testing</category><body package="I18n-Tools">validateNode: aNode	^self validationBlock value: aNode</body></methods><methods><class-id>I18nTools.RewriteNodeType</class-id> <category>printing</category><body package="I18n-Tools">printOn: aStream	super printOn: aStream.	aStream		space;		print: (self type ifNil:[#default]);		space;		nextPutAll: self template</body></methods><methods><class-id>I18nTools.RewriteNodeType class</class-id> <category>instance creation</category><body package="I18n-Tools">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>I18nTools.ChangeSetDependent</class-id> <category>interface closing</category><body package="I18n-Tools">noticeOfWindowClose: aWindow	super noticeOfWindowClose: aWindow.	self release</body></methods><methods><class-id>I18nTools.ChangeSetDependent</class-id> <category>accessing</category><body package="I18n-Tools">buildMethodObjectCache	"fill the methodsObjectCache dictionary"	self subclassResponsibility</body><body package="I18n-Tools">flushMethodObjectCache	methodsObjectCache := nil</body><body package="I18n-Tools">methodObjectCache	methodsObjectCache ifNil: [self buildMethodObjectCache].	^methodsObjectCache</body></methods><methods><class-id>I18nTools.ChangeSetDependent</class-id> <category>updating</category><body package="I18n-Tools">method: aMethodDefinition hasMissingI18nStrings: missingI18nStrings andUsesCatalogs: catalogs	self flushMethodObjectCache</body><body package="I18n-Tools">methodAdded: aMethodDefinition	| methods missingI18nStrings catalogs |	methods := Array with: aMethodDefinition.	missingI18nStrings := I18nCore.I18nFinder missingI18nStringsInMethods: methods.	catalogs := I18nCore.I18nFinder userMessageCatalogsInMethods: methods.	self		method: aMethodDefinition		hasMissingI18nStrings: missingI18nStrings		andUsesCatalogs: catalogs</body><body package="I18n-Tools">methodChanged: aMethodDefinition	self methodAdded: aMethodDefinition</body><body package="I18n-Tools">methodRemoved: aMethodDefinition	self		method: aMethodDefinition		hasMissingI18nStrings: #()		andUsesCatalogs: #()</body><body package="I18n-Tools">referencedObjectsForMethod: aMethodDefinition	^self methodObjectCache at: aMethodDefinition ifAbsent: [#()]</body><body package="I18n-Tools">update: anAspect with: aParameter from: aSender	| method |	aSender ~= ChangeSet		ifTrue: [^super update: anAspect with: aParameter from: aSender].	aParameter size &gt; 1 ifFalse: [^self].	method := MethodDefinition class: (aParameter at: 2)				selector: aParameter first.	anAspect = #changeSelector:class:attributes:		ifTrue: [^self methodChanged: method].	anAspect = #addSelector:class:attributes:		ifTrue: [^self methodAdded: method].	anAspect = #removeSelector:class: ifTrue: [^self methodRemoved: method]</body></methods><methods><class-id>I18nTools.ChangeSetDependent</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize	super initialize.	self flushMethodObjectCache.	^self</body><body package="I18n-Tools">release		super release.	ChangeSet removeDependent: self</body></methods><methods><class-id>I18nTools.ChangeSetDependent</class-id> <category>interface opening</category><body package="I18n-Tools">postBuildWith: aBuilder	super postBuildWith: aBuilder.	ChangeSet addDependent: self</body></methods><methods><class-id>I18nTools.CatalogsUI</class-id> <category>updating</category><body package="I18n-Tools">method: aMethodDefinition hasMissingI18nStrings: missingI18nStrings andUsesCatalogs: catalogs	| newCatalogs |	newCatalogs := self				updateExistingCatalogs: self catalogs				withCatalogsOfChangedMethod: catalogs				referencedIn: aMethodDefinition.	self listCatalogs: newCatalogs.	super		method: aMethodDefinition		hasMissingI18nStrings: missingI18nStrings		andUsesCatalogs: catalogs</body><body package="I18n-Tools">updateExistingCatalogs: existingCatalogs withCatalogsOfChangedMethod: catalogsOfOneMethod referencedIn: aMethodDefinition	"catalogsOfOneMethod are created for a method that has been changed. 	All existing catalogs need to be merged with the new ones.	Merging needs to update all user messages that are referenced according to the data that's now in the new catalogs."	| newCatalogs catalogsDict updatedCatalogs newListOfCatalogs methodReferences |	catalogsDict := Dictionary				withAll: (catalogsOfOneMethod collect: [:each | each name -&gt; each]).	newCatalogs := Dictionary withAll: catalogsDict.	existingCatalogs do: 			[:catalog |			catalogsDict at: catalog name				ifPresent: 					[:newCatalog |					catalog mergeWithCatalog: newCatalog.					newCatalogs removeKey: catalog name]].	updatedCatalogs := existingCatalogs				reject: [:catalog | catalog messages isEmpty].	methodReferences := self referencedObjectsForMethod: aMethodDefinition.	methodReferences do: 			[:catalog |			(catalogsDict includesKey: catalog name)				ifFalse: [catalog removeMessagesInMethod: aMethodDefinition]].	newListOfCatalogs := updatedCatalogs , newCatalogs values asArray.	^newListOfCatalogs</body></methods><methods><class-id>I18nTools.CatalogsUI</class-id> <category>menus</category><body package="I18n-Tools">augmentMenu: mainMenu named: menuName	mainMenu		augmentFrom: self class		to: self class		menuName: menuName		for: self.	^mainMenu</body><body package="I18n-Tools">catalogsListContextMenu	^catalogsListContextMenu		ifNil: 			[catalogsListContextMenu := self privateCatalogsListContextMenu asValue]</body><body package="I18n-Tools">menu	^menu ifNil: [menu := self privateMenu asValue]</body><body package="I18n-Tools">privateCatalogsListContextMenu	^self augmentMenu: Menu new named: #contextMenu</body><body package="I18n-Tools">privateMenu	| newMenu fileMenu |	newMenu := Menu new.	fileMenu := MenuItem labeled: #file &lt;&lt; #i18n &gt;&gt; 'File'.	fileMenu nameKey: #file.	fileMenu submenu: self class toolbar.	newMenu addItem: fileMenu.	^self augmentMenu: newMenu named: #menu</body><body package="I18n-Tools">privateToolbar	^self augmentMenu: self class toolbar named: #toolbar</body><body package="I18n-Tools">saveAllIcon	^	[AlphaCompositedImage image: (Image				extent: 24 @ 24				depth: 32				bitsPerPixel: 32				palette: (Graphics.FixedPalette						redShift: 0						redMask: 255						greenShift: 8						greenMask: 255						blueShift: 16						blueMask: 255)				usingBits: (ByteArray						fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????Z?7=?_?????;;^7.?&gt;7-;/?.;.??;.;/?&gt;7.;??-;^;?;^7.&gt;&gt;7-;/????=6&gt;_''9@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C????I+*&gt;085-\W?&gt;E!(#&gt;$IFS?9VV&amp;O&gt;V%9''?%YZX?9RU%?&gt;T%I_?%IVW?)BQ$?&gt;D!X_%P4UH2YFS%L;I2,,@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C?????S%EU?4%KS?:Z&amp;97?1LWE?&lt;GB0/?F1,#?1,[H?&lt;[F2O?E1\[?/&lt;CA?&lt;KC0?:&amp;):#?OTAD?20/L?&lt;/L#T@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C?????K#D6?SP7N?&gt;Y&amp;)3?1&lt;#I?&lt;3L3_?P4MG?4MGR?=CP4/?N3=C?2L''J?&lt;3M3_&gt;(*Z/=L#T:&gt;1\ZG/0REQ @????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C?????M3$&gt;?2X(K_&gt;I"(7?-KZ7?;N4-_&gt;=/+??0,OC?&lt;CA0/&gt;;/K3?*:2.?:&gt;0,/&gt;S%Y_?HRP)?2@#I?&lt; H2X@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C?????OC9B?2,-L_&gt;E!8''?+*:1?:^''*/&gt;,+J;?+J2.?:.,+/&gt;***7?)ZV(?:^''*/&gt;H"(3?J282?2L%J_&lt;"IB @????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C?????O4ED?2$+K?=:_G;?%IVX?9NS%/&gt;)*:3?X&amp;M&amp;?8VF"O&gt;P$YO?%YZX?9ZW&amp;_&gt;U%)#?%IVW?9RT%?&gt;T%Y_&gt;$IFS?8RE!&gt;UCQT#I$YNT3,''J20C???&lt;@????@O???0C?????O4IE?280MO=IR4;?X6U''?6M%Y?=NTUW?RT-O?9&amp;Z''O?D1\W?0\KB?&lt;[F2O?F1,#?1,[H?&lt;WE1/&gt;?0LG?0,OC?*Z''*O&lt;=PDS?KB&lt;3?2&lt;2MPC???&lt;@????@O???0C?????PTMH?3 ;O?&lt;/LS[?J"00?2,-L_&lt;.LS[?MC\;?9&amp;Z''O?G2L''?3L3M?=CP4_?P4]K?4MCR?&lt;;O4O?H2\+?3L7M?:")*?42MS+;E1(^?AHUF@C???&lt;@????@O???0C?????QT]L?3 :O?&lt;4M#+?O$AD?4ECQ?&lt;7NS;?I" -?8&amp;J#_&gt;4-+_?,;R5?;6&gt;/??B0&lt;O?0LGB?;.&lt;/O&gt;++J;?+;B2?9NU%?&lt;!IB''?HBL''?2@#I C???&lt;@????@O???0C?????QT]K?3=AQ_&gt;L#X??/&lt;CB?;*;/_&lt;&lt;O$K?J241?8VG"_&gt;.++G?):^*?:2,+/&gt;,+J;?*:2.?:**+_&gt;%)Z#?):^*?8"J#O&lt;+K#K?H2T)?2H$J@C???&lt;@????@O???0C?????PDIE?55_X/?(9&gt;#?-+Z8?8ZF"O&lt;?PTS?JR,/?7)&lt;_/&gt;T%Y#?$9NV?9&amp;Z''O&gt;[''I;?''Y6 ?96](O&gt;Y&amp;)3?%9&amp;[?8JD!/&lt;)KCC?I" +?2P&amp;JPC???&lt;@????@O???0C?????P$MG?6M$Y??V5-_?_W:A?4UHSO&lt;?P$W?K#@4?4%KS/=#YV_?X6U''?6!)[O=,[WC?[&amp;=2?61.\O=)Z&amp;7?Z&amp;1.?5ESU?&lt;*KCC?JB$-?2T''J C???&lt;@????@O???0C?????QDYJ?6E#Y/?K2&lt;3?#(&gt;Q?6U''Z/=AP4#?NC,??2&lt;1M/&lt;*KCC?J241?20.L/&lt;,K#K?KB82?20.L/&lt;+KSG?JR,/?2&lt;1M_&lt;4MS+?JR,/?2\)KPC???&lt;@????@O???0C?????NS,??5]XV?&gt;3,;S?"H&amp;K?6)+[/=EQ43?NC(??3P6N/&lt;&gt;PDS?PTMG?4ICQ?=BQD#?P$QH?4ICQ?=@P$[?OS=C?3P6N/&lt;4M#+?KR&lt;2?2(,K0C???&lt;@????@O???0C?????PDEE?41MS?&gt;L#H3?!XVF?7-;_O=EQ4/?O4EE?82M#?&gt;?0LK?.+.=?;&amp;9/O&gt;8.[+?.K&amp;:?;"8./&gt;7.K+?/K2&gt;?8*K#/&lt;9N3??KR&lt;3?24/L0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O????=@P$W?WU="?&gt;#'':O&gt;6-+#?!(ZH?=+Z6??4&lt;?S?:&gt;/+?&gt;7-;_?+:&gt;3?=OO4?=? 8_=WVE3?I2$-?3@2MPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O????=BP4_?X6Q''?=[V5?==_(G?QT!L?;R5-/?[6=3?3,;P?=GQ4/?O3=C?5]WV?&lt;?O4O=]W6K?JR,/?3L4N@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O????=DQ$+?XVM&amp;?&lt;/K3O&gt;N#9G?YV]*?;Z7.O?R4-O?2\''J?&lt;/K3O?I2\+?3&lt;?P?&lt;[F1?=[WFC?KB41?3P5N@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O????&lt;9N3??U5![?;N3-O&gt;H"X/?Z&amp;-.?:V&amp;)?&gt;8.K''?,+J3?;N3-O&gt;2,+O?-;^8?:&gt;/,O=RT5[?I2 ,?24.LPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O????=@PTW?SD5O?82L#O&gt;E!X[?^7-&lt;?8*J"/&gt;M#X;?#H2L?82L#_&gt;K"83?#8&gt;O?8.K"?=IR$3?O4EC?45NT@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????'								asIs))]			once</body><body package="I18n-Tools">toolbar	^toolbar ifNil: [toolbar := self privateToolbar asValue]</body></methods><methods><class-id>I18nTools.CatalogsUI</class-id> <category>catalog writing</category><body package="I18n-Tools">defaultTargetDirectory	| default target |	default := (IndexedFileMessageCatalog directoriesModel value detect:[:any| true] ifNone:['.']) asFilename.	target := default / Locale current languageID.	target exists ifFalse:[^default / 'C'].	^target</body><body package="I18n-Tools">requestTargetDirectory	"Ask the user for the target directory to write catalogs to"	| reply |	reply := Dialog requestDirectoryName: #DirectoryToStore &lt;&lt; #i18n						&gt;&gt; 'Directory to store catalogs?'				default: self targetDirectory.	 ^reply isEmpty ifTrue: [nil] ifFalse: [targetDirectory := reply asFilename]</body><body package="I18n-Tools">warnInvalidCatalogs: invalidCatalogs	| ws catalogNames sortedCatalogNames |	invalidCatalogs isEmpty ifTrue: [^self].	ws := String new writeStream.	sortedCatalogNames := (invalidCatalogs sorted: #name ascending)				collect: [:each | each name asSymbol].	sortedCatalogNames size &gt; 1		ifTrue: 			[(sortedCatalogNames allButLast: 1) do: [:each | ws print: each]				separatedBy: [ws nextPutAll: (#enumerationComma &lt;&lt; #i18n &gt;&gt; ', ') asString].			ws				nextPutAll: (#_and_ &lt;&lt; #i18n &gt;&gt; ' and ') asString;				print: sortedCatalogNames last]		ifFalse: [ws print: sortedCatalogNames first].	catalogNames := ws contents.	Dialog		warn: (#TheFollowingCatalogsCan___seTheyHaveProblemsN1s_ &lt;&lt; #i18n				&gt;&gt; 'The following Catalogs cannot be exported because they have problems: &lt;n&gt;&lt;1s&gt;'					expandMacrosWith: catalogNames)</body><body package="I18n-Tools">writeCatalog: catalog	catalog writeToFile: self targetDirectory / catalog name</body><body package="I18n-Tools">writeCatalogItems: selectedCatalogItems	| items |	items := selectedCatalogItems groupedBy: #isValid.	items at: false		ifPresent: [:invalidItems | self warnInvalidCatalogs: (invalidItems collect: #catalog)].	items at: true		ifPresent: 			[:validItems |			self requestTargetDirectory ifNil:[^self].			validItems do: [:catalogItem | self writeCatalog: catalogItem catalog]]</body></methods><methods><class-id>I18nTools.CatalogsUI</class-id> <category>actions</category><body package="I18n-Tools">findMissingI18nString	ProblemViewer findMissingI18nStrings</body><body package="I18n-Tools">listCatalogs: catalogs	self catalogsList		refreshList: ((catalogs				collect: [:catalog | CatalogItem forCatalog: catalog])					sorted: #numberOfProblems descending , #name ascending)</body><body package="I18n-Tools">refreshCatalogs	self listCatalogs: I18nCore.I18nFinder findAllCatalogs</body><body package="I18n-Tools">showSelectedCatalog	| userMessagesInCatalog catalogItems |	catalogItems := self selectedCatalogItems.	catalogItems isEmpty ifTrue: [^self].	userMessagesInCatalog := Set new.	catalogItems do: 			[:catalogItem |			userMessagesInCatalog				addAll: catalogItem catalog allProblems;				addAll: catalogItem catalog allUserMessages;				yourself].	ProblemViewer viewProblems: userMessagesInCatalog</body><body package="I18n-Tools">writeAllCatalogs	self writeCatalogItems: self catalogsList list</body><body package="I18n-Tools">writeSelectedCatalogs	self writeCatalogItems: self selectedCatalogItems</body></methods><methods><class-id>I18nTools.CatalogsUI</class-id> <category>accessing</category><body package="I18n-Tools">buildMethodObjectCache	methodsObjectCache := Dictionary new.	self catalogs do: 			[:catalog |			catalog messages do: 					[:message |					(catalog methodsForMessage: message) do: 							[:method |							(methodsObjectCache at: method ifAbsentPut: [IdentitySet new])								add: catalog]]]</body><body package="I18n-Tools">catalogs	^(self catalogsList list collect: #catalog) asArray</body><body package="I18n-Tools">selectedCatalogItems	^self catalogsList selections</body><body package="I18n-Tools">targetDirectory	^targetDirectory ifNil:[targetDirectory := self defaultTargetDirectory]</body></methods><methods><class-id>I18nTools.CatalogsUI</class-id> <category>aspects</category><body package="I18n-Tools">catalogsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^catalogsList isNil		ifTrue:			[catalogsList :=  MultiSelectionInList new.			catalogsList selectionIndexHolder compute:				[:v |				catalogsList selections isEmpty ifFalse: [					self selectedCatalog value: catalogsList selections first]].			catalogsList selectionHolder onChangeSend: #selectedCatalogChanged to: self.			catalogsList]		ifFalse:			[catalogsList]</body><body package="I18n-Tools">selectedCatalog	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	selectedCatalog isNil ifTrue: [selectedCatalog := nil asValue].	^selectedCatalog</body><body package="I18n-Tools">selectedCatalogChanged	self toolbar value: self privateToolbar.	self menu value: self privateMenu.	self catalogsListContextMenu value: self privateCatalogsListContextMenu</body></methods><methods><class-id>I18nCore.SourceFileCatalogWriter</class-id> <category>accessing</category><body package="I18n-Core">directoriesToIgnore	^directoriesToIgnore</body><body package="I18n-Core">directoriesToIgnore: anObject	directoriesToIgnore := anObject</body><body package="I18n-Core">errorChangeList	| list |	list := ChangeList new.	list changes addAll: self errorChanges.	list updateList.	^list</body><body package="I18n-Core">errorChanges	^errorChanges</body><body package="I18n-Core">errorChanges: anObject	errorChanges := anObject</body><body package="I18n-Core">handleReadingErrorsWhile: aBlock	aBlock on: MalformedSignal		do: 			[:ex |			('*&lt;st-source&gt;*' asIs match: ex messageText) ifTrue: [ex return].			ex getSignal = XML.BadCharacterSignal				ifTrue: 					[Transcript						cr;						show: #errBadCharacter &lt;&lt; #dialogs &gt;&gt; 'Bad character'.					ex resume].			ex pass]</body><body package="I18n-Core">openErrorChangeList	self errorChangeList open</body><body package="I18n-Core">parcelsToIgnore	^parcelsToIgnore</body><body package="I18n-Core">parcelsToIgnore: anObject	parcelsToIgnore := anObject</body><body package="I18n-Core">rootFolder	^rootFolder</body><body package="I18n-Core">rootFolder: anObject	rootFolder := anObject</body></methods><methods><class-id>I18nCore.SourceFileCatalogWriter</class-id> <category>private</category><body package="I18n-Core">addAllPstFilesIn: folder to: files	| file |	folder directoryContents do: 			[:each |			file := folder / each.			file isDirectory				ifTrue: 					[(self directoriesToIgnore includes: each)						ifFalse: [self addAllPstFilesIn: file to: files]]				ifFalse: [(self shouldParsePstFileNamed: each) ifTrue: [files add: file]]]</body><body package="I18n-Core">addUserMessagesInChange: change toCatalogs: catalogs	| tree |	tree := self parseTreeOfChange: change catalogs: catalogs.	UserMessageNodeFinder		addMessagesInTree: tree		fromMethod: change		toCatalogs: catalogs</body><body package="I18n-Core">catalogsWithUserMessagesInChangeFiles: files	| catalogs |	catalogs := Dictionary new.	files do: 			[:file |			Transcript				cr;				nextPutAll: ((#Scanning1s &lt;&lt; #i18n &gt;&gt; 'Scanning &lt;1s&gt;') expandMacrosWith: file asString);				flush.			self handleReadingErrorsWhile: 					[XML.SourceScannerNodeBuilder new scanFile: file						do: [:change | self addUserMessagesInChange: change toCatalogs: catalogs]]].	^catalogs</body><body package="I18n-Core">extractErrorsFromCatalogs: catalogs	errorChanges := OrderedCollection new.	catalogs		do: [:catalog | errorChanges addAll: catalog invalidMessagesAsChanges].</body><body package="I18n-Core">findFilesToParse	| files |	files := OrderedCollection new.	files add: self rootFolder / 'image' asIs / 'visual.sou' asIs.	self addAllPstFilesIn: self rootFolder to: files.	^files</body><body package="I18n-Core">parseTreeOfChange: change catalogs: catalogs	change isDefinition ifFalse: [^nil].	change type = #'method definition'		ifTrue: [^RBParser parseMethod: change text onError: [:aString :pos | ^nil]].	change type = #'shared variable definition'		ifTrue: 			[^RBParser parseExpression: change initializerText				onError: [:aString :pos | ^nil]].	^nil</body><body package="I18n-Core">shouldParsePstFileNamed: aString	^('*.pst' asIs match: aString)		and: [self parcelsToIgnore allSatisfy: [:each | (each match: aString) not]]</body><body package="I18n-Core">writeCatalogs: catalogs inFolder: directory	directory ensureDirectory.	(catalogs sorted: #name ascending) do: 			[:catalog |			Transcript				cr;				nextPutAll: (#writingCatalog1s &lt;&lt; #i18n &gt;&gt; 'writing catalog &lt;1s&gt;'							expandMacrosWith: catalog name);				flush.			catalog writeToFile: directory / catalog defaultLblFileName]</body></methods><methods><class-id>I18nCore.SourceFileCatalogWriter</class-id> <category>public</category><body package="I18n-Core">createCatalogsInto: directory	"	self openErrorChangeList.	"	| files catalogs |	files := self findFilesToParse.	catalogs := self catalogsWithUserMessagesInChangeFiles: files.	self writeCatalogs: catalogs inFolder: directory.	self extractErrorsFromCatalogs: catalogs</body></methods><methods><class-id>I18nCore.SourceFileCatalogWriter</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	directoriesToIgnore := #().	parcelsToIgnore := #().	rootFolder := '$(VISUALWORKS)' asIs asLogicalFileSpecification.	errorChanges := #().	^self</body></methods><methods><class-id>I18nCore.SourceFileCatalogWriter class</class-id> <category>instance creation</category><body package="I18n-Core">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>I18nCore.UserMessageCatalog</class-id> <category>problems</category><body package="I18n-Core">allProblems	| problems |	problems := OrderedCollection new.	self problemCreationSelectors		do: [:each | problems addAll: (self perform: each)].	^problems</body><body package="I18n-Core">allUserMessages	^self createProblemsOfClass: UserMessageInCatalog		whereMessagesMatch: [:each | true]</body><body package="I18n-Core">duplicateKeyUserMessages	| keysAndStrings nilKey duplicateKeysAndStrings duplicateUserMessages duplicateMessage |	nilKey := Object new.	keysAndStrings := Dictionary new.	self messages do: 			[:userMessage |			| key |			key := userMessage key ifNil: [nilKey].			(keysAndStrings at: key ifAbsentPut: [Set new])				add: userMessage defaultString].	keysAndStrings removeKey: nilKey ifAbsent: [].	duplicateKeysAndStrings := keysAndStrings select: [:each | each size &gt; 1].	duplicateUserMessages := OrderedCollection new.	duplicateKeysAndStrings keysAndValuesDo: 			[:key :strings |			duplicateMessage := (DuplicateKeyUserMessage new)						key: key;						catalog: self name;						yourself.			strings do: 					[:string |					| userMessage |					userMessage := UserMessage								defaultString: string								key: key								catalogID: self name.					(self methodsForMessage: userMessage)						do: [:method | duplicateMessage addMethod: method forString: string]].			duplicateUserMessages add: duplicateMessage].	^duplicateUserMessages</body><body package="I18n-Core">invalidKeyUserMessages	^self createProblemsOfClass: InvalidKeyMessage		whereMessagesMatch: 			[:each |			each key isNil or: [each key isEmpty or: [each key precedence ~= 1]]]</body><body package="I18n-Core">invalidUserMessages	^self createProblemsOfClass: InvalidCodeUserMessage		whereMessagesMatch: [:each | each isValid not]</body><body package="I18n-Core">problemCreationSelectors	^#(#duplicateKeyUserMessages #invalidKeyUserMessages #tooLongKeyUserMessages #invalidUserMessages)</body><body package="I18n-Core">tooLongKeyUserMessages	^self createProblemsOfClass: TooLongKeyMessage		whereMessagesMatch: [:each | each key notNil and: [each key size &gt; 53]]</body></methods><methods><class-id>I18nCore.UserMessageCatalog</class-id> <category>accessing</category><body package="I18n-Core">addMethod: aMethodDefinition forMessage: anUserMessage	(self messageMap at: anUserMessage ifAbsentPut: [Set new])		add: aMethodDefinition</body><body package="I18n-Core">createProblemsOfClass: class whereMessagesMatch: aBlock	| invalidMessages |	invalidMessages := self messages select: aBlock.	^invalidMessages collect: [:each | class forMessage: each inCatalog: self]</body><body package="I18n-Core">defaultLblFileName	^self name</body><body package="I18n-Core">invalidMessagesAsChanges	| errorMap changes |	errorMap := Dictionary new.	self allProblems		do: [:each | each addMethodsWithErrorToDictionary: errorMap].	changes := OrderedCollection new.	errorMap values do: 			[:changeWithErrors |			changes add: changeWithErrors errorCommentChange.			changes add: changeWithErrors change].	^changes</body><body package="I18n-Core">mergeWithCatalog: aCatalog	"aCatalog contains information about one particular method. I have to update my messages for this method."	| newMethodsToMessages newMessagesToMethods |	newMethodsToMessages := aCatalog reverseMessageMap.	newMessagesToMethods := Dictionary withAll: aCatalog messageMap.	self messageMap keysAndValuesDo: 			[:message :methods |			newMethodsToMessages keys do: [:each | methods remove: each ifAbsent: []]].	newMethodsToMessages keysAndValuesDo: 			[:method :messages |			messages do: 					[:message |					self messageMap at: message						ifPresent: 							[:methods |							methods add: method.							newMessagesToMethods removeKey: message]]].	newMessagesToMethods keysAndValuesDo: 			[:message :methods |			methods do: [:method | self addMethod: method forMessage: message]].	self messageMap keys do: 			[:key |			(self messageMap at: key) isEmpty ifTrue: [self messageMap removeKey: key]]</body><body package="I18n-Core">messageMap	^messageMap</body><body package="I18n-Core">messageMap: anObject	messageMap := anObject</body><body package="I18n-Core">messages	^self messageMap keys</body><body package="I18n-Core">methodsForMessage: aUserMessage	^self messageMap at: aUserMessage ifAbsent: [#()]</body><body package="I18n-Core">name	^name</body><body package="I18n-Core">name: anObject	name := anObject</body><body package="I18n-Core">removeMessagesInMethod: aMethodDefinition	| emptyMessages |	emptyMessages := Set new.	self messageMap keysAndValuesDo: 			[:message :methods |			methods remove: aMethodDefinition ifAbsent: [].			methods isEmpty ifTrue: [emptyMessages add: message]].	emptyMessages do: [:each | self messageMap removeKey: each]</body><body package="I18n-Core">reverseMessageMap	| dict |	dict := Dictionary new.	self messageMap keysAndValuesDo: 			[:message :methods |			methods				do: [:method | (dict at: method ifAbsentPut: [Set new]) add: message]].	^dict</body><body package="I18n-Core">validMessages	| problems matchingProblems validMessages message |	problems := self allProblems.	validMessages := Dictionary new.	self messages do: 			[:each |			matchingProblems := problems select: [:problem | each key = problem key].			(matchingProblems allSatisfy: #validForWritingCatalog)				ifTrue: 					[message := validMessages at: each key ifAbsentPut: [each].					message displayString &gt; each displayString						ifTrue: [validMessages at: each key put: each]]].	^validMessages</body></methods><methods><class-id>I18nCore.UserMessageCatalog</class-id> <category>comparing</category><body package="I18n-Core">= aCatalog	^self name = aCatalog name</body><body package="I18n-Core">hash	^self name hash</body></methods><methods><class-id>I18nCore.UserMessageCatalog</class-id> <category>catalog writing</category><body package="I18n-Core">withSortedKeysAndDefaultStringsDo: block	(self validMessages sorted: #key ascending) do: 			[:message |			| key string |			key := message key asString.			string := message defaultString ifNil: [message key asString].			block value: key value: string]</body><body package="I18n-Core">writeCatalogHeaderWithName: catalogName onCatalogStream: writeStream	writeStream		nextPutAll: 'encoding: #UTF_8' asIs;		cr.	writeStream		nextPutAll: 'catalog: ' asIs , catalogName asSymbol storeString;		cr;		cr;		cr</body><body package="I18n-Core">writeKey: key defaultString: defaultString onCatalogStream: writeStream	writeStream		nextPutAll: ('&lt;1s&gt; = &lt;2p&gt;&lt;n&gt;' asIs expandMacrosWith: key with: defaultString)</body><body package="I18n-Core">writeMessageToFile: baseFile	| catName ws lblFile |	catName := baseFile tail asSymbol.	lblFile := baseFile directory / (baseFile tail , '.lbl' asIs).	"#source defaults to UTF8 if BOM support is not loaded. 	Otherwise #source is defined as #autoDetectOrUTF8:UTF8WithBOM:"	ws := (lblFile withEncoding: #source) writeStream.		[ws lineEndTransparent.	self writeCatalogHeaderWithName: catName onCatalogStream: ws.	self withSortedKeysAndDefaultStringsDo: 			[:key :defaultString |			self writeKey: key defaultString: defaultString onCatalogStream: ws]]			ensure: [ws close]</body><body package="I18n-Core">writeToFile: baseFile	self writeMessageToFile: baseFile.	IndexedFileMessageCatalog compileCatalogIndexFor: baseFile</body></methods><methods><class-id>I18nCore.UserMessageCatalog</class-id> <category>testing</category><body package="I18n-Core">isValid	^self allProblems isEmpty</body></methods><methods><class-id>I18nCore.UserMessageCatalog</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	super initialize.	messageMap := Dictionary new</body></methods><methods><class-id>I18nCore.UserMessageCatalog class</class-id> <category>instance creation</category><body package="I18n-Core">named: aString	aString isNil ifTrue: [^UndefinedUserMessageCatalog new].	^(self new)		name: aString;		yourself</body><body package="I18n-Core">new	^super new initialize</body></methods><methods><class-id>I18nCore.UndefinedUserMessageCatalog</class-id> <category>accessing</category><body package="I18n-Core">defaultLblFileName	^'the null catalog' asIs</body><body package="I18n-Core">name	^self class catalogName</body></methods><methods><class-id>I18nCore.UndefinedUserMessageCatalog</class-id> <category>problems</category><body package="I18n-Core">problemCreationSelectors	^super problemCreationSelectors copyWith: #allUserMessages</body></methods><methods><class-id>I18nCore.UndefinedUserMessageCatalog class</class-id> <category>instance creation</category><body package="I18n-Core">catalogName		^'-undefined-' asIs</body><body package="I18n-Core">nilKey	^nilKey ifNil: [nilKey := Object new]</body></methods><methods><class-id>I18nCore.UndefinedUserMessageCatalog class</class-id> <category>class initialization</category><body package="I18n-Core">initialize	"initialize the nilKey"	self nilKey</body></methods><methods><class-id>I18nTools.MacroBuilder</class-id> <category>action</category><body package="I18n-Tools">convertSelection	(self rewriter)		convertConcatanationToMacroInNode: self findNode			inMethod: self selectedMethod;		applyChanges</body></methods><methods><class-id>I18nTools.MacroBuilder</class-id> <category>testing</category><body package="I18n-Tools">canBeApplied	^super canBeApplied and: [self isStringConcatanationSelected]</body><body package="I18n-Tools">isStringConcatanationSelected	| parts |	parts := self stringConcatanationPartsOfSelection.	^parts notEmpty</body></methods><methods><class-id>I18nTools.MacroBuilder</class-id> <category>accessing</category><body package="I18n-Tools">stringConcatanationPartsOfSelection	^self rewriter partsOfConcatanation: self findNode</body></methods><methods><class-id>I18nCore.UserMessageProblemWithMethods</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	methods := Set new.	^self</body></methods><methods><class-id>I18nCore.UserMessageProblemWithMethods</class-id> <category>accessing</category><body package="I18n-Core">allMethods	^self methods</body><body package="I18n-Core">methods	^methods</body><body package="I18n-Core">methods: anObject	methods := anObject</body></methods><methods><class-id>I18nCore.UserMessageProblemWithMethods class</class-id> <category>accessing</category><body package="I18n-Core">forMessage: each inCatalog: aCatalog	^(super forMessage: each inCatalog: aCatalog)		methods: (Set withAll: (aCatalog methodsForMessage: each));		yourself</body></methods><methods><class-id>I18nTools.ProblemNavigatorWithMethods</class-id> <category>accessing</category><body package="I18n-Tools">methodsOfSelectedProblem	^self selectedProblem ifNil: [#()] ifNotNil: #methods</body><body package="I18n-Tools">objectHighlightBlock	^#displayString</body><body package="I18n-Tools">problemContextMenu	^Menu new		augmentFrom: self class		to: ProblemNavigator		menuName: #problemMenu		for: self</body><body package="I18n-Tools">selectedProblemChanged	self methodListHolder value: self methodsOfSelectedProblem.	self searchStringHolder		value: ((Array with: (self selectedProblem						ifNotNil: [:each | self objectHighlightBlock value: each]))				select: [:each | each notNil and: [each notEmpty]])</body><body package="I18n-Tools">stringOfSelectedProblem	^self selectedProblem ifNil: ['' asIs] ifNotNil: #string</body></methods><methods><class-id>I18nTools.ProblemNavigatorWithMethods</class-id> <category>updating</category><body package="I18n-Tools">catalogCreationSelector	^self subclassResponsibility</body><body package="I18n-Tools">methodsOfProblem: problem	^problem methods</body><body package="I18n-Tools">objectsForMethods	| res |	res := Dictionary new.	self problems do: 			[:key |			key methods				do: [:method | (res at: method ifAbsentPut: [Set new]) add: key]].	^res</body><body package="I18n-Tools">updateExistingProblem: existingProblem withUpdatedProblem: updatedProblem inMethod: aMethodDefinition	updatedProblem isNil		ifTrue: 			[existingProblem methods remove: aMethodDefinition ifAbsent: [].			^self].	existingProblem methods addAll: updatedProblem methods</body><body package="I18n-Tools">updatedProblemsInCatalogs: catalogs i18nStrings: i18nStrings	^catalogs inject: Set new		into: 			[:set :catalog |			set				addAll: (catalog perform: self catalogCreationSelector);				yourself]</body></methods><methods><class-id>I18nTools.ProblemNavigatorWithMethods</class-id> <category>interface opening</category><body package="I18n-Tools">connectAspects	self problemList		refreshList: (self problems sorted: #displayString ascending)</body><body package="I18n-Tools">problemList	problemList isNil ifTrue: [problemList := SelectionInList new].	^problemList</body></methods><methods><class-id>I18nTools.ProblemNavigatorWithMethods</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self problemList selectionHolder onChangeSend: #selectedProblemChanged		to: self.	^self</body><body package="I18n-Tools">selectedProblem	^self problemList selection</body></methods><methods><class-id>I18nTools.ProblemNavigatorWithMethods</class-id> <category>testing</category><body package="I18n-Tools">hasSelection	^self selectedProblem notNil</body></methods><methods><class-id>I18nTools.UserMessageProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">objectHighlightBlock	^	[:each |	| selector |	selector := #(#defaultString #key #catalog) detect: 					[:sel |					| string |					string := each perform: sel.					string notNil and: [string notEmpty]]				ifNone: [#displayString].	each perform: selector]</body><body package="I18n-Tools">windowLabel	self problems do: 			[:each |			^#UserMessagesForCatalog1s_ &lt;&lt; #i18n &gt;&gt; 'UserMessages for catalog: &lt;1s&gt;'				expandMacrosWith: each catalog].	^#UserMessages &lt;&lt; #i18n &gt;&gt; 'User Messages'</body></methods><methods><class-id>I18nTools.UserMessageProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">catalogCreationSelector	^#allUserMessages</body></methods><methods><class-id>I18nTools.CatalogItem</class-id> <category>accessing</category><body package="I18n-Tools">catalog	^catalog</body><body package="I18n-Tools">catalog: anObject	catalog := anObject</body><body package="I18n-Tools">name	^self catalog name</body><body package="I18n-Tools">numberOfDefinedKeys	^self catalog messages size</body><body package="I18n-Tools">numberOfDefinedKeysText	^self numberOfDefinedKeys printString</body><body package="I18n-Tools">numberOfProblems	^self catalog allProblems size</body><body package="I18n-Tools">numberOfProblemsText	^self textForInvalidNumber: self numberOfProblems</body></methods><methods><class-id>I18nTools.CatalogItem</class-id> <category>comparing</category><body package="I18n-Tools">= aCatalogItem	^self class = aCatalogItem class		and: [self catalog = aCatalogItem catalog]</body><body package="I18n-Tools">hash	^self catalog hash</body></methods><methods><class-id>I18nTools.CatalogItem</class-id> <category>testing</category><body package="I18n-Tools">isValid	^self catalog isValid</body></methods><methods><class-id>I18nTools.CatalogItem</class-id> <category>printing</category><body package="I18n-Tools">textForInvalidNumber: number	| resultText |	resultText := number printString asText.	number &gt; 0		ifTrue: [resultText emphasizeAllWith: #(#bold #red)].	^resultText</body></methods><methods><class-id>I18nTools.CatalogItem class</class-id> <category>instance creation</category><body package="I18n-Tools">forCatalog: aCatalog	^(self new)		catalog: aCatalog;		yourself</body></methods><methods><class-id>I18nTools.MissingI18nProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">catalogCreationSelector	^self shouldNotImplement</body><body package="I18n-Tools">updatedProblemsInCatalogs: catalogs i18nStrings: i18nStrings	^i18nStrings</body></methods><methods><class-id>I18nTools.MissingI18nProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">convertString: string toNonI18nStringIn: methods	(I18nRewriter new)		markString: string asNonI18nInMethods: methods;		browseChanges</body><body package="I18n-Tools">convertString: string toUsermessagesIn: methods	| userMessage |	userMessage := UserMessageCreationDialog userMessageForString: string.	userMessage isNil ifTrue: [^self].	(I18nRewriter new)		convertString: string toUserMessage: userMessage inMethods: methods;		browseChanges</body><body package="I18n-Tools">objectHighlightBlock	^[:each | each string printString].</body><body package="I18n-Tools">windowLabel	^#MissingInternationalization &lt;&lt; #i18n &gt;&gt; 'Missing Internationalization'</body></methods><methods><class-id>I18nTools.NoProblemNavigator</class-id> <category>testing</category><body package="I18n-Tools">hasSelection	^false</body></methods><methods><class-id>I18nTools.NoProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">methodsOfProblem: problem	^#()</body><body package="I18n-Tools">objectsForMethods	^Dictionary new</body><body package="I18n-Tools">updateExistingProblem: existingProblem withUpdatedProblem: updatedProblem inMethod: aMethodDefinition	self shouldNotImplement</body></methods><methods><class-id>I18nTools.NoProblemNavigator</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize		super initialize.	problems := #()</body></methods><methods><class-id>I18nTools.NoProblemNavigator</class-id> <category>interface opening</category><body package="I18n-Tools">connectAspects</body></methods><methods><class-id>I18nTools.NoProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">windowLabel	^#NoProblems &lt;&lt; #i18n &gt;&gt; 'No Problems'</body></methods><methods><class-id>I18nCore.MissingI18nStringNodeFinder</class-id> <category>processing</category><body package="I18n-Core">searchForNodesIn: aTree	"find all strings and then remove all the strings that are part of a user message"	| messageNodesAndResults filteredNodesAndResults stringNodesAndResults |	stringNodesAndResults := self nodesAndResultsInTree: aTree.	messageNodesAndResults := UserMessageNodeFinder new				nodesAndResultsInTree: aTree.	filteredNodesAndResults := self filterOutSubResults: ((Set new)						addAll: messageNodesAndResults;						addAll: stringNodesAndResults;						yourself).	^filteredNodesAndResults select: [:each | each wasFoundBy: self]</body></methods><methods><class-id>I18nCore.MissingI18nStringNodeFinder class</class-id> <category>utility</category><body package="I18n-Core">keyForValueNode: aNode inArrayNode: anArrayNode	"consider a literal array like: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 838 266 1082 775 ) ) 	aNode would be the node for 'Unlabled Canvas' and anArrayNode is the node for the whole array.	returns the value of the node before aNode - #label: in that case.	returns nil in case aNode is not found or does not have a sibling before it"	| siblingNodes index |	siblingNodes := anArrayNode children.	index := siblingNodes indexOf: aNode.	index &lt; 2 ifTrue: [^nil].	^(siblingNodes at: index - 1) value</body></methods><methods><class-id>I18nTools.InvalidKeyProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">objectHighlightBlock	^[:each | each key ifNil: [each defaultString]]</body><body package="I18n-Tools">windowLabel	^#InvalidKeyFinder &lt;&lt; #i18n &gt;&gt; 'Invalid Key Finder'</body></methods><methods><class-id>I18nTools.InvalidKeyProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">catalogCreationSelector	^#invalidKeyUserMessages</body></methods><methods><class-id>I18nCore.MethodFilterMissingI18n</class-id> <category>private</category><body package="I18n-Core">privateSelectClass: aClass selector: sel method: method	^(self shouldCheckSelector: sel inClass: aClass)		and: [(MissingI18nStringNodeFinder findInMethod: method) notEmpty]</body><body package="I18n-Core">shouldCheckSelector: sel inClass: aClass	^aClass i18nSelectorsToIgnore allSatisfy: [:each | (each match: sel) not]</body></methods><methods><class-id>I18nCore.MethodFilterMissingI18n</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>I18nCore.MethodFilterMissingI18n</class-id> <category>ordering</category><body package="I18n-Core">priority	"low means high priority. Higher priority filters are evaluated before the lower.	The longer a filter takes and the less it reduces the resulting collection, the lower the priority should be.	selector-filter has a pretty high priority, as do #and and #or filters"	^15</body></methods><methods><class-id>I18nCore.MethodFilterMissingI18n</class-id> <category>printing</category><body package="I18n-Core">displayString	^#_hasMissingUserMessages &lt;&lt; #i18n &gt;&gt; ' has missing user messages'</body></methods><methods><class-id>I18nCore.MethodFilterMissingI18n class</class-id> <category>instance creation</category><body package="I18n-Core">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>I18nTools.InvalidCodeUserMessageProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">catalogCreationSelector	^#invalidUserMessages</body></methods><methods><class-id>I18nTools.InvalidCodeUserMessageProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">windowLabel	^#InvalidUserMessages &lt;&lt; #i18n &gt;&gt; 'Invalid User Messages'</body></methods><methods><class-id>I18nCore.UserMessageInCatalog</class-id> <category>accessing</category><body package="I18n-Core">catalog	^catalog</body><body package="I18n-Core">catalog: anObject	catalog := anObject</body><body package="I18n-Core">defaultString	^defaultString</body><body package="I18n-Core">defaultString: anObject	defaultString := anObject</body><body package="I18n-Core">errorDescription	^#userMessageWithoutCatalogMacro &lt;&lt; #i18n &gt;&gt; '&lt;1p&gt; &gt;&gt; &lt;2p&gt;'		expandMacrosWith: self key		with: self defaultString</body><body package="I18n-Core">errorName	UndefinedUserMessageCatalog catalogName = self catalog		ifTrue: [^#NoCatalog &lt;&lt; #i18n &gt;&gt; 'No Catalog'].	^#AllMessages &lt;&lt; #i18n &gt;&gt; 'All Messages'</body><body package="I18n-Core">key	^key</body><body package="I18n-Core">key: anObject	key := anObject</body></methods><methods><class-id>I18nCore.UserMessageInCatalog</class-id> <category>comparing</category><body package="I18n-Core">= anUserMessageInCatalog	^super = anUserMessageInCatalog and: 			[self key = anUserMessageInCatalog key and: 					[self catalog = anUserMessageInCatalog catalog						and: [self defaultString = anUserMessageInCatalog defaultString]]]</body><body package="I18n-Core">hash	^self key hash</body><body package="I18n-Core">validForWritingCatalog	^true</body></methods><methods><class-id>I18nCore.UserMessageInCatalog</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	super initialize.	key := #''.	defaultString := '' asIs.	catalog := #''.	^self</body></methods><methods><class-id>I18nCore.UserMessageInCatalog</class-id> <category>printing</category><body package="I18n-Core">displayString	| string |	string := self defaultString				ifNil: [#nilDefaultString &lt;&lt; #i18n &gt;&gt; '-nil-'].	^self catalog isNil		ifTrue: 			[#userMessageWithoutCatalogMacro1 &lt;&lt; #i18n &gt;&gt; '&lt;1p&gt; &gt;&gt; &lt;2s&gt;'				expandMacrosWith: self key				with: string]		ifFalse: 			[#userMessageMacro &lt;&lt; #i18n &gt;&gt; '&lt;1p&gt; &gt;&gt; &lt;2s&gt; %&lt;%&lt; &lt;3p&gt;'				expandMacrosWith: self key				with: string				with: self catalog]</body></methods><methods><class-id>I18nCore.UserMessageInCatalog class</class-id> <category>accessing</category><body package="I18n-Core">forMessage: each inCatalog: aCatalog	^(super forMessage: each inCatalog: aCatalog)		key: each key;		catalog: aCatalog name;		defaultString: each defaultString;		yourself</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">methodsOfProblem: problem	^problem strings inject: Set new		into: 			[:set :string |			set				addAll: (problem methodsForString: string);				yourself]</body><body package="I18n-Tools">objectsForMethods	| res |	res := Dictionary new.	self problems do: 			[:key |			key strings do: 					[:string |					(key methodsForString: string)						do: [:method | (res at: method ifAbsentPut: [Set new]) add: key]]].	^res</body><body package="I18n-Tools">updateExistingProblem: existingProblem withUpdatedProblem: updatedProblem inMethod: aMethodDefinition	| stringsToRemove removedStrings |	updatedProblem isNil		ifTrue: 			[stringsToRemove := Set new.			existingProblem strings do: 					[:string |					existingProblem removeMethod: aMethodDefinition forString: string.					(existingProblem hasMethodsForString: string)						ifTrue: [stringsToRemove add: string]].			stringsToRemove do: [:string | existingProblem removeString: string]]		ifFalse: 			[updatedProblem stringsWithMethods keysAndValuesDo: 					[:string :methods |					methods						do: [:method | existingProblem addMethod: method forString: string].					removedStrings := existingProblem strings								reject: [:each | updatedProblem strings includes: each].					removedStrings						do: [:each | existingProblem stringsWithMethods removeKey: each]]]</body><body package="I18n-Tools">updatedProblemsInCatalogs: catalogs i18nStrings: i18nStrings	^catalogs inject: Set new		into: 			[:set :catalog |			set				addAll: catalog duplicateKeyUserMessages;				yourself]</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">selectedKey	^self keysList selection</body><body package="I18n-Tools">selectedString	^self stringsList selection</body><body package="I18n-Tools">windowLabel	^#KeyCollisionFinder &lt;&lt; #i18n &gt;&gt; 'Key Collision Finder'</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize	super initialize.	self keysList selectionHolder onChangeSend: #selectedKeyChanged to: self.	self stringsList selectionHolder onChangeSend: #selectedStringChanged to: self.</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id> <category>interface opening</category><body package="I18n-Tools">connectAspects	self keysList		refreshList: (self problems sorted: #key ascending , #catalog ascending).	self selectedKeyChanged.</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id> <category>aspects</category><body package="I18n-Tools">keysList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^keysList isNil		ifTrue:			[keysList := SelectionInList new]		ifFalse:			[keysList]</body><body package="I18n-Tools">stringsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^stringsList isNil		ifTrue:			[stringsList := SelectionInList new]		ifFalse:			[stringsList]</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id> <category>changing</category><body package="I18n-Tools">selectedKeyChanged	self stringsList		refreshList: (self keysList selection ifNil: [#()] ifNotNil: #strings) sorted</body><body package="I18n-Tools">selectedStringChanged	self methodListHolder value: (self selectedKey				ifNil: [#()]				ifNotNil: [:key | key methodsForString: self selectedString]).	self searchStringHolder		value: ((Array with: self selectedString) select: #notNil)</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator</class-id> <category>testing</category><body package="I18n-Tools">hasSelection	^self selectedString notNil</body></methods><methods><class-id>I18nCore.NodeWithObject</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	node := nil.	object := nil.	finder := nil.	^self</body></methods><methods><class-id>I18nCore.NodeWithObject</class-id> <category>accessing</category><body package="I18n-Core">finder	^finder</body><body package="I18n-Core">finder: anObject	finder := anObject</body><body package="I18n-Core">node	^node</body><body package="I18n-Core">node: anObject	node := anObject</body><body package="I18n-Core">object	^object</body><body package="I18n-Core">object: anObject	object := anObject</body><body package="I18n-Core">start	^self node start</body><body package="I18n-Core">stop	^self node stop</body></methods><methods><class-id>I18nCore.NodeWithObject</class-id> <category>testing</category><body package="I18n-Core">enclosesNode: aNode	^self start &lt;= aNode start and: [self stop &gt;= aNode stop]</body><body package="I18n-Core">wasFoundBy: aFinder	^aFinder = self finder</body></methods><methods><class-id>I18nCore.NodeWithObject</class-id> <category>printing</category><body package="I18n-Core">printOn: aStream	super printOn: aStream.	aStream		space;		print: self object;		nextPutAll: ' &lt;== ' asIs;		print: self node;		nextPutAll: ' (' asIs;		print: (self start to: self stop);		nextPut: $)</body></methods><methods><class-id>I18nCore.NodeWithObject class</class-id> <category>instance creation</category><body package="I18n-Core">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="I18n-Core">node: node object: object finder: finder	^(self new)		node: node;		object: object;		finder: finder;		yourself</body></methods><methods><class-id>I18nTools.I18nPatchChangeList</class-id> <category>fileIn/Out</category><body package="I18n-Tools">scanFile: aFileStream	"Obtain changes from aFileStream.  Depending on the checkSystem mode	 either read in all changes, or only changes which differ in source or code."	| rawChanges | 	rawChanges := OrderedCollection new.	(aFileStream isExternalStream and: [aFileStream fileName hasSourceExtension])		ifTrue: [aFileStream lineEndTransparent].	Cursor read showWhile: 			[			[ChangeScanner new scanFile: aFileStream				do: 					[:change |					(nil == checkSystem or: [(change sameAsSystem: self) not])						ifTrue: 							[rawChanges								add: (change isDefinition ifTrue: [change asI18nChange] ifFalse: [change])]]]					ensure: [aFileStream close]].	self parseChanges: rawChanges.</body></methods><methods><class-id>I18nTools.I18nPatchChangeList</class-id> <category>accessing</category><body package="I18n-Tools">changes: aSequenceOfChanges	changes := aSequenceOfChanges asList.	self updateList.</body><body package="I18n-Tools">value: aValue	"The receiver's text for the currently selected change (if any) has 	changed. Update the text view, and update the change's text."	| thisChange |	value := aValue.	self changed: #value.	(value size &gt; 0 and: [selectionIndex &gt; 0])		ifTrue: 			[thisChange := list at: selectionIndex.			thisChange text ~= value asString				ifTrue: 					[thisChange text: value asString.					self updateSelection: selectionIndex]]</body></methods><methods><class-id>I18nTools.I18nPatchChangeList</class-id> <category>aspects</category><body package="I18n-Tools">relativesFilterAdaptor	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: 7]		putBlock: [:m :v | m switchFilter: 7 perform: #isRelatedTo:]		updateBlock: [:m :a :p | a == #filter and: [p = 7]]</body></methods><methods><class-id>I18nTools.I18nPatchChangeList</class-id> <category>private</category><body package="I18n-Tools">addFilter: aSymbol 	"Override to handle isRelatedTo:'s argument"	| filterKeyValue oldFilter |	aSymbol ~~ #isRelatedTo: ifTrue: [^super addFilter: aSymbol].	selectionIndex &gt; 0		ifTrue: [filterKeyValue := list at: selectionIndex]		ifFalse: [^self].	filter isNil		ifTrue: [filter := [:change | filterKeyValue isRelatedTo: change]]		ifFalse: 			[oldFilter := filter.			filter := [:change | (filterKeyValue isRelatedTo: change) and: [oldFilter value: change]]]</body><body package="I18n-Tools">filterTemplates	"return the templates for the filters"	^#(	#( filterByFile filterByType filterByClass filterByProtocol filterBySelector filterBySame filterByRelative )		#( fileName type className category selector values isRelatedTo:))</body><body package="I18n-Tools">listEntryForChange: aChange	"Return the string to display in the list for the supplied change.	 This depends on the showing filters."	| entry |	entry := super listEntryForChange: aChange.	(aChange isDefinition and: [aChange isModified]) ifTrue: [entry := '*', entry].	^entry</body><body package="I18n-Tools">parseChanges: aCollection	| parseStream |	parseStream := ReadStream on: aCollection.	changes := List new.	[parseStream atEnd] whileFalse: 			[| change errors |			change := parseStream next.			((change isKindOf: OtherChange) and: [change type = #comment])				ifTrue: 					[| errorStream |					errors := Set new.					errorStream := change text readStream.					[errorStream atEnd] whileFalse: 							[errors add: (errorStream upTo: Character cr) trimBlanks]].			(change isKindOf: I18nMethodDefinitionChange)				ifTrue: 					[change errors: errors.					changes add: change]]</body></methods><methods><class-id>I18nTools.I18nPatchChangeList</class-id> <category>testing</category><body package="I18n-Tools">hasModifications	^self changes contains: [:any | any isDefinition and: [any isModified]]</body></methods><methods><class-id>I18nTools.I18nPatchChangeList</class-id> <category>actions</category><body package="I18n-Tools">selectNextChangeContainingString	| string |	string := Dialog				request: (#SelectNextChangeContainingString &lt;&lt; #i18n &gt;&gt; 'Select next change containing string')				initialAnswer: (lastTextSearch isNil ifTrue: [''] ifFalse: [lastTextSearch]).	string isEmpty ifTrue: [^self].	lastTextSearch := string.	string := '*', string, '*'.	selectionIndex + 1 to: list size do:		[:i|		(string match: (list at: i) text) ifTrue:			[self toggleListIndex: i.			 self updateSelection: i.			 (builder componentAt: #listView) widget makeVisible: i.			 ^self]]</body></methods><methods><class-id>I18nTools.UserMessageCreationDialog</class-id> <category>initialize-release</category><body package="I18n-Tools">initWithDefaultString: aString	self defaultString value: aString.	self key value: aString asUserMessageKey.	self catalog value: self lastUsedCatalog</body><body package="I18n-Tools">initialize	super initialize.	self key onChangeSend: #validateUserMessage to: self.	self catalog onChangeSend: #validateUserMessage to: self</body><body package="I18n-Tools">isProperSymbol: aString	^aString notEmpty and: [Scanner isLiteralSymbol: aString asSymbol]</body><body package="I18n-Tools">validateUserMessage	| okButton |	okButton := self widgetAt: #ok.	okButton isNil ifTrue:[^self].	okButton isEnabled: ((self isProperSymbol: self key value)				and: [self isProperSymbol: self catalog value])</body></methods><methods><class-id>I18nTools.UserMessageCreationDialog</class-id> <category>interface opening</category><body package="I18n-Tools">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self validateUserMessage.	(self widgetAt: #key) controller continuousAccept: true.	(self widgetAt: #catalog) controller continuousAccept: true</body></methods><methods><class-id>I18nTools.UserMessageCreationDialog</class-id> <category>aspects</category><body package="I18n-Tools">catalog	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^catalog isNil ifTrue: [catalog := '' asIs asValue] ifFalse: [catalog]</body><body package="I18n-Tools">defaultString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^defaultString isNil		ifTrue:			[defaultString := String new asValue]		ifFalse:			[defaultString]</body><body package="I18n-Tools">key	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^key isNil		ifTrue:			[key := '' asIs asValue]		ifFalse:			[key]</body><body package="I18n-Tools">lastUsedCatalog	^LastUsedCatalog ifNil: ['' asIs]</body><body package="I18n-Tools">lastUsedCatalog: aString	^LastUsedCatalog := aString</body></methods><methods><class-id>I18nTools.UserMessageCreationDialog</class-id> <category>interface specs</category><body package="I18n-Tools">rememberCatalog	self lastUsedCatalog: self catalog value</body></methods><methods><class-id>I18nTools.UserMessageCreationDialog</class-id> <category>i18n</category><body package="I18n-Tools">userMessage	^UserMessage		defaultString: self defaultString value asString		key: self key value asSymbol		catalogID: self catalog value asSymbol</body></methods><methods><class-id>I18nTools.UserMessageCreationDialog class</class-id> <category>interface specs</category><body package="I18n-Tools">userMessageForString: aString	| dialog |	dialog := self new.	dialog initWithDefaultString: aString.	dialog open		ifTrue: 			[dialog rememberCatalog.			^dialog userMessage].	^nil</body></methods><methods><class-id>I18nCore.MethodFilterAnyUserMessage</class-id> <category>private</category><body package="I18n-Core">matchUserMessage: aUserMessage	^true</body><body package="I18n-Core">privateSelectClass: aClass selector: sel method: method	^(UserMessageNodeFinder findInMethod: method)		anySatisfy: [:each | self matchUserMessage: each]</body></methods><methods><class-id>I18nCore.MethodFilterAnyUserMessage</class-id> <category>printing</category><body package="I18n-Core">displayString	^#hasAUserMessage &lt;&lt; #i18n &gt;&gt; 'has a UserMessage'</body></methods><methods><class-id>I18nCore.MethodFilterAnyUserMessage</class-id> <category>ordering</category><body package="I18n-Core">priority	"a number close to 0 means high priority. Higher priority filters are evaluated before the lower.	The longer a filter takes and the less it reduces the resulting collection, the lower the priority should be.	selector-filter has a pretty high priority, as do #and and #or filters"	^15</body></methods><methods><class-id>I18nTools.TooLongKeyProblemNavigator</class-id> <category>accessing</category><body package="I18n-Tools">windowLabel	^#TooLongKeyFinder &lt;&lt; #i18n &gt;&gt; 'Too Long Key Finder'</body></methods><methods><class-id>I18nTools.TooLongKeyProblemNavigator</class-id> <category>updating</category><body package="I18n-Tools">catalogCreationSelector	^#tooLongKeyUserMessages</body></methods><methods><class-id>I18nCore.MissingI18nString</class-id> <category>accessing</category><body package="I18n-Core">errorDescription	self shouldNotImplement</body><body package="I18n-Core">errorName	^#MissingI18n &lt;&lt; #i18n &gt;&gt; 'Missing I18n'</body><body package="I18n-Core">string	^string</body><body package="I18n-Core">string: anObject	string := anObject</body></methods><methods><class-id>I18nCore.MissingI18nString</class-id> <category>comparing</category><body package="I18n-Core">= anI18nString	^super = anI18nString and: [self string = anI18nString string]</body><body package="I18n-Core">hash	^self string hash</body></methods><methods><class-id>I18nCore.MissingI18nString</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	string := '' asIs.	^self</body></methods><methods><class-id>I18nCore.MissingI18nString</class-id> <category>printing</category><body package="I18n-Core">displayString	^self string</body></methods><methods><class-id>I18nCore.MissingI18nString class</class-id> <category>instance creation</category><body package="I18n-Core">named: aString	^(self new)		string: aString;		yourself</body></methods><methods><class-id>I18nTools.I18nErrorBrowser</class-id> <category>accessing</category><body package="I18n-Tools">changeView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^changeView isNil		ifTrue:			[changeView := I18nPatchChangeList new]		ifFalse:			[changeView]</body><body package="I18n-Tools">changes	^self keyedErrors values inject: OrderedCollection new		into: [:sofar :value | sofar addAll: value; yourself]</body><body package="I18n-Tools">keyedErrors	^keyedErrors</body><body package="I18n-Tools">patchesDirectory	^patchDirectory asString</body><body package="I18n-Tools">patchesDirectory: aString	patchDirectory := aString asLogicalFileSpecification</body></methods><methods><class-id>I18nTools.I18nErrorBrowser</class-id> <category>notification</category><body package="I18n-Tools">hasModifications	^self changeView hasModifications</body><body package="I18n-Tools">updateChangeList	self changeView  changes: (keyedErrors at: self changeList selection ifAbsent:[#()]) asList.</body></methods><methods><class-id>I18nTools.I18nErrorBrowser</class-id> <category>interface opening</category><body package="I18n-Tools">openOn: aSequenceOfChanges	"Open up the receiver on the given set of changes."	self changes: aSequenceOfChanges.	self open</body></methods><methods><class-id>I18nTools.I18nErrorBrowser</class-id> <category>private</category><body package="I18n-Tools">changes: aSequenceOfChanges	keyedErrors := Dictionary new.	aSequenceOfChanges do: 			[:errorChange |			errorChange errors				do: [:error | (keyedErrors at: error ifAbsentPut: [Set new]) add: errorChange]].	self changeList list: keyedErrors keys asSortedCollection asList</body><body package="I18n-Tools">merge: existingFile with: updates to: newFile	| rs scs updateLookup |	updates isEmpty ifTrue: [^existingFile copyTo: newFile].	updateLookup := Dictionary new.	updates do: [:change| updateLookup at: change checkingName put: change].	existingFile exists ifTrue:		[rs := (existingFile withEncoding: #Source) readStream.		 [rs lineEndTransparent.		  ChangeScanner new			scanFile: rs			do: [:aChange |				(updateLookup includesKey: aChange checkingName) ifFalse:					[updates add: aChange asI18nChange]]]			ensure: [rs close]].	scs := SourceCodeStream write: newFile.	[(self sortChanges: updates) do:		[:change| change fileOutOn: scs].	scs checkMethodChunkClass: nil protocol: nil]		ensure: [scs close]</body><body package="I18n-Tools">nextPatchFileDirectory	| npfd index value |	(npfd := self patchesDirectory) isEmpty ifTrue: [^nil].	index := npfd size.	[(npfd at: index) isDigit and: [index &gt; 0]]		whileTrue:			[index := index - 1].	index = npfd size ifTrue: [^nil].	value := Integer readFrom: (ReadStream on: npfd from: index + 1 to: npfd size).	^(npfd copyFrom: 1 to: index), (value + 1) printString</body><body package="I18n-Tools">patchFileForFileName: fileName	^patchDirectory construct: (fileName tail									copyReplaceAll: fileName extension									with: '.st')</body><body package="I18n-Tools">sortChanges: aCollectionOfChanges	^aCollectionOfChanges asSortedCollection:		[:a :b| | fa fb sf |		fa := a file.		fb := b file.		fa = fb			ifTrue: [a checkingName &lt; b checkingName]			ifFalse:				[sf := SourceFileManager default fileAt: 1.				fa = sf				or: [fb ~= sf				and: [fa displayString &lt; fb displayString]]]]</body></methods><methods><class-id>I18nTools.I18nErrorBrowser</class-id> <category>aspects</category><body package="I18n-Tools">changeList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^changeList isNil		ifTrue:			[changeList := SelectionInList new]		ifFalse:			[changeList]</body></methods><methods><class-id>I18nTools.I18nErrorBrowser</class-id> <category>actions</category><body package="I18n-Tools">scanFilename	self changeView scanFilename.	self changes: self changeView changes.</body><body package="I18n-Tools">updatePatches	| allPatchFiles updatesByFile npfd updates |	allPatchFiles := (patchDirectory filesMatching: '*.st') asSet collect: [:ea| ea asLogicalFileSpecification].	npfd := self nextPatchFileDirectory asFilename.	npfd ensureDirectory.	updates := self changes select: [:ea| ea isDefinition and: [ea isModified]].	updatesByFile := Dictionary new.	updates do:		[:change|		(updatesByFile			at: (allPatchFiles add: (self patchFileForFileName: change originalFile fileName))			ifAbsentPut: [Set new]) add: change].	allPatchFiles do:		[:patchFile|		self merge: patchFile with: (updatesByFile at: patchFile ifAbsent: [#()]) to: (npfd construct: patchFile tail)].	patchDirectory := npfd</body></methods><methods><class-id>I18nTools.I18nErrorBrowser</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize	super initialize.	patchDirectory := 'i18n-patches0' asLogicalFileSpecification.</body></methods><methods><class-id>I18nCore.InvalidKeyMessage</class-id> <category>comparing</category><body package="I18n-Core">= anInvalidKeyMessage	^self class = anInvalidKeyMessage class and: 			[self catalog = anInvalidKeyMessage catalog and: 					[self defaultString = anInvalidKeyMessage defaultString						and: [self key = anInvalidKeyMessage key]]]</body><body package="I18n-Core">hash	^self defaultString hash</body></methods><methods><class-id>I18nCore.InvalidKeyMessage</class-id> <category>accessing</category><body package="I18n-Core">catalog	^catalog</body><body package="I18n-Core">catalog: anObject	catalog := anObject</body><body package="I18n-Core">defaultString	^defaultString</body><body package="I18n-Core">defaultString: anObject	defaultString := anObject</body><body package="I18n-Core">errorDescription	^self key printString</body><body package="I18n-Core">errorName	^#IllegalKey &lt;&lt; #i18n &gt;&gt; 'Illegal Key'</body><body package="I18n-Core">key	^key</body><body package="I18n-Core">key: anObject	key := anObject</body></methods><methods><class-id>I18nCore.InvalidKeyMessage</class-id> <category>printing</category><body package="I18n-Core">displayString	^#userMessageDisplayStringMacro &lt;&lt; #i18n &gt;&gt; '&lt;1p&gt; &gt;&gt; &lt;3p&gt; %&lt;%&lt; &lt;2p&gt;'		expandMacrosWith: self key		with: self catalog		with: self defaultString</body></methods><methods><class-id>I18nCore.InvalidKeyMessage</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	defaultString := '' asIs.	catalog := #''.	key := nil.	^self</body></methods><methods><class-id>I18nCore.InvalidKeyMessage class</class-id> <category>accessing</category><body package="I18n-Core">forMessage: each inCatalog: aCatalog	^(super forMessage: each inCatalog: aCatalog)		key: each key;		catalog: aCatalog name;		defaultString: each defaultString;		yourself</body></methods><methods><class-id>I18nCore.TooLongKeyMessage</class-id> <category>accessing</category><body package="I18n-Core">errorName	^#TooLongKey &lt;&lt; #i18n &gt;&gt; 'Too Long Key'</body></methods><methods><class-id>I18nCore.I18nFinder class</class-id> <category>finding</category><body package="I18n-Core">findAllCatalogs	| methods |	methods := self				allMethodsFilteredBy: [:methodCollector | methodCollector hasUserMessage].	^self userMessageCatalogsInMethods: methods</body><body package="I18n-Core">findAllI18nStrings	| methods |	methods := self				allMethodsFilteredBy: [:methodCollector | methodCollector hasMissingI18nStrings].	^self missingI18nStringsInMethods: methods</body><body package="I18n-Core">findAllI18nStringsInBundle: aBundle	| methods |	methods := self allMethodsFilteredBy: 					[:methodCollector |					(methodCollector bundle: aBundle)						&amp; methodCollector hasMissingI18nStrings].	^self missingI18nStringsInMethods: methods</body><body package="I18n-Core">findAllI18nStringsInPackage: aPackage	| methods |	methods := self allMethodsFilteredBy: 					[:methodCollector |					(methodCollector package: aPackage)						&amp; methodCollector hasMissingI18nStrings].	^self missingI18nStringsInMethods: methods</body></methods><methods><class-id>I18nCore.I18nFinder class</class-id> <category>private</category><body package="I18n-Core">allMethodsFilteredBy: filterCreationBlock	| methods methodCollector |	methods := Set new.	methodCollector := MethodCollector new.	Notice		showProgress: #searchingForMethodsWithUserMessages &lt;&lt; #i18n				&gt;&gt; 'searching for methods with user messages'		complete: Metaclass allInstances size * 2		while: 			[methods addAll: (methodCollector						select: (filterCreationBlock value: methodCollector))].	^methods</body><body package="I18n-Core">missingI18nStringsInMethods: methods	| i18nString missingStrings |	missingStrings := Dictionary new.	self withMethods: methods		do: 			[:methodDefinition |			(MissingI18nStringNodeFinder findInMethod: methodDefinition method) do: 					[:string |					i18nString := missingStrings at: string								ifAbsentPut: [MissingI18nString named: string].					i18nString methods add: methodDefinition]].	^missingStrings values</body><body package="I18n-Core">userMessageCatalogsInMethods: methodDefinitions	| catalogs tree |	catalogs := Dictionary new.	self withMethods: methodDefinitions		do: 			[:methodDefinition |			tree := UserMessageNodeFinder parseTreeOfMethod: methodDefinition method.			UserMessageNodeFinder				addMessagesInTree: tree				fromMethod: methodDefinition				toCatalogs: catalogs].	^catalogs values</body><body package="I18n-Core">withMethods: methods do: aBlock	Notice		showProgress: #CollectingCatalogsFromMethods &lt;&lt; #i18n				&gt;&gt; 'Collecting Catalogs from Methods'		complete: methods size		while: 			[methods do: 					[:methodDefinition |					IncrementNotification raiseSignal.					aBlock value: methodDefinition]]</body></methods><methods><class-id>I18nTools.ProblemViewer</class-id> <category>accessing</category><body package="I18n-Tools">browser	^browser</body><body package="I18n-Tools">browser: anObject	browser := anObject</body><body package="I18n-Tools">buildMethodObjectCache		methodsObjectCache := self problemNavigator objectsForMethods</body><body package="I18n-Tools">currentBrowserEnvironment	| environment |	environment := Refactory.Browser.SelectorEnvironmentInSubcanvas				onMethods: self methods value sorted.	self searchStrings value		do: [:string | environment addSearchString: string].	^environment</body><body package="I18n-Tools">menu	^self browser menu</body><body package="I18n-Tools">methods	methods isNil ifTrue: [methods := Array new asValue].	^methods</body><body package="I18n-Tools">problemNavigator	^problemNavigator</body><body package="I18n-Tools">problemNavigator: anObject	problemNavigator := anObject</body><body package="I18n-Tools">searchStrings	searchStrings isNil ifTrue: [searchStrings := #() asValue].	^searchStrings</body><body package="I18n-Tools">windowLabel	^self problemNavigator windowLabel</body></methods><methods><class-id>I18nTools.ProblemViewer</class-id> <category>interface opening</category><body package="I18n-Tools">postBuildWith: aBuilder	super postBuildWith: aBuilder.	#(#problemNavigator #browser) do: 			[:each |			(self widgetAt: each)				client: (self perform: each)				spec: #windowSpec				builder: self builder newSubBuilder]</body><body package="I18n-Tools">toolbar	^toolbar ifNil: [toolbar := Menu new asValue]</body></methods><methods><class-id>I18nTools.ProblemViewer</class-id> <category>changing</category><body package="I18n-Tools">methodsChanged	self updateBrowser</body><body package="I18n-Tools">searchStringsChanged	self updateBrowser</body><body package="I18n-Tools">updateBrowser	| newState oldSelection availableMethodDefinitions newSelection |	oldSelection := self browser environment methodDefinitions first: 1.	self browser environment: self currentBrowserEnvironment.	newState := self browser navigator getState.	availableMethodDefinitions := self browser environment methodDefinitions.	newSelection := (oldSelection				anySatisfy: [:each | availableMethodDefinitions includes: each])					ifTrue: [oldSelection]					ifFalse: [availableMethodDefinitions first: 1].	newState definitions: newSelection.	self browser navigator updateWithState: newState</body></methods><methods><class-id>I18nTools.ProblemViewer</class-id> <category>initialize-release</category><body package="I18n-Tools">initForProblemNavigator: aProblemNavigator	aProblemNavigator		methodListHolder: self methods;		searchStringHolder: self searchStrings;		toolbarChannel: self toolbar;		yourself.	self problemNavigator: aProblemNavigator</body><body package="I18n-Tools">initialize	super initialize.	self browser: (Refactory.Browser.RefactoringBrowserInSubcanvas				onEnvironment: self currentBrowserEnvironment).	self methods onChangeSend: #methodsChanged to: self.	self searchStrings onChangeSend: #searchStringsChanged to: self</body><body package="I18n-Tools">release	super release.	self browser release</body></methods><methods><class-id>I18nTools.ProblemViewer</class-id> <category>updating</category><body package="I18n-Tools">keepBrowserSelectionWhile: aBlock	| oldSelection state |	oldSelection := self browser navigator getState definitions first: 1.	aBlock value.	oldSelection do: 			[:methodDefinition |			(self browser environment methodDefinitions includes: methodDefinition)				ifFalse: [self browser environment methodDefinitions add: methodDefinition]].	state := self browser navigator getState.	state definitions: oldSelection.	self browser navigator updateWithState: state</body><body package="I18n-Tools">method: aMethodDefinition hasMissingI18nStrings: missingI18nStrings andUsesCatalogs: catalogs	| selectedMethods |	self keepBrowserSelectionWhile: 			[selectedMethods := self methods value copy.			self problemNavigator				method: aMethodDefinition				hasMissingI18nStrings: missingI18nStrings				andUsesCatalogs: catalogs				references: (self referencedObjectsForMethod: aMethodDefinition).			self methods value: selectedMethods.			super				method: aMethodDefinition				hasMissingI18nStrings: missingI18nStrings				andUsesCatalogs: catalogs]</body></methods><methods><class-id>I18nTools.ProblemViewer</class-id> <category>testing</category><body package="I18n-Tools">hasSelection	^self problemNavigator hasSelection</body><body package="I18n-Tools">isActionMenuItemEnabled: aMenuItem	^self browser isActionMenuItemEnabled: aMenuItem</body></methods><methods><class-id>I18nTools.ProblemViewer class</class-id> <category>actions</category><body package="I18n-Tools">findMissingI18nStrings	| pundle strings |	pundle := self requestPundle ifNil:[^self].	strings := pundle isBundle				ifTrue: [I18nCore.I18nFinder findAllI18nStringsInBundle: pundle]				ifFalse: [I18nCore.I18nFinder findAllI18nStringsInPackage: pundle].	self viewProblems: strings</body><body package="I18n-Tools">requestPundle	| dialog |	dialog := IncrementalSearchDialog				forSelectionFrom: (Store.Registry allPundles						sorted: [:a | a isBundle ifTrue:[0] ifFalse:[1]] ascending , #name ascending)				filterBlock: [:entry :pundle | '*' asIs, entry , '*' asIs match: pundle name].	dialog		windowLabel: #FindPackageOrBundle &lt;&lt; #browser &gt;&gt; 'Find Package or Bundle';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #PackagesAndBundlesC &lt;&lt; #browser &gt;&gt; 'Packages and Bundles:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #toolListText;		iconSelector: #toolListIcon.	^dialog select</body></methods><methods><class-id>I18nTools.ProblemViewer class</class-id> <category>interface opening</category><body package="I18n-Tools">findNavigatorClassForProblems: navigatorProblems	| navigatorClasses |	navigatorProblems isEmpty ifTrue: [^NoProblemNavigator].	navigatorClasses := ProblemNavigator allSubclasses				select: [:aClass | (aClass navigatableProblemsFrom: navigatorProblems) notEmpty].	navigatorClasses isEmpty ifTrue: [^NoProblemNavigator].	navigatorClasses size = 1 ifTrue: [^navigatorClasses asArray first].	^CompositeProblemNavigator</body><body package="I18n-Tools">viewProblems: navigatorProblems	| navigatorClass |	navigatorClass := self findNavigatorClassForProblems: navigatorProblems.	^self viewProblems: navigatorProblems		usingNavigatorClass: navigatorClass</body><body package="I18n-Tools">viewProblems: userMessagesInCatalogs usingNavigatorClass: navigatorClass	| viewer |	viewer := (self new)				initForProblemNavigator: (navigatorClass							forProblems: userMessagesInCatalogs);				yourself.	^viewer open</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>public batch conversion</category><body package="I18n-Tools">convertString: string toUserMessage: userMessage inMethods: methods	(self nodeTypesForReplacement: #userMessage) do: 			[:aNodeType |			self				convertMissingI18nPattern: string printString				to: (self sourceCodeOfUserMessage: userMessage						withTemplate: aNodeType template)				inMethods: methods				ifStringType: aNodeType]</body><body package="I18n-Tools">markString: string asNonI18nInMethods: methods	(self nodeTypesForReplacement: #nonI18n) do: 			[:aNodeType |			self				convertMissingI18nPattern: string printString				to: (self sourceCodeOfNonI18nString: string withTemplate: aNodeType template)				inMethods: methods				ifStringType: aNodeType]</body><body package="I18n-Tools">sourceCodeOfNonI18nString: string withTemplate: template	^template expandMacrosWith: string with: #asIs</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>initialize-release</category><body package="I18n-Tools">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	root := RBRootNameSpace new.	^self</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>string contexts</category><body package="I18n-Tools">isArrayNode: aNode	^aNode parent notNil and: [aNode parent isLiteralNode]</body><body package="I18n-Tools">isTagNode: aNode	^aNode parent notNil and: [aNode parent isKindOf: RBTagNode]</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>string substitution</category><body package="I18n-Tools">defaultPragmasForReplacement: aSymbol	^(Pragma allNamed: #defaultReplacement: in: self class)		select: [:each | (each argumentAt: 1) = aSymbol]</body><body package="I18n-Tools">nodeTypesForReplacement: aSymbol	| rewriteTypesForReplacement contextType replacement defaultTypes |	rewriteTypesForReplacement := (self templatePragmasForReplacement: aSymbol)				collect: 					[:each |					contextType := each argumentAt: 1.					replacement := each argumentAt: 2.					(RewriteNodeType new)						type: contextType;						replacement: replacement;						validationBlock: (self validationBlockForNodeOfType: contextType);						template: (self perform: each selector);						resolutionBlock: (self resolutionBlockForNodeOfType: replacement);						yourself].	defaultTypes := (self defaultPragmasForReplacement: aSymbol) collect: 					[:each |					(RewriteNodeType new)						type: nil;						replacement: (each argumentAt: 1);						validationBlock: 								[:node |								rewriteTypesForReplacement									allSatisfy: [:type | (type validateNode: node) not]];						resolutionBlock: (self resolutionBlockForNodeOfType: (each argumentAt: 1));						template: (self perform: each selector);						yourself].	^rewriteTypesForReplacement , defaultTypes</body><body package="I18n-Tools">resolutionBlockForNodeOfType: contextType	| pragmas |	pragmas := (Pragma allNamed: #templateResolution: in: self class)				select: [:each | (each argumentAt: 1) = contextType].	pragmas size ~= 1		ifTrue: 			[self error: (#cannotResolveTemplateForType1p_ &lt;&lt; #i18n	&gt;&gt; 'cannot resolve template for type: &lt;1p&gt;'						expandMacrosWith: contextType)].	^[:node | self perform: pragmas first selector with: node]</body><body package="I18n-Tools">templatePragmasForReplacement: aSymbol	^(Pragma allNamed: #templateForContext:replacement: in: self class)		select: [:each | (each argumentAt: 2) = aSymbol]</body><body package="I18n-Tools">validationBlockForNodeOfType: contextType	| pragmas |	pragmas := (Pragma allNamed: #stringContext: in: self class)				select: [:each | (each argumentAt: 1) = contextType].	^[:node | pragmas allSatisfy: [:each | self perform: each selector with: node]]</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>accessing</category><body package="I18n-Tools">changes	^root changes</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>private</category><body package="I18n-Tools">convertMethods: methods usingReplaceRuleFrom: block	| replaceRule rewriter existingChange |	methods do: 			[:method |			"create the parseTree twice because sending it to the block could modify the tree already.			So a fresh tree needs to be passed to the ParseTreeRewriter."			replaceRule := block value: (self parseTreeForMethod: method) value: method.			rewriter := ParseTreeRewriter new.			rewriter addRule: replaceRule.			rewriter addArgumentRule: replaceRule.			rewriter executeTree: (self parseTreeForMethod: method).			"if this method was already changed here, remove this change. 			There's no need to have multiple changes for the same method. 			Especially as the UI will display all of these changes, which is confusing"			existingChange := self existingChangeForMethod: method.			(root classNamed: method implementingClass fullName)				compileTree: rewriter tree.			root changes removeChange: existingChange]</body><body package="I18n-Tools">convertMissingI18nPattern: sourcePattern to: resultPattern inMethods: methods ifStringType: aNodeType	| validNodes |	self convertMethods: methods		usingReplaceRuleFrom: 			[:tree :method |			validNodes := (MissingI18nStringNodeFinder forMethod: method) searchForNodesIn: tree.			(RBStringReplaceRule new)				searchFor: sourcePattern					replaceWith: resultPattern					when: 						[:node |						(aNodeType validateNode: node) and: 								[validNodes									anySatisfy: [:validNode | validNode node = node and: [validNode enclosesNode: node]]]];				yourself]</body><body package="I18n-Tools">existingChangeForMethod: method	^method implementingClass isMeta		ifTrue: 			[root changes				changeForMetaclass: method implementingClass instanceBehavior fullName				selector: method selector]		ifFalse: 			[root changes changeForClass: method implementingClass fullName				selector: method selector]</body><body package="I18n-Tools">parseTreeForMethod: method	"if the method was already modified, take this change's parseTree. 	Otherwise the changes will always be performed on the same source 	and incremental changes would ignore previous changes"	(self existingChangeForMethod: method)		ifNotNil: [:oldChange | ^oldChange parseTree].	^method parseTree</body><body package="I18n-Tools">ruleToReplaceNode: bestNode withString: replacement	^RBStringReplaceRule new		searchFor: bestNode formattedCode		replaceWith: replacement		when: [:node | node start &lt;= bestNode start and: [node stop &gt;= bestNode stop]]</body><body package="I18n-Tools">souceCodeOfNonI18nString: aString inNode: aNode	^self sourceCodeForReplacing: aString type: #nonI18n inNode: aNode</body><body package="I18n-Tools">souceCodeOfUserMessage: userMessage forNode: aNode	^self sourceCodeForReplacing: userMessage type: #userMessage inNode: aNode</body><body package="I18n-Tools">sourceCodeForReplacing: userMessage type: replacement inNode: aNode	| types validTypes |	types := self nodeTypesForReplacement: replacement.	validTypes := types select: [:each | each validateNode: aNode].	validTypes size ~= 1 ifTrue: [^nil].	^validTypes first sourceCodeForObject: userMessage</body><body package="I18n-Tools">sourceCodeOfUserMessage: userMessage withTemplate: template	^template		expandMacrosWith: userMessage key asSymbol		with: userMessage catalogID asSymbol		with: userMessage defaultString asString</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>macros</category><body package="I18n-Tools">convertPartsToMacro: concatanationParts	| s arguments |	s := String new writeStream.	s nextPutAll: '(''' asIs.	arguments := OrderedCollection new.	concatanationParts do: 			[:each |			each isLiteralNode				ifTrue: 					[[s nextPutAll: (self escapeString: each value)] on: Error do: [:ex | ^nil]]				ifFalse: 					[each isMessage						ifTrue: 							[each selector = #printString								ifTrue: 									[arguments add: each receiver.									s										nextPut: $&lt;;										print: arguments size;										nextPutAll: 'p&gt;' asIs]								ifFalse: 									[arguments add: each.									s										nextPut: $&lt;;										print: arguments size;										nextPutAll: 's&gt;' asIs]]						ifFalse: 							[each isVariable								ifTrue: 									[arguments add: each.									s										nextPut: $&lt;;										print: arguments size;										nextPutAll: 's&gt;' asIs]								ifFalse: [^nil]]]].	arguments isEmpty		ifTrue: 			[s nextPutAll: ''')' asIs.			^s contents].	s nextPut:$'.	self writeExpandMessageWithArguments: arguments on: s.	s nextPut: $).	^s contents</body><body package="I18n-Tools">escapeString: string	| ws rs char |	ws := String new writeStream.	rs := string readStream.	[rs atEnd] whileFalse: 			[char := rs next.			('%&lt;' asIs includes: char) ifTrue: [ws nextPut: $%].			char = $' ifTrue:[ws nextPut:$'].			char = Character tab				ifTrue: [ws nextPutAll: '&lt;t&gt;' asIs]				ifFalse: 					[char = Character cr						ifTrue: [ws nextPutAll: '&lt;n&gt;' asIs]						ifFalse: [  ws nextPut: char]]].	^ws contents</body><body package="I18n-Tools">partsOfConcatanation: startNode	| parts node |	parts := OrderedCollection new.	node := startNode.	[node isMessage and: [node selector = #,]] whileTrue: 			[parts addFirst: node arguments first.			node := node receiver].	parts addFirst: node.	parts size = 1 ifTrue: [^#()].	^parts</body><body package="I18n-Tools">writeExpandMessageWithArguments: arguments on: s	arguments size &lt;= 4		ifTrue: 			[s nextPutAll: ' expandMacrosWith: ' asIs.			arguments				do: [:each | s nextPutAll: (' ( &lt;1s&gt; )' asIs expandMacrosWith: each formattedCode)]				separatedBy: [s nextPutAll: ' with: ' asIs]]		ifFalse: 			[s				nextPutAll: ' expandMacrosWithArguments: (( OrderedCollection new ) ' asIs.			arguments do: 					[:each |					s						nextPutAll: (' add: ( &lt;1s&gt; ); ' asIs expandMacrosWith: each formattedCode)].			s nextPutAll: ' yourself)' asIs]</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>actions</category><body package="I18n-Tools">applyChanges	self applyChanges: self changes</body><body package="I18n-Tools">applyChanges: changes	RefactoryChangeManager instance performChange: changes</body><body package="I18n-Tools">browseChanges	self changes inspect</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>public conversion per node</category><body package="I18n-Tools">convertConcatanationToMacroInNode: aNode inMethod: method	| bestNode parts replacement |	self convertMethods: (Array with: method)		usingReplaceRuleFrom: 			[:tree :aMethod |			bestNode := tree bestNodeFor: (aNode start to: aNode stop).			parts := self partsOfConcatanation: bestNode.			replacement := self convertPartsToMacro: parts.			self ruleToReplaceNode: bestNode withString: replacement]</body><body package="I18n-Tools">convertStringNode: aStringNode toUserMessage: userMessage inMethod: method	self convertMethods: (Array with: method)		usingReplaceRuleFrom: 			[:tree :aMethod |			| replacement |			replacement := self souceCodeOfUserMessage: userMessage						forNode: aStringNode.			replacement isNil ifTrue:[^self].			self ruleToReplaceNode: aStringNode withString: replacement]</body><body package="I18n-Tools">markStringNode: aStringNode asNonI18nStringInMethod: method	self convertMethods: (Array with: method)		usingReplaceRuleFrom: 			[:tree :aMethod |			| replacement |			replacement := self souceCodeOfNonI18nString: aStringNode value						inNode: aStringNode.			replacement isNil ifTrue:[^self].			self ruleToReplaceNode: aStringNode withString: replacement]</body></methods><methods><class-id>I18nTools.I18nRewriter class</class-id> <category>instance creation</category><body package="I18n-Tools">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>I18nCore.InvalidUserMessage</class-id> <category>testing</category><body package="I18n-Core">isValid	^false</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>related changes</category><body package="I18n-Tools">addRelatedChange: aChange	aChange ~= self ifTrue:		[relatedChanges isNil ifTrue: [relatedChanges := Set new].		 relatedChanges add: aChange]</body><body package="I18n-Tools">addRelatedChanges: changes	relatedChanges isNil ifTrue:		[relatedChanges := Set new: changes size * 2].	changes do:		[:aChange|		aChange ~= self ifTrue:			[relatedChanges add: aChange]]</body><body package="I18n-Tools">explanationChange	| errorReport |	errorReport := String new writeStream.	self errors asSortedCollection do: [:errorText | errorReport nextPutAll: errorText]		separatedBy: [errorReport cr].	^(OtherChange new)		text: errorReport contents;		type: #comment;		yourself</body><body package="I18n-Tools">relatedChanges	^relatedChanges notNil ifTrue: [relatedChanges] ifFalse: [#()]</body><body package="I18n-Tools">removeRelatedChange: aChange	relatedChanges notNil ifTrue:		[relatedChanges remove: aChange ifAbsent: []]</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>testing</category><body package="I18n-Tools">isModified	^sourceCode isString</body><body package="I18n-Tools">isRelatedTo: aChange 	^self = aChange	  or: [relatedChanges notNil	  	  and: [relatedChanges includes: (aChange isDefinition 											ifTrue: [aChange]											ifFalse: [aChange myDefinition])]]</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>file accessing</category><body package="I18n-Tools">fileName	"Return the name of the receiver's stream"	| file |	originalFile isNil		ifTrue: [(file := self file) == nil ifTrue: [^(#someLocalStream &lt;&lt; #i18n &gt;&gt; 'some local stream')]]		ifFalse: [file := originalFile].	^file displayString copyReplaceAll: '$(VISUALWORKS)' with: 'VW'</body><body package="I18n-Tools">originalFile	^originalFile</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>comparing</category><body package="I18n-Tools">= anObject	^self == anObject	 or: [self class == anObject class		and: [selector == anObject selector		and: [className = anObject className		and: [self file = anObject file]]]]</body><body package="I18n-Tools">hash	^selector hash + className hash</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>accessing</category><body package="I18n-Tools">errors	^errors ifNil:[errors := Set new]</body><body package="I18n-Tools">errors: aCollection	errors := aCollection</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>printing</category><body package="I18n-Tools">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: (#for &lt;&lt; #i18n &gt;&gt; ' for ') asString;		nextPutAll: self checkingName</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>private</category><body package="I18n-Tools">updateAfterMutation	originalFile := self file</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>converting</category><body package="I18n-Tools">asI18nChange	originalFile == nil ifTrue: [self updateAfterMutation].	^self</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange</class-id> <category>source code</category><body package="I18n-Tools">cachedText: txt	cachedText := txt</body><body package="I18n-Tools">text	"Answer the text displayed by the receiver."	cachedText == nil ifFalse: [^cachedText].	^super text</body></methods><methods><class-id>I18nTools.I18nMethodDefinitionChange class</class-id> <category>instance creation</category><body package="I18n-Tools">fromChange: aMethodDefinitionChange	| new |	new := Array new: self instSize.	new 		replaceFrom: 1		to: MethodDefinitionChange instSize		with: (aMethodDefinitionChange shallowCopy changeClassTo: Array)		startingAt: 1.	self adoptInstance: new.	new updateAfterMutation.	^new</body></methods><methods><class-id>I18nCore.MethodFilterUserMessage</class-id> <category>printing</category><body package="I18n-Core">displayString	^#hasUserMessageMatchingUserMessageMacro &lt;&lt; #i18n		&gt;&gt; 'has UserMessage matching: &lt;1p&gt; %&lt;%&lt;% &lt;2p&gt; &gt;&gt; &lt;3p&gt;'			expandMacrosWith: self keyPattern			with: self catalogPattern			with: self defaultStringPattern</body></methods><methods><class-id>I18nCore.MethodFilterUserMessage</class-id> <category>accessing</category><body package="I18n-Core">catalogPattern	^catalogPattern</body><body package="I18n-Core">catalogPattern: anObject	catalogPattern := anObject</body><body package="I18n-Core">defaultStringPattern	^defaultStringPattern</body><body package="I18n-Core">defaultStringPattern: anObject	defaultStringPattern := anObject</body><body package="I18n-Core">keyPattern	^keyPattern</body><body package="I18n-Core">keyPattern: anObject	keyPattern := anObject</body></methods><methods><class-id>I18nCore.MethodFilterUserMessage</class-id> <category>private</category><body package="I18n-Core">matchUserMessage: aUserMessage	^(self		matchValueOf: #key		inMessage: aUserMessage		againsPatternAt: #keyPattern) and: 				[(self					matchValueOf: #catalogID					inMessage: aUserMessage					againsPatternAt: #catalogPattern) and: 							[self								matchValueOf: #defaultString								inMessage: aUserMessage								againsPatternAt: #defaultStringPattern]]</body><body package="I18n-Core">matchValueOf: messageSelector inMessage: aUserMessage againsPatternAt: patternSelector	| pattern messageValue |	pattern := self perform: patternSelector.	messageValue := aUserMessage perform: messageSelector.	pattern isNil ifTrue: [^messageValue isNil].	messageValue isNil ifTrue: [^false].	pattern isEmpty ifTrue: [^messageValue isEmpty].	^pattern match: messageValue</body></methods><methods><class-id>I18nCore.InvalidCodeUserMessage</class-id> <category>initialize-release</category><body package="I18n-Core">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>I18nCore.InvalidCodeUserMessage</class-id> <category>comparing</category><body package="I18n-Core">validForWritingCatalog	^false</body></methods><methods><class-id>I18nCore.InvalidCodeUserMessage</class-id> <category>accessing</category><body package="I18n-Core">errorName	^#InvalidCode &lt;&lt; #i18n &gt;&gt; 'Invalid Code'</body></methods><methods><class-id>Tools.MethodCollector</class-id> <category>building queries</category><body package="I18n-Core">hasMissingI18nStrings	"Answer a filter that answers all Methods that have strings that are not part of a UserMessage. 	| mc |	mc := MethodCollector new.	mc browseSelect: mc hasMissingI18nStrings.	"	^I18nCore.MethodFilterMissingI18n new</body><body package="I18n-Core">hasUserMessage	"Answer a filter that answers all methods containing UserMessages 	| mc |	mc := MethodCollector new.	mc browseSelect: mc userMessage.	"	^I18nCore.MethodFilterAnyUserMessage new</body><body package="I18n-Core">hasUserMessageLike: aUserMessage	"Answer a filter that answers all references of a UserMessage. 	The parts of the UserMessage are used as match-strings.	| mc |	mc := MethodCollector new.	mc browseSelect: (mc userMessageLike: #'*' &lt;&lt; #'*' &gt;&gt; '*).	mc browseSelect: (mc userMessageLike: #'*' &lt;&lt; #menu &gt;&gt; '*test*')	"	^(I18nCore.MethodFilterUserMessage new)		catalogPattern: aUserMessage catalogID;		keyPattern: aUserMessage key;		defaultStringPattern: aUserMessage defaultString;		yourself</body></methods><methods><class-id>Kernel.IndexedFileMessageCatalog</class-id> <category>initializing</category><body package="I18n-Core">named: name	index := MC_FileBTree named: name , '.idx' asIs.	cacheLimit := index cacheLimit.	"overridden because source defaults to UTF8 if BOM support is not loaded. 	Otherwise source is defined as #autoDetectOrUTF8:UTF8WithBOM:"	messageFile := ((name , '.lbl' asIs) asFilename withEncoding: #source)				readStream.	messageFile close.	messageFile lineEndTransparent.	catalogID := index catalogID.	self close</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>accessing</category><body package="I18n-Core">initializerText	^(otherParameters detect: [:asc | asc key == #initializer:] ifNone: []) value</body></methods><methods><class-id>Kernel.UserMessage</class-id> <category>testing</category><body package="I18n-Core">isValid	^true</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="I18n-Core">i18nPragmasToIgnore	^self i18nSelectorsReturnedByMethodsWithPragma: #i18nPragmasToIgnore</body><body package="I18n-Core">i18nSelectorsInMethodDefinition: methodDefinition	"returns a collection of symbols that are stored in the provided method definition. 	It doesn't matter how the symbols are stored, because the method is executed"	| receiver result aClass |	aClass := methodDefinition implementingClass.	receiver := aClass isMeta				ifTrue: [aClass instanceBehavior]				ifFalse: [aClass basicNew].	result := 			[methodDefinition method valueWithReceiver: receiver arguments: #()]					on: Error					do: 						[:ex |						Transcript							show: ('Cannot execute &lt;1p&gt;&gt;&gt;&lt;2p&gt;' expandMacrosWith: aClass										with: methodDefinition);							cr.						^#()].	(result isKindOf: Collection) ifTrue: [^result].	Transcript		show: ('&lt;1p&gt;&gt;&gt;&lt;2p&gt; does not return a Collection' expandMacrosWith: aClass					with: methodDefinition);		cr.	^#()</body><body package="I18n-Core">i18nSelectorsReturnedByMethodsWithPragma: pragmaName	| pragmas selectors |	pragmas := Pragma				allNamed: pragmaName				from: self				to: self withAllSuperclasses last.	selectors := Set new.	pragmas do: 			[:pragma |			selectors				addAll: (self i18nSelectorsInMethodDefinition: pragma methodDefinition)].	^selectors</body><body package="I18n-Core">i18nSelectorsToIgnore	^self i18nSelectorsReturnedByMethodsWithPragma: #i18nSelectorsToIgnore</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>converting</category><body package="I18n-Tools">asI18nChange	^I18nTools.I18nClassDefinitionChange fromChange: self</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>i18n</category><body package="I18n-Tools">macroBuilder	^I18nTools.MacroBuilder onSourceCodeEditor: self</body><body package="I18n-Tools">menuItemLabeled: message forHelper: helper	^(MenuItem labeled: message)		enablement: [helper canBeApplied];		value: [helper convertSelection];		visibility: [evaluator class = BrowserSourceCodeTool];		yourself</body><body package="I18n-Tools">nonI18nBuilder	^I18nTools.MarkNonI18nBuilder onSourceCodeEditor: self</body><body package="I18n-Tools">userMessageBuilder	^I18nTools.UserMessageBuilder onSourceCodeEditor: self</body></methods><methods><class-id>Kernel.MethodDefinitionChange</class-id> <category>converting</category><body package="I18n-Tools">asI18nChange	^I18nTools.I18nMethodDefinitionChange fromChange: self</body></methods><methods><class-id>I18nTools.ProblemNavigator class</class-id> <category>instance creation</category><body package="I18n-Tools">problemKindPragma	&lt;pragmas: #class&gt;	^#(#problemKind)</body></methods><methods><class-id>I18nTools.CompositeProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window: #(#{UI.WindowSpec}			#label: #(#{Kernel.UserMessage}				#key: #UnlabeledCanvas				#defaultString: 'Unlabeled Canvas'				#catalogID: #i18n)			#bounds: #(#{Graphics.Rectangle} 838 266 1082 775))		#component: #(#{UI.SpecCollection}			#collection: #(#(#{UI.SequenceViewSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.3)				#name: #problemNavigators				#model: #problemNavigators				#useModifierKeys: true				#selectionType: #highlight) #(#{UI.ResizingSplitterSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 1 0.3 0 1 4 0.3)				#name: #splitter				#horizontal: true				#minAboveSize: 30				#minBelowSize: 30				#aboveWidgets: 'problemKinds'				#belowWidgets: 'subNavigator') #(#{UI.SubCanvasSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 5 0.3 0 1 0 1)				#name: #subNavigator				#flags: 0))))</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>rules</category><body package="I18n-Core">angleCatalogStringNode: aNode	&lt;pattern: '`#key &gt;&gt; `#string'&gt;	^self		userMessageWithKey: aNode receiver		catalog: nil		defaultString: aNode arguments first</body><body package="I18n-Core">angleKeyCatalogNode: aNode	"if the first argument is a string, the resulting user message will have a string as catalog, which doesn't work.	To have this properly transported as a problem, use the string as defaultString, because this was probably the intension of the developer"	&lt;pattern: '`#key &lt;&lt; `#catalog'&gt;	| defaultStringNode catalogNode |	defaultStringNode := nil.	catalogNode := aNode arguments first.	((self isProperSymbolNode: catalogNode) not		and: [self isProperStringNode: catalogNode])			ifTrue: 				[defaultStringNode := catalogNode.				catalogNode := nil].	^self		userMessageWithKey: aNode receiver		catalog: catalogNode		defaultString: defaultStringNode</body><body package="I18n-Core">angleKeyCatalogStringNode1: aNode	&lt;pattern: '`#key &gt;&gt; `#string &lt;&lt; `#catalog'&gt;	^self		userMessageWithKey: aNode receiver receiver		catalog: aNode arguments first		defaultString: aNode receiver arguments first</body><body package="I18n-Core">angleKeyCatalogStringNode: aNode	&lt;pattern: '`#key &lt;&lt; `#catalog &gt;&gt; `#string'&gt;	^self		userMessageWithKey: aNode receiver receiver		catalog: aNode receiver arguments first		defaultString: aNode arguments first</body><body package="I18n-Core">arrayCatalogStringNode1: aNode	&lt;	pattern: '#(`#class #key: `#key #defaultString: `#message #catalogID: `#catalog)'&gt;	(self refersNode: (aNode contents at: 1) toClass: UserMessage)		ifFalse: [^nil].	^self		userMessageWithKey: (aNode contents at: 3)		catalog: (aNode contents at: 7)		defaultString: (aNode contents at: 5)</body><body package="I18n-Core">arrayCatalogStringNode2: aNode	&lt;	pattern: '#(`#class  #defaultString: `#message #key: `#key #catalogID: `#catalog)'&gt;	(self refersNode: (aNode contents at: 1) toClass: UserMessage)		ifFalse: [^nil].	^self		userMessageWithKey: (aNode contents at: 5)		catalog: (aNode contents at: 7)		defaultString: (aNode contents at: 3)</body><body package="I18n-Core">arrayCatalogStringNode3: aNode	&lt;	pattern: '#(`#class  #defaultString: `#message #catalogID: `#catalog #key: `#key)'&gt;	(self refersNode: (aNode contents at: 1) toClass: UserMessage)		ifFalse: [^nil].	^self		userMessageWithKey: (aNode contents at: 7)		catalog: (aNode contents at: 5)		defaultString: (aNode contents at: 3)</body><body package="I18n-Core">arrayCatalogStringNode4: aNode	&lt;	pattern: '#(`#class  #catalogID: `#catalog #defaultString: `#message #key: `#key)'&gt;	(self refersNode: (aNode contents at: 1) toClass: UserMessage)		ifFalse: [^nil].	^self		userMessageWithKey: (aNode contents at: 7)		catalog: (aNode contents at: 3)		defaultString: (aNode contents at: 5)</body><body package="I18n-Core">arrayCatalogStringNode5: aNode	&lt;	pattern: '#(`#class  #catalogID: `#catalog #key: `#key #defaultString: `#message )'&gt;	(self refersNode: (aNode contents at: 1) toClass: UserMessage)		ifFalse: [^nil].	^self		userMessageWithKey: (aNode contents at: 5)		catalog: (aNode contents at: 3)		defaultString: (aNode contents at: 7)</body><body package="I18n-Core">arrayCatalogStringNode6: aNode	&lt;	pattern: '#(`#class #key: `#key  #catalogID: `#catalog  #defaultString: `#message )'&gt;	(self refersNode: (aNode contents at: 1) toClass: UserMessage)		ifFalse: [^nil].	^self		userMessageWithKey: (aNode contents at: 3)		catalog: (aNode contents at: 5)		defaultString: (aNode contents at: 7)</body><body package="I18n-Core">classUserMessageKeyStringCatalogNode: aNode	&lt;	pattern: 'UserMessage defaultString: `#string key: `#key catalogID: `#catalog'&gt;	^self		userMessageWithKey: (aNode arguments at: 2)		catalog: aNode arguments last		defaultString: aNode arguments first</body><body package="I18n-Core">classUserMessageKeyStringNode: aNode	&lt;pattern: 'UserMessage defaultString: `#string key: `#key'&gt;	^self		userMessageWithKey: aNode arguments last		catalog: nil		defaultString: aNode arguments first</body><body package="I18n-Core">condenseUserMessageArray: aNode	&lt;pattern: '#(`#key `#catalog `#string)'&gt;	^self		userMessageWithKey: (aNode contents at: 1)		catalog: (aNode contents at: 2)		defaultString: (aNode contents at: 3)</body><body package="I18n-Core">incorrectAngleKeyCatalogStringNode1: aNode	&lt;pattern: '`#key &lt;&lt; `#catalog &lt;&lt; `#string'&gt;	| userMessage |	userMessage := self				userMessageWithKey: aNode receiver receiver				catalog: aNode receiver arguments first				defaultString: aNode arguments first.	userMessage ifNil: [^nil].	^InvalidUserMessage		defaultString: userMessage defaultString		key: userMessage key		catalogID: userMessage catalogID</body><body package="I18n-Core">incorrectAngleKeyCatalogStringNode: aNode	&lt;pattern: '`#key &gt;&gt; `#string &gt;&gt; `#catalog'&gt;	| userMessage |	userMessage := self				userMessageWithKey: aNode receiver receiver				catalog: aNode arguments first				defaultString: aNode receiver arguments first.	userMessage ifNil: [^nil].	^InvalidUserMessage		defaultString: userMessage defaultString		key: userMessage key		catalogID: userMessage catalogID</body><body package="I18n-Core">slarUserMessage: aNode	&lt;	pattern: '#(#slar #{Kernel.UserMessage} #(#catalogID `#catalog) #(#defaultString `#aString) #(#key `#key))'&gt;	^self		userMessageWithKey: (aNode contents at: 5) contents last		catalog: (aNode contents at: 3) contents last		defaultString: (aNode contents at: 4) contents last</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>instance creation</category><body package="I18n-Core">invalidationPragmas	"the invalidation pragma is used in methods that can invalidate an otherwise valid node. The methods can have one or two arguments, which are the node and the result. If the method returns false, then the node is rejected"	&lt;pragmas: #class&gt;	^#(#invalidation #invalidationFor:)</body><body package="I18n-Core">patternPragma	"#pattern: defines a string that's used as rewrite-rule for finding a certain pattern in code. The method that defines takes one argument, which will be the node that matches the pattern. It then has to return either nil or an object. If it's not nil, this match will be kept"	&lt;pragmas: #class&gt;	^#(#pattern:)</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>public</category><body package="I18n-Core">oldWindowSpecNode: aNode	&lt;invalidationFor: #condenseUserMessageArray:&gt;	| currentNode catalog |	currentNode := aNode parent.	[currentNode isLiteralNode and: [currentNode value isKindOf: Array]]		whileTrue: 			[(#(#FullSpec #WindowSpec #SpecCollection)				includes: currentNode value first)					ifTrue: 						["aNode is part of a Spec and there UserMessages are stored in a different way"						^true].			currentNode := currentNode parent].	(currentNode isMessage and: [currentNode selector = #decodeAsLiteralArray])		ifTrue: [^true].	catalog := aNode value at: 2.	catalog precedence ~= 1 ifTrue: [^true].	^false</body></methods><methods><class-id>I18nCore.UserMessageNodeFinder class</class-id> <category>i18n</category><body package="I18n-Core">i18nIgnores	&lt;i18nSelectorsToIgnore&gt;	^#(#'*')</body></methods><methods><class-id>I18nTools.CatalogsUI</class-id> <category>menu-items</category><body package="I18n-Tools">browseSelection	&lt;itemInMenu: #(#toolbar) position: 30.0&gt;	&lt;itemInMenu: #(#menu #file) position: 30.0&gt;	&lt;itemInMenu: #(contextMenu) position:30.0&gt;	^(MenuItem labeled: #BrowseSelection &gt;&gt; 'Browse Selected Catalogs' &lt;&lt; #i18n)		labelImage: WorkspaceIcons workspace;		enablement: [self selectedCatalogItems notEmpty];		value: [self showSelectedCatalog];		helpText: #browseSelectionDescription &lt;&lt; #i18n					&gt;&gt; 'Browse all User Messages and Problems of the selected catalogs';		yourself</body><body package="I18n-Tools">writeAll	&lt;itemInMenu: #(#toolbar) position: 20.075&gt;	&lt;itemInMenu: #(#menu #file) position: 20.075&gt;	^(MenuItem labeled: #WriteAll &gt;&gt; 'Write All Catalogs' &lt;&lt; #i18n )		labelImage: self saveAllIcon;		value: [self writeAllCatalogs];		helpText: #writeAllDescription &lt;&lt; #i18n &gt;&gt; 'Write all Catalogs to LBL and IDX files';		yourself</body><body package="I18n-Tools">writeSelection	&lt;itemInMenu: #(#toolbar) position: 20.0&gt;	&lt;itemInMenu: #(#menu #file) position: 20.0&gt;	&lt;itemInMenu: #(#contextMenu) position: 20.0&gt;	^(MenuItem labeled: #WriteSelection &gt;&gt; 'Write Selected Catalogs' &lt;&lt; #i18n)		labelImage: WorkspaceIcons workspaceSave;		enablement: [self selectedCatalogItems notEmpty];		value: [self writeSelectedCatalogs];		helpText: #writeSelectionDescription &lt;&lt; #i18n					&gt;&gt; 'Write the selected Catalogs to LBL and IDX files';		yourself</body></methods><methods><class-id>I18nTools.CatalogsUI class</class-id> <category>resources</category><body package="I18n-Tools">toolbar	"Tools.MenuEditor new openOnClass: self andSelector: #toolbar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #refresh 								#defaultString: 'Refresh' 								#catalogID: #i18n ) 							#value: #refreshCatalogs 							#shortcutKeyCharacter: $R 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{DebuggerIcons} #restart ) 							#helpText: 							#(#{Kernel.UserMessage} 								#key: #refreshCatalogsDescription 								#defaultString: 'Search for the catalogs again' 								#catalogID: #i18n ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #findMissingI18nStrings 					#defaultString: 'Find Missing I18n Strings' 					#catalogID: #i18n ) 				#value: #findMissingI18nString 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.DebuggerIcons} #inspector ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #findMissingI18nStringsDescription 					#defaultString: 'Find strings that are not internationalized' 					#catalogID: #i18n ) ) 			 ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>I18nTools.CatalogsUI class</class-id> <category>interface specs</category><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #catalogs 				#defaultString: 'Catalogs' 				#catalogID: #i18n ) 			#bounds: #(#{Graphics.Rectangle} 733 369 1188 672 ) 			#flags: 4 			#menu: #menu 			#toolBar: #toolbar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -10 1 ) 					#name: #catalogsList 					#model: #catalogsList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #showSelectedCatalog ) 					#menu: #catalogsListContextMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedCatalog name' 							#label: 							#(#{Kernel.UserMessage} 								#key: #name 								#defaultString: 'Name' 								#catalogID: #i18n ) 							#labelIsImage: false 							#width: 183 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedCatalog numberOfProblemsText' 							#label: 							#(#{Kernel.UserMessage} 								#key: #problems 								#defaultString: 'Problems' 								#catalogID: #i18n ) 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedCatalog numberOfDefinedKeysText' 							#label: 							#(#{Kernel.UserMessage} 								#key: #numberOfDefinedKeys 								#defaultString: 'Defined Keys' 								#catalogID: #i18n ) 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#multipleSelections: true ) ) ) )</body></methods><methods><class-id>I18nTools.ProblemNavigatorWithMethods class</class-id> <category>interface specs</category><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window: #(#{UI.WindowSpec}			#label: #(#{Kernel.UserMessage}				#key: #UnlabeledCanvas				#defaultString: 'Unlabeled Canvas'				#catalogID: #i18n)			#bounds: #(#{Graphics.Rectangle} 738 263 942 747))		#component: #(#{UI.SpecCollection}			#collection: #(#(#{UI.SequenceViewSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1)				#name: #problemList				#model: #problemList				#menu: #problemContextMenu				#useModifierKeys: true				#selectionType: #highlight))))</body></methods><methods><class-id>I18nTools.UserMessageProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">problemKind	&lt;problemKind&gt;	^UserMessageInCatalog</body></methods><methods><class-id>I18nTools.MissingI18nProblemNavigator</class-id> <category>context menu</category><body package="I18n-Tools">convertAllToNonI18nStrings	&lt;itemInMenu: #(#problemMenu) position: 2&gt;	&lt;itemInMenu: #(#toolbar) position: 2&gt;	^(MenuItem		labeled: #markAllToNonI18nStrings &gt;&gt; 'Mark All As Non Internationalizable'				&lt;&lt; #i18n)		labelImage: BrowserIcons extractMethod;		enablement: #hasSelection;		value: 				[self convertString: self stringOfSelectedProblem					toNonI18nStringIn: self methodsOfSelectedProblem];		helpText: #convertAllToNonI18nStringsDescription &lt;&lt; #i18n					&gt;&gt; 'Mark all occurances of this string to not Internationalizable';		yourself</body><body package="I18n-Tools">convertAllToUserMessage	&lt;itemInMenu: #(#problemMenu) position: 1&gt;	&lt;itemInMenu: #(#toolbar) position: 1&gt;	^(MenuItem		labeled: #convertAllToUserMessage &gt;&gt; 'Convert All To UserMessage' &lt;&lt; #i18n)		enablement: #hasSelection;		labelImage: BrowserIcons definitionsMethod;		value: 				[self convertString: self stringOfSelectedProblem					toUsermessagesIn: self methodsOfSelectedProblem];		helpText: #convertAllToUserMessageDescription &lt;&lt; #i18n					&gt;&gt; 'Convert all occurances of this string to the same User Messages';		yourself</body></methods><methods><class-id>I18nTools.MissingI18nProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">problemKind	&lt;problemKind&gt;	^MissingI18nString</body></methods><methods><class-id>I18nTools.NoProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window: #(#{UI.WindowSpec}			#label: #(#{Kernel.UserMessage}				#key: #UnlabeledCanvas				#defaultString: 'Unlabeled Canvas'				#catalogID: #i18n)			#bounds: #(#{Graphics.Rectangle} 860 420 1060 620))		#component: #(#{UI.SpecCollection}			#collection: #(#(#{UI.SequenceViewSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1)				#name: #emptyList				#useModifierKeys: true				#selectionType: #highlight))))</body></methods><methods><class-id>I18nCore.MissingI18nStringNodeFinder class</class-id> <category>invalidations</category><body package="I18n-Core">asIsNode: aNode	"if the string is in an array or directly receives the message #asIs, then this string should not be internationalized"	&lt;invalidation&gt;	| nonLiteralNode |	nonLiteralNode := aNode parent.	[nonLiteralNode isLiteralNode]		whileTrue: [nonLiteralNode := nonLiteralNode parent].	^nonLiteralNode isMessage and: [nonLiteralNode selector = #asIs]</body><body package="I18n-Core">ignorePragmas: aNode value: aString inMethod: aMethod	"if a string is inside a pragma, this string can only be marked as not to be localized by adding the pragma to the list of	pragmas that should be ignored. These pragmas have to be implemented in a class-method called #i18nPragmasToIgnore"	&lt;invalidation&gt;	| tagNode methodNode pragmasToIgnore |	methodNode := aNode methodNode.	methodNode tagCount = 0 ifTrue: [^false].	tagNode := aNode.	[tagNode isNil or: [tagNode isKindOf: RBTagNode]]		whileFalse: [tagNode := tagNode parent].	tagNode isNil ifTrue: [^false].	pragmasToIgnore := aMethod implementingClass i18nPragmasToIgnore.	^pragmasToIgnore includes: tagNode selector</body><body package="I18n-Core">inResizingSplitterAttribute: aNode	"resizing splitters use strings to store the ids of their above and below widgets, both must not be considered for localization"	&lt;invalidation&gt;	| arrayNode |	arrayNode := aNode parent.	^arrayNode isLiteralArray and: 			[arrayNode value first isBindingReference and: 					[arrayNode value first fullName = #{UI.ResizingSplitterSpec} fullName and: 							[#(#aboveWidgets: #belowWidgets:)								includes: (self keyForValueNode: aNode inArrayNode: arrayNode)]]]</body><body package="I18n-Core">isFormatString: aNode	"resizing splitters use strings to store the ids of their above and below widgets, both must not be considered for localization"	&lt;invalidation&gt;	| arrayNode |	arrayNode := aNode parent.	^arrayNode isLiteralArray and: 			[arrayNode value first isBindingReference and: 					[('*Spec' match: arrayNode value first fullName) and: 							[#(#formatString:)								includes: (self keyForValueNode: aNode inArrayNode: arrayNode)]]]</body><body package="I18n-Core">packedStringNode: aNode	&lt;invalidation&gt;	^aNode parent notNil and: 			[aNode parent isMessage and: [aNode parent selector = #fromPackedString:]]</body><body package="I18n-Core">tooLongStringNode: aNode	&lt;invalidation&gt;	| method |	method := aNode methodNode.	^method notNil and: [method source size &gt; BrowserTextTool parserTextLimit]</body></methods><methods><class-id>I18nCore.MissingI18nStringNodeFinder class</class-id> <category>rules</category><body package="I18n-Core">stringForNode: aNode	&lt;pattern: '`#string'&gt;	| literal |	literal := aNode value.	(literal isString and: [literal isSymbol not]) ifTrue: [^literal].	^nil</body></methods><methods><class-id>I18nTools.InvalidKeyProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">problemKind	&lt;problemKind&gt;	^InvalidKeyMessage</body></methods><methods><class-id>I18nTools.InvalidCodeUserMessageProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">problemKind	&lt;problemKind&gt;	^InvalidCodeUserMessage</body></methods><methods><class-id>I18nTools.DuplicateKeyProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">problemKind	&lt;problemKind&gt;	^DuplicateKeyUserMessage</body><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window: #(#{UI.WindowSpec}			#label: #(#{Kernel.UserMessage}				#key: #UnlabeledCanvas				#defaultString: 'Unlabeled Canvas'				#catalogID: #i18n)			#bounds: #(#{Graphics.Rectangle} 740 405 944 889))		#component: #(#{UI.SpecCollection}			#collection: #(#(#{UI.SequenceViewSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.5)				#name: #keysList				#model: #keysList				#useModifierKeys: true				#selectionType: #highlight) #(#{UI.ResizingSplitterSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 1 0.5 0 1 5 0.5)				#name: #splitter				#horizontal: true				#minAboveSize: 30				#minBelowSize: 30				#aboveWidgets: 'keysList'				#belowWidgets: 'stringsList') #(#{UI.SequenceViewSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 6 0.5 0 1 0 1)				#name: #stringsList				#model: #stringsList				#useModifierKeys: true				#selectionType: #highlight))))</body></methods><methods><class-id>I18nTools.I18nPatchChangeList class</class-id> <category>interface specs</category><body package="I18n-Tools">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadFilesDot 								#defaultString: '&amp;Read File(s)...' 								#catalogID: #menus ) 							#value: #fileIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadDifferentSourceFromFilesDot 								#defaultString: 'Read Different &amp;Source from File(s)...' 								#catalogID: #menus ) 							#value: #fileInSourceDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadDifferentCodeFromFilesDot 								#defaultString: 'Read Different &amp;Code from File(s)...' 								#catalogID: #menus ) 							#value: #fileInDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #WriteFileDot 								#defaultString: '&amp;Write File...' 								#catalogID: #menus ) 							#value: #fileOut 							#enablementSelector: #anyToFileOut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RecoverLastChanges 								#defaultString: 'Recover &amp;Last Changes' 								#catalogID: #menus ) 							#value: #recover ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayS_ystemChanges 								#defaultString: 'Display S&amp;ystem Changes' 								#catalogID: #menus ) 							#value: #getChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayAllSystemChanges 								#defaultString: 'Display &amp;All System Changes' 								#catalogID: #menus ) 							#value: #getAllChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Display_ParcelDot 								#defaultString: 'Display &amp;Parcel...' 								#catalogID: #menus ) 							#value: #getParcel ) ) #(1 2 1 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Replay 					#defaultString: '&amp;Replay' 					#catalogID: #menus ) 				#nameKey: #replay 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #doThis 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromTheTop 								#defaultString: 'All from the &amp;Top' 								#catalogID: #menus ) 							#value: #doAll 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromHereDown 								#defaultString: 'All from here &amp;Down' 								#catalogID: #menus ) 							#value: #doFromHere 							#enablementSelector: #hasSelection ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Re_move 					#defaultString: 'Re&amp;move' 					#catalogID: #menus ) 				#nameKey: #remove 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #removeItem 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #A_ll 								#defaultString: 'A&amp;ll' 								#catalogID: #menus ) 							#value: #removeAll 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllAbove 								#defaultString: 'All &amp;Above' 								#catalogID: #menus ) 							#value: #removeAllAbove 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllBelow 								#defaultString: 'All &amp;Below' 								#catalogID: #menus ) 							#value: #removeAllBelow 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExchangeRemoved 								#defaultString: 'E&amp;xchange Removed' 								#catalogID: #menus ) 							#value: #exchangeRemoved 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameCodeAsSystem 								#defaultString: 'Same &amp;Code as System' 								#catalogID: #menus ) 							#value: #removeSameAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSourceAsSystem 								#defaultString: 'Same &amp;Source as System' 								#catalogID: #menus ) 							#value: #removeSameSourceAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentCodeToSystem 								#defaultString: 'Different C&amp;ode to System' 								#catalogID: #menus ) 							#value: #removeConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentSourceToSystem 								#defaultString: 'Different So&amp;urce to System' 								#catalogID: #menus ) 							#value: #removeSourceConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CodeForClassesNotInSystem 								#defaultString: 'Code for Classes &amp;not in System' 								#catalogID: #menus ) 							#value: #removeClassesNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MethodsNotInSystem 								#defaultString: '&amp;Methods not in System' 								#catalogID: #menus ) 							#value: #removeMethodsNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OldVersions 								#defaultString: 'Old &amp;Versions' 								#catalogID: #menus ) 							#value: #removeOldVersions 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExactDuplicates 								#defaultString: 'Exact &amp;Duplicates' 								#catalogID: #menus ) 							#value: #removeDuplicates 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Con_flicts 								#defaultString: 'Con&amp;flicts' 								#catalogID: #menus ) 							#value: #removeConflictsInList 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangesWithTextDot 								#defaultString: 'Changes with &amp;Text ...' 								#catalogID: #menus ) 							#value: #removeChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(4 1 2 2 2 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #For_get 					#defaultString: 'For&amp;get' 					#catalogID: #menus ) 				#nameKey: #forget 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetSelection 								#defaultString: 'Forget &amp;Selection' 								#catalogID: #menus ) 							#value: #forgetSelection 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Forget_Marked 								#defaultString: 'Forget &amp;Marked' 								#catalogID: #menus ) 							#value: #forgetThese 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetAllMarked 								#defaultString: 'Forget &amp;All Marked' 								#catalogID: #menus ) 							#value: #forgetAll 							#enablementSelector: #hasRemovedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreSelection 								#defaultString: '&amp;Restore Selection' 								#catalogID: #menus ) 							#value: #restoreItem 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreAll 								#defaultString: 'R&amp;estore All' 								#catalogID: #menus ) 							#value: #restoreAll 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreChangesWithTextDot 								#defaultString: 'Restore Changes with &amp;Text...' 								#catalogID: #menus ) 							#value: #restoreChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Fi_nd 					#defaultString: 'Fi&amp;nd' 					#catalogID: #menus ) 				#nameKey: #find 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileDot 								#defaultString: '&amp;File ...' 								#catalogID: #menus ) 							#value: #findFile ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_TypeDot 								#defaultString: '&amp;Type ...' 								#catalogID: #menus ) 							#value: #findType ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassDot 								#defaultString: '&amp;Class ...' 								#catalogID: #menus ) 							#value: #findClass ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ProtocolDot 								#defaultString: '&amp;Protocol ...' 								#catalogID: #menus ) 							#value: #findProtocol ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectorDot 								#defaultString: '&amp;Selector ...' 								#catalogID: #menus ) 							#value: #findSelector ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnSelection 								#defaultString: 'Spa&amp;wn Selection' 								#catalogID: #menus ) 							#value: #spawnBrowserOnSelection 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Spawn_All 								#defaultString: 'Spawn &amp;All' 								#catalogID: #menus ) 							#value: #copyView 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnChangesWithTextDot 								#defaultString: 'Spawn Changes with &amp;Text ...' 								#catalogID: #menus ) 							#value: #spawnChangesContainingString 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectNextChangeWithTextDot 								#defaultString: 'Select &amp;Next Change with Text ...' 								#catalogID: #menus ) 							#value: #selectNextChangeContainingString 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassMatching 								#defaultString: 'Class &amp;Matching' 								#catalogID: #menus ) 							#nameKey: #classMatching 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #InstanceAndClass 											#defaultString: '&amp;Instance and Class' 											#catalogID: #menus ) 										#nameKey: #groupClassAndMetaclass 										#value: #groupClassAndMetaclass 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SelectedClassOnly 											#defaultString: 'Selected Class &amp;Only' 											#catalogID: #menus ) 										#nameKey: #ungroupClassAndMetaclass 										#value: #ungroupClassAndMetaclass 										#indication: true ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameFile 								#defaultString: 'Same File' 								#catalogID: #menus ) 							#nameKey: #filterByFile 							#value: #toggleFileFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameType 								#defaultString: 'Same Type' 								#catalogID: #menus ) 							#nameKey: #filterByType 							#value: #toggleTypeFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameClass 								#defaultString: 'Same Class' 								#catalogID: #menus ) 							#nameKey: #filterByClass 							#value: #toggleClassFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameProtocol 								#defaultString: 'Same Protocol' 								#catalogID: #menus ) 							#nameKey: #filterByProtocol 							#value: #toggleProtocolFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSelector 								#defaultString: 'Same Selector' 								#catalogID: #menus ) 							#nameKey: #filterBySelector 							#value: #toggleSelectorFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameChange 								#defaultString: 'Same Change' 								#catalogID: #menus ) 							#nameKey: #filterBySame 							#value: #toggleSameFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RelatedChange 								#defaultString: 'Related Change' 								#catalogID: #menus ) 							#nameKey: #filterByRelative							#value: #toggleRelatedFilter 							#indication: true ) ) #(5 4 1 6 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Conflicts 					#defaultString: '&amp;Conflicts' 					#catalogID: #menus ) 				#nameKey: #conflicts 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SaveConflictsAsDot 								#defaultString: '&amp;Save Conflicts As...' 								#catalogID: #menus ) 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_ConflictsWithSystemAsDot 								#defaultString: 'Save &amp;Conflicts with System As...' 								#catalogID: #menus ) 							#value: #checkWithSystem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveConflicts 								#defaultString: '&amp;Remove Conflicts' 								#catalogID: #menus ) 							#value: #removeConflictsInList ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveConflictsWithSystem 								#defaultString: 'Remove Conflicts &amp;with System' 								#catalogID: #menus ) 							#value: #removeConflictsWithSystem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddSystemConflicts 								#defaultString: '&amp;Add System Conflicts' 								#catalogID: #menus ) 							#value: #addSystemConflicts ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddOriginalVersions 								#defaultString: 'Add &amp;Original Versions' 								#catalogID: #menus ) 							#value: #addOriginals ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddToChangeSet 								#defaultString: 'A&amp;dd to Change Set' 								#catalogID: #menus ) 							#value: #addChangesToCurrentChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveFromChangeSet 								#defaultString: 'Remove &amp;from Change Set' 								#catalogID: #menus ) 							#value: #removeChangesFromCurrentChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BuildScriptToSystem 								#defaultString: '&amp;Build Script to System' 								#catalogID: #menus ) 							#value: #spawnConvergeScriptToSystem ) ) #(2 2 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show 					#defaultString: '&amp;Show' 					#catalogID: #menus ) 				#nameKey: #show 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowFile 								#defaultString: 'Show &amp;File' 								#catalogID: #menus ) 							#nameKey: #showFile 							#value: #toggleShowFile 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowProtocol 								#defaultString: 'Show &amp;Protocol' 								#catalogID: #menus ) 							#nameKey: #showProtocol 							#value: #toggleShowProtocol 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowConflicts 								#defaultString: 'Show &amp;Conflicts' 								#catalogID: #menus ) 							#nameKey: #showConflicts 							#value: #toggleShowConflicts 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Co_nflicts 								#defaultString: 'Co&amp;nflicts' 								#catalogID: #menus ) 							#nameKey: #showConflicts 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #VerticalView 											#defaultString: '&amp;Vertical View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsVertically 										#value: #viewConflictsVertically 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #HorizontalView 											#defaultString: '&amp;Horizontal View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsHorizontally 										#value: #viewConflictsHorizontally 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SourceDifferences 											#defaultString: '&amp;Source Differences' 											#catalogID: #menus ) 										#nameKey: #highlightSourceDifferences 										#value: #highlightSourceDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #CodeDifferences 											#defaultString: 'Co&amp;de Differences' 											#catalogID: #menus ) 										#nameKey: #highlightCodeDifferences 										#value: #highlightCodeDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #EmphasizeInList 											#defaultString: '&amp;Emphasize in List' 											#catalogID: #menus ) 										#nameKey: #toggleListEmphasis 										#value: #toggleListEmphasis ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #IndicateSameMethods 											#defaultString: '&amp;Indicate Same Methods' 											#catalogID: #menus ) 										#nameKey: #toggleTypesIncludeSame 										#value: #toggleTypesIncludeSame ) ) #(2 2 2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LineEndTreatment 								#defaultString: '&amp;Line End Treatment' 								#catalogID: #menus ) 							#nameKey: #lineEndTreatment 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #AsInFile 											#defaultString: '&amp;As in File' 											#catalogID: #menus ) 										#nameKey: #lineEndsRaw 										#value: #lineEndsRaw 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #C_onvertedToCRs 											#defaultString: 'C&amp;onverted to CRs' 											#catalogID: #menus ) 										#nameKey: #lineEndsTreated 										#value: #lineEndsTreated 										#indication: true ) ) #(2 ) nil ) ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ChangeList 								#defaultString: '&amp;Change List' 								#catalogID: #menus ) 							#value: #helpChangeList 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #C_hangesAndChangeSets 								#defaultString: 'C&amp;hanges and Change Sets' 								#catalogID: #menus ) 							#value: #helpChangesAndChangeSets ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(2 1 ) nil ) ) ) #(8 ) nil ) decodeAsLiteralArray</body><body package="I18n-Tools">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ChangeList #defaultString: 'Change List' #catalogID: #labels) 			#min: #(#{Core.Point} 300 400 ) 			#bounds: #(#{Graphics.Rectangle} 512 268 942 768 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -100 1 150 0 ) 					#name: #listView 					#model: #selectionInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#toggleRemoveForListController: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #changeListMenuHolder ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 0 ) 							#model: #fileFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #file #defaultString: 'file' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 25 ) 							#model: #changeTypeFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #type #defaultString: 'type' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 50 ) 							#model: #classNameFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #class #defaultString: 'class' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 75 ) 							#model: #selectorFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #selector #defaultString: 'selector' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 100 ) 							#model: #valuesFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #same #defaultString: 'same' #catalogID: #labels) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 4 125 ) 							#model: #relativesFilterAdaptor 							#label: #(#{Kernel.UserMessage} #key: #related #defaultString: 'related' #catalogID: #labels) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -100 1 0 0 0 1 150 0 ) 						#name: #filters 						#flags: 8 ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 150 0 0 1 153 0 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 150 					#minBelowSize: 25 					#aboveWidgets: 'listView filters' 					#belowWidgets: 'textCanvas' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 153 0 0 1 0 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #standardText ) ) ) )</body></methods><methods><class-id>I18nTools.UserMessageCreationDialog class</class-id> <category>interface specs</category><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #userMessageCreation 				#defaultString: 'User Message Creation' 				#catalogID: #i18n ) 			#bounds: #(#{Graphics.Rectangle} 809 410 1112 630 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Core.Point} 5 5 ) 					#name: #Lkey 					#label: 					#(#{Kernel.UserMessage} 						#key: #keyColon 						#defaultString: 'Key:' 						#catalogID: #i18n ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 85 0 5 0 -5 1 28 0 ) 					#name: #key 					#model: #key 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 35 ) 					#name: #Lcatalog 					#label: 					#(#{Kernel.UserMessage} 						#key: #catalogColon 						#defaultString: 'Catalog:' 						#catalogID: #i18n ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 85 0 35 0 -5 1 58 0 ) 					#name: #catalog 					#model: #catalog 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 65 ) 					#name: #LdefaultString 					#label: 					#(#{Kernel.UserMessage} 						#key: #defaultStringColon 						#defaultString: 'Default String:' 						#catalogID: #i18n ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 85 0 65 0 -5 1 -34 1 ) 					#name: #defaultString 					#model: #defaultString 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -185 1 -28 1 -95 1 -5 1 ) 					#name: #ok 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #ok 						#defaultString: 'OK' 						#catalogID: #i18n ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -28 1 -5 1 -5 1 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #cancel 						#defaultString: 'Cancel' 						#catalogID: #i18n ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>I18nTools.TooLongKeyProblemNavigator class</class-id> <category>interface specs</category><body package="I18n-Tools">problemKind	&lt;problemKind&gt;	^TooLongKeyMessage</body></methods><methods><class-id>I18nTools.I18nErrorBrowser class</class-id> <category>interface specs</category><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #cascade #openType #advanced ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #ChangeBrowser 				#defaultString: 'i18n Error Browser' 				#catalogID: #i18n ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 440 405 890 853 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 20 0 -53 0.5 -5 1 ) 					#name: #List1 					#flags: 15 					#model: #changeList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateChangeList ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} -45 0.5 20 0 -4 1 -5 1 ) 					#name: #Subcanvas1 					#majorKey: #{I18nTools.I18nPatchChangeList} 					#minorKey: #windowSpec 					#clientKey: #changeView ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -50 0.5 5 0 -47 0.5 -2 1 ) 					#name: #ResizingSplitter2 					#flags: 8 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'List1 ' 					#belowWidgets: 'Subcanvas1 Label2' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Errors 						#defaultString: 'Errors' 						#catalogID: #i18n ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -45 0.5 0 0 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #MessageDefinitions 						#defaultString: 'Message Definitions' 						#catalogID: #i18n ) ) ) ) )</body></methods><methods><class-id>I18nTools.I18nErrorBrowser class</class-id> <category>resources</category><body package="I18n-Tools">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Read Catalog Report(s)...' 							#value: #scanFilename ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save Patches' 							#enabled: false 							#value: #updatePatches 							#enablementSelector: #hasModifications ) 						#(#{UI.MenuItem} 							#rawLabel: 'Exit' 							#value: #closeRequest ) ) #(2 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>I18nTools.ProblemViewer class</class-id> <category>interface specs</category><body package="I18n-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 469 228 1212 782 ) 			#flags: 4 			#menu: #menu 			#toolBar: #toolbar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 0.3 -5 1 ) 					#name: #problemNavigator 					#flags: 0 ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -4 0.3 5 0 -1 0.3 -5 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'problemNavigator' 					#belowWidgets: 'browser' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.3 5 0 -5 1 -5 1 ) 					#name: #browser 					#flags: 0 ) ) ) )</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>string contexts</category><body package="I18n-Tools">isLiteralArrayNode: aNode	&lt;stringContext: #literalArray&gt;	^((self isTagNode: aNode) or: [self isArrayNode: aNode])		and: [(self isSpecArrayNode: aNode) not]</body><body package="I18n-Tools">isMacroNode: aNode	&lt;stringContext: #macro&gt;	^aNode parent notNil and: 			[aNode parent isMessage				and: ['expandMacros*' asIs match: aNode parent selector]]</body><body package="I18n-Tools">isSourceNode: aNode	&lt;stringContext: #source&gt;	^((self isTagNode: aNode) or: [self isArrayNode: aNode]) not</body><body package="I18n-Tools">isSpecArrayNode: aNode	&lt;stringContext: #specArray&gt;	| array |	^(self isArrayNode: aNode) and: 			[array := aNode parent value.			array notEmpty and: [(array at: 1) isBindingReference]]</body></methods><methods><class-id>I18nTools.I18nRewriter</class-id> <category>templates</category><body package="I18n-Tools">evaluatingUserMessageTemplate	&lt;defaultReplacement: #userMessage&gt;	^'( &lt;1p&gt; %&lt;%&lt; &lt;2p&gt; &gt;&gt; &lt;3p&gt; ) asString' asIs</body><body package="I18n-Tools">literalArrayUserMessageTemplate	&lt;templateForContext: #literalArray replacement: #userMessage&gt;	^'#(&lt;1p&gt; &lt;2p&gt; &lt;3p&gt;)' asIs</body><body package="I18n-Tools">macroUserMessageTemplate	&lt;templateForContext: #macro replacement: #userMessage&gt;	^'&lt;1p&gt; %&lt;%&lt; &lt;2p&gt; &gt;&gt; &lt;3p&gt;' asIs</body><body package="I18n-Tools">nonI18nSourceTemplate	&lt;templateForContext: #source replacement: #nonI18n&gt;	^'&lt;1p&gt; &lt;2s&gt;' asIs</body><body package="I18n-Tools">nonI18nStringResolution: aString	&lt;templateResolution: #nonI18n&gt;	^Array with: aString with: #asIs</body><body package="I18n-Tools">specArrayUserMessageTemplate	&lt;templateForContext: #specArray replacement: #userMessage&gt;	^'#(#{Kernel.UserMessage} #key: &lt;1p&gt; #defaultString: &lt;3p&gt; #catalogID: &lt;2p&gt;)' asIs</body><body package="I18n-Tools">userMessageTemplateResolution: aUserMessage	&lt;templateResolution: #userMessage&gt;	^Array		with: aUserMessage key		with: aUserMessage catalogID		with: aUserMessage defaultString</body></methods><methods><class-id>I18nTools.I18nRewriter class</class-id> <category>instance creation</category><body package="I18n-Tools">pragmas	"stringContext: is used in methods that define in what context a string-node is. The methods with that pragma return true of false. They have a parameter which is a string node.	The context that these methods define is a symbol and the same symbol should be used in the #templateForContext:replacement: pragma. the other parameter in the template pragma is the kind of replacement the pragma is for. like #userMessage or #nonI18n.	If no stringContext is found for a node, the #defaultReplacement: tag is used	The #templateResolution pragma returns the array of arguments that are passed to the template"	&lt;pragmas: #instance&gt;	^#(#stringContext: #templateForContext:replacement: #defaultReplacement: #templateResolution:)</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>i18n</category><body package="I18n-Tools">convertToMacro	&lt;itemInMenu: #(#contextMenu) position: 51.11&gt;	^self menuItemLabeled: #convertToMacro &lt;&lt; #i18n &gt;&gt; 'Convert to Macro'		forHelper: self macroBuilder</body><body package="I18n-Tools">convertToNonI18nString	&lt;itemInMenu: #(#contextMenu) position: 51.12&gt;	^self menuItemLabeled: #convertToNonI18nString &lt;&lt; #i18n				&gt;&gt; 'Don''t internationalize String'		forHelper: self nonI18nBuilder</body><body package="I18n-Tools">convertToUserMessage	&lt;itemInMenu: #(#contextMenu) position: 51.10&gt;	^self		menuItemLabeled: #convertToUserMessage &lt;&lt; #i18n &gt;&gt; 'Convert to UserMessage'		forHelper: self userMessageBuilder</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="I18n-Tools">browseMessageCatalogs	"Open the CatalogsUI tool"	&lt;menuItem: #(#browseMessageCatalogs #i18n 'Browse Message Catalogs')		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 20.8&gt;	self openApplicationForClassNamed: #{I18nTools.CatalogsUI}</body><body package="I18n-Tools">browseMissingI18nStrings	"Find MissingI18nStrings"	&lt;menuItem: #(#browseMissingI18nStrings #i18n 'Browse Missing I18n Strings')		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 20.9&gt;	self openApplicationForClassNamed: #{I18nTools.ProblemViewer} withSelector: #findMissingI18nStrings</body><body package="I18n-Tools">openCatalogErrorBrowser	"Open a new Catalog Error Browser."	&lt;menuItem: #(#CatalogReport_Browser #i18n 'Catalog Report &amp;Browser')	icon: nil	nameKey: nil	menu: #(#menuBar #tools)	position: 20.10&gt;	self openApplicationForClassNamed: #{I18nTools.I18nErrorBrowser}</body></methods><initialize><class-id>I18nCore.UserMessageNodeFinder</class-id></initialize><initialize><class-id>I18nCore.UndefinedUserMessageCatalog</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>IndexedFileMessageCatalog</name><environment>Kernel</environment><super>Kernel.MessageCatalog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageFile index catalogID cache cacheLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>SourceCodeEditor</name><environment>Refactory.Browser</environment><super>UI.DocumentView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decorations plugins theme evaluator needsRedecoration warning parseTree parserClass acceptAnimationCancel language errorHandlerClass timingStatistics compilerClass </inst-vars><class-inst-vars>defaultTheme compilationPragmas evaluationPragmas enablement </class-inst-vars><imports>			private Text2.*			</imports><category></category><attributes><package>Browser-SourceCodeUI</package></attributes></class><class><name>MethodFilter</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>MethodDefinitionChange</name><environment>Kernel</environment><super>Kernel.MethodChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes methodSources </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ClassDefinitionChange</name><environment>Kernel</environment><super>Kernel.ClassChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassName nameSpaceName otherParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ChangeList</name><environment>Tools</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>UserMessage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString key catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>MethodCollector</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>browser interfaceWindow filter </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.RefactoringBrowser			</imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class></st-source>