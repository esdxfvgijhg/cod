<?xml version="1.0"?><st-source><!-- Name: Searchlight-ToolsNotice: MIT LicenseCopyright (c) 2008-2014 Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: Searchlight-Tools is a search engine inspired by Apple Spotlight for the Smalltalk development environment. It aggregates all the common things you search for - messages, classes, namespaces, packages, bundles, parcels, literals, etc.. in to a single search paradigm with a sophisticated set of search engine backends and criteria rules.This package adds a tool to the Visual Launcher at the bottom which lets you do a quick search for anything in the image. It also adds an incremental search window which you can open from the Visual Launcher at Browse > Searchlight. Finally, it also integrates in to the Refactoring Browsers Find: toolbar widget.This package uses the Searchlight package as its search engine backend and it combines and groups the results by type, allowing the user to get a quick glance at 4 high scoring results for each type of thing that we get hits for. If the user wants more hits, they can click on the group name and all results for that group will appear. There is always the option of going < Back if those results aren't what you're looking for too.Usually you type the prefix of a word you know is in the image, such as part of a class name or method name and Searchlight will do the rest. Weak associative searching also works where the word you're looking for may be in the middle of a name or a partial word. You can also do a special capitals-only search, such as writing MNU which is understood to match the capitals of names, eg: MNU would take you to MessageNotUnderstood.Each of the tools behaves slightly differently, as its context depends on what you want to do with it. For example, in the refactoring browser, the Find: toolbar searcher will always try and navigate you to any exact match on your search criteria. If you type in a selector, such as 'printString', you will immediately be shown implementors and senders of that message, however it may not have been what you were looking for so the < Back option is still available.The behavior of the Find: option is contrary to the Visual Launchers dock search which will not try and auto-navigate to a result, but like the browsers find, it will auto-close when you pick a result. Finally, the stand alone 'discovery' tool will shrink itself away to a minimum size when you're not doing a search, but expand with results when you are. It will not close when you click on a result, which lets you quickly navigate and explore potential results that you may be looking for without having to repeat your search again.Requires: VisualWorks 7.7+Todo+- - +	* Incremental Indexing (appears to mostly be done)		- unloading parcels/packages leaves junk behind in the cache	* ThreePaneSelectorsBrowser-like search results interface	* Hotkey for searching	* Comment indexing (is this desirable?)	* Memory usage optimizationsDbIdentifier: bear73DbTrace: 498938DbUsername: smichaelDbVersion: 333DevelopmentPrerequisites: #(#(#any 'Assets' '') #(#any 'Searchlight-Core' '') #(#any 'Searchlight-Query' ''))DialectVersion: VisualWorks 7.9ExplicitPrerequisites: #()IgnoredPrerequisites: #('ProgrammingExtensions')PackageName: Searchlight-ToolsParcel: #('Searchlight-Tools')PrerequisiteDescriptions: #(#(#name 'Assets') #(#name 'Searchlight-Core' #componentType #package) #(#name 'Searchlight-Query'))PrerequisiteParcels: #(#('Assets' '') #('Searchlight-Core' '') #('Searchlight-Query' ''))PrintStringCache: (333,smichael)Version: 333Date: 1:31:42 PM March 3, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (mar17.1) of March 3, 2017 on March 3, 2017 at 1:31:42 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Icons</name><environment>Searchlight</environment><super>Core.Assets</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Searchlight</category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.Icons</class-id><body>Icons are assets for Searchlights tools</body></comment><class><name>ControllerView</name><environment>Searchlight</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.ControllerView</class-id><body>ControllerView is a view that is its own controller too. This class handles its own events, both mouse and keyboard, instead of using a Controller to do that for it. The class also comes with a simple state machine based on a single symbol that represents the views currents state.There are several standard states that the view might be in at any one time:	* idle 	- this is the default state, it indicates that there is no activity going on, the mouse is not even over us	* active	- this indicates that the mouse is over us but more specifically, over one of our children, so we are not the direct focus of attention by the user	* over	- this indicates that the mouse is over us explicity and we have focus of activityThe @children dictionary is used as an analog for the CompositePart. The add behavior is used to setup children, usually during #initialize but it can be done at any time. @children is an OrderedDictionary that maps between your real view and the wrappers that wrap up that view. This duality is important because generally you want to manipulate your view directly and manipulate the wrappers during a layout event.When layout occurs in the VisualComponent hierarchy we are told that #bounds: has changed. At this point, the method #layout is called to provide an opportunity to layout the views that you created during #initialize or at some other point. This is generally done by calling the various #layout: methods which know that the layout wrapper of your view is the value for the key of your view in the @children dictionary.The mouse events that come to us are passed to the wrappers for our @children so that they can be coordinate translated / scroll offset to the children that you actually created. In the process of identifying who should handle the event, various signals are fired (which should be turned in to Announcements) and state changes may occur.When a state change occurs, by sending #setState:, if the new state is the same as the old state nothing will happen. If the state is different, the new state is set and the view is invalidated immediately to be redrawn in its new persona. Whenever an event arrives on our view, such as MouseMovedEvent, the event is sent to our instance as &lt;state name&gt;&lt;event class name&gt;: - eg: #overMouseMovedEvent: - this is the general state machine that allows rapid development of widget behavior.When a state changes, a &lt;old state name&gt;Leave method will be called on us and also a &lt;new state name&gt;Enter method will also be sent. If any particular event or state change method doesn't exist on our class, we declare that we don't handle that event and return ^nil as our event handler. This allows wrapping widgets to capture mouse wheel events, etc even though the event was specifically sent to us. This also means you only have to implement the event methods that you actually want to respond to on your view.Instance Variables:	children	&lt;(OrderedDictionary of: VisualComponent and: Wrapper)&gt;	the children that we will render and interact with	state	&lt;Symbol&gt;	the current state of the widget</body></comment><class><name>ActiveLabelView</name><environment>Searchlight</environment><super>Searchlight.ControllerView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.ActiveLabelView</class-id><body>ActiveLabelView is a Label that has mouse behavior.Instance Variables:	label	&lt;ActiveLabelView&gt;	the label that does the font alignment, icon aligntment, extent calculating and drawing</body></comment><class><name>SnippetSensor</name><environment>Searchlight</environment><super>UI.EventSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.SnippetSensor</class-id><body>SnippetSensor is a private class to deal with hover help events</body></comment><class><name>SearchView</name><environment>Searchlight</environment><super>Searchlight.ControllerView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultsView searchResults titleView history mode browser closeOnSelect abortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.SearchView</class-id><body>SearchView is the main UI widget for representing a SearchEngine's results.Instance Variables:	browser	&lt;RefactoringBrowser&gt;	the refactoring browser we should navigate to when we click on a result	closeOnSelect	&lt;Boolean&gt;	as soon as the user has selected something, should we close?	history	&lt;OrderedCollection&gt;	the history of results we've nagivated through so we can go '&lt; back'	mode	&lt;Symbol&gt;	the mode we're using to display the results, eg: summary, all, group	resultsView	&lt;ResultsView&gt;	the results view instance we use to display our results	searchResults	&lt;(Collection of: (Result))&gt;	the results we got back from doing the search	titleView	&lt;ActiveLabelView&gt;	the title view at the top of our rendering which usually contains the '&lt; back' option</body></comment><class><name>OrderedDictionary</name><environment>Searchlight</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Convenience</category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.OrderedDictionary</class-id><body>OrderedDictionary is a Dictionary with ordered keys.Instance Variables:	keys	&lt;OrderedCollection&gt;	description of keys	values	&lt;OrderedCollection&gt;	description of values</body></comment><class><name>DiscoveryToolDock</name><environment>Searchlight</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>search popupWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSpotlight</category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.DiscoveryToolDock</class-id><body>DiscoveryToolDock adds Searchlight to the Launchers tools dockInstance Variables:	popupWindow	&lt;ScheduledWindow&gt;	the window we popup with the search results	search	&lt;ValueModel&gt;	the search criteria aspect</body></comment><class><name>ResultsView</name><environment>Searchlight</environment><super>Searchlight.ControllerView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchResults browser snippetWindow abortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.ResultsView</class-id><body>ResultsView is a widget that renders search results as Group -&gt; Results.Instance Variables:	browser	&lt;RefactoryBrowser&gt;	the browser we should use if we want to navigate to a result	searchResults	&lt;Dictionary&gt;	the views we create to represent the search results	snippetWindow	&lt;SnippetWindow&gt;	the window we popup as our snippet 'hover help'</body></comment><class><name>SnippetWindow</name><environment>Searchlight</environment><super>UI.TransientWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.SnippetWindow</class-id><body>SnippetWindow is the hover help window for ResultsView</body></comment><class><name>DiscoveryWindow</name><environment>Searchlight</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchView search updateProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSpotlight</category><attributes><package>Searchlight-Tools</package></attributes></class><comment><class-id>Searchlight.DiscoveryWindow</class-id><body>DiscoveryWindow is a stand alone window for doing searches with Spotlight. It auto-resizes itself based on the number of available search results.Instance Variables:	searchView	&lt;SearchView&gt;	the search view instance	search	&lt;ValueModel&gt;	the search criteria aspect</body></comment><methods><class-id>Searchlight.ControllerView</class-id> <category>children</category><body package="Searchlight-Tools">add: aVisualPart	children at: aVisualPart put: ((BoundedWrapper on: aVisualPart) container: self).	^aVisualPart</body><body package="Searchlight-Tools">addScrolling: aVisualPart	children at: aVisualPart put: ((BoundedWrapper on: (BorderDecorator on: aVisualPart) noBorder) container: self).	^aVisualPart</body><body package="Searchlight-Tools">layout	"subclasses override to position the bounded wrappers for their children "</body><body package="Searchlight-Tools">layout: aVisualPart at: origin	self		layout: aVisualPart		origin: origin		extent: aVisualPart preferredExtent</body><body package="Searchlight-Tools">layout: aVisualPart bounds: bounds	(children at: aVisualPart) bounds: bounds</body><body package="Searchlight-Tools">layout: aVisualPart origin: origin corner: corner	self layout: aVisualPart bounds: (origin corner: corner)</body><body package="Searchlight-Tools">layout: aVisualPart origin: origin extent: extent	self layout: aVisualPart bounds: (origin extent: extent)</body><body package="Searchlight-Tools">remove: aVisualPart	children removeKey: aVisualPart.	aVisualPart release</body><body package="Searchlight-Tools">reset	children do: [:each | each release].	children := OrderedDictionary new</body><body package="Searchlight-Tools">swap: aVisualPart with: aNewVisualPart	(children at: aVisualPart) component: aNewVisualPart.	children at: aNewVisualPart put: (children at: aVisualPart).	children removeKey: aVisualPart.	aVisualPart release.	^aNewVisualPart</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>event driven</category><body package="Searchlight-Tools">anyfocusKeypressEvent: aKeyboardEvent	^false</body><body package="Searchlight-Tools">desiresFocus	"Default desiresFocus to false. Views that want keyboard focus have to redefine this method."	^false</body><body package="Searchlight-Tools">getEventHandler	^self</body><body package="Searchlight-Tools">handleEvent: anEvent	| selector |	self triggerEvent: anEvent class name with: anEvent.	(selector := self handlerForEvent: anEvent) ifNil: [^nil].	self perform: selector with: anEvent</body><body package="Searchlight-Tools">handlerForEvent: anEvent	| selector |	selector := (state , anEvent class name , ':') asSymbol.	(self respondsTo: selector) ifTrue: [^selector].	selector := (anEvent class name, ':') asSymbol.	(self respondsTo: selector) ifTrue: [^selector].	^nil</body><body package="Searchlight-Tools">handlerForMouseEvent: aMouseEvent	children values reverseDo: [:each | (each handlerForMouseEvent: aMouseEvent) ifNotNil: [:handler |		(state = #idle or: [state = #over]) ifTrue: [self setState: #active].		^handler]].	^(self viewHasCursorWithEvent: aMouseEvent) 		ifTrue:			[(state = #active or: [state = #idle]) ifTrue: [self setState: #over].			self triggerEvent: aMouseEvent class name with: aMouseEvent.			(self handlerForEvent: aMouseEvent) ifNotNil: [self getEventHandler]]		ifFalse:			[self setState: #idle.			nil]</body><body package="Searchlight-Tools">sensor	self topComponent ifNil: [^nil].	self topComponent sensor ifNil: [^nil].	^self topComponent sensor translatingSensor		view: self;		yourself</body><body package="Searchlight-Tools">takeKeyboardFocus	self keyboardProcessor ifNotNil: [:kp | kp requestActivationFor: self]</body><body package="Searchlight-Tools">viewContainsCursor	"Similar to #viewHasCursor, but does not care whether the containing 	window is active or not - in other words, only does the bounds check."	| sensor |	sensor := self sensor.	^sensor notNil and: [self bounds containsPoint: sensor cursorPoint]</body><body package="Searchlight-Tools">viewHasCursor	"Answer true if the cursor point of the receiver's sensor lies within 	the display box of the receiver's view. #viewHasCursor is 	normally used in internal methods."	| sensor |	sensor := self sensor.	^sensor notNil and: [sensor isActive and: [self bounds containsPoint: sensor cursorPoint]]</body><body package="Searchlight-Tools">viewHasCursorWithEvent: event	"Answer true if the cursor point of the receiver's sensor lies within 	the display box of the receiver's view. #viewHasCursor is 	normally used in internal methods."	| sensor |	event hasPoint ifFalse: [^false].	sensor := self sensor.	^sensor notNil and: [self bounds containsPoint: (sensor cursorPointFor: event)]</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>event states</category><body package="Searchlight-Tools">KeyPressedEvent: event	self keyboardProcessor ifNotNil: [:kp |		event isBackTab ifTrue: [^kp prevFieldFrom: self].		event keyValue == Character tab ifTrue: [^kp nextFieldFrom: self]]</body><body package="Searchlight-Tools">activate	self hasControl.	self invalidateNow</body><body package="Searchlight-Tools">deactivate	InputManager default focusView: nil.	self invalidate</body><body package="Searchlight-Tools">hasControl	InputManager default focusView: self</body><body package="Searchlight-Tools">hasFocus	self keyboardProcessor ifNotNil: [:kp | ^kp focusedEventHandler == self].	^false</body><body package="Searchlight-Tools">setState: newState	| leaveSelector enterSelector |	state = newState ifTrue: [^self]."	Transcript cr; show: self class name, ' ', self identityHash printString, ' from ', state, ' to ', newState."	leaveSelector := (state, 'Leave') asSymbol.	enterSelector := (newState, 'Enter') asSymbol.	(self respondsTo: leaveSelector) ifTrue: [self perform: leaveSelector].	self triggerEvent: leaveSelector.	state := newState.	(self respondsTo: enterSelector) ifTrue: [self perform: enterSelector].	self triggerEvent: enterSelector.	self invalidateNow</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>bounds accessing</category><body package="Searchlight-Tools">bounds: newBounds	super bounds: newBounds.	self layout</body><body package="Searchlight-Tools">preferredExtent	^children inject: Point zero into: [ :extent :child | extent max: child bounds corner].</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>initialize-release</category><body package="Searchlight-Tools">initialize	super initialize.	children := OrderedDictionary new.	state := #idle</body><body package="Searchlight-Tools">newGraphicsDevice: aGraphicsDevice	"Forward the newGraphicsDevice: aGraphicsDevice messages	to the receiver's components."	super newGraphicsDevice: aGraphicsDevice.	children do: [:component | component newGraphicsDevice: aGraphicsDevice]</body><body package="Searchlight-Tools">release	children do: [:each | each release].	super release</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>displaying</category><body package="Searchlight-Tools">displayOn: aGraphicsContext	| clipBox |	clipBox := aGraphicsContext clippingBounds.	children do: [:aBoundedWrapper |		(aBoundedWrapper intersects: clipBox) ifTrue: [aBoundedWrapper displayOn: aGraphicsContext copy]]</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>event dispatching</category><body package="Searchlight-Tools">checkForAccept	"Check to see whether the receiver needs to accept edits."</body><body package="Searchlight-Tools">checkForAcceptWithValidation	"Check to see whether the receiver needs to accept edits.	If so, allow any validation to run and, if it succeeds, do the	accept.  Return true if the receiver has accepted, false if	the receiver still has unaccepted changes due to validation	failure."	^true</body><body package="Searchlight-Tools">checkForAutoAccept	"If the receiver has been set to AutoAccept, check to see whether	it needs to accept edits."</body><body package="Searchlight-Tools">checkForAutoAcceptWithValidation	"If the receiver has been set to AutoAccept, check to see whether	it needs to accept edits.  If so, allow any validation to run and, if	it succeeds, do the accept."	^true</body><body package="Searchlight-Tools">requestFocusIn	"Ask any interested parties if it is ok for the receiver to take keyboard 	focus."	^true</body><body package="Searchlight-Tools">requestFocusOut	"Ask any interested parties if it is ok for the receiver to give up 	keyboard focus."	^true</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>private</category><body package="Searchlight-Tools">componentHierarchyChildren	^self components</body><body package="Searchlight-Tools">controller	^self</body><body package="Searchlight-Tools">visit: aVisitor	aVisitor visitVisualComponent: self.	aVisitor visitComposite: self</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>accessing</category><body package="Searchlight-Tools">children	^children</body><body package="Searchlight-Tools">childrenDo: aBlock	children do: aBlock</body><body package="Searchlight-Tools">components	^children values</body><body package="Searchlight-Tools">view	^ self</body></methods><methods><class-id>Searchlight.ControllerView</class-id> <category>uilayout</category><body package="Searchlight-Tools">layoutComponentSubtreeIfNeeded	self components do: #layoutComponentSubtreeIfNeeded.</body></methods><methods><class-id>Searchlight.ControllerView class</class-id> <category>private-events</category><body package="Searchlight-Tools">ambivalentEventChecking	^true</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>event states</category><body package="Searchlight-Tools">KeyReleasedEvent: event	event keyValue == Character space ifTrue: [^self click].	event keyValue == Character cr ifTrue: [^self click]</body><body package="Searchlight-Tools">overRedButtonPressedEvent: anEvent	self sensor grabMouseEventFor: self.	self setState: #pressed</body><body package="Searchlight-Tools">pressedRedButtonReleasedEvent: anEvent	self sensor ungrabMouseEventFor: self.	(self viewHasCursorWithEvent: anEvent)		ifTrue:	[self setState: #active. self click]		ifFalse:	[self setState: #idle]</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>initialize-release</category><body package="Searchlight-Tools">initialize	super initialize.	label := LabelAndIcon new</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>accessing</category><body package="Searchlight-Tools">height	^label height</body><body package="Searchlight-Tools">icon	^label icon</body><body package="Searchlight-Tools">icon: anObject	label icon: anObject</body><body package="Searchlight-Tools">text	^label text</body><body package="Searchlight-Tools">text: anObject	label text: anObject</body><body package="Searchlight-Tools">width	^label width</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>printing</category><body package="Searchlight-Tools">printOn: stream	self text ifNil: [^super printOn: stream].	stream nextPutAll: self text</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>event driven</category><body package="Searchlight-Tools">desiresFocus	^true</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>actions</category><body package="Searchlight-Tools">click	self triggerEvent: #click</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>displaying</category><body package="Searchlight-Tools">displayOn: aGraphicsContext	state = #over		ifTrue:	[aGraphicsContext paint: ColorValue blue]		ifFalse:	[aGraphicsContext paint: ColorValue black].	state = #pressed ifTrue: [aGraphicsContext paint: (ColorValue red: 0.25 green: 0 blue: 1)].	self hasFocus ifTrue: [aGraphicsContext paint: (ColorValue red: 0.25 green: 0 blue: 1)].	label displayOn: aGraphicsContext</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>focus control</category><body package="Searchlight-Tools">isTabStop	^true</body></methods><methods><class-id>Searchlight.ActiveLabelView</class-id> <category>bounds accessing</category><body package="Searchlight-Tools">preferredExtent	^label preferredExtent</body></methods><methods><class-id>Searchlight.SnippetSensor</class-id> <category>event processing</category><body package="Searchlight-Tools">notifyTooltipSystemOfActivity	self window recycle</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>modes</category><body package="Searchlight-Tools">allNext	self modePop</body><body package="Searchlight-Tools">allResults	| results groupedResults |	results := searchResults groupedBy: [:each | each type].	results do: [:each | self sortResults: each].	groupedResults := Dictionary new.	results keysAndValuesDo: [:group :all | groupedResults at: (group -&gt; all size) put: all].	^groupedResults</body><body package="Searchlight-Tools">allTitle	^'&lt; Back'</body><body package="Searchlight-Tools">groupNext	self modePop</body><body package="Searchlight-Tools">groupResults	^self allResults</body><body package="Searchlight-Tools">groupTitle	^'&lt; Back'</body><body package="Searchlight-Tools">summaryNext	history isEmpty		ifTrue:	[self modePush: #all]		ifFalse:	[self modePop]</body><body package="Searchlight-Tools">summaryResults	| results groupedResults |	results := searchResults groupedBy: [:each | each type].	results do: [:each | self sortResults: each].	groupedResults := Dictionary new.	results keysAndValuesDo: [:group :all | groupedResults at: (group -&gt; all size) put: (all first: 5)].	^groupedResults</body><body package="Searchlight-Tools">summaryTitle	^history isEmpty		ifTrue:	['View All Results (', searchResults size printString, ')']		ifFalse:	['&lt; Back']</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>private</category><body package="Searchlight-Tools">applyMode	| resultsSelector titleSelector |	resultsSelector := (mode, 'Results') asSymbol.	titleSelector := (mode, 'Title') asSymbol.	resultsView initialize: (self perform: resultsSelector).	titleView text: (self perform: titleSelector).	self layout.	self invalidate</body><body package="Searchlight-Tools">modePop	| previousHistory |	previousHistory := history removeLast.	mode := previousHistory key.	searchResults := previousHistory value.	self applyMode</body><body package="Searchlight-Tools">modePush: aMode	self modePush: aMode do: []</body><body package="Searchlight-Tools">modePush: aMode do: aBlock	history add: mode -&gt; searchResults.	mode := aMode.	aBlock value.	self applyMode</body><body package="Searchlight-Tools">sortResults: results	results sort: [:a :b | a score = b score ifTrue: [a sortString &lt;= b sortString] ifFalse: [a score &lt; b score]]</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>actions</category><body package="Searchlight-Tools">clickedGroup: group	mode = #group ifTrue: [^self modePop].	self modePush: #group do: [searchResults := searchResults select: [:each | each type = group]]</body><body package="Searchlight-Tools">clickedResult: result	closeOnSelect ifTrue: [self topComponent controller closeAndUnschedule]</body><body package="Searchlight-Tools">clickedSymbol: symbol	self modePush: #summary do:		[Cursor wait showWhile: [searchResults := SearchReferences search: symbol]]</body><body package="Searchlight-Tools">clickedTitle	self perform: (mode, 'Next') asSymbol</body><body package="Searchlight-Tools">search: criteria	Cursor wait showWhile: [self initialize: (SearchImage search: criteria) mode: #summary]</body><body package="Searchlight-Tools">searchReferences: object	Cursor wait showWhile: [self initialize: (SearchReferences search: object) mode: #summary]</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>accessing</category><body package="Searchlight-Tools">abortBlock	^abortBlock</body><body package="Searchlight-Tools">abortBlock: anObject	abortBlock := anObject.	resultsView abortBlock: anObject</body><body package="Searchlight-Tools">browser	^browser</body><body package="Searchlight-Tools">browser: anObject	browser := anObject.	resultsView browser: browser</body><body package="Searchlight-Tools">closeOnSelect	^closeOnSelect</body><body package="Searchlight-Tools">closeOnSelect: anObject	closeOnSelect := anObject</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>children</category><body package="Searchlight-Tools">layout	self layout: titleView origin: (self bounds width - titleView width) half @ 0 extent: titleView width @ titleView height.	self layout: resultsView origin: 0 @ titleView height corner: self bounds corner</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>initialize-release</category><body package="Searchlight-Tools">initialize	super initialize.	searchResults := OrderedCollection new.	history := OrderedCollection new.	closeOnSelect := false.	abortBlock := [self topComponent controller closeAndUnschedule].	self add: (titleView := ActiveLabelView new).	titleView when: #click send: #clickedTitle to: self.	titleView when: #KeyReleasedEvent send: #KeyReleasedEvent: to: self.	self addScrolling: (resultsView := ResultsView new).	resultsView abortBlock: abortBlock.	resultsView when: #clickedGroup: send: #clickedGroup: to: self.	resultsView when: #clickedResult: send: #clickedResult: to: self.	resultsView when: #clickedSymbol: send: #clickedSymbol: to: self</body><body package="Searchlight-Tools">initialize: results mode: aMode	searchResults := results.	history := OrderedCollection new.	mode := aMode.	self applyMode</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>event states</category><body package="Searchlight-Tools">KeyReleasedEvent: event	event keyValue == Character esc ifTrue: [^abortBlock value]</body></methods><methods><class-id>Searchlight.SearchView</class-id> <category>bounds accessing</category><body package="Searchlight-Tools">preferredExtent	^searchResults isEmpty		ifTrue: [ Point zero]		ifFalse: [ super preferredExtent ]</body></methods><methods><class-id>Searchlight.OrderedDictionary</class-id> <category>initialize-release</category><body package="Searchlight-Tools">initializeWithSize: allocationSize	keys := OrderedCollection new: allocationSize.	values := OrderedCollection new: allocationSize</body></methods><methods><class-id>Searchlight.OrderedDictionary</class-id> <category>removing</category><body package="Searchlight-Tools">remove: oldObject ifAbsent: anExceptionBlock	| index |	index := self indexForObject: oldObject.	index = 0 ifTrue: [^anExceptionBlock value].	keys removeIndex: index.	values removeIndex: index</body><body package="Searchlight-Tools">removeKey: key ifAbsent: aBlock	| index |	index := self indexForKey: key.	index = 0 ifTrue: [^aBlock value].	keys removeIndex: index.	values removeIndex: index</body></methods><methods><class-id>Searchlight.OrderedDictionary</class-id> <category>private</category><body package="Searchlight-Tools">indexForKey: key	^keys indexOf: key</body><body package="Searchlight-Tools">indexForObject: oldObject	^values indexOf: oldObject</body></methods><methods><class-id>Searchlight.OrderedDictionary</class-id> <category>accessing</category><body package="Searchlight-Tools">at: key ifAbsent: aBlock	| index |	index := self indexForKey: key.	index = 0 ifTrue: [^aBlock value].	^values at: index</body><body package="Searchlight-Tools">at: key put: value	self removeKey: key ifAbsent: [].	keys add: key.	values add: value.	^value</body></methods><methods><class-id>Searchlight.OrderedDictionary</class-id> <category>adding</category><body package="Searchlight-Tools">add: anAssociation	self at: anAssociation key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>Searchlight.OrderedDictionary</class-id> <category>enumerating</category><body package="Searchlight-Tools">keysAndValuesDo: aBlock	^keys with: values do: aBlock</body></methods><methods><class-id>Searchlight.OrderedDictionary class</class-id> <category>instance creation</category><body package="Searchlight-Tools">new	^self new: 10</body><body package="Searchlight-Tools">new: allocationSize	^super new initializeWithSize: allocationSize</body></methods><methods><class-id>Searchlight.DiscoveryToolDock</class-id> <category>private</category><body package="Searchlight-Tools">closePopupWindow	popupWindow ifNotNil:		[popupWindow controller closeAndUnschedule.		popupWindow := nil]</body><body package="Searchlight-Tools">displaySearchFor	self search value: self offerOfSearch</body><body package="Searchlight-Tools">nothingToSearchFor	self closePopupWindow.	self displaySearchFor</body><body package="Searchlight-Tools">offerOfSearch	^'Search for...' asText emphasizeAllWith: #color -&gt; ColorValue lightGray</body><body package="Searchlight-Tools">popupBounds	| displayBox origin extent |	displayBox := self mainWindow getDisplayBox.	origin := displayBox bottomLeft + self sizeOfWindowTitle.	extent := displayBox width @ 550.	^origin extent: extent</body><body package="Searchlight-Tools">sizeOfWindowTitle	^-1 @ 24</body></methods><methods><class-id>Searchlight.DiscoveryToolDock</class-id> <category>events</category><body package="Searchlight-Tools">searchChanged	| searchView criteria |	criteria := (self widgetAt: #search) editValue asString.	criteria isEmpty ifTrue: [^self nothingToSearchFor].	self closePopupWindow.	(searchView := SearchView new)		search: criteria;		closeOnSelect: true.	(popupWindow := ScheduledWindow new)		damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new;		label: criteria;		background: SymbolicPaint background;		component: searchView;		openIn: self popupBounds</body><body package="Searchlight-Tools">searchEntry: ctrl	self search value = self offerOfSearch ifTrue: [self search value: String new].	^true</body></methods><methods><class-id>Searchlight.DiscoveryToolDock</class-id> <category>aspects</category><body package="Searchlight-Tools">search	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^search isNil		ifTrue:			[search := String new asValue]		ifFalse:			[search]</body></methods><methods><class-id>Searchlight.DiscoveryToolDock</class-id> <category>initialize-release</category><body package="Searchlight-Tools">initialize	super initialize.	self displaySearchFor</body><body package="Searchlight-Tools">intrinsicHeight	^25</body></methods><methods><class-id>Searchlight.DiscoveryToolDock</class-id> <category>interface opening</category><body package="Searchlight-Tools">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	(self controllerAt: #search) crBlock: [:event | self searchChanged]</body></methods><methods><class-id>Searchlight.DiscoveryToolDock</class-id> <category>view accessing</category><body package="Searchlight-Tools">mainWindow	^(self widgetAt: #search) topComponent</body></methods><methods><class-id>Searchlight.DiscoveryToolDock class</class-id> <category>accessing</category><body package="Searchlight-Tools">visualLauncherToolDockSize	^ 3</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>properties</category><body package="Searchlight-Tools">groupBackgroundAlternateColor	^self backgroundColor asColorValue blendWith: (ColorValue red: 0.90 green: 0.90 blue: 1)</body><body package="Searchlight-Tools">groupBackgroundColor	^self backgroundColor asColorValue blendWith: (ColorValue red: 0.95 green: 0.95 blue: 1)</body><body package="Searchlight-Tools">groupPaddingLeft	^5</body><body package="Searchlight-Tools">groupPaddingRight	^5</body><body package="Searchlight-Tools">resultPaddingLeft	^5</body><body package="Searchlight-Tools">snippetBackgroundColor	^ ColorValue brightness: 0.99</body><body package="Searchlight-Tools">splitterColor	^self backgroundColor asColorValue blendWith: ColorValue gray</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>actions</category><body package="Searchlight-Tools">clickedGroup: group	self closeSnippetWindow.	self triggerEvent: #clickedGroup: with: group</body><body package="Searchlight-Tools">clickedResult: result	self closeSnippetWindow.	result object isSymbol ifTrue: [^self triggerEvent: #clickedSymbol: with: result object].	result object searchlightBrowse: (result object searchlightNeedsBrowser ifTrue: [self browser] ifFalse: [nil]).	self triggerEvent: #clickedResult: with: result</body><body package="Searchlight-Tools">rightClickBrowse: result	self clickedResult: result</body><body package="Searchlight-Tools">rightClickEvent: anEvent result: result	| menuItem |	self closeSnippetWindow.	menuItem := (MenuView model: self class contextMenu) openFromView: self topComponent event: anEvent.	menuItem ifNil: [^self].	self perform: menuItem value with: result</body><body package="Searchlight-Tools">rightClickReferences: result	self triggerEvent: #clickedSymbol: with: result object</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>event states</category><body package="Searchlight-Tools">KeyReleasedEvent: event	event keyValue == Character esc ifTrue: [^abortBlock value]</body><body package="Searchlight-Tools">activeMouseWheelEvent: anEvent	anEvent up		ifTrue: [container scrollVertically: self lineHeight * 4]		ifFalse: [container scrollVertically: self lineHeight negated * 4]</body><body package="Searchlight-Tools">idleEnter	self closeSnippetWindow</body><body package="Searchlight-Tools">overEnter	self closeSnippetWindow</body><body package="Searchlight-Tools">overMouseWheelEvent: anEvent	self activeMouseWheelEvent: anEvent</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>accessing</category><body package="Searchlight-Tools">abortBlock	^abortBlock</body><body package="Searchlight-Tools">abortBlock: anObject	abortBlock := anObject</body><body package="Searchlight-Tools">browser	browser ifNil: [^browser := self newBrowser].	browser builder window isOpen ifFalse: [^browser := self newBrowser].	^browser</body><body package="Searchlight-Tools">browser: aBrowser	browser := aBrowser</body><body package="Searchlight-Tools">defaultGroups	^OrderedCollection new		add: Implementor;		add: Reference;		addAll: Symbol withAllSubclasses;		add: Store.BundleModel;		add: Store.PackageModel;		add: NameSpace;		add: Class;		add: CompiledMethod;		add: Parcel;		add: InstanceVariable;		add: SharedVariable;		add: MethodLiteral;		add: Object;		yourself</body><body package="Searchlight-Tools">lineHeight	^TextAttributes defaultNoCopy lineGrid</body><body package="Searchlight-Tools">split	| split |	split := 0.	searchResults keysAndValuesDo: [:group :results | split := split max: group width].	split := split + self groupPaddingLeft + self groupPaddingRight.	^split</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>snippets</category><body package="Searchlight-Tools">closeSnippetWindow	snippetWindow notNil 		ifTrue: 		[ 	snippetWindow close.			snippetWindow := nil 		 ]</body><body package="Searchlight-Tools">maxSnippetExtentForScreenBounds: screenBounds	^ screenBounds extent // 4</body><body package="Searchlight-Tools">openNewSnippetWindowWith: snippetComponent in: box 	snippetWindow := SnippetWindow newIn: box withType: #popUp masterWindow: self topComponent.	snippetWindow		windowManager: NullWindowManager new;		setBackground: self snippetBackgroundColor;		component: snippetComponent;		map</body><body package="Searchlight-Tools">openSnippetWith: snippetComponent in: box 	snippetWindow notNil 		ifTrue: [  self reopenSnippetWindowWith: snippetComponent in: box  ]		ifFalse: [  self openNewSnippetWindowWith: snippetComponent in: box  ]</body><body package="Searchlight-Tools">reopenSnippetWindowWith: snippetComponent in: box 	snippetWindow reopenWith: snippetComponent in: box</body><body package="Searchlight-Tools">shouldShowSnippet	self viewHasCursor ifTrue: [^true].	^snippetWindow notNil and: [snippetWindow isActive]</body><body package="Searchlight-Tools">showSnippet: result	| snippet snippetComponent box |	self shouldShowSnippet ifFalse: [^self].	snippet := result displaySnippet.	snippet isNil 		ifTrue: [  self closeSnippetWindow  ]		ifFalse: 		[ 	snippetComponent := self wrapSnippet: snippet.			box := self snippetBoundsFor: snippetComponent.			snippetComponent bounds: (0 @ 0 extent: box extent).			self openSnippetWith: snippetComponent in: box.		 ]</body><body package="Searchlight-Tools">snippetBoundsFor: snippetComponent	| win origin maxBounds boxExtent screenBounds |	win := self topComponent.	origin := win globalOrigin x @ InputState default mousePoint y.	screenBounds := Screen default boundsAround: origin.	screenBounds isNil ifTrue: [screenBounds := Screen default bounds].	" don't be too greedy "	maxBounds := self maxSnippetExtentForScreenBounds: screenBounds.	boxExtent := (snippetComponent preferredExtent min: maxBounds) + (4 @ 4).	" is there enough room to the the right? "	origin := screenBounds width - (origin x + win width) &gt;= boxExtent x				ifTrue: [origin + (win width @ 0)]				ifFalse: [origin - (boxExtent x @ 0) - (5 @ 5)].	^origin extent: boxExtent</body><body package="Searchlight-Tools">wrapSnippet: aStringOrText 	| text wrapper foregroundPaint |	text := ComposedText 				withText: aStringOrText				style: self widgetPolicy lookPolicyClass systemTextStyle.	foregroundPaint := ColorValue black.	wrapper := BorderedWrapper on: (TranslatingWrapper on: text at: 2 @ 0).	wrapper		borderColor: foregroundPaint;		inset: 1.	^ wrapper</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>private</category><body package="Searchlight-Tools">newBrowser	^Refactory.Browser.RefactoringBrowser open</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>displaying</category><body package="Searchlight-Tools">displayGroupBackgroundAt: split bottom: bottom on: aGraphicsContext	| positions y1 |	searchResults size &lt; 2 ifTrue:		[aGraphicsContext paint: self groupBackgroundColor. 		aGraphicsContext displayRectangle: (Point zero extent: split @ (self bounds height max: bottom)).		^self].	positions := searchResults keys collect: [:each | each container bounds top].	positions add: (self bounds height max: bottom).	y1 := positions removeFirst.	positions keysAndValuesDo: [:index :y2 |		index odd			ifTrue:	[aGraphicsContext paint: self groupBackgroundColor]			ifFalse:	[aGraphicsContext paint: self groupBackgroundAlternateColor].		aGraphicsContext displayRectangle: ((0 @ y1) corner: (split @ y2)).		y1 := y2]</body><body package="Searchlight-Tools">displayOn: aGraphicsContext	| split clippingBounds clippingTop clippingBottom |	clippingBounds := aGraphicsContext clippingBounds.	clippingTop := clippingBounds top - self lineHeight.	clippingBottom := clippingBounds bottom + self lineHeight.	split := self split.	self displayGroupBackgroundAt: split bottom: clippingBottom on: aGraphicsContext.	self displaySplitterAt: split top: clippingTop bottom: clippingBottom on: aGraphicsContext.	super displayOn: aGraphicsContext</body><body package="Searchlight-Tools">displaySplitterAt: split top: top bottom: bottom on: aGraphicsContext	aGraphicsContext paint: self splitterColor.	aGraphicsContext		displayLineFrom: split @ (0 max: top)		to: split @ (self bounds height max: bottom)</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>initialize-release</category><body package="Searchlight-Tools">groups: allGroups	| groups |	groups := self defaultGroups.	allGroups do: [:each | (groups includes: each key) ifFalse: [groups add: each key]].	^groups</body><body package="Searchlight-Tools">initialize	super initialize.	searchResults := Dictionary new</body><body package="Searchlight-Tools">initialize: groupedResults	self reset.	searchResults := OrderedDictionary new.	(self groups: groupedResults keys) do: [:type |		| group results groupDisplayString |		results := #().		group := Object -&gt; 0.		groupedResults keysAndValuesDo: [:each :theResults | each key = type ifTrue: [group := each. results := theResults]].		results notEmpty ifTrue:			[groupDisplayString := group key groupDisplayString.			results size &lt; group value ifTrue: [groupDisplayString := groupDisplayString, ' (', group value printString, ')'].			searchResults				at: (self add: (ActiveLabelView new					text: groupDisplayString asText allBold;					when: #click send: #clickedGroup: to: self with: group key;					when: #KeyReleasedEvent send: #KeyReleasedEvent: to: self;					yourself))				put: (results collect: [:result |					self add: (ActiveLabelView new						text: result displayString;						icon: result displayIcon;						when: #click send: #clickedResult: to: self with: result;						when: #YellowButtonReleasedEvent send: #rightClickEvent:result: to: self with: nil with: result;						when: #KeyReleasedEvent send: #KeyReleasedEvent: to: self;						when: #overEnter send: #showSnippet: to: self with: result;						yourself)])]]</body><body package="Searchlight-Tools">release	self closeSnippetWindow.	super release</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>children</category><body package="Searchlight-Tools">layout	| y split |	y := 0.	split := self split.	searchResults keysAndValuesDo: [:group :results |		self layout: group at: (split - self groupPaddingRight - group width)@y.		results do: [:result |			self layout: result at: (split + self resultPaddingLeft) @y.			y := y + self lineHeight]]</body></methods><methods><class-id>Searchlight.SnippetWindow</class-id> <category>private</category><body package="Searchlight-Tools">recycle	component ifNotNil: [ self releaseComponent ].	mapped ifTrue: [ handle ifNotNil: [ self unmap ] ].	self unscheduleWindow.</body><body package="Searchlight-Tools">reopenWith: snippetComponent in: box 	component ifNotNil: [  self releaseComponent  ].	self component: snippetComponent.	self		moveTo: box origin floor resize: box extent floor;		updateDimensions;		map;		display</body><body package="Searchlight-Tools">sensorClass		^SnippetSensor</body></methods><methods><class-id>Searchlight.SnippetWindow</class-id> <category>event driven</category><body package="Searchlight-Tools">windowEventDispatcher	^self</body></methods><methods><class-id>Searchlight.DiscoveryWindow</class-id> <category>aspects</category><body package="Searchlight-Tools">search	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^search isNil		ifTrue:			[search := String new asValue]		ifFalse:			[search]</body><body package="Searchlight-Tools">searchView	^searchView</body></methods><methods><class-id>Searchlight.DiscoveryWindow</class-id> <category>initialize-release</category><body package="Searchlight-Tools">initialize	super initialize.	searchView := SearchView new.	searchView abortBlock:		[self search value: ''.		self searchUpdated.		builder window keyboardProcessor requestActivationFor: (self controllerAt: #search)]</body><body package="Searchlight-Tools">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	aBuilder window damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	(self controllerAt: #search) continuousAccept: true</body></methods><methods><class-id>Searchlight.DiscoveryWindow</class-id> <category>events</category><body package="Searchlight-Tools">searchChanged	updateProcess ifNotNil: [updateProcess terminate].	updateProcess := 		[(Delay forMilliseconds: 33) wait.		searchView search: self search value asString.		updateProcess := nil.		self searchUpdated] fork</body><body package="Searchlight-Tools">searchUpdated	| window height |	window := self builder window.	window isOpen ifFalse: [^self].	[height := 640.	self search value isEmpty ifTrue: [height := 25].	window moveTo: window displayBox origin resize: (window bounds width @ height)] uiEvent</body></methods><methods><class-id>Core.Object class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^self name</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	^self class toolListIcon</body><body package="Searchlight-Tools">searchlightDisplaySnippet	^nil</body><body package="Searchlight-Tools">searchlightDisplayString	^self printString</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Searchlight-Tools">searchlightNeedsBrowser	^true</body></methods><methods><class-id>Searchlight.SharedVariable class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Shared Variables'</body></methods><methods><class-id>Searchlight.SharedVariable</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| state |	state := Refactory.Browser.NavigatorState new.	state classOrNameSpace: namespace.	state definition: (Refactory.Browser.RBInitializerDefinition nameSpace: namespace key: name).	browser navigator updateWithState: state</body></methods><methods><class-id>Searchlight.SharedVariable</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayString	^name asString, ' (', namespace fullName, ')'</body></methods><methods><class-id>Searchlight.MethodDescription</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	(mclass compiledMethodAt: selector) searchlightBrowse: browser</body></methods><methods><class-id>Searchlight.MethodDescription</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplaySnippet	^(mclass compiledMethodAt: selector) searchlightDisplaySnippet</body><body package="Searchlight-Tools">searchlightDisplayString	^selector, ' (', mclass fullName, ')'</body></methods><methods><class-id>Core.ClassDescription class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Classes'</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| state |	state := Refactory.Browser.NavigatorState new.	state classOrNameSpace: self.	browser navigator updateWithState: state</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplaySnippet	| stream |	stream := TextStream on: String new.	superclass ifNotNil:		[stream			nextPutAll: superclass fullName;			cr;			nextPutAll: '+--';			emphasis: #bold].	stream nextPutAll: self fullName.	stream emphasis: nil.	stream		nextPutAll: '(in ';		nextPutAll: (Store.Registry containingPackageForClass: self) name;		nextPutAll: ')'. 	stream cr; cr; nextPutAll: self comment.	^stream contents</body><body package="Searchlight-Tools">searchlightDisplayString	self environment = Smalltalk ifTrue: [^self name].	^self name, ' (', self environment fullName, ')'</body></methods><methods><class-id>Searchlight.Result</class-id> <category>printing</category><body package="Searchlight-Tools">displayIcon	^object searchlightDisplayIcon</body><body package="Searchlight-Tools">displaySnippet	| stream snippet cap |	snippet := object searchlightDisplaySnippet.	snippet ifNil: [^nil].	stream := TextStream on: String new.	cap := 200 min: snippet size.  "searchlightNthIndex: 10 of: Character cr ifAbsent: [SmallInteger maxVal])."	stream nextPutAllText: (snippet first: cap).	(snippet size &gt; cap) ifTrue: 		[stream emphasis: (Array with: #bold with: #color -&gt; ColorValue gray).		stream nextPutAll: ' ...'].	^stream contents</body><body package="Searchlight-Tools">displayString	^object searchlightDisplayString</body><body package="Searchlight-Tools">sortString	^self displayString</body></methods><methods><class-id>Core.Symbol class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Messages'</body></methods><methods><class-id>Core.Symbol</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayString	^self asString</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Parcels'</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| parcelName |	self isLoaded ifTrue: [^(Store.Registry pundleNamed: self pundleName) searchlightBrowse: browser].	parcelName := self name.	(Dialog confirm: 'Load ', parcelName, ' ?') ifFalse: [^self].	Parcel loadParcelByName: parcelName.	(Parcel parcelNamed: parcelName) pundleInImage searchlightBrowse: browser</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	self isLoaded ifTrue: [^self toolListIcon].	^ListIconLibrary visualFor: #unloadedParcel</body><body package="Searchlight-Tools">searchlightDisplaySnippet	^self commentOrNil</body><body package="Searchlight-Tools">searchlightDisplayString	^self name</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="Searchlight-Tools">searchlightNthIndex: n of: element ifAbsent: absentBlock	" 'FooBar' searchlightNthIndex: 2 of: $o ifAbsent: [ nil] "	" 'FooBar' searchlightNthIndex: 3 of: $o ifAbsent: [ nil] "	| c index |	c := 0.	index := 0.	[		index := self nextIndexOf: element from: index + 1 to: self size.		index notNil	] whileTrue: [		c := c + 1.		c = n ifTrue: [ ^ index ].	].	^ absentBlock value</body></methods><methods><class-id>Searchlight.Reference class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Senders'</body></methods><methods><class-id>Searchlight.Reference</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	method searchlightBrowse: browser</body></methods><methods><class-id>Searchlight.Reference</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	^method searchlightDisplayIcon</body><body package="Searchlight-Tools">searchlightDisplaySnippet	^method searchlightDisplaySnippet</body><body package="Searchlight-Tools">searchlightDisplayString	"References are better grouped together by class, not selector."		(method isKindOf: Store.PundleModel) ifTrue: [^method name].	^method mclass fullName, ' #', method selector</body></methods><methods><class-id>Searchlight.InstanceVariable class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Variables'</body></methods><methods><class-id>Searchlight.InstanceVariable</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| state |	state := Refactory.Browser.NavigatorState new.	state classOrNameSpace: behavior.	state instanceVariables: (Array with: self name).	browser navigator updateWithState: state</body></methods><methods><class-id>Searchlight.InstanceVariable</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayString	^self name, ' (', behavior fullName, ')'</body></methods><methods><class-id>Searchlight.MethodLiteral class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Literals'</body></methods><methods><class-id>Searchlight.MethodLiteral</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| state |	state := Refactory.Browser.NavigatorState new.	state classOrNameSpace: method mclass.	state selector: method selector.	browser navigator updateWithState: state</body></methods><methods><class-id>Searchlight.MethodLiteral</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	^String toolListIcon</body><body package="Searchlight-Tools">searchlightDisplaySnippet	literal isString ifFalse: [^literal printString].	^literal</body><body package="Searchlight-Tools">searchlightDisplayString	^method searchlightDisplayString</body></methods><methods><class-id>Searchlight.Primitive class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Primitives'</body></methods><methods><class-id>Searchlight.Primitive</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	method searchlightBrowse: browser</body></methods><methods><class-id>Searchlight.Primitive</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	^method searchlightDisplayIcon</body><body package="Searchlight-Tools">searchlightDisplaySnippet	^method searchlightDisplaySnippet</body><body package="Searchlight-Tools">searchlightDisplayString	^method searchlightDisplayString</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>interface opening</category><body package="Searchlight-Tools">addFind	[ | components toolbar |	components := self builder window component components.	components size = 3 ifFalse: [^self].	((toolbar := (components at: 2) component) isKindOf: ToolBarView)		ifFalse: [^self].	toolbar		addTool: [			| toolBuilder searchView |			toolBuilder := builder newSubBuilder.			toolBuilder source: builder source.			toolBuilder bindings: builder bindings.			toolBuilder add: self class findWindowSpec decodeAsLiteralArray.			searchView := (toolBuilder componentAt: #find) component.			searchView widget controller crBlock: [:event | navigator find: searchView widget editValue in: searchView].			searchView]		width: #fill.	toolbar invalidateWidget]		on: Error		do: [:ex | ex return]</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>initialize-release</category><body package="Searchlight-Tools">initialize	super initialize.	self class showToolbarHolder onChangeSend: #updateToolbar to: self.	self findHolder retractInterestsFor: self.	toolsetsList := SelectionInList new</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>private</category><body package="Searchlight-Tools">autoBrowseResult: results	| result |	result := self bestResult: results.	result ifNil: [^false].	result object isSymbol ifTrue: [^false].	result object searchlightBrowse: self builder window model.	^true</body><body package="Searchlight-Tools">autoExploreResult: results view: searchView	| result |	result := self bestResult: results.	result ifNil: [^false].	result object isSymbol ifFalse: [^false].	searchView clickedSymbol: result object.	^true</body><body package="Searchlight-Tools">bestResult: results	| exactResults |	results isEmpty ifTrue: [^nil].	exactResults := results select: [:each | each score &lt;= 1].	exactResults size = 1		ifTrue:	[^exactResults first]		ifFalse:	[results size = 1 ifTrue: [^results first]].	^nil</body><body package="Searchlight-Tools">find: aString in: aSearchView	"Incredibly horrible hack/override to force the already incredibly horrible #addFind hack to use Searchlight instead"	| searchView results |	results := Searchlight.SearchImage search: aString.	(self autoBrowseResult: results) ifTrue: [^self].	(searchView := Searchlight.SearchView new)		initialize: results mode: #summary;		closeOnSelect: true;		browser: self builder window model.	self autoExploreResult: results view: searchView.	UI.ScheduledWindow new		damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new;		label: aString;		background: SymbolicPaint background;		component: searchView;		openIn: (self popupBoundsFor: aSearchView).	searchView takeKeyboardFocus</body><body package="Searchlight-Tools">popupBoundsFor: aSearchView	| origin extent |	origin := self mainWindow globalOrigin + aSearchView boundingFrame bottomLeft + (0 @ self sizeOfWindowTitle y).	extent := aSearchView boundingFrame width @ 550.	^origin extent: extent</body><body package="Searchlight-Tools">searchWidget	^self builder window component components		detect: [ :each | (each isKindOf: WidgetWrapper) and: [ each bottomComponent components last bottomComponent isKindOf: ComboBoxInputFieldView ] ]		ifNone: [ nil ]</body><body package="Searchlight-Tools">sizeOfWindowTitle	^-1 @ 24</body></methods><methods><class-id>Kernel.NameSpace class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Namespaces'</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| state |	state := Refactory.Browser.NavigatorState new.	state classOrNameSpace: self.	browser navigator updateWithState: state</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	^self toolListIcon</body><body package="Searchlight-Tools">searchlightDisplaySnippet	self comment isEmpty ifTrue: [^nil].	^self comment</body><body package="Searchlight-Tools">searchlightDisplayString	self environment = Smalltalk ifTrue: [^self name].	self environment ifNil: [^self name].	^self name, ' (', self environment fullName, ')'</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Bundles'</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>resources</category><body package="Searchlight-Tools">searchlight	^Searchlight.Icons searchIcon</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>status registration</category><body package="Searchlight-Tools">miniRepositoryManagerGap	"Remove the store mini repository gap as it's not needed with searchlight loaded"</body></methods><methods><class-id>Searchlight.Implementor class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Implementors'</body></methods><methods><class-id>Searchlight.Implementor</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	method searchlightBrowse: browser</body></methods><methods><class-id>Searchlight.Implementor</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	^method searchlightDisplayIcon</body><body package="Searchlight-Tools">searchlightDisplaySnippet	^method searchlightDisplaySnippet</body><body package="Searchlight-Tools">searchlightDisplayString	^method mclass searchlightDisplayString</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Packages'</body></methods><methods><class-id>Kernel.CompiledMethod class</class-id> <category>accessing</category><body package="Searchlight-Tools">groupDisplayString	^'Methods'</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| state |	state := Refactory.Browser.NavigatorState new.	state classOrNameSpace: self mclass.	state selector: self selector.	browser navigator updateWithState: state</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplaySnippet	| source stream |	stream := TextStream on: String new.	self mclass ifNotNil:		[stream			emphasis: #bold;			nextPutAll: self mclass fullName;			emphasis: nil;			nextPutAll: '&gt;&gt;'].	source := self getSource.	#{Refactory.CodeHighlighter.CodeHighlightingParser} 		ifDefinedDo: [ : p | source size &lt;= Refactory.Browser.BrowserTextTool.ParserTextLimit ifTrue: [ source := p formatMethod: source for: self mclass  ]].	stream nextPutAllText: source.	^stream contents</body><body package="Searchlight-Tools">searchlightDisplayString	^self selector, ' (', self mclass fullName, ')'</body></methods><methods><class-id>Store.PundleModel</class-id> <category>user interface</category><body package="Searchlight-Tools">searchlightBrowse: browser	| state |	state := Refactory.Browser.NavigatorState new.	state pundle: self.	browser navigator updateWithState: state</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Searchlight-Tools">searchlightDisplayIcon	^self toolListIcon</body><body package="Searchlight-Tools">searchlightDisplaySnippet	^self commentOrNil</body><body package="Searchlight-Tools">searchlightDisplayString	^self name</body></methods><methods><class-id>Searchlight.Icons class</class-id> <category>png imports</category><body package="Searchlight-Tools">searchIcon	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'searchIcon.png'&gt;	&lt;md5sum: #[20 156 106 108 42 177 250 151 159 224 9 73 173 45 126 39]&gt;	^[OpaqueImage			figure: (CachedImage on: ((Image extent: 16@16 depth: 24 bitsPerPixel: 24 palette: (FixedPalette redShift: 16 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 0 blueMask: 255) usingBits: (ByteArray fromPackedString: '????????;N3,9^W-9NS.:N#-9.[-8&gt;O.;N3,????????????????????????????????;N3,9^W-.++6%IS=!8_?#H3&gt;(*K:6-+*6-+#????????????????????????;N3,9.[-**+;%)[?$YG?#X7?"X''?!8_?"X''&gt;.K#S/;?A????????????????????7-;$1LS.*J#?)JS?''9??&amp;9/?%9_?$)K?#(;?#X77(*J*''):^????????????????1\WK/K37-+[?,+K?+Z7?*Z''?)ZW?(JC?''I3?&amp;I#?"8.$ 8NC????????????????+Z6/2\''?1LS?0LC?/K3?-;_?,;O?+*;?**+?)*[?!XV0ZF!(????????????????%YVX4-K84-K?3,;?2,+?1\W?0\G?/K3?.K#?-KS?\GBIST5M???????????????? HBB0,KU8NC?7M3?6M#?4=O?3&lt;??2&lt;/?1,[?0LC=P4MHL#H2????????????????V%)ZYVU(9NS9:^''?9.[?8^G?7]7?6]''?5MS?^7.SKR4/@@@@????????????????????QDQEUUUY3,;!:^''?:^''?:^''?9NS;]7^EF!(\%)ZVO3&lt;?@@@@????????????????????FQ$ZHB@"MCP8WU5%PDAFD1LUC0&lt;PL3L3YFQ$ (JBM3\7@@@@????????????????????????@@@@@@@@@@@@@@@@@@@@@@@@G!8^Q$YFYVU%K2&lt;/@@@@????????????????????????????????????????@@@@@@@@A@PDJB (R$)JI"X&amp;@@@@????????????????????????????????????????@@@@@@@@@@@@B0,KKR4-F!(Z????????????????????????????????????????????@@@@@@@@@@@@@@@@A@PD????????????????????????????????????????????????@@@@@@@@@@@@@@@@'))))			shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[63 128 0 0 127 192 0 0 255 224 0 0 255 240 0 0 255 240 0 0 255 240 0 0 255 240 0 0 255 240 0 0 255 240 0 0 127 248 0 0 63 252 0 0 15 254 0 0 0 127 0 0 0 63 0 0 0 31 0 0 0 15 0 0])))] once</body></methods><methods><class-id>Searchlight.DiscoveryToolDock class</class-id> <category>interface specs</category><body package="Searchlight-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Searchlight'			#layoutManagerClass: #{UI.UILayout.HorizontalLineLayoutManager}			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1104 445 1454 995 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 0 0 -6 1 0 1 ) 					#name: #search 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #search 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusInSelector: 						#searchEntry: ) 					#type: #text ) ) ) )</body></methods><methods><class-id>Searchlight.ResultsView class</class-id> <category>resources</category><body package="Searchlight-Tools">contextMenu	"Tools.MenuEditor new openOnClass: self andSelector: #contextMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Browse' 				#nameKey: #browse 				#value: #rightClickBrowse: ) 			#(#{UI.MenuItem} 				#rawLabel: 'References' 				#nameKey: #references 				#value: #rightClickReferences: ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Searchlight.DiscoveryWindow class</class-id> <category>interface specs</category><body package="Searchlight-Tools">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Search the image:' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 960 600 1410 625 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 25 0 ) 					#name: #search 					#model: #search 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #searchChanged ) 					#type: #text ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 0 1 0 1 ) 					#name: #searchView 					#flags: 0 					#component: #searchView ) ) ) )</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="Searchlight-Tools">openSearchlightCommand	&lt;command: #openSearchlight&gt;	^Command		label: (#OpenSearchlight &lt;&lt; #menus &gt;&gt; 'Open Searchlight')		group: #launcher		bindings: #()</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser class</class-id> <category>interface specs</category><body package="Searchlight-Tools">findWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #findWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #browser ) 			#bounds: #(#{Graphics.Rectangle} 1134 704 1424 734 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 0 0 -8 1 25 0 ) 					#name: #find 					#model: #findHolder 					#tabable: true 					#isReadOnly: false 					#comboList: #findList ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>status registration</category><body package="Searchlight-Tools">miniSearchlight	&lt;tool: 0 width: #fill&gt;	^SubCanvasView		client: Searchlight.DiscoveryToolDock new		spec: Searchlight.DiscoveryToolDock windowSpec</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus</category><body package="Searchlight-Tools">openSearchlight	&lt;menuItemForCommand: #openSearchlight		icon: #searchlight		nameKey: #openSearchlight		menu: #(menuBar #browse)		position: 10.05&gt;	Searchlight.DiscoveryWindow open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TransientWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component paintPreferences controller masterWindow layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Assets</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>lastDirectory </class-inst-vars><imports></imports><category>Assets</category><attributes><package>Assets</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Result</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object score </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>RefactoringBrowser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractRefactoringBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policyClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-RB UI</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>InstanceVariable</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>behavior index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><class><name>MethodLiteral</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method literal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><class><name>Parcel</name><environment>Kernel</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects definedClasses definedBindings classSelectors namedObjects dirty loaded </inst-vars><class-inst-vars>parcels classParcelMap parcelFileInfoCache parcelFileDirectoryCache dependents </class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>Reference</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SharedVariable</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Navigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment state dispatcher parts partsDictionary menus showOnlyFiltered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>Primitive</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><class><name>EventSensor</name><environment>UI</environment><super>UI.ApplicationWindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collapseEvents queueLocked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class><class><name>Implementor</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><class><name>MethodDescription</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mclass selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class></st-source>