<?xml version="1.0"?><st-source><!-- Changes in change set SqueakFileInCompatibility --><time-stamp>From VisualWorksÂ®, Release 7.1 of March 21, 2003 on October 1, 2003 at 10:56:35 am</time-stamp><class><name>ClassCommentReader</name><environment>Kernel</environment><super>Kernel.ClassCategoryReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category></class><methods><class-id>Core.ClassDescription</class-id> <category>fileIn/Out Squeak Compatibility</category><body>commentStamp: aString prior: anInteger	"For Squeak file-in compatibility"	^ClassCommentReader  class: self category: nil</body><body>methodsFor: protocolString stamp: datestampString	"Answer a ClassCategoryReader for accessing the messages in the method	dictionary category, aString, of the receiver."	^self methodsFor: protocolString</body></methods><methods><class-id>Kernel.ClassCommentChange</class-id> <category>accessing</category><body>text	"Answer the text displayed by the receiver."	| unavailableText targetObject |	unavailableText := (#CommentNotAvailable &lt;&lt; #dialogs &gt;&gt; 'Comment not available') asString.	sourceCode isNil ifTrue:		[^(targetObject := self targetObject) == nil			ifTrue: [unavailableText]			ifFalse: [targetObject comment]].	sourceCode isCharacters ifTrue:		[^sourceCode].	sourceCode isInteger ifTrue:		[^self cleanSourceFrom: ([| string stream |									string := manager												stringAt: sourceCode												ifAbsent: [(#SourceUnavailable &lt;&lt; #dialogs &gt;&gt; 'source unavailable') asString].									((stream := string readStream) skipSeparators; peek) = $'										ifTrue: [String readFrom: stream]										ifFalse: [string]]											on: Error											do: [:ex2| (#SourceUnavailable &lt;&lt; #dialogs &gt;&gt; 'source unavailable') asString])].	^unavailableText</body></methods><methods><class-id>Kernel.ChangeScanner</class-id> <category>expression scanning</category><body>scanOldStyleClassCommentClass: class do: aBlock	aBlock value: ((ClassCommentChange new className: class) file: file position: file position).	self nextChunkStream</body></methods><methods><class-id>Kernel.ChangeScanner</class-id> <category>file scanning</category><body>scanSpecialDo: aBlock	"Scan a chunk of file beginning with a !.	 For now, the only thing I understand is method definitions."	| class category |	(class := self nextClass) notNil ifTrue:		[(tokenType == #keyword		and: [token = 'methodsFor:'			or: [token = 'publicMethodsFor:'			or: [token = 'privateMethodsFor:'			or: [token = 'methodsForUndefined:']]]]) ifTrue:			[self scanToken.			tokenType == #string ifTrue:				[category := token.				self scanToken.				"Squeak compatibility"				(tokenType == #keyword and: [token = 'stamp:']) ifTrue:					[self scanToken; scanToken].				tokenType == #doIt ifTrue:					[^self scanMethodsClass: class category: category asSymbol do: aBlock]]].		((tokenType == #word or: [tokenType == #compoundWord])		and: [token = 'methods']) ifTrue:			[self scanToken.			tokenType == #doIt ifTrue:				[^self scanMethodsClass: class category: nil do: aBlock]]].	(token = 'comment:' or: [token = 'commentStamp:']) ifTrue:		[^self scanOldStyleClassCommentClass: class do: aBlock].	"I don't understand what's on the file.  Scan for a blank chunk and hope for the best."	[self nextChunkStream atEnd] whileFalse</body></methods><methods><class-id>Kernel.ClassCommentReader</class-id> <category>fileIn/Out</category><body>scanFrom: aStream using: aFormatter	"Assigns the next chunk as a comment to the receiver's class object"	class instanceBehavior comment: aStream nextChunk</body></methods></st-source>