<?xml version="1.0"?><st-source><!-- Changes in change set HPSVMConstruction-WarpBlt --><time-stamp>From VisualWorksÂ®, Release 7.1 of March 21, 2003 on October 1, 2003 at 10:51:55 am</time-stamp><class><name>WarpBlt</name><environment>Graphics</environment><super>Graphics.RasterOp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>p1x p1y p1z p2x p2y p2z p3x p3y p3z p4x p4y p4z cellSize sourceRGBmap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category></class><methods><class-id>Core.Point</class-id> <category>point functions</category><body>rotateBy: angle about: center 	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretation of angle."	| p r theta |	p := self - center.	r := p r.	theta := angle asFloat - p theta.	^(center x asFloat + (r * theta cos)) 		@ (center y asFloat - (r * theta sin))</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>accessing</category><body>innerCorners	"Return an array of inner corner points,	ie, the most extreme pixels included,	in the order of a quadrilateral spec for WarpBlt"	| r1 |	r1 := self topLeft corner: self bottomRight - (1@1).	^Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight</body></methods><methods><class-id>Graphics.Image</class-id> <category>accessing</category><body>boundingBox	^0@0 corner: width @ height</body></methods><methods><class-id>Core.ByteArray</class-id> <category>bit processing</category><body>copyBitsStride: destStride width: destWidth atX: destX y: destY from: sourceByteArrayOrNil stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule 	"Perform a BitBLT operation from the sourceByteArrayOrNil to the 	receiver byte array. Each byte array is considered to be a 	two-dimensional array of bits. Both rows and columns are 	numbered starting at 0. Bits are stored in the order (0,0), (1,0), ..., 	(S*32-1,0), (0,1), ... where S is the stride of the array (number of 	32-bits words per row). If the byte array does not contain an 	integral number of rows, the final partial row is treated as though it 	did not exist. 		Within each byte, bits are numbered in big-endian fashion: the 	high-order bit is numbered 0, and the low-order bit is numbered 7. 		The copyBits operation replaces each bit of the destination (receiver) 	within the designated rectangle with the designated Boolean 	function of the destination bit and the source bit. If the source 	bitmap is nil, it is considered to be an infinite bitmap filled with 1's; 	the source stride and position are ignored in that case. The 	combinationRule argument is an integer between 0 and 15 	(inclusive) that specifies the Boolean function: 		rule		result 		0			0 	1			D bitAnd: S 	2			D bitInvert bitAnd: S 	3			S 	4			D bitAnd: S bitInvert 	5			D 	6			D bitXor: S 	7			D bitOr: S 	8			D bitInvert bitAnd: S bitInvert 	9			D bitXor: S bitInvert 	10			D bitInvert 	11			D bitInvert bitOr: S 	12			S bitInvert 	13			D bitOr: S bitInvert 	14			D bitInvert bitOr: S bitInvert 	15			1 		This operation clips to the bounds of the destination byte array."	&lt;primitive: 933 errorCode: ec&gt;	"Handle float coordinates"	self		copyBitsIntegralStride: destStride rounded		width: destWidth rounded		atX: destX rounded		y: destY rounded		from: sourceByteArrayOrNil		stride: sourceStride rounded		width: sourceWidth rounded		atX: sourceX rounded		y: sourceY rounded		width: width rounded		height: height rounded		rule: combinationRule</body><body>tileBitsStride: destStride width: destWidth atX: destX y: destY from: sourceByteArray stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule 	"Perform a tiling BitBLT operation from the sourceByteArray to the 	receiver byte array. This operation differs from the copyBits version 	by using multiple copies of the source to fill the destination 	rectangle, rather than failing if a source coordinate doesn't lie within 	the source bounds. 		Each byte array is considered to be a two-dimensional array of bits. 	Both rows and columns are numbered starting at 0. Bits are stored in 	the order (0,0), (1,0), ..., (S*32-1,0), (0,1), ... where S is the stride of 	the array (number of 32-bits words per row). If the byte array does 	not contain an integral number of rows, the final partial row is 	treated as though it did not exist. 		Within each byte, bits are numbered in big-endian fashion: the 	high-order bit is numbered 0, and the low-order bit is numbered 7. 		The tileBits operation replaces each bit of the destination (receiver) 	within the designated rectangle with the designated Boolean 	function of the destination bit and the source bit. The 	combinationRule argument is an integer between 0 and 15 	(inclusive) that specifies the Boolean function: 		rule		result 		0			0 	1			D bitAnd: S 	2			D bitInvert bitAnd: S 	3			S 	4			D bitAnd: S bitInvert 	5			D 	6			D bitXor: S 	7			D bitOr: S 	8			D bitInvert bitAnd: S bitInvert 	9			D bitXor: S bitInvert 	10			D bitInvert 	11			D bitInvert bitOr: S 	12			S bitInvert 	13			D bitOr: S bitInvert 	14			D bitInvert bitOr: S bitInvert 	15			1 		This operation clips to the bounds of the destination byte array."	&lt;primitive: 934 errorCode: ec&gt;	"Handle float coordinates"	self		tileBitsIntegralStride: destStride rounded		width: destWidth rounded		atX: destX rounded		y: destY rounded		from: sourceByteArray		stride: sourceStride rounded		width: sourceWidth rounded		atX: sourceX rounded		y: sourceY rounded		width: width rounded		height: height rounded		rule: combinationRule</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private</category><body>copyBitsClippedStride: destStride width: destWidth atX: destX y: destY from: sourceByteArrayOrNil stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule	&lt;primitive: 933 errorCode: ec&gt;	"The synthetic rule 'paint' is equivalent to 'under' when there is no	halftone."	combinationRule = RasterOp paint		ifTrue: [self copyBitsRuleAdjustedStride: destStride width: destWidth				atX: destX y: destY				from: sourceByteArrayOrNil stride: sourceStride width: sourceWidth				atX: sourceX y: sourceY				width: width height: height				rule: RasterOp under]		ifFalse: [self primitiveFailed]</body><body>copyBitsIntegralStride: destStride width: destWidth atX: destX y: destY from: sourceByteArrayOrNil stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule	&lt;primitive: 933 errorCode: ec&gt;	| dx dy sx sy w h destHeight sourceHeight |	"Adjust copy bounds to clip to the source and destination."	destX &lt; 0		ifTrue: [sx := sourceX - destX. w := width + destX. dx := 0]		ifFalse: [sx := sourceX. w := width. dx := destX].	destY &lt; 0		ifTrue: [sy := sourceY - destY. h := height + destY. dy := 0]		ifFalse: [sy := sourceY. h := height. dy := destY].	sourceByteArrayOrNil == nil		ifFalse:			[sx &lt; 0				ifTrue: [dx := dx - sx. w := width + sx. sx := 0].			sy &lt; 0				ifTrue: [dy := dy - sy. h := height + sy. sy := 0]].	dx + w &gt; destWidth		ifTrue: [w := destWidth - dx].	destHeight := self size // (destStride bitShift: 2).	dy + h &gt; destHeight		ifTrue: [h := destHeight - dy].	sourceByteArrayOrNil == nil		ifFalse:			[sx + w &gt; sourceWidth				ifTrue: [w := sourceWidth - sx].			sourceHeight := sourceByteArrayOrNil size // (sourceStride bitShift: 2).			sy + h &gt; sourceHeight				ifTrue: [h := sourceHeight - sy]].	self copyBitsClippedStride: destStride width: destWidth		atX: dx y: dy		from: sourceByteArrayOrNil stride: sourceStride width: sourceWidth		atX: sx y: sy		width: w height: h		rule: combinationRule</body><body>copyBitsRuleAdjustedStride: destStride width: destWidth atX: destX y: destY from: sourceByteArrayOrNil stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule	&lt;primitive: 933 errorCode: ec&gt;	self primitiveFailed</body><body>tileBits32By32Stride: destStride width: destWidth atX: destX y: destY from: sourceByteArray stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule	&lt;primitive: 934 errorCode: ec&gt;	"The synthetic rule 'paint' is equivalent to 'under' when there is no	halftone."	combinationRule = RasterOp paint		ifTrue: [self tileBitsRuleAdjustedStride: destStride width: destWidth				atX: destX y: destY				from: sourceByteArray stride: sourceStride width: sourceWidth				atX: sourceX y: sourceY				width: width height: height				rule: RasterOp under]		ifFalse: [self primitiveFailed]</body><body>tileBitsClippedStride: destStride width: destWidth atX: destX y: destY from: sourceByteArray stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule	&lt;primitive: 934 errorCode: ec&gt;	| sourceHeight maxDestXPlusOne maxDestYPlusOne tileX tileY |	sourceHeight := sourceByteArray size // (sourceStride bitShift: 2).	(32 \\ sourceWidth = 0 and: [32 \\ sourceHeight = 0])		ifTrue:			[| newTile dimension |			"Use a 32x32 tile, which is the size directly supported by the primitive."			newTile := self class new: 128 "32 * 4".			newTile copyBitsStride: 1 width: 32 atX: 0 y: 0				from: sourceByteArray stride: sourceStride width: sourceWidth				atX: 0 y: 0 width: sourceWidth height: sourceHeight rule: RasterOp over.			"double in X direction"			dimension := sourceWidth.			[dimension &lt; 32] whileTrue:				[newTile copyBitsStride: 1 width: 32 atX: dimension y: 0					from: newTile stride: 1 width: 32					atX: 0 y: 0 width: dimension height: sourceHeight rule: RasterOp over.				dimension := dimension bitShift: 1].			"double in Y direction"			dimension := sourceHeight.			[dimension &lt; 32] whileTrue:				[newTile copyBitsStride: 1 width: 32 atX: 0 y: dimension					from: newTile stride: 1 width: 32					atX: 0 y: 0 width: 32 height: dimension rule: RasterOp over.				dimension := dimension bitShift: 1].			^self tileBits32By32Stride: destStride width: destWidth atX: destX y: destY					from: newTile stride: 1 width: 32					atX: sourceX y: sourceY width: width height: height					rule: combinationRule].	"tile by stamping the source throughout the destination area"	maxDestXPlusOne := destX + width.	maxDestYPlusOne := destY + height.	tileX := sourceX \\ sourceWidth.	tileY := sourceY \\ sourceHeight.	destY - tileY to: maxDestYPlusOne - 1 by: sourceHeight do:		[:y2 |		| sy dy h |		y2 &lt; destY			ifTrue: [h := sourceHeight - destY + y2. sy := destY - y2. dy := destY]			ifFalse: [h := sourceHeight. sy := 0. dy := y2].		dy + h &gt; maxDestYPlusOne			ifTrue: [h := maxDestYPlusOne - dy].		destX - tileX to: maxDestXPlusOne - 1 by: sourceWidth do:			[:x2 |			| sx dx w |			x2 &lt; destX				ifTrue: [w := sourceWidth - destX + x2. sx := destX - x2. dx := destX]				ifFalse: [w := sourceWidth. sx := 0. dx := x2].			dx + w &gt; maxDestXPlusOne				ifTrue: [w := maxDestXPlusOne - dx].			self copyBitsStride: destStride width: destWidth atX: dx y: dy				from: sourceByteArray stride: sourceStride width: sourceWidth atX: sx y: sy				width: w height: h rule: combinationRule]]</body><body>tileBitsIntegralStride: destStride width: destWidth atX: destX y: destY from: sourceByteArray stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule	&lt;primitive: 934 errorCode: ec&gt;	| sx sy dx dy w h destHeight |	"Adjust copy bounds to clip to the source and destination."	destX &lt; 0		ifTrue: [sx := sourceX - destX. w := width + destX. dx := 0]		ifFalse: [sx := sourceX. w := width. dx := destX].	destY &lt; 0		ifTrue: [sy := sourceY - destY. h := height + destY. dy := 0]		ifFalse: [sy := sourceY. h := height. dy := destY].	dx + w &gt; destWidth		ifTrue: [w := destWidth - dx].	destHeight := self size // (destStride bitShift: 2).	dy + h &gt; destHeight		ifTrue: [h := destHeight - dy].	self tileBitsClippedStride: destStride width: destWidth		atX: dx y: dy		from: sourceByteArray stride: sourceStride width: sourceWidth		atX: sx y: sy		width: w height: h		rule: combinationRule</body><body>tileBitsRuleAdjustedStride: destStride width: destWidth atX: destX y: destY from: sourceByteArray stride: sourceStride width: sourceWidth atX: sourceX y: sourceY width: width height: height rule: combinationRule	&lt;primitive: 934 errorCode: ec&gt;	self primitiveFailed</body></methods><comment><class-id>Graphics.DisplaySurface</class-id><body>Class DisplaySurface is the abstract class for all classes that act as destinations for graphics operations targeted for a bitmap video display (as opposed to printing, for example).  DisplaySurfaces are host resources that are usually limited and must be closed.Instance variables:	handle			&lt;GraphicsHandle | nil&gt;	handle to the host resource	width			&lt;SmallInteger&gt;			width of the surface	height			&lt;SmallInteger&gt;			height of the surface	background		&lt;Paint&gt;					paint used to clear the surfaceClass variables:	OpenSurfaces	&lt;HandleRegistry&gt;	registry of open display mediumsSubclasses must implement the following messages:	painting		defaultBackgroundPaint	private		contentsOfArea:		privateCloseObject Reference:DisplaySurface is an abstract class that provides displaying support for its subclasses, which represent various kinds of screen-based surfaces on which graphic objects can be displayed. For comparison, its peer, PostScriptFile, is an example of a graphic medium that displays graphic objects but not on a screen. Display surfaces are divided into those that display their contents on a screen (Window and its subclasses) and those that remain invisible (UnmappableSurface and its subclasses, Pixmap and Mask). A Pixmap is useful for assembling a group of displayed objects behind the scenes, so that it can be displayed in a window faster. A Mask is used mostly as a stencil through which portions of an image are made visible. Most of the abilities that DisplaySurface provides are of little use to applications, though they are important to specific collaborators. </body></comment><methods><class-id>Graphics.RasterOp class</class-id> <category>instance creation</category><body>toImage: aForm	^ self new setDestImage: aForm</body></methods><methods><class-id>Graphics.RasterOp class</class-id> <category>examples</category><body>bitBltExampleDestDepth: destDepth sourceDepth: sourceDepth toWindow: aWindow where: aPoint 	"The classic BitBlt example to test combination rules using BitBltSimulation and little endian forms"	| origins d s |	origins := Array new writeStream.	(0 to: 3 * 40 by: 40) 		do: [:y | (0 to: 3 * 40 by: 40) do: [:x | origins nextPut: x @ y + 4]].	origins := origins contents.	d := Image extent: 41 * 4 asPoint depth: destDepth palette: (self paletteForDepth: destDepth abs).	s := Image extent: 32 asPoint depth: sourceDepth palette: (self paletteForDepth: sourceDepth abs).	(RasterOp 		destinationImage: s sourceImage: nil halftoneImage: nil		combinationRule: RasterOp writeOnes		destOrigin: 8 asPoint sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0		extent: 16 asPoint clipRect: s bounds) copyBits.	origins with: (0 to: 15) do:		[:orig :rule |  | o |		o := orig + (1 @ 0).		(RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeOnes			destOrigin: o - 1 sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 34 asPoint clipRect: d bounds) copyBits.		(RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeZeros			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 32 asPoint clipRect: d bounds) copyBits.		(RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeOnes			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 16 @ 32 clipRect: d bounds) copyBits.		(RasterOp			destinationImage: d sourceImage: s halftoneImage: nil			combinationRule: rule			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 32 asPoint clipRect: d bounds) copyBits].	d displayOn: aWindow graphicsContext at: aPoint</body><body>paletteForDepth: depth	^depth &gt; 8 		ifTrue: 			[depth = 16 				ifTrue: 					[FixedPalette 						redShift: 11 redMask: 31						greenShift: 5 greenMask: 63						blueShift: 0 blueMask: 31]					ifFalse: 						[FixedPalette 							redShift: 16 redMask: 16rFF							greenShift: 8 greenMask: 16rFF							blueShift: 0 blueMask: 16rFF]]			ifFalse: 				[(depth = 1					ifTrue: [MonoMappedPalette]					ifFalse: [MappedPalette]) 							withColors: ((1 to: (2 raisedTo: depth)) collect:											[:i |											i even												ifTrue: [ColorValue white]												ifFalse: [ColorValue black]])]</body><body>primBitBltExampleDestDepth: destDepth sourceDepth: sourceDepth toWindow: aWindow where: aPoint 	"The classic BitBlt example to test combination rules using BitBltSimulation and little endian forms"	| origins d s |	origins := Array new writeStream.	(0 to: 3 * 40 by: 40) 		do: [:y | (0 to: 3 * 40 by: 40) do: [:x | origins nextPut: x @ y + 4]].	origins := origins contents.	d := Image extent: 41 * 4 asPoint depth: destDepth palette: (self paletteForDepth: destDepth abs).	s := Image extent: 32 asPoint depth: sourceDepth palette: (self paletteForDepth: sourceDepth abs).	(RasterOp 		destinationImage: s sourceImage: nil halftoneImage: nil		combinationRule: RasterOp writeOnes		destOrigin: 8 asPoint sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0		extent: 16 asPoint clipRect: s bounds) primCopyBits.	origins with: (0 to: 15) do:		[:orig :rule |  | o |		o := orig + (1 @ 0).		(RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeOnes			destOrigin: o - 1 sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 34 asPoint clipRect: d bounds) primCopyBits.		(RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeZeros			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 32 asPoint clipRect: d bounds) primCopyBits.		(RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeOnes			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 16 @ 32 clipRect: d bounds) primCopyBits.		(RasterOp			destinationImage: d sourceImage: s halftoneImage: nil			combinationRule: rule			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 32 asPoint clipRect: d bounds) primCopyBits].	d displayOn: aWindow graphicsContext at: aPoint</body><body>simBitBltExampleDestDepth: destDepth sourceDepth: sourceDepth toWindow: aWindow where: aPoint 	"The classic BitBlt example to test combination rules using BitBltSimulation and little endian forms"	| origins d s |	origins := Array new writeStream.	(0 to: 3 * 40 by: 40) 		do: [:y | (0 to: 3 * 40 by: 40) do: [:x | origins nextPut: x @ y + 4]].	origins := origins contents.	d := Image extent: 41 * 4 asPoint depth: destDepth palette: (self paletteForDepth: destDepth abs).	s := Image extent: 32 asPoint depth: sourceDepth palette: (self paletteForDepth: sourceDepth abs).	HPSVM.BitBltSimulation doPrimitive: #copyBits receiver: (RasterOp		destinationImage: s sourceImage: nil halftoneImage: nil		combinationRule: RasterOp writeOnes		destOrigin: 8 asPoint sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0		extent: 16 asPoint clipRect: s bounds).	origins with: (0 to: 15) do:		[:orig :rule |  | o |		o := orig + (1 @ 0).		HPSVM.BitBltSimulation doPrimitive: #copyBits receiver: (RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeOnes			destOrigin: o - 1 sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 34 asPoint clipRect: d bounds).		HPSVM.BitBltSimulation doPrimitive: #copyBits receiver: (RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeZeros			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 32 asPoint clipRect: d bounds).		HPSVM.BitBltSimulation doPrimitive: #copyBits receiver: (RasterOp			destinationImage: d sourceImage: nil halftoneImage: nil			combinationRule: RasterOp writeOnes			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 16 @ 32 clipRect: d bounds).		HPSVM.BitBltSimulation doPrimitive: #copyBits receiver: (RasterOp			destinationImage: d sourceImage: s halftoneImage: nil			combinationRule: rule			destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0			extent: 32 asPoint clipRect: d bounds)].	d displayOn: aWindow graphicsContext at: aPoint</body></methods><reorganize><class-id>Graphics.RasterOp class</class-id> <organization>('instance creation' #destination:stride:width:source:stride:width:halftone:stride:width:combinationRule:destOrigin:sourceOrigin:halftonePhase:extent:clipRect: #destinationImage:sourceImage:halftoneImage:combinationRule:destOrigin:sourceOrigin:halftonePhase:extent:clipRect: #toImage: #toReverse:)('mode constants' #and #erase #over #paint #reverse #reverseUnder #under #writeOnes #writeZeros)('examples' #bitBltExampleDestDepth:sourceDepth:toWindow:where: #paletteForDepth: #primBitBltExampleDestDepth:sourceDepth:toWindow:where: #simBitBltExampleDestDepth:sourceDepth:toWindow:where:)</organization></reorganize><methods><class-id>Graphics.RasterOp</class-id> <category>copying</category><body>primCopyBits	&lt;primitive: 'primitiveCopyBits' module: 'BitBltPlugin'&gt;	self primitiveFailed	"self new primCopyBits"</body></methods><methods><class-id>Graphics.RasterOp</class-id> <category>private</category><body>setDestImage: destImage	| bb |	bb := destImage boundingBox.	destination := destImage.	clipX := bb left.	clipY := bb top.	clipWidth := bb width.	clipHeight := bb height</body></methods><methods><class-id>Graphics.WarpBlt class</class-id> <category>initialization</category><body>toImage: destinationForm	"Default cell size is 1 (no pixel smoothing)"	^ (super toImage: destinationForm) cellSize: 1</body></methods><methods><class-id>Graphics.WarpBlt class</class-id> <category>examples</category><body>test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 := Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 := Sensor waitClickButton.				(Image dotOfSize: 8) displayAt: p0].	warp := (self toImage: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: self over.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := (Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight)			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]</body><body>test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 := Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 := Sensor waitClickButton.				(Image dotOfSize: 8) displayAt: p0].	warp := (self toImage: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: self over.	warp2 := (self toImage: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 250@0);		sourceForm: Display;		combinationRule: self over.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := (Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight)			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 250@0).		]</body><body>test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box := 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map := (Display depth &gt; 8		ifTrue: ["RGB is a bit messy..."				d := Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t := i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp := (WarpBlt toImage: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: self over.	p0 := box center.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]</body><body>test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box := 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp := (WarpBlt toImage: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: self over.	p0 := box center.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]</body><body>test5   "Display restoreAfter: [WarpBlt test5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 := Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 := Sensor waitClickButton.				(Image dotOfSize: 8) displayAt: p0].	warp := (self toImage: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: self over.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := (Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight)			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]</body></methods><methods><class-id>Graphics.WarpBlt class</class-id> <category>form rotation</category><body>rotate: srcImage degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize	"Rotate the given Image the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Image and the second is the position offset required to align the center of the rotated Image with that of the original. Note that the dimensions of the resulting Image generally differ from those of the original."	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstImage newCenter warpSrc |	srcRect := srcImage boundingBox.	center := srcRect center.	radians := angleInDegrees degreesToRadians.	dstOrigin := dstCorner := center.	srcRect corners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p := ((corner - center) scaleBy: scalePoint) + center.		p := (p rotateBy: radians about: center) rounded.		dstOrigin := dstOrigin min: p.		dstCorner := dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect := dstOrigin corner: dstCorner.	inverseScale := (1.0 / scalePoint x)@(1.0 / scalePoint y).	quad := dstRect innerCorners collect: [:corner |		p := corner rotateBy: radians negated about: center.		((p - center) scaleBy: inverseScale) + center].	"make a Form to hold the result and do the rotation"	warpSrc := srcImage.	(srcImage isKindOf: ColorForm)		ifTrue: [			cellSize &gt; 1 | true "ar 12/27/2001: Always enable - else sketches won't work"				ifTrue: [					warpSrc := Image extent: srcImage extent depth: 16.					srcImage displayOn: warpSrc.					dstImage := Image extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"				ifFalse: [					dstImage := srcImage class extent: dstRect extent depth: srcImage depth]]		ifFalse: [			dstImage := srcImage class extent: dstRect extent depth: srcImage depth].	(WarpBlt toImage: dstImage)		sourceForm: warpSrc;		colorMap: (warpSrc colormapIfNeededFor: dstImage);		cellSize: cellSize;  "installs a new colormap if cellSize &gt; 1"		combinationRule: self paint;		copyQuad: quad toRect: dstImage boundingBox.	(dstImage isKindOf: ColorForm) ifTrue: [dstImage colors: srcImage colors copy].	newCenter := (center rotateBy: radians about: aPoint) truncated.	^ Array with: dstImage with: dstRect origin + (newCenter - center)</body></methods><methods><class-id>Graphics.WarpBlt class</class-id> <category>instance creation</category><body>current	"Return the class currently to be used for WarpBlt"	^Display defaultWarpBltClass</body></methods><comment><class-id>Graphics.WarpBlt</class-id><body>WarpBlt is a little warp-drive added on to BitBlt (RasterOp in VisualWorks).  It takes a quadrilateral as its source specification, while its destination is traversed and combined just like any other call to copyBits.The source quadrilateral is specified as an array of points starting with the corner that wants to end up in the topLeft, and proceding to the successive points that want to follow counter clockwise around the destination rectangle.  Note that in specifying a plain old rectangle source, its non topLeft points must be actual pixels, not outside by 1, as with rectangle bottomRight, eg.  See the method Rectangle asQuad.WarpBlt does a fast job of rotation, reflection and scaling, and it can even produce a semblance of perspective.  Depth parameters are included for future improvements in this direction. but the primitve does not support this yet.</body></comment><methods><class-id>Graphics.WarpBlt</class-id> <category>setup</category><body>cellSize	^ cellSize</body><body>cellSize: s	cellSize := s.	cellSize = 1 ifTrue: [^ self].	colorMap := Color colorMapIfNeededFrom: 32 to: destination depth</body></methods><methods><class-id>Graphics.WarpBlt</class-id> <category>smoothing</category><body>mixPix: pix sourceMap: sourceMap destMap: destMap	"Average the pixels in array pix to produce a destination pixel.	First average the RGB values either from the pixels directly,	or as supplied in the sourceMap.  Then return either the resulting	RGB value directly, or use it to index the destination color map." 	| r g b rgb nPix bitsPerColor d |	nPix := pix size.	r := 0. g := 0. b := 0.	1 to: nPix do:		[:i |   "Sum R, G, B values for each pixel"		rgb := source depth &lt;= 8				ifTrue: [sourceMap at: (pix at: i) + 1]				ifFalse: [source depth = 32						ifTrue: [pix at: i]						ifFalse: [self rgbMap: (pix at: i) from: 5 to: 8]].		r := r + ((rgb bitShift: -16) bitAnd: 16rFF).		g := g + ((rgb bitShift: -8) bitAnd: 16rFF).		b := b + ((rgb bitShift: 0) bitAnd: 16rFF)].	destMap == nil		ifTrue: [bitsPerColor := 3.  "just in case eg depth &lt;= 8 and no map"				destination depth = 16 ifTrue: [bitsPerColor := 5].				destination depth = 32 ifTrue: [bitsPerColor := 8]]		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor := 3].				destMap size = 4096 ifTrue: [bitsPerColor := 4].				destMap size = 32768 ifTrue: [bitsPerColor := 5]].	d := bitsPerColor - 8.	rgb := ((r // nPix bitShift: d) bitShift: bitsPerColor*2)		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)		+ ((b // nPix bitShift: d) bitShift: 0).	^destMap == nil		ifTrue: [rgb]		ifFalse: [destMap at: rgb+1]</body><body>rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	self inline: true.	(d := nBitsOut - nBitsIn) &gt; 0		ifTrue:			["Expand to more bits by zero-fill"			mask := (1 &lt;&lt; nBitsIn) - 1.  "Transfer mask"			srcPix := sourcePixel &lt;&lt; d.			mask := mask &lt;&lt; d.			destPix := srcPix bitAnd: mask.			mask := mask &lt;&lt; nBitsOut.			srcPix := srcPix &lt;&lt; d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix &lt;&lt; d bitAnd: mask &lt;&lt; nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d := nBitsIn - nBitsOut.			mask := (1 &lt;&lt; nBitsOut) - 1.  "Transfer mask"			srcPix := sourcePixel &gt;&gt; d.			destPix := srcPix bitAnd: mask.			mask := mask &lt;&lt; nBitsOut.			srcPix := srcPix &gt;&gt; d.			destPix := destPix + (srcPix bitAnd: mask)					+ (srcPix &gt;&gt; d bitAnd: mask &lt;&lt; nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]</body></methods><methods><class-id>Graphics.WarpBlt</class-id> <category>primitives</category><body>copyQuad: pts toRect: destRect	self sourceQuad: pts destRect: destRect.	self warpBits</body><body>deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	x1 is starting pixel, x2 is ending pixel;  assumes n &gt;= 1"	| fixedPtOne |	fixedPtOne := 16384.  "1.0 in fixed-pt representation"	x2 &gt; x1		ifTrue: [^ x2 - x1 + fixedPtOne // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + fixedPtOne // (n+1) + 1)]</body><body>sourceForm: srcImage destRect: dstRectangle	"Set up a WarpBlt from the entire source Image to the given destination rectangle."	| w h |	source := srcImage.	sourceX := sourceY := 0.	destX := dstRectangle left.	destY := dstRectangle top.	width := dstRectangle width.	height := dstRectangle height.	w := 16384 * (srcImage width - 1).	h := 16384 * (srcImage height - 1).	p1x := 0.	p2x := 0.	p3x := w.	p4x := w.	p1y := 0.	p2y := h.	p3y := h.	p4y := 0.	p1z := p2z := p3z := p4z := 16384.  "z-warp ignored for now"</body><body>sourceQuad: pts destRect: aRectangle	| fixedPt1 |	sourceX := sourceY := 0.	self destRect: aRectangle.	fixedPt1 := (pts at: 1) x isInteger ifTrue: [16384] ifFalse: [16384.0].	p1x := (pts at: 1) x * fixedPt1.	p2x := (pts at: 2) x * fixedPt1.	p3x := (pts at: 3) x * fixedPt1.	p4x := (pts at: 4) x * fixedPt1.	p1y := (pts at: 1) y * fixedPt1.	p2y := (pts at: 2) y * fixedPt1.	p3y := (pts at: 3) y * fixedPt1.	p4y := (pts at: 4) y * fixedPt1.	p1z := p2z := p3z := p4z := 16384.  "z-warp ignored for now"</body><body>startFrom: x1 to: x2 offset: sumOfDeltas	"Utility routine for computing Warp increments."	x2 &gt;= x1		ifTrue: [^ x1]		ifFalse: [^ x2 - sumOfDeltas]</body><body>warpBits	"Move those pixels!"	self warpBitsSmoothing: cellSize		sourceMap: (source colormapIfNeededForDepth: 32).</body><body>warpBitsSmoothing: n	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps sourceMap |	&lt;primitive: 'primitiveWarpBitssmoothing' module: 'BitBltPlugin' errorCode: ec&gt;	(width &lt; 1) | (height &lt; 1) ifTrue: [^ self].	fixedPtOne := 16384.  "1.0 in fixed-pt representation"	n &gt; 1 ifTrue:		[(destination depth &lt; 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		source depth &lt; 16 ifTrue: [sourceMap := source palette elementData].		pix := Array new: n*n].	nSteps := height-1 max: 1.	deltaP12 := (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA := (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 := (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB := (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker := RasterOp current bitPeekerFromImage: source.	poker := RasterOp current bitPokerToImage: destination.	poker clipRect: self clipRect.	nSteps := width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB := (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp := (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp := sp + deltaPAB].		pA := pA + deltaP12.		pB := pB + deltaP43]</body><body>warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	&lt;primitive: 'primitiveWarpBitssmoothingsourceMap' module: 'BitBltPlugin' errorCode: ec&gt;	(width &lt; 1) | (height &lt; 1) ifTrue: [^ self].	fixedPtOne := 16384.  "1.0 in fixed-pt representation"	n &gt; 1 ifTrue:		[(destination depth &lt; 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix := Array new: n*n].	nSteps := height-1 max: 1.	deltaP12 := (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA := (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 := (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB := (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker := RasterOp current bitPeekerFromImage: source.	poker := RasterOp current bitPokerToImage: destination.	poker clipRect: self clipRect.	nSteps := width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB := (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp := (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp := sp + deltaPAB].		pA := pA + deltaP12.		pB := pB + deltaP43]</body></methods><methods><class-id>Graphics.WarpBlt</class-id> <category>system simulation</category><body>warpBitsSimulated	"Simulate WarpBlt"	self warpBitsSimulated: cellSize		sourceMap: (source colormapIfNeededForDepth: 32).</body><body>warpBitsSimulated: n sourceMap: sourceMap	"Simulate WarpBlt"	Smalltalk at: #BitBltSimulation ifPresent:[:bb| bb warpBitsFrom: self].</body></methods></st-source>