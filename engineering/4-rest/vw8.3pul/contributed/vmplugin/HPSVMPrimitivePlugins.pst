<?xml version="1.0"?><st-source><!-- Name: HPSVM Primitive PluginsNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel provides a port of the Squeak Primitive Plugin framework.  It provides a scheme for implementing algorithms in Smalltalk and then automatically translating the to C code which can be compiled and loaded into the VM via the dynamically-loadable user primitives facilities.See http://wiki.cs.uiuc.edu/VisualWorks/The+Squeak+Plugin+Primitives+Port for more information.This parcel is a first-cut at 64-bit support.DbIdentifier: bear73DbTrace: 299398DevelopmentPrerequisites: #(#(#any 'HPSVM Namespace' '') #(#any 'HPSVM Squeak Compatibility' ''))HideSource: falsePackageName: HPSVM Primitive PluginsParcel: #('HPSVM Primitive Plugins')ParcelName: HPSVM Primitive PluginsPrerequisiteParcels: #(#('HPSVM Namespace' '') #('HPSVM Squeak Compatibility' ''))PrintStringCache: (1.4,dcaster)SaveSource: trueVersion: 1.4Date: 8:23:15 AM September 3, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (sep10.1) of September 3, 2010 on September 3, 2010 at 8:23:15 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TtoCParseNode</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TtoCReturnNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>InterpreterProxy</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>successFlag remapBuffer bytesPerOOP </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Plugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TestCClass1</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>ReturnNode</name><environment>Kernel</environment><super>Kernel.StatementNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports>			HPSVM.TtoCReturnNode			</imports><category>System-Compiler-Program Objects</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>Kernel.ReturnNode</class-id><body>Class ReturnNode represents a method return (^).Instance Variables:	value	&lt;ValueNode&gt;</body></comment><class><name>TtoCVariableNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TtoCConstantNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>VariableNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name read </inst-vars><class-inst-vars></class-inst-vars><imports>			HPSVM.TtoCVariableNode			HPSVM.TtoCConstantNode			</imports><category>System-Compiler-Program Objects</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>Kernel.VariableNode</class-id><body>Class VariableNode represents a variable - argument, temporary, instance, class, pool, or global.Instance Variables:	name	&lt;String&gt;</body></comment><class><name>CObjectAccessor</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object offset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Plugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.CObjectAccessor</class-id><body>I am used to simulate the indexed access to any object during plugin simulation.</body></comment><class><name>TtoCAssignmentNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable expression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TtoCStmtListNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>BlockNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments body </inst-vars><class-inst-vars></class-inst-vars><imports>			HPSVM.TtoCStmtListNode			</imports><category>System-Compiler-Program Objects</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>Kernel.BlockNode</class-id><body>Class BlockNode represents a block, with or without arguments.  Local temporaries, if any, are bound in the SequenceNode which is the body.Instance Variables:	arguments	&lt;Array of: ParameterNode&gt;	body		&lt;ValueNode&gt;  normally, but not necessarily, a SequenceNode</body></comment><class><name>CArrayAccessor</name><environment>HPSVM</environment><super>HPSVM.CObjectAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-TestPlugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.CArrayAccessor</class-id><body>I am used to simulate the indexed access to arrays during plugin simulation.</body></comment><class><name>CPluggableAccessor</name><environment>HPSVM</environment><super>HPSVM.CArrayAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readBlock writeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Plugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TtoCSendNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector receiver arguments isBuiltinOperator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>VMMaker</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inline forBrowser allPlugins internalPlugins externalPlugins platformName sourceDirName platformRootDirName logger allFilesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Building</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.VMMaker</class-id><body>This class builds a VM codebase from the in-image and on-file code.The platforms file tree you need can be downloaded via cvs from http://squeak.Sourceforge.net. See also the swiki (http://minnow.cc.gatech.edu/squeak/2106) for instructions.It is fairly configurable as to where directories live and can handle multiple platform's source trees at once. It's main purpose is to allow easy building of source trees with any combination of internal/external/unused plugins to suit your platform needs and capabilities. For example, the Acorn has no need of Sound or AsynchFile plugins since I haven't written any platform code for them. There is a simple UI tool for this 	VMMakerTool openInWorldwill open a reasonably self explanatory tool with balloon help to explain all the fields - and a help window on top of that.There are some simple workspace &amp; inspector commands, allowing scripted building:	VMMaker default initializeAllExternal generateEntirefor example will build sources for a system with all the plugins external whereas 	VMMaker default initializeAllInternal generateEntirewould build all applicable plugins for internal compilation.	(VMMaker forPlatform: 'Mac OS') initializeAllExternal generateEntirewould build a source tree for a Mac even on a Windows machine (err, ignoring for now the irritation of lineends).	If you have a slightly more complex configuration you want to use, perhaps with Socket and Serial support external (because for your case they are rarely used and saving the space has some value) then you could try		(VMMaker default initializeAllInternalBut: #(SocketPlugin SerialPlugin) generateEntire	More complex still would be		(VMMaker default initializeInternal: #(BitBltPlugin MiscPrimsPlugin FilePlugin) external: #(SocketPlugin ZipPlugin B2DPlugin)which allows you to precisely list all the plugins to use.WARNING If you miss out a plugin you need, it won't be there. This message is really best suited to use by a UI like VMMakerTool.	To save a configuration for later use, you need to send #saveConfiguration to an active instance of VMMaker. Obviously you could simply use		(VMMaker default initializeAllInternalBut: #(SocketPlugin SerialPlugin) saveConfigurationbut inspecting 		VMMaker defaultand altering the internalPlugins and externalPlugins or the boolean flags for inline or forBrowser followed by saving the configuration allows ultimate power for now. To load a saved configuration file, use #loadConfigurationFrom: aFilename whilst inspecting a VMMaker. The loaded state will completely override any pre-existing state, so take care.	You can generate only parts of the source tree if you wish; as shown above #generateEntire will create the whole collection of internal and external plugins as well as the core VM. To create only  the external plugins use #generateExternalPlugins, or create a single  plugin with #generateExternalPlugin: name. To assemble the main VM including the internal plugins, use #generateMainVM. The interpreter 'interp.c' file is made with #generateInterpreterFile. You can generate a single internal plugin with #generateInternalPlugin: only if it has already been generated before; this interlocking is intended to make sure the named primitive table in the vm is correct.There are some rules to observe in order to use this:-- under the working directory (by default - you can configure it) you need a directory called 'platforms' (also configurable) with subdirectories named as the platform names returned by Smalltalk platformName (ie unix, RiscOS, Mac OS, etc - this isn't configurable). At the very least you need the one for your own platform and the pseudo-platform called 'Cross'. By adding a 'DirNames' entry for #machineType you can cross 'compile' for some other platform. Now all we need is a cross-compiler for the C code :-)- under this directory you must have a simple structure of directories for each generated plugin that you support on the platform, plus 'vm'. In each directory you place any/all platform specific files (and subdirectories) for that plugin. In 'misc' you can place any miscellaneous files such as makefiles, resources etc. For example, for unix you have	platforms/		unix/			plugins/				AsynchFilePlugin /					sqUnixAsynchfile.c			vm/				sqGnu.h				Profile/			misc/				makefile.in				util/								...etcAny plugins requiring platform files that you don't support shouldn't appear in the resulting code tree. If you try to include an unsupported plugin in the list to be made external, the VMMaker simply ignores it. However, if you include it in the list to be made internal you will get an error since that seems like a potentially serious source of confusion.There are three lists of plugins maintained herein:-1) the list of all known generatable plugins. We scan this list and compare with the supported plugins as indicated by the file tree.2) the list of chosen internal plugins.3) the list of chosen external plugins.See initializeAllPlugins, initialiseAllExternal etc for fairly obvious usage.There is also a short list of directory names in the class variable 'DirNames' that you can alter if needed.Known problems:-a) since Squeak has really poor filename handling, you can't simply change the directory names to '/foo/bar/myEvilCodeBase' and expect it to work. You fix file names and I'll fix VMMaker :-)b) Squeak copying of a file loses the assorted permissions, filetype info and other useful bits. To workaround this problem, see the FileCopyPlugin, which provides the platform independent part of a simple access for the OS filecopy capability. So far there are functional plugins for unix, Mac and Acorn. DOS machines appear not to need one. This is less of a problem in practise now that unix &amp; Mac no longer copy files from /platforms to /src.inline &lt;Boolean&gt; - is the generated code to be inlined or notforBrowser &lt;Boolean&gt; - is this to be a build for in-Browser use? Only relevent to MacsallPlugins &lt;Collection&gt; - all the known possible pluginsinternalPlugins &lt;Collection&gt; - the plugins chosen to be generated for internal linkingexternalPlugins &lt;Collection&gt; - the plugins intended to be external pluginsexportList &lt;Collection&gt; - a list of function names exported from plugins intended to be internalplatformName &lt;String&gt; - the name of the platform for which we are building a source tree. It is possible to do 'cross-compiles'sourceDirName, platformRootDirName &lt;String&gt; - the name of the directory into which we write the generated sources and the name of the directory where we should find the platforms tree.</body></comment><class><name>CCodeGenerator</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>translationDict asArgumentTranslationDict inlineList constants variables variableDeclarations methods variablesSetCache headerFiles plugin pluginName isCPP currentMethod reservedWords wordsToUndefine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.CCodeGenerator</class-id><body>This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: 'interp.c' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.</body></comment><class><name>CascadeNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver messages </inst-vars><class-inst-vars></class-inst-vars><imports>			HPSVM.TtoCStmtListNode			</imports><category>System-Compiler-Program Objects</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>Kernel.CascadeNode</class-id><body>Class CascadeNode represents a cascaded message.  The receiver in each MessageNode is the same as the receiver for the cascade, so we can generate the right kind of send.Instance Variables:	receiver	&lt;ValueNode&gt;	messages	&lt;"at least 2" SequenceableCollection of: MessageNode&gt;</body></comment><class><name>LiteralNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports>			HPSVM.TtoCConstantNode			</imports><category>System-Compiler-Program Objects</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>Kernel.LiteralNode</class-id><body>Class LiteralNode represents an occurrence of a literal.Instance Variables:	value	&lt;Object&gt;</body></comment><class><name>VMMakerException</name><environment>HPSVM</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Building</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TtoCCaseStmtNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression firsts lasts cases </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>PluggableCodeGenerator</name><environment>HPSVM</environment><super>HPSVM.CCodeGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.PluggableCodeGenerator</class-id><body>I generate code that can be loaded dynamically from external libraries (e.g., DSOs on Unix or DLLs on Windows)</body></comment><class><name>TestCodeGenerator</name><environment>HPSVM</environment><super>HPSVM.PluggableCodeGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debugFlag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-TestPlugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.TestCodeGenerator</class-id><body>Subclass of CCodeGenerator, used in connection with TestInterpreterPlugin to generate named primitives with type coercion specifications</body></comment><class><name>TestCClass3</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>InterpreterPlugin</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interpreterProxy moduleName </inst-vars><class-inst-vars>timeStamp </class-inst-vars><imports>			private Tools.Pragma			</imports><category>VMConstruction-Plugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TestInterpreterPlugin</name><environment>HPSVM</environment><super>HPSVM.InterpreterPlugin</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Plugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.TestInterpreterPlugin</class-id><body>Subclass of InterpreterPlugin, used in connection with TestCodeGenerator for named primitives with type coercion specifications</body></comment><class><name>Oop</name><environment>HPSVM</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-TestPlugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.Oop</class-id><body>Cooercion specification for Identity coercions:	x asOop: Oop == x	y asValue: Oop == y</body></comment><class><name>TtoCLabeledCommentNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>MessageNode</name><environment>Kernel</environment><super>Kernel.SimpleMessageNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expanded expansion </inst-vars><class-inst-vars></class-inst-vars><imports>			HPSVM.TtoCSendNode			</imports><category>System-Compiler-Program Objects</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>Kernel.MessageNode</class-id><body>Class MessageNode represents a message appearing in source code - possibly to be expanded for code generation.Instance Variables:	expanded	&lt;Boolean | nil&gt;  nil means haven't checked yet	expansion	&lt;nil | ValueNode&gt;Class Variables:	MacroSelectors 	&lt;IdentityDictionary&gt; special messages in-lined by the compiler</body></comment><class><name>Unsigned</name><environment>HPSVM</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-TestPlugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.Unsigned</class-id><body>Coercion specification for 32-bit unsigned numbers.Note: "x asOop: Unsigned" can cause garbage collection when x is outside SmallInteger range.</body></comment><class><name>TtoCMethod</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete export static comment definingClass builtinOnly </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Pragma			</imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TestTtoCMethod</name><environment>HPSVM</environment><super>HPSVM.TtoCMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isPrimitive suppressingFailureGuards fullSelector fullArgs parmSpecs rcvrSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-TestPlugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>HPSVM.TestTtoCMethod</class-id><body>Variation of TtoCMethod node of the Smalltalk C Code Generator, used in conjunction with TestCodeGenerator and TestInterpreterPlugin to generate named primitives with type coercion specifications.</body></comment><class><name>AssignmentNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value leftArrow assignToArgOK </inst-vars><class-inst-vars></class-inst-vars><imports>			HPSVM.TtoCAssignmentNode			</imports><category>System-Compiler-Program Objects</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><comment><class-id>Kernel.AssignmentNode</class-id><body>Class AssignmentNode represents an assignment, variable &lt;left arrow&gt; value or variable := value.Instance Variables:	variable	&lt;VariableNode&gt;	value	&lt;ValueNode&gt;	leftArrow	&lt;Boolean&gt;	"true if left arrow generated this, false if ':='"	assignToArgOK	&lt;Boolean&gt;  "true if this is an internally generated assignment					that is allowed to assign to an argument"</body></comment><class><name>TestCClass2</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><class><name>TtoCGoToNode</name><environment>HPSVM</environment><super>HPSVM.TtoCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Translation to C</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class><shared-variable><name>Buffer</name><environment>HPSVM.CArrayAccessor</environment><private>true</private><constant>true</constant><category>buffer</category><initializer>UninterpretedBytes new: 8</initializer><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><shared-variable><name>VectSize</name><environment>HPSVM.TestCClass2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><shared-variable><name>VisualWorks</name><environment>HPSVM.InterpreterPlugin</environment><private>false</private><constant>true</constant><category>dialect specificity</category><initializer>true</initializer><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><shared-variable><name>CaseStatements</name><environment>HPSVM.TtoCMethod</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><shared-variable><name>DirNames</name><environment>HPSVM.VMMaker</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><shared-variable><name>WhineAboutMissingDirectories</name><environment>HPSVM.VMMaker</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><shared-variable><name>EmitExportPragma</name><environment>HPSVM.CCodeGenerator</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><shared-variable><name>UseRightShiftForDivide</name><environment>HPSVM.CCodeGenerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM Primitive Plugins</package></attributes></shared-variable><methods><class-id>HPSVM.TtoCParseNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="allCalls">allCalls	"Answer a collection of selectors for the messages sent in this parse tree."	| calls |	calls := Set new: 100.	self nodesDo: [ :node |		node isSend ifTrue: [ calls add: node selector ].	].	^calls</body><body package="HPSVM Primitive Plugins" selector="bindVariableUsesIn:">bindVariableUsesIn: aDictionary	"Bind uses of all variables in the given dictionary, but do not change variables that appear on the left-hand-side of an assignment statement."	^ self</body><body package="HPSVM Primitive Plugins" selector="bindVariablesIn:">bindVariablesIn: aDictionary	^self</body><body package="HPSVM Primitive Plugins" selector="hasExplicitReturn">hasExplicitReturn	self nodesDo: [ :node |		node isReturn ifTrue: [ ^true ].	].	^false</body><body package="HPSVM Primitive Plugins" selector="inlineMethodsUsing:">inlineMethodsUsing: aDictionary	self</body><body package="HPSVM Primitive Plugins" selector="isAssertion">isAssertion	^false</body><body package="HPSVM Primitive Plugins" selector="isAssignment">isAssignment	^false</body><body package="HPSVM Primitive Plugins" selector="isCaseStmt">isCaseStmt	^false</body><body package="HPSVM Primitive Plugins" selector="isComment">isComment	^false</body><body package="HPSVM Primitive Plugins" selector="isConstant">isConstant	^false</body><body package="HPSVM Primitive Plugins" selector="isGoTo">isGoTo	^false</body><body package="HPSVM Primitive Plugins" selector="isLabel">isLabel	^false</body><body package="HPSVM Primitive Plugins" selector="isLeaf">isLeaf	"Answer true if the receiver is a variable or a constant node."	^false</body><body package="HPSVM Primitive Plugins" selector="isReturn">isReturn	^false</body><body package="HPSVM Primitive Plugins" selector="isSend">isSend	^false</body><body package="HPSVM Primitive Plugins" selector="isStmtList">isStmtList	^false</body><body package="HPSVM Primitive Plugins" selector="isVariable">isVariable	^false</body><body package="HPSVM Primitive Plugins" selector="nameOrValue">nameOrValue	self error: 'object is neither variable nor constant'</body><body package="HPSVM Primitive Plugins" selector="nodeCount">nodeCount	"Answer the number of nodes in this parseTree (a rough measure of its size)."	| cnt |	cnt := 0.	self nodesDo: [ :n | cnt := cnt + 1 ].	^cnt</body><body package="HPSVM Primitive Plugins" selector="nodesDo:">nodesDo: aBlock	aBlock value: self.</body><body package="HPSVM Primitive Plugins" selector="printOn:">printOn: aStream 	"Append a description of the receiver onto the given stream."	self printOn: aStream level: 0.</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: anInteger 	"Typically overridden. If control actually gets here, avoid recursion loop by sending to super."	super printOn: aStream.</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	"default: do nothing"</body><body package="HPSVM Primitive Plugins" selector="replaceNodesIn:">replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [self]</body><body package="HPSVM Primitive Plugins" selector="shouldEmitReturnForReturn">shouldEmitReturnForReturn	^true</body></methods><methods><class-id>HPSVM.TtoCParseNode</class-id> <category>emit comments</category><body package="HPSVM Primitive Plugins" selector="comment:">comment: aComment	comment := aComment</body><body package="HPSVM Primitive Plugins" selector="emitCCommentOn:level:">emitCCommentOn: aStream level: level	"Emit the transferred Smalltalk comments as C comments."	comment ifNotNil: [		comment isString ifTrue: [^self].	"safety catch"		aStream cr.		1 to: comment size do: [:index | 			aStream 				tab: level;				nextPutAll: '/* ';				nextPutAll: (comment at: index);				nextPutAll: ' */';				cr].		aStream cr]</body></methods><methods><class-id>HPSVM.TtoCParseNode</class-id> <category>As yet unclassified</category><body package="HPSVM Primitive Plugins" selector="emitCCodeAsArgumentOn:level:generator:">emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen	^self emitCCodeOn: aStream level: level generator: aCodeGen</body><body package="HPSVM Primitive Plugins" selector="emitCCodeAsExpressionOn:level:generator:">emitCCodeAsExpressionOn: aStream level: level generator: aCodeGen	^self emitCCodeOn: aStream level: level generator: aCodeGen</body></methods><methods><class-id>HPSVM.TtoCReturnNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="bindVariableUsesIn:">bindVariableUsesIn: aDictionary	expression := expression bindVariableUsesIn: aDictionary.</body><body package="HPSVM Primitive Plugins" selector="bindVariablesIn:">bindVariablesIn: aDictionary	expression := expression bindVariablesIn: aDictionary.</body><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new		setExpression: expression copyTree</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen	expression shouldEmitReturnForReturn ifTrue:		[aStream nextPutAll: 'return '.		 aCodeGen currentMethod returnType = 'void' ifTrue: [^self]].	expression emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen.</body><body package="HPSVM Primitive Plugins" selector="expression">expression	^expression</body><body package="HPSVM Primitive Plugins" selector="inlineMethodsUsing:">inlineMethodsUsing: aDictionary	expression := expression inlineMethodsUsing: aDictionary.</body><body package="HPSVM Primitive Plugins" selector="isReturn">isReturn	^true</body><body package="HPSVM Primitive Plugins" selector="nodesDo:">nodesDo: aBlock	expression nodesDo: aBlock.	aBlock value: self.</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	aStream nextPut: $^.	expression printOn: aStream level: level.</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	expression removeAssertions</body><body package="HPSVM Primitive Plugins" selector="replaceNodesIn:">replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression := expression replaceNodesIn: aDictionary.		self]</body><body package="HPSVM Primitive Plugins" selector="setExpression:">setExpression: aNode	expression := aNode.</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>converting</category><body package="HPSVM Primitive Plugins" selector="checkedIntegerValueOf:">checkedIntegerValueOf: intOop	^(self isIntegerObject: intOop)		ifTrue:[self integerValueOf: intOop]		ifFalse:[self primitiveFail].</body><body package="HPSVM Primitive Plugins" selector="floatObjectOf:">floatObjectOf: aFloat	self var: #aFloat declareC: 'double aFloat'.	aFloat class == Float ifFalse:[self error:'Not a float object'].	^aFloat</body><body package="HPSVM Primitive Plugins" selector="floatValueOf:">floatValueOf: anOop	self returnTypeC:'double'.	(self isImmediateObject: anOop) ifFalse:		[anOop class == self classFloat ifTrue: [^self firstFieldAsFloat: anOop].		anOop class == self classDouble ifTrue: [^self firstFieldAsDouble: anOop]].	self primitiveFail.	^0.0</body><body package="HPSVM Primitive Plugins" selector="positive32BitIntegerFor:">positive32BitIntegerFor: integerValue	self notYetImplementedError.	integerValue isInteger ifFalse:[self error:'Not an Integer object'].	^integerValue &gt; 0		ifTrue:[integerValue]		ifFalse:[ (1 bitShift: 32) + integerValue]</body><body package="HPSVM Primitive Plugins" selector="positive32BitValueOf:">positive32BitValueOf: obj	^self		cCode: 'unsigned v;			if (!stOopToCValue(&amp;v, obj, Unsigned, sizeof(v)))				primitiveFailed();			return v;'		inSmalltalk:			[obj isInteger ifFalse:[self error:'Not an integer object'].			 obj &lt; 0 				ifTrue:[self primitiveFail]				ifFalse:[obj]]</body><body package="HPSVM Primitive Plugins" selector="positive64BitIntegerFor:">positive64BitIntegerFor: integerValue	self notYetImplementedError.	integerValue isInteger ifFalse:[self error:'Not an Integer object'].	^integerValue &gt; 0		ifTrue:[integerValue]		ifFalse:[ (1 bitShift: 64) + integerValue]</body><body package="HPSVM Primitive Plugins" selector="positive64BitValueOf:">positive64BitValueOf: oop	self notYetImplementedError.	oop isInteger ifFalse:[self error:'Not an integer object'].	^oop &lt; 0 		ifTrue:[self primitiveFail]		ifFalse:[oop]</body><body package="HPSVM Primitive Plugins" selector="signed32BitIntegerFor:">signed32BitIntegerFor: integerValue	self notYetImplementedError.	integerValue isInteger ifFalse:[self error:'Not an Integer object'].	^integerValue</body><body package="HPSVM Primitive Plugins" selector="signed32BitValueOf:">signed32BitValueOf: oop	self notYetImplementedError.	oop isInteger ifFalse:[self error:'Not an integer object'].	^oop</body><body package="HPSVM Primitive Plugins" selector="signed64BitIntegerFor:">signed64BitIntegerFor: integerValue	self notYetImplementedError.	integerValue isInteger ifFalse:[self error:'Not an Integer object'].	^integerValue</body><body package="HPSVM Primitive Plugins" selector="signed64BitValueOf:">signed64BitValueOf: oop	self notYetImplementedError.	oop isInteger ifFalse:[self error:'Not an integer object'].	^oop</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>object access</category><body package="HPSVM Primitive Plugins" selector="arrayValueOf:">arrayValueOf: oop	self returnTypeC: 'void *'.	self success: (self isBytes: oop).	^CArrayAccessor on: oop.</body><body package="HPSVM Primitive Plugins" selector="fetchArray:ofObject:">fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop := self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop</body><body package="HPSVM Primitive Plugins" selector="fetchFloat:ofObject:">fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| floatOop |	self returnTypeC: 'double'.	floatOop := self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop</body><body package="HPSVM Primitive Plugins" selector="fetchInteger:ofObject:">fetchInteger: fieldIndex ofObject: objectPointer	"Note: May be called by translated primitive code."	| intOop |	self inline: true.	intOop := self fetchPointer: fieldIndex ofObject: objectPointer.	^(self isIntegerObject: intOop)		ifTrue: [self integerValueOf: intOop]		ifFalse: [self primitiveFail]</body><body package="HPSVM Primitive Plugins" selector="stObject:at:">stObject: array at: index	self notYetImplementedError.	^array at: index</body><body package="HPSVM Primitive Plugins" selector="stObject:at:put:">stObject: array at: index put: value	self notYetImplementedError.	^array at: index put: value</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="isFloatObject:">isFloatObject: oop	^oop class == Float</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="isInterpreterProxy">isInterpreterProxy	"Return true since I am not a real Interpreter simulation"	^true</body><body package="HPSVM Primitive Plugins" selector="mustNotBeImmediate:">mustNotBeImmediate: oop 	"Check that the argument is not an immediate because it is	 being used in some context where it must not be an immediate."	oop class hasImmediateInstances ifTrue:		[self error: 'immediate object would crash C code!']</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>other</category><body package="HPSVM Primitive Plugins" selector="byteSwapped:">byteSwapped: anInteger	self inline: true.	^((anInteger bitShift: -24) bitAnd: 16rFF)	+ ((anInteger bitShift: -8) bitAnd: 16rFF00)	+ ((anInteger bitAnd: 16rFF00) bitShift: 8)	+ ((anInteger bitAnd: 16rFF) bitShift: 24)	"(self basicNew byteSwapped: 16rAABBCCDD) printStringRadix: 16"</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>As yet unclassified</category><body package="HPSVM Primitive Plugins" selector="confirm:">confirm: aString	^Dialog confirm: aString</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>FFI support</category><body package="HPSVM Primitive Plugins" selector="ioLoadFunction:From:">ioLoadFunction: functionName From: moduleNameString	"Dummy - provided by support code"	^0</body><body package="HPSVM Primitive Plugins" selector="ioLoadModule:OfLength:">ioLoadModule: moduleNameIndex OfLength: moduleLength	"Dummy - provided by support code"	^0</body><body package="HPSVM Primitive Plugins" selector="ioLoadSymbol:OfLength:FromModule:">ioLoadSymbol: functionNameIndex OfLength: functionLength FromModule: moduleHandle	"Dummy - provided by support code"	^0</body><body package="HPSVM Primitive Plugins" selector="isInMemory:">isInMemory: address	self notYetImplementedError.	"Return true if the given address is in ST object memory"	^true</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>instance creation</category><body package="HPSVM Primitive Plugins" selector="makePointwithxValue:yValue:">makePointwithxValue: xValue yValue: yValue	self notYetImplementedError.	(xValue class == SmallInteger and:[yValue class == SmallInteger]) 		ifFalse:[self error:'Not SmallInteger objects'].	^xValue@yValue</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>initialize</category><body package="HPSVM Primitive Plugins" selector="initialize">initialize	successFlag := true.	bytesPerOOP := ObjectMemory current bytesPerOOP</body></methods><methods><class-id>HPSVM.InterpreterProxy class</class-id> <category>translation</category><body package="HPSVM Primitive Plugins" selector="addMethodsToRetainTo:">addMethodsToRetainTo: aSet 	self organization categories do: 		[:cat | 		(cat ~= 'initialize' and: [cat ~= 'private']) ifTrue:			[aSet addAll: (self organization listAtCategoryNamed: cat)]]</body></methods><methods><class-id>HPSVM.InterpreterProxy class</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="generateVMProxyOn:">generateVMProxyOn: fileName	| cg proxyClass catList |	proxyClass := InterpreterProxy.	cg := PluggableCodeGenerator new initialize.	cg addClass: proxyClass.	catList := proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList := catList collect:[:cat| cat -&gt; (proxyClass organization listAtCategoryNamed: cat)].	cg storeVirtualMachineProxyHeader: catList on: (fileName,'.h').	cg storeVirtualMachineProxyImplementation: catList on: (fileName,'.c').	"InterpreterProxy generateVMProxyOn:'sqVirtualMachine'"</body><body package="HPSVM Primitive Plugins" selector="validateProxyImplementation:">validateProxyImplementation: anInterpreter 	"InterpreterProxy validateProxyImplementation: Interpreter"	"InterpreterProxy validateProxyImplementation: DynamicInterpreter"	| proxyClass catList |	proxyClass := InterpreterProxy.	catList := proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList do:[:categ|		(proxyClass organization listAtCategoryNamed: categ) do:[:selector|			(anInterpreter canUnderstand: selector) 				ifFalse:					[self notifyWithLabel: selector, ' is not implemented in ', anInterpreter name]]]</body></methods><methods><class-id>HPSVM.InterpreterProxy class</class-id> <category>instance creation</category><body package="HPSVM Primitive Plugins" selector="new">new	^super new initialize</body></methods><methods><class-id>HPSVM.TestCClass1</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="arg1:arg2:">arg1: a arg2: b	"CCodeGenerator new initialize addClass: TestCClass1"	| i j k |	self var: #i declareC: 'char *i'.	i := 'abc'.	j := 2.	k := 3.</body><body package="HPSVM Primitive Plugins" selector="ifTests">ifTests	true ifTrue: [		self print: 'true case'	].	true ifFalse: [		self print: 'false case'	].	true ifTrue: [		self print: 'true case'	] ifFalse: [		self print: 'false case'	].	true ifFalse: [		self print: 'false case'	] ifTrue: [		self print: 'true case'	].</body><body package="HPSVM Primitive Plugins" selector="isIntegerValue:">isIntegerValue: intValue	"Copied from ObjectMemory."	^ (intValue bitXor: (intValue &lt;&lt; 1)) &gt;= 0</body><body package="HPSVM Primitive Plugins" selector="loopTests">loopTests	| v |	v := 0.	[v &lt; 10] whileTrue: [ self printNum: v.  v := v + 1 ].	self print: ''.	[v &lt; 1] whileFalse: [ self printNum: v.  v := v - 1 ].	self print: ''.	1 to: 10 do: [ :i | self printNum: i ].	self print: ''.	1 to: 10 by: 2 do: [ :i | self printNum: i ].	self print: ''.</body><body package="HPSVM Primitive Plugins" selector="method1">method1	"(CCodeGenerator new initialize addClass: TestCClass1) codeString"	x &amp; y ifTrue: [		x := 10.		y := 20.	].	y := nil + 3.	x = nil ifTrue: [ x := 18 ].	^nil</body><body package="HPSVM Primitive Plugins" selector="method2">method2	self method1; method8: 0; setX: 10 Y: 20.</body><body package="HPSVM Primitive Plugins" selector="method3">method3	x &gt; 0 ifTrue: [ ^x ] ifFalse: [ ^y ].</body><body package="HPSVM Primitive Plugins" selector="method4">method4	x := 0.	y := 0.	[x &lt; 100] whileTrue: [		y := y + x.		x := x + 1.	].	^y</body><body package="HPSVM Primitive Plugins" selector="method5">method5	self inline: true.	x &amp; y.	x | y.	x and: [y].	x or: [y].	x not.	x + y.	x - y.	x * y.	x // y.	x \\ y.	x min: y.	x max: y.	x bitAnd: y.	x bitOr: y.	x bitXor: y.	x bitInvert32.	x bitShift: y.	x &gt;&gt; y.	x &lt;&lt; y.	x &lt; y.	x &lt;= y.	x = y.	x &gt;= y.	x &gt; y.	x ~= y.	x == y.	x isNil.	x notNil.	[x &gt; y] whileTrue: [ x := x + 1 ].	[x &gt; y] whileFalse: [ x := x + 1 ].	x &gt; y ifTrue: [ x := x - 1 ].	x &gt; y ifFalse: [ x := x + 1 ].	x &gt; y ifTrue: [ x := x - 1 ] ifFalse: [ x := x + 1 ].	x &gt; y ifFalse: [ x := x + 1 ] ifTrue: [ x := x - 1 ].	x at: 3.	x at: 3 put: y.	self integerValueOf: x.	self integerObjectOf: x.	(self isIntegerObject: x) ifTrue: [ x := x - 1 ].	(self isIntegerValue: x) ifTrue: [ x := x - 1 ].	self cCoerce: x * (y - 1) to: 'int'.	x := x + 1.	x := x - 1.	x preDecrement.	y preIncrement &gt; 0 ifTrue: [ x := x + 1 ].</body><body package="HPSVM Primitive Plugins" selector="method6">method6	self dispatchOn: x in: #(f1 f2 f3 f4 f5).</body><body package="HPSVM Primitive Plugins" selector="method7">method7	| t1 |	self method1.	self method2.	t1 := self method3.	self method4.	self method5.</body><body package="HPSVM Primitive Plugins" selector="method8:">method8: arg	| a |	self returnTypeC: 'float'.	self var: #a    declareC: 'float a = 0'.	self var: #arg declareC: 'float arg'.	self cCode: 'a = arg * 3.14159'.	self cCode: 'a = arg * 2.0' inSmalltalk: [a := arg * 2.0].	^ a</body><body package="HPSVM Primitive Plugins" selector="method9">method9	"Test conditional code generation."	true ifTrue: [^ 1].	false ifTrue: [^ 'should not be generated'].	true ifFalse: [^ 'should not be generated'].	false ifFalse: [^ 2].	true ifTrue: [^ 3] ifFalse: [^ 'should not be generated'].	false ifTrue: [^ 'should not be generated'] ifFalse: [^ 4].	true ifFalse: [^ 'should not be generated'] ifTrue: [^ 5].	false ifFalse: [^ 6] ifTrue: [^ 'should not be generated'].</body><body package="HPSVM Primitive Plugins" selector="print:">print: val	self cCode: 'printf("%d\n", val)'.</body><body package="HPSVM Primitive Plugins" selector="printNum:">printNum: i	self cCode: 'printf("%d ", i)'.</body><body package="HPSVM Primitive Plugins" selector="setX:Y:">setX: newX Y: newY	x := newX min: newY.	y := newY.</body><body package="HPSVM Primitive Plugins" selector="testConditionals:">testConditionals: argTrue	| shouldBeTrue shouldBeFalse shouldntBeAssignedTo |	true ifTrue: [shouldBeTrue := true].	true ifFalse: [shouldntBeAssignedTo := true].	argTrue ifTrue: [shouldBeTrue := true].	argTrue ifFalse: [shouldntBeAssignedTo := true].	true ifTrue: [shouldBeTrue := true] ifFalse: [shouldntBeAssignedTo := false].	true ifFalse: [shouldntBeAssignedTo := true] ifTrue: [shouldBeFalse := false].	argTrue ifTrue: [shouldBeTrue := true] ifFalse: [shouldntBeAssignedTo := false].	argTrue ifFalse: [shouldntBeAssignedTo := true] ifTrue: [shouldBeFalse := false].</body></methods><methods><class-id>Kernel.ReturnNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationToCNode">asTranslationToCNode	^TtoCReturnNode new 		setExpression: value asTranslationToCNode;		comment: comment</body></methods><methods><class-id>HPSVM.TtoCVariableNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="bindVariableUsesIn:">bindVariableUsesIn: aDictionary	^ (aDictionary at: name ifAbsent: [^ self]) copyTree</body><body package="HPSVM Primitive Plugins" selector="bindVariablesIn:">bindVariablesIn: aDictionary 	^ (aDictionary at: name ifAbsent: [^ self]) copyTree</body><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new setName: name</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen 	aStream		nextPutAll: (name = 'nil' 						ifTrue: [aCodeGen cLiteralFor: nil]						ifFalse: [name])</body><body package="HPSVM Primitive Plugins" selector="isLeaf">isLeaf	^true</body><body package="HPSVM Primitive Plugins" selector="isVariable">isVariable	^true</body><body package="HPSVM Primitive Plugins" selector="name">name	^name</body><body package="HPSVM Primitive Plugins" selector="nameOrValue">nameOrValue	^name</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	aStream nextPutAll: name.</body><body package="HPSVM Primitive Plugins" selector="setName:">setName: aString	name := aString.</body></methods><methods><class-id>HPSVM.TtoCConstantNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new		setValue: value</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C literal."	aStream nextPutAll: (aCodeGen cLiteralFor: value).</body><body package="HPSVM Primitive Plugins" selector="isConstant">isConstant	^true</body><body package="HPSVM Primitive Plugins" selector="isLeaf">isLeaf	^true</body><body package="HPSVM Primitive Plugins" selector="nameOrValue">nameOrValue	^value</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	value storeOn: aStream.</body><body package="HPSVM Primitive Plugins" selector="setValue:">setValue: anObject	value := anObject.</body><body package="HPSVM Primitive Plugins" selector="value">value	^value</body></methods><methods><class-id>Kernel.VariableNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationToCNode">asTranslationToCNode	name = 'true' ifTrue: [^ TtoCConstantNode new setValue: true].	name = 'false' ifTrue: [^ TtoCConstantNode new setValue: false].	^ TtoCVariableNode new setName: name</body></methods><methods><class-id>HPSVM.CObjectAccessor</class-id> <category>pointer arithmetic</category><body package="HPSVM Primitive Plugins" selector="+">+ increment	^self shallowCopy += increment</body><body package="HPSVM Primitive Plugins" selector="+=">+= increment	offset := offset + increment</body><body package="HPSVM Primitive Plugins" selector="-">- decrement	^self clone -= decrement</body><body package="HPSVM Primitive Plugins" selector="-=">-= decrement	offset := offset - decrement</body></methods><methods><class-id>HPSVM.CObjectAccessor</class-id> <category>converting</category><body package="HPSVM Primitive Plugins" selector="asOop:">asOop: aClass	(aClass ccgCanConvertFrom: object)		ifFalse: [^self error: 'incompatible object for autocoercion'].	^object</body><body package="HPSVM Primitive Plugins" selector="asPluggableAccessor:">asPluggableAccessor: accessorArray	^((CPluggableAccessor on: object) += offset)		readBlock: accessorArray first		writeBlock: accessorArray last</body></methods><methods><class-id>HPSVM.CObjectAccessor</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="at:">at: index	^object instVarAt: index + offset + 1</body><body package="HPSVM Primitive Plugins" selector="at:put:">at: index put: value	^object instVarAt: index + offset + 1 put: value</body><body package="HPSVM Primitive Plugins" selector="object">object	^ object</body><body package="HPSVM Primitive Plugins" selector="offset">offset	^ offset</body></methods><methods><class-id>HPSVM.CObjectAccessor</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="getObject">getObject	^object</body><body package="HPSVM Primitive Plugins" selector="setObject:">setObject: anObject	object := anObject.	offset := 0.</body></methods><methods><class-id>HPSVM.CObjectAccessor</class-id> <category>printing</category><body package="HPSVM Primitive Plugins" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPutAll:' on: ';		print: object.</body><body package="HPSVM Primitive Plugins" selector="printOnStream:">printOnStream: aStream	super printOnStream: aStream.	aStream		print:' on: ';		write: object.</body></methods><methods><class-id>HPSVM.CObjectAccessor class</class-id> <category>instance creation</category><body package="HPSVM Primitive Plugins" selector="on:">on: anObject	^self new setObject: anObject</body></methods><methods><class-id>HPSVM.TtoCAssignmentNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="bindVariablesIn:">bindVariablesIn: aDictionary	variable := variable bindVariablesIn: aDictionary.	expression := expression bindVariablesIn: aDictionary.</body><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new		setVariable: variable copyTree		expression: expression copyTree</body><body package="HPSVM Primitive Plugins" selector="emitCCodeAsExpressionOn:level:generator:">emitCCodeAsExpressionOn: aStream level: level generator: aCodeGen	aStream nextPut: $(.	self emitCCodeOn: aStream level: level generator: aCodeGen.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen 	self isVariableUpdatingAssignment		ifTrue:			[variable emitCCodeOn: aStream level: level generator: aCodeGen.			 aStream				space;				nextPutAll: expression selector;	"+ or -"				nextPut: $=;				space.			expression args first emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen]		ifFalse:			[variable emitCCodeOn: aStream level: level generator: aCodeGen.			 aStream space; nextPut: $=; space.			 expression emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen]</body><body package="HPSVM Primitive Plugins" selector="expression">expression	^expression</body><body package="HPSVM Primitive Plugins" selector="inlineMethodsUsing:">inlineMethodsUsing: aDictionary	variable inlineMethodsUsing: aDictionary.	expression inlineMethodsUsing: aDictionary.</body><body package="HPSVM Primitive Plugins" selector="isAssignment">isAssignment	^true</body><body package="HPSVM Primitive Plugins" selector="isVariableUpdatingAssignment">isVariableUpdatingAssignment	"Return true if this assignment statement is of one of the forms:		var = var + ...		var = var - ...	Such assignments statements can exploit the C updating assignment operators. For example, 'x += 4' can be generated instead of 'x = x + 4'. This produces better code under some C compilers, most notably the CodeWarrior 68K compiler."	| sel |	(expression isSend and: [expression receiver isVariable]) ifFalse: [^ false].	sel := expression selector.	^ (expression receiver name = variable name) and: [(sel = #+) or: [sel = #-]]</body><body package="HPSVM Primitive Plugins" selector="nodesDo:">nodesDo: aBlock	variable nodesDo: aBlock.	expression nodesDo: aBlock.	aBlock value: self.</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	variable printOn: aStream level: level.	aStream nextPutAll: ' := '.	expression printOn: aStream level: level + 2.</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	expression removeAssertions</body><body package="HPSVM Primitive Plugins" selector="replaceNodesIn:">replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		variable := variable replaceNodesIn: aDictionary.		expression := expression replaceNodesIn: aDictionary.		self]</body><body package="HPSVM Primitive Plugins" selector="setVariable:expression:">setVariable: varNode expression: expressionNode	variable := varNode.	expression := expressionNode.</body><body package="HPSVM Primitive Plugins" selector="variable">variable	^variable</body></methods><methods><class-id>HPSVM.TtoCAssignmentNode</class-id> <category>inlining</category><body package="HPSVM Primitive Plugins" selector="bindVariableUsesIn:">bindVariableUsesIn: aDictionary	"Do NOT bind the variable on the left-hand-side of an assignment statement."	"was bindVariablesIn:"	expression := expression bindVariableUsesIn: aDictionary.</body></methods><methods><class-id>HPSVM.TtoCStmtListNode</class-id> <category>As yet unclassified</category><body package="HPSVM Primitive Plugins" selector="args">args	^arguments</body><body package="HPSVM Primitive Plugins" selector="bindVariableUsesIn:">bindVariableUsesIn: aDictionary	statements := statements collect: [ :s | s bindVariableUsesIn: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="bindVariablesIn:">bindVariablesIn: aDictionary	statements := statements collect: [ :s | s bindVariablesIn: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new		setArguments: arguments copy		statements: (statements collect: [ :s | s copyTree ])</body><body package="HPSVM Primitive Plugins" selector="emitCCodeAsArgumentOn:level:generator:">emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen	| statementWasComment |	statementWasComment := false.	statements		do:			[:s |			s emitCCommentOn: aStream level: level.			s emitCCodeAsArgumentOn: aStream level: 0 generator: aCodeGen.			statementWasComment := s isComment]		separatedBy:			[((self endsWithCloseBracket: aStream)			  or: [statementWasComment]) ifFalse: [aStream nextPut: $,]]</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen	statements do: [:s |		s emitCCommentOn: aStream level: level.		aStream tab: level.		s emitCCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) or:		 [s isComment])			ifFalse: [aStream nextPut: $;].		aStream cr].</body><body package="HPSVM Primitive Plugins" selector="endsWithCloseBracket:">endsWithCloseBracket: aStream	"Answer true if the given stream ends in a $} character."	| ch pos |	(pos := aStream position) &gt; 0 ifTrue: [		aStream position: pos - 1.		ch := aStream next].	^ ch = $}</body><body package="HPSVM Primitive Plugins" selector="inlineMethodsUsing:">inlineMethodsUsing: aDictionary	statements do: [ :s | s inlineMethodsUsing: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="isNilStmtListNode">isNilStmtListNode	|stmt|	statements size = 1 ifFalse: [^false].	stmt := statements at: 1.	^ stmt isVariable and: [stmt name = 'nil']</body><body package="HPSVM Primitive Plugins" selector="isStmtList">isStmtList	^true</body><body package="HPSVM Primitive Plugins" selector="nodesDo:">nodesDo: aBlock	statements do: [ :s | s nodesDo: aBlock ].		aBlock value: self.</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	aStream nextPut: $[.	arguments size &gt; 0 ifTrue: [		arguments do: [ :arg | aStream nextPutAll: ' :', arg ].		aStream nextPutAll: ' | '.	].	self printStatementsOn: aStream level: level.	aStream nextPut: $].</body><body package="HPSVM Primitive Plugins" selector="printStatementsOn:level:">printStatementsOn: aStream level: level	statements size &gt; 1 ifTrue: [ aStream crtab: level + 1 ].	1 to: statements size do: [ :i |		(statements at: i) printOn: aStream level: level.		i = statements size ifTrue: [			(statements size &gt; 1) ifTrue: [				aStream crtab: level.			].		] ifFalse: [			aStream nextPut: $.; crtab: level + 1.		].	].</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	| newStatements |	newStatements := OrderedCollection new: statements size.	statements do: [ :stmt |		stmt isAssertion ifFalse: [			newStatements add: (stmt removeAssertions; yourself).		]	].	self setStatements: newStatements asArray</body><body package="HPSVM Primitive Plugins" selector="replaceNodesIn:">replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		statements := statements collect: [ :s | s replaceNodesIn: aDictionary ].		self]</body><body package="HPSVM Primitive Plugins" selector="setArguments:">setArguments: argList	arguments := argList.</body><body package="HPSVM Primitive Plugins" selector="setArguments:statements:">setArguments: argList statements: statementList	"Initialize this method using the given information."	arguments := argList.	statements := statementList.</body><body package="HPSVM Primitive Plugins" selector="setStatements:">setStatements: stmtList	statements := stmtList asOrderedCollection.</body><body package="HPSVM Primitive Plugins" selector="statements">statements	^statements</body><body package="HPSVM Primitive Plugins" selector="tryToRemoveArgs:">tryToRemoveArgs: argsToRemove 	(arguments isSameSequenceAs: argsToRemove) ifFalse: [^false].	arguments := #().	^true</body></methods><methods><class-id>HPSVM.TtoCStmtListNode</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="hasReturn">hasReturn	^statements notEmpty and: [statements last isReturn]</body></methods><methods><class-id>Kernel.BlockNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationToCNode">asTranslationToCNode	| statementList |	statementList := OrderedCollection new.	body statements do:		[ :s | | newS |		newS := s asTranslationToCNode.		newS isStmtList			ifTrue:				["inline the statement list returned when a CascadeNode is translated"				statementList addAll: newS statements]			ifFalse: [statementList add: newS]].	^TtoCStmtListNode new		setArguments: (arguments asArray collect: [ :arg | arg name ])		statements: statementList;		comment: comment</body></methods><methods><class-id>HPSVM.CArrayAccessor</class-id> <category>comparing</category><body package="HPSVM Primitive Plugins" selector="&lt;">&lt; other	^ (object == other object) and: [offset &lt; other offset].</body><body package="HPSVM Primitive Plugins" selector="&lt;=">&lt;= other	^ (object == other object) and: [offset &lt;= other offset].</body><body package="HPSVM Primitive Plugins" selector="&gt;">&gt; other	^ (object == other object) and: [offset &gt; other offset].</body><body package="HPSVM Primitive Plugins" selector="&gt;=">&gt;= other	^ (object == other object) and: [offset &gt;= other offset].</body></methods><methods><class-id>HPSVM.CArrayAccessor</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="at:">at: index	^object at: index + offset + 1</body><body package="HPSVM Primitive Plugins" selector="at:put:">at: index put: value	^object at: index + offset + 1 put: value</body><body package="HPSVM Primitive Plugins" selector="byteAt:">byteAt: index	^object byteAt: index + offset + 1</body><body package="HPSVM Primitive Plugins" selector="cPtrAsOop">cPtrAsOop	offset = 0 ifFalse: [self error: 'offset must be zero'].	^object</body><body package="HPSVM Primitive Plugins" selector="longAt:">longAt: index	| idx |	idx := (offset + index) + 1.	"Note: This is a special hack for BitBlt."	(idx = (object basicSize + 1)) ifTrue:[^0].	^Buffer		replaceBytesFrom: 1 to: 4 with: object startingAt: idx; 		unsignedLongAt: 1</body><body package="HPSVM Primitive Plugins" selector="longAt:put:">longAt: index put: value	| idx |	idx := (offset + index) + 1.	Buffer unsignedLongAt: 1 put: value.	object replaceBytesFrom: idx to: idx + 3 with: Buffer startingAt: 1.	^value</body><body package="HPSVM Primitive Plugins" selector="next">next	|val|	val := self at: 0.	offset := offset + 1.	^val</body><body package="HPSVM Primitive Plugins" selector="size">size	^object size</body></methods><methods><class-id>HPSVM.CPluggableAccessor</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="at:">at: index	^readBlock value: object value: index + offset + 1</body><body package="HPSVM Primitive Plugins" selector="at:put:">at: index put: value	^writeBlock value: object value: index + offset + 1 value: value</body></methods><methods><class-id>HPSVM.CPluggableAccessor</class-id> <category>initialize</category><body package="HPSVM Primitive Plugins" selector="readBlock:writeBlock:">readBlock: rBlock writeBlock: wBlock	readBlock := rBlock.	writeBlock := wBlock</body></methods><methods><class-id>HPSVM.TtoCSendNode</class-id> <category>As yet unclassified</category><body package="HPSVM Primitive Plugins" selector="args">args	^arguments</body><body package="HPSVM Primitive Plugins" selector="bindVariableUsesIn:">bindVariableUsesIn: aDictionary	receiver := receiver bindVariableUsesIn: aDictionary.	arguments := arguments collect: [ :a | a bindVariableUsesIn: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="bindVariablesIn:">bindVariablesIn: aDictionary	receiver := receiver bindVariablesIn: aDictionary.	arguments := arguments collect: [ :a | a bindVariablesIn: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new		setSelector: selector		receiver: receiver copyTree		arguments: (arguments collect: [ :arg | arg copyTree ])		isBuiltInOp: isBuiltinOperator</body><body package="HPSVM Primitive Plugins" selector="emitCCodeAsArgumentOn:level:generator:">emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen	"Emit the receiver in a form that can be passed as an argument."	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructAsArgumentFor: self on: aStream level: level) ifFalse:		["Otherwise generate the vanilla C function call."		 self emitCCodeAsFunctionCallOn: aStream level: level generator: aCodeGen]</body><body package="HPSVM Primitive Plugins" selector="emitCCodeAsExpressionOn:level:generator:">emitCCodeAsExpressionOn: aStream level: level generator: aCodeGen	^self emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen	"Emit the receiver as a statement."	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifFalse:		["Otherwise generate the vanilla C function call."		 self emitCCodeAsFunctionCallOn: aStream level: level generator: aCodeGen]</body><body package="HPSVM Primitive Plugins" selector="inlineMethodsUsing:">inlineMethodsUsing: aDictionary	arguments := arguments collect: [ :arg |		arg inlineMethodsUsing: aDictionary.	].	"xxx inline this message if it is in the dictionary xxx"</body><body package="HPSVM Primitive Plugins" selector="isAssertion">isAssertion	^((selector beginsWith: 'assert') or: [selector beginsWith: 'verify']) or: [selector beginsWith: 'oe_assert']</body><body package="HPSVM Primitive Plugins" selector="isBuiltinOperator">isBuiltinOperator	^ isBuiltinOperator</body><body package="HPSVM Primitive Plugins" selector="isBuiltinOperator:">isBuiltinOperator: builtinFlag	isBuiltinOperator := builtinFlag.</body><body package="HPSVM Primitive Plugins" selector="isSend">isSend	^true</body><body package="HPSVM Primitive Plugins" selector="nodesDo:">nodesDo: aBlock	receiver nodesDo: aBlock.	arguments do: [ :arg | arg nodesDo: aBlock ].	aBlock value: self.</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	| keywords |	receiver printOn: aStream level: level.	arguments size = 0 ifTrue: [		aStream space; nextPutAll: selector.		^self	].	keywords := selector keywords.	1 to: keywords size do: [ :i |		aStream space.		aStream nextPutAll: (keywords at: i); space.		(arguments at: i) printOn: aStream level: level + 1.	].</body><body package="HPSVM Primitive Plugins" selector="receiver">receiver	^receiver</body><body package="HPSVM Primitive Plugins" selector="receiver:">receiver: aNode	receiver := aNode.</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	receiver removeAssertions.	arguments do: [:arg | arg removeAssertions].</body><body package="HPSVM Primitive Plugins" selector="replaceNodesIn:">replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		receiver := receiver replaceNodesIn: aDictionary.		arguments := arguments collect: [ :a | a replaceNodesIn: aDictionary ].		self]</body><body package="HPSVM Primitive Plugins" selector="selector">selector	^selector</body><body package="HPSVM Primitive Plugins" selector="setSelector:receiver:arguments:">setSelector: aSymbol receiver: rcvrNode arguments: argList	selector := aSymbol.	receiver := rcvrNode.	arguments := argList asArray.	isBuiltinOperator := false.</body><body package="HPSVM Primitive Plugins" selector="setSelector:receiver:arguments:isBuiltInOp:">setSelector: aSymbol receiver: rcvrNode arguments: argList isBuiltInOp: builtinFlag	selector := aSymbol.	receiver := rcvrNode.	arguments := argList asArray.	isBuiltinOperator := builtinFlag.</body><body package="HPSVM Primitive Plugins" selector="shouldEmitReturnForReturn">shouldEmitReturnForReturn	^selector ~~ #primitiveFail</body><body package="HPSVM Primitive Plugins" selector="visualWorks">visualWorks	^true</body></methods><methods><class-id>HPSVM.TtoCSendNode</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="emitCCodeAsFunctionCallOn:level:generator:">emitCCodeAsFunctionCallOn: aStream level: level generator: aCodeGen	"Translate this message send into a C function call."	aStream		nextPutAll: (aCodeGen cFunctionNameFor: selector);		nextPut: $(.	(receiver isVariable	 and: ['self' = receiver name			or: ['interpreterProxy' = receiver name]]) ifFalse:		["self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments notEmpty ifTrue: [aStream nextPut: $,; space]].	arguments		do: [ :arg| arg emitCCodeAsArgumentOn: aStream level: level generator: aCodeGen]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $)</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>plugin lists</category><body package="HPSVM Primitive Plugins" selector="allModuleNames">allModuleNames	"return the list of all the all plugins' moduleNames"	^Array streamContents:[:strm| self allPluginsDo:[:pl| strm nextPut: pl moduleName ]]</body><body package="HPSVM Primitive Plugins" selector="allPluginsDo:">allPluginsDo: aBlock 	"for each class that should be an external plugin, evaluate aBlock"	self externalPluginsDo: aBlock.	self internalPluginsDo: aBlock.</body><body package="HPSVM Primitive Plugins" selector="canSupportPlugin:">canSupportPlugin: pluginClassName 	"see if this plugin needs any external files and if so, check to see if 	they seem to exist."	[self validatePlugin: pluginClassName in: allPlugins , internalPlugins , externalPlugins]		on: VMMakerException		do: [:ex| ^ false].	^ true</body><body package="HPSVM Primitive Plugins" selector="externalFilesRequiredFor:">externalFilesRequiredFor: plugin	^plugin requiresCrossPlatformFiles or:[plugin requiresPlatformFiles]</body><body package="HPSVM Primitive Plugins" selector="externalModuleNames">externalModuleNames	"return the list of all the external plugins' moduleNames"	^Array streamContents:[:strm| self externalPluginsDo:[:pl| strm nextPut: pl moduleName ]]</body><body package="HPSVM Primitive Plugins" selector="externalPluginsDo:">externalPluginsDo: aBlock 	"for each class that should be an external plugin, evaluate aBlock"	self plugins: externalPlugins do: aBlock</body><body package="HPSVM Primitive Plugins" selector="internalModuleNames">internalModuleNames	"return the list of all the internal plugins' moduleNames"	^Array streamContents:[:strm| self internalPluginsDo:[:pl| strm nextPut: pl moduleName ]]</body><body package="HPSVM Primitive Plugins" selector="internalPluginsDo:">internalPluginsDo: aBlock 	"for each class that should be an internal plugin, evaluate aBlock"	self plugins: internalPlugins do: aBlock</body><body package="HPSVM Primitive Plugins" selector="plugins:do:">plugins: aCollection do: aBlock 	"for each class in aCollection that should be a plugin, evaluate aBlock"	aCollection do:		[:sym | 		(self class environment fullyQualifiedReferenceOf: sym)			ifDefinedDo:				[:value|				value isBehavior					ifTrue: [aBlock value: value]					ifFalse: ["Another place to raise a sensible error to the UI"							^self couldNotFindPluginClass: sym]]			elseDo: 				["Another place to raise a sensible error to the UI"				^self couldNotFindPluginClass: sym]]</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>UI access</category><body package="HPSVM Primitive Plugins" selector="availablePlugins">availablePlugins	allPlugins ifNil:[self initializeAllPlugins].	^allPlugins</body><body package="HPSVM Primitive Plugins" selector="externalModules">externalModules	^externalPlugins</body><body package="HPSVM Primitive Plugins" selector="internalModules">internalModules	^internalPlugins</body><body package="HPSVM Primitive Plugins" selector="listOfName:">listOfName: aSymbol	"work out which list is the one associated with this symbol"	#availableModules = aSymbol ifTrue:[^allPlugins].	#internalModules = aSymbol ifTrue:[^internalPlugins].	#externalModules =aSymbol ifTrue:[^externalPlugins].	^nil</body><body package="HPSVM Primitive Plugins" selector="logger">logger	^logger</body><body package="HPSVM Primitive Plugins" selector="logger:">logger: aStream	logger := aStream.</body><body package="HPSVM Primitive Plugins" selector="makeAllModulesAvailable">makeAllModulesAvailable	self internal: #() external: #().	self reinitializePluginsLists</body><body package="HPSVM Primitive Plugins" selector="makeAllModulesExternal">makeAllModulesExternal	self initializeAllPlugins.	self internal: #() external: self availablePlugins.	self changed: #reinitialize</body><body package="HPSVM Primitive Plugins" selector="makeAllModulesInternal">makeAllModulesInternal	self initializeAllPlugins.	self internal: self availablePlugins external: #().	self changed: #reinitialize</body><body package="HPSVM Primitive Plugins" selector="movePlugin:from:to:">movePlugin: pluginName from: srcListName to: dstListName	"the VMMakerTool UI has been used to drag a plugin from one list to 	another "	"we need to do some tests - 	are the lists actually ours? 	is the plugin ours? 	is the destination list one where we must check the plugin for 	acceptability? return true if all is ok, false otherwise"	| dstList srcList |	dstList := self listOfName: dstListName.	srcList := self listOfName: srcListName.	dstList == allPlugins		ifTrue: [dstList				add: (srcList remove: pluginName)]		ifFalse: ["the dest must be internal or external, so check the plugin for 			acceptability "			(self canSupportPlugin: pluginName)				ifTrue: [dstList						add: (srcList remove: pluginName)]]</body><body package="HPSVM Primitive Plugins" selector="platformName">platformName	^platformName</body><body package="HPSVM Primitive Plugins" selector="reinitializePluginsLists">reinitializePluginsLists	"something has changed that affects the validity of the plugin lists. Recalculate them as best we can. It is probably possible to check on the current lists and keep the configuration as close as possible the same; but for the moment just try to use the same lists "	self initializeAllPlugins.	self internal: internalPlugins external: externalPlugins.	self changed: #reinitialize</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>objects from disk</category><body package="HPSVM Primitive Plugins" selector="configurationInfo">configurationInfo	"build a simple Array of the configuration information that would be 	usefully saved for later reloading:- 	the list of internal &amp; external plugins, the flags, the platform name, and the two major directory names"	^ Array new writeStream nextPut: internalPlugins;		 nextPut: externalPlugins;		 nextPut: inline;		 nextPut: forBrowser;		 nextPut: platformName;		 nextPut: self sourceDirectory pathName;		 nextPut: self platformRootDirectory pathName;	contents</body><body package="HPSVM Primitive Plugins" selector="loadConfiguration:">loadConfiguration: aConfigArray	"load the configuration but ignore the platformName - the platform name must have been handled during the creation of this vmmaker in order for it to work correctly"	inline := aConfigArray at:3.	forBrowser := aConfigArray at: 4.	"This part must be ignored --&gt; self setPlatName: (aConfigArray at: 5)."	self sourceDirectoryName: (aConfigArray at: 6).	self platformRootDirectoryName: ( aConfigArray at:7).	self initializeAllPlugins.	self internal: (aConfigArray at:1) external:(aConfigArray at:2).	self changed: #reinitialize</body><body package="HPSVM Primitive Plugins" selector="readConfigurationFrom:">readConfigurationFrom: aFileName	"read info about the current configuration from a file. Return the array that would have been made by #configurationInfo"	|  fileStream |	fileStream := aFileName readStream.	^[fileStream fileInObjectAndCode] ensure: [fileStream close]</body><body package="HPSVM Primitive Plugins" selector="saveConfigurationTo:">saveConfigurationTo: aFile	"write info about the current configuration to a file."	| fileStream |	fileStream := aFile asFilename newReadWriteStream.	[fileStream fileOutClass: nil andObject: self configurationInfo] ensure: [fileStream close]</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>copying files</category><body package="HPSVM Primitive Plugins" selector="copyAssortedFiles">copyAssortedFiles	"copy any miscellaneous files/dirs from the cross-platformDirectory/misc/ToCopy -  	general readme files etc, then from the platform specific directory/misc/ToCopy - makefiles, 	utils etc that have to be copied."	| srcDir |	"Is there a crossPlatformDirectory subdirectory called 'misc'?"	(self crossPlatformDirectory directoryExists: 'misc')		ifTrue: [srcDir := self crossPlatformDirectory directoryNamed: 'misc'.			"Is there a subdirectory called 'ToCopy' ?"			(srcDir directoryExists: 'ToCopy') ifTrue:[				srcDir := srcDir directoryNamed: 'ToCopy'.				self copyFilesFromSourceDirectory: srcDir toTargetDirectory: self sourceDirectory]].	"Is there a platformDirectory subdirectory called 'misc'?"	(self platformDirectory directoryExists: 'misc')		ifTrue: [srcDir := self platformDirectory directoryNamed: 'misc'.			"Is there a subdirectory called 'ToCopy' ?"			(srcDir directoryExists: 'ToCopy') ifTrue:[				srcDir := srcDir directoryNamed: 'ToCopy'.				self copyFilesFromSourceDirectory: srcDir toTargetDirectory: self sourceDirectory]]</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>private - copying files</category><body package="HPSVM Primitive Plugins" selector="copyFilesFrom:to:">copyFilesFrom: srcDir to: dstDir 	"This really ought to be a facility in file system. The major annoyance here is that file types and permissions are not handled by current Squeak code"		srcDir fileNames do: [:filenm | (srcDir fullNameFor: filenm) copyTo: (dstDir fullNameFor: filenm)]</body><body package="HPSVM Primitive Plugins" selector="copyFilesFromSourceDirectory:toTargetDirectory:">copyFilesFromSourceDirectory: srcDir toTargetDirectory: dstDir 	"copy all the files and directories from srcDir to dstDir, recursively"		self copyFilesFromSourceDirectory: srcDir			toTargetDirectory: dstDir			recursively: true</body><body package="HPSVM Primitive Plugins" selector="copyFilesFromSourceDirectory:toTargetDirectory:recursively:">copyFilesFromSourceDirectory: srcDir toTargetDirectory: dstDir recursively: recurseBoolean	"copy all files and subdirectories from srcDir to dstDir, optionally recursing down the tree.	It is assumed that both directories already exist and have appropriate 	permissions - proper error handling ought to be provided sometime. 	Note how nice it would be if the file system classes already did this; 	why, they could even defer to an improved file plugin for some of 	these things."	"copy all the files"	| dirList  |	srcDir localName = 'CVS' ifTrue:[logger show: 'CVS files NOT copied by VMMaker'; cr. ^self].	self copyFilesFrom: srcDir to: dstDir.	recurseBoolean ifFalse:[^self].	"If we are recursing create the subdirectories of srcDir in dstDir, and then copy that 	subtree "	dirList := srcDir directoryNames copyWithout: 'CVS'.	dirList do: 		[:newDstDir | 		(dstDir directoryExists: newDstDir)			ifFalse: [dstDir createDirectory: newDstDir].		self copyFilesFromSourceDirectory: (srcDir directoryNamed: newDstDir)			toTargetDirectory: (dstDir directoryNamed: newDstDir)			recursively: true]</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>target directories</category><body package="HPSVM Primitive Plugins" selector="coreVMDirectory">coreVMDirectory	"return the target directory for the main VM sources, interp.c etc"	| fd |	fd := self sourceDirectory directoryNamed: self class coreVMDirName.	fd assureExistence.	^ fd</body><body package="HPSVM Primitive Plugins" selector="deleteEntireGeneratedTree">deleteEntireGeneratedTree	"remove all the files - all of them I say"	self sourceDirectory recursiveDelete</body><body package="HPSVM Primitive Plugins" selector="deleteUnwantedExternalPluginDirectories">deleteUnwantedExternalPluginDirectories	"delete directories in the external plugins tree with names not in the list  	of external plugins. This will make sure that only wanted plugins are  	left after generating external plugins - no previous ones will get left  	there like unwanted porridge"	(self externalPluginsDirectory directoryNames copyWithoutAll: self externalModuleNames)		do: [:nm | (self externalPluginsDirectory directoryNamed: nm) recursiveDelete]</body><body package="HPSVM Primitive Plugins" selector="deleteUnwantedInternalPluginDirectories">deleteUnwantedInternalPluginDirectories	"delete directories in the internal plugins tree with names not in the list  	of internal plugins. This will make sure that only wanted plugins are  	left after generating internal plugins - no previous ones will get left  	there like unwanted porridge"	(self internalPluginsDirectory directoryNames copyWithoutAll: self internalModuleNames)		do: [:nm | (self internalPluginsDirectory directoryNamed: nm) recursiveDelete]</body><body package="HPSVM Primitive Plugins" selector="externalPluginsDirectory">externalPluginsDirectory	"return the target directory for the external plugins sources"	| fd |	fd := self sourceDirectory directoryNamed: self class pluginsDirName.	fd assureExistence.	^fd</body><body package="HPSVM Primitive Plugins" selector="externalPluginsDirectoryFor:">externalPluginsDirectoryFor: plugin	"return the directory for the external plugin sources"	|fd|	fd := self externalPluginsDirectory directoryNamed: plugin moduleName.	fd assureExistence.	^fd</body><body package="HPSVM Primitive Plugins" selector="internalPluginsDirectory">internalPluginsDirectory	"return the directory for the internal plugins sources"	|fd|	fd := self coreVMDirectory directoryNamed: 'intplugins'.	fd assureExistence.	^fd</body><body package="HPSVM Primitive Plugins" selector="internalPluginsDirectoryFor:">internalPluginsDirectoryFor: plugin	"return the directory for the internal plugin sources"	|fd|	fd := self internalPluginsDirectory directoryNamed: plugin moduleName.	fd assureExistence.	^fd</body><body package="HPSVM Primitive Plugins" selector="makefileDirectory">makefileDirectory"where to put generated makefile related files"	^self sourceDirectory</body><body package="HPSVM Primitive Plugins" selector="sourceDirectory">sourceDirectory	| fd |	fd := Filename defaultDirectory directoryNamed: (sourceDirName		ifNil: [self class sourceDirName]).	fd assureExistence.	^ fd</body><body package="HPSVM Primitive Plugins" selector="sourceDirectoryName:">sourceDirectoryName: aString	"Sanity check really ought to be added, This is the root directory for where the sources will be WRITTEN"	sourceDirName := aString.	sourceDirName asFilename assureExistence.	self changed: #sourceDirectory.	^true</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>private - errors</category><body package="HPSVM Primitive Plugins" selector="couldNotFindDirectory:">couldNotFindDirectory: dirName	"This should raise a nice exception to a UI"	(VMMakerException new messageText: self class name, ' could not find directory ', dirName) raise</body><body package="HPSVM Primitive Plugins" selector="couldNotFindPlatformDirectoryFor:">couldNotFindPlatformDirectoryFor: platName	"This should raise a nice exception to a UI"	self couldNotFindDirectory: 'for: ', platName, ' specific files; is the platform root path set correctly?'</body><body package="HPSVM Primitive Plugins" selector="couldNotFindPlatformFilesFor:">couldNotFindPlatformFilesFor: plugin	"This should raise a nice exception to a UI"	(VMMakerException new messageText: self class name, ' could not find platform specific files for: ', plugin moduleName) raise</body><body package="HPSVM Primitive Plugins" selector="couldNotFindPluginClass:">couldNotFindPluginClass: pluginSymbol	"This should raise a nice exception to a UI"	(VMMakerException new messageText: self class name, ' could not find the class for: ', pluginSymbol) raise</body><body package="HPSVM Primitive Plugins" selector="couldNotOpenFile:">couldNotOpenFile: fileName	"This should raise a nice exception to a UI"	(VMMakerException new messageText: self class name, ' could not open file: ', fileName) raise</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>source directories</category><body package="HPSVM Primitive Plugins" selector="crossPlatformDirectory">crossPlatformDirectory	"return the directory where we should find the cross-platform literal 	sources - &lt;sq.h&gt; etc"	| fd machDirNm |	fd := self platformRootDirectory.	machDirNm := 'Cross'.	((fd directoryExists: machDirNm) not	and: [WhineAboutMissingDirectories]) ifTrue:		["The supposed directory for the actual cross-platform code does not exist."		 ^ self couldNotFindPlatformDirectoryFor: 'cross-platform '].	^ fd directoryNamed: machDirNm</body><body package="HPSVM Primitive Plugins" selector="crossPlatformPluginsDirectory">crossPlatformPluginsDirectory	"return the directory where we should find the cross-platform plugin specific sources"	((self crossPlatformDirectory directoryExists: self class pluginsDirName) not	 and: [WhineAboutMissingDirectories]) ifTrue:		["The supposed directory for the plugins code does not exist.		  We need to raise a suitable exception, but can't think of one right now."		 ^self couldNotFindPlatformDirectoryFor: 'any plugins needing cross-platform'].	^self crossPlatformDirectory directoryNamed: self class pluginsDirName</body><body package="HPSVM Primitive Plugins" selector="platformDirectory">platformDirectory	"return the directory where we should find the platform specific sources"	| fd platNm |	fd := self platformRootDirectory.	platNm := self platformName.	((fd directoryExists: platNm) not	and: [WhineAboutMissingDirectories]) ifTrue:		["The supposed directory for the actual platform code does not exist."		 ^ self couldNotFindPlatformDirectoryFor: platNm].	^ fd directoryNamed: platNm</body><body package="HPSVM Primitive Plugins" selector="platformPluginsDirectory">platformPluginsDirectory	"return the directory where we should find the platform plugin specific sources"	((self platformDirectory directoryExists: self class pluginsDirName) not	and: [WhineAboutMissingDirectories]) ifTrue:		["The supposed directory for the plugins code does not  exist.		  We need to raise a suitable exception, but can't think of one right now."		 ^self couldNotFindPlatformDirectoryFor: 'any plugins needing ', self platformName].	^self platformDirectory directoryNamed: self class pluginsDirName</body><body package="HPSVM Primitive Plugins" selector="platformRootDirectory">platformRootDirectory	"return the directory where we should find all platform's sources"	| fileName |	fileName := Filename defaultDirectory construct: (platformRootDirName ifNil: [self class platformsDirName]).	((fileName exists and: [fileName isDirectory]) not	 and: [WhineAboutMissingDirectories]) ifTrue:		["The supposed directory for the platforms code does not  exist."		^ self couldNotFindDirectory: 'the platform code tree'].	^fileName</body><body package="HPSVM Primitive Plugins" selector="platformRootDirectoryName:">platformRootDirectoryName: aString	"set the directory where we should find all platform's sources	There really ought to be plausible sanity checks done here"	platformRootDirName := aString.	(Filename defaultDirectory directoryExists: aString) ifFalse:[self couldNotFindDirectory: aString. ^false].	self reinitializePluginsLists.	^true</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>exports</category><body package="HPSVM Primitive Plugins" selector="export:forExternalPlugin:">export: exportList forExternalPlugin: aPlugin"it may be useful on certain platforms to do something with the export list of external plugins, just as the internal plugins' exports get added to the VM list. Default is to do nothing though."</body><body package="HPSVM Primitive Plugins" selector="generateExportsFile">generateExportsFile	^self storeExportsOn:(self coreVMDirectory fullNameFor: 'sqNamedPrims.h').</body><body package="HPSVM Primitive Plugins" selector="storeExportsOn:">storeExportsOn: aFilename 	"Store the exports on the given file"	| s |	[s := aFilename asFilename newReadWriteStream.	 self class setLineEndConventionForCode: s] 		on: OsInaccessibleError		do:[^self couldNotOpenFile: aFilename].	s nextPutAll:'/* This is an automatically generated table of all builtin modules in the VM */'; cr.	s cr; nextPutAll:'extern sqExport vm_exports[];'.	s cr; nextPutAll: 'extern sqExport os_exports[];'.	self internalPluginsDo:[:cls|		s cr; nextPutAll: 'extern sqExport '; nextPutAll: cls moduleName; nextPutAll:'_exports[];'.	].	s cr.	s cr; nextPutAll:'sqExport *pluginExports[] = {'.	s crtab; nextPutAll:'vm_exports,'.	s crtab; nextPutAll: 'os_exports,'.	self internalPluginsDo:[:cls|		s crtab; nextPutAll: cls moduleName; nextPutAll:'_exports,'	].	s crtab; nextPutAll:'NULL'.	s cr; nextPutAll:'};'; cr.	s close</body><body package="HPSVM Primitive Plugins" selector="storeExternalPluginList">storeExternalPluginList	| s fileName |	fileName := self makefileDirectory fullNameFor: 'plugins.ext'.	[s := fileName asFilename newReadWriteStream.	 self class setLineEndConventionForCode: s] 		on: OsInaccessibleError		do:[^self couldNotOpenFile: fileName].	s nextPutAll:'# Automatically generated makefile include for external plugins'.	s cr; nextPutAll:'EXTERNAL_PLUGINS ='.	self externalPluginsDo:[:cls|		s space; nextPutAll: cls moduleName.	].	s cr; close</body><body package="HPSVM Primitive Plugins" selector="storeInternalPluginList">storeInternalPluginList	| s fileName |	fileName := self makefileDirectory fullNameFor: 'plugins.int'.	[s := fileName asFilename newReadWriteStream.	 self class setLineEndConventionForCode: s] 		on: OsInaccessibleError		do:[^self couldNotOpenFile: fileName].	s nextPutAll:'# Automatically generated makefile include for internal plugins'.	s cr; nextPutAll:'INTERNAL_PLUGINS ='.	self internalPluginsDo:[:cls|		s space; nextPutAll: cls moduleName.	].	s cr; close</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>generate sources</category><body package="HPSVM Primitive Plugins" selector="generateEntire">generateEntire"generate the interp, internal plugins and exports as well as the external plugins"	self generateMainVM.	self generateExternalPlugins.</body><body package="HPSVM Primitive Plugins" selector="generateExternalPlugin:">generateExternalPlugin: pluginName 	"generate the named external plugin"	| exports plugin |	"Refuse to translate this plugin if it requires platform specific files and they are not present."	plugin := [self validateExternalPlugin: pluginName]				on: VMMakerException				do:[:ex| ^self].	exports := plugin				translateInDirectory: (self externalPluginsDirectoryFor: plugin)				doInlining: inline.	logger show: 'external plugin ' , plugin name , ' generated as ' , plugin moduleName; cr.	exports ifNotNil: ["if exp is nil we skip this since the plugin was already up to date"			self export: exports forExternalPlugin: plugin].	self processFilesForExternalPlugin: plugin</body><body package="HPSVM Primitive Plugins" selector="generateExternalPlugins">generateExternalPlugins	"generate the external plugins"	self deleteUnwantedExternalPluginDirectories.	self externalPluginsDo: [:plugin | 		self generateExternalPlugin: plugin].	self storeExternalPluginList.</body><body package="HPSVM Primitive Plugins" selector="generateInternalPlugin:">generateInternalPlugin: pluginName 	"generate the named internal plugin. Make sure the exports list is actually 	correct and write it out"	self deleteUnwantedInternalPluginDirectories.	self privateGenerateInternalPlugin: pluginName.	self generateExportsFile</body><body package="HPSVM Primitive Plugins" selector="generateInternalPlugins">generateInternalPlugins	"generate the internal plugins and add their exports to the main list. te exports list is NOT written to file by this method"	self deleteUnwantedInternalPluginDirectories.	self internalPluginsDo: [:plugin | 		self privateGenerateInternalPlugin: plugin].	self storeInternalPluginList.</body><body package="HPSVM Primitive Plugins" selector="generateInterpreterFile">generateInterpreterFile	"generate the main 'interp.c' file for the interpreter and the list of 	export statments"	self excised:		'Interpreter			translateInDirectory: self coreVMDirectory			doInlining: inline			forBrowserPlugin: forBrowser.'</body><body package="HPSVM Primitive Plugins" selector="generateMainVM">generateMainVM"generate the interp, internal plugins and exports"	self generateInterpreterFile;		processFilesForCoreVM;		processAssortedFiles;		generateInternalPlugins;		generateExportsFile</body><body package="HPSVM Primitive Plugins" selector="privateGenerateInternalPlugin:">privateGenerateInternalPlugin: pluginName 	"generate the named internal plugin"	| plugin |	"Refuse translate this plugin if it requires platform specific files and  	they are not present."	plugin := self validateInternalPlugin: pluginName.	plugin		ifNil: [^ self couldNotFindPluginClass: pluginName].	plugin		translateInDirectory: (self internalPluginsDirectoryFor: plugin)		doInlining: inline.	logger show: 'internal plugin ' , plugin name , ' generated as ' , plugin moduleName; cr.	self processFilesForInternalPlugin: plugin.</body><body package="HPSVM Primitive Plugins" selector="validateExternalPlugin:">validateExternalPlugin:	plName	^self validatePlugin: plName in: externalPlugins</body><body package="HPSVM Primitive Plugins" selector="validateInternalPlugin:">validateInternalPlugin:	plName	^self validatePlugin: plName in: internalPlugins</body><body package="HPSVM Primitive Plugins" selector="validatePlugin:in:">validatePlugin:	plName in: listOfPlugins"check that the plName is either an actual plugin class or a plugin class name. Return the plugin class or raise an error if nil"	| plugin |	plName isString		ifTrue: [(listOfPlugins includes: plName)				ifTrue: [plugin := self class environment at: plName]]		ifFalse: [((plName isBehavior						and: [plName inheritsFrom: InterpreterPlugin])					and: [listOfPlugins includes: plName name])				ifTrue: [plugin := plName]].	plugin ifNil: [^ self couldNotFindPluginClass: plName].	"Is there a cross-platform or platform files directory of the same name as this plugin?"	plugin requiresPlatformFiles		ifTrue: [(self platformPluginsDirectory directoryExists: plugin moduleName)				ifFalse: [logger show: 'No platform specific files found for ' , plugin moduleName printString; cr.					^ self couldNotFindPlatformFilesFor: plugin]].	plugin requiresCrossPlatformFiles		ifTrue: [(self crossPlatformPluginsDirectory directoryExists: plugin moduleName)				ifFalse: [logger show: 'No cross platform files found for ' , plugin moduleName printString; cr.					^ self couldNotFindPlatformFilesFor: plugin]].	^plugin</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>initialize</category><body package="HPSVM Primitive Plugins" selector="initialize">initialize	logger := Transcript.	inline := true.	forBrowser := false.	internalPlugins := SortedCollection new.	externalPlugins := SortedCollection new.	platformName := self class machinesDirName.	allFilesList := Dictionary new</body><body package="HPSVM Primitive Plugins" selector="initializeAllExternal">initializeAllExternal	"add all the plugins to the external list and make sure the internal list is empty"	self initializeInternal: #() external: self availablePlugins</body><body package="HPSVM Primitive Plugins" selector="initializeAllExternalBut:">initializeAllExternalBut: arrayOfInternalPluginNames	"add all the plugins to the external list except for those listed, which should be added to the internal list"	self initializeInternal: arrayOfInternalPluginNames external: (self availablePlugins copyWithoutAll: arrayOfInternalPluginNames )</body><body package="HPSVM Primitive Plugins" selector="initializeAllInternal">initializeAllInternal	"add all the plugins to the internal list and make sure the external list is empty"	self initializeInternal: self availablePlugins  external: #()</body><body package="HPSVM Primitive Plugins" selector="initializeAllInternalBut:">initializeAllInternalBut: arrayOfExternalPluginNames	"add all the plugins to the internal list except for those listed, which should be added to the external list"	self initializeInternal: (self availablePlugins copyWithoutAll: arrayOfExternalPluginNames) external:  arrayOfExternalPluginNames</body><body package="HPSVM Primitive Plugins" selector="initializeAllPlugins">initializeAllPlugins	allPlugins := self providedPlugins</body><body package="HPSVM Primitive Plugins" selector="initializeInternal:external:">initializeInternal: arrayOfInternalPluginNames external: arrayOfExternalPluginNames	"try to set up with the listed internal and external plugins."	self initialize.	self internal: arrayOfInternalPluginNames external: arrayOfExternalPluginNames</body><body package="HPSVM Primitive Plugins" selector="internal:external:">internal: arrayOfInternalPluginNames external: arrayOfExternalPluginNames	"try to set up with the listed internal and external plugins. Check that they are supportable plugins, reject those that are not - remember that this depends on the platform etc "	"since we went to some trouble to drop plugins we cannot handle, don't add them now"	internalPlugins := (allPlugins intersection: arrayOfInternalPluginNames) select: [:pl | self canSupportPlugin: pl].	allPlugins := allPlugins copyWithoutAll: internalPlugins.	externalPlugins := (allPlugins intersection: arrayOfExternalPluginNames) select: [:pl | self canSupportPlugin: pl ].	allPlugins := allPlugins copyWithoutAll: externalPlugins.</body><body package="HPSVM Primitive Plugins" selector="providedPlugins">providedPlugins	"generate the list by asking the InterpreterPlugins"	^ ((InterpreterPlugin allSubclasses		select: [:cl | cl shouldBeTranslated])		collect: [:cl | cl name]) asSortedCollection</body><body package="HPSVM Primitive Plugins" selector="setPlatName:">setPlatName: aString	"private - just set the platform name string, nothing else. Go away...."	platformName := aString</body></methods><methods><class-id>HPSVM.VMMaker</class-id> <category>processing external files</category><body package="HPSVM Primitive Plugins" selector="processAssortedFiles">processAssortedFiles	"Here is where we get a chance to process any files needed as part of the make process; instructions, makefile fragments, resources etc.	The default is to copy any miscellaneous files/dirs from the cross-platformDirectory/misc/ToCopy, then from the platform specific directory/misc/ToCopy. You can put any tree structure you like under misc/ToCopy, should that be important to you."	| srcDir |	"Is there a crossPlatformDirectory subdirectory called 'misc'?"	(self crossPlatformDirectory directoryExists: 'misc')		ifTrue: [srcDir := self crossPlatformDirectory directoryNamed: 'misc'.			"Is there a subdirectory called 'ToCopy' ?"			(srcDir directoryExists: 'ToCopy') ifTrue:[				srcDir := srcDir directoryNamed: 'ToCopy'.				self copyFilesFromSourceDirectory: srcDir toTargetDirectory: self sourceDirectory]].	"Is there a platformDirectory subdirectory called 'misc'?"	(self platformDirectory directoryExists: 'misc')		ifTrue: [srcDir := self platformDirectory directoryNamed: 'misc'.			"Is there a subdirectory called 'ToCopy' ?"			(srcDir directoryExists: 'ToCopy') ifTrue:[				srcDir := srcDir directoryNamed: 'ToCopy'.				self copyFilesFromSourceDirectory: srcDir toTargetDirectory: self sourceDirectory]]</body><body package="HPSVM Primitive Plugins" selector="processFilesForCoreVM">processFilesForCoreVM	"process any cross-platform files from the crossPlatformDir and then any files relating to the core vm from the platformDirectory's vm subdirectory."	"This is a stub ready for collecting all the filenames etc that might be needed to write a makefile. No details are yet certain."	| vmDirName fList |	vmDirName := self class coreVMDirName.	fList := OrderedCollection new.	(Array		with: (self crossPlatformDirectory directoryNamed: vmDirName)		with: (self platformDirectory directoryNamed: vmDirName)		with: self coreVMDirectory)		do:[:dir| fList addAll: (dir fullNamesOfAllFilesInSubtree reject:[:el| (el findString: 'CVS' startingAt: 1) ~= 0])].	allFilesList at: 'vm' put: fList</body><body package="HPSVM Primitive Plugins" selector="processFilesForExternalPlugin:">processFilesForExternalPlugin: plugin 	"process any files relating to the external plugin.	This also provides a  stub ready for collecting all the filenames etc that might be needed to write a makefile, carefully weeding out any CVS related files. No details are yet certain."	|fList|	fList := OrderedCollection new.	(Array		with: (self crossPlatformPluginsDirectory directoryNamed:  plugin moduleName)		with: (self platformPluginsDirectory directoryNamed:  plugin moduleName)		with: (self externalPluginsDirectoryFor: plugin))		do:[:dir| fList addAll: (dir fullNamesOfAllFilesInSubtree reject:[:el| (el findString: 'CVS' startingAt: 1) ~= 0])].	allFilesList at: plugin moduleName put: fList</body><body package="HPSVM Primitive Plugins" selector="processFilesForInternalPlugin:">processFilesForInternalPlugin: plugin 	"process any files relating to the internal plugin.	This also provides a  stub ready for collecting all the filenames etc that might be needed to write a makefile, carefully weeding out any CVS related files. No details are yet certain."	|fList|	fList := OrderedCollection new.	(Array		with: (self crossPlatformPluginsDirectory directoryNamed:  plugin moduleName)		with: (self platformPluginsDirectory directoryNamed:  plugin moduleName)		with: (self internalPluginsDirectoryFor: plugin))		do:[:dir| fList addAll: (dir fullNamesOfAllFilesInSubtree reject:[:el| (el findString: 'CVS' startingAt: 1) ~= 0])].	allFilesList at: plugin moduleName put: fList</body></methods><methods><class-id>HPSVM.VMMaker class</class-id> <category>initialisation</category><body package="HPSVM Primitive Plugins" selector="activeVMMakerClassFor:">activeVMMakerClassFor: platformName	"Return the concrete VMMaker subclass for the platform on which we are currently running."	VMMaker allSubclasses do: [:class |		(class isActiveVMMakerClassFor: platformName) ifTrue: [^ class]].	"no responding subclass; use VMMaker"	^ VMMaker</body><body package="HPSVM Primitive Plugins" selector="default">default	"return a VMMaker initialised to build a default no-internal-plugins, no-external-plugins vm codebase"	^self forPlatform: Smalltalk platformName</body><body package="HPSVM Primitive Plugins" selector="forConfigurationFile:">forConfigurationFile: aFileName	| config  fileStream vmMaker |	fileStream := aFileName asFilename readStream.	[config := fileStream fileInObjectAndCode] ensure: [fileStream close].	vmMaker := self forPlatform: (config at: 5).	vmMaker loadConfiguration: config.	^vmMaker</body><body package="HPSVM Primitive Plugins" selector="forPlatform:">forPlatform: platformName	"return a VMMaker initialised to build a default no-internal-plugins, no-external-plugins vm codebase"	^(self activeVMMakerClassFor: platformName) new initialize setPlatName: platformName</body><body package="HPSVM Primitive Plugins" selector="initialize">initialize	"HPSVM.VMMaker initialize"	DirNames := Dictionary new.	DirNames at: #coreVMDir put: 'vm';		at: #platformsDir put: 'platforms';		at: #pluginsDir put: 'plugins';		at: #sourceDir put: 'src'</body><body package="HPSVM Primitive Plugins" selector="isActiveVMMakerClassFor:">isActiveVMMakerClassFor: platformName 	"Does this class claim to be that properly active subclass of VMMaker for 	this platform? Subclasses are welcome to override this default"	^ platformName , '*' match: self name</body></methods><methods><class-id>HPSVM.VMMaker class</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="coreVMDirName">coreVMDirName	^DirNames at: #coreVMDir</body><body package="HPSVM Primitive Plugins" selector="machinesDirName">machinesDirName	^DirNames at: #machineType ifAbsent:[OSHandle currentOS]</body><body package="HPSVM Primitive Plugins" selector="platformsDirName">platformsDirName	^DirNames at: #platformsDir</body><body package="HPSVM Primitive Plugins" selector="pluginsDirName">pluginsDirName	^DirNames at: #pluginsDir</body><body package="HPSVM Primitive Plugins" selector="setLineEndConventionForCode:">setLineEndConventionForCode: aStream	"Set the line end convention in which to generate C code.  It turns out that	 all the compilers used so far with VisualWorks accept files in unix's lineEndLF	 conventioln, so we use that."	aStream lineEndLF.	^aStream</body><body package="HPSVM Primitive Plugins" selector="sourceDirName">sourceDirName	^DirNames at: #sourceDir</body></methods><methods><class-id>HPSVM.VMMaker class</class-id> <category>instance creation</category><body package="HPSVM Primitive Plugins" selector="new">new	^super new initialize</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>public</category><body package="HPSVM Primitive Plugins" selector="addAllClassVarsFor:">addAllClassVarsFor: aClass	"Add the class variables for the given class (and its superclasses) to the code base as constants."	| allClasses |	allClasses := aClass withAllSuperclasses.	allClasses do: [:c | self addClassVarsFor: c].</body><body package="HPSVM Primitive Plugins" selector="addClass:">addClass: aClass 	"Add the variables and methods of the given class to the code base."	self checkClassForNameConflicts: aClass.	self addClassVarsFor: aClass.	"ikp..."	self addPoolVarsFor: aClass.	variables addAll: aClass pluginGlobalVariables.	'Adding Class ' , aClass name , '...'		displayProgressAt: InputSensor cursorPoint		from: 0		to: aClass selectors size		during: 			[:bar |			aClass selectors asSortedCollection				doWithIndex: 					[:sel :i | 	| source |					bar value: i.					source := aClass sourceCodeAt: sel.					self addMethod: (((Compiler new							parse: source							in: aClass							notifying: nil)							node asTranslationMethodOfClass: self translationMethodClass)								definingClass: aClass;								yourself)]]</body><body package="HPSVM Primitive Plugins" selector="addClassVarsFor:">addClassVarsFor: aClass	"Add the class variables for the given class to the code base as constants."	aClass classPool bindingsDo: [:assoc | 		constants			at: assoc key asString			put: (TtoCConstantNode new setValue: assoc value)]</body><body package="HPSVM Primitive Plugins" selector="addHeaderFile:">addHeaderFile: aString	"Add a header file."	(headerFiles includes: aString) ifFalse:		[headerFiles addLast: aString]</body><body package="HPSVM Primitive Plugins" selector="addMethodsForPrimitives:">addMethodsForPrimitives: classAndSelectorList 	| verbose definingClass |	classAndSelectorList do: 		[:classAndSelector | | sel aClass source meth |		aClass := (classAndSelector at: 1) asQualifiedReference value.		self addAllClassVarsFor: aClass."TPR - should pool vars also be added here?"		"find the method in either the class or the metaclass"		sel := classAndSelector at: 2.		definingClass := (aClass includesSelector: sel)							ifTrue: [aClass]							ifFalse: [aClass class].		source := definingClass sourceCodeAt: sel.		"compile the method source and convert to a suitable translation method "		meth := (Compiler new					parse: source					in: definingClass					notifying: nil)					asTranslationMethodOfClass: self translationMethodClass.		meth definingClass: definingClass.		"for old-style array accessing: 		meth covertToZeroBasedArrayReferences."		meth replaceSizeMessages.		self addMethod: meth].	"method preparation"	verbose := true.	self prepareMethods.	verbose ifTrue: 		[self printUnboundCallWarnings.		 self printUnboundVariableReferenceWarnings.		 Transcript cr].	"code generation"	self doInlining: true.	methods do:		[:m|		"if this method is supposed to be a primitive (rather than a helper 		routine), add assorted prolog and epilog items"		m primitive &gt; 0 ifTrue: [m preparePrimitivePrologue]].</body><body package="HPSVM Primitive Plugins" selector="addPoolVarsFor:">addPoolVarsFor: aClass 	"Add the pool variables for the given class to the code base as constants."	aClass sharedPools do: [:pool |		pool asNameSpace bindingsDo: [:assoc |			constants at: assoc key asString 				put: (TtoCConstantNode new setValue: assoc value)]]</body><body package="HPSVM Primitive Plugins" selector="addReservedWord:">addReservedWord: aString	"Add a reserved word."	reservedWords add: aString.</body><body package="HPSVM Primitive Plugins" selector="addVar:type:">addVar: varName type: type	self var: varName type: type.	variables add: varName</body><body package="HPSVM Primitive Plugins" selector="addWordToUndefine:">addWordToUndefine: aString	"Add a word to undefine in the prolog."	wordsToUndefine add: aString.</body><body package="HPSVM Primitive Plugins" selector="codeString">codeString	"Return a string containing all the C code for the code base. Used for testing."	| stream |	stream := ReadWriteStream on: (String new: 1000).	self emitCCodeOn: stream doInlining: true doAssertions: true.	^stream contents</body><body package="HPSVM Primitive Plugins" selector="codeStringForPrimitives:">codeStringForPrimitives: classAndSelectorList 	self addMethodsForPrimitives: classAndSelectorList.	^self generateCodeStringForPrimitives</body><body package="HPSVM Primitive Plugins" selector="declareModuleName:">declareModuleName: nameString	"add the declaration of a module name, version and local/external tag"	self		var: #moduleName		declareC:'const char *moduleName =#ifdef BUILTIN_PLUGIN	"', nameString,' (i)"#else	"', nameString,' (e)"#endif'</body><body package="HPSVM Primitive Plugins" selector="exportedMethods">exportedMethods	"Return an array of all exported methods"	^methods select:[:m| m export]</body><body package="HPSVM Primitive Plugins" selector="exportedPrimitiveNames">exportedPrimitiveNames	"Return an array of all exported primitives"	^methods select:[:m| m export] thenCollect:[:m| m selector copyWithout: $:].</body><body package="HPSVM Primitive Plugins" selector="generateCodeStringForPrimitives">generateCodeStringForPrimitives	| s methodList |	s := ReadWriteStream on: (String new: 1000).	methodList := methods asSortedCollection: [:m1 :m2 | m1 selector &lt; m2 selector].	self emitCHeaderForPrimitivesOn: s.	self emitCVariablesOn: s.	self emitCFunctionPrototypes: methodList on: s.	methodList do: [:m | m emitCCodeOn: s generator: self].	self emitExportsOn: s.	^ s contents</body><body package="HPSVM Primitive Plugins" selector="globalsAsSet">globalsAsSet	"Used by the inliner to avoid name clashes with global variables."	((variablesSetCache == nil) or:	 [variablesSetCache size ~= variables size]) ifTrue: [		variablesSetCache := variables asSet.	].	^ variablesSetCache</body><body package="HPSVM Primitive Plugins" selector="initialize">initialize	translationDict := Dictionary new.	inlineList := Array new.	constants := Dictionary new: 100.	variables := OrderedCollection new: 100.	variableDeclarations := Dictionary new: 100.	methods := Dictionary new: 500.	self initializeCTranslationDictionary.	headerFiles := OrderedCollection new.	isCPP := false.	self initializeReservedWords.	self initializeWordsToUndefine</body><body package="HPSVM Primitive Plugins" selector="initializeReservedWords">initializeReservedWords	reservedWords := #("C reserved words (incomplete)"							'return' 'char' 'int' 'long' 'unsigned' 'void' ) asSet</body><body package="HPSVM Primitive Plugins" selector="initializeWordsToUndefine">initializeWordsToUndefine	wordsToUndefine := Set new</body><body package="HPSVM Primitive Plugins" selector="isCPP:">isCPP: aBoolean	isCPP := aBoolean</body><body package="HPSVM Primitive Plugins" selector="plugin:">plugin: aPlugin	"Set the plugin when generating plugins."	plugin := aPlugin.	pluginName := plugin moduleName</body><body package="HPSVM Primitive Plugins" selector="pluginName">pluginName	"Return the plugin prefix when generating local plugins.	Local plugins are plugins compiled with the main interpreter	source but are not included (nor inlined into) interp.c"	^pluginName</body><body package="HPSVM Primitive Plugins" selector="pluginName:">pluginName: aString	"Set the plugin name when generating plugins."	pluginName := aString.</body><body package="HPSVM Primitive Plugins" selector="storeCodeOnFile:doInlining:">storeCodeOnFile: fileName doInlining: inlineFlag	"Store C code for this code base on the given file."	self storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: true</body><body package="HPSVM Primitive Plugins" selector="storeCodeOnFile:doInlining:doAssertions:">storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Store C code for this code base on the given file."	| stream |	stream := fileName asFilename newReadWriteStream.	stream ifNil: [Error signal: 'Could not open C code file: ', fileName].	VMMaker setLineEndConventionForCode: stream.	self emitCCodeOn: stream doInlining: inlineFlag doAssertions: assertionFlag.	stream close</body><body package="HPSVM Primitive Plugins" selector="var:declareC:">var: varName declareC: declarationString	"Record the given C declaration for a global variable."	variableDeclarations at: varName asString put: declarationString.</body><body package="HPSVM Primitive Plugins" selector="var:type:">var: varName type: type	self var: varName declareC: type , ' ' , varName</body><body package="HPSVM Primitive Plugins" selector="var:type:array:">var: varName type: type array: array	self		var: varName		declareC: (String streamContents: [:s |			s nextPutAll: type.			s space.			s nextPutAll: varName.			s nextPutAll: '[] = {'.			self printArray: array on: s.			s nextPut: $}])</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>utilities</category><body package="HPSVM Primitive Plugins" selector="addMethod:">addMethod: aTMethod	"Add the given method to the code base."	(methods includesKey:  aTMethod selector) ifTrue: [		self error: 'Method name conflict: ', aTMethod selector.	].	methods at: aTMethod selector put: aTMethod.</body><body package="HPSVM Primitive Plugins" selector="builtin:">builtin: sel	"Answer true if the given selector is one of the builtin selectors."	((sel = #longAt:) or: [(sel = #longAt:put:) or: [sel = #error:]]) ifTrue: [ ^true ].	((sel = #byteAt:) or: [sel = #byteAt:put:]) ifTrue: [ ^true ].	^translationDict includesKey: sel</body><body package="HPSVM Primitive Plugins" selector="cCodeForMethod:">cCodeForMethod: selector	"Answer a string containing the C code for the given method."	"Example:		((CCodeGenerator new initialize addClass: TestCClass1; prepareMethods)			cCodeForMethod: #ifTests)"	| m s |	m := self methodNamed: selector.	m = nil ifTrue: [ self error: 'method not found in code base: ', selector ].	s := (ReadWriteStream on: '').	m emitCCodeOn: s generator: self.	^ s contents</body><body package="HPSVM Primitive Plugins" selector="emitBuiltinConstructAsArgumentFor:on:level:">emitBuiltinConstructAsArgumentFor: msgNode on: aStream level: level	"If the given selector is in the translation dictionary, translate it into a target code construct and return true. Otherwise, do nothing and return false."	| action |	action := asArgumentTranslationDict				at: msgNode selector				ifAbsent: [translationDict at: msgNode selector ifAbsent: [ ^false ]].	self perform: action with: msgNode with: aStream with: level.	^true</body><body package="HPSVM Primitive Plugins" selector="emitBuiltinConstructFor:on:level:">emitBuiltinConstructFor: msgNode on: aStream level: level	"If the given selector is in the translation dictionary, translate it into a target code construct and return true. Otherwise, do nothing and return false."	| action |	action := translationDict at: msgNode selector ifAbsent: [ ^false ].	self perform: action with: msgNode with: aStream with: level.	^true</body><body package="HPSVM Primitive Plugins" selector="isGeneratingPluginCode">isGeneratingPluginCode	^false</body><body package="HPSVM Primitive Plugins" selector="methodNamed:">methodNamed: selector	"Answer the method in the code base with the given selector.  Ignore builtins, externals and macros."	| m |	^((m := methods at: selector ifAbsent: [ nil ]) isNil	  or: [m isMacroDefinition])		ifFalse: [m]</body><body package="HPSVM Primitive Plugins" selector="methodsReferringToGlobal:">methodsReferringToGlobal: v	"Return a collection of methods that refer to the given global variable."	| out |	out := OrderedCollection new.	methods associationsDo: [ :assoc |		(assoc value freeVariableReferences includes: v) ifTrue: [			out add: assoc key.		].	].	^ out</body><body package="HPSVM Primitive Plugins" selector="methodsThatCanInvoke:">methodsThatCanInvoke: aSelectorList	"Return a set of methods that can invoke one of the given selectors, either directly or via a sequence of intermediate methods."	| out todo sel mSelector |	out := Set new.	todo := aSelectorList copy asOrderedCollection.	[todo isEmpty] whileFalse: [		sel := todo removeFirst.		out add: sel.		methods do: [ :m |			(m allCalls includes: sel) ifTrue: [				mSelector := m selector.				((out includes: mSelector) or:				 [todo includes: mSelector]) ifFalse: [					todo add: mSelector.				].			].		].	].	^ out</body><body package="HPSVM Primitive Plugins" selector="nilOrBooleanConstantReceiverOf:">nilOrBooleanConstantReceiverOf: sendNode	"Answer nil or the boolean constant that is the receiver of the given message send. Used to suppress conditional code when the condition is a translation-time constant."	| rcvr val |	rcvr := sendNode receiver.	rcvr isConstant ifTrue: [		val := rcvr value.		((val == true) or: [val == false]) ifTrue: [^ val]].	"Turn failed() into false for plugins to eliminate unnecessary if (failed()) primitiveFail();"	(self isGeneratingPluginCode	 and: [rcvr isSend	 and: [rcvr selector == #failed]]) ifTrue:		[^false].	^ nil</body><body package="HPSVM Primitive Plugins" selector="note:">note: ignored	"record as design issue, etc"</body><body package="HPSVM Primitive Plugins" selector="prepareMethods">prepareMethods	"Prepare methods for browsing."	| globals |	globals := Set new: 200.	globals addAll: variables.		methods do:		[ :m | | errorBlock |		m isMacroDefinition ifFalse:			[errorBlock :=					[:err :var | | report |					report := err expandMacrosWith: var with: m method definition.					Transcript cr; show: report.					(Dialog confirm: report, (String with: Character cr), 'Continue?') ifFalse:						[^self error: 'abort']].			(m locals, m args) do: [ :var | | sym |				(reservedWords includes: var) ifTrue:					[errorBlock						value: 'Local variable name &lt;1s&gt; conflicts with reserved word when generating&lt;n&gt;&lt;2p&gt;'						value: var].				(globals includes: var) ifTrue:					[errorBlock						value: 'Local variable name &lt;1s&gt; may mask global when inlining&lt;n&gt;&lt;2p&gt;'						value: var].				((sym := Symbol findInterned: var) notNil				 and: [methods includesKey: sym]) ifTrue:					[errorBlock						value: 'Local variable name &lt;1p&gt; may mask method when inlining&lt;n&gt;&lt;2p&gt;'						value: var]]].		m bindClassVariablesIn: constants.		m prepareMethodIn: self]</body><body package="HPSVM Primitive Plugins" selector="reportRecursiveMethods">reportRecursiveMethods	"Report in transcript all methods that can call themselves directly or indirectly or via a chain of N intermediate methods."	| visited calls newCalls sel called |	methods do: [: m |		visited := translationDict keys asSet.		calls := m allCalls asOrderedCollection.		5 timesRepeat: [			newCalls := Set new: 50.			[calls isEmpty] whileFalse: [				sel := calls removeFirst.				sel = m selector ifTrue: [					Transcript show: m selector, ' is recursive'; cr.				] ifFalse: [					(visited includes: sel) ifFalse: [						called := self methodNamed: sel.						called = nil ifFalse: [ newCalls addAll: called allCalls ].					].					visited add: sel.				].			].			calls := newCalls asOrderedCollection.		].	].</body><body package="HPSVM Primitive Plugins" selector="translationMethodClass">translationMethodClass	"return the class used to produce C translation methods from MethodNodes"	^TtoCMethod</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>C code generator</category><body package="HPSVM Primitive Plugins" selector="cFunctionNameFor:">cFunctionNameFor: aSelector	"Create a C function name from the given selector by omitting colons	and prefixing with the plugin name if the method is exported."	^aSelector copyWithout: $:</body><body package="HPSVM Primitive Plugins" selector="cLiteralFor:">cLiteralFor: anObject	"Return a string representing the C literal value for the given object."	anObject respondsToArithmetic		ifTrue:			[anObject isInteger ifTrue:				[^anObject &lt; 16r7FFFFFFF					ifTrue: [anObject printString]					ifFalse: [anObject printString , 'U']].			(anObject isKindOf: LimitedPrecisionReal) ifTrue: [^ anObject printString]]		ifFalse:			[anObject isString ifTrue:				[^ anObject isSymbol ifTrue: [anObject] ifFalse: ['"', anObject, '"']].			anObject == nil ifTrue: [^ 'null' ].			anObject == true ifTrue: [^ '1' ].			"ikp"			anObject == false ifTrue: [^ '0' ].			"ikp"			(anObject isMemberOf: Character) ifTrue:[^anObject asString printString]]. "ar"	self error:								"ikp"		'Warning: A Smalltalk literal could not be translated into a C constant: ', anObject printString.	^'"XXX UNTRANSLATABLE CONSTANT XXX"'</body><body package="HPSVM Primitive Plugins" selector="emitBuiltinMacrosOn:">emitBuiltinMacrosOn: aStream	"Store any builtin function declarations the plugin may have."	aStream nextPutAll: '/*** Builtin Macros ***/'; cr; cr.	((methods select: [:m| m isMacroDefinition]) asSortedCollection: [:m1 :m2| m1 selector &lt;= m2 selector]) do:		[:m| aStream nextPutAll: m macroDefinition; cr; cr]</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:doInlining:doAssertions:">emitCCodeOn: aStream doInlining: inlineFlag doAssertions: assertionFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	| verbose methodList |	"method preparation"	verbose := true.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	assertionFlag ifFalse: [ self removeAssertions ].	self doInlining: inlineFlag.	"code generation"	methodList := methods asSortedCollection: [ :m1 :m2 | m1 selector &lt; m2 selector ].	self emitCHeaderOn: aStream.	self emitBuiltinMacrosOn: aStream.	self emitCFunctionPrototypes: methodList on: aStream.	self emitCVariablesOn: aStream.	plugin notNil ifTrue: [aStream cr; cr; nextPutAll: '/* PlugIn Code */'; cr; cr].	'Writing Translated Code...'		displayProgressAt: InputSensor cursorPoint		from: 0 to: methods size		during:			[:bar |			methodList doWithIndex:				[ :m :i |				m isMacroDefinition ifFalse:					[bar value: i.					self currentMethod: m.					m emitCCodeOn: aStream generator: self]]].	self emitExportsOn: aStream.</body><body package="HPSVM Primitive Plugins" selector="emitCExpression:on:">emitCExpression: aParseNode on: aStream 	"Emit C code for the expression described by the given parse node."	aParseNode isLeaf 		ifTrue: 			["omit parens"			 aParseNode emitCCodeAsExpressionOn: aStream level: 0 generator: self]		ifFalse: 			[aStream nextPut: $(.			 aParseNode emitCCodeAsExpressionOn: aStream level: 0 generator: self.			 aStream nextPut: $)]</body><body package="HPSVM Primitive Plugins" selector="emitCFunctionPrototypes:on:">emitCFunctionPrototypes: methodList on: aStream 	"Store prototype declarations for all non-inlined methods on the given stream."	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	isCPP ifTrue: [aStream nextPutAll: 'extern "C" {'; cr].	EmitExportPragma		ifTrue:			[| exporting |			 exporting := false.			 methodList do: [:m |				m isMacroDefinition ifFalse:					[exporting ~~ m export ifTrue:						[aStream							nextPutAll: '#pragma export ';							nextPutAll: ((exporting := m export) ifTrue: ['on'] ifFalse: ['off']);							cr].					m emitCFunctionPrototype: aStream generator: self]].			exporting ifTrue: [aStream nextPutAll: '#pragma export off'; cr]]		ifFalse:			[methodList do: [:m |				m isMacroDefinition ifFalse:					[m emitCFunctionPrototype: aStream generator: self]]].	isCPP ifTrue: [aStream nextPut: $}; cr]</body><body package="HPSVM Primitive Plugins" selector="emitCHeaderForPrimitivesOn:">emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream		nextPutAll: '/* Automatically generated from VisualWorks on ';		print: Time dateAndTimeNow;		nextPutAll: ' */';		cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	"Additional header files"	headerFiles do:[:hdr|		aStream nextPutAll:'#include '; nextPutAll: hdr; cr].	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int stackIntegerValue(int);extern int successFlag;/* allows accessing Strings in both C and Smalltalk */#define asciiValue(c) c'.	aStream cr.</body><body package="HPSVM Primitive Plugins" selector="emitCHeaderOn:">emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream		nextPutAll: '/* Automatically generated from VisualWorks on ';		print: Time dateAndTimeNow;		nextPutAll: ' */';		cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr.	"Additional header files"	headerFiles do:[:hdr|		aStream nextPutAll:'#include '; nextPutAll: hdr; cr].	wordsToUndefine asSortedCollection do:		[:word| aStream nextPutAll: '#undef '; nextPutAll: word; cr].	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)int printCallStack(void);void error(char *s);void error(char *s) {	/* Print an error message and exit. */	static int printingStack = false;	printf("\n%s\n\n", s);	if (!printingStack) {		/* flag prevents recursive error when trying to print a broken stack */		printingStack = true;		printCallStack();	}	exit(-1);}'.	aStream cr.</body><body package="HPSVM Primitive Plugins" selector="emitCTestBlock:on:">emitCTestBlock: aBlockNode on: aStream	"Emit C code for the given block node to be used as a loop test."	aBlockNode statements size &gt; 1 ifTrue: [		aBlockNode emitCCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aBlockNode statements first emitCCodeOn: aStream level: 0 generator: self.	].</body><body package="HPSVM Primitive Plugins" selector="emitCVariablesOn:">emitCVariablesOn: aStream	"Store the global variable declarations on the given stream."	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection do:		[:var | | varString |		varString := var asString.		self isGeneratingPluginCode ifTrue: [aStream nextPutAll: 'static '].		aStream			nextPutAll: (variableDeclarations							at: varString							ifAbsent: ['oopInt ', varString "default variable declaration"]);			nextPut: $; ;			cr].	aStream cr</body><body package="HPSVM Primitive Plugins" selector="emitExportsOn:">emitExportsOn: aStream	"Store all the exported primitives in a form to be used by internal plugins"	| prefix |	pluginName ifNotNil:[aStream cr; cr; nextPutAll:'#ifdef BUILTIN_PLUGIN';cr].	aStream cr; cr; nextPutAll:'void *', (pluginName ifNil:['vm']),'_exports[][4] = {'.	prefix := pluginName ifNil:['""'] ifNotNil:['"', pluginName,'"'].	self exportedMethods do:		[:method| | primName |		primName := method selector copyWithout: $:.		aStream cr;			nextPutAll:'	{'; 			nextPutAll: prefix; 			nextPutAll:', "'; 			nextPutAll: primName; 			nextPutAll:'", (void*)'; 			nextPutAll: primName;			nextPutAll: ', (void*)';			print: method numArgs - 1 " primitive takes receiver and args ";			nextPutAll:'},'.].	aStream nextPutAll:'	{NULL, NULL, NULL,NULL}};'.	pluginName ifNotNil:[aStream cr; cr; nextPutAll:'#endif /* BUILTIN_PLUGIN */'; cr].</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>error notification</category><body package="HPSVM Primitive Plugins" selector="checkClassForNameConflicts:">checkClassForNameConflicts: aClass	"Verify that the given class does not have constant, variable, or method names that conflict with those of previously added classes. Raise an error if a conflict is found, otherwise just return."	"check for constant name collisions"	aClass classPool bindingsDo: [ :assoc |		(constants includesKey: assoc key asString) ifTrue: [			self error: 'Constant was defined in a previously added class: ', assoc key.		].	].	"ikp..."	aClass sharedPools do: [:pool |		pool asNameSpace bindingsDo: [ :assoc |			(constants includesKey: assoc key asString) ifTrue: [				self error: 'Constant was defined in a previously added class: ', assoc key.			].		].	].	"check for instance variable name collisions"	aClass instVarNames do: [ :varName |		(variables includes: varName) ifTrue: [			self error: 'Instance variable was defined in a previously added class: ', varName.		].	].	"check for method name collisions"	aClass selectors do: [ :sel |		(methods includesKey: sel) ifTrue: [			self error: 'Method was defined in a previously added class: ', sel.		].	].</body><body package="HPSVM Primitive Plugins" selector="printUnboundCallWarnings">printUnboundCallWarnings	"Print a warning message for every unbound method call in the code base."	| knownSelectors undefinedCalls |	undefinedCalls := Dictionary new.	knownSelectors := translationDict keys asSet.	knownSelectors add: #error:.	methods do: [ :m | knownSelectors add: m selector ].	methods do: [ :m |		m allCalls do: [ :sel |			(knownSelectors includes: sel) ifFalse: [				(undefinedCalls includesKey: sel)					ifTrue: [ (undefinedCalls at: sel) add: m selector ]					ifFalse: [ undefinedCalls at: sel put: (OrderedCollection with: m selector) ].			].		].	].	Transcript cr.	undefinedCalls keys asSortedCollection do: [ :undefined |		Transcript show: undefined, ' -- undefined method sent by:'; cr.		(undefinedCalls at: undefined) do: [ :caller |			Transcript tab; show: caller; cr.		].	].</body><body package="HPSVM Primitive Plugins" selector="printUnboundVariableReferenceWarnings">printUnboundVariableReferenceWarnings	"Print a warning message for every unbound variable reference in the code base."	| undefinedRefs globalVars knownVars |	undefinedRefs := Dictionary new.	globalVars := Set new: 100.	globalVars addAll: variables.	methods do:		[ :m |		knownVars := globalVars copy.		m args do: [ :var | knownVars add: var ].		m locals do: [ :var | knownVars add: var ].		m freeVariableReferences do: [ :varName |			(knownVars includes: varName) ifFalse:				[(undefinedRefs at: varName ifAbsentPut: [OrderedCollection new])					addLast: m selector]]].	Transcript cr.	undefinedRefs keys asSortedCollection do:		[ :var |		Transcript show: var, ' -- undefined variable used in:'; cr.		(undefinedRefs at: var) do: [ :sel | Transcript tab; show: sel; cr]]</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>inlining</category><body package="HPSVM Primitive Plugins" selector="collectInlineList">collectInlineList	"Make a list of methods that should be inlined."	"Details: The method must not include any inline C, since the	 translator cannot currently map variable names in inlined C code.	 Methods to be inlined must be small or called from only one place.	 Macros must not be inlined."	| methodsNotToInline callsOf |	methodsNotToInline := Set new: methods size.	"build dictionary to record the number of calls to each method"	callsOf := Dictionary new: methods size * 2.	methods keys do: [:s | callsOf at: s put: 0].	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations or is a macro		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	inlineList := Set new: methods size * 2.	methods do:		[:m | | inlineIt hasCCode nodeCount senderCount sel |		inlineIt := #dontCare.		(translationDict includesKey: m selector)			ifTrue: [hasCCode := true]			ifFalse:				[m isMacroDefinition					ifTrue: [hasCCode := true. inlineIt := false]					ifFalse:						[hasCCode := m declarations size &gt; 0.						nodeCount := 0.						m parseTree nodesDo:							[:node |							node isSend								ifTrue:									[sel := node selector.									(sel = #cCode: or: [sel = #cCode:inSmalltalk:]) ifTrue: [hasCCode := true].									senderCount := callsOf at: sel ifAbsent: [nil].									nil = senderCount ifFalse: [callsOf at: sel put: senderCount + 1]].							nodeCount := nodeCount + 1].						inlineIt := m extractInlineDirective	"may be true, false, or #dontCare" ]].		(hasCCode or: [inlineIt = false])			ifTrue:				["don't inline if method has C code and it contains negative inline directive"				methodsNotToInline add: m selector]			ifFalse:				[(nodeCount &lt; 40 or: [inlineIt = true]) ifTrue:					["inline if method has no C code and is either small or contains inline directive"					inlineList add: m selector]]].	callsOf associationsDo:		[:assoc |		(assoc value = 1 and: [(methodsNotToInline includes: assoc key) not])			ifTrue: [inlineList add: assoc key]]</body><body package="HPSVM Primitive Plugins" selector="doInlining:">doInlining: inlineFlag	"Inline the bodies of all methods that are suitable for inlining."	"Modified slightly for the translator, since the first level of inlining for the interpret loop must be performed in order that the instruction implementations can easily discover their addresses."	| pass progress |	inlineFlag ifFalse:		[self inlineDispatchesInMethodNamed: #interpret localizingVars: #().		 ^self].	self collectInlineList.	pass := 0.	progress := true.	[progress] whileTrue:		["repeatedly attempt to inline methods until no further progress is made"		progress := false.		('Inlining pass ', (pass := pass + 1) printString, '...')			displayProgressAt: InputSensor cursorPoint			from: 0 to: methods size			during:				[:bar |				methods keysAndValuesDo:					[:s :m |					bar value: s.					m isMacroDefinition ifFalse:						[(m tryToInlineMethodsIn: self) ifTrue:							[pass &gt; 10 ifTrue: [self halt]. progress := true]]]]].	plugin isNil ifTrue:		['Inlining bytecodes'			displayProgressAt: InputSensor cursorPoint			from: 1 to: 2			during:				[:bar |				self inlineDispatchesInMethodNamed: #interpret					localizingVars: #(currentBytecode localIP localSP localHomeContext).				bar value: 1.				self removeMethodsReferingToGlobals: #(currentBytecode localIP localSP localHomeContext)					except: #interpret.				bar value: 2]].	"make receiver on the next line false to generate code for all methods, even those that are inlined or unused"	true 		ifTrue: 		[self visualWorks 			ifTrue: [self pruneUnreachableMethods]			ifFalse: 				[(methods includesKey: #interpret) ifTrue: 					["only prune when generating the interpreter itself"					self pruneUnreachableMethods]]]</body><body package="HPSVM Primitive Plugins" selector="inlineDispatchesInMethodNamed:localizingVars:">inlineDispatchesInMethodNamed: selector localizingVars: varsList	"Inline dispatches (case statements) in the method with the given name."	| m varString |	m := self methodNamed: selector.	m = nil ifFalse: [		m inlineCaseStatementBranchesIn: self localizingVars: varsList.		m parseTree nodesDo: [ :n |			n isCaseStmt ifTrue: [				n customizeShortCasesForDispatchVar: 'currentBytecode'.			].		].	].	variables := variables asOrderedCollection.	varsList do: [ :v |		varString := v asString.		variables remove: varString ifAbsent: [].		(variableDeclarations includesKey: varString) ifTrue: [			m declarations at: v asString put: (variableDeclarations at: varString).			variableDeclarations removeKey: varString.		].	].</body><body package="HPSVM Primitive Plugins" selector="mayInline:">mayInline: sel	"Answer true if the method with the given selector may be inlined."	^ inlineList includes: sel</body><body package="HPSVM Primitive Plugins" selector="methodStatsString">methodStatsString	"Return a string describing the size, # of locals, and # of senders ofeach method. Note methods that have inline C code or C declarations."	| methodsWithCCode sizesOf callsOf hasCCode nodeCount senderCount scalls registers selr m |	methodsWithCCode := Set new: methods size.	sizesOf := Dictionary new: methods size * 2.  "selector -&gt; nodeCount"	callsOf := Dictionary new: methods size * 2.  "selector -&gt; senderCount"	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	methods do: [ :m0 |  m := m0.		(translationDict includesKey: m selector) ifTrue: [			hasCCode := true.		] ifFalse: [			hasCCode := m declarations size &gt; 0.			nodeCount := 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					selr := node selector.					selr = #cCode: ifTrue: [ hasCCode := true ].					senderCount := callsOf at: selr ifAbsent: [ 0 ].					callsOf at: selr put: senderCount + 1.				].				nodeCount := nodeCount + 1.			].		].		hasCCode ifTrue: [ methodsWithCCode add: m selector ].		sizesOf at: m selector put: nodeCount.	].	s := WriteStream on: (String new: 5000).	methods keys asSortedCollection do: [ :sel |		m := methods at: sel.		registers := m locals size + m args size.		calls := callsOf at: sel ifAbsent: [0].		registers &gt; 11 ifTrue: [			s nextPutAll: sel; tab.			s nextPutAll: (sizesOf at: sel) printString; tab.			s nextPutAll: calls printString; tab.			s nextPutAll: registers printString; tab.			(methodsWithCCode includes: sel) ifTrue: [ s nextPutAll: 'CCode' ].		s cr.		].	].	^ s contents</body><body package="HPSVM Primitive Plugins" selector="pruneMethods:">pruneMethods: selectorList	"Explicitly prune some methods"	selectorList do:[:sel| methods removeKey: sel ifAbsent:[]].</body><body package="HPSVM Primitive Plugins" selector="pruneUnreachableMethods">pruneUnreachableMethods	"Remove any methods that are not reachable. Retain methods needed by the BitBlt operation table, primitives, plug-ins, or interpreter support code." 	| retain |	"Build a set of selectors for methods that should be output even though they have no apparent callers. Some of these are stored in tables for indirect lookup, some are called by the C support code or by primitives."	retain := Set new: 100.	plugin notNil ifTrue: [plugin addMethodsToRetainTo: retain].	InterpreterProxy addMethodsToRetainTo: retain.	#(checkedLongAt: fullDisplayUpdate interpret printCallStack printAllStacks	   readImageFromFile:HeapSize:StartingAt: success:		"Windows needs the following two for startup and debug"	   readableFormat: getCurrentBytecode		"Jitter reuses all of these"	   allocateChunk: characterForAscii:	   findClassOfMethod:forReceiver: findSelectorOfMethod:forReceiver:	   firstAccessibleObject loadInitialContext noteAsRoot:headerLoc:	   nullCompilerHook	   primitiveFloatAdd primitiveFloatDivide primitiveFloatMultiply	   primitiveFloatSubtract primitiveFlushExternalPrimitives	   setCompilerInitialized: splObj:)			do: [:sel | retain add: sel].	"Remove all the unreachable methods that aren't retained for the reasons above."	(self unreachableMethodsRetaining: retain) do:		[:sel |		methods removeKey: sel ifAbsent: []].</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	"Remove all assertions in method bodies.  This is for the benefit of inlining, which	fails to recognise and disregard empty method bodies when checking the inlinability	of sends."	| newMethods |	newMethods := Dictionary new.	'Removing assertions...'		displayProgressAt: InputSensor cursorPoint		from: 0 to: methods size		during: [ :bar |			methods doWithIndex: [ :m :i |				bar value: i.				m isAssertion ifFalse: [					newMethods at: m selector put: m.					m removeAssertions]]].	methods := newMethods.</body><body package="HPSVM Primitive Plugins" selector="removeMethodsReferingToGlobals:except:">removeMethodsReferingToGlobals: varList except: methodName	"Remove any methods (presumably inlined) that still contain references to the given obsolete global variables."	| varListAsStrings removeIt mVars |	varListAsStrings := varList collect: [ :sym | sym asString ].	methods keys copy do:		[ :sel | | m |		removeIt := false.		(m := self methodNamed: sel) notNil ifTrue:			[mVars := m freeVariableReferences asSet.			varListAsStrings do:				[ :v | (mVars includes: v) ifTrue: [ removeIt := true ]].			(removeIt and: [sel ~= methodName]) ifTrue:				[methods removeKey: sel ifAbsent: []]]]</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="currentMethod">currentMethod	^currentMethod</body><body package="HPSVM Primitive Plugins" selector="currentMethod:">currentMethod: anObject	currentMethod := anObject</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="generateAnd:on:indent:">generateAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &amp;&amp; '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateAsFloat:on:indent:">generateAsFloat: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll:'((double)'.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsInteger:on:indent:">generateAsInteger: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll:'((oopInt)'.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPut: $).</body><body package="HPSVM Primitive Plugins" selector="generateAt:on:indent:">generateAt: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPut: $[.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPut: $]</body><body package="HPSVM Primitive Plugins" selector="generateAtPut:on:indent:">generateAtPut: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPut: $[.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: '] = '.	self emitCExpression: msgNode args last on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateBitAnd:on:indent:">generateBitAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &amp; '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateBitInvert32:on:indent:">generateBitInvert32: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPut: $~.	self emitCExpression: msgNode receiver on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateBitOr:on:indent:">generateBitOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateBitShift:on:indent:">generateBitShift: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| arg rcvr |	arg := msgNode args first.	rcvr := msgNode receiver.	arg isConstant ifTrue: [		"bit shift amount is a constant"		aStream nextPutAll: '((unsigned) '.		self emitCExpression: rcvr on: aStream.		arg value &lt; 0 ifTrue: [			aStream nextPutAll: ' &gt;&gt; ', arg value negated printString.		] ifFalse: [			aStream nextPutAll: ' &lt;&lt; ', arg value printString.		].		aStream nextPutAll: ')'.	] ifFalse: [		"bit shift amount is an expression"		aStream nextPutAll: '(('.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ' &lt; 0) ? ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' &gt;&gt; -'.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ') : ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' &lt;&lt; '.		self emitCExpression: arg on: aStream.		aStream nextPutAll: '))'.	].</body><body package="HPSVM Primitive Plugins" selector="generateBitXor:on:indent:">generateBitXor: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' ^ '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateCCoercion:on:indent:">generateCCoercion: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream		nextPut: $(;		nextPut: $(;		nextPutAll: msgNode args last value;		nextPut: $).	self emitCExpression: msgNode args first on: aStream.	aStream nextPut: $).</body><body package="HPSVM Primitive Plugins" selector="generateClass:on:indent:">generateClass: msgNode on: aStream indent: level	"Generate the code for the classmessage onto the given stream."	aStream		nextPutAll: '(oopInt)oopClass((oop)(';		nextPutAll: msgNode receiver name;		nextPutAll: '))'</body><body package="HPSVM Primitive Plugins" selector="generateDivide:on:indent:">generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| rcvr arg divisor |	rcvr := msgNode receiver.	arg := msgNode args first.	(arg isConstant and:	 [UseRightShiftForDivide and:	 [(divisor := arg value) isInteger and:	 [divisor isPowerOfTwo and:	 [divisor &gt; 0 and:	 [divisor &lt;= (1 bitShift: 31)]]]]])	ifTrue: [		"use signed (arithmetic) right shift instead of divide"		aStream nextPutAll: '((oopInt) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' &gt;&gt; ', (divisor log: 2) asInteger printString.		aStream nextPutAll: ')'.	] ifFalse: [		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		self emitCExpression: arg on: aStream].</body><body package="HPSVM Primitive Plugins" selector="generateDoWhileFalse:on:indent:">generateDoWhileFalse: msgNode on: aStream indent: level	"Generate do {stmtList} while(!(cond))"	| stmts testStmt |	stmts := msgNode receiver statements asOrderedCollection.	testStmt := stmts removeLast.	msgNode receiver setStatements: stmts.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while(!('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: '))'.</body><body package="HPSVM Primitive Plugins" selector="generateDoWhileTrue:on:indent:">generateDoWhileTrue: msgNode on: aStream indent: level	"Generate do {stmtList} while(cond)"	| stmts testStmt |	stmts := msgNode receiver statements asOrderedCollection.	testStmt := stmts removeLast.	msgNode receiver setStatements: stmts.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: ')'.</body><body package="HPSVM Primitive Plugins" selector="generateEqual:on:indent:">generateEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateGreaterThan:on:indent:">generateGreaterThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &gt; '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateGreaterThanOrEqual:on:indent:">generateGreaterThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &gt;= '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateIfFalse:on:indent:">generateIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPutAll: 'if (!('.			msgNode receiver emitCCodeAsExpressionOn: aStream level: level + 1 generator: self.			aStream nextPutAll: ')) {'; cr.			msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.			level timesRepeat: [aStream tab].			aStream nextPut: $}]		ifNotNil:			[:const |			const ifFalse:				[msgNode args first emitCCodeOn: aStream level: level generator: self]]</body><body package="HPSVM Primitive Plugins" selector="generateIfFalseAsArgument:on:indent:">generateIfFalseAsArgument: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPutAll: '(!('.			 msgNode receiver emitCCodeAsArgumentOn: aStream level: 0 generator: self.			aStream nextPut: $); crtab: level + 1; nextPut: $?; space.			msgNode args last emitCCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream crtab: level + 1; nextPutAll: ': 0)']		ifNotNil:			[:const|			const ifFalse:				[msgNode args first emitCCodeAsArgumentOn: aStream level: level generator: self]]</body><body package="HPSVM Primitive Plugins" selector="generateIfFalseIfTrue:on:indent:">generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPutAll: 'if ('.			msgNode receiver emitCCodeAsExpressionOn: aStream level: level generator: self.			aStream nextPutAll: ') {'; cr.			msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.			aStream tab: level; nextPut: $}; cr; tab: level; nextPutAll: 'else {'; cr.			msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.			aStream tab: level; nextPut: $}]		ifNotNil:			[:const |			 (const ifTrue: [msgNode args last] ifFalse: [msgNode args first])				emitCCodeOn: aStream level: level generator: self]</body><body package="HPSVM Primitive Plugins" selector="generateIfFalseIfTrueAsArgument:on:indent:">generateIfFalseIfTrueAsArgument: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPut: $(.			msgNode receiver emitCCodeAsArgumentOn: aStream level: level generator: self.			aStream crtab: level + 1; nextPut: $?; space.			msgNode args last emitCCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream crtab: level + 1; nextPut: $:; space.			msgNode args first emitCCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream nextPut: $)]		ifNotNil:			[:const|			(const				ifTrue: [msgNode args last]				ifFalse: [msgNode args first])					emitCCodeAsArgumentOn: aStream level: level generator: self]</body><body package="HPSVM Primitive Plugins" selector="generateIfTrue:on:indent:">generateIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPutAll: 'if ('.			msgNode receiver emitCCodeAsExpressionOn: aStream level: level generator: self.			aStream nextPutAll: ') {'; cr.			msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.			level timesRepeat: [ aStream tab ].			aStream nextPut: $}]		ifNotNil:			[:const |			const ifTrue:				[msgNode args first emitCCodeOn: aStream level: level generator: self]]</body><body package="HPSVM Primitive Plugins" selector="generateIfTrueAsArgument:on:indent:">generateIfTrueAsArgument: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPut: $(.			 msgNode receiver emitCCodeAsArgumentOn: aStream level: level generator: self.			 aStream crtab: level + 1; nextPut: $?; space.			 msgNode args first emitCCodeAsArgumentOn: aStream level: level + 2 generator: self.			 aStream crtab: level + 1; nextPutAll: ': 0)']		ifNotNil:			[:const|			const ifTrue:				[msgNode args first emitCCodeAsArgumentOn: aStream level: level generator: self]]</body><body package="HPSVM Primitive Plugins" selector="generateIfTrueIfFalse:on:indent:">generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPutAll: 'if ('.			msgNode receiver emitCCodeAsExpressionOn: aStream level: level generator: self.			aStream nextPutAll: ') {'; cr.			msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.			aStream tab: level; nextPut: $}; cr; tab: level; nextPutAll: 'else {'; cr.			msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.			aStream tab: level; nextPut: $}]		ifNotNil:			[:const |			(const ifTrue: [msgNode args first] ifFalse: [msgNode args last])				emitCCodeOn: aStream level: level generator: self]</body><body package="HPSVM Primitive Plugins" selector="generateIfTrueIfFalseAsArgument:on:indent:">generateIfTrueIfFalseAsArgument: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPut: $(.			msgNode receiver emitCCodeAsArgumentOn: aStream level: level generator: self.			aStream crtab: level + 1; nextPut: $?; space.			msgNode args first emitCCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream crtab: level + 1; nextPut: $:; space.			msgNode args last emitCCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream nextPut: $)]		ifNotNil:			[:const|			(const ifTrue: [msgNode args first] ifFalse: [msgNode args last])				emitCCodeAsArgumentOn: aStream level: level generator: self]</body><body package="HPSVM Primitive Plugins" selector="generateInlineCCode:on:indent:">generateInlineCCode: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: msgNode args first value.</body><body package="HPSVM Primitive Plugins" selector="generateInlineDirective:on:indent:">generateInlineDirective: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '/* inline: '.	aStream nextPutAll: msgNode args first name.	aStream nextPutAll: ' */'.</body><body package="HPSVM Primitive Plugins" selector="generateIntegerObjectOf:on:indent:">generateIntegerObjectOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(oopInt)asSmallInt('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIntegerValueOf:on:indent:">generateIntegerValueOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'oopIntVal('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsIntegerObject:on:indent:">generateIsIntegerObject: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'oopIsInt('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsNil:on:indent:">generateIsNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == sysOop(nilOopX)'</body><body package="HPSVM Primitive Plugins" selector="generateLessThan:on:indent:">generateLessThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &lt; '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateLessThanOrEqual:on:indent:">generateLessThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &lt;= '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateMax:on:indent:">generateMax: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &lt; '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.</body><body package="HPSVM Primitive Plugins" selector="generateMin:on:indent:">generateMin: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &lt; '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.</body><body package="HPSVM Primitive Plugins" selector="generateMinus:on:indent:">generateMinus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' - '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateModulo:on:indent:">generateModulo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' % '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateNot:on:indent:">generateNot: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPut: $!.	self emitCExpression: msgNode receiver on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateNotEqual:on:indent:">generateNotEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' != '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateNotNil:on:indent:">generateNotNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' != sysOop(nilOopX)'</body><body package="HPSVM Primitive Plugins" selector="generateOr:on:indent:">generateOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generatePerform:on:indent:">generatePerform: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '('.	(msgNode args copyFrom: 2 to: msgNode args size) do:[:arg|		self emitCExpression: arg on: aStream.	] separatedBy:[aStream nextPutAll:', '].	aStream nextPutAll:')'.</body><body package="HPSVM Primitive Plugins" selector="generatePlus:on:indent:">generatePlus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' + '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generatePreDecrement:on:indent:">generatePreDecrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode := msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preDecrement can only be applied to variables' ].	aStream nextPutAll: '--'.	aStream nextPutAll: varNode name.</body><body package="HPSVM Primitive Plugins" selector="generatePreIncrement:on:indent:">generatePreIncrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode := msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preIncrement can only be applied to variables' ].	aStream nextPutAll: '++'.	aStream nextPutAll: varNode name.</body><body package="HPSVM Primitive Plugins" selector="generateRaisedTo:on:indent:">generateRaisedTo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll:'pow('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ','.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll:')'.</body><body package="HPSVM Primitive Plugins" selector="generateSequentialAnd:on:indent:">generateSequentialAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &amp;&amp; ('.	self emitCTestBlock: msgNode args first on: aStream.	aStream nextPutAll: ')'.</body><body package="HPSVM Primitive Plugins" selector="generateSequentialOr:on:indent:">generateSequentialOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for or:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || ('.	self emitCTestBlock: msgNode args last on: aStream.	aStream nextPutAll: ')'.</body><body package="HPSVM Primitive Plugins" selector="generateSharedCodeDirective:on:indent:">generateSharedCodeDirective: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '/* common code: '.	aStream nextPutAll: msgNode args first value.	aStream nextPutAll: ' */'.</body><body package="HPSVM Primitive Plugins" selector="generateShiftLeft:on:indent:">generateShiftLeft: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' &lt;&lt; '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateShiftRight:on:indent:">generateShiftRight: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '((unsigned) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.	aStream nextPutAll: ' &gt;&gt; '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateTimes:on:indent:">generateTimes: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' * '.	self emitCExpression: msgNode args first on: aStream.</body><body package="HPSVM Primitive Plugins" selector="generateToByDo:on:indent:">generateToByDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar step |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar := msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar,		(((step := msgNode args at: 2) isConstant and: [step value &lt; 0])			ifTrue: [' &gt;= '] ifFalse: [' &lt;= ']).	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, ' += '.	self emitCExpression: step on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.</body><body package="HPSVM Primitive Plugins" selector="generateToDo:on:indent:">generateToDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar := msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' &lt;= '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, '++) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.</body><body package="HPSVM Primitive Plugins" selector="generateWhileFalse:on:indent:">generateWhileFalse: msgNode on: aStream indent: level	"Generate C code for a loop in one of the following formats, as appropriate:		while(!(cond)) { stmtList }		do {stmtList} while(!(cond))		while(1) {stmtListA; if (cond) break; stmtListB}"	msgNode receiver statements size &lt;= 1		ifTrue: [^self generateWhileFalseLoop: msgNode on: aStream indent: level].	msgNode args first isNilStmtListNode		ifTrue: [^self generateDoWhileFalse: msgNode on: aStream indent: level].	^self generateWhileForeverBreakTrueLoop: msgNode on: aStream indent: level</body><body package="HPSVM Primitive Plugins" selector="generateWhileFalseLoop:on:indent:">generateWhileFalseLoop: msgNode on: aStream indent: level	"Generate while(!(cond)) {stmtList}."	aStream nextPutAll: 'while (!('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ')) {'; cr.	msgNode args first isNilStmtListNode ifFalse:		[msgNode args first emitCCodeOn: aStream level: level + 1 generator: self].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.</body><body package="HPSVM Primitive Plugins" selector="generateWhileForeverBreakFalseLoop:on:indent:">generateWhileForeverBreakFalseLoop: msgNode on: aStream indent: level	"Generate while(1) {stmtListA; if(!(cond)) break; stmtListB}."	| stmts testStmt |	stmts := msgNode receiver statements asOrderedCollection.	testStmt := stmts removeLast.	msgNode receiver setStatements: stmts.	level - 1 timesRepeat: [ aStream tab ].	aStream nextPutAll: 'while (1) {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	(level + 1) timesRepeat: [ aStream tab ].	aStream nextPutAll: 'if (!('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: ')) break;'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.</body><body package="HPSVM Primitive Plugins" selector="generateWhileForeverBreakTrueLoop:on:indent:">generateWhileForeverBreakTrueLoop: msgNode on: aStream indent: level	"Generate while(1) {stmtListA; if(cond) break; stmtListB}."	| stmts testStmt |	stmts := msgNode receiver statements asOrderedCollection.	testStmt := stmts removeLast.	msgNode receiver setStatements: stmts.	level - 1 timesRepeat: [ aStream tab ].	aStream nextPutAll: 'while (1) {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	(level + 1) timesRepeat: [ aStream tab ].	aStream nextPutAll: 'if ('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: ') break;'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.</body><body package="HPSVM Primitive Plugins" selector="generateWhileTrue:on:indent:">generateWhileTrue: msgNode on: aStream indent: level	"Generate C code for a loop in one of the following formats, as appropriate:		while(cond) { stmtList }		do {stmtList} while(cond)		while(1) {stmtListA; if (!(cond)) break; stmtListB}"	msgNode receiver statements size &lt;= 1		ifTrue: [^self generateWhileTrueLoop: msgNode on: aStream indent: level].	msgNode args first isNilStmtListNode		ifTrue: [^self generateDoWhileTrue: msgNode on: aStream indent: level].	^self generateWhileForeverBreakFalseLoop: msgNode on: aStream indent: level</body><body package="HPSVM Primitive Plugins" selector="generateWhileTrueLoop:on:indent:">generateWhileTrueLoop: msgNode on: aStream indent: level	"Generate while(cond) {stmtList}."	aStream nextPutAll: 'while ('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args first isNilStmtListNode ifFalse:		[msgNode args first emitCCodeOn: aStream level: level + 1 generator: self].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.</body><body package="HPSVM Primitive Plugins" selector="initializeCTranslationDictionary">initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| triples |	translationDict := Dictionary new: 200.	asArgumentTranslationDict := Dictionary new: 10.	triples := #(	#&amp;				#generateAnd:on:indent:		nil	#|				#generateOr:on:indent:		nil	#and:			#generateSequentialAnd:on:indent:		nil	#or:			#generateSequentialOr:on:indent:		nil	#not			#generateNot:on:indent:		nil	#+				#generatePlus:on:indent:		nil	#-				#generateMinus:on:indent:		nil	#*				#generateTimes:on:indent:		nil	#/				#generateDivide:on:indent:		nil	#//				#generateDivide:on:indent:		nil	#\\				#generateModulo:on:indent:		nil	#&lt;&lt;			#generateShiftLeft:on:indent:		nil	#&gt;&gt;			#generateShiftRight:on:indent:		nil	#min:			#generateMin:on:indent:		nil	#max:			#generateMax:on:indent:		nil	#bitAnd:		#generateBitAnd:on:indent:		nil	#bitOr:			#generateBitOr:on:indent:		nil	#bitXor:		#generateBitXor:on:indent:		nil	#bitShift:		#generateBitShift:on:indent:		nil	#bitInvert32	#generateBitInvert32:on:indent:		nil	#&lt;				#generateLessThan:on:indent:		nil	#&lt;=			#generateLessThanOrEqual:on:indent:		nil	#=				#generateEqual:on:indent:		nil	#&gt;				#generateGreaterThan:on:indent:		nil	#&gt;=			#generateGreaterThanOrEqual:on:indent:		nil	#~=			#generateNotEqual:on:indent:		nil	#==			#generateEqual:on:indent:		nil	#~~			#generateNotEqual:on:indent:		nil	#isNil			#generateIsNil:on:indent:		nil	#notNil			#generateNotNil:on:indent:		nil	#whileTrue: 	#generateWhileTrue:on:indent:		nil	#whileFalse:	#generateWhileFalse:on:indent:		nil	#whileTrue 	#generateDoWhileTrue:on:indent:		nil	#whileFalse	#generateDoWhileFalse:on:indent:		nil	#to:do:			#generateToDo:on:indent:		nil	#to:by:do:		#generateToByDo:on:indent:		nil	#ifTrue:			#generateIfTrue:on:indent:		#generateIfTrueAsArgument:on:indent:		#ifFalse:		#generateIfFalse:on:indent:		#generateIfFalseAsArgument:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:		#generateIfTrueIfFalseAsArgument:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:		#generateIfFalseIfTrueAsArgument:on:indent:	#at:				#generateAt:on:indent:		nil	#at:put:			#generateAtPut:on:indent:		nil	#basicAt:		#generateAt:on:indent:		nil	#basicAt:put:	#generateAtPut:on:indent:		nil	#class				#generateClass:on:indent:		nil	#cCode:				#generateInlineCCode:on:indent:		nil	#cCode:inSmalltalk:	#generateInlineCCode:on:indent:		nil	#cCoerce:to:			#generateCCoercion:on:indent:		nil	#preIncrement		#generatePreIncrement:on:indent:		nil	#preDecrement		#generatePreDecrement:on:indent:		nil	#inline:				#generateInlineDirective:on:indent:		nil	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:		nil	#asFloat				#generateAsFloat:on:indent:		nil	#asInteger			#generateAsInteger:on:indent:		nil	#anyMask:			#generateBitAnd:on:indent:		nil	#raisedTo:			#generateRaisedTo:on:indent:		nil	#perform:						#generatePerform:on:indent:		nil	#perform:with:					#generatePerform:on:indent:		nil	#perform:with:with:				#generatePerform:on:indent:		nil	#perform:with:with:with:		#generatePerform:on:indent:		nil	#perform:with:with:with:with:	#generatePerform:on:indent:		nil	).	1 to: triples size by: 3 do: [:i |		translationDict at: (triples at: i) put: (triples at: i + 1).		(triples at: i + 2) notNil ifTrue:			[asArgumentTranslationDict at: (triples at: i) put: (triples at: i + 2)]]</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="printArray:on:">printArray: array on: aStream	| first |	first := true.	1 to: array size do:		[:i |		first 			ifTrue: [first := false]			ifFalse: [aStream nextPutAll: ', '].		i \\ 16 = 1 ifTrue: [aStream cr].		self printInt: (array at: i) on: aStream]</body><body package="HPSVM Primitive Plugins" selector="printInt:on:">printInt: int on: aStream	aStream print: int.	(int between: -2147483648 and: 2147483647)		ifFalse: [(int between: 2147483648 and: 4294967295)			ifTrue: [aStream nextPut: $U]			ifFalse: [aStream nextPut: $L]]</body><body package="HPSVM Primitive Plugins" selector="visualWorks">visualWorks	^true</body></methods><methods><class-id>HPSVM.CCodeGenerator</class-id> <category>As yet unclassified</category><body package="HPSVM Primitive Plugins" selector="unreachableMethodsRetaining:">unreachableMethodsRetaining: selectorsToRetain	"Return a collection of methods that are never invoked."	| sent out toTrace traced toTraceNext |	sent := Set new.	toTrace := Set new.	traced := Set new.	methods do:		[ :m |		m export ifTrue:[sent add: m selector. toTrace add: m].		m isStatic ifFalse: [sent add: m selector. toTrace add: m]].	selectorsToRetain do:		[:sel|		(methods includesKey: sel) ifTrue:			[sent add: sel. toTrace add: (methods at: sel)]].	[toTrace notEmpty] whileTrue:		[toTraceNext := Set new.		 toTrace do:			[:m|			traced add: m.			m allCalls do:				[:selector| | callee |				sent add: selector.				callee := methods at: selector ifAbsent: [].				(callee notNil and: [(traced includes: callee) not]) ifTrue:					[toTraceNext add: callee]]].		 toTrace := toTraceNext].	out := OrderedCollection new.	methods keys do:		[ :sel |		(sent includes: sel) ifFalse: [out add: sel]].	^ out</body></methods><methods><class-id>HPSVM.CCodeGenerator class</class-id> <category>removing from system</category><body package="HPSVM Primitive Plugins" selector="removeCompilerMethods">removeCompilerMethods	"Before removing the C code generator classes from the system, use this method to remove the compiler node methods that support it. This avoids leaving dangling references to C code generator classes in the compiler node classes."	ProgramNode withAllSubclasses do:		[ :nodeClass |		nodeClass removeCategory: 'C translation'].	#{AbstractSound} ifDefinedDo:		[:abstractSound |		 abstractSound class removeCategory: 'primitive generation'].</body></methods><methods><class-id>HPSVM.CCodeGenerator class</class-id> <category>class initialization</category><body package="HPSVM Primitive Plugins" selector="initialize">initialize	"HPSVM.CCodeGenerator initialize"	UseRightShiftForDivide := true.		"If UseRightShiftForDivide is true, the translator will generate a right-shift when it encounters a division by a constant that is a small power of two. For example, 'x / 8' will generate '((oopInt) x &gt;&gt; 3)'. The coercion to int is done to make it clear that the C compiler should generate a signed shift."		"Note: The Kernighan and Ritchie 2nd Edition C manual, p. 49, leaves the semantics of right-shifting a negative number open to the discretion of the compiler implementor. However, it strongly suggests that most compilers should generate an arithmetic right shift (i.e., shifting in the sign bit), which is the same as dividing by a power of two. If your compiler does not generate or simulate an arithmetic shift, then make this class variable false and re-translate."</body></methods><methods><class-id>Kernel.CascadeNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationToCNode">asTranslationToCNode	^TtoCStmtListNode new		setArguments: #()		statements: (messages collect:			[ :msg| msg asTranslationToCNode receiver: receiver asTranslationToCNode]);		comment: comment</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationToCNode">asTranslationToCNode 	true ifTrue: [^TtoCConstantNode new setValue: value].	^TtoCConstantNode new		setValue: (value respondsToArithmetic						ifTrue: [value]						ifFalse: [value printString])</body></methods><methods><class-id>HPSVM.TtoCCaseStmtNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="bindVariableUsesIn:">bindVariableUsesIn: aDictionary	expression := expression bindVariableUsesIn: aDictionary.	cases := cases collect: [ :c | c bindVariableUsesIn: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="bindVariablesIn:">bindVariablesIn: aDictionary	expression := expression bindVariablesIn: aDictionary.	cases := cases collect: [ :c | c bindVariablesIn: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="cases">cases	^cases</body><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new		setExpression: expression copyTree		firsts: firsts copy		lasts: lasts copy		cases: (cases collect: [ :case | case copyTree ])</body><body package="HPSVM Primitive Plugins" selector="customizeCase:forVar:from:to:">customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."	| newCases dict newCase |	newCases := OrderedCollection new.	firstIndex to: lastIndex do: [ :caseIndex |		dict := Dictionary new.		dict at: varName put: (TtoCConstantNode new setValue: caseIndex).		newCase := caseParseTree copyTree bindVariableUsesIn: dict.		self fixSharedCodeBlocksForCase: caseIndex in: newCase.		newCases addLast: newCase.	].	^ newCases</body><body package="HPSVM Primitive Plugins" selector="customizeShortCasesForDispatchVar:">customizeShortCasesForDispatchVar: varName	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."	| newFirsts newLasts newCases l f case expanded |	newFirsts := OrderedCollection new.	newLasts := OrderedCollection new.	newCases := OrderedCollection new.	1 to: cases size do: [ :i |		l := lasts at: i.		f := firsts at: i.		case := cases at: i.		expanded := false.		(l - f) &gt; 1 ifTrue: [  "case code covers multiple cases"			case nodeCount &lt; 60 ifTrue: [				newFirsts addAll: (f to: l).				newLasts addAll: (f to: l).				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).				expanded := true.			].		].		expanded ifFalse: [			self fixSharedCodeBlocksForCase: f in: case.			newFirsts addLast: f.			newLasts addLast: l.			newCases addLast: case.		].	].	firsts := newFirsts asArray.	lasts := newLasts asArray.	cases := newCases asArray.</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen	| indent |	indent := (String new: level) collect: [ :ch | Character tab ].	aStream nextPutAll: 'switch ('.	expression emitCCodeOn: aStream level: level generator: aCodeGen.	aStream nextPutAll: ') {'; cr.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream nextPutAll: indent, 'case ', caseIndex printString, ':'; cr.		].		(cases at: i) emitCCodeOn: aStream level: level + 1 generator: aCodeGen.		aStream nextPutAll: indent; tab; nextPutAll: 'break;'.		aStream cr.	].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.</body><body package="HPSVM Primitive Plugins" selector="expression">expression	^expression</body><body package="HPSVM Primitive Plugins" selector="fixSharedCodeBlocksForCase:in:">fixSharedCodeBlocksForCase: caseIndex in: caseParseTree	"Process 'sharedCode' directives in the given parse tree. The sharedCode directive allows code replicated in different arms of a case statement to be shared. The replicated code must be the final code of the case so that it ends with a break out of the case statement. The replicated code will be generated in exactly one arm of the case statement; other instances of the shared code will be replaced by branches to that single instance of the code."	"NOTE: I have made this work for the nested case (ie several shared entry points in the same case, but it does not really work for methods with arguments.  A mechanism coud be added that would add a preamble of the form,	innerSharedTemp = outerTemp;when they differed.  There should at least be a test here."	| copying oldStmts newStmts stmt codeBlockName |	caseParseTree  nodesDo: [ :node |		node isStmtList ifTrue: [			copying := true.			oldStmts := node statements asArray.			newStmts := nil.  "becomes an OrderedCollection if sharedCode block is found"			1 to: oldStmts size do: [ :i |				copying ifTrue: [					stmt := oldStmts at: i.					(stmt isSend and: [stmt selector = #sharedCodeNamed:inCase:]) ifTrue: [						newStmts == nil 							ifTrue: [newStmts := (oldStmts copyFrom: 1 to: i - 1) asOrderedCollection]							ifFalse: [newStmts removeLast "preserve any prior shared entry points - di"].						codeBlockName := stmt args first value.						(stmt args last value = caseIndex) ifTrue: [							newStmts add: 								(TtoCLabeledCommentNode new setLabel: codeBlockName comment: '').						] ifFalse: [							newStmts add: (TtoCGoToNode new setLabel: codeBlockName).							copying := false.  "don't copy remaining statements"						].					] ifFalse: [						newStmts = nil ifFalse: [newStmts add: stmt].					].				] ifFalse: [	"ikp: this permits explicit returns before 'goto aSharedCodeLabel'"					stmt := oldStmts at: i.					(stmt isLabel and: [stmt label ~= nil]) ifTrue: [newStmts add: stmt].				].			].			newStmts = nil ifFalse: [node setStatements: newStmts].		].	].</body><body package="HPSVM Primitive Plugins" selector="inlineMethodsUsing:">inlineMethodsUsing: aDictionary	expression inlineMethodsUsing: aDictionary.	cases do: [ :c | c inlineMethodsUsing: aDictionary ].</body><body package="HPSVM Primitive Plugins" selector="isCaseStmt">isCaseStmt	^true</body><body package="HPSVM Primitive Plugins" selector="nodesDo:">nodesDo: aBlock	expression nodesDo: aBlock.	cases do: [ :c | c nodesDo: aBlock ].	aBlock value: self.</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	aStream crtab: level.	aStream nextPutAll: 'select '.	expression printOn: aStream level: level.	aStream nextPutAll: ' in'.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream crtab: level.			aStream nextPutAll: 'case ', caseIndex printString, ':'.		].		aStream crtab: level + 1.		(cases at: i) printOn: aStream level: level + 1.	].	aStream crtab: level.	aStream nextPutAll: 'end select'.</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	expression removeAssertions.	cases do: [ :case | case removeAssertions ].</body><body package="HPSVM Primitive Plugins" selector="replaceNodesIn:">replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression := expression replaceNodesIn: aDictionary.		cases := cases collect: [ :c | c replaceNodesIn: aDictionary ].		self]</body><body package="HPSVM Primitive Plugins" selector="setExpression:firsts:lasts:cases:">setExpression: aNode firsts: firstsList lasts: lastsList cases: caseList	expression := aNode.	firsts := firstsList.	lasts := lastsList.	cases := caseList.</body><body package="HPSVM Primitive Plugins" selector="setExpression:selectors:arguments:">setExpression: aNode selectors: selectorList arguments: anArray	"Initialize the node from the given set of selectors."	"Note: Each case is a statement list with containing one statement, a send to self of a selector from the given selector list. Having statement list nodes makes inlining easier later."	| selfNode stmt lastSel firstInRun sel |	expression := aNode.	selfNode := TtoCVariableNode new setName: 'self'.	firsts := OrderedCollection new: 400.	lasts := OrderedCollection new: 400.	cases := OrderedCollection new: 400.	lastSel := selectorList first.	firstInRun := 0.	1 to: selectorList size do: [ :i |		sel := selectorList at: i.		sel ~= lastSel ifTrue: [			firsts add: firstInRun.			lasts add: i - 2.			stmt := TtoCSendNode new setSelector: lastSel receiver: selfNode arguments: anArray.			cases add: (TtoCStmtListNode new setArguments: #() statements: (Array with: stmt)).			lastSel := sel.			firstInRun := i - 1.		].	].	firsts add: firstInRun.	lasts add: selectorList size - 1.	stmt := TtoCSendNode new setSelector: lastSel receiver: selfNode arguments: anArray.	cases add: (TtoCStmtListNode new setArguments: #() statements: (Array with: stmt)).</body></methods><methods><class-id>HPSVM.PluggableCodeGenerator</class-id> <category>As yet unclassified</category><body package="HPSVM Primitive Plugins" selector="addUsedSelectorsInClass:">addUsedSelectorsInClass: aClass	"Add the transitive closure of used selectors in aClass"	| pass |	pass := 1.	[self addUsedSelectorsInClass: aClass pass: pass] whileTrue:		[pass := pass + 1]</body><body package="HPSVM Primitive Plugins" selector="addUsedSelectorsInClass:pass:">addUsedSelectorsInClass: aClass pass: pass	| addedSome selectorsToAdd |	selectorsToAdd := Set new.	methods do:		[ :m|		m messages do:			[:s|			((aClass includesSelector: s)			  and: [(m isMacroDefinition not					or: [m class isMacroDefinition: (aClass compiledMethodAt: s)])			  and: [s ~~ m selector "don't treat recursive calls as roots"]]) ifTrue:				[selectorsToAdd add: s]]].	selectorsToAdd isEmpty ifTrue: [^false].	addedSome := false.	selectorsToAdd := selectorsToAdd asSortedCollection.	'Adding Used Methods In Class ' , aClass name , ' pass ', pass printString, '...'		displayProgressAt: InputSensor cursorPoint		from: 0		to: selectorsToAdd size		during: 			[:bar |			selectorsToAdd				doWithIndex: 					[:sel :i | | source |					bar value: i.					(methods includesKey: sel) ifFalse:						[addedSome := true.						 source := aClass sourceCodeAt: sel.						 self addMethod: (((Compiler new								parse: source								in: aClass								notifying: nil)									node asTranslationMethodOfClass: self translationMethodClass)									definingClass: aClass;									yourself)]]].	^addedSome</body></methods><methods><class-id>HPSVM.PluggableCodeGenerator</class-id> <category>public</category><body package="HPSVM Primitive Plugins" selector="codeStringForPrimitives:">codeStringForPrimitives: classAndSelectorList 	self addClass: InterpreterPlugin.	InterpreterPlugin declareCVarsIn: self.	^super codeStringForPrimitives: classAndSelectorList</body></methods><methods><class-id>HPSVM.PluggableCodeGenerator</class-id> <category>C code generator</category><body package="HPSVM Primitive Plugins" selector="emitCHeaderForPrimitivesOn:">emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	self emitCHeaderOn: aStream.	aStream nextPutAll: '/*** Plugin Functions ***/#define primitiveFail() (failed = TRUE)'.	self visualWorks ifTrue: [^self].	aStream nextPutAll: '/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy-&gt;stackValue(i))#define stackIntegerValue(i) (interpreterProxy-&gt;stackIntegerValue(i))#define successFlag (!interpreterProxy-&gt;failed())#define success(bool) (interpreterProxy-&gt;success(bool))#define arrayValueOf(oop) (interpreterProxy-&gt;arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy-&gt;checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy-&gt;fetchArrayofObject(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy-&gt;fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy-&gt;fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy-&gt;floatValueOf(oop))#define pop(n) (interpreterProxy-&gt;pop(n))#define pushInteger(n) (interpreterProxy-&gt;pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy-&gt;sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy-&gt;storeIntegerofObjectwithValue(idx,oop,value))#define primitiveFail() interpreterProxy-&gt;primitiveFail()/* allows accessing Strings in both C and Smalltalk */#define asciiValue(c) c'.	aStream cr.</body><body package="HPSVM Primitive Plugins" selector="emitCHeaderOn:">emitCHeaderOn: aStream	"Write a C file header onto the given stream."	| t |	aStream		nextPutAll: '/* Automatically generated from VisualWorks on ';		print: (t := Time dateAndTimeNow) first; space; print: t last;		nextPutAll: ' */';		cr; cr.	#('#if !defined(BUILTIN_PLUGIN) &amp;&amp; defined(_WIN32) /* Inevitably Windows is a little more problematic than other platforms; sigh... */'		'#	define DLUP_EXPORT(returnType) __declspec(dllexport) returnType'		'#	define DLUP_IMPORT(returnType) __declspec(dllimport) returnType'		'#else'		'#	define DLUP_EXPORT(returnType) returnType'		'#endif')		do: [:str| aStream cr; nextPutAll: str].	aStream cr; cr.	"header files"	headerFiles do:		[:hdr| aStream nextPutAll:'#include "'; nextPutAll: hdr; nextPutAll: '.h"'; cr].	aStream cr; cr.	wordsToUndefine asSortedCollection do:		[:word| aStream nextPutAll: '#undef '; nextPutAll: word; cr].	aStream		cr;		nextPutAll: '#define null 0  /* using ''null'' because nil is predefined in Think C */';		cr;		cr</body></methods><methods><class-id>HPSVM.PluggableCodeGenerator</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="isGeneratingPluginCode">isGeneratingPluginCode	^true</body></methods><methods><class-id>HPSVM.PluggableCodeGenerator</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="storeVirtualMachineProxyHeader:on:">storeVirtualMachineProxyHeader: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream := fileName asFilename newReadWriteStream.	stream nextPutAll:'#ifndef _HPSVM_H#define _HPSVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 0typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr; crtab.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitProxyFunctionPrototype: stream generator: self.			stream nextPutAll: ';'; crtab]].	stream nextPutAll:'} VirtualMachine;#endif /* _HPSVM_H */'.	stream close.</body><body package="HPSVM Primitive Plugins" selector="storeVirtualMachineProxyImplementation:on:">storeVirtualMachineProxyImplementation: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream := fileName asFilename newReadWriteStream.	stream nextPutAll:'#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include "sqVirtualMachine.h"'; cr;cr.	stream nextPutAll:'/*** Function prototypes ***/'.	categoryList do:[:assoc|		stream cr; cr; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitCFunctionPrototype: stream generator: self]].	stream cr; nextPutAll:'struct VirtualMachine *VM = NULL;'; cr.	stream cr; nextPutAll:'static int majorVersion(void) {	return VM_PROXY_MAJOR;}static int minorVersion(void) {	return VM_PROXY_MINOR;}struct VirtualMachine* sqGetInterpreterProxy(void){	if(VM) return VM;	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));	/* Initialize Function pointers */	VM-&gt;majorVersion = majorVersion;	VM-&gt;minorVersion = minorVersion;'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; crtab.		assoc value asSortedCollection do:[:sel|		stream nextPutAll:'VM-&gt;';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:' = ';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:';';			crtab]].	stream cr; crtab; nextPutAll:'return VM;'; cr; nextPutAll:'}'; cr.	stream close.</body></methods><methods><class-id>HPSVM.TestCodeGenerator</class-id> <category>translating builtins</category><body package="HPSVM Primitive Plugins" selector="generateAsBooleanObj:on:indent:">generateAsBooleanObj: aNode on: aStream indent: anInteger	aStream nextPutAll: 'STBool('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsCBoolean:on:indent:">generateAsCBoolean: aNode on: aStream indent: anInteger	aStream nextPutAll: 'booleanValueOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsCInt:on:indent:">generateAsCInt: aNode on: aStream indent: anInteger	aStream nextPutAll: 'oopIntVal('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsCUnsigned:on:indent:">generateAsCUnsigned: aNode on: aStream indent: anInteger	aStream nextPutAll: 'positive32BitValueOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsCharPtr:on:indent:">generateAsCharPtr: aNode on: aStream indent: anInteger	aStream nextPutAll: 'firstIndexableField('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsFloatObj:on:indent:">generateAsFloatObj: aNode on: aStream indent: anInteger	aStream nextPutAll: 'floatObjectOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsIfVar:on:indent:">generateAsIfVar: aNode on: aStream indent: anInteger	| cName fName class index |	cName := String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class := self class environment at: cName asSymbol ifAbsent: [nil].	class isBehavior ifFalse: 		[^self error: 'first arg must identify class'].	fName := aNode args second value.	index := class allInstVarNames				indexOf: fName				ifAbsent: [^self error: 'second arg must be instVar'].	aStream 		nextPutAll: 'fetchPointerofObject(';		print: index - 1;		nextPut: $,.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsIfVarAsValue:on:indent:">generateAsIfVarAsValue: aNode on: aStream indent: anInteger	| cName fName class index fetchNode |	cName := String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class := self class environment at: cName asSymbol ifAbsent: [nil].	class isBehavior ifFalse: 		[^self error: 'first arg must identify class'].	fName := aNode args second value.	index := class allInstVarNames		indexOf: fName		ifAbsent: [^self error: 'second arg must be instVar'].	fetchNode := TtoCSendNode new		setSelector: #fetchPointer:ofObject:		receiver: (TtoCVariableNode new setName: self vmNameString)		arguments: (Array						with: (TtoCConstantNode new setValue: index - 1)						with: aNode receiver).	cName := aNode args third nameOrValue.	class := self class environment at: cName asSymbol ifAbsent: [nil].	class isBehavior ifFalse: 		[^self error: 'third arg must identify class'].	class ccg: self generateCoerceToValueFrom: fetchNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="generateAsIfVarPut:on:indent:">generateAsIfVarPut: aNode on: aStream indent: anInteger	| cName fName class index |	cName := String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class := self class environment at: cName asSymbol ifAbsent: [nil].	class isBehavior ifFalse: 		[^self error: 'first arg must identify class'].	fName := aNode args second value.	index := class allInstVarNames				indexOf: fName				ifAbsent: [^self error: 'second arg must be instVar'].	aStream 		nextPutAll: 'storePointerofObjectwithValue(';		print: index - 1;		nextPut: $,.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $,.	self emitCExpression: aNode args third on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsIntPtr:on:indent:">generateAsIntPtr: aNode on: aStream indent: anInteger	aStream nextPutAll: '(oopInt *) firstIndexableField('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsOop:on:indent:">generateAsOop: aNode on: aStream indent: anInteger	| cName class |	self notYetImplemented.	cName := aNode args first nameOrValue.	class := self class environment at: cName asSymbol ifAbsent: [nil].	class isBehavior ifFalse: 		[^self error: 'first arg must identify class'].	class ccg: self generateCoerceToOopFrom: aNode receiver on: aStream</body><body package="HPSVM Primitive Plugins" selector="generateAsPositiveIntegerObj:on:indent:">generateAsPositiveIntegerObj: aNode on: aStream indent: anInteger	aStream nextPutAll: 'positive32BitIntegerFor('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsSmallIntegerObj:on:indent:">generateAsSmallIntegerObj: aNode on: aStream indent: anInteger	aStream nextPutAll: 'integerObjectOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateAsValue:on:indent:">generateAsValue: aNode on: aStream indent: anInteger	| cName class |	cName := aNode args first nameOrValue.	class := self class environment at: cName asSymbol ifAbsent: [nil].	class isBehavior ifFalse: 		[^self error: 'first arg must identify class'].	class ccg: self generateCoerceToValueFrom: aNode receiver on: aStream</body><body package="HPSVM Primitive Plugins" selector="generateCPtrAsOop:on:indent:">generateCPtrAsOop: aNode on: aStream indent: anInteger	"This is a horrible hack!  Essentially VW cannot implement	 cPtrAsOop except by knowing which oop gave rise to which C pointer."	aNode receiver isVariable ifFalse:		[ self error: 'cPtrAsOop can only be applied to variables' ].	aStream nextPutAll: (TestTtoCMethod argNameFor: aNode receiver name)</body><body package="HPSVM Primitive Plugins" selector="generateDebugCode:on:indent:">generateDebugCode: aNode on: aStream indent: level 	"Generate the C debug code for this message onto the given stream, if  	compiled in debugMode."	self generateDebugCode		ifTrue: 			[aStream nextPutAll: '/* DebugCode... */';			 cr.			aNode args first				emitCCodeOn: aStream				level: level				generator: self.			aStream tab: level.			aStream nextPutAll: '/* ...DebugCode */']		ifFalse: [aStream nextPutAll: '/* missing DebugCode */']</body><body package="HPSVM Primitive Plugins" selector="generateField:on:indent:">generateField: aNode on: aStream indent: anInteger	aStream nextPutAll: 'fetchPointerofObject('.	self emitCExpression: aNode args first on: aStream.	aStream nextPut: $,.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateFieldPut:on:indent:">generateFieldPut: aNode on: aStream indent: anInteger			aStream nextPutAll: 'storePointerofObjectwithValue('.	self emitCExpression: aNode args first on: aStream.	aStream nextPut: $,.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $,.	self emitCExpression: aNode args second on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsFloat:on:indent:">generateIsFloat: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isFloatObject('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsIndexable:on:indent:">generateIsIndexable: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isIndexable('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsIntegerOop:on:indent:">generateIsIntegerOop: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isIntegerObject('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsIntegerValue:on:indent:">generateIsIntegerValue: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isIntegerValue('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsKindOf:on:indent:">generateIsKindOf: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isKindOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','''.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ''')'.</body><body package="HPSVM Primitive Plugins" selector="generateIsMemberOf:on:indent:">generateIsMemberOf: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isMemberOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','''.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ''')'.</body><body package="HPSVM Primitive Plugins" selector="generateIsPointers:on:indent:">generateIsPointers: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isPointers('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsWords:on:indent:">generateIsWords: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isWords('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateIsWordsOrBytes:on:indent:">generateIsWordsOrBytes: aNode on: aStream indent: anInteger	aStream nextPutAll: 'isWordsOrBytes('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateNext:on:indent:">generateNext: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	(varNode := msgNode receiver) isVariable ifFalse:		[ self error: 'next can only be applied to variables' ].	aStream		nextPut: $*;		nextPutAll: varNode name;		nextPutAll: '++'</body><body package="HPSVM Primitive Plugins" selector="generateRemapOopIn:on:indent:">generateRemapOopIn: aNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| idList |	idList := aNode args first nameOrValue.	idList class == Array ifFalse: [idList := Array with: idList].	idList do:		[:each | 		 aStream 			nextPutAll: 'pushRemappableOop(';			nextPutAll: each asString;			nextPutAll: ');']		separatedBy: [aStream crtab: level].	aStream cr.	aNode args second emitCCodeOn: aStream level: level generator: self.	level timesRepeat: [aStream tab].	idList reversed do:		[:each |		 aStream 			nextPutAll: each asString;			nextPutAll: ' = popRemappableOop()']		separatedBy: [aStream nextPut: $;; crtab: level].</body><body package="HPSVM Primitive Plugins" selector="generateStAt:on:indent:">generateStAt: aNode on: aStream indent: anInteger	aStream nextPutAll: 'stObjectat('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $,.	self emitCExpression: aNode args first on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateStAtPut:on:indent:">generateStAtPut: aNode on: aStream indent: anInteger	aStream nextPutAll: 'stObjectatput('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $,.	self emitCExpression: aNode args first on: aStream.	aStream nextPut: $,.	self emitCExpression: aNode args second on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateStSize:on:indent:">generateStSize: aNode on: aStream indent: anInteger	aStream nextPutAll: 'stSizeOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="initializeCTranslationDictionary">initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	super initializeCTranslationDictionary.	pairs := #(		#asCInt						#generateAsCInt:on:indent:		#asCUnsigned				#generateAsCUnsigned:on:indent:		#asCBoolean					#generateAsCBoolean:on:indent:		#asCDouble					#generateAsCDouble		#asSmallIntegerObj			#generateAsSmallIntegerObj:on:indent:		#asPositiveIntegerObj		#generateAsPositiveIntegerObj:on:indent:		#asBooleanObj				#generateAsBooleanObj:on:indent:		#asFloatObj					#generateAsFloatObj:on:indent:		#asIf:var:					#generateAsIfVar:on:indent:		#asIf:var:asValue:			#generateAsIfVarAsValue:on:indent:		#asIf:var:put:					#generateAsIfVarPut:on:indent:		#field:						#generateField:on:indent:		#field:put:					#generateFieldPut:on:indent:				#stSize						#generateStSize:on:indent:		#stAt:						#generateStAt:on:indent:		#stAt:put:					#generateStAtPut:on:indent:		#asCharPtr					#generateAsCharPtr:on:indent:		#asIntPtr					#generateAsIntPtr:on:indent:		#cPtrAsOop					#generateCPtrAsOop:on:indent:		#next						#generateNext:on:indent:		#asOop:						#generateAsOop:on:indent:		#asValue:					#generateAsValue:on:indent:		#isFloat						#generateIsFloat:on:indent:		#isIndexable					#generateIsIndexable:on:indent:		#isIntegerOop				#generateIsIntegerOop:on:indent:		#isIntegerValue				#generateIsIntegerValue:on:indent:		#FloatOop					#generateIsFloatValue:on:indent:		#isWords					#generateIsWords:on:indent:		#isWordsOrBytes			#generateIsWordsOrBytes:on:indent:		#isPointers					#generateIsPointers:on:indent:		#isMemberOf:				#generateIsMemberOf:on:indent:		#isKindOf:					#generateIsKindOf:on:indent:		#clone						#generateClone:on:indent:		#new						#generateNew:on:indent:		#new:						#generateNewSize:on:indent:		#superclass					#generateSuperclass:on:indent:		#remapOop:in:				#generateRemapOopIn:on:indent:		#debugCode:				#generateDebugCode:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].</body></methods><methods><class-id>HPSVM.TestCodeGenerator</class-id> <category>coercing</category><body package="HPSVM Primitive Plugins" selector="ccgLoad:expr:asKindOf:">ccgLoad: aBlock expr: aString asKindOf: aClass	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy is: ';		nextPutAll: aString;		nextPutAll: 	' KindOf: ';		print:	aClass asString;		nextPutAll: ').';		crtab;		nextPutAll: (self ccgLoad: aBlock exprAsRawOop: aString)]</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsBooleanValue:">ccgLoad: aBlock exprAsBooleanValue: aString	"Answer codestring for boolean coercion (with validating side-effect) of object, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: 'self booleanValueOf:', aString</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsCharPtr:andThen:">ccgLoad: aBlock exprAsCharPtr: aString andThen: valBlock	"Answer codestring for character pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: aString), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (self firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPut: $);		crtab: 3;		nextPutAll: 'to: ''char *''']))</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsCharacterValue:">ccgLoad: aBlock exprAsCharacterValue: aString	"Answer codestring for character coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: 'interpreterProxy characterValueOf: ', aString</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsFloatValue:">ccgLoad: aBlock exprAsFloatValue: aString	"Answer codestring for double precision coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: 'interpreterProxy floatValueOf: ', aString</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsIntPtr:andThen:">ccgLoad: aBlock exprAsIntPtr: aString andThen: valBlock	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: 'self cCoerce: ', aString, ' to: ''oopInt''.'), (String with: $. with: Character cr), 	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll: ') to: ''oopInt *''']))</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsIntegerValue:">ccgLoad: aBlock exprAsIntegerValue: aString	"Answer codestring for integer coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: 'interpreterProxy integerValueOf: ', aString</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsRawOop:">ccgLoad: aBlock exprAsRawOop: aString	"Answer a string for a Slang expression that will load an oop (without validation) from the argument variable aString  Apply aBlock, a BlockContext instance that when passed an expression, will return a string assigning the expression to the desired identifier, to the string before answering.  aString is a Slang expression that refers to the stack value, once it has been loaded."	^aBlock value: 'self cCoerce: ', aString, ' to: ''oopInt'''</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsUnsignedPtr:andThen:">ccgLoad: aBlock exprAsUnsignedPtr: aString andThen: valBlock	"Answer a codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: aString), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPut: $);		crtab: 3;		nextPutAll: 'to: ''unsigned *''']))</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsUnsignedValue:">ccgLoad: aBlock exprAsUnsignedValue: aString	"Answer a codestring for positive integer coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: 'interpreterProxy positive32BitValueOf: ', aString</body><body package="HPSVM Primitive Plugins" selector="ccgLoad:exprAsWBFloatPtr:">ccgLoad: aBlock exprAsWBFloatPtr: aString	"Answer codestring for single-precision float pointer to first indexable field of object (with validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPut: $);		crtab: 3;		nextPutAll: 'to: ''float *'''])</body><body package="HPSVM Primitive Plugins" selector="ccgTVarBlock:">ccgTVarBlock: anInteger	^[:expr | '(thisContext tempAt: 1) tempAt: ', anInteger asString, ' put: (', expr, ')']</body><body package="HPSVM Primitive Plugins" selector="ccgValBlock:expr:">ccgValBlock: valString expr: sourceExpr	^[:index | String streamContents:		[:aStream | aStream			nextPutAll: 'interpreterProxy success: (interpreterProxy ';			nextPutAll: valString;			nextPutAll: ': (';			nextPutAll: sourceExpr;			nextPutAll: '))']]</body></methods><methods><class-id>HPSVM.TestCodeGenerator</class-id> <category>asOop:/asValue:</category><body package="HPSVM Primitive Plugins" selector="generateCoerceToBooleanObjectFrom:on:">generateCoerceToBooleanObjectFrom: aNode on: aStream	aStream nextPutAll: 'STBool('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToBooleanValueFrom:on:">generateCoerceToBooleanValueFrom: aNode on: aStream	aStream nextPutAll: 'booleanValueOf('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToFloatObjectFrom:on:">generateCoerceToFloatObjectFrom: aNode on: aStream	aStream nextPutAll: 'floatObjectOf('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToFloatValueFrom:on:">generateCoerceToFloatValueFrom: aNode on: aStream	aStream nextPutAll: 'floatValueOf('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToObjectFromPtr:on:">generateCoerceToObjectFromPtr: aNode on: aStream	"This is a horrible hack!  Essentially VW cannot implement	 cPtrAsOop except by knowing which oop gave rise to which C pointer."	aStream nextPutAll: (TestTtoCMethod argNameFor: aNode name)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToPtr:fromObject:on:">generateCoerceToPtr: aString fromObject: aNode on: aStream	"This code assumes no named instance variables"	aStream 		nextPutAll: '((';		nextPutAll: aString;		nextPutAll: ') firstIndexableField('.	self emitCExpression: aNode on: aStream.	aStream nextPutAll: '))'</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToSmallIntegerObjectFrom:on:">generateCoerceToSmallIntegerObjectFrom: aNode on: aStream	aStream nextPutAll: 'integerObjectOf('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToSmallIntegerValueFrom:on:">generateCoerceToSmallIntegerValueFrom: aNode on: aStream	aStream nextPutAll: 'integerValueOf('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToUnsignedObjectFrom:on:">generateCoerceToUnsignedObjectFrom: aNode on: aStream	aStream nextPutAll: 'positive32BitIntegerFor('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="generateCoerceToUnsignedValueFrom:on:">generateCoerceToUnsignedValueFrom: aNode on: aStream	aStream nextPutAll: 'positive32BitValueOf('.	self emitCExpression: aNode on: aStream.	aStream nextPut: $)</body></methods><methods><class-id>HPSVM.TestCodeGenerator</class-id> <category>initialize</category><body package="HPSVM Primitive Plugins" selector="initialize">initialize	super initialize.	debugFlag := false</body></methods><methods><class-id>HPSVM.TestCodeGenerator</class-id> <category>transforming</category><body package="HPSVM Primitive Plugins" selector="var:as:">var: varName as: aClass	"Record the given C declaration for a global variable"	variableDeclarations at: varName asString put: (aClass ccgDeclareCForVar: varName)</body></methods><methods><class-id>HPSVM.TestCodeGenerator</class-id> <category>utilities</category><body package="HPSVM Primitive Plugins" selector="translationMethodClass">translationMethodClass	"return the class used to produce C translation methods from MethodNodes"	^TestTtoCMethod</body></methods><methods><class-id>HPSVM.TestCodeGenerator</class-id> <category>debug code</category><body package="HPSVM Primitive Plugins" selector="generateDebugCode">generateDebugCode	^ debugFlag</body><body package="HPSVM Primitive Plugins" selector="generateDebugCode:">generateDebugCode: aBool 	debugFlag := aBool</body></methods><methods><class-id>HPSVM.TestCClass3</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="dispatchOn:in:">dispatchOn: currentBytecode in: selectorArray	"Simulate a case statement via selector table lookup. The given integer must be between 0 and (selectorArray size - 1), inclusive. Send the selector at (currentBytecode + 1) in selectorArray to the receiver. For speed, no extra range test is done, since it is done by the at: operation."	"Note: Delete this method from the generated code."	"assert: (currentBytecode &gt;= 0) | (currentBytecode &lt; selectorArray size)"	self perform: (selectorArray at: (currentBytecode + 1)).</body><body package="HPSVM Primitive Plugins" selector="f1">f1	| local r |	local := self functionWithLabel: 1.	r := 7.	self print: 'f1'.</body><body package="HPSVM Primitive Plugins" selector="f2">f2	| local i |	local := 2.	i := self functionWithLabel: -2.	i &gt; 0 ifTrue: [ ^ -1 ].	self print: 'f2'.</body><body package="HPSVM Primitive Plugins" selector="f3">f3	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f3'.</body><body package="HPSVM Primitive Plugins" selector="f4">f4	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f4'.</body><body package="HPSVM Primitive Plugins" selector="f5">f5	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f5'.</body><body package="HPSVM Primitive Plugins" selector="functionWithLabel:">functionWithLabel: arg	arg &gt; 0 ifTrue: [ ^1 ] ifFalse: [ ^-1 ].</body><body package="HPSVM Primitive Plugins" selector="interpret">interpret	"TestCClass3 new main"	"(CCodeGenerator new initialize addClass: TestCClass3) codeString"	0 to: 9 do: [ :currentBytecode |		self dispatchOn: currentBytecode in: #(f1 f2 f2 f3 f3 f3 f4 f4 f5 f2).	].</body><body package="HPSVM Primitive Plugins" selector="print:">print: s	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.</body></methods><methods><class-id>HPSVM.InterpreterPlugin</class-id> <category>initialize</category><body package="HPSVM Primitive Plugins" selector="getModuleName">getModuleName	"Note: This is hardcoded so it can be run from Squeak.	The module name is used for validating a module *after*	it is loaded to check if it does really contain the module	we're thinking it contains. This is important!"	self returnTypeC:'const char*'.	self export: true.	^moduleName</body><body package="HPSVM Primitive Plugins" selector="setInterpreter:">setInterpreter: anInterpreter 	"Under VisualWorks in the translated code this doesn't need to do anything."	self cCode: '' inSmalltalk:[interpreterProxy := anInterpreter].		^ true</body></methods><methods><class-id>HPSVM.InterpreterPlugin</class-id> <category>debugging</category><body package="HPSVM Primitive Plugins" selector="halt">halt	self cCode: '' inSmalltalk: [super halt].</body><body package="HPSVM Primitive Plugins" selector="msg:">msg: s 	self var: #s declareC: 'char *s'.	self cCode: 'fprintf(stderr, "\n%s: %s", moduleName, s)' inSmalltalk: [Transcript cr; show: self class moduleName , ': ' , s; endEntry]</body></methods><methods><class-id>HPSVM.InterpreterPlugin class</class-id> <category>translation</category><body package="HPSVM Primitive Plugins" selector="addMethodsToRetainTo:">addMethodsToRetainTo: aSet	"Add the selectors of any and all methods we want to ensure are not pruned as unreachable.	 Subclasses may override to add selectors to the set."</body><body package="HPSVM Primitive Plugins" selector="baseDirectoryName">baseDirectoryName	"Return the directory into which plugins should be generated by default."	^Filename defaultDirectoryName</body><body package="HPSVM Primitive Plugins" selector="buildCodeGeneratorUpTo:">buildCodeGeneratorUpTo: aPluginClass	"Build a CCodeGenerator for the plugin"	 | cg theClass |	cg := self codeGeneratorClass new initialize.	cg plugin: self.	"Add an extra declaration for module name"	cg declareModuleName: self moduleNameAndVersion.	theClass := aPluginClass.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass := theClass superclass].	cg addUsedSelectorsInClass: InterpreterProxy.	^cg</body><body package="HPSVM Primitive Plugins" selector="declareCVarsIn:">declareCVarsIn: aCCodeGenerator	"Note: This method must be implemented by all subclasses to declare variables."	#("HPS reserved types (incomplete)"		'oop' 'bool' 'class') do:			[:rv| aCCodeGenerator addReservedWord: rv].	#("HPS defines that pollute the plugin namespace"		'fileHandle' 'imageOpenError' 'imageReadFlags' 'imageWriteFlags' 'operatingSystem'		'platform' 'processor') do:		[:def| aCCodeGenerator addWordToUndefine: def].	self declareHeaderFilesIn: aCCodeGenerator.</body><body package="HPSVM Primitive Plugins" selector="declareHeaderFilesIn:">declareHeaderFilesIn: aCCodeGenerator	#('hps' 'oop' 'mm' 'sysOop' 'class' 'pr' 'exMessage' 'mmAllocate') do:		[:header| aCCodeGenerator addHeaderFile: header].	self hasHeaderFile ifTrue:		[aCCodeGenerator addHeaderFile: self moduleName].</body><body package="HPSVM Primitive Plugins" selector="hasHeaderFile">hasHeaderFile	"If there is a single intrinsic header file to be associated with the plugin, here is where you want to flag"	^false</body><body package="HPSVM Primitive Plugins" selector="requiresCrossPlatformFiles">requiresCrossPlatformFiles	"default is ok for most, any plugin needing cross platform files aside from a normal header must say so. See SoundCodecPlugin for example"	^self hasHeaderFile</body><body package="HPSVM Primitive Plugins" selector="requiresPlatformFiles">requiresPlatformFiles	"default is ok for most, any plugin needing platform specific files must say so"	^false</body><body package="HPSVM Primitive Plugins" selector="selectorsForUsedInterpreterProxyMethodsFrom:">selectorsForUsedInterpreterProxyMethodsFrom: aCCodeGenerator	"Answer the set of selectors of methods used in InterpreterProxy.	 These must be generated when generating a stand-alone plugin."	 ^aCCodeGenerator methods		inject: Set new		into:			[:undecl :m|			undecl				addAll: (m messages select: [:s| InterpreterProxy includesSelector: s]);				yourself]</body><body package="HPSVM Primitive Plugins" selector="shouldBeTranslated">shouldBeTranslated"is this class intended to be translated as a plugin? Most subclasses should answer true, but some such as:-	TestInterpreterPlugin	FlippArrayPlugin2	InflatePlugin	should answer false for various reasons."	^true</body><body package="HPSVM Primitive Plugins" selector="storeString:onFileNamed:">storeString: s onFileNamed: fileName	"Store the given string in a file of the given name."	| f |	f := fileName asFilename newReadWriteStream.	[VMMaker setLineEndConventionForCode: f.	 f nextPutAll: s] ensure: [f close]</body><body package="HPSVM Primitive Plugins" selector="translateInDirectory:doInlining:">translateInDirectory: directory doInlining: inlineFlag"This is the default method for writing out sources for a plugin. Several classes need special handling, so look at all implementors of this message"	| cg fname fileName |	 fname := self moduleName, '.c'.	"don't translate if the file is newer than my timeStamp"	((fileName := directory construct: fname) exists	 and: [self timeStamp &lt; fileName modificationTimestamp]) ifTrue:		[^nil].	self initialize.	cg := self buildCodeGeneratorUpTo: self.	cg storeCodeOnFile:  (directory fullNameFor: fname) doInlining: inlineFlag.	^cg exportedPrimitiveNames asArray</body></methods><methods><class-id>HPSVM.InterpreterPlugin class</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="codeGeneratorClass">codeGeneratorClass	"return the appropriate class of code generator for this kind ofplugin"	^PluggableCodeGenerator</body><body package="HPSVM Primitive Plugins" selector="selectorForPrimitive:">selectorForPrimitive: aSymbol	self subclassResponsibility</body></methods><methods><class-id>HPSVM.InterpreterPlugin class</class-id> <category>instance creation</category><body package="HPSVM Primitive Plugins" selector="doPrimitive:receiver:">doPrimitive: primitiveName receiver: aReceiver	^self doPrimitive: primitiveName receiver: aReceiver arguments: #()</body><body package="HPSVM Primitive Plugins" selector="doPrimitive:receiver:arguments:">doPrimitive: primitiveName receiver: aReceiver arguments: argumentArray	| plugin |	plugin := self simulatorClass new.	plugin setInterpreter: InterpreterProxy new.	(plugin respondsTo: #initialiseModule) ifTrue: [plugin initialiseModule].	^plugin		perform: (self selectorForPrimitive: primitiveName)		withArguments: (Array with: aReceiver), argumentArray</body></methods><methods><class-id>HPSVM.InterpreterPlugin class</class-id> <category>class initialization</category><body package="HPSVM Primitive Plugins" selector="initialize">initialize	"Nothing to do ..."</body></methods><methods><class-id>HPSVM.InterpreterPlugin class</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="isCPP">isCPP	^ false</body><body package="HPSVM Primitive Plugins" selector="moduleExtension">moduleExtension	^ self isCPP ifTrue: ['.cpp'] ifFalse: ['.c']</body><body package="HPSVM Primitive Plugins" selector="moduleName">moduleName	"Answer the receiver's module name that is used for the plugin's C code."	^ self name asString</body><body package="HPSVM Primitive Plugins" selector="moduleNameAndVersion">moduleNameAndVersion	"Answer the receiver's module name and version info that is used for the plugin's C code. The default is to append the code generation date, but any useful text is ok (keep it short)"	^ self moduleName, ' ', Date today printString</body><body package="HPSVM Primitive Plugins" selector="simulatorClass">simulatorClass	"For running from Smalltalk - answer a class that can be used to 	simulate the receiver. By default every plugin can simulate itself."	^ self</body><body package="HPSVM Primitive Plugins" selector="timeStamp">timeStamp	^timeStamp ifNil: [Timestamp fromSeconds: 0]</body><body package="HPSVM Primitive Plugins" selector="touch">touch	timeStamp := Timestamp now</body></methods><methods><class-id>HPSVM.InterpreterPlugin class</class-id> <category>compiling</category><body package="HPSVM Primitive Plugins" selector="noteCompilationOf:meta:">noteCompilationOf: aSelector meta: isMeta	"note the recompiliation by resetting the timeStamp "	self touch.	^super noteCompilationOf: aSelector meta: isMeta</body><body package="HPSVM Primitive Plugins" selector="pluginGlobalVariables">pluginGlobalVariables	"Hook for subclasses to add or prune variables if required."	^self instVarNames copyWithout: 'interpreterProxy'</body></methods><methods><class-id>HPSVM.TestInterpreterPlugin</class-id> <category>debugging</category><body package="HPSVM Primitive Plugins" selector="sqAssert:">sqAssert: aBool 	self		debugCode: [aBool				ifFalse: [self error: 'Assertion failed!'].			^ aBool]</body></methods><methods><class-id>HPSVM.TestInterpreterPlugin class</class-id> <category>translation</category><body package="HPSVM Primitive Plugins" selector="addMethodsToRetainTo:">addMethodsToRetainTo: aSet	"Add the selectors of any and all methods we want to ensure are not pruned as unreachable."	aSet addAll: #(isIndexable: isBytes: isWords:)</body><body package="HPSVM Primitive Plugins" selector="shouldBeTranslated">shouldBeTranslated"TestInterpreterPlugin should not be translated but its subclasses should"	^self ~= TestInterpreterPlugin</body><body package="HPSVM Primitive Plugins" selector="translateDoInlining:locally:debug:">translateDoInlining: inlineFlag locally: localFlag debug: debugFlag 	^ self		translate: self moduleName , '.c'		doInlining: inlineFlag		locally: localFlag		debug: debugFlag</body></methods><methods><class-id>HPSVM.TestInterpreterPlugin class</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="codeGeneratorClass">codeGeneratorClass	"return the appropriate class of code generator for this kind ofplugin"	^TestCodeGenerator</body><body package="HPSVM Primitive Plugins" selector="generateVMProxyOn:">generateVMProxyOn: fileName	| cg proxyClass catList |	proxyClass := InterpreterProxy.	cg := TestCodeGenerator new initialize.	cg addClass: proxyClass.	catList := proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList := catList collect:[:cat| cat -&gt; (proxyClass organization listAtCategoryNamed: cat)].	cg storeVirtualMachineProxyHeader: catList on: (fileName,'.h').	cg storeVirtualMachineProxyImplementation: catList on: (fileName,'.c').	"InterpreterProxy generateVMProxyOn:'sqVirtualMachine'"</body></methods><methods><class-id>HPSVM.TestInterpreterPlugin class</class-id> <category>instance creation</category><body package="HPSVM Primitive Plugins" selector="doPrimitive:withArguments:">doPrimitive: primitiveName withArguments: argArray	| proxy plugin |	proxy := InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	plugin := self simulatorClass new.	plugin setInterpreter: proxy.	^plugin perform: primitiveName asSymbol withArguments: argArray</body></methods><methods><class-id>HPSVM.Oop class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToOopFrom:on:">ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToValueFrom:on:">ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock exprAsRawOop: aString</body><body package="HPSVM Primitive Plugins" selector="ccgCanConvertFrom:">ccgCanConvertFrom: anObject	^(anObject isKindOf: SmallInteger) not</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'oopInt ', aSymbolOrString</body></methods><methods><class-id>HPSVM.TtoCLabeledCommentNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new		setLabel: label		comment: comment</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C comment with optional label."	self printOptionalLabelOn: aStream.	aStream nextPutAll: '/* '.	aStream nextPutAll: comment.	aStream nextPutAll: ' */'.</body><body package="HPSVM Primitive Plugins" selector="isComment">isComment	"Answer true if the receiver is just a comment (i.e., it has no label)."	^label = nil</body><body package="HPSVM Primitive Plugins" selector="isLabel">isLabel	^true</body><body package="HPSVM Primitive Plugins" selector="isLeaf">isLeaf	^true</body><body package="HPSVM Primitive Plugins" selector="label">label	^label</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	self printOptionalLabelOn: aStream.	aStream nextPut: $".	aStream nextPutAll: comment.	aStream nextPut: $".</body><body package="HPSVM Primitive Plugins" selector="printOptionalLabelOn:">printOptionalLabelOn: aStream	label ~= nil ifTrue: [		self unindentOneTab: aStream.		aStream nextPutAll: label.		aStream nextPut: $:.		aStream tab.		].</body><body package="HPSVM Primitive Plugins" selector="setComment:">setComment: commentString	label := nil.	comment := commentString.</body><body package="HPSVM Primitive Plugins" selector="setLabel:">setLabel: labelString	label := labelString.</body><body package="HPSVM Primitive Plugins" selector="setLabel:comment:">setLabel: labelString comment: commentString	label := labelString.	comment := commentString.</body><body package="HPSVM Primitive Plugins" selector="unindentOneTab:">unindentOneTab: aStream	"Remove the last tab from the given stream if possible."	(aStream isKindOf: ReadWriteStream) ifFalse: [ ^self ].	aStream position &gt; 0 ifTrue: [		aStream position: aStream position - 1.		"restore stream position if previous char was not a tab"		aStream peek = Character tab ifFalse: [ aStream next ].	].</body></methods><methods><class-id>Kernel.MessageNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationToCNode">asTranslationToCNode	"selector is sometimes a Symbol, sometimes a SelectorNode!	On top of this, numArgs is needed due to the (truly grody) use of	arguments as a place to store the extra expressions needed to generate	code for in-line to:by:do:, etc.  see below, where it is used."	| sel args |	sel := selector isSymbol ifTrue: [selector] ifFalse: [selector key].	args := (1 to: sel numArgs) collect:			[:i | (arguments at: i) asTranslationToCNode].	(sel = #to:by:do: and: [arguments size = 7 and: [(arguments at: 7) notNil]])		ifTrue: ["Restore limit expr that got moved by transformToDo:"				args at: 1 put: (arguments at: 7) value asTranslationToCNode].	(sel = #or: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformOr:"				args at: 1 put: (arguments at: 2) asTranslationToCNode].	(sel = #ifFalse: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformIfFalse:"				args at: 1 put: (arguments at: 2) asTranslationToCNode].	^ TtoCSendNode new		setSelector: sel		receiver: (receiver ~~ nil ifTrue: [receiver asTranslationToCNode])		arguments: args</body></methods><methods><class-id>HPSVM.Unsigned</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock exprAsUnsignedValue: aString</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'unsigned ', aSymbolOrString</body></methods><methods><class-id>HPSVM.Unsigned class</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToOopFrom:on:">ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToUnsignedObjectFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToValueFrom:on:">ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg generateCoerceToUnsignedValueFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccgCanConvertFrom:">ccgCanConvertFrom: anObject	anObject isInteger ifFalse: 		[self error: 'Not an Integer object'. ^false].	anObject &gt;= 0 ifFalse: 		[self error: 'Object is negative integer'. ^false].	anObject &lt; (2 raisedToInteger: 32) ifFalse: 		[self error: 'Object is too large'. ^false].	^true</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>inlining support</category><body package="HPSVM Primitive Plugins" selector="addVarsDeclarationsAndLabelsOf:">addVarsDeclarationsAndLabelsOf: methodToBeInlined	"Prepare to inline the body of the given method into the receiver by making the args and locals of the argument to the receiver be locals of the receiver. Record any type declarations for these variables. Record labels. Assumes that the variables have already be renamed to avoid name clashes."	methodToBeInlined args, methodToBeInlined locals do: [ :v |		(locals includes: v) ifFalse: [ locals addLast: v ].	].	methodToBeInlined declarations associationsDo: [ :assoc |		declarations add: assoc.	].	methodToBeInlined labels do: [ :label |		labels add: label.	].</body><body package="HPSVM Primitive Plugins" selector="computePossibleSideEffectsIn:">computePossibleSideEffectsIn: aCodeGen	"Answer true if this method may have side effects. It has side effects if it assigns to a global variable. It may have side effects if it calls a non-built-in method."	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^true ].		].	].	^ false</body><body package="HPSVM Primitive Plugins" selector="endsWithReturn">endsWithReturn	"Answer true if the last statement of this method is a return."	^ parseTree statements last isReturn</body><body package="HPSVM Primitive Plugins" selector="extractInlineDirective">extractInlineDirective	"Scan the top-level statements for an inlining directive of the form:		self inline: &lt;boolean&gt;	 and remove the directive from the method body. Return the argument of the directive or #dontCare if there is no inlining directive."	| result newStatements |	result := #dontCare.	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do: 		[:stmt | 		(stmt isSend and: [stmt selector = #inline:]) 			ifTrue: [result := #(true #true 'true') includes: stmt args first nameOrValue]			ifFalse: [newStatements add: stmt]].	parseTree setStatements: newStatements asArray.	^result</body><body package="HPSVM Primitive Plugins" selector="hasReturn">hasReturn	"Answer true if this method contains a return statement."	parseTree nodesDo: [ :n | n isReturn ifTrue: [ ^ true ]].	^ false</body><body package="HPSVM Primitive Plugins" selector="isAssertion">isAssertion	^((selector beginsWith: 'assert') or: [selector beginsWith: 'verify']) or: [selector beginsWith: 'oe_assert']</body><body package="HPSVM Primitive Plugins" selector="maySubstituteGlobal:in:">maySubstituteGlobal: globalVar in: aCodeGen	"Answer true if this method does or may have side effects on the given global variable."	possibleSideEffectsCache = nil ifTrue: [		"see if this calls any other method and record the result"		possibleSideEffectsCache := self computePossibleSideEffectsIn: aCodeGen.	].	possibleSideEffectsCache ifTrue: [ ^ false ].	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [			node variable name = globalVar ifTrue: [ ^ false ].		].	].	"if we get here, receiver calls no other method	 and does not itself assign to the given global variable"	^ true</body><body package="HPSVM Primitive Plugins" selector="renameLabelsForInliningInto:">renameLabelsForInliningInto: destMethod	"Rename any labels that would clash with those of the destination method."	| destLabels usedLabels labelMap newLabelName |	destLabels := destMethod labels asSet.	usedLabels := destLabels copy.  "usedLabels keeps track of labels in use"	usedLabels addAll: labels.	labelMap := Dictionary new: 100.	self labels do: [ :l |		(destLabels includes: l) ifTrue: [			newLabelName := self unusedNamePrefixedBy: 'l' avoiding: usedLabels.			labelMap at: l put: newLabelName.		].	].	self renameLabelsUsing: labelMap.</body><body package="HPSVM Primitive Plugins" selector="renameLabelsUsing:">renameLabelsUsing: aDictionary	"Rename all labels according to the old-&gt;new mappings of the given dictionary."	labels := labels collect: [ :label |		(aDictionary includesKey: label) ifTrue: [ aDictionary at: label ] ifFalse: [ label ].	].	parseTree nodesDo: [ :node |		(node isGoTo and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].		(node isLabel and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].	].</body><body package="HPSVM Primitive Plugins" selector="renameVariablesUsing:">renameVariablesUsing: aDictionary	"Rename all variables according to old-&gt;new mappings of the given dictionary."	| newDecls |	"map args and locals"	args := args collect: [ :arg |		(aDictionary includesKey: arg) ifTrue: [ aDictionary at: arg ] ifFalse: [ arg ].	].	locals := locals collect: [ :v |		(aDictionary includesKey: v) ifTrue: [ aDictionary at: v ] ifFalse: [ v ].	].	"map declarations"	newDecls := declarations species new.	declarations associationsDo: [ :assoc |		(aDictionary includesKey: assoc key)			ifTrue: [ newDecls at: (aDictionary at: assoc key) put: assoc value ]			ifFalse: [ newDecls add: assoc ].	].	declarations := newDecls.	"map variable names in parse tree"	parseTree nodesDo: [ :node |		(node isVariable and:		 [aDictionary includesKey: node name]) ifTrue: [			node setName: (aDictionary at: node name).		].		(node isStmtList and: [node args size &gt; 0]) ifTrue: [			node setArguments:				(node args collect: [ :arg |					(aDictionary includesKey: arg)						ifTrue: [ aDictionary at: arg ]						ifFalse: [ arg ].				]).		].	].</body><body package="HPSVM Primitive Plugins" selector="renameVarsForCaseStmt">renameVarsForCaseStmt	"Rename the arguments and locals of this method with names like t1, t2, t3, etc. Return the number of variable names assigned. This is done to allow registers to be shared among the cases."	| i varMap |	i := 1.	varMap := Dictionary new: 100.	args, locals do: [ :v |		varMap at: v put: ('t', i printString) asSymbol.		i := i + 1.	].	self renameVariablesUsing: varMap.	^ i - 1</body><body package="HPSVM Primitive Plugins" selector="renameVarsForInliningInto:in:">renameVarsForInliningInto: destMethod in: aCodeGen	"Rename any variables that would clash with those of the destination method."	| destVars usedVars varMap newVarName |	destVars := aCodeGen globalsAsSet copy.	destVars addAll: destMethod locals.	destVars addAll: destMethod args.	usedVars := destVars copy.  "keeps track of names in use"	usedVars addAll: args; addAll: locals.	varMap := Dictionary new: 100.	args, locals do: [ :v |		(destVars includes: v) ifTrue: [			newVarName := self unusedNamePrefixedBy: v avoiding: usedVars.			varMap at: v put: newVarName.		].	].	self renameVariablesUsing: varMap.</body><body package="HPSVM Primitive Plugins" selector="unusedNamePrefixedBy:avoiding:">unusedNamePrefixedBy: aString avoiding: usedNames	"Choose a unique variable or label name with the given string as a prefix, avoiding the names in the given collection. The selected name is added to usedNames."	| n newVarName |	n := 1.	newVarName := aString, n printString.	[usedNames includes: newVarName] whileTrue: [		n := n + 1.		newVarName := aString, n printString.	].	usedNames add: newVarName.	^ newVarName</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>utilities</category><body package="HPSVM Primitive Plugins" selector="allCalls">allCalls	"Answer a collection of selectors for the messages sent by this method."	^parseTree allCalls</body><body package="HPSVM Primitive Plugins" selector="copy">copy	"Make a deep copy of this TMethod."	^ self class basicNew		setSelector: selector		returnType: returnType		args: args copy		locals: locals copy		declarations: declarations copy		primitive: primitive		parseTree: parseTree copyTree		labels: labels copy		complete: complete</body><body package="HPSVM Primitive Plugins" selector="freeVariableReferences">freeVariableReferences	"Answer a collection of variables referenced this method, excluding locals, arguments, and pseudovariables."	| refs |	refs := Set new.	parseTree nodesDo: [ :node |		node isVariable ifTrue: [ refs add: node name asString ].	].	args do: [ :var | refs remove: var asString ifAbsent: [] ].	locals do: [ :var | refs remove: var asString ifAbsent: [] ].	#('self' 'nil' 'true' 'false') do: [ :var | refs remove: var ifAbsent: [] ].	^ refs asSortedCollection</body><body package="HPSVM Primitive Plugins" selector="hasNoCCode">hasNoCCode	"Answer true if the receiver does not use inlined C or C declarations, which are not currently renamed properly by the the inliner."	declarations isEmpty ifFalse: [ ^ false ].	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node selector = #cCode: ifTrue: [ ^ false ].		].	].	^ true</body><body package="HPSVM Primitive Plugins" selector="nodeCount">nodeCount	"Answer the number of nodes in this method's parseTree (a rough measure of its size)."	| cnt |	cnt := 0.	parseTree nodesDo: [ :n | cnt := cnt + 1 ].	^cnt</body><body package="HPSVM Primitive Plugins" selector="variablesAssignedTo">variablesAssignedTo	"Answer a collection of variables assigned to by this method."	| refs |	refs := Set new.	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [ refs add: node variable name ].	].	^ refs</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>inlining</category><body package="HPSVM Primitive Plugins" selector="argAssignmentsFor:args:in:">argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList := OrderedCollection new: 100.	substitutionDict := Dictionary new: 100.	meth args with: argList do: [ :argName :exprNode |		(self isSubstitutableNode: exprNode intoMethod: meth in: aCodeGen) ifTrue: [			substitutionDict at: argName put: exprNode.			locals remove: argName.		] ifFalse: [			stmtList add: (TtoCAssignmentNode new				setVariable: (TtoCVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList</body><body package="HPSVM Primitive Plugins" selector="checkForCompleteness:in:">checkForCompleteness: stmtLists in: aCodeGen	"Set the complete flag if none of the given statement list nodes contains further candidates for inlining."	complete := true.	stmtLists do:		[ :stmtList |		stmtList statements do:			[ :node |			(self inlineableSend: node in: aCodeGen) ifTrue:				[complete := false.  "more inlining to do"				^self]]].	parseTree nodesDo:		[ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue:			[complete := false.  "more inlining to do"			^self]]</body><body package="HPSVM Primitive Plugins" selector="exitVar:label:">exitVar: exitVar label: exitLabel	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed |	labelUsed := false.	parseTree nodesDo: [ :node |		node isStmtList ifTrue: [			newStmts := OrderedCollection new: 100.			node statements do: [ :stmt |				(stmt isReturn) ifTrue: [					exitVar = nil ifTrue: [						stmt expression isLeaf ifFalse: [							"evaluate return expression even though value isn't used"							newStmts add: stmt expression.						].					] ifFalse: [						"assign return expression to exit variable"						newStmts add:							(TtoCAssignmentNode new								setVariable: (TtoCVariableNode new setName: exitVar)								expression: stmt expression).					].					(stmt == parseTree statements last) ifFalse: [						"generate a goto (this return is NOT the last statement in the method)"						newStmts add: (TtoCGoToNode new setLabel: exitLabel).						labelUsed := true.					].				] ifFalse: [					newStmts addLast: stmt.				].			].			node setStatements: newStmts asArray.		].	].	^labelUsed</body><body package="HPSVM Primitive Plugins" selector="inlineCaseStatementBranchesIn:localizingVars:">inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList	| stmt sel meth newStatements maxTemp usedVars exitLabel v |	maxTemp := 0.	parseTree nodesDo: [ :n |		n isCaseStmt ifTrue: [			n cases do: [ :stmtNode |				stmt := stmtNode statements first.				stmt isSend ifTrue: [					sel := stmt selector.					meth := aCodeGen methodNamed: sel.					((meth ~= nil) and:					 [meth hasNoCCode and:					 [meth args size = 0]]) ifTrue: [						meth := meth copy.						maxTemp := maxTemp max: (meth renameVarsForCaseStmt).						meth hasReturn ifTrue: [							exitLabel := self unusedLabelForInliningInto: self.							meth exitVar: nil label: exitLabel.							labels add: exitLabel.						] ifFalse: [ exitLabel := nil ].						meth renameLabelsForInliningInto: self.						meth labels do: [ :label | labels add: label ].						newStatements := stmtNode statements asOrderedCollection.						newStatements removeFirst.						exitLabel ~= nil ifTrue: [							newStatements addFirst:								(TtoCLabeledCommentNode new									setLabel: exitLabel comment: 'end case').						].						newStatements addAllFirst: meth statements.						newStatements addFirst:							(TtoCLabeledCommentNode new setComment: meth selector).						stmtNode setStatements: newStatements.					].				].			].		].	].	usedVars := (locals, args) asSet.	1 to: maxTemp do: [ :i |		v := ('t', i printString).		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].		locals addLast: v.	].	"make local versions of the given globals"	varsList do: [ :var |		(usedVars includes: var) ifFalse: [ locals addFirst: var asString ].	].</body><body package="HPSVM Primitive Plugins" selector="inlineCodeOrNilForStatement:in:">inlineCodeOrNilForStatement: aNode in: aCodeGen	"If the given statement node can be inlined, answer the statements that replace it. Otherwise, answer nil."	| stmts |	aNode isReturn ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			stmts := self inlineSend: aNode expression				directReturn: true exitVar: nil in: aCodeGen.			^stmts		].	].	aNode isAssignment ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			^self inlineSend: aNode expression				directReturn: false exitVar: aNode variable name in: aCodeGen		].	].	aNode isSend ifTrue: [		(self inlineableSend: aNode in: aCodeGen) ifTrue: [			^self inlineSend: aNode				directReturn: false exitVar: nil in: aCodeGen		].	].	^nil</body><body package="HPSVM Primitive Plugins" selector="inlineFunctionCall:in:">inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict |	sel := aSendNode selector.	meth := (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict := Dictionary new: 100.	meth args with: aSendNode args do: [ :argName :exprNode |		substitutionDict at: argName put: exprNode.		locals remove: argName].	meth parseTree bindVariablesIn: substitutionDict.	^ meth statements first expression</body><body package="HPSVM Primitive Plugins" selector="inlineSend:directReturn:exitVar:in:">inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."	| sel meth exitLabel labelUsed inlineStmts |	sel := aSendNode selector.	meth := (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	meth hasReturn ifTrue: [		directReturn ifTrue: [			"propagate the return type, if necessary"			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"			returnType := meth returnType.		] ifFalse: [			exitLabel := self unusedLabelForInliningInto: self.			labelUsed := meth exitVar: exitVar label: exitLabel.			labelUsed				ifTrue: [ labels add: exitLabel ]				ifFalse: [ exitLabel := nil ].		].		"propagate type info if necessary"		((exitVar ~= nil) and: [meth returnType ~= 'oopInt']) ifTrue: [			declarations at: exitVar put: meth returnType, ' ', exitVar.		].	].	inlineStmts := OrderedCollection new: 100.	inlineStmts add: (TtoCLabeledCommentNode new setComment: 'begin ', sel).	inlineStmts addAll:		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).	inlineStmts addAll: meth statements.  "method body"	(directReturn and: [meth endsWithReturn not]) ifTrue: [		inlineStmts add: (TtoCReturnNode new setExpression: (TtoCVariableNode new setName: 'nil')).	].	exitLabel ~= nil ifTrue: [		inlineStmts add:			(TtoCLabeledCommentNode new				setLabel: exitLabel comment: 'end ', meth selector).	].	^inlineStmts</body><body package="HPSVM Primitive Plugins" selector="inlineableFunctionCall:in:">inlineableFunctionCall: aNode in: aCodeGen	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."	| m |	aNode isSend ifFalse: [ ^false ].	aNode selector == selector ifTrue: [^false]. "recursion"	m := aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	^m notNil	and: [m isFunctional	and: [(aCodeGen mayInline: m selector)	and: [aNode args allSatisfy: [ :a | self isSubstitutableNode: a intoMethod: m in: aCodeGen]]]]</body><body package="HPSVM Primitive Plugins" selector="inlineableSend:in:">inlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	aNode selector == selector ifTrue: [^false].	m := aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	^m notNil and: [m isComplete and: [aCodeGen mayInline: m selector]]</body><body package="HPSVM Primitive Plugins" selector="isFunctional">isFunctional	"Answer true if the receiver is a functional method. That is, if it consists of a single return statement of an expression that contains no other returns."	(parseTree statements size = 1 and:	 [parseTree statements last isReturn]) ifFalse: [ ^false ].	parseTree statements last expression nodesDo: [ :n | n isReturn ifTrue: [ ^false ]].	^true</body><body package="HPSVM Primitive Plugins" selector="isMacroDefinition">isMacroDefinition	"Answer if our Smalltalk method represents a macro definition when translated to C."	^self class isMacroDefinition: self method</body><body package="HPSVM Primitive Plugins" selector="isSubstitutableNode:">isSubstitutableNode: aNode	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	aNode isConstant ifTrue: [ ^true ].	^aNode isVariable and:		[(locals includes: aNode name) or:		[args includes: aNode name]]</body><body package="HPSVM Primitive Plugins" selector="isSubstitutableNode:intoMethod:in:">isSubstitutableNode: aNode intoMethod: targetMeth in: aCodeGen	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted into methods with possible side effects (i.e., methods that may assign to global variables) because the inlined method might depend on having the value of the global variable captured when it is passed in as an argument."	| var |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var := aNode name.		((locals includes: var) or: [args includes: var]) ifTrue: [ ^ true ].		(#(self true false nil) includes: var) ifTrue: [ ^ true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^ true ].	].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^false ].		].		node isVariable ifTrue: [			var := node name.			((locals includes: var) or:			 [(args includes: var) or:			 [(#(self true false nil) includes: var) or:			 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^ false ].		].		(node isConstant or: [node isVariable or: [node isSend]]) ifFalse: [ ^false ].	].	^ true</body><body package="HPSVM Primitive Plugins" selector="macroDefinition">macroDefinition	(Pragma allInMethod: self method) do:		[:p| 		p message selector == #macroDefinition: ifTrue:			[^p argumentAt: 1]].	^nil</body><body package="HPSVM Primitive Plugins" selector="statementsListsForInlining">statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."	| stmtLists |	stmtLists := OrderedCollection new: 10.	parseTree nodesDo: [ :node | 		node isStmtList ifTrue: [ stmtLists add: node ].	].	parseTree nodesDo: [ :node | 		node isSend ifTrue: [			((node selector = #and:) or: [node selector = #or:]) ifTrue: [				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args last ifAbsent: [].			].			((node selector = #ifTrue:) or: [node selector = #ifFalse:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #ifTrue:ifFalse:) or: [node selector = #ifFalse:ifTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #whileFalse:) or: [node selector = #whileTrue:]) ifTrue: [				"Allow inlining if it is a [...] whileTrue/whileFalse.				This is identified by having more than one statement in the 				receiver block in which case the C code wouldn't work anyways"				node receiver statements size = 1					ifTrue:[stmtLists remove: node receiver ifAbsent: []].			].			(node selector = #to:do:) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].			].			(node selector = #to:do:) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: (node args at: 2) ifAbsent: [].			].		].		node isCaseStmt ifTrue: [			"don't inline cases"			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].		].	].	^stmtLists</body><body package="HPSVM Primitive Plugins" selector="tryToInlineMethodsIn:">tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements inlinedStmts sendsToInline |	didSomething := false.	sendsToInline := Dictionary new: 100.	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			sendsToInline at: n put: (self inlineFunctionCall: n in: aCodeGen).		].	].	sendsToInline isEmpty ifFalse: [		didSomething := true.		parseTree := parseTree replaceNodesIn: sendsToInline.	].	didSomething ifTrue: [		possibleSideEffectsCache := nil.		^didSomething	].	stmtLists := self statementsListsForInlining.	stmtLists do: [ :stmtList | 		newStatements := OrderedCollection new: 100.		stmtList statements do: [ :stmt |			inlinedStmts := self inlineCodeOrNilForStatement: stmt in: aCodeGen.			(inlinedStmts = nil) ifTrue: [				newStatements addLast: stmt.			] ifFalse: [				didSomething := true.				newStatements addAllLast: inlinedStmts.			].		].		stmtList setStatements: newStatements asArray.	].	didSomething ifTrue: [		possibleSideEffectsCache := nil.		^didSomething	].	complete ifFalse: [		self checkForCompleteness: stmtLists in: aCodeGen.		complete ifTrue: [ didSomething := true ].  "marking a method complete is progress"	].	^didSomething</body><body package="HPSVM Primitive Plugins" selector="unusedLabelForInliningInto:">unusedLabelForInliningInto: targetMethod	| usedLabels |	usedLabels := labels asSet.	usedLabels addAll: targetMethod labels.	^self unusedNamePrefixedBy: 'l' avoiding: usedLabels</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>primitive compilation</category><body package="HPSVM Primitive Plugins" selector="argConversionExprFor:stackIndex:">argConversionExprFor: varName stackIndex: stackIndex 	"Return the parse tree for an expression that fetches and converts the 	primitive argument at the given stack offset."	| exprList decl stmtList |	exprList := OrderedCollection new.	(declarations includesKey: varName)		ifTrue: 			[decl := declarations at: varName.			(decl includes: $*)				ifTrue: 					["array"					exprList add: varName , ' := ', self vmNameString, ' arrayValueOf: (', self vmNameString, ' stackValue: (' , stackIndex printString , '))'.					exprList add: varName , ' := ' , varName , ' - 1']				ifFalse: 					["must be a double"					(decl findString: 'double' startingAt: 1)						= 0 ifTrue: [self error: 'unsupported type declaration in a primitive method'].					exprList add: varName , ' := ', self vmNameString, ' stackFloatValue: ' , stackIndex printString]]		ifFalse: ["undeclared variables are taken to be integer"			exprList add: varName , ' := ', self vmNameString, ' stackIntegerValue: ' , stackIndex printString].	stmtList := OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList</body><body package="HPSVM Primitive Plugins" selector="checkSuccessExpr">checkSuccessExpr	"Return the parse tree for an expression that aborts the primitive if the successFlag is not true."	| expr |	expr := 'successFlag ifFalse: [^ nil ]'.	^ self statementsFor: expr varName: ''</body><body package="HPSVM Primitive Plugins" selector="covertToZeroBasedArrayReferences">covertToZeroBasedArrayReferences	"Replace the index expressions in at: and at:put: messages with (&lt;expr&gt; - 1), since C uses zero-based array indexing."	"Note: Up through release 1.31, generated primitives used the convention that array variables pointed to the first element. That meant that Smalltalk one-based index expressions had to have one subtracted to yield a zero-based index. Later, we decided to adjust the base address by -1 once in the primitive prolog rather on every array access. This resulted in a five percent performance increase for the bitmap compress/decompress primitives. This method is retained as documentation and in case we choose to revert the the previous scheme."	| oldIndexExpr newIndexExpr |	parseTree nodesDo: [ :n |		(n isSend and: [(n selector = #at:) or: [ n selector = #at:put: ]]) ifTrue: [			oldIndexExpr := n args first.			oldIndexExpr isConstant ifTrue: [				"index expression is a constant: decrement the constant now"				newIndexExpr := TtoCConstantNode new setValue: (n args first value - 1).			] ifFalse: [				"index expression is complex: build an expression to decrement result at runtime"				newIndexExpr := TtoCSendNode new					setSelector: #-					receiver: oldIndexExpr					arguments: (Array with: (TtoCConstantNode new setValue: 1)).			].			n args at: 1 put: newIndexExpr.		].	].</body><body package="HPSVM Primitive Plugins" selector="fetchRcvrExpr">fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr |	expr := 'rcvr := ', self vmNameString, ' stackValue: (', args size printString, ')'.	^ self statementsFor: expr varName: ''</body><body package="HPSVM Primitive Plugins" selector="fixUpReturns:postlog:">fixUpReturns: argCount postlog: postlog	"Replace each return statement in this method with (a) the given postlog, (b) code to pop the receiver and the given number of arguments, and (c) code to push the integer result and return."	| newStmts |	parseTree nodesDo: [:node |		node isStmtList ifTrue: [			newStmts := OrderedCollection new: 100.			node statements do: [:stmt |				stmt isReturn					ifTrue: [						(stmt expression isSend and:						 ['primitiveFail' = stmt expression selector])							ifTrue: [  "failure return"								newStmts addLast: stmt expression.								newStmts addLast: (TtoCReturnNode new									setExpression: (TtoCVariableNode new setName: 'null'))]							ifFalse: [  "normal return"								newStmts addAll: postlog.								newStmts addAll: (self popArgsExpr: argCount + 1).								newStmts addLast: (TtoCSendNode new									setSelector: #pushInteger:									receiver: (TtoCVariableNode new setName: self vmNameString)									arguments: (Array with: stmt expression)).								newStmts addLast: (TtoCReturnNode new									setExpression: (TtoCVariableNode new setName: 'null'))]]					ifFalse: [						newStmts addLast: stmt]].			node setStatements: newStmts asArray]].</body><body package="HPSVM Primitive Plugins" selector="instVarGetExprFor:offset:">instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| exprList decl stmtList |	exprList := OrderedCollection new.	(declarations includesKey: varName) ifTrue: [		decl := declarations at: varName.		(decl includes: $*) ifTrue: [  "array"			exprList add:				(varName, ' := ', self vmNameString, ' fetchArray: ', instIndex printString, ' ofObject: rcvr').			exprList add: (varName, ' := ', varName, ' - 1').		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add:				(varName, ' := ', self vmNameString, ' fetchFloat: ', instIndex printString, ' ofObject: rcvr').		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add:			(varName, ' := ', self vmNameString, ' fetchInteger: ', instIndex printString, ' ofObject: rcvr').	].	stmtList := OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList</body><body package="HPSVM Primitive Plugins" selector="instVarPutExprFor:offset:">instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr := '', self vmNameString, ' storeInteger: ', instIndex printString, ' ofObject: rcvr withValue: ', varName.	^ self statementsFor: expr varName: varName</body><body package="HPSVM Primitive Plugins" selector="popArgsExpr:">popArgsExpr: argCount	"Return the parse tree for an expression that pops the given number of arguments from the stack."	| expr |	expr := '', self vmNameString, ' pop: ', argCount printString.	^ self statementsFor: expr varName: ''</body><body package="HPSVM Primitive Plugins" selector="preparePrimitiveName">preparePrimitiveName	"Prepare the selector for this method in translation"	| aClass |	aClass := definingClass.	primitive = 117 		ifTrue:[selector := ((aClass includesSelector: selector)					ifTrue: [aClass compiledMethodAt: selector]					ifFalse: [aClass class compiledMethodAt: selector]) literals first at: 2.				export := true]		ifFalse:[selector := 'prim', aClass name, selector].</body><body package="HPSVM Primitive Plugins" selector="preparePrimitivePrologue">preparePrimitivePrologue	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn aClass |	aClass := definingClass.	prolog := OrderedCollection new.	postlog := OrderedCollection new.	instVarsUsed := self freeVariableReferences asSet.	varsAssignedTo := self variablesAssignedTo asSet.	instVarList := aClass allInstVarNames.	primArgCount := args size.	"add receiver fetch and arg conversions to prolog"	prolog addAll: self fetchRcvrExpr.	1 to: args size do: [:argIndex |		varName := args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add success check to postlog"	postlog addAll: self checkSuccessExpr.	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName := instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	prolog addAll: self checkSuccessExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args := args class new.	locals asSet size = locals size		ifFalse: [self error: 'local name conflicts with instance variable name'].	endsWithReturn := self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [			postlog addAll: (self popArgsExpr: primArgCount).			parseTree setStatements: prolog, parseTree statements, postlog].</body><body package="HPSVM Primitive Plugins" selector="replaceSizeMessages">replaceSizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive."	parseTree nodesDo:		[:n | | argExpr |		(n isSend and: [n selector = #size]) ifTrue:			[argExpr := TtoCSendNode new				setSelector: #+				receiver: n receiver				arguments: (Array with: (TtoCConstantNode new setValue: 1)).			n				setSelector: #sizeOfSTArrayFromCPrimitive:				receiver: (TtoCVariableNode new setName: self vmNameString)				arguments: (Array with: argExpr)]].</body><body package="HPSVM Primitive Plugins" selector="statementsFor:varName:">statementsFor: sourceText varName: varName	"Return the parse tree for the given expression. The result is the statements list of the method parsed from the given source text."	"Details: Various variables are declared as locals to avoid Undeclared warnings from the parser."	| s |	s := (String new: 256) writeStream.	s nextPutAll: 'temp'; cr; cr; tab.	self printTempsAndVar: varName on: s.	s nextPutAll: sourceText.	^ ((Compiler new parse: s contents in: Object notifying: nil) node			asTranslationMethodOfClass: self class) statements</body><body package="HPSVM Primitive Plugins" selector="vmNameString">vmNameString	"return the string to use as the vm name in code generated for this method"	^'self'</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="args">args	"The arguments of this method."	^args</body><body package="HPSVM Primitive Plugins" selector="comment:">comment: aComment	comment := aComment</body><body package="HPSVM Primitive Plugins" selector="declarations">declarations	"The type declaration dictionary of this method."	^declarations</body><body package="HPSVM Primitive Plugins" selector="definingClass">definingClass	^definingClass</body><body package="HPSVM Primitive Plugins" selector="definingClass:">definingClass: aClass	definingClass := aClass.</body><body package="HPSVM Primitive Plugins" selector="export">export	^ export</body><body package="HPSVM Primitive Plugins" selector="isComplete">isComplete	"A method is 'complete' if it does not contain any more inline-able calls."	^complete</body><body package="HPSVM Primitive Plugins" selector="isStatic">isStatic	^static ifNil:[false].</body><body package="HPSVM Primitive Plugins" selector="labels">labels	^labels</body><body package="HPSVM Primitive Plugins" selector="locals">locals	"The local variables of this method."	^locals</body><body package="HPSVM Primitive Plugins" selector="messages">messages	| selectors |	selectors := Set new: 32.	parseTree nodesDo:		[:stmt|		stmt isSend ifTrue: [selectors add: stmt selector]].	selectors addAll: self method messages.	^selectors</body><body package="HPSVM Primitive Plugins" selector="method">method	^definingClass compiledMethodAt: selector</body><body package="HPSVM Primitive Plugins" selector="numArgs">numArgs	^args size</body><body package="HPSVM Primitive Plugins" selector="parseTree">parseTree	"The parse tree of this method."	^parseTree</body><body package="HPSVM Primitive Plugins" selector="parseTree:">parseTree: aNode	"Set the parse tree of this method."	parseTree := aNode.</body><body package="HPSVM Primitive Plugins" selector="primitive">primitive	"The primitive number of this method; zero if not a primitive."	^ primitive</body><body package="HPSVM Primitive Plugins" selector="returnType">returnType	"The type of the values returned by this method. This string will be used in the C declaration of this function."	^returnType</body><body package="HPSVM Primitive Plugins" selector="selector">selector	"The Smalltalk selector of this method."	^selector</body><body package="HPSVM Primitive Plugins" selector="selector:">selector: newSelector	selector := newSelector.</body><body package="HPSVM Primitive Plugins" selector="statements">statements	parseTree isStmtList		ifFalse: [ self error: 'expected method parse tree to be a TStmtListNode' ].	(self visualWorks			ifTrue: [parseTree tryToRemoveArgs: args]			ifFalse: [parseTree args = nil or: [parseTree args isEmpty]])		ifFalse: [ self error: 'expected method parse tree to have no args' ].	^parseTree statements</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>transformations</category><body package="HPSVM Primitive Plugins" selector="bindClassVariablesIn:">bindClassVariablesIn: constantDictionary	"Class variables are used as constants. This method replaces all references to class variables in the body of this method with the corresponding constant looked up in the class pool dictionary of the source class. The source class class variables should be initialized before this method is called."	parseTree := parseTree bindVariablesIn: constantDictionary.</body><body package="HPSVM Primitive Plugins" selector="buildCaseStmt:">buildCaseStmt: aSendNode	"Build a case statement node for the given send of dispatchOn:in:."	"Note: the first argument is the variable to be dispatched on. The second argument is a constant node holding an array of unary selectors, which will be turned into sends to self."	((aSendNode args size &gt;= 2) and:	 [aSendNode args second isConstant and:	 [aSendNode args second value class = Array]]) ifFalse: [		self error: 'wrong node structure for a case statement'.	].	^TtoCCaseStmtNode new		setExpression: aSendNode args first		selectors: aSendNode args second value		arguments: (aSendNode args copyFrom: 3 to: aSendNode args size)</body><body package="HPSVM Primitive Plugins" selector="extractBuiltinDirective">extractBuiltinDirective	"Scan the top-level statements for a directive of the form:		self internal: &lt;boolean&gt;	 and remove the directive from the method body. Return the argument of the directive or false if there is no internal directive."	| result newStatements |	result := false.	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do: 		[:stmt |		(stmt isSend and: [stmt selector = #internal:]) 			ifTrue: [result := #(true #true 'true') includes: stmt args first nameOrValue]			ifFalse: [newStatements add: stmt]].	parseTree setStatements: newStatements asArray.	^result</body><body package="HPSVM Primitive Plugins" selector="extractExportDirective">extractExportDirective	"Scan the top-level statements for a directive of the form:		self export: &lt;boolean&gt;	 and remove the directive from the method body. Return the argument of the directive or false if there is no export directive."	| result newStatements |	result := false.	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do: 		[:stmt |		(stmt isSend and: [stmt selector = #export:]) 			ifTrue: [result := #(true #true 'true') includes: stmt args first nameOrValue]			ifFalse: [newStatements add: stmt]].	parseTree setStatements: newStatements asArray.	^result</body><body package="HPSVM Primitive Plugins" selector="extractStaticDirective">extractStaticDirective	"Scan the top-level statements for a directive of the form:		self static: &lt;boolean&gt;	 and remove the directive from the method body. Return the argument of the directive or true if there is no static directive."	| result newStatements |	result := true.	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do:		[:stmt | 		(stmt isSend and: [stmt selector = #static:]) 			ifTrue:  [result := (#(false #false 'false') includes: stmt args first nameOrValue) not]			ifFalse: [newStatements add: stmt]].	parseTree setStatements: newStatements asArray.	^result</body><body package="HPSVM Primitive Plugins" selector="isPrimitiveMethod">isPrimitiveMethod	^'primitive*' match: selector</body><body package="HPSVM Primitive Plugins" selector="prepareMethodIn:">prepareMethodIn: aCodeGen	"Record sends of builtin operators and replace sends of the special selector dispatchOn:in: with case statement nodes."	"Note: Only replaces top-level sends of dispatchOn:in:. Case statements must be top-level statements; they cannot appear in expressions."	| stmts stmt |	parseTree nodesDo: [ :node |		node isSend ifTrue: [			"record sends of builtin operators"			(aCodeGen builtin: node selector) ifTrue: [ node isBuiltinOperator: true ].		].		node isStmtList ifTrue: [			"replace dispatchOn:in: with case statement node"			stmts := node statements.			1 to: stmts size do: [ :i |				stmt := stmts at: i.				(stmt isSend and: [CaseStatements includes: stmt selector]) ifTrue: [					stmts at: i put: (self buildCaseStmt: stmt).				].			].		].	].</body><body package="HPSVM Primitive Plugins" selector="recordDeclarations">recordDeclarations	"Record C type declarations of the forms		self returnTypeC: 'float'.		self var: #foo declareC: 'float foo'		self var: #foo type:'float'.	 and remove the declarations from the method body."	| newStatements |	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do:		[:stmt | | isDeclaration varName varType |		isDeclaration := false.		stmt isSend ifTrue:			[stmt selector = #var:declareC: ifTrue:				[isDeclaration := true.				 declarations at: stmt args first value asString put: stmt args last value].			stmt selector = #var:type: ifTrue:				[isDeclaration := true.				 varName := stmt args first value asString.				 varType := stmt args last value.				 declarations at: varName put: varType , ' ' , varName].			stmt selector = #returnTypeC: ifTrue:				[isDeclaration := true.				 returnType := stmt args last value]].		isDeclaration ifFalse: [newStatements add: stmt]].	parseTree setStatements: newStatements asArray</body><body package="HPSVM Primitive Plugins" selector="removeAssertions">removeAssertions	parseTree removeAssertions</body><body package="HPSVM Primitive Plugins" selector="removeFinalSelfReturn">removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList lastStmt |	(stmtList := parseTree statements asOrderedCollection) isEmpty ifTrue: [^self].	lastStmt := stmtList last.	((lastStmt isReturn) and:	 [(lastStmt expression isVariable) and:	 ['self' = lastStmt expression name]]) ifTrue: [		stmtList removeLast.		parseTree setStatements: stmtList.	].</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>C code generation</category><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:generator:">emitCCodeOn: aStream generator: aCodeGen	"Emit C code for this method onto the given stream. All calls to inlined methods should already have been expanded."	builtinOnly ifTrue: [aStream cr; nextPutAll: '#ifdef BUILTIN_PLUGIN'].	self emitCCommentOn: aStream.	"place method comment before function"	self emitCHeaderOn: aStream generator: aCodeGen.	parseTree emitCCodeOn: aStream level: 1 generator: aCodeGen.	parseTree hasReturn ifFalse:		[self emitDefaultReturnOn: aStream generator: aCodeGen].	aStream nextPut: $}; cr.	builtinOnly ifTrue: [aStream nextPutAll: '#endif /* BUILTIN_PLUGIN */'; cr]</body><body package="HPSVM Primitive Plugins" selector="emitCCommentOn:">emitCCommentOn: aStream	"Emit the transferred Smalltalk comments as C comments."	comment ifNotNil: [		aStream cr;cr.		1 to: comment size do: [:index | 			aStream 				nextPutAll: '/*'; tab;				nextPutAll: (comment at: index);				nextPutAll: ' */';				cr]]</body><body package="HPSVM Primitive Plugins" selector="emitCFunctionDeclaration:generator:">emitCFunctionDeclaration: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	^self emitCFunctionDeclarationOrPrototype: #declaration on: aStream generator: aCodeGen</body><body package="HPSVM Primitive Plugins" selector="emitCFunctionPrototype:generator:">emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	builtinOnly ifTrue: [aStream nextPutAll: '#ifdef BUILTIN_PLUGIN'; cr].	self emitCFunctionDeclarationOrPrototype: #prototype on: aStream generator: aCodeGen.	aStream nextPut: $; ; cr.	builtinOnly ifTrue: [aStream nextPutAll: '#endif'; cr]</body><body package="HPSVM Primitive Plugins" selector="emitCHeaderOn:generator:">emitCHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr.	self emitCFunctionDeclaration: aStream generator: aCodeGen.	aStream cr; nextPut: ${.	locals do:		[ :var |		aStream			tab;			nextPutAll: (declarations at: var ifAbsent: ['oopInt ', var]);			nextPut: $; ;			cr].	aStream cr</body><body package="HPSVM Primitive Plugins" selector="emitDefaultReturnOn:generator:">emitDefaultReturnOn: aStream generator: aCodeGen 	returnType ~= 'void' ifTrue:		[aStream nextPutAll: '    return ('; nextPutAll: returnType; nextPutAll: ')0;'; cr]</body><body package="HPSVM Primitive Plugins" selector="emitProxyFunctionPrototype:generator:">emitProxyFunctionPrototype: aStream generator: aCodeGen	"Emit an indirect C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: '(*', (aCodeGen cFunctionNameFor: selector), ')('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg := args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'oopInt ', (args at: i).		].		i &lt; args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>printing</category><body package="HPSVM Primitive Plugins" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' (', selector, ')'.</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="emitCFunctionDeclarationOrPrototype:on:generator:">emitCFunctionDeclarationOrPrototype: typeSymbol on: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	export 		ifTrue:[aStream nextPutAll:'DLUP_EXPORT('; nextPutAll: returnType; nextPut:$)]		ifFalse:			[(aCodeGen isGeneratingPluginCode and:[self isStatic])  ifTrue:					[aStream nextPutAll:'static '].			aStream nextPutAll: returnType].	typeSymbol == #prototype		ifTrue: [aStream space]		ifFalse: [aStream cr].	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector); nextPut: $(.	args isEmpty		ifTrue: [typeSymbol == #prototype ifTrue: [aStream nextPutAll: 'void']]		ifFalse:			[args do:					[ :arg |					aStream nextPutAll: (declarations										at: arg										ifAbsent: ['oopInt ', arg])]				separatedBy: [aStream nextPut: $,; space]].	aStream nextPut: $)</body><body package="HPSVM Primitive Plugins" selector="printTempsAndVar:on:">printTempsAndVar: varName on: aStream 	"add the required temps and the varname to the stream"	aStream nextPutAll: '| rcvr stackPointer successFlag ' , varName , ' |';	 cr</body><body package="HPSVM Primitive Plugins" selector="uniqueLocalsFrom:">uniqueLocalsFrom: localList	| localSet theLocals |	localSet := Set new: localList size.	theLocals := OrderedCollection new: localList size.	localList do:		[:arg| | name |		(localSet includes: (name := arg name)) ifFalse:			[localSet add: name.			 theLocals addLast: name]].	^theLocals</body><body package="HPSVM Primitive Plugins" selector="visualWorks">visualWorks	^true</body></methods><methods><class-id>HPSVM.TtoCMethod</class-id> <category>initialization</category><body package="HPSVM Primitive Plugins" selector="setSelector:args:locals:block:primitive:">setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector := sel.	returnType := 'oopInt'. 	 "assume return type is ``object'' for now"	args := argList asOrderedCollection collect: [:arg | arg name].	locals := self uniqueLocalsFrom: localList.	declarations := Dictionary new.	primitive := aNumber.	parseTree := aBlockNode asTranslationToCNode.	labels := OrderedCollection new.	complete := false.  "set to true when all possible inlining has been done"	export := self extractExportDirective.	static := self extractStaticDirective.	builtinOnly := self extractBuiltinDirective.	self removeFinalSelfReturn.	self recordDeclarations.</body><body package="HPSVM Primitive Plugins" selector="setSelector:returnType:args:locals:declarations:primitive:parseTree:labels:complete:">setSelector: sel returnType: retType args: argList locals: localList declarations: decls primitive: primNumber parseTree: aNode labels: labelList complete: completeFlag	"Initialize this method using the given information. Used for copying."	selector := sel.	returnType := retType.	args := argList.	locals := localList.	declarations := decls.	primitive := primNumber.	parseTree := aNode.	labels := labelList.	complete := completeFlag.</body></methods><methods><class-id>HPSVM.TtoCMethod class</class-id> <category>class initialization</category><body package="HPSVM Primitive Plugins" selector="initialize">initialize	"HPSVM.TtoCMethod initialize"		CaseStatements := IdentitySet new: 10.	CaseStatements addAll: #(dispatchOn:in: dispatchOn:in:with: dispatchOn:in:with:with:).</body></methods><methods><class-id>HPSVM.TtoCMethod class</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="isMacroDefinition:">isMacroDefinition: aSmalltalkMethod	"Answer if our Smalltalk method represents a macro definition when translated to C."	^(Pragma allInMethod: aSmalltalkMethod) anySatisfy:		[:p| p message selector == #macroDefinition:]</body></methods><methods><class-id>HPSVM.TestTtoCMethod</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="method">method	^definingClass compiledMethodAt: (fullSelector isNil ifTrue: [selector] ifFalse: [fullSelector])</body><body package="HPSVM Primitive Plugins" selector="parmSpecs">parmSpecs	^parmSpecs</body><body package="HPSVM Primitive Plugins" selector="rcvrSpec">rcvrSpec	^rcvrSpec</body></methods><methods><class-id>HPSVM.TestTtoCMethod</class-id> <category>specifying primitives</category><body package="HPSVM Primitive Plugins" selector="extractPrimitiveDirectives">extractPrimitiveDirectives	"Save selector in fullSelector and args in fullArgs.  Scan top-level statements for a directive of the form:		self				primitive: 	&lt;string&gt;or		self			primitive:	&lt;string&gt;			parameters: &lt;list of class names&gt;or		self			primitive:	&lt;string&gt;			parameters: &lt;list of class names&gt;			receiver: &lt;class name&gt;or an assignment of that expression to a local, and manipulate the state and parse tree accordingly."	parseTree setStatements: (Array streamContents:		[:sStream |			parseTree statements do:				[:stmt |				 (self primitiveDirectiveWasHandled: stmt on: sStream)					ifFalse: [sStream nextPut: stmt]]]).	isPrimitive 		ifTrue:			[export := true.			 parseTree 				setStatements: self namedPrimitiveProlog, 								parseTree statements.			 self fixUpReturns.			 self replaceSizeMessages.			 ^true]		ifFalse: [self removeFinalSelfReturn].	^false</body><body package="HPSVM Primitive Plugins" selector="handlePrimitiveDirective:on:">handlePrimitiveDirective: aStmt on: sStream	isPrimitive := true.	locals addAll: args.	self visualWorks		ifTrue:			[fullArgs := args.			 args with: parmSpecs do:				[:argName :spec |					declarations						at: argName						put: (spec ccgDeclareCForVar: argName)].			 args := args collect: [:argName| self class argNameFor: argName].			 args do: [:argName|					declarations						at: argName						put: 'oop ', argName]]		ifFalse:			[fullArgs := args.			 args := OrderedCollection new.			 fullArgs with: parmSpecs do:				[:argName :spec |					declarations						at: argName						put: (spec ccgDeclareCForVar: argName)]].	aStmt isAssignment ifTrue:		[declarations			at: aStmt variable name			put: (rcvrSpec ccgDeclareCForVar: aStmt variable name).		 sStream nextPutAll: (self			statementsFor:				(rcvrSpec					ccg:	TestCodeGenerator new					prolog:  [:expr | aStmt variable name, ' := ', expr]					expr: 	(self visualWorks ifTrue: [self argNameFor: aStmt variable name] ifFalse: [aStmt variable name]))			varName: (self argNameFor: aStmt variable name))].	"This is much simpler in VisualWorks since return from failure happens at the point of failure.	 So we don't need any failure guards."	"((self visualWorks ifTrue: [args] ifFalse: [fullArgs]) isEmpty not or:[aStmt isAssignment]) ifTrue:[self generateFailureGuardOn: sStream]."	^true.</body><body package="HPSVM Primitive Plugins" selector="isPrimitiveDirectiveSend:">isPrimitiveDirectiveSend: stmt		stmt isSend ifTrue:		[stmt selector = #primitive: ifTrue:			[^self primitive: 	stmt args first value				   parameters:	(Array new: args size withAll: #Oop)				   receiver:		#Oop].		 stmt selector = #primitive:parameters: ifTrue:			[^self primitive: 	stmt args first value				   parameters: 	stmt args second value				   receiver:		#Oop].		 stmt selector = #primitive:parameters:receiver: ifTrue:			[^self primitive:		stmt args first value				   parameters:	stmt args second value				   receiver:		stmt args third value]].	^false.</body><body package="HPSVM Primitive Plugins" selector="namedPrimitiveProlog">namedPrimitiveProlog	| cg |	cg := TestCodeGenerator new.	^Array streamContents:		[:sStream |		1 to: args size do:			[:i |			 sStream nextPutAll: 				(self statementsFor: 						((parmSpecs at: i) 							ccg: 	cg							prolog:  [:expr | (fullArgs at: i), ' := ', expr]							expr: (args at: i))					varName: (args at: i))]]</body><body package="HPSVM Primitive Plugins" selector="primitive:parameters:receiver:">primitive: aString parameters: anArray receiver: aClassSymbol	fullSelector := selector.	selector := aString asSymbol.	anArray size = args size ifFalse: 		[^self error: selector, ': incorrect number of parameter specifications'].	parmSpecs := anArray collect:		[:each |		self class environment at: each ifAbsent: []].	parmSpecs do:		[:each |		each isBehavior ifFalse:			[^self error: selector, ': parameter spec must be a Behavior']].	rcvrSpec := self class environment at: aClassSymbol asSymbol ifAbsent: [].	rcvrSpec isBehavior ifFalse:		[^self error: selector, ': receiver spec must be a Behavior'].	^true</body><body package="HPSVM Primitive Plugins" selector="primitiveDirectiveWasHandled:on:">primitiveDirectiveWasHandled: stmt on: sStream	(self isPrimitiveDirectiveSend: stmt) ifTrue:		[^self handlePrimitiveDirective: stmt on: sStream].	(stmt isAssignment and: 		[self isPrimitiveDirectiveSend: stmt expression]) ifTrue:			[^self handlePrimitiveDirective: stmt on: sStream].	^false.</body><body package="HPSVM Primitive Plugins" selector="simulatePrologInContext:">simulatePrologInContext: aContext	|cg instructions |	cg := TestCodeGenerator new.	parmSpecs keysAndValuesDo: 		[:index :each |		 instructions := ((parmSpecs at: index)			ccg: cg 			prolog: (cg ccgTVarBlock: index) 			expr: '&lt;foo&gt;' 			index: args size - index).		 Compiler new 			evaluate: instructions			in: aContext 			to: aContext receiver			notifying: nil			ifFail: nil].	instructions := (rcvrSpec		ccg: cg 		prolog: [:expr | '^', expr]		expr: '&lt;foo&gt;' 		index: args size).	 ^Compiler new 		evaluate: instructions		in: aContext 		to: aContext receiver		notifying: nil		ifFail: nil</body></methods><methods><class-id>HPSVM.TestTtoCMethod</class-id> <category>transforming</category><body package="HPSVM Primitive Plugins" selector="extractSuppressFailureGuardDirective">extractSuppressFailureGuardDirective	"Scan the top-level statements for a pragma directive of the form:		self suppressFailureGuards: &lt;boolean&gt;	 and remove the directive from the method body. Answer the argument of the directive or false if there is no #supressFailureGuards: directive."	| result newStatements |	result := false.	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #suppressFailureGuards:]) ifTrue: [			result := stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result</body><body package="HPSVM Primitive Plugins" selector="fixUpReturnOneStmt:on:">fixUpReturnOneStmt: stmt on: sStream	"This is much simpler in VisualWorks since return from failure happens at the point of failure.	 So below we simply have to generate a null return."	stmt isReturn ifFalse: [^sStream nextPut: stmt].	(stmt expression isSend and: ['primitiveFail' = stmt expression selector]) ifTrue: 		["failure return"		 sStream nextPut: stmt expression.		 sStream nextPut: self nullReturnExpr.		 ^nil].	(stmt expression isVariable and: ['nil' = stmt expression name]) ifTrue: 		["^ nil -- this is never right unless automatically generated"		 sStream nextPut: stmt.		 ^nil].	sStream nextPut: self nullReturnExpr.	^nil</body><body package="HPSVM Primitive Plugins" selector="fixUpReturns">fixUpReturns	"Replace each return statement in this method with (a) the given postlog, (b) code to pop the receiver and the given number of arguments, and (c) code to push the integer result and return."	parseTree nodesDo: [:node |		node isStmtList ifTrue: [			node setStatements: (Array streamContents:				[:sStream |				 node statements do: 					[:stmt | self fixUpReturnOneStmt: stmt on: sStream]])]]</body><body package="HPSVM Primitive Plugins" selector="recordDeclarations">recordDeclarations	"Record C type declarations of the forms		self returnTypeC: 'float'.		self var: #foo declareC: 'float foo'		self var: #foo type:'float'.	 and remove the declarations from the method body."	| newStatements |	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do:		[:stmt | | isDeclaration varName varType theClass |		isDeclaration := false.		stmt isSend ifTrue:			[stmt selector = #var:declareC: ifTrue:				[isDeclaration := true.				 declarations at: stmt args first value asString put: stmt args last value].			stmt selector = #var:type: ifTrue:				[isDeclaration := true.				 varName := stmt args first value asString.				 varType := stmt args last value.				 declarations at: varName put: varType , ' ' , varName].			 stmt selector = #var:as: ifTrue:				[isDeclaration := true.				 theClass := self class environment 								at: stmt args last name asSymbol								ifAbsent: [^self error: 'declarator must be a Behavior'].				 theClass isBehavior ifFalse:					[^self error: 'declarator must be a Behavior'].				 declarations 					at: stmt args first value asString 					put: (theClass ccgDeclareCForVar: stmt args first value asString)].			stmt selector = #returnTypeC: ifTrue:				[isDeclaration := true.				 returnType := stmt args last value]].		isDeclaration ifFalse: [newStatements add: stmt]].	parseTree setStatements: newStatements asArray</body><body package="HPSVM Primitive Plugins" selector="replaceSizeMessages">replaceSizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive."	parseTree nodesDo:		[:n |		(n isSend and: [n selector = #size]) ifTrue:			[n				setSelector: #sizeOfSTArrayFromCPrimitive:				receiver: (TtoCVariableNode new setName: self vmNameString)				arguments: (Array with: n receiver)]].</body></methods><methods><class-id>HPSVM.TestTtoCMethod</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="assign:expression:">assign: variable expression: expression	^TtoCAssignmentNode new setVariable: variable expression: expression</body><body package="HPSVM Primitive Plugins" selector="checkSuccessExpr">checkSuccessExpr	"Return the parse tree for an expression that aborts the primitive if the successFlag is not true."	| expr |	expr := self vmNameString, ' failed ifTrue: [^nil]'.	^ self statementsFor: expr varName: ''</body><body package="HPSVM Primitive Plugins" selector="nullReturnExpr">nullReturnExpr	^ TtoCReturnNode new setExpression: (TtoCVariableNode new setName: 'null')</body><body package="HPSVM Primitive Plugins" selector="oopVariable:">oopVariable: aString	(locals includes: aString) ifFalse:		[locals add: aString.		 declarations at: aString put: 'oopInt ', aString].	^TtoCVariableNode new setName: aString</body><body package="HPSVM Primitive Plugins" selector="printTempsAndVar:on:">printTempsAndVar: varName on: aStream 	"add the required temps and the varname to the stream"	aStream nextPutAll: '| '.	(#('rcvr' 'stackPointer' 'successFlag' 'interpreterProxy' )		reject: [:each | locals includes: each]) do:			[:each | aStream nextPutAll: each;  space].	(locals reject: [:each | each first = $_]) do:		[:each | aStream nextPutAll: each; space].	"don't add varName twice. Probably a deeper reason for this, but WTH. TPR"	(locals includes: varName) ifFalse:[aStream nextPutAll: varName].	aStream nextPut: $|; cr</body></methods><methods><class-id>HPSVM.TestTtoCMethod</class-id> <category>initializing</category><body package="HPSVM Primitive Plugins" selector="setSelector:args:locals:block:primitive:">setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector := sel.	returnType := 'oopInt'. 	 "assume return type is ``object'' for now"	args := argList asOrderedCollection collect: [:arg | arg name].	locals := localList asOrderedCollection collect: [:arg | arg name].	declarations := Dictionary new.	primitive := aNumber.	parseTree := aBlockNode asTranslationToCNode.	labels := OrderedCollection new.	complete := false.  "set to true when all possible inlining has been done"	export := self extractExportDirective.	static := self extractStaticDirective.	builtinOnly := self extractBuiltinDirective.	isPrimitive := false.  "set to true only if a primtive directive is found."	suppressingFailureGuards := self extractSuppressFailureGuardDirective.	self recordDeclarations.	self extractPrimitiveDirectives.</body></methods><methods><class-id>HPSVM.TestTtoCMethod</class-id> <category>primitive compilation</category><body package="HPSVM Primitive Plugins" selector="vmNameString">vmNameString	"return the string to use as the vm name in code generated for this method"	^'interpreterProxy'</body></methods><methods><class-id>HPSVM.TestTtoCMethod class</class-id> <category>utilities</category><body package="HPSVM Primitive Plugins" selector="argNameFor:">argNameFor: aString	^'_', aString, 'ArgOop'</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationToCNode">asTranslationToCNode	^TtoCAssignmentNode new		setVariable: variable asTranslationToCNode		expression: value asTranslationToCNode;		comment: comment</body></methods><methods><class-id>HPSVM.TestCClass2</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="atAllPut">atAllPut	| i |	i := VectSize.	[i &gt; 0] whileTrue: [		vect at: i put: 5.		i := i - 1.	].	(vect at: 1) ~= 5 ifTrue: [ self error: 'AtAllPutBenchmark' ].</body><body package="HPSVM Primitive Plugins" selector="error:">error: s	"Print an error message and exit."	self print: 'Error in %s\n' f: s.	self exit: -1.</body><body package="HPSVM Primitive Plugins" selector="incrementAll">incrementAll	| oldVal i |	oldVal := vect at: 1.	i := VectSize.	[i &gt; 0] whileTrue: [		vect at: i put: ((vect at: i) + 1).		i := i - 1.	].	(vect at: 1) ~= (oldVal + 1) ifTrue: [ self error: 'IncrementAllBenchmark' ].</body><body package="HPSVM Primitive Plugins" selector="initialize">initialize	VectSize := 10000.	vect := Array new: VectSize.</body><body package="HPSVM Primitive Plugins" selector="main">main	| startTicks ticks |	self printf: 'atAllPut: '.	startTicks := self clock.	self atAllPut.	ticks := self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'incrementAll: '.	self incrementAll.	ticks := self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'nestedWhileLoop: '.	self nestedWhileLoop.	ticks := self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sieve: '.	self sieve.	ticks := self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumAll: '.	self sumAll.	ticks := self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumFromTo: '.	self sumFromTo.	ticks := self clock - startTicks.	self print: '%ld\n' f: ticks.</body><body package="HPSVM Primitive Plugins" selector="nestedWhileLoop">nestedWhileLoop	| sum i j |	sum := 0.	i := 1000.	[i &gt; 0] whileTrue: [		j := 100.		[j &gt; 0] whileTrue: [			sum := sum + 1.			j := j - 1.		].		i := i - 1.	].	sum ~= 100000 ifTrue: [ self error: 'NestedWhileBenchmark' ].</body><body package="HPSVM Primitive Plugins" selector="sieve">sieve	| flagsSize flags primeCount i k |	flagsSize := 8190.	flags := Array new: flagsSize.	i := flagsSize.	[i &gt; 0] whileTrue: [		flags at: i put: true.		i := i - 1.	].	primeCount := 0.	i := 2.	[i &lt;= flagsSize] whileTrue: [		(flags at: i) ifTrue: [			primeCount := primeCount + 1. "i is a prime"			k := i + i.			[k &lt;= flagsSize] whileTrue: [				flags at: k put: false. "k is not a prime; it is a multiple of i"				k := k + i.			].		].		i := i + 1.	].	primeCount ~= 1027 ifTrue: [ self error: 'SieveBenchmark' ].</body><body package="HPSVM Primitive Plugins" selector="sumAll">sumAll	| elementVal sum i |	elementVal := vect at: 1.	sum := 0.	i := VectSize.	[i &gt; 0] whileTrue: [		sum := sum + (vect at: i).		i := i - 1.	].	sum ~= (VectSize * elementVal) ifTrue: [ self error: 'SumAllBenchmark' ].</body><body package="HPSVM Primitive Plugins" selector="sumFromTo">sumFromTo	| sum i j |	i := 10.	[i &gt; 0] whileTrue: [		sum := 0.		j := 10000.		[j &gt; 0] whileTrue: [			sum := sum + j.			j := j - 1.		].		i := i - 1.	].	sum ~= 50005000 ifTrue: [ self error: 'SumFromToBenchmark' ].</body></methods><methods><class-id>HPSVM.TestCClass2 class</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="test">test	"TestCClass2 test"	"(CCodeGenerator new initialize addClass: TestCClass2) codeString"	| bm |	bm := self new initialize.	Transcript show: 'atAllPut: '.	Transcript show: (Time millisecondsToRun: [bm atAllPut]) printString; cr.	Transcript show: 'incrementAll: '.	Transcript show: (Time millisecondsToRun: [bm incrementAll]) printString; cr.	Transcript show: 'nestedWhileLoop: '.	Transcript show: (Time millisecondsToRun: [bm nestedWhileLoop]) printString; cr.	Transcript show: 'sieve: '.	Transcript show: (Time millisecondsToRun: [bm sieve]) printString; cr.	Transcript show: 'sumAll: '.	Transcript show: (Time millisecondsToRun: [bm sumAll]) printString; cr.	Transcript show: 'sumFromTo: '.	Transcript show: (Time millisecondsToRun: [bm sumFromTo]) printString; cr.</body></methods><methods><class-id>HPSVM.TtoCGoToNode</class-id> <category>as yet unclassified</category><body package="HPSVM Primitive Plugins" selector="copyTree">copyTree	^self class new setLabel: label</body><body package="HPSVM Primitive Plugins" selector="emitCCodeOn:level:generator:">emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.</body><body package="HPSVM Primitive Plugins" selector="isGoTo">isGoTo	^true</body><body package="HPSVM Primitive Plugins" selector="label">label	^label</body><body package="HPSVM Primitive Plugins" selector="printOn:level:">printOn: aStream level: level	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.</body><body package="HPSVM Primitive Plugins" selector="setLabel:">setLabel: aString	label := aString.</body></methods><methods><class-id>Core.Integer</class-id> <category>translation support</category><body package="HPSVM Primitive Plugins" selector="bitInvert32">bitInvert32	"Answer the 32-bit complement of the receiver."	^self bitXor: 16rFFFFFFFF</body></methods><methods><class-id>Core.String class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg 		ccgLoad: aBlock 		exprAsCharPtr: aString		andThen: (cg ccgValBlock: 'isBytes' expr: aString)</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString</body></methods><methods><class-id>Kernel.BlockAnalysisUnsharedVariable</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="isAnonymousVariable">isAnonymousVariable	^true</body></methods><methods><class-id>Core.Object class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToOopFrom:on:">ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToValueFrom:on:">ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock expr: aString asKindOf: self</body><body package="HPSVM Primitive Plugins" selector="ccgCanConvertFrom:">ccgCanConvertFrom: anObject	^anObject isKindOf: self</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'int ', aSymbolOrString</body></methods><methods><class-id>Core.Object</class-id> <category>translation support</category><body package="HPSVM Primitive Plugins" selector="asIf:var:">asIf: aClass var: aString	|index|	index := aClass allInstVarNames 		indexOf: aString		ifAbsent: [self error: 'must use instVar name'].	^self instVarAt: index</body><body package="HPSVM Primitive Plugins" selector="asIf:var:asValue:">asIf: aClass var: aString asValue: someClass	^(self asIf: aClass var: aString) asValue: someClass</body><body package="HPSVM Primitive Plugins" selector="asIf:var:put:">asIf: aClass var: aString put: aValue	|index|	index := aClass allInstVarNames 		indexOf: aString		ifAbsent: [self error: 'must use instVar name'].	^self instVarAt: index put: aValue</body><body package="HPSVM Primitive Plugins" selector="asOop:">asOop: aClass	(self class isVariable and: [self class instSize &gt; 0])		ifTrue: [self error: 'cannot auto-coerce indexable objects with named instance variables'].	(aClass ccgCanConvertFrom: self)		ifFalse: [self error: 'incompatible object for this coercion'].	^self</body><body package="HPSVM Primitive Plugins" selector="asSmallIntegerObj">asSmallIntegerObj	^self</body><body package="HPSVM Primitive Plugins" selector="asValue:">asValue: aClass	^self</body><body package="HPSVM Primitive Plugins" selector="cCode:">cCode: codeString	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="cCode:inSmalltalk:">cCode: codeString inSmalltalk: aBlock	"Support for Smalltalk-to-C translation. The given string is output literally when generating C code. If this code is being simulated in Smalltalk, answer the result of evaluating the given block."	^ aBlock value</body><body package="HPSVM Primitive Plugins" selector="cCoerce:to:">cCoerce: value to: cType	"Type coercion for translation only; just return the value when running in Smalltalk."	^ value</body><body package="HPSVM Primitive Plugins" selector="debugCode:">debugCode: aBlock 	"Sending this message tells the code generator that there is debug code in 	aBlock. Debug code will be be generated only, if the correponding flag 	has been set by TestCodeGenerator&gt;&gt;generateDebugCode:.	In ST simulation just perform the debug code."	aBlock value</body><body package="HPSVM Primitive Plugins" selector="export:">export: aBoolean	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="inline:">inline: inlineFlag	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="primitive:parameters:receiver:">primitive: primID parameters: parmSpecs receiver: rcvrSpec	| tMethod |	tMethod := TestTMethod new 		fromContext: thisContext sender 		primitive: primID 		parameters: parmSpecs 		receiver: rcvrSpec.	^tMethod simulatePrologInContext: thisContext sender</body><body package="HPSVM Primitive Plugins" selector="remapOop:in:">remapOop: oopOrList in: aBlock	"For translation only; noop when running in Smalltalk."	^aBlock value</body><body package="HPSVM Primitive Plugins" selector="returnTypeC:">returnTypeC: typeString	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="sharedCodeNamed:inCase:">sharedCodeNamed: label inCase: caseNumber	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="stAt:">stAt: index	^self at: index</body><body package="HPSVM Primitive Plugins" selector="stAt:put:">stAt: index put: value	^self at: index put: value</body><body package="HPSVM Primitive Plugins" selector="static:">static: aBoolean	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="stSize">stSize	^self size</body><body package="HPSVM Primitive Plugins" selector="suppressFailureGuards:">suppressFailureGuards: failureGuardFlag	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="var:declareC:">var: varSymbol declareC: declString	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="var:type:">var: varSymbol type: typeString	"For translation only; noop when running in Smalltalk."</body><body package="HPSVM Primitive Plugins" selector="var:type:array:">var: varSymbol type: typeString array: array	"For translation only; noop when running in Smalltalk."</body></methods><methods><class-id>Core.WordArray class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg 		ccgLoad: aBlock 		exprAsUnsignedPtr: aString		andThen: (cg ccgValBlock: 'isWords' expr: aString)</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'unsigned *', aSymbolOrString</body></methods><methods><class-id>Core.Character class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock exprAsCharacterValue: aString</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'wchar_t ', aSymbolOrString</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock exprAsCharValue: aString</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString</body></methods><methods><class-id>Core.SmallInteger class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToOopFrom:on:">ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToSmallIntegerObjectFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToValueFrom:on:">ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg generateCoerceToSmallIntegerValueFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock exprAsIntegerValue: aString</body><body package="HPSVM Primitive Plugins" selector="ccgCanConvertFrom:">ccgCanConvertFrom: anObject	^anObject class == self</body></methods><methods><class-id>Kernel.MethodNode</class-id> <category>C translation</category><body package="HPSVM Primitive Plugins" selector="asTranslationMethodOfClass:">asTranslationMethodOfClass: aClass	^(aClass new)		setSelector: selector			args: block arguments			locals: (block compilerHints temps					select: [:ea | ea isAnonymousVariable not]					thenCollect: [:ea | ea node])			block: block			primitive: primitive;		comment: comment</body></methods><methods><class-id>OS.Filename</class-id> <category>Squeak compatibility</category><body package="HPSVM Primitive Plugins" selector="assureExistence">assureExistence	self exists ifFalse:		[self directory assureExistence.		 self makeDirectory]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="HPSVM Primitive Plugins" selector="second">second	^self at: 2</body><body package="HPSVM Primitive Plugins" selector="third">third	^self at: 3</body></methods><methods><class-id>Core.ArrayedCollection class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToOopFrom:on:">ccg: cg generateCoerceToOopFrom: aNode on: aStream	self instSize &gt; 0 ifTrue: 		[self error: 'cannot auto-coerce arrays with named instance variables'].	cg generateCoerceToObjectFromPtr: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToValueFrom:on:">ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg 		generateCoerceToPtr: (self ccgDeclareCForVar: '')		fromObject: aNode on: aStream</body></methods><methods><class-id>Core.IntegerArray class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg 		ccgLoad: aBlock 		exprAsIntPtr: aString		andThen: (cg ccgValBlock: 'isWords' expr: aString)</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'int *', aSymbolOrString</body></methods><methods><class-id>Core.Boolean class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToOopFrom:on:">ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToBooleanObjectFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToValueFrom:on:">ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg generateCoerceToBooleanValueFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock exprAsBooleanValue: aString</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>Squeak compatibility</category><body package="HPSVM Primitive Plugins" selector="fixTemps">fixTemps	"Thius is for Squeak compatibility for non-reentrant blocks.  Nothing to do for block closures."	^self</body></methods><methods><class-id>Kernel.BlockAnalysisVariable</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="isAnonymousVariable">isAnonymousVariable	^false</body></methods><methods><class-id>Core.Float class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToOopFrom:on:">ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToFloatObjectFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:generateCoerceToValueFrom:on:">ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg generateCoerceToFloatValueFrom: aNode on: aStream</body><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg ccgLoad: aBlock exprAsFloatValue: aString</body><body package="HPSVM Primitive Plugins" selector="ccgCanConvertFrom:">ccgCanConvertFrom: anObject	^anObject class == self</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'double ', aSymbolOrString</body></methods><methods><class-id>Core.Array class</class-id> <category>plugin generation</category><body package="HPSVM Primitive Plugins" selector="ccg:prolog:expr:">ccg: cg prolog: aBlock expr: aString	^cg 		ccgLoad: aBlock 		exprAsIntPtr: aString		andThen: (cg ccgValBlock: 'isIndexable' expr: aString)</body><body package="HPSVM Primitive Plugins" selector="ccgDeclareCForVar:">ccgDeclareCForVar: aSymbolOrString	^'int *', aSymbolOrString</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>converting</category><body package="HPSVM Primitive Plugins" selector="abs">abs	"Hack for BitBltSimulation"	&lt;macroDefinition: '#define abs(v) ((v) &gt;= 0 ? (v) : 0 - (v))'&gt;	^self abs</body><body package="HPSVM Primitive Plugins" selector="booleanValueOf:">booleanValueOf: obj	&lt;macroDefinition: '#define booleanValueOf(o) ((oop)(o) == sysOop(trueOopX) \														? 1 \														: ((oop)(o) == sysOop(falseOopX) \															? 0 \															: primitiveFail()))'&gt;	obj == true ifTrue:[^true].	obj == false ifTrue:[^false].	self primitiveFail.	^nil</body><body package="HPSVM Primitive Plugins" selector="characterValueOf:">characterValueOf: anOop	&lt;macroDefinition: '#define characterValueOf(o) (oopIsChar(o) ? oopCharVal(o) : primitiveFail())'&gt;	anOop class == Character ifFalse:[self error:'Not a Character'].	^anOop</body><body package="HPSVM Primitive Plugins" selector="firstFieldAsDouble:">firstFieldAsDouble: anObj	&lt;macroDefinition: '#define firstFieldAsDouble(o) objDataField((oop)(o),double,0)'&gt;	^anObj</body><body package="HPSVM Primitive Plugins" selector="firstFieldAsFloat:">firstFieldAsFloat: anObj	&lt;macroDefinition: '#define firstFieldAsFloat(o) objDataField((oop)(o),float,0)'&gt;	^anObj</body><body package="HPSVM Primitive Plugins" selector="integerObjectOf:">integerObjectOf: value	&lt;macroDefinition: '#define integerObjectOf(v) (isIntegerValue(v) ? (oopInt)asSmallInt(v) : primitiveFail())'&gt;	(self isIntegerValue: value) ifFalse:[self error: 'Not a SmallInteger object'].	^value</body><body package="HPSVM Primitive Plugins" selector="integerValueOf:">integerValueOf: anOop	&lt;macroDefinition: '#define integerValueOf(o) (oopIsInt(o) ? oopIntVal(o) : primitiveFail())'&gt;	anOop class == SmallInteger ifFalse:[self error:'Not a SmallInteger'].	^anOop</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>object access</category><body package="HPSVM Primitive Plugins" selector="byteSizeOf:">byteSizeOf: oop	"Return the size of the receiver in bytes"	&lt;macroDefinition: '#define byteSizeOf(o) objByteDataSize((oop)(o))'&gt;	^oop class isBits		ifTrue:[oop basicSize]		ifFalse:[(self slotSizeOf: oop) * bytesPerOOP]</body><body package="HPSVM Primitive Plugins" selector="fetchClassOf:">fetchClassOf: oop	&lt;macroDefinition: '#define fetchClassOf(o) ((oopInt)oopClass((oop)(o)))'&gt;	^oop class</body><body package="HPSVM Primitive Plugins" selector="fetchPointer:ofObject:">fetchPointer: index ofObject: anOop	&lt;macroDefinition: '#define fetchPointerofObject(i,o) objDataField((oop)(o),oopInt,i)'&gt;	^anOop instVarAt: index+1</body><body package="HPSVM Primitive Plugins" selector="fetchWord:ofObject:">fetchWord: fieldIndex ofObject: obj	&lt;macroDefinition: '#define fetchWordofObject(fi,obj) objDataField((oop)(obj), long, (fi))'&gt;	^obj instVarAt: fieldIndex+1</body><body package="HPSVM Primitive Plugins" selector="firstFixedField:">firstFixedField: oop	&lt;macroDefinition: '#define firstFixedField(o) objDataPtr((oop)(o), void)'&gt;	self returnTypeC:'void *'.	^CObjectAccessor on: oop</body><body package="HPSVM Primitive Plugins" selector="firstIndexableField:">firstIndexableField: anOop	&lt;macroDefinition: '#define firstIndexableField(o) ((void *)objVarDataPtr((oop)(o)))'&gt;	^CArrayAccessor on: anOop</body><body package="HPSVM Primitive Plugins" selector="slotSizeOf:">slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	&lt;macroDefinition:'#define slotSizeOf(o) (oopIsImm((oop)(o)) \	? 0 \	: (objHasPtrs((oop)(o)) \		? bytesToOops(objDataSize((oop)(o))) \		: objDataSize((oop)(o))))'&gt;	^(oop basicSize) + (oop class instSize)</body><body package="HPSVM Primitive Plugins" selector="stSizeOf:">stSizeOf: obj	"Return the number of indexable fields in the receiver"	&lt;macroDefinition: '#define stSizeOf(o) (objHasPtrs((oop)(o)) \												? objVarOopSize((oop)(o)) \												: objDataSize((oop)(o)))'&gt;	self mustNotBeImmediate: obj.	^obj basicSize</body><body package="HPSVM Primitive Plugins" selector="storeInteger:ofObject:withValue:">storeInteger: index ofObject: oop withValue: integer	&lt;macroDefinition: '#define storeIntegerofObjectwithValue(i,o,v) do { oop intObj; \	if (nonOop == (intObj = cSignedToOop(v)))\		primitiveFail();\	else \		storeOop((oop)(o), i, intObj); \} while(0)'&gt;	^(self isIntegerValue: integer) 		ifTrue:[self storePointer: index ofObject: oop withValue: integer]		ifFalse:[self primitiveFail]</body><body package="HPSVM Primitive Plugins" selector="storePointer:ofObject:withValue:">storePointer: index ofObject: oop withValue: valuePointer	&lt;macroDefinition: '#define storePointerofObjectwithValue(i,o,v) storeOop((oop)(o), i, (oop)(v))'&gt;	^oop instVarAt: index+1 put: valuePointer</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>testing</category><body package="HPSVM Primitive Plugins" selector="assert:">assert: expression	&lt;macroDefinition: '' "hps.h provides the definition of assert"&gt;	expression ifFalse: [self halt]</body><body package="HPSVM Primitive Plugins" selector="dassert:">dassert: expression	&lt;macroDefinition: '' "hps.h provides the definition of dassert"&gt;	expression ifFalse: [self halt]</body><body package="HPSVM Primitive Plugins" selector="eassert:">eassert: expression	&lt;macroDefinition: '' "hps.h provides the definition of eassert"&gt;	expression ifFalse: [self halt]</body><body package="HPSVM Primitive Plugins" selector="isBytes:">isBytes: obj	&lt;macroDefinition: '#define isBytes(o) (!objHasPtrs((oop)(o)))'&gt;	self mustNotBeImmediate: obj.	^obj class isBits</body><body package="HPSVM Primitive Plugins" selector="isImmediateObject:">isImmediateObject: objectPointer	&lt;macroDefinition: '#define isImmediateObject(o) oopIsImm(o)'&gt;	^objectPointer class hasImmediateInstances</body><body package="HPSVM Primitive Plugins" selector="isImmutableObject:">isImmutableObject: objectPointer	&lt;macroDefinition: '#define isImmutableObject(o) (oopIsImm(o) || objIsImmutable((oop)(o)))'&gt;	^objectPointer isImmutable</body><body package="HPSVM Primitive Plugins" selector="isIndexable:">isIndexable: obj	"Alas in VisualWorks we cannot easily distinguish between byte-indexable and word-indexable objects."	&lt;macroDefinition: '#define isIndexable(o) objIsIndexable((oop)(o))'&gt;	self mustNotBeImmediate: obj.	^obj class isVariable</body><body package="HPSVM Primitive Plugins" selector="isIntegerObject:">isIntegerObject: objectPointer	&lt;macroDefinition: '#define isIntegerObject(o) oopIsInt(o)'&gt;	^objectPointer class == SmallInteger</body><body package="HPSVM Primitive Plugins" selector="isIntegerValue:">isIntegerValue: intValue	&lt;macroDefinition: '#define isIntegerValue(v) ((v) &lt;= (oopUInt)maxSmallInt &amp;&amp; (v) &gt;= minSmallInt)'&gt;	^intValue class == SmallInteger</body><body package="HPSVM Primitive Plugins" selector="isPointers:">isPointers: obj	&lt;macroDefinition: '#define isPointers(o) objHasPtrs((oop)(o))'&gt;	self mustNotBeImmediate: obj.	^obj class isPointers</body><body package="HPSVM Primitive Plugins" selector="isWeak:">isWeak: obj	&lt;macroDefinition: '#define isWeak(o) (objIsGCSpecial((oop)(o)) &amp;&amp; !objIsEphemeronNotWeak((oop)(o)))'&gt;	self mustNotBeImmediate: obj.	^obj class isWeak</body><body package="HPSVM Primitive Plugins" selector="isWords:">isWords: obj	"Alas in VisualWorks we cannot easily distinguish between byte-indexable and word-indexable objects."	&lt;macroDefinition: '#define isWords(o) (!objHasPtrs((oop)(o)))'&gt;	self mustNotBeImmediate: obj.	^obj class isPointers not</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="byteAt:">byteAt: accessor	&lt;macroDefinition: '#define byteAt(i) (*((unsigned char *) (i)))'&gt;	^accessor byteAt: 0</body><body package="HPSVM Primitive Plugins" selector="byteAt:put:">byteAt: accessor put: value	&lt;macroDefinition: '#define byteAtput(i, val) (*((unsigned char *) (i)) = val)'&gt;	^accessor byteAt: 0 put: value</body><body package="HPSVM Primitive Plugins" selector="longAt:">longAt: accessor	&lt;macroDefinition: '#define longAt(i) (oopInt)(*((q32 *) (i)))'&gt;	^accessor longAt: 0</body><body package="HPSVM Primitive Plugins" selector="longAt:put:">longAt: accessor put: value	&lt;macroDefinition: '#define longAtput(i, val) (*((q32 *) (i)) = (q32)(val))'&gt;	^accessor longAt: 0 put: value</body><body package="HPSVM Primitive Plugins" selector="notYetImplementedError">notYetImplementedError	&lt;macroDefinition: '#define notYetImplementedError() primitiveFail()'&gt;	^self error: 'InterpreterProxy function not yet implemented!'</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>other</category><body package="HPSVM Primitive Plugins" selector="failed">failed	&lt;macroDefinition: '#define failed() FALSE'&gt;	^successFlag not</body><body package="HPSVM Primitive Plugins" selector="popRemappableOop:">popRemappableOop: oop 	"Pop and return the possibly remapped object from the remap buffer.	 N.B. Provided only for Squeak compatibility.  See pushRemappableOop:"	&lt;macroDefinition: '#define popRemappableOop(o) (remapBufferCount &lt;= 0 \										? (remapBufferCount = 0, primitiveFail() ) \										: remapBuffer[--remapBufferCount])'&gt;	^remapBuffer removeLast</body><body package="HPSVM Primitive Plugins" selector="primitiveFail">primitiveFail	&lt;macroDefinition: '#define primitiveFail() UPFailPrimitiveAtLine(__LINE__)'&gt;	(self confirm:'A primitive is failing -- Stop simulation?') ifTrue:[self halt].	successFlag := false.</body><body package="HPSVM Primitive Plugins" selector="pushRemappableOop:">pushRemappableOop: oop 	"Record the given object in a the remap buffer. Objects in this	 buffer are remapped when a compaction occurs. This facility	 is used by the Squeak interpreter to ensure that objects in	 temporary variables are properly remapped.	 N.B. Provided only for Squeak compatibility.  VisualWorks does	 not garbage collect during a primitive so there is no need to	 record newly-created oops during a primitive."	&lt;macroDefinition:'#define RemapBufferSize 25static int remapBufferCount = -1;static oopInt remapBuffer[RemapBufferSize];#define pushRemappableOop(o) do { \	if (++remapBufferCount &gt;= RemapBufferSize) { \		remapBufferCount = 0; \		primitiveFail(); \	} \	remapBuffer[remapBufferCount] = (o); \} while (0)'&gt;	remapBuffer isNil		ifTrue: [remapBuffer := OrderedCollection new]		ifFalse: [remapBuffer size &gt;= 25 ifTrue: [self primitiveFail]].	remapBuffer addLast: oop</body><body package="HPSVM Primitive Plugins" selector="showDisplayBits:Left:Top:Right:Bottom:">showDisplayBits: aForm Left: l Top: t Right: r Bottom: b	&lt;macroDefinition: '#define showDisplayBitsLeftTopRightBottom(a,b,c,d,e) 0'&gt;	aForm == Display ifTrue:		[Display forceToScreen: (Rectangle left: l right: r top: t bottom: b)].</body><body package="HPSVM Primitive Plugins" selector="success:">success: aBoolean	&lt;macroDefinition: '#define success(aBool) ((aBool) || primitiveFail())'&gt;	successFlag ifFalse: [^self].	(successFlag := aBoolean) ifFalse:		[self primitiveFail].</body><body package="HPSVM Primitive Plugins" selector="superclassOf:">superclassOf: obj	&lt;macroDefinition: '#define superclassOf(obj) ((oopInt)(objDataPtr((oop)(obj),class)-&gt;superclass))'&gt;	self mustNotBeImmediate: obj.	^obj superclass</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>instance creation</category><body package="HPSVM Primitive Plugins" selector="clone:">clone: oop	&lt;macroDefinition: 'static oop __clone;#define clone(o) (oopIsImm(o) \						? (o) \						: ((__clone = createShallowCopyOf((oop)(o))) == nonOop \							? primitiveFail() \							: (oopInt)__clone))'&gt;	^oop clone</body><body package="HPSVM Primitive Plugins" selector="instantiateClass:indexableSize:">instantiateClass: classPointer indexableSize: size	&lt;macroDefinition: 'static oop __newObj;#define instantiateClassindexableSize(classPointer, size) ((__newObj = ((size) == 0 \						? allocFSObj((oop)(classPointer)) \						: allocVSObj((oop)(classPointer),(size)))) == nonOop \							? primitiveFail() \							: (oopInt)__newObj)'&gt;	^size = 0 		ifTrue:[classPointer basicNew]		ifFalse:[classPointer basicNew: size]</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>special classes</category><body package="HPSVM Primitive Plugins" selector="classArray">classArray	&lt;macroDefinition: '#define classArray() ((oopInt)sysOop(arrayClassX))'&gt;	^Array</body><body package="HPSVM Primitive Plugins" selector="classByteArray">classByteArray	&lt;macroDefinition: '#define classByteArray() ((oopInt)sysOop(byteArrayClassX))'&gt;	^ByteArray</body><body package="HPSVM Primitive Plugins" selector="classByteString">classByteString	&lt;macroDefinition: '#define classByteString() ((oopInt)sysOop(byteStringClassX))'&gt;	^ByteString</body><body package="HPSVM Primitive Plugins" selector="classCharacter">classCharacter	&lt;macroDefinition: '#define classCharacter() ((oopInt)sysOop(characterClassX))'&gt;	^Character</body><body package="HPSVM Primitive Plugins" selector="classDouble">classDouble	&lt;macroDefinition: '#define classDouble() ((oopInt)sysOop(doubleClassX))'&gt;	^Double</body><body package="HPSVM Primitive Plugins" selector="classFloat">classFloat	&lt;macroDefinition: '#define classFloat() ((oopInt)sysOop(floatClassX))'&gt;	^Float</body><body package="HPSVM Primitive Plugins" selector="classLargeNegativeInteger">classLargeNegativeInteger	&lt;macroDefinition: '#define classLargeNegativeInteger() ((oopInt)sysOop(largeNegativeIntegerClassX))'&gt;	^LargeNegativeInteger</body><body package="HPSVM Primitive Plugins" selector="classLargePositiveInteger">classLargePositiveInteger	&lt;macroDefinition: '#define classLargePositiveInteger() ((oopInt)sysOop(largePositiveIntegerClassX))'&gt;	^LargePositiveInteger</body><body package="HPSVM Primitive Plugins" selector="classPoint">classPoint	&lt;macroDefinition: '#define classPoint() ((oopInt)sysOop(pointClassX))'&gt;	^Point</body><body package="HPSVM Primitive Plugins" selector="classSemaphore">classSemaphore	&lt;macroDefinition: '#define classSemaphore() ((oopInt)sysOop(semaphoreClassX))'&gt;	^Semaphore</body><body package="HPSVM Primitive Plugins" selector="classSmallInteger">classSmallInteger	&lt;macroDefinition: '#define classSmallInteger() ((oopInt)sysOop(smallIntegerClassX))'&gt;	^SmallInteger</body><body package="HPSVM Primitive Plugins" selector="classTwoByteString">classTwoByteString	&lt;macroDefinition: '#define classTwoByteString() ((oopInt)sysOop(twoByteStringClassX))'&gt;	^TwoByteString</body></methods><methods><class-id>HPSVM.InterpreterProxy</class-id> <category>special objects</category><body package="HPSVM Primitive Plugins" selector="falseObject">falseObject	&lt;macroDefinition: '#define falseObject() ((oopInt)sysOop(falseOopX))'&gt;	^false</body><body package="HPSVM Primitive Plugins" selector="nilObject">nilObject	&lt;macroDefinition: '#define nilObject() ((oopInt)sysOop(nilOopX))'&gt;	^nil</body><body package="HPSVM Primitive Plugins" selector="trueObject">trueObject	&lt;macroDefinition: '#define trueObject() ((oopInt)sysOop(trueOopX))'&gt;	^true</body><body package="HPSVM Primitive Plugins" selector="zeroObject">zeroObject	&lt;macroDefinition: '#define zeroObject() ((oopInt)asSmallInt(0))'&gt;	^0</body></methods><methods><class-id>HPSVM.InterpreterProxy class</class-id> <category>private</category><body package="HPSVM Primitive Plugins" selector="translationPragmas">translationPragmas	"This method defines the pragmas allowed in this class.	The pragma expression says that the pragmas defined are allowed on	the class side, and the body returns the collection of pragma keywords	allowed."	&lt;pragmas: #instance&gt;	^#(macroDefinition:)</body></methods><initialize><class-id>HPSVM.VMMaker</class-id></initialize><initialize><class-id>HPSVM.CCodeGenerator</class-id></initialize><initialize><class-id>HPSVM.InterpreterPlugin</class-id></initialize><initialize><class-id>HPSVM.TtoCMethod</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>StatementNode</name><environment>Kernel</environment><super>Kernel.ProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>ValueNode</name><environment>Kernel</environment><super>Kernel.StatementNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>LeafNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>MethodNode</name><environment>Kernel</environment><super>Kernel.ProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector primitive primitiveErrorCode primitiveModule primitiveSourcePosition block attributeMessages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>BlockAnalysisUnsharedVariable</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>BlockAnalysisVariable</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types references node home definitionType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SimpleMessageNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector arguments precedence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class></st-source>