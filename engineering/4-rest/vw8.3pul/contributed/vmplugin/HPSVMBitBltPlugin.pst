<?xml version="1.0"?><st-source><!-- Name: HPSVM BitBlt PluginNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel contains the Smalltalk code that defines the BitBlt Plugin included in all vw7.2 and subsequent engines.  It can be used to generate new versions of the BitBlt and WarpBlt code.  This version is a first cut at 64-bit support.DbIdentifier: bear73DbTrace: 299232DevelopmentPrerequisites: #(#(#any 'HPSVM Primitive Plugins' '') #(#any 'HPSVM Namespace' ''))HideSource: falsePackageName: HPSVM BitBlt PluginParcel: #('HPSVM BitBlt Plugin')ParcelName: HPSVM BitBlt PluginPrerequisiteParcels: #(#('HPSVM Primitive Plugins' '') #('HPSVM Namespace' ''))PrintStringCache: (7.7 - 2,dcaster)SaveSource: trueVersion: 7.7 - 2Date: 8:23:17 AM September 3, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (sep10.1) of September 3, 2010 on September 3, 2010 at 8:23:17 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BitBltSimulation</name><environment>HPSVM</environment><super>HPSVM.InterpreterPlugin</super><private>false</private><indexed-type>none</indexed-type><inst-vars>destForm sourceForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight sourceWidth sourceHeight sourceDepth sourcePitch sourceBits sourcePPW sourceMSB destWidth destHeight destDepth destPitch destBits destPPW destMSB bitCount skew mask1 mask2 preload nWords destMask hDir vDir sourceIndex sourceDelta destIndex destDelta sx sy dx dy bbW bbH halftoneHeight noSource noHalftone halftoneBase sourceAlpha srcBitShift dstBitShift bitBltOop affectedL affectedR affectedT affectedB opTable maskTable ditherMatrix4x4 ditherThresholds16 ditherValues16 hasSurfaceLock warpSrcMask warpAlignShift warpAlignMask warpBitShiftTable querySurfaceFn lockSurfaceFn unlockSurfaceFn isWarping bigEndian srcCmFlags srcCmMask srcCmShifts srcCmMasks dstCmFlags dstCmMask dstCmShifts dstCmMasks dstExpandedLookupTable srcExpandedLookupTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Interpreter</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></class><comment><class-id>HPSVM.BitBltSimulation</class-id><body>This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWord	34	alphaBlendScaled: sourceWord with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.To add a new rule to BitBlt...	1.  add the new rule method or methods in the category 'combination rules' of BBSim	2.  describe it in the class comment  of BBSim and in the class comment for BitBlt	3.  add refs to initializeRuleTable in proper positions	4.  add refs to initBBOpTable, following the pattern</body></comment><class><name>BitBltSimulation24bpp</name><environment>HPSVM</environment><super>HPSVM.BitBltSimulation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Interpreter</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></class><class><name>BitBltSimulator24bpp</name><environment>HPSVM</environment><super>HPSVM.BitBltSimulation24bpp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Interpreter</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></class><class><name>BitBltSimulator</name><environment>HPSVM</environment><super>HPSVM.BitBltSimulation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VMConstruction-Interpreter</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></class><shared-variable><name>ImagePaletteIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(Image instVarIndexFor: 'palette') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRSourceXIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'sourceX') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRDestStrideIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'destStride') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRDestinationIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'destination') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ImageDepthIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(Image instVarIndexFor: 'depth') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ImageHeightIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(Image instVarIndexFor: 'height') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRSourceWidthIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'sourceWidth') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRColorMapIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'colorMap') - 1 "-1" "for now; see loadColorMap"</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRCombinationRuleIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'combinationRule') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRClipYIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'clipY') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>GreenIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>FixedPt1</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ColorMapPresent</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRHalftonePhaseYIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'halftonePhaseY') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRHalftonePhaseXIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'halftonePhaseX') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRHalftoneIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'halftone') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RedIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>0</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRDestYIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'destY') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRDestXIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'destX') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRDestWidthIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'destWidth') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>BlueIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>2</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>BinaryPoint</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRSourceStrideIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'sourceStride') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ImageBitsPerPixelIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(Image instVarIndexFor: 'bitsPerPixel') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRSourceIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'source') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ImageBitsIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(Image instVarIndexFor: 'bits') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRHeightIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'height') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>AllOnes</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>16rFFFFFFFF</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRHalftoneWidthIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'halftoneWidth') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRClipXIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'clipX') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRClipWidthIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'clipWidth') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>AlphaIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>3</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRHalftoneStrideIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'halftoneStride') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ShftUnitsToBytes</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>2</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRClipHeightIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'clipHeight') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRWidthIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'width') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ColorMapNewStyle</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ColorMapIndexedPart</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ColorMapFixedPart</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>OpTableSize</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>OpTable</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRWarpBase</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>RasterOp instSize</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>ImageWidthIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(Image instVarIndexFor: 'width') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><shared-variable><name>RRSourceYIndex</name><environment>HPSVM.BitBltSimulation</environment><private>false</private><constant>true</constant><category>As yet unclassified</category><initializer>(RasterOp instVarIndexFor: 'sourceY') - 1</initializer><attributes><package>HPSVM BitBlt Plugin</package></attributes></shared-variable><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>combination rules</category><body package="HPSVM BitBlt Plugin" selector="addWord:with:">addWord: sourceWord with: destinationWord	^sourceWord + destinationWord</body><body package="HPSVM BitBlt Plugin" selector="alphaBlend:with:">alphaBlend: sourceWord with: destinationWord	"Blend sourceWord with destinationWord, assuming both are 32-bit pixels.	The source is assumed to have 255*alpha in the high 8 bits of each pixel,	while the high 8 bits of the destinationWord will be ignored.	The blend produced is alpha*source + (1-alpha)*dest, with	the computation being performed independently on each color	component.  The high byte of the result will be 0."	| alpha unAlpha colorMask result blend shift |	self inline: false.	alpha := sourceWord &gt;&gt; 24.  "High 8 bits of source pixel"	alpha = 0 ifTrue: [ ^ destinationWord ].	alpha = 255 ifTrue: [ ^ sourceWord ].	unAlpha := 255 - alpha.	colorMask := 16rFF.	result := 0.	"ar 9/9/2000 - include alpha in computation"	1 to: 4 do:		[:i | shift := (i-1)*8.		blend := (((sourceWord&gt;&gt;shift bitAnd: colorMask) * alpha)					+ ((destinationWord&gt;&gt;shift bitAnd: colorMask) * unAlpha))			 	+ 254 // 255 bitAnd: colorMask.		result := result bitOr: blend&lt;&lt;shift].	^ result</body><body package="HPSVM BitBlt Plugin" selector="alphaBlendConst:with:">alphaBlendConst: sourceWord with: destinationWord	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: false</body><body package="HPSVM BitBlt Plugin" selector="alphaBlendConst:with:paintMode:">alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: true.	destDepth &lt; 16 ifTrue: [^ destinationWord "no-op"].	unAlpha := 255 - sourceAlpha.	pixMask := maskTable at: destDepth.	destDepth = 16 		ifTrue: [bitsPerColor := 5]		ifFalse:[bitsPerColor := 8].	rgbMask := (1&lt;&lt;bitsPerColor) - 1.	maskShifted := destMask.	destShifted := destinationWord.	sourceShifted := sourceWord.	result := destinationWord.	destPPW = 1 ifTrue:["32bpp blends include alpha"		paintMode &amp; (sourceWord = 0)  "painting a transparent pixel" ifFalse:[			result := 0.			1 to: 4 do:[:i|				shift := (i-1)*8.				blend := (((sourceWord&gt;&gt;shift bitAnd: rgbMask) * sourceAlpha)							+ ((destinationWord&gt;&gt;shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				result := result bitOr: blend&lt;&lt;shift].		].	] ifFalse:[		1 to: destPPW do:[:j |			sourcePixVal := sourceShifted bitAnd: pixMask.			((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"				or: [paintMode &amp; (sourcePixVal = 0)  "or painting a transparent pixel"])			ifFalse:				[destPixVal := destShifted bitAnd: pixMask.				pixBlend := 0.				1 to: 3 do:					[:i | shift := (i-1)*bitsPerColor.					blend := (((sourcePixVal&gt;&gt;shift bitAnd: rgbMask) * sourceAlpha)								+ ((destPixVal&gt;&gt;shift bitAnd: rgbMask) * unAlpha))						 	+ 254 // 255 bitAnd: rgbMask.					pixBlend := pixBlend bitOr: blend&lt;&lt;shift].				destDepth = 16					ifTrue: [result := (result bitAnd: (pixMask &lt;&lt; (j-1*16)) bitInvert32)										bitOr: pixBlend &lt;&lt; (j-1*16)]					ifFalse: [result := pixBlend]].			maskShifted := maskShifted &gt;&gt; destDepth.			sourceShifted := sourceShifted &gt;&gt; destDepth.			destShifted := destShifted &gt;&gt; destDepth].	].	^ result</body><body package="HPSVM BitBlt Plugin" selector="alphaBlendScaled:with:">alphaBlendScaled: sourceWord with: destinationWord	"Blend sourceWord with destinationWord using the alpha value from sourceWord.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	In contrast to alphaBlend:with: the color produced is		srcColor + (1-srcAlpha) * dstColor	e.g., it is assumed that the source color is already scaled."	| unAlpha dstMask srcMask b g r a |	self inline: false.	"Do NOT inline this into optimized loops"	unAlpha := 255 - (sourceWord &gt;&gt; 24).  "High 8 bits of source pixel"	dstMask := destinationWord.	srcMask := sourceWord.	b := (dstMask bitAnd: 255) * unAlpha &gt;&gt; 8 + (srcMask bitAnd: 255).	b &gt; 255 ifTrue:[b := 255].	dstMask := dstMask &gt;&gt; 8.	srcMask := srcMask &gt;&gt; 8.	g := (dstMask bitAnd: 255) * unAlpha &gt;&gt; 8 + (srcMask bitAnd: 255).	g &gt; 255 ifTrue:[g := 255].	dstMask := dstMask &gt;&gt; 8.	srcMask := srcMask &gt;&gt; 8.	r := (dstMask bitAnd: 255) * unAlpha &gt;&gt; 8 + (srcMask bitAnd: 255).	r &gt; 255 ifTrue:[r := 255].	dstMask := dstMask &gt;&gt; 8.	srcMask := srcMask &gt;&gt; 8.	a := (dstMask bitAnd: 255) * unAlpha &gt;&gt; 8 + (srcMask bitAnd: 255).	a &gt; 255 ifTrue:[a := 255].	^(((((a &lt;&lt; 8) + r) &lt;&lt; 8) + g) &lt;&lt; 8) + b</body><body package="HPSVM BitBlt Plugin" selector="alphaPaintConst:with:">alphaPaintConst: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord  "opt for all-transparent source"].	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: true</body><body package="HPSVM BitBlt Plugin" selector="bitAnd:with:">bitAnd: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord</body><body package="HPSVM BitBlt Plugin" selector="bitAndInvert:with:">bitAndInvert: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord bitInvert32</body><body package="HPSVM BitBlt Plugin" selector="bitInvertAnd:with:">bitInvertAnd: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord</body><body package="HPSVM BitBlt Plugin" selector="bitInvertAndInvert:with:">bitInvertAndInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord bitInvert32</body><body package="HPSVM BitBlt Plugin" selector="bitInvertDestination:with:">bitInvertDestination: sourceWord with: destinationWord	^destinationWord bitInvert32</body><body package="HPSVM BitBlt Plugin" selector="bitInvertOr:with:">bitInvertOr: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord</body><body package="HPSVM BitBlt Plugin" selector="bitInvertOrInvert:with:">bitInvertOrInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord bitInvert32</body><body package="HPSVM BitBlt Plugin" selector="bitInvertSource:with:">bitInvertSource: sourceWord with: destinationWord	^sourceWord bitInvert32</body><body package="HPSVM BitBlt Plugin" selector="bitInvertXor:with:">bitInvertXor: sourceWord with: destinationWord	^sourceWord bitInvert32 bitXor: destinationWord</body><body package="HPSVM BitBlt Plugin" selector="bitOr:with:">bitOr: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord</body><body package="HPSVM BitBlt Plugin" selector="bitOrInvert:with:">bitOrInvert: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord bitInvert32</body><body package="HPSVM BitBlt Plugin" selector="bitXor:with:">bitXor: sourceWord with: destinationWord	^sourceWord bitXor: destinationWord</body><body package="HPSVM BitBlt Plugin" selector="clearWord:with:">clearWord: source with: destination	^ 0</body><body package="HPSVM BitBlt Plugin" selector="destinationWord:with:">destinationWord: sourceWord with: destinationWord	^destinationWord</body><body package="HPSVM BitBlt Plugin" selector="fixAlpha:with:">fixAlpha: sourceWord with: destinationWord	"For any non-zero pixel value in destinationWord with zero alpha channel take the alpha from sourceWord and fill it in. Intended for fixing alpha channels left at zero during 16-&gt;32 bpp conversions."	destDepth = 32 ifFalse:[^destinationWord]. "no-op for non 32bpp"	destinationWord = 0 ifTrue:[^0].	(destinationWord bitAnd: 16rFF000000) = 0 ifFalse:[^destinationWord].	^destinationWord bitOr: (sourceWord bitAnd: 16rFF000000)</body><body package="HPSVM BitBlt Plugin" selector="partitionedAND:to:nBits:nPartitions:">partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result |	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result := result bitOr: (word2 bitAnd: mask)].		mask := mask &lt;&lt; nBits  "slide left to next partition"].	^ result</body><body package="HPSVM BitBlt Plugin" selector="partitionedAdd:to:nBits:nPartitions:">partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result |	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		sum := (word1 bitAnd: mask) + (word2 bitAnd: mask).		result := sum &lt;= mask  "result must not carry out of partition"					ifTrue: [result bitOr: sum]					ifFalse: [result bitOr: mask].		mask := mask &lt;&lt; nBits  "slide left to next partition"].	^ result</body><body package="HPSVM BitBlt Plugin" selector="partitionedMax:with:nBits:nPartitions:">partitionedMax: word1 with: word2 nBits: nBits nPartitions: nParts	"Max word1 to word2 as nParts partitions of nBits each"	| mask result |	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		result := result bitOr: ((word2 bitAnd: mask) max: (word1 bitAnd: mask)).		mask := mask &lt;&lt; nBits  "slide left to next partition"].	^ result</body><body package="HPSVM BitBlt Plugin" selector="partitionedMin:with:nBits:nPartitions:">partitionedMin: word1 with: word2 nBits: nBits nPartitions: nParts	"Min word1 to word2 as nParts partitions of nBits each"	| mask result |	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		result := result bitOr: ((word2 bitAnd: mask) min: (word1 bitAnd: mask)).		mask := mask &lt;&lt; nBits  "slide left to next partition"].	^ result</body><body package="HPSVM BitBlt Plugin" selector="partitionedMul:with:nBits:nPartitions:">partitionedMul: word1 with: word2 nBits: nBits nPartitions: nParts	"Multiply word1 with word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors.	Bug in loop version when non-white background"	| sMask product result dMask |	sMask := maskTable at: nBits.  "partition mask starts at the right"	dMask :=  sMask &lt;&lt; nBits.	result := (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) &gt;&gt; nBits.	"optimized first step"	product := (((word1&gt;&gt;nBits bitAnd: sMask)+1) * ((word2&gt;&gt;nBits bitAnd: sMask)+1) - 1 bitAnd: dMask).	result := result bitOr: (product bitAnd: dMask).	product := (((word1&gt;&gt;(2*nBits) bitAnd: sMask)+1) * ((word2&gt;&gt;(2*nBits) bitAnd: sMask)+1) - 1 bitAnd: dMask).	result := result bitOr: (product bitAnd: dMask) &lt;&lt; nBits.	^ result"	| sMask product result dMask |	sMask := maskTable at: nBits.  'partition mask starts at the right'	dMask :=  sMask &lt;&lt; nBits.	result := (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) &gt;&gt; nBits.	'optimized first step'	nBits to: nBits * (nParts-1) by: nBits do: [:ofs |		product := (((word1&gt;&gt;ofs bitAnd: sMask)+1) * ((word2&gt;&gt;ofs bitAnd: sMask)+1) - 1 bitAnd: dMask).		result := result bitOr: (product bitAnd: dMask) &lt;&lt; (ofs-nBits)].	^ result"</body><body package="HPSVM BitBlt Plugin" selector="partitionedSub:from:nBits:nPartitions:">partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result p1 p2 |	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: nParts do:		[:i |		p1 := word1 bitAnd: mask.		p2 := word2 bitAnd: mask.		p1 &lt; p2  "result is really abs value of thedifference"			ifTrue: [result := result bitOr: p2 - p1]			ifFalse: [result := result bitOr: p1 - p2].		mask := mask &lt;&lt; nBits  "slide left to next partition"].	^ result</body><body package="HPSVM BitBlt Plugin" selector="pickSourcePixels:srcMask:destMask:srcShiftInc:dstShiftInc:">pickSourcePixels: nPixels srcMask: srcMask destMask: dstMask srcShiftInc: srcShiftInc dstShiftInc: dstShiftInc	"Pick nPix pixels starting at srcBitIndex from the source, map by the	color map, and justify them according to dstBitIndex in the resulting destWord."	| sourceWord destWord sourcePix destPix srcShift dstShift nPix |	self inline: true. "oh please"	sourceWord := self srcLongAt: sourceIndex.	destWord := 0.	srcShift := srcBitShift. "Hint: Keep in register"	dstShift := dstBitShift. "Hint: Keep in register"	nPix := nPixels. "always &gt; 0 so we can use do { } while(--nPix);"	(srcCmFlags bitAnd: ColorMapIndexedPart) ~= 0 ifTrue:[		"a little optimization for (pretty crucial) blits using indexed lookups only"		[	"grab, colormap and mix in pixel"			sourcePix := sourceWord &gt;&gt; srcShift bitAnd: srcMask.			destPix := self tableLookup: srcExpandedLookupTable at: (sourcePix bitAnd: srcCmMask).			destWord := destWord bitOr: (destPix bitAnd: dstMask) &lt;&lt; dstShift.			"adjust dest pix index"			dstShift := dstShift + dstShiftInc.			"adjust source pix index"			((srcShift := srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift := srcShift + 32] ifFalse:[srcShift := srcShift - 32].				sourceWord := self srcLongAt: (sourceIndex := sourceIndex + 4)].		(nPix := nPix - 1) = 0] whileFalse.	] ifFalse:[		[	"grab, colormap and mix in pixel"			sourcePix := sourceWord &gt;&gt; srcShift bitAnd: srcMask.			destPix := self mapSourcePixel: sourcePix.			destWord := destWord bitOr: (destPix bitAnd: dstMask) &lt;&lt; dstShift.			"adjust dest pix index"			dstShift := dstShift + dstShiftInc.			"adjust source pix index"			((srcShift := srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift := srcShift + 32] ifFalse:[srcShift := srcShift - 32].				sourceWord := self srcLongAt: (sourceIndex := sourceIndex + 4)].		(nPix := nPix - 1) = 0] whileFalse.	].	srcBitShift := srcShift. "Store back"	^destWord</body><body package="HPSVM BitBlt Plugin" selector="pixClear:with:">pixClear: sourceWord with: destinationWord	"Clear all pixels in destinationWord for which the pixels of sourceWord have the same values. Used to clear areas of some constant color to zero."	| mask result nBits pv |	self inline: false.	destDepth = 32 ifTrue:[^sourceWord = destinationWord ifTrue:[0] ifFalse:[destinationWord]].	nBits := destDepth.	mask := maskTable at: nBits.  "partition mask starts at the right"	result := 0.	1 to: destPPW do:[:i |		pv := destinationWord bitAnd: mask.		(sourceWord bitAnd: mask) = pv ifTrue:[pv := 0].		result := result bitOr: pv.		mask := mask &lt;&lt; nBits "slide left to next partition"].	^ result</body><body package="HPSVM BitBlt Plugin" selector="pixMask:with:">pixMask: sourceWord with: destinationWord	self inline: false.	^ self partitionedAND: sourceWord bitInvert32 to: destinationWord					nBits: destDepth nPartitions: destPPW</body><body package="HPSVM BitBlt Plugin" selector="pixPaint:with:">pixPaint: sourceWord with: destinationWord	self inline: false.	sourceWord = 0 ifTrue: [^ destinationWord].	^ sourceWord bitOr:		(self partitionedAND: sourceWord bitInvert32 to: destinationWord						nBits: destDepth nPartitions: destPPW)</body><body package="HPSVM BitBlt Plugin" selector="pixSwap:with:">pixSwap: sourceWord with: destWord	"Swap the pixels in destWord"	| result shift lowMask highMask |	self inline: false.	destPPW = 1 ifTrue:[^destWord]. "a single pixel per word"	result := 0.	lowMask := (1 &lt;&lt; destDepth) - 1. "mask low pixel"	highMask := lowMask &lt;&lt; (destPPW-1 * destDepth). "mask high pixel"	shift := 32 - destDepth.	result := result bitOr: (				(destWord bitAnd: lowMask) &lt;&lt; shift bitOr:					(destWord bitAnd: highMask) &gt;&gt; shift).	destPPW &lt;= 2 ifTrue:[^result].	2 to: destPPW // 2 do:[:i|		lowMask := lowMask &lt;&lt; destDepth.		highMask := highMask &gt;&gt; destDepth.		shift := shift - (destDepth * 2).		result := result bitOr: (					(destWord bitAnd: lowMask) &lt;&lt; shift bitOr:						(destWord bitAnd: highMask) &gt;&gt; shift)].	^result</body><body package="HPSVM BitBlt Plugin" selector="rgbAdd:with:">rgbAdd: sourceWord with: destinationWord	self inline: false.	destDepth &lt; 16 ifTrue:		["Add each pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Add RGB components of each pixel separately"		^ (self partitionedAdd: sourceWord to: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedAdd: sourceWord&gt;&gt;16 to: destinationWord&gt;&gt;16						nBits: 5 nPartitions: 3) &lt;&lt; 16)]	ifFalse:		["Add RGB components of the pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: 8 nPartitions: 3]</body><body package="HPSVM BitBlt Plugin" selector="rgbDiff:with:">rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal bitsPerColor rgbMask sourcePixVal diff maskShifted |	self inline: false.	pixMask := maskTable at: destDepth.	destDepth = 16		ifTrue: [bitsPerColor := 5.  rgbMask := 16r1F]		ifFalse: [bitsPerColor := 8.  rgbMask := 16rFF].	maskShifted := destMask.	destShifted := destinationWord.	sourceShifted := sourceWord.	1 to: destPPW do:		[:i |		(maskShifted bitAnd: pixMask) &gt; 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal := destShifted bitAnd: pixMask.			sourcePixVal := sourceShifted bitAnd: pixMask.			destDepth &lt; 16				ifTrue: [sourcePixVal = destPixVal							ifTrue: [diff := 0]							ifFalse: [diff := 1]]				ifFalse: [diff := (self partitionedSub: sourcePixVal from: destPixVal								nBits: bitsPerColor nPartitions: 3).						diff := (diff bitAnd: rgbMask)							+ (diff&gt;&gt;bitsPerColor bitAnd: rgbMask)							+ ((diff&gt;&gt;bitsPerColor)&gt;&gt;bitsPerColor bitAnd: rgbMask)].			bitCount := bitCount + diff].		maskShifted := maskShifted &gt;&gt; destDepth.		sourceShifted := sourceShifted &gt;&gt; destDepth.		destShifted := destShifted &gt;&gt; destDepth].	^ destinationWord  "For no effect on dest"</body><body package="HPSVM BitBlt Plugin" selector="rgbMax:with:">rgbMax: sourceWord with: destinationWord	self inline: false.	destDepth &lt; 16 ifTrue:		["Max each pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Max RGB components of each pixel separately"		^ (self partitionedMax: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMax: sourceWord&gt;&gt;16 with: destinationWord&gt;&gt;16						nBits: 5 nPartitions: 3) &lt;&lt; 16)]	ifFalse:		["Max RGB components of the pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]</body><body package="HPSVM BitBlt Plugin" selector="rgbMin:with:">rgbMin: sourceWord with: destinationWord	self inline: false.	destDepth &lt; 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord&gt;&gt;16 with: destinationWord&gt;&gt;16						nBits: 5 nPartitions: 3) &lt;&lt; 16)]	ifFalse:		["Min RGB components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]</body><body package="HPSVM BitBlt Plugin" selector="rgbMinInvert:with:">rgbMinInvert: wordToInvert with: destinationWord	| sourceWord |	self inline: false.	sourceWord := wordToInvert bitInvert32.	destDepth &lt; 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord&gt;&gt;16 with: destinationWord&gt;&gt;16						nBits: 5 nPartitions: 3) &lt;&lt; 16)]	ifFalse:		["Min RGB components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]</body><body package="HPSVM BitBlt Plugin" selector="rgbMul:with:">rgbMul: sourceWord with: destinationWord	self inline: false.	destDepth &lt; 16 ifTrue:		["Mul each pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Mul RGB components of each pixel separately"		^ (self partitionedMul: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMul: sourceWord&gt;&gt;16 with: destinationWord&gt;&gt;16						nBits: 5 nPartitions: 3) &lt;&lt; 16)]	ifFalse:		["Mul RGB components of the pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]"	| scanner |	Display repaintMorphicDisplay.	scanner := DisplayScanner quickPrintOn: Display.	MessageTally time: [0 to: 760 by: 4 do:  [:y |scanner drawString: 'qwrepoiuasfd=)(/&amp;()=#!￿lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,Mqwrepoiuasfd=)(/&amp;()=#!￿lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,M1234124356785678' at: 0@y]]. "</body><body package="HPSVM BitBlt Plugin" selector="rgbSub:with:">rgbSub: sourceWord with: destinationWord	self inline: false.	destDepth &lt; 16 ifTrue:		["Sub each pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: destDepth nPartitions: destPPW].	destDepth = 16 ifTrue:		["Sub RGB components of each pixel separately"		^ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedSub: sourceWord&gt;&gt;16 from: destinationWord&gt;&gt;16						nBits: 5 nPartitions: 3) &lt;&lt; 16)]	ifFalse:		["Sub RGB components of the pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3]</body><body package="HPSVM BitBlt Plugin" selector="setWord:with:">setWord: source with: destination	^16rFFFFFFFF</body><body package="HPSVM BitBlt Plugin" selector="sourceWord:with:">sourceWord: sourceWord with: destinationWord	^sourceWord</body><body package="HPSVM BitBlt Plugin" selector="subWord:with:">subWord: sourceWord with: destinationWord	^sourceWord - destinationWord</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>accessing</category><body package="HPSVM BitBlt Plugin" selector="affectedBottom">affectedBottom	^affectedB</body><body package="HPSVM BitBlt Plugin" selector="affectedLeft">affectedLeft	^affectedL</body><body package="HPSVM BitBlt Plugin" selector="affectedRight">affectedRight	^affectedR</body><body package="HPSVM BitBlt Plugin" selector="affectedTop">affectedTop	^affectedT</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>inner loop</category><body package="HPSVM BitBlt Plugin" selector="alphaSourceBlendBits16">alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift ditherBase ditherIndex ditherThreshold |	self inline: false. "This particular method should be optimized in itself"	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	srcShift := (dx bitAnd: 1) * 16.	destMSB ifTrue:[srcShift := 16 - srcShift].	mask1 := 16rFFFF &lt;&lt; (16 - srcShift).	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx // 2 * 4).		ditherBase := (dstY bitAnd: 3) * 4.		ditherIndex := (sx bitAnd: 3) - 1. "For pre-increment"		deltaX := bbW + 1. "So we can pre-decrement"		dstMask := mask1.		dstMask = 16rFFFF ifTrue:[srcShift := 16] ifFalse:[srcShift := 0].		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			ditherThreshold := ditherMatrix4x4 at: ditherBase + (ditherIndex := ditherIndex + 1 bitAnd: 3).			sourceWord := self srcLongAt: srcIndex.			srcAlpha := sourceWord &gt;&gt; 24.			srcAlpha = 255 ifTrue:[				"Dither from 32 to 16 bit"				sourceWord := self dither32To16: sourceWord threshold: ditherThreshold.				sourceWord = 0 ifTrue:[sourceWord := 1].				sourceWord := sourceWord &lt;&lt; srcShift.				"Store masked value"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[				] ifFalse:[ "0 &lt; srcAlpha &lt; 255"					"If we have to mix colors then just copy a single word"					destWord := self dstLongAt: dstIndex.					destWord := destWord bitAnd: dstMask bitInvert32.					destWord := destWord &gt;&gt; srcShift.					"Expand from 16 to 32 bit by adding zero bits"					destWord := (((destWord bitAnd: 16r7C00) bitShift: 9) bitOr:									((destWord bitAnd: 16r3E0) bitShift: 6)) bitOr:								(((destWord bitAnd: 16r1F) bitShift: 3) bitOr:									16rFF000000).					"Mix colors"					sourceWord := self alphaBlendScaled: sourceWord with: destWord.					"And dither"					sourceWord := self dither32To16: sourceWord threshold: ditherThreshold.					sourceWord = 0 ifTrue:[sourceWord := 1].					sourceWord := sourceWord &lt;&lt; srcShift.					"Store back"					self dstLongAt: dstIndex put: sourceWord mask: dstMask.				].			].			srcIndex := srcIndex + 4.			destMSB				ifTrue:[srcShift = 0 ifTrue:[dstIndex := dstIndex + 4]]				ifFalse:[srcShift = 0 ifFalse:[dstIndex := dstIndex + 4]].			srcShift := srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask := dstMask bitInvert32. "Mask other half word"		].		srcY := srcY + 1.		dstY := dstY + 1.	].</body><body package="HPSVM BitBlt Plugin" selector="alphaSourceBlendBits32">alphaSourceBlendBits32	"This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	self inline: false. "This particular method should be optimized in itself"	"Give the compile a couple of hints"	self var: #sourceWord declareC:'register int sourceWord'.	self var: #deltaX declareC:'register int deltaX'.	"The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does)"	self var: #srcIndex declareC:'register oopInt srcIndex'.	self var: #dstIndex declareC:'register oopInt dstIndex'.	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx * 4).		deltaX := bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			sourceWord := self srcLongAt: srcIndex.			srcAlpha := sourceWord &gt;&gt; 24.			srcAlpha = 255 ifTrue:[				self dstLongAt: dstIndex put: sourceWord.				srcIndex := srcIndex + 4.				dstIndex := dstIndex + 4.				"Now copy as many words as possible with alpha = 255"				[(deltaX := deltaX - 1) ~= 0 and:[					(sourceWord := self srcLongAt: srcIndex) &gt;&gt; 24 = 255]]						whileTrue:[							self dstLongAt: dstIndex put: sourceWord.							srcIndex := srcIndex + 4.							dstIndex := dstIndex + 4.						].				"Adjust deltaX"				deltaX := deltaX + 1.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[					srcIndex := srcIndex + 4.					dstIndex := dstIndex + 4.					"Now skip as many words as possible,"					[(deltaX := deltaX - 1) ~= 0 and:[						(sourceWord := self srcLongAt: srcIndex) &gt;&gt; 24 = 0]]						whileTrue:[							srcIndex := srcIndex + 4.							dstIndex := dstIndex + 4.						].					"Adjust deltaX"					deltaX := deltaX + 1.				] ifFalse:[ "0 &lt; srcAlpha &lt; 255"					"If we have to mix colors then just copy a single word"					destWord := self dstLongAt: dstIndex.					destWord := self alphaBlendScaled: sourceWord with: destWord.					self dstLongAt: dstIndex put: destWord.					srcIndex := srcIndex + 4.					dstIndex := dstIndex + 4.				].			].		].		srcY := srcY + 1.		dstY := dstY + 1.	].</body><body package="HPSVM BitBlt Plugin" selector="alphaSourceBlendBits8">alphaSourceBlendBits8	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust mappingTable |	self inline: false. "This particular method should be optimized in itself"	self var: #mappingTable declareC:'unsigned int *mappingTable'.	mappingTable := self default8To32Table.	deltaY := bbH + 1. "So we can pre-decrement"	srcY := sy.	dstY := dy.	mask1 := ((dx bitAnd: 3) * 8).	destMSB ifTrue:[mask1 := 24 - mask1].	mask2 := AllOnes bitXor:(16rFF &lt;&lt; mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust := 0]		ifFalse:[adjust := 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust := adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY := deltaY - 1) ~= 0] whileTrue:[		adjust := adjust bitXor: 16r1F1F1F1F.		srcIndex := sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex := destBits + (dstY * destPitch) + (dx // 4 * 4).		deltaX := bbW + 1. "So we can pre-decrement"		srcShift := mask1.		dstMask := mask2.		"This is the inner loop"		[(deltaX := deltaX - 1) ~= 0] whileTrue:[			sourceWord := ((self srcLongAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha := sourceWord &gt;&gt; 24.			srcAlpha &gt; 31 ifTrue:["Everything below 31 is transparent"				srcAlpha &lt; 224 ifTrue:["Everything above 224 is opaque"					destWord := self dstLongAt: dstIndex.					destWord := destWord bitAnd: dstMask bitInvert32.					destWord := destWord &gt;&gt; srcShift.					destWord := mappingTable at: destWord.					sourceWord := self alphaBlendScaled: sourceWord with: destWord.				].				sourceWord := self mapSourcePixel: sourceWord.				sourceWord := sourceWord &lt;&lt; srcShift.				"Store back"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			].			srcIndex := srcIndex + 4.			destMSB ifTrue:[				srcShift = 0 					ifTrue:[dstIndex := dstIndex + 4.							srcShift := 24.							dstMask := 16r00FFFFFF]					ifFalse:[srcShift := srcShift - 8.							dstMask := (dstMask &gt;&gt; 8) bitOr: 16rFF000000].			] ifFalse:[				srcShift = 32					ifTrue:[dstIndex := dstIndex + 4.							srcShift := 0.							dstMask := 16rFFFFFF00]					ifFalse:[srcShift := srcShift + 8.							dstMask := dstMask &lt;&lt; 8 bitOr: 255].			].			adjust := adjust bitXor: 16r1F1F1F1F.		].		srcY := srcY + 1.		dstY := dstY + 1.	].</body><body package="HPSVM BitBlt Plugin" selector="copyLoop">copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith destWord |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc := hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew := unskew := skewMask := 0]		ifFalse: [skew &lt; 0			ifTrue:				[unskew := skew+32.				skewMask := AllOnes &lt;&lt; (0-skew)]			ifFalse:				[skew = 0					ifTrue:						[unskew := 0.						skewMask := AllOnes]					ifFalse:						[unskew := skew-32.						skewMask := AllOnes &gt;&gt; skew]]].	notSkewMask := skewMask bitInvert32.	noHalftone		ifTrue:			[halftoneWord := AllOnes.			 halftoneHeight := 0]		ifFalse:			[y := dy.			 halftoneWord := self halftoneAt: 0.			 halftoneHeight = 1 ifTrue:				[halftoneHeight := 0]].	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight ifTrue:  "Otherwise, its always the same"			[halftoneWord := self halftoneAt: y.			y := y + vDir].		preload			ifTrue:				["load the 64-bit shifter"				prevWord := self srcLongAt: sourceIndex.				sourceIndex := sourceIndex + hInc]			ifFalse: [prevWord := 0].	"Note: the horizontal loop has been expanded into three parts for speed:"		"This first section requires masking of the destination store..."		destMask := mask1.		thisWord := self srcLongAt: sourceIndex.  "pick up next word"		sourceIndex := sourceIndex + hInc.		skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).		prevWord := thisWord.		destWord := self dstLongAt: destIndex.		mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.		destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).		self dstLongAt: destIndex put: destWord.		destIndex := destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask := AllOnes.combinationRule = 3ifTrue: [(skew = 0) &amp; (halftoneWord = AllOnes)		ifTrue: 		["Very special inner loop for STORE mode with no skew -- just move words"		hDir &lt; 0		ifTrue: ["Woeful patch: revert to older code for hDir &lt; 0"				2 to: nWords-1 do: 					[ :word |					thisWord := self srcLongAt: sourceIndex.					sourceIndex := sourceIndex + hInc.					self dstLongAt: destIndex put: thisWord.					destIndex := destIndex + hInc]]		ifFalse: [2 to: nWords-1 do: 					[ :word |  "Note loop starts with prevWord loaded (due to preload)"					self dstLongAt: destIndex put: prevWord.					destIndex := destIndex + hInc.					prevWord := self srcLongAt: sourceIndex.					sourceIndex := sourceIndex + hInc]]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord := self srcLongAt: sourceIndex.			sourceIndex := sourceIndex + hInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			self dstLongAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex := destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)							with: (self dstLongAt: destIndex).			self dstLongAt: destIndex put: mergeWord.			destIndex := destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords &gt; 1 ifTrue:			[destMask := mask2.			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + hInc].	sourceIndex := sourceIndex + sourceDelta.	destIndex := destIndex + destDelta]</body><body package="HPSVM BitBlt Plugin" selector="copyLoopNoSource">copyLoopNoSource	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	| halftoneWord mergeWord mergeFnwith destWord |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord := AllOnes]			ifFalse: [halftoneWord := self halftoneAt: dy+i-1].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask := mask1.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: halftoneWord							with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr: 							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + 4.		"This central horizontal loop requires no store masking"			destMask := AllOnes.			combinationRule = 3 ifTrue: ["Special inner loop for STORE"				destWord := halftoneWord.				2 to: nWords-1 do:[ :word |					self dstLongAt: destIndex put: destWord.					destIndex := destIndex + 4].			] ifFalse:[ "Normal inner loop does merge"				2 to: nWords-1 do:[ :word | "Normal inner loop does merge"					destWord := self dstLongAt: destIndex.					mergeWord := self mergeFn: halftoneWord with: destWord.					self dstLongAt: destIndex put: mergeWord.					destIndex := destIndex + 4].			].		"This last section, if used, requires masking of the destination store..."		nWords &gt; 1 ifTrue:			[destMask := mask2.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: halftoneWord with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + 4].	destIndex := destIndex + destDelta]</body><body package="HPSVM BitBlt Plugin" selector="copyLoopPixMap">copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	"ar 12/7/1999:	The loop has been rewritten to use only one pickSourcePixels call.	The idea is that the call itself could be inlined. If we decide not	to inline pickSourcePixels we could optimize the loop instead."	| skewWord halftoneWord mergeWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask mergeFnwith nPix srcShift dstShift destWord words srcShiftInc dstShiftInc dstShiftLeft |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	sourcePPW := 32//sourceDepth.	sourcePixMask := maskTable at: sourceDepth.	destPixMask := maskTable at: destDepth.	sourceIndex := sourceBits +					(sy * sourcePitch) + ((sx // sourcePPW) *4).	scrStartBits := sourcePPW - (sx bitAnd: sourcePPW-1).	bbW &lt; scrStartBits		ifTrue: [nSourceIncs := 0]		ifFalse: [nSourceIncs := (bbW - scrStartBits)//sourcePPW + 1].	sourceDelta := sourcePitch - (nSourceIncs * 4).	"Note following two items were already calculated in destmask setup!"	startBits := destPPW - (dx bitAnd: destPPW-1).	endBits := ((dx + bbW - 1) bitAnd: destPPW-1) + 1.	bbW &lt; startBits ifTrue:[startBits := bbW].	"Precomputed shifts for pickSourcePixels"	srcShift := ((sx bitAnd: sourcePPW - 1) * sourceDepth).	dstShift := ((dx bitAnd: destPPW - 1) * destDepth).	srcShiftInc := sourceDepth.	dstShiftInc := destDepth.	dstShiftLeft := 0.	sourceMSB ifTrue:[		srcShift := 32 - sourceDepth - srcShift.		srcShiftInc := 0 - srcShiftInc].	destMSB ifTrue:[		dstShift := 32 - destDepth - dstShift.		dstShiftInc := 0 - dstShiftInc.		dstShiftLeft := 32 - destDepth].	1 to: bbH do: "here is the vertical loop"		[ :i |		"*** is it possible at all that noHalftone == false? ***"		noHalftone			ifTrue:[halftoneWord := AllOnes]			ifFalse: [halftoneWord := self halftoneAt: dy+i-1].		"setup first load"		srcBitShift := srcShift.		dstBitShift := dstShift.		destMask := mask1.		nPix := startBits.		"Here is the horizontal loop..."		words := nWords.			["pick up the word"			skewWord := self pickSourcePixels: nPix								srcMask: sourcePixMask destMask: destPixMask								srcShiftInc: srcShiftInc dstShiftInc: dstShiftInc.			"align next word to leftmost pixel"			dstBitShift := dstShiftLeft.			destMask = AllOnes ifTrue:["avoid read-modify-write"				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (self dstLongAt: destIndex).				self dstLongAt: destIndex put: (destMask bitAnd: mergeWord).			] ifFalse:[ "General version using dest masking"				destWord := self dstLongAt: destIndex.				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (destWord bitAnd: destMask).				destWord := (destMask bitAnd: mergeWord) bitOr:								(destWord bitAnd: destMask bitInvert32).				self dstLongAt: destIndex put: destWord.			].			destIndex := destIndex + 4.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask := mask2.						nPix := endBits]				ifFalse:["use fullword mask for inner loop"						destMask := AllOnes.						nPix := destPPW].			(words := words - 1) = 0] whileFalse.		"--- end of inner loop ---"		sourceIndex := sourceIndex + sourceDelta.		destIndex := destIndex + destDelta]</body><body package="HPSVM BitBlt Plugin" selector="warpLoopSmoothing:">warpLoopSmoothing: smoothingCount	"This version of the inner loop traverses an arbirary quadrilateral	 source, thus producing a general affine transformation."	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy pBx pBy	  xDelta yDelta nSteps nPix words destWord endBits	  mergeFnwith dstShiftInc dstShiftLeft |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	(interpreterProxy slotSizeOf: bitBltOop) &gt;= (RRWarpBase+12) ifFalse:		[^ interpreterProxy primitiveFail].	(nSteps := height-1) &lt;= 0 ifTrue: [nSteps := 1].	pAx := self fetchIntOrFloat: RRWarpBase ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+3 ofObject: bitBltOop.	deltaP12x := self deltaFrom: pAx to: words nSteps: nSteps.	deltaP12x &lt; 0 ifTrue: [pAx := words - (nSteps*deltaP12x)].	pAy := self fetchIntOrFloat: RRWarpBase+1 ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+4 ofObject: bitBltOop.	deltaP12y := self deltaFrom: pAy to: words nSteps: nSteps.	deltaP12y &lt; 0 ifTrue: [pAy := words - (nSteps*deltaP12y)].	pBx := self fetchIntOrFloat: RRWarpBase+9 ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+6 ofObject: bitBltOop.	deltaP43x := self deltaFrom: pBx to: words nSteps: nSteps.	deltaP43x &lt; 0 ifTrue: [pBx := words - (nSteps*deltaP43x)].	pBy := self fetchIntOrFloat: RRWarpBase+10 ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+7 ofObject: bitBltOop.	deltaP43y := self deltaFrom: pBy to: words nSteps: nSteps.	deltaP43y &lt; 0 ifTrue: [pBy := words - (nSteps*deltaP43y)].	nSteps := width-1.  nSteps &lt;= 0 ifTrue: [nSteps := 1].	startBits := destPPW - (dx bitAnd: destPPW-1).	endBits := ((dx + bbW - 1) bitAnd: destPPW-1) + 1. 	bbW &lt; startBits ifTrue:[startBits := bbW].	destY &lt; clipY ifTrue:		["Advance increments if there was clipping in y"		pAx := pAx + (clipY - destY * deltaP12x).		pAy := pAy + (clipY - destY * deltaP12y).		pBx := pBx + (clipY - destY * deltaP43x).		pBy := pBy + (clipY - destY * deltaP43y)].	"Setup values for faster pixel fetching."	self warpLoopSetup.	destMSB		ifTrue:[	dstShiftInc := 0 - destDepth.				dstShiftLeft := 32 - destDepth]		ifFalse:[	dstShiftInc := destDepth.				dstShiftLeft := 0].	1 to: bbH do:		[ :i | "here is the vertical loop..."		xDelta := self deltaFrom: pAx to: pBx nSteps: nSteps. 		sx := xDelta &gt;= 0 ifTrue: [pAx] ifFalse: [pBx - (nSteps*xDelta)].		yDelta := self deltaFrom: pAy to: pBy nSteps: nSteps. 		sy := yDelta &gt;= 0 ifTrue: [pAy] ifFalse: [pBy - (nSteps*yDelta)].		dstBitShift := destMSB						ifTrue:[32 - ((dx bitAnd: destPPW - 1) + 1 * destDepth)]						ifFalse:[(dx bitAnd: destPPW - 1) * destDepth].		(destX &lt; clipX) ifTrue:			["Advance increments if there was clipping in x"			sx := sx + (clipX - destX * xDelta).			sy := sy + (clipX - destX * yDelta)].		halftoneWord := noHalftone							ifTrue: [AllOnes]							ifFalse: [self halftoneAt: dy+i-1].		destMask := mask1.		nPix := startBits.		"Here is the inner loop..."		words := nWords.			["pick up word"			smoothingCount = 1				ifTrue: "Faster if not smoothing"					[skewWord := self warpPickSourcePixels: nPix										xDeltah: xDelta yDeltah: yDelta										xDeltav: deltaP12x yDeltav: deltaP12y										dstShiftInc: dstShiftInc]				ifFalse: "more difficult with smoothing"					[skewWord := self warpPickSmoothPixels: nPix										xDeltah: xDelta yDeltah: yDelta										xDeltav: deltaP12x yDeltav: deltaP12y										smoothing: smoothingCount										dstShiftInc: dstShiftInc].			"align next word access to left most pixel"			dstBitShift := dstShiftLeft.			destMask = AllOnes				ifTrue: "avoid read-modify-write"					[mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)										with: (self dstLongAt: destIndex).					self dstLongAt: destIndex put: (destMask bitAnd: mergeWord)]				ifFalse: "General version using dest masking"					[destWord := self dstLongAt: destIndex.					mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)										with: (destWord bitAnd: destMask).					destWord := (destMask bitAnd: mergeWord) bitOr:										(destWord bitAnd: destMask bitInvert32).					self dstLongAt: destIndex put: destWord].			destIndex := destIndex + 4.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask := mask2.						nPix := endBits]				ifFalse:["use fullword mask for inner loop"						destMask := AllOnes.						nPix := destPPW].			(words := words - 1) = 0] whileFalse.		"--- end of inner loop ---"		pAx := pAx + deltaP12x.		pAy := pAy + deltaP12y.		pBx := pBx + deltaP43x.		pBy := pBy + deltaP43y.		destIndex := destIndex + destDelta] "end 1 to: bbH do:"</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>vw bitblt compatibility</category><body package="HPSVM BitBlt Plugin" selector="byteArrayCopyBits:stride:width:x:y:source:stride:width:x:y:halftone:stride:width:heigth:rule:">byteArrayCopyBits: destByteArrayOop stride: destStrideOop width: destWidthOop x: destXOop y: destYOopsource: sourceByteArrayOrNilOop stride: sourceStrideOop width: sourceWidthOop x: sourceXOop y: sourceYOophalftone: tileByteArrayOrNilOop stride: tileStrideOopwidth: widthOop heigth: heightOop rule: ruleOop	| sourceStride destStride tileHeight tileStride |	((interpreterProxy isBytes: destByteArrayOop)	 and: [(sourceByteArrayOrNilOop = interpreterProxy nilObject		or: [interpreterProxy isBytes: sourceByteArrayOrNilOop])	 and: [tileByteArrayOrNilOop = interpreterProxy nilObject		or: [interpreterProxy isBytes: tileByteArrayOrNilOop]]]) ifFalse:		[interpreterProxy primitiveFail].	destWidth := interpreterProxy checkedIntegerValueOf: destWidthOop.	destStride := interpreterProxy checkedIntegerValueOf: destStrideOop.	"destHeight is computed below"	destX := interpreterProxy checkedIntegerValueOf: destXOop.	destY := interpreterProxy checkedIntegerValueOf: destYOop.	width := interpreterProxy checkedIntegerValueOf: widthOop.	height := interpreterProxy checkedIntegerValueOf: heightOop.	(destStride &lt;= 0 or: [destWidth &lt;= 0]) ifTrue:		[interpreterProxy primitiveFail].	(width &lt; 0 or: [height &lt; 0]) ifTrue:		[^destByteArrayOop].	destHeight := (interpreterProxy byteSizeOf: destByteArrayOop) / (destStride &lt;&lt; ShftUnitsToBytes).	combinationRule := interpreterProxy checkedIntegerValueOf: ruleOop.	(combinationRule &gt;= 0 and: [combinationRule &lt;= 15]) ifFalse:		[interpreterProxy primitiveFail].	(	destX &lt; 0	or: [destY &lt; 0	or: [destX + width &gt; destWidth	or: [destY + height &gt; destHeight]]]) ifTrue:		[interpreterProxy primitiveFail].	sourceByteArrayOrNilOop ~= interpreterProxy nilObject		ifTrue:			[sourceWidth := interpreterProxy checkedIntegerValueOf: sourceWidthOop.			 sourceStride := interpreterProxy checkedIntegerValueOf: sourceStrideOop.			 sourceX := interpreterProxy checkedIntegerValueOf: sourceXOop.			 sourceY := interpreterProxy checkedIntegerValueOf: sourceYOop.			  (	 sourceX &lt; 0			  or: [sourceY &lt; 0			  or: [sourceStride &lt;= 0			  or: [sourceWidth &lt;= 0]]]) ifTrue:				[interpreterProxy primitiveFail].			 sourceHeight := (interpreterProxy byteSizeOf: sourceByteArrayOrNilOop) / (sourceStride &lt;&lt; ShftUnitsToBytes).			 (	sourceX + width &gt; sourceWidth			 or: [sourceY + height &gt; sourceHeight]) ifTrue:				[interpreterProxy primitiveFail].			 sourcePPW := 32.			 sourceDepth := 1.			 sourcePitch := sourceStride &lt;&lt; ShftUnitsToBytes.			 sourceBits := self cCoerce: (interpreterProxy firstIndexableField: sourceByteArrayOrNilOop) to:'oopInt'.			sourceMSB := true.			noSource := self ruleIgnoresSource: combinationRule]		ifFalse:			[sourceX := sourceY := 0. noSource := true. sourceBits := nil].	tileByteArrayOrNilOop ~= interpreterProxy nilObject		ifTrue:			[tileStride := interpreterProxy checkedIntegerValueOf: tileStrideOop.			 tileStride ~= 1 ifTrue:				[interpreterProxy primitiveFail].			 tileHeight := (interpreterProxy byteSizeOf: tileByteArrayOrNilOop) / (tileStride &lt;&lt; ShftUnitsToBytes).			 tileHeight ~= 32 ifTrue:				[interpreterProxy primitiveFail].			 halftoneBase := self cCoerce: (interpreterProxy firstIndexableField: tileByteArrayOrNilOop) to:'oopInt'.			 halftoneHeight := tileHeight.			 noHalftone := self ruleIgnoresSource: combinationRule]		ifFalse:			[noHalftone := true].	destPPW := 32.	destDepth := 1.	destPitch := destStride &lt;&lt; ShftUnitsToBytes.	destBits := self cCoerce: (interpreterProxy firstIndexableField: destByteArrayOop) to:'oopInt'.	destMSB := true.	clipX := destX. clipY := destY. clipWidth := width. clipHeight := height.	srcCmFlags := dstCmFlags := 0.	"For checkOverlap we need destForm and sourceForm to have meaningful values"	destForm := destByteArrayOop.	sourceForm := sourceByteArrayOrNilOop.	((interpreterProxy isImmediateObject: destForm) not		and: [interpreterProxy isImmutableObject: destForm])			ifTrue: [^interpreterProxy primitiveFail].	self copyByteArrayBits.	interpreterProxy failed ifTrue:[^interpreterProxy primitiveFail].	self showDisplayBits.	interpreterProxy failed ifTrue:[^interpreterProxy primitiveFail].	^destByteArrayOop</body><body package="HPSVM BitBlt Plugin" selector="byteArrayCopyBits:stride:width:x:y:source:stride:width:x:y:width:heigth:rule:">byteArrayCopyBits: destByteArrayOop stride: destStrideOop width: destWidthOop x: destXOop y: destYOopsource: sourceByteArrayOrNilOop stride: sourceStrideOop width: sourceWidthOop x: sourceXOop y: sourceYOop width: widthOop heigth: heightOop rule: ruleOop	^self 		byteArrayCopyBits: destByteArrayOop		stride: destStrideOop		width: destWidthOop		x: destXOop		y: destYOop		source: sourceByteArrayOrNilOop		stride: sourceStrideOop		width: sourceWidthOop		x: sourceXOop		y: sourceYOop		halftone: interpreterProxy nilObject		stride: interpreterProxy zeroObject		width: widthOop		heigth: heightOop		rule: ruleOop</body><body package="HPSVM BitBlt Plugin" selector="copyByteArrayBits">copyByteArrayBits	"This function is exported for the Balloon engine"	self inline: true.	sourceAlpha := -1.	self clipRange.	(bbW &gt; 0 and: [bbH &gt; 0]) ifTrue:		[self copyBitsLockedAndClipped]</body><body package="HPSVM BitBlt Plugin" selector="initBitBltPrimitives">initBitBltPrimitives	self internal: true.	self static: false.	self returnTypeC: 'void'.	self cCode: 'oe_assert(sizeof(int) == sizeof(oop))'.	interpreterProxy		add: 933		C: (self cCoerce: #byteArrayCopyBitsstridewidthxysourcestridewidthxywidthheigthrule to: 'oop (*)()')		Primitive: 12.	interpreterProxy		add: 934		C: (self cCoerce: #tileArrayCopyBitsstridewidthxysourcestridewidthxywidthheigthrule to: 'oop (*)()')		Primitive: 12.	self initialiseModule.</body><body package="HPSVM BitBlt Plugin" selector="sourceBLT:stride:dest:stride:dx:dy:sx:sy:w:h:rule:doTile:">sourceBLT: sourceBitsArg stride: sourceStride dest: destBitsArg stride: destStride dx: dxArg dy: dyArg sx: sxArg sy: syArg w: w h: h rule: r doTile: doTile 	self export: true.	self returnTypeC: 'void'.	self var: #sourceBitsArg declareC: 'dispType *sourceBitsArg'.	self var: #sourceStride declareC: 'oopInt sourceStride'.	self var: #destBitsArg declareC: 'dispType *destBitsArg'.	self var: #destStride declareC: 'oopInt destStride'.	self var: #dxArg declareC: 'oopInt dxArg'.	self var: #dyArg declareC: 'oopInt dyArg'.	self var: #sxArg declareC: 'oopInt sxArg'.	self var: #syArg declareC: 'oopInt syArg'.	self var: #w declareC: 'oopInt w'.	self var: #h declareC: 'oopInt h'.	self var: #r declareC: 'oopInt r'.	self var: #doTile declareC: 'bool doTile'.	destWidth := destStride &lt;&lt; (ShftUnitsToBytes + 3).	destHeight := dyArg + h.	destX := dxArg.	destY := dyArg.	width := w.	height := h.	combinationRule := r.	(width &lt; 0 or: [height &lt; 0]) ifTrue:		[^self].	doTile		ifFalse:			[sourceWidth := sourceStride &lt;&lt; (ShftUnitsToBytes + 3).			 sourceHeight := syArg + h.			 sourceX := sxArg.			 sourceY := syArg.			 sourcePPW := 32.			 sourceDepth := 1.			 sourcePitch := sourceStride &lt;&lt; ShftUnitsToBytes.			 sourceBits := self cCoerce: sourceBitsArg to:'oopInt'.			 sourceMSB := true.			 noSource := self ruleIgnoresSource: combinationRule.			 noHalftone := true]		ifTrue:			[sourceX := sourceY := 0. noSource := true. sourceBits := nil.			 halftoneBase := self cCoerce: sourceBitsArg to:'oopInt'.			 noSource := true.			 noHalftone := self ruleIgnoresSource: combinationRule].	destPPW := 32.	destDepth := 1.	destPitch := destStride &lt;&lt; ShftUnitsToBytes.	destBits := self cCoerce: destBitsArg to:'oopInt'.	destMSB := true.	clipX := destX. clipY := destY. clipWidth := width. clipHeight := height.	srcCmFlags := dstCmFlags := 0.	"For checkOverlap we need destForm and sourceForm to have meaningful values"	destForm := self cCoerce: destBitsArg to:'oopInt'.	sourceForm := self cCoerce: sourceBitsArg to:'oopInt'.	self copyByteArrayBits</body><body package="HPSVM BitBlt Plugin" selector="tileArrayCopyBits:stride:width:x:y:source:stride:width:x:y:width:heigth:rule:">tileArrayCopyBits: destByteArrayOop stride: destStrideOop width: destWidthOop x: destXOop y: destYOopsource: sourceByteArrayOop stride: sourceStrideOop width: sourceWidthOop x: sourceXOop y: sourceYOop width: widthOop heigth: heightOop rule: ruleOop	^self 		byteArrayCopyBits: destByteArrayOop		stride: destStrideOop		width: destWidthOop		x: destXOop		y: destYOop		source: interpreterProxy nilObject		stride: interpreterProxy zeroObject		width: interpreterProxy zeroObject		x: interpreterProxy zeroObject		y: interpreterProxy zeroObject		halftone: sourceByteArrayOop		stride: sourceStrideOop		width: widthOop		heigth: heightOop		rule: ruleOop</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>setup</category><body package="HPSVM BitBlt Plugin" selector="checkSourceOverlap">checkSourceOverlap	"check for possible overlap of source and destination"	"ar 10/19/1999: This method requires surfaces to be locked."	| t |	self inline: true.	(sourceForm = destForm and: [dy &gt;= sy]) ifTrue:		[dy &gt; sy ifTrue:			["have to start at bottom"			vDir := -1.			sy := sy + bbH - 1.			dy := dy + bbH - 1]		ifFalse:			[(dy = sy) &amp; (dx &gt; sx) ifTrue:				["y's are equal, but x's are backward"				hDir := -1.				sx := sx + bbW - 1.				"start at right"				dx := dx + bbW - 1.				"and fix up masks"				nWords &gt; 1 ifTrue: 					[t := mask1.					mask1 := mask2.					mask2 := t]]].		"Dest inits may be affected by this change"		destIndex := destBits + (dy * destPitch) + ((dx // destPPW) *4).		destDelta := (destPitch * vDir) - (4 * (nWords * hDir))]</body><body package="HPSVM BitBlt Plugin" selector="clipRange">clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	destX &gt;= clipX		ifTrue: [sx := sourceX.				dx := destX.				bbW := width]		ifFalse: [sx := sourceX + (clipX - destX).				bbW := width - (clipX - destX).				dx := clipX].	(dx + bbW) &gt; (clipX + clipWidth)		ifTrue: [bbW := bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY &gt;= clipY		ifTrue: [sy := sourceY.				dy := destY.				bbH := height]		ifFalse: [sy := sourceY + clipY - destY.				bbH := height - (clipY - destY).				dy := clipY].	(dy + bbH) &gt; (clipY + clipHeight)		ifTrue: [bbH := bbH - ((dy + bbH) - (clipY + clipHeight))].	noSource ifTrue: [^ nil].	sx &lt; 0		ifTrue: [dx := dx - sx.				bbW := bbW + sx.				sx := 0].	sx + bbW &gt; sourceWidth		ifTrue: [bbW := bbW - (sx + bbW - sourceWidth)].	sy &lt; 0		ifTrue: [dy := dy - sy.				bbH := bbH + sy.				sy := 0].	sy + bbH &gt; sourceHeight		ifTrue: [bbH := bbH - (sy + bbH - sourceHeight)]</body><body package="HPSVM BitBlt Plugin" selector="copyBits">copyBits	"This function is exported for the Balloon engine"	self export: true.	self inline: false.	self clipRange.	(bbW &lt;= 0 or: [bbH &lt;= 0]) ifTrue:		["zero width or height; noop"		affectedL := affectedR := affectedT := affectedB := 0.		^ nil].	"Lock the surfaces"	self lockSurfaces ifFalse:[interpreterProxy primitiveFail. ^nil].	self copyBitsLockedAndClipped.	self unlockSurfaces.</body><body package="HPSVM BitBlt Plugin" selector="copyBitsFrom:to:at:">copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	self export: true.	destX := startX.	destY := yValue.	sourceX := startX.	width := (stopX - startX).	self copyBits.	self showDisplayBits.</body><body package="HPSVM BitBlt Plugin" selector="copyBitsLockedAndClipped">copyBitsLockedAndClipped	"Perform the actual copyBits operation.	Assume: Surfaces have been locked and clipping was performed."	| done |	self inline: true.	combinationRule &gt;= 30 ifTrue:		["Try a shortcut for stuff that should be run as quickly as possible" 		done := self tryCopyingBitsQuickly.		done ifTrue:[^nil].		(combinationRule = 30 or:[combinationRule = 31]) ifTrue:			["Check and fetch source alpha parameter for alpha blend"			(sourceAlpha &gt;= 0 and: [sourceAlpha &lt;= 255]) ifFalse:				[interpreterProxy primitiveFail. ^nil]]].	bitCount := 0.	"Choose and perform the actual copy loop."	self performCopyLoop.	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL := affectedR := affectedT := affectedB := 0]. 	hDir &gt; 0		ifTrue: [affectedL := dx.				affectedR := dx + bbW]		ifFalse: [affectedL := dx - bbW + 1.				affectedR := dx + 1].	vDir &gt; 0		ifTrue: [affectedT := dy.				affectedB := dy + bbH]		ifFalse: [affectedT := dy - bbH + 1.				affectedB := dy + 1]</body><body package="HPSVM BitBlt Plugin" selector="destMaskAndPointerInit">destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	self inline: true.	pixPerM1 := destPPW - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits := destPPW - (dx bitAnd: pixPerM1).	mask1 := destMSB				ifTrue:[ AllOnes &gt;&gt; (32 - (startBits*destDepth))] 				ifFalse:[ AllOnes &lt;&lt; (32 - (startBits*destDepth))].	"how many pixels in last word"	endBits := ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	mask2 := destMSB 				ifTrue:[AllOnes &lt;&lt; (32 - (endBits*destDepth))] 				ifFalse:[AllOnes &gt;&gt; (32 - (endBits*destDepth))].	"determine number of words stored per line; merge masks if only 1"	bbW &lt; startBits		ifTrue: [mask1 := mask1 bitAnd: mask2.				mask2 := 0.				nWords := 1]		ifFalse: [nWords := (bbW - startBits) + pixPerM1 // destPPW + 1].	hDir := vDir := 1. "defaults for no overlap with source"	"calculate byte addr and delta, based on first word of data"	"Note pitch is bytes and nWords is longs, not bytes"	destIndex := destBits + (dy * destPitch) + ((dx // destPPW) *4).	destDelta := destPitch * vDir - (4 * (nWords * hDir)).  "byte addr delta"</body><body package="HPSVM BitBlt Plugin" selector="failIfPalettesDoNotMatch">failIfPalettesDoNotMatch	| sourcePalette destPalette size |	sourceForm == destForm ifTrue: [^true].	sourcePalette := interpreterProxy fetchPointer: ImagePaletteIndex ofObject: sourceForm.	destPalette := interpreterProxy fetchPointer: ImagePaletteIndex ofObject: destForm.	sourcePalette == destPalette ifTrue: [^true].	size := interpreterProxy byteSizeOf: sourcePalette.	size ~= (interpreterProxy byteSizeOf: destPalette) ifTrue:		[^interpreterProxy primitiveFail].	1 to: size // 4 do:		[:i|		(interpreterProxy fetchPointer: i ofObject: sourcePalette) ~= (interpreterProxy fetchPointer: i ofObject: destPalette) ifTrue:			[^interpreterProxy primitiveFail]].	^true</body><body package="HPSVM BitBlt Plugin" selector="ignoreSourceOrHalftone:">ignoreSourceOrHalftone: formPointer	formPointer = interpreterProxy nilObject ifTrue: [ ^true ].	^self ruleIgnoresSource: combinationRule</body><body package="HPSVM BitBlt Plugin" selector="palettesMatch">palettesMatch	| sourcePalette destPalette size |	sourceForm == destForm ifTrue: [^true].	sourcePalette := interpreterProxy fetchPointer: ImagePaletteIndex ofObject: sourceForm.	destPalette := interpreterProxy fetchPointer: ImagePaletteIndex ofObject: destForm.	sourcePalette == destPalette ifTrue: [^true].	size := interpreterProxy byteSizeOf: sourcePalette.	size ~= (interpreterProxy byteSizeOf: destPalette) ifTrue:		[^interpreterProxy primitiveFail].	1 to: size // 4 do:		[:i|		(interpreterProxy fetchPointer: i ofObject: sourcePalette) ~= (interpreterProxy fetchPointer: i ofObject: destPalette) ifTrue:			[^false]].	^true</body><body package="HPSVM BitBlt Plugin" selector="performCopyLoop">performCopyLoop	"Based on the values provided during setup choose and	perform the appropriate inner loop function."	self inline: true.	"Should be inlined into caller for speed"	self destMaskAndPointerInit.	noSource 		ifTrue: 			["Simple fill loop"			self copyLoopNoSource]		ifFalse: 			["Loop using source and dest"			self checkSourceOverlap.			(sourceDepth ~= destDepth			 or: [sourceMSB ~= destMSB			 or: [srcCmFlags ~= 0]]) 				ifTrue: 					["If we must convert between pixel depths or use					  color lookups or swap pixels use the general version"					self copyLoopPixMap]				ifFalse: 					["Otherwise we simply copy pixels and can use a faster version"					self sourceSkewAndPointerInit.					self copyLoop]]</body><body package="HPSVM BitBlt Plugin" selector="ruleIgnoresSource:">ruleIgnoresSource: r	self inline: true.	^r = 0 or: [r = 5 or: [r = 10 or: [r = 15]]]</body><body package="HPSVM BitBlt Plugin" selector="sourceSkewAndPointerInit">sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	self inline: true.	pixPerM1 := destPPW - 1.  "A mask, assuming power of two"	sxLowBits := sx bitAnd: pixPerM1.	dxLowBits := dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir &gt; 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid := bbW min: destPPW - dxLowBits.		preload := (sxLowBits + dWid) &gt; pixPerM1]	ifFalse:		[dWid := bbW min: dxLowBits + 1.		preload := (sxLowBits - dWid + 1) &lt; 0].	"calculate right-shift skew from source to dest"	skew := sourceMSB				ifTrue:[(sxLowBits - dxLowBits) * destDepth] 				ifFalse:[(dxLowBits - sxLowBits) * destDepth].  " -32..32 "	preload ifTrue: 		[skew := skew &lt; 0					ifTrue: [skew+32]					ifFalse: [skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex := sourceBits + (sy * sourcePitch) + ((sx // (32//sourceDepth)) *4).	"calculate increments from end of 1 line to start of next"	sourceDelta := (sourcePitch * vDir) - (4 * (nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta := sourceDelta - (4*hDir)].</body><body package="HPSVM BitBlt Plugin" selector="tryCopyingBitsQuickly">tryCopyingBitsQuickly	"Shortcut for stuff that's being run from the balloon engine.	Since we do this at each scan line we should avoid the expensive 	setup for source and destination."	self inline: true.	"We need a source."	noSource ifTrue:[^false].	"We handle only combinationRule 34"	(combinationRule = 34) ifFalse:[^false].	"We handle only sourceDepth 32"	(sourceDepth = 32) ifFalse:[^false].	"We don't handle overlaps"	(sourceForm = destForm) ifTrue:[^false].	"We need at least 8bit deep dest forms"	(destDepth &lt; 8) ifTrue:[^false].	"If 8bit, then we want a color map"	(destDepth = 8 and:[(dstCmFlags bitAnd: ColorMapPresent) = 0]) ifTrue:[^false].	destDepth = 32 		ifTrue:[self alphaSourceBlendBits32].	destDepth = 16		ifTrue:[self alphaSourceBlendBits16].	destDepth = 8		ifTrue:[self alphaSourceBlendBits8].	affectedL := dx.	affectedR := dx + bbW.	affectedT := dy.	affectedB := dy + bbH.	^true</body><body package="HPSVM BitBlt Plugin" selector="warpBitsSmoothing:">warpBitsSmoothing: smoothingCount	| ns |	self inline: true.	ns := noSource.	noSource := true.	self clipRange.	"noSource suppresses sourceRect clipping"	noSource := ns.	(noSource or: [bbW &lt;= 0 or: [bbH &lt;= 0]]) ifTrue: 		["zero width or height; noop"		affectedL := affectedR := affectedT := affectedB := 0.		^nil].	self lockSurfaces.	self destMaskAndPointerInit.	self warpLoopSmoothing: smoothingCount.	hDir &gt; 0 		ifTrue: 			[affectedL := dx.			affectedR := dx + bbW]		ifFalse: 			[affectedL := dx - bbW + 1.			affectedR := dx + 1].	vDir &gt; 0 		ifTrue: 			[affectedT := dy.			affectedB := dy + bbH]		ifFalse: 			[affectedT := dy - bbH + 1.			affectedB := dy + 1].	self unlockSurfaces</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>pixel mapping</category><body package="HPSVM BitBlt Plugin" selector="default8To32Table">default8To32Table	"Return the default translation table from 1..8 bit indexed colors to 32bit"	"The table has been generated by the following statements"	"| pvs hex |	String streamContents:[:s|		s nextPutAll:'static unsigned int theTable[256] = { '.		pvs := (Color colorMapIfNeededFrom: 8 to: 32) asArray.		1 to: pvs size do:[:i|			i &gt; 1 ifTrue:[s nextPutAll:', '].			(i-1 \\ 8) = 0 ifTrue:[s cr].			s nextPutAll:'0x'.			hex := (pvs at: i) printStringBase: 16.			s nextPutAll: (hex copyFrom: 4 to: hex size).		].		s nextPutAll:'};'.	]."	| theTable |	self returnTypeC:'unsigned int *'.	self var: #theTable declareC:'static unsigned int theTable[256] = { 0x0, 0xFF000001, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF, 0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050, 0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7, 0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7, 0xFF000001, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333, 0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966, 0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99, 0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF, 0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900, 0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33, 0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399, 0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC, 0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF, 0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333, 0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966, 0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99, 0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF, 0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900, 0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33, 0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399, 0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC, 0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF, 0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333, 0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966, 0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99, 0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF, 0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900, 0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33, 0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399, 0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC, 0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF};'.	^theTable</body><body package="HPSVM BitBlt Plugin" selector="deltaFrom:to:nSteps:">deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments."	self inline: true.	x2 &gt; x1		ifTrue: [^ x2 - x1 + FixedPt1 // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + FixedPt1 // (n+1) + 1)]</body><body package="HPSVM BitBlt Plugin" selector="dither32To16:threshold:">dither32To16: srcWord threshold: ditherValue	"Dither the given 32bit word to 16 bit. Ignore alpha."	| pv threshold value out |	self inline: true. "You bet"	pv := srcWord bitAnd: 255.	threshold := ditherThresholds16 at: (pv bitAnd: 7).	value := ditherValues16 at: (pv bitShift: -3).	ditherValue &lt; threshold		ifTrue:[out := value + 1]		ifFalse:[out := value].	pv := (srcWord bitShift: -8) bitAnd: 255.	threshold := ditherThresholds16 at: (pv bitAnd: 7).	value := ditherValues16 at: (pv bitShift: -3).	ditherValue &lt; threshold		ifTrue:[out := out bitOr: (value+1 bitShift:5)]		ifFalse:[out := out bitOr: (value bitShift: 5)].	pv := (srcWord bitShift: -16) bitAnd: 255.	threshold := ditherThresholds16 at: (pv bitAnd: 7).	value := ditherValues16 at: (pv bitShift: -3).	ditherValue &lt; threshold		ifTrue:[out := out bitOr: (value+1 bitShift:10)]		ifFalse:[out := out bitOr: (value bitShift: 10)].	^out</body><body package="HPSVM BitBlt Plugin" selector="pickWarpPixelAtX:y:">pickWarpPixelAtX: xx y: yy	"Pick a single pixel from the source for WarpBlt.	Note: This method is crucial for WarpBlt speed w/o smoothing	and still relatively important when smoothing is used."	| x y srcIndex sourceWord sourcePix |	self inline: true. "*please*"	"note: it would be much faster if we could just	avoid these stupid tests for being inside sourceForm."	(xx &lt; 0 or:[yy &lt; 0 or:[		(x := xx &gt;&gt; BinaryPoint) &gt;= sourceWidth or:[			(y := yy &gt;&gt; BinaryPoint) &gt;= sourceHeight]]]) ifTrue:[^0]. "out of bounds"	"Fetch source word.	Note: We should really update srcIndex with sx and sy so that	we don't have to do the computation below. We might even be	able to simplify the out of bounds test from above."	srcIndex := sourceBits + (y * sourcePitch) + (x &gt;&gt; warpAlignShift * 4).	sourceWord := self srcLongAt: srcIndex.	"Extract pixel from word"	srcBitShift := warpBitShiftTable at: (x bitAnd: warpAlignMask).	sourcePix := sourceWord &gt;&gt; srcBitShift bitAnd: warpSrcMask.	^sourcePix</body><body package="HPSVM BitBlt Plugin" selector="warpLoopSetup">warpLoopSetup	"Setup values for faster pixel fetching."	| words warpSrcShift |	self inline: true.	"warpSrcShift = log2(sourceDepth)"	warpSrcShift := 0.	words := sourceDepth. "recycle temp"	[words = 1] whileFalse:[		warpSrcShift := warpSrcShift + 1.		words := words &gt;&gt; 1].	"warpSrcMask = mask for extracting one pixel from source word"	warpSrcMask := maskTable at: sourceDepth.	"warpAlignShift: Shift for aligning x position to word boundary"	warpAlignShift := 5 - warpSrcShift.	"warpAlignMask: Mask for extracting the pixel position from an x position"	warpAlignMask := 1 &lt;&lt; warpAlignShift - 1.	"Setup the lookup table for source bit shifts"	"warpBitShiftTable: given an sub-word x value what's the bit shift?"	0 to: warpAlignMask do:[:i|		sourceMSB			ifTrue:[warpBitShiftTable at: i put: 32 - ( i + 1 &lt;&lt; warpSrcShift )]			ifFalse:[warpBitShiftTable at: i put: (i &lt;&lt; warpSrcShift)]].</body><body package="HPSVM BitBlt Plugin" selector="warpPickSmoothPixels:xDeltah:yDeltah:xDeltav:yDeltav:smoothing:dstShiftInc:">warpPickSmoothPixels: nPixels	xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n	dstShiftInc: dstShiftInc	"Pick n (sub-) pixels from the source form, mapped by sourceMap,	average the RGB values, map by colorMap and return the new word.	This version is only called from WarpBlt with smoothingCount &gt; 1"	| rgb x y a r g b xx yy xdh ydh xdv ydv dstMask destWord i j k nPix |	self inline: false. "nope - too much stuff in here"	dstMask := maskTable at: destDepth.	destWord := 0.	n = 2 "Try avoiding divides for most common n (divide by 2 is generated as shift)"		ifTrue:[xdh := xDeltah // 2. ydh := yDeltah // 2. 				xdv := xDeltav // 2. ydv := yDeltav // 2]		ifFalse:[xdh := xDeltah // n. ydh := yDeltah // n. 				xdv := xDeltav // n. ydv := yDeltav // n].	i := nPixels.	[		x := sx. y := sy.		a := r := g := b := 0.		"Pick and average n*n subpixels"		nPix := 0.  "actual number of pixels (not clipped and not transparent)"		j := n.		[			xx := x. yy := y.			k := n.			[				"get a single subpixel"				rgb := self pickWarpPixelAtX: xx y: yy.				(combinationRule=25 "PAINT") ifFalse:[					"If not clipped and not transparent, then tally rgb values"					nPix := nPix + 1.					(srcCmFlags bitAnd: ColorMapFixedPart) ~= 0						ifTrue:							[r := r + ((rgb bitAnd: (srcCmMasks at: RedIndex)) &gt;&gt; (srcCmShifts at: RedIndex)).							g := g + ((rgb bitAnd: (srcCmMasks at: GreenIndex)) &gt;&gt; (srcCmShifts at: GreenIndex)).							b := b + ((rgb bitAnd: (srcCmMasks at: BlueIndex)) &gt;&gt; (srcCmShifts at: BlueIndex)).							a := a + ((rgb bitAnd: (srcCmMasks at: AlphaIndex)) &gt;&gt; (srcCmShifts at: AlphaIndex))]						ifFalse:							[rgb := srcExpandedLookupTable at: (rgb bitAnd: srcCmMask).							r := r + (rgb &gt;&gt; 16 bitAnd: 255).							g := g + (rgb &gt;&gt; 8 bitAnd: 255).							 b := b + (rgb bitAnd: 255).							a := a + (rgb &gt;&gt; 24)]].				xx := xx + xdh.				yy := yy + ydh.			(k := k - 1) = 0] whileFalse.			x := x + xdv.			y := y + ydv.		(j := j - 1) = 0] whileFalse.		(nPix = 0 or: [combinationRule=25 "PAINT" and: [nPix &lt; (n * n // 2)]])			ifTrue:[rgb := 0  "All pixels were 0, or most were transparent"]			ifFalse:				["normalize rgba sums"				nPix = 4 "Try to avoid divides for most common n"					ifTrue:[r := r &gt;&gt; 2. g := g &gt;&gt; 2.	 b := b &gt;&gt; 2. a := a &gt;&gt; 2]					ifFalse:[r := r // nPix. g := g // nPix. b := b // nPix. a := a // nPix].				rgb := ((a &lt;&lt; (dstCmShifts at: AlphaIndex)) bitAnd: (dstCmMasks at: AlphaIndex))						+ ((r &lt;&lt; (dstCmShifts at: RedIndex)) bitAnd: (dstCmMasks at: RedIndex))						+ ((g &lt;&lt; (dstCmShifts at: GreenIndex)) bitAnd: (dstCmMasks at: GreenIndex))						+ ((b &lt;&lt; (dstCmShifts at: BlueIndex)) bitAnd: (dstCmMasks at: BlueIndex)).				"map the pixel"				rgb = 0 ifTrue:					["only generate zero if pixel is really transparent"					(r + g + b + a) &gt; 0 ifTrue:						[rgb := (1 &lt;&lt; (dstCmShifts at: RedIndex))							  + (1 &lt;&lt; (dstCmShifts at: GreenIndex))							  + (1 &lt;&lt; (dstCmShifts at: BlueIndex))]]].		"Mix it in"		destWord := destWord bitOr: (rgb bitAnd: dstMask) &lt;&lt; dstBitShift.		dstBitShift := dstBitShift + dstShiftInc.		sx := sx + xDeltah.		sy := sy + yDeltah.	(i := i - 1) = 0] whileFalse.	^destWord</body><body package="HPSVM BitBlt Plugin" selector="warpPickSourcePixels:xDeltah:yDeltah:xDeltav:yDeltav:dstShiftInc:">warpPickSourcePixels: nPixels xDeltah: xDeltah yDeltah: yDeltah xDeltav: xDeltav yDeltav: yDeltav dstShiftInc: dstShiftInc	"Pick n pixels from the source form,	map by colorMaps and return aligned by dstBitShift.	This version is only called from WarpBlt with smoothingCount = 1"	| dstMask destWord nPix sourcePix destPix |	self inline: true.	"Yepp - this should go into warpLoop"	dstMask := maskTable at: destDepth.	destWord := 0.	nPix := nPixels.	(srcCmFlags bitAnd: ColorMapIndexedPart) ~= 0		ifTrue:			["a little optimization for (pretty crucial) blits using indexed lookups only"			["grab, colormap and mix in pixel"			sourcePix := self pickWarpPixelAtX: sx y: sy.			destPix := srcExpandedLookupTable at: (sourcePix bitAnd: srcCmMask).			destPix := self mapDestPixel: destPix.			destWord := destWord bitOr: (destPix bitAnd: dstMask) &lt;&lt; dstBitShift.			dstBitShift := dstBitShift + dstShiftInc.			sx := sx + xDeltah.			sy := sy + yDeltah.			(nPix := nPix - 1) &gt; 0]				whileTrue]		ifFalse:			[			["grab, colormap and mix in pixel"			sourcePix := self pickWarpPixelAtX: sx y: sy.			destPix := self mapSourcePixel: sourcePix.			destPix := self mapDestPixel: destPix.			destWord := destWord bitOr: (destPix bitAnd: dstMask) &lt;&lt; dstBitShift.			dstBitShift := dstBitShift + dstShiftInc.			sx := sx + xDeltah.			sy := sy + yDeltah.			(nPix := nPix - 1) &gt; 0]				whileTrue].	^destWord</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>interpreter interface</category><body package="HPSVM BitBlt Plugin" selector="drawLoopX:Y:">drawLoopX: xDelta Y: yDelta 	"This is the primitive implementation of the line-drawing loop.	See the comments in BitBlt&gt;&gt;drawLoopX:Y:"	| dx1 dy1 px py P affL affR affT affB |	xDelta &gt; 0		ifTrue: [dx1 := 1]		ifFalse: [xDelta = 0				ifTrue: [dx1 := 0]				ifFalse: [dx1 := -1]].	yDelta &gt; 0		ifTrue: [dy1 := 1]		ifFalse: [yDelta = 0				ifTrue: [dy1 := 0]				ifFalse: [dy1 := -1]].	px := yDelta abs.	py := xDelta abs.	affL := affT := 9999.  "init null rectangle"	affR := affB := -9999.	py &gt; px		ifTrue: 			["more horizontal"			P := py // 2.			1 to: py do: 				[:i |				destX := destX + dx1.				(P := P - px) &lt; 0 ifTrue: 					[destY := destY + dy1.					P := P + py].				i &lt; py ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL &lt; affectedR and: [affectedT &lt; affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL := affL min: affectedL.						affR := affR max: affectedR.						affT := affT min: affectedT.						affB := affB max: affectedB.						(affR - affL) * (affB - affT) &gt; 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL := affL.  affectedR := affR.							affectedT := affT.  affectedB := affB.							self showDisplayBits.							affL := affT := 9999.  "init null rectangle"							affR := affB := -9999]].					]]]		ifFalse: 			["more vertical"			P := px // 2.			1 to: px do:				[:i |				destY := destY + dy1.				(P := P - py) &lt; 0 ifTrue: 					[destX := destX + dx1.					P := P + px].				i &lt; px ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL &lt; affectedR and: [affectedT &lt; affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL := affL min: affectedL.						affR := affR max: affectedR.						affT := affT min: affectedT.						affB := affB max: affectedB.						(affR - affL) * (affB - affT) &gt; 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL := affL.  affectedR := affR.							affectedT := affT.  affectedB := affB.							self showDisplayBits.							affL := affT := 9999.  "init null rectangle"							affR := affB := -9999]].					]]].	"Remaining affected rect"	affectedL := affL.  affectedR := affR.	affectedT := affT.  affectedB := affB.	"store destX, Y back"		interpreterProxy storeInteger: RRDestXIndex ofObject: bitBltOop withValue: destX.	interpreterProxy storeInteger: RRDestYIndex ofObject: bitBltOop withValue: destY.</body><body package="HPSVM BitBlt Plugin" selector="fetchIntOrFloat:ofObject:">fetchIntOrFloat: fieldIndex ofObject: objectPointer	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	| fieldOop floatValue |	self var: #floatValue declareC:'double floatValue'.	fieldOop := interpreterProxy fetchPointer: fieldIndex ofObject: objectPointer.	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	floatValue := interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 &lt;= floatValue and:[floatValue &lt;= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail. ^0].	^floatValue asInteger</body><body package="HPSVM BitBlt Plugin" selector="fetchIntOrFloat:ofObject:ifNil:">fetchIntOrFloat: fieldIndex ofObject: objectPointer ifNil: defaultValue	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	| fieldOop floatValue |	self var: #floatValue declareC:'double floatValue'.	fieldOop := interpreterProxy fetchPointer: fieldIndex ofObject: objectPointer.	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	(fieldOop = interpreterProxy nilObject) ifTrue:[^defaultValue].	floatValue := interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 &lt;= floatValue and:[floatValue &lt;= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail. ^0].	^floatValue asInteger</body><body package="HPSVM BitBlt Plugin" selector="loadBitBltDestForm">loadBitBltDestForm	"Load the dest form for BitBlt. Return false if anything is wrong, true otherwise."	| destBitsSize |	self inline: true.	((interpreterProxy isPointers: destForm)	and: [(interpreterProxy slotSizeOf: destForm) &gt; ImagePaletteIndex]) ifFalse:		[^interpreterProxy primitiveFail].	destBits := interpreterProxy fetchPointer: ImageBitsIndex ofObject: destForm.	destWidth := interpreterProxy fetchInteger: ImageWidthIndex ofObject: destForm.	destHeight := interpreterProxy fetchInteger: ImageHeightIndex ofObject: destForm.	(destWidth &gt;= 0 and: [destHeight &gt;= 0]) ifFalse:		[^interpreterProxy primitiveFail].	destDepth := interpreterProxy fetchInteger: ImageBitsPerPixelIndex ofObject: destForm.	destMSB := destDepth &gt; 0.	destDepth := destDepth abs.	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isImmediateObject: destBits)		ifTrue:			[(interpreterProxy isIntegerObject: destBits) ifFalse:				[^interpreterProxy primitiveFail].			"Query for actual surface dimensions"			(self queryDestSurface: (interpreterProxy integerValueOf: destBits)) ifFalse:				[^interpreterProxy primitiveFail].			destPPW := 32 // destDepth.			destBits := destPitch := 0]		ifFalse:			[(interpreterProxy isImmutableObject: destBits) ifTrue:				[^interpreterProxy primitiveFail].			destPPW := 32 // destDepth.			destPitch := destWidth + (destPPW-1) // destPPW * 4.			destBitsSize := interpreterProxy byteSizeOf: destBits.			((interpreterProxy isBytes: destBits)			 and: [destBitsSize = (destPitch * destHeight)])				ifFalse: [^interpreterProxy primitiveFail].			"Skip header since external bits don't have one"			destBits := self cCoerce: (interpreterProxy firstIndexableField: destBits) to:'oopInt'].	dstCmFlags := self loadColorMapFrom: (interpreterProxy													fetchPointer: ImagePaletteIndex													ofObject: destForm)						intoCLUT: dstExpandedLookupTable						shifts: dstCmShifts						masks: dstCmMasks.	dstCmMask := dstCmMasks at: 4.	^true</body><body package="HPSVM BitBlt Plugin" selector="loadBitBltFrom:">loadBitBltFrom: bbObj	"Load BitBlt from the oop.	This function is exported for the Balloon engine."	self export: true.	^self loadBitBltFrom: bbObj warping: false.</body><body package="HPSVM BitBlt Plugin" selector="loadBitBltFrom:warping:">loadBitBltFrom: bbObj warping: aBool	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!"	| halftoneForm |	self inline: false.	bitBltOop := bbObj.	isWarping := aBool.	combinationRule := interpreterProxy fetchInteger: RRCombinationRuleIndex ofObject: bitBltOop.	(combinationRule &lt; 0	 or: [combinationRule &gt; (OpTableSize - 2)	 or: [(opTable at: combinationRule + 1) = nil]]) ifTrue:		[^interpreterProxy primitiveFail  "operation out of range"].	sourceForm := interpreterProxy fetchPointer: RRSourceIndex ofObject: bitBltOop.	noSource := self ignoreSourceOrHalftone: sourceForm.	halftoneForm := interpreterProxy fetchPointer: RRHalftoneIndex ofObject: bitBltOop.	noHalftone := self ignoreSourceOrHalftone: halftoneForm.	destForm := interpreterProxy fetchPointer: RRDestinationIndex ofObject: bbObj.	self loadBitBltDestForm.	destX := self fetchIntOrFloat: RRDestXIndex ofObject: bitBltOop ifNil: 0.	destY := self fetchIntOrFloat: RRDestYIndex ofObject: bitBltOop ifNil: 0.	width := self fetchIntOrFloat: RRWidthIndex ofObject: bitBltOop ifNil: destWidth.	height := self fetchIntOrFloat: RRHeightIndex ofObject: bitBltOop ifNil: destHeight.	noSource		ifTrue:			[sourceX := sourceY := 0. srcCmFlags := 0]		ifFalse: 			[self loadBitBltSourceForm.			sourceX := self fetchIntOrFloat: RRSourceXIndex ofObject: bitBltOop ifNil: 0.			sourceY := self fetchIntOrFloat: RRSourceYIndex ofObject: bitBltOop ifNil: 0.			"Temporary hack to avoid using copyBitsPixMap which is currently broken			 in at least source+halftone and overlapping dest cases."			(combinationRule &lt;= 16			and: [destDepth = sourceDepth			and: [	sourceForm = destForm					or: [self palettesMatch]]]) ifTrue:				[srcCmFlags := dstCmFlags := 0]].	noHalftone ifFalse: [self loadHalftoneForm: halftoneForm].	clipX := self fetchIntOrFloat: RRClipXIndex ofObject: bitBltOop ifNil: 0.	clipY := self fetchIntOrFloat: RRClipYIndex ofObject: bitBltOop ifNil: 0.	clipWidth := self fetchIntOrFloat: RRClipWidthIndex ofObject: bitBltOop ifNil: destWidth.	clipHeight := self fetchIntOrFloat: RRClipHeightIndex ofObject: bitBltOop ifNil: destHeight.	clipX &lt; 0 ifTrue: [clipWidth := clipWidth + clipX.  clipX := 0].	clipY &lt; 0 ifTrue: [clipHeight := clipHeight + clipY.  clipY := 0].	clipX+clipWidth &gt; destWidth ifTrue: [clipWidth := destWidth - clipX].	clipY+clipHeight &gt; destHeight ifTrue: [clipHeight := destHeight - clipY].	^ true</body><body package="HPSVM BitBlt Plugin" selector="loadBitBltSourceForm">loadBitBltSourceForm	"Load the source form for BitBlt. Return false if anything is wrong, true otherwise."	| sourceBitsSize |	self inline: true.	((interpreterProxy isPointers: sourceForm)	 and: [(interpreterProxy slotSizeOf: sourceForm) &gt; ImagePaletteIndex]) ifFalse:		[^interpreterProxy primitiveFail].	sourceBits := interpreterProxy fetchPointer: ImageBitsIndex ofObject: sourceForm.	sourceWidth := interpreterProxy fetchInteger: ImageWidthIndex ofObject: sourceForm.	sourceHeight := interpreterProxy fetchInteger: ImageHeightIndex ofObject: sourceForm.	(sourceWidth &gt;= 0 and: [sourceHeight &gt;= 0]) ifFalse:		[^interpreterProxy primitiveFail].	sourceDepth := interpreterProxy fetchInteger: ImageBitsPerPixelIndex ofObject: sourceForm.	sourceMSB := sourceDepth &gt; 0.	sourceDepth := sourceDepth abs.	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isImmediateObject: sourceBits)		ifTrue:			[(interpreterProxy isIntegerObject: sourceBits) ifFalse:				[^interpreterProxy primitiveFail].			"Query for actual surface dimensions"			(self querySourceSurface: (interpreterProxy integerValueOf: sourceBits)) ifFalse:				[^interpreterProxy primitiveFail].			sourcePPW := 32 // sourceDepth.			sourceBits := sourcePitch := 0]	ifFalse:		[sourcePPW := 32 // sourceDepth.		sourcePitch := sourceWidth + (sourcePPW-1) // sourcePPW * 4.		sourceBitsSize := interpreterProxy byteSizeOf: sourceBits.		((interpreterProxy isBytes: sourceBits)		 and: [sourceBitsSize = (sourcePitch * sourceHeight)])			ifFalse: [^interpreterProxy primitiveFail].		"Skip header since external bits don't have one"		sourceBits := self cCoerce: (interpreterProxy firstIndexableField: sourceBits) to:'oopInt'].	srcCmFlags := self loadColorMapFrom: (interpreterProxy													fetchPointer: ImagePaletteIndex													ofObject: sourceForm)						intoCLUT: srcExpandedLookupTable						shifts: srcCmShifts						masks: srcCmMasks.	srcCmMask := srcCmMasks at: 4.	^true</body><body package="HPSVM BitBlt Plugin" selector="loadColorMapFrom:intoCLUT:shifts:masks:">loadColorMapFrom: paletteOop intoCLUT: expandedCLUT shifts: shifts masks: masks	"A lookup table is either a MappedPalette of 3 words per pixel:		8191 (ColorValue.MaxValue) the max of each color stimulus;		65535 (MappedPalette.UnallocatedEntryValue) == unallocated	 or a FixedPalette of three or four pairs of shifts and masks.	 Answer the flags identifying which form of palette was found.	 Answer the pixel mask for a lookup palette in the extra mask entry"	| cmSize clutOop shift mask clutBits i j pv pixelMask |	self inline: true.	self var: #expandedCLUT declareC: 'unsigned int expandedCLUT[]'.	self var: #shifts declareC: 'int shifts[]'.	self var: #masks declareC: 'unsigned int masks[]'.	self var: #clutBits declareC: 'unsigned short *clutBits'.	((interpreterProxy isPointers: paletteOop) 	 and:[(interpreterProxy slotSizeOf: paletteOop) &gt;= 3]) ifFalse:		[^interpreterProxy primitiveFail].	clutOop := interpreterProxy fetchPointer: 1 ofObject: paletteOop.	((interpreterProxy isImmediateObject: clutOop) not	 and: [interpreterProxy isBytes: clutOop])		ifTrue:			["A lookup table of 3 words per pixel:				8191 (ColorValue.MaxValue) the max of each color stimulus;				65535 (MappedPalette.UnallocatedEntryValue) == unallocated"			cmSize := (interpreterProxy byteSizeOf: clutOop).			clutBits := interpreterProxy firstIndexableField: clutOop.			"Note that we *don''t* insist there is one entry in the clut for every pixel.			 VisualWorks palettes only have entries for the pixels actually used.  So			 we trust the image to get it right."			((cmSize \\ 6) ~= 0 or: [false and: [(cmSize / 6 bitAnd: cmSize / 6 - 1) ~= 0]]) ifTrue:				[^interpreterProxy primitiveFail].			cmSize := cmSize / 6.			pixelMask := 1.			[pixelMask &lt; cmSize] whileTrue:				[pixelMask := pixelMask + pixelMask + 1].			masks at: 4 put: pixelMask.			"Compute the 32-bit-per-pixel RGBA clut in advance"			i := j := 0.			[i &lt; cmSize] whileTrue:				[pv := (((clutBits at: j) &gt;&gt; 5) &lt;&lt; 16 "red")					+ (((clutBits at: j + 1) &gt;&gt; 5) &lt;&lt; 8 "green")					+ (((clutBits at: j + 2) &gt;&gt; 5) &lt;&lt; 0 "blue").				 expandedCLUT at: i put: pv.				 i := i + 1.				 j := j + 3].			^ColorMapPresent bitOr: ColorMapIndexedPart]		ifFalse:			["a shift/mask table (make this a loop from 0 to 3)"			(interpreterProxy slotSizeOf: paletteOop) &gt;= 6 ifFalse: [^interpreterProxy primitiveFail].			i := j := 0.			[i &lt; 3] whileTrue:				[shift := (interpreterProxy checkedIntegerValueOf:							(interpreterProxy fetchPointer: j ofObject: paletteOop)).				mask:= (interpreterProxy checkedIntegerValueOf:							(interpreterProxy fetchPointer: j + 1 ofObject: paletteOop)).				shifts at: i put: shift.				masks at: i put: (mask &lt;&lt; shift).				i := i + 1.				j := j + 2].			((interpreterProxy slotSizeOf: paletteOop) &gt;= 8			and: [(interpreterProxy isIntegerObject: (shift := interpreterProxy fetchPointer: 6 ofObject: paletteOop))			and: [interpreterProxy isIntegerObject: (mask := interpreterProxy fetchPointer: 7 ofObject: paletteOop)]])				ifTrue:					[masks at: AlphaIndex put: (mask &lt;&lt; shift).					 shifts at: AlphaIndex put: shift]				ifFalse:					[masks at: AlphaIndex put: (srcCmShifts at: AlphaIndex put: 0)].			^(ColorMapPresent bitOr: ColorMapFixedPart)]</body><body package="HPSVM BitBlt Plugin" selector="loadHalftoneForm:">loadHalftoneForm: halftoneForm	"Load the halftone form"	| halftoneBits |	self inline: true.	noHalftone ifTrue:		[self cCode: '' inSmalltalk: [halftoneBase := nil].		^true].	((interpreterProxy isPointers: halftoneForm)	 and: [(interpreterProxy slotSizeOf: halftoneForm) &gt;= 4]) ifFalse:		[^interpreterProxy primitiveFail].	halftoneBits := interpreterProxy fetchPointer: ImageBitsIndex ofObject: halftoneForm.	halftoneHeight := interpreterProxy fetchInteger: ImageHeightIndex ofObject: halftoneForm.	(interpreterProxy isBytes: halftoneBits) ifFalse:		[^interpreterProxy primitiveFail].	halftoneBase := self cCoerce: (interpreterProxy firstIndexableField: halftoneBits) to:'oopInt'.	^true</body><body package="HPSVM BitBlt Plugin" selector="showDisplayBits">showDisplayBits	interpreterProxy 		showDisplayBits: destForm		Left: affectedL		Top: affectedT		Right: affectedR		Bottom: affectedB</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>memory access</category><body package="HPSVM BitBlt Plugin" selector="dstLongAt:">dstLongAt: idx	| v |	self inline: true.	v := interpreterProxy longAt: idx.	^destMSB ~= bigEndian		ifTrue: [interpreterProxy byteSwapped: v]		ifFalse: [v]</body><body package="HPSVM BitBlt Plugin" selector="dstLongAt:put:">dstLongAt: idx put: value	self inline: true.	interpreterProxy		longAt: idx		put: (destMSB ~= bigEndian				ifTrue: [interpreterProxy byteSwapped: value]				ifFalse: [value])</body><body package="HPSVM BitBlt Plugin" selector="dstLongAt:put:mask:">dstLongAt: idx put: srcValue mask: dstMask	"Store the given value back into destination form, using dstMask	to mask out the bits to be modified. This is an essiantial	read-modify-write operation on the destination form."	| dstValue |	self inline: true.	dstValue := self dstLongAt: idx.	dstValue := dstValue bitAnd: dstMask.	dstValue := dstValue bitOr: srcValue.	self dstLongAt: idx put: dstValue.</body><body package="HPSVM BitBlt Plugin" selector="halftoneAt:">halftoneAt: idx	"Return a value from the halftone pattern."	^interpreterProxy longAt: halftoneBase + (idx \\ halftoneHeight * 4)</body><body package="HPSVM BitBlt Plugin" selector="srcLongAt:">srcLongAt: idx	| v |	self inline: true.	v := interpreterProxy longAt: idx.	^bigEndian ~= sourceMSB		ifTrue: [interpreterProxy byteSwapped: v]		ifFalse: [v]</body><body package="HPSVM BitBlt Plugin" selector="tableLookup:at:">tableLookup: table at: index	"Note: Nasty coercion only necessary for the non-inlined version of this method in C. Duh? Oh well, here's the full story. The code below will definitely be inlined so everything that calls this method is fine. But... the translator doesn't quite prune this method so it generates a C function that tries to attempt an array access on an int - and most compilers don't like this. If you don't know what I'm talking about try to remove the C coercion and you'll see what happens when you try to compile a new VM..."	^(self cCoerce: table to:'int*') at: index</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>surface support</category><body package="HPSVM BitBlt Plugin" selector="loadSurfacePlugin">loadSurfacePlugin	"Load the surface support plugin"	querySurfaceFn := interpreterProxy ioLoadFunction:'ioGetSurfaceFormat' From:'SurfacePlugin'.	lockSurfaceFn := interpreterProxy ioLoadFunction:'ioLockSurface' From:'SurfacePlugin'.	unlockSurfaceFn := interpreterProxy ioLoadFunction:'ioUnlockSurface' From:'SurfacePlugin'.	^querySurfaceFn ~= 0 and:[lockSurfaceFn ~= 0 and:[unlockSurfaceFn ~= 0]]</body><body package="HPSVM BitBlt Plugin" selector="lockSurfaces">lockSurfaces	"Get a pointer to the bits of any OS surfaces."	"Notes: 	* For equal source/dest handles only one locking operation is performed.	This is to prevent locking of overlapping areas which does not work with	certain APIs (as an example, DirectDraw prevents locking of overlapping areas). 	A special case for non-overlapping but equal source/dest handle would 	be possible but we would have to transfer this information over to 	unlockSurfaces somehow (currently, only one unlock operation is 	performed for equal source and dest handles). Also, this would require	a change in the notion of ioLockSurface() which is right now interpreted	as a hint and not as a requirement to lock only the specific portion of	the surface.	* The arguments in ioLockSurface() provide the implementation with	an explicit hint what area is affected. It can be very useful to	know the max. affected area beforehand if getting the bits requires expensive	copy operations (e.g., like a roundtrip to the X server or a glReadPixel op).	However, the returned pointer *MUST* point to the virtual origin of the surface	and not to the beginning of the rectangle. The promise made by BitBlt	is to never access data outside the given rectangle (aligned to 4byte boundaries!)	so it is okay to return a pointer to the virtual origin that is actually outside	the valid memory area.	* The area provided in ioLockSurface() is already clipped (e.g., it will always	be inside the source and dest boundingBox) but it is not aligned to word boundaries	yet. It is up to the support code to compute accurate alignment if necessary.	* Warping always requires the entire source surface to be locked because	there is no beforehand knowledge about what area will actually be traversed.	"	| sourceHandle destHandle l r t b fn |	self inline: true. "If the CCodeGen learns how to inline #cCode: methods"	self var: #fn declareC:'int (*fn)(oopInt, oopInt*, oopInt, oopInt, oopInt, oopInt)'.	hasSurfaceLock := false.	destBits = 0 ifTrue:["Blitting *to* OS surface"		lockSurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^nil]].		fn := self cCoerce: lockSurfaceFn to: 'int (*)(oopInt, oopInt*, oopInt, oopInt, oopInt, oopInt)'.		destHandle := interpreterProxy fetchInteger: ImageBitsIndex ofObject: destForm.		(sourceBits = 0 and:[noSource not]) ifTrue:[			sourceHandle := interpreterProxy fetchInteger: ImageBitsIndex ofObject: sourceForm.			"Handle the special case of equal source and dest handles"			(sourceHandle = destHandle) ifTrue:[				"If we have overlapping source/dest we lock the entire area				so that there is only one area transmitted"				isWarping ifFalse:[					"When warping we always need the entire surface for the source"					sourceBits := self cCode:'fn(sourceHandle, &amp;sourcePitch, 0,0, sourceWidth, sourceHeight)'.				] ifTrue:[					"Otherwise use overlapping area"					l := sx min: dx. r := (sx max: dx) + bbW.					t := sy min: dy. b := (sy max: sy) + bbH.					sourceBits := self cCode:'fn(sourceHandle, &amp;sourcePitch, l, t, r-l, b-t)'.				].				destBits := sourceBits.				destPitch := sourcePitch.				hasSurfaceLock := true.				^destBits ~~ 0			].			"Fall through - if not equal it'll be handled below"		].		destBits := self cCode:'fn(destHandle, &amp;destPitch, dx, dy, bbW, bbH)'.		hasSurfaceLock := true.	].	(sourceBits == 0 and:[noSource not]) ifTrue:["Blitting *from* OS surface"		sourceHandle := interpreterProxy fetchInteger: ImageBitsIndex ofObject: sourceForm.		lockSurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^nil]].		fn := self cCoerce: lockSurfaceFn to: 'int (*)(oopInt, oopInt*, oopInt, oopInt, oopInt, oopInt)'.		"Warping requiring the entire surface"		isWarping ifTrue:[			sourceBits := self cCode:'fn(sourceHandle, &amp;sourcePitch, 0, 0, sourceWidth, sourceHeight)'.		] ifFalse:[			sourceBits := self cCode:'fn(sourceHandle, &amp;sourcePitch, sx, sy, bbW, bbH)'.		].		hasSurfaceLock := true.	].	^destBits ~~ 0 and:[sourceBits ~~ 0 or:[noSource]].</body><body package="HPSVM BitBlt Plugin" selector="queryDestSurface:">queryDestSurface: handle 	"Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller."	querySurfaceFn = 0 ifTrue:		[self loadSurfacePlugin ifFalse:			[^interpreterProxy primitiveFail]].	^self 		cCode: ' ((int (*) (oopInt, oopInt*, oopInt*, oopInt*, oopInt*))querySurfaceFn)(handle, &amp;destWidth, &amp;destHeight, &amp;destDepth, &amp;destMSB)'		inSmalltalk: [false]</body><body package="HPSVM BitBlt Plugin" selector="querySourceSurface:">querySourceSurface: handle 	"Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller."	querySurfaceFn = 0 ifTrue:		[self loadSurfacePlugin ifFalse: [^interpreterProxy primitiveFail]].	^self 		cCode: ' ((int (*) (oopInt, oopInt*, oopInt*, oopInt*, oopInt*))querySurfaceFn)(handle, &amp;sourceWidth, &amp;sourceHeight, &amp;sourceDepth, &amp;sourceMSB)'		inSmalltalk: [false]</body><body package="HPSVM BitBlt Plugin" selector="unlockSurfaces">unlockSurfaces	"Unlock the bits of any OS surfaces."	"See the comment in lockSurfaces. Similar rules apply. That is, the area provided in ioUnlockSurface can be used to determine the dirty region after drawing. If a source is unlocked, then the area will be (0,0,0,0) to indicate that no portion is dirty."	| sourceHandle destHandle destLocked fn |	self var: #fn declareC:'int (*fn)(oopInt, oopInt, oopInt, oopInt, oopInt)'.	hasSurfaceLock ifTrue:[		unlockSurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^nil]].		fn := self cCoerce: unlockSurfaceFn to: 'int (*)(oopInt, oopInt, oopInt, oopInt, oopInt)'.		destLocked := false.		destHandle := interpreterProxy fetchPointer: ImageBitsIndex ofObject: destForm.		(interpreterProxy isIntegerObject: destHandle) ifTrue:[			destHandle := interpreterProxy integerValueOf: destHandle.			"The destBits are always assumed to be dirty"			self cCode:'fn(destHandle, affectedL, affectedT, affectedR-affectedL, affectedB-affectedT)'.			destBits := destPitch := 0.			destLocked := true.		].		noSource ifFalse:[			sourceHandle := interpreterProxy fetchPointer: ImageBitsIndex ofObject: sourceForm.			(interpreterProxy isIntegerObject: sourceHandle) ifTrue:[				sourceHandle := interpreterProxy integerValueOf: sourceHandle.				"Only unlock sourceHandle if different from destHandle"				(destLocked and:[sourceHandle = destHandle]) 					ifFalse:[self cCode: 'fn(sourceHandle, 0, 0, 0, 0)'].				sourceBits := sourcePitch := 0.			].		].		hasSurfaceLock := false.	].</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>color mapping</category><body package="HPSVM BitBlt Plugin" selector="mapDestPixel:">mapDestPixel: sourcePixel 	"Color map the given source pixel."	self inline: true.	self var: #sourcePixel declareC: 'unsigned int sourcePixel'.	dstCmFlags = 0 ifTrue: [^sourcePixel].	^ (((sourcePixel &gt;&gt; 24) &lt;&lt; (dstCmShifts at: AlphaIndex)) bitAnd: (dstCmMasks at: AlphaIndex))	+ (((sourcePixel &gt;&gt; 16) &lt;&lt; (dstCmShifts at: RedIndex)) bitAnd: (dstCmMasks at: RedIndex))	+ (((sourcePixel &gt;&gt;    8) &lt;&lt; (dstCmShifts at: GreenIndex)) bitAnd: (dstCmMasks at: GreenIndex))	+ ((sourcePixel              &lt;&lt; (dstCmShifts at: BlueIndex)) bitAnd: (dstCmMasks at: BlueIndex)).</body><body package="HPSVM BitBlt Plugin" selector="mapSourcePixel:">mapSourcePixel: sourcePixel 	"Color map the given source pixel."	| pv |	self inline: true.	pv := sourcePixel.	srcCmFlags ~= 0 ifTrue:		[(srcCmFlags bitAnd: ColorMapFixedPart) ~= 0			ifTrue: 				[pv := ((sourcePixel bitAnd: (srcCmMasks at: RedIndex))							&gt;&gt; (srcCmShifts at: RedIndex)) &lt;&lt; 16						bitOr: (((sourcePixel bitAnd: (srcCmMasks at: GreenIndex))							&gt;&gt; (srcCmShifts at: GreenIndex)) &lt;&lt; 8						bitOr: (((sourcePixel bitAnd: (srcCmMasks at: BlueIndex))							&gt;&gt; (srcCmShifts at: BlueIndex))						 bitOr: (((sourcePixel bitAnd: (srcCmMasks at: AlphaIndex))							&gt;&gt; (srcCmShifts at: AlphaIndex)) &lt;&lt; 24))).				"avoid introducing transparency by color reduction"				(pv = 0 and: [sourcePixel ~= 0]) ifTrue: [pv := 1]]			ifFalse: [pv := srcExpandedLookupTable at: (pv bitAnd: srcCmMask)]].	^pv</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>initialize-release</category><body package="HPSVM BitBlt Plugin" selector="initialiseModule">initialiseModule	self export: true.	self cCode: 'oe_assert(sizeof(int) == sizeof(oop))'.	^true</body><body package="HPSVM BitBlt Plugin" selector="moduleUnloaded:">moduleUnloaded: aModuleName	"The module with the given name was just unloaded.	Make sure we have no dangling references."	self export: true.	self var: #aModuleName type: 'char *'.	(aModuleName strcmp: 'SurfacePlugin') = 0 ifTrue:[		"The surface plugin just shut down. How nasty."		querySurfaceFn := lockSurfaceFn := unlockSurfaceFn := 0.	].</body></methods><methods><class-id>HPSVM.BitBltSimulation</class-id> <category>primitives</category><body package="HPSVM BitBlt Plugin" selector="primitiveCopyBits:">primitiveCopyBits: receiver	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	self export: true.	sourceAlpha := -1.	self loadBitBltFrom: receiver warping: false.	self copyBits.	self showDisplayBits.	^(combinationRule = 22 or: [combinationRule = 32])		ifTrue: [interpreterProxy integerObjectOf: bitCount]		ifFalse: [receiver]</body><body package="HPSVM BitBlt Plugin" selector="primitiveCopyBits:translucency:">primitiveCopyBits: receiver translucency: translucencyOop	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	self export: true.	sourceAlpha := interpreterProxy integerValueOf: translucencyOop.	(sourceAlpha &lt; 0 or: [sourceAlpha &gt; 255]) ifTrue:		[^interpreterProxy primitiveFail].	self loadBitBltFrom: receiver warping: false.	self copyBits.	self showDisplayBits.	^(combinationRule = 22 or: [combinationRule = 32])		ifTrue: [interpreterProxy integerObjectOf: bitCount]		ifFalse: [receiver]</body><body package="HPSVM BitBlt Plugin" selector="primitiveDisplayString:string:from:to:map:xTable:kern:">primitiveDisplayString: bbObj string: sourceString from: startIndexOop to: stopIndexOop map: glyphMap xTable: xTable kern: kernDeltaOop	| kernDelta stopIndex startIndex maxGlyph ascii glyphIndex sourcePtr left quickBlt |	self export: true.	self var: #sourcePtr type: 'unsigned char *'.	kernDelta := interpreterProxy integerValueOf: kernDeltaOop.	((interpreterProxy fetchClassOf: xTable) = interpreterProxy classArray	 and:[(interpreterProxy fetchClassOf: glyphMap) = interpreterProxy classArray])		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: glyphMap) = 256		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^interpreterProxy primitiveFail].	maxGlyph := (interpreterProxy slotSizeOf: xTable) - 2.	stopIndex := interpreterProxy integerValueOf: stopIndexOop.	startIndex := interpreterProxy integerValueOf: startIndexOop.	interpreterProxy failed ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: sourceString) ifFalse:[^interpreterProxy primitiveFail].	(startIndex &gt; 0 and:[stopIndex &gt; 0 and:[		stopIndex &lt;= (interpreterProxy byteSizeOf: sourceString)]])			ifFalse:[^interpreterProxy primitiveFail].	self loadBitBltFrom: bbObj warping: false.	(combinationRule = 30 or:[combinationRule = 31]) "needs extra source alpha"		ifTrue:[^interpreterProxy primitiveFail].	"See if we can go directly into copyLoopPixMap (usually we can)"	quickBlt := destBits ~= 0 "no OS surfaces please"				and:[sourceBits ~= 0 "and again"				and:[noSource = false "needs a source"				and:[sourceForm ~= destForm "no blits onto self"				and:[(srcCmFlags ~= 0 						or:[sourceMSB ~= destMSB 						or:[sourceDepth ~= destDepth]]) "no point using slower version"				]]]].	left := destX.	sourcePtr := interpreterProxy firstIndexableField: sourceString.	startIndex to: stopIndex do:[:charIndex|		ascii := interpreterProxy byteAt: sourcePtr + charIndex - 1.		glyphIndex := interpreterProxy fetchInteger: ascii ofObject: glyphMap.		(glyphIndex &lt; 0 or:[glyphIndex &gt; maxGlyph]) 			ifTrue:[^interpreterProxy primitiveFail].		sourceX := interpreterProxy fetchInteger: glyphIndex ofObject: xTable.		width := (interpreterProxy fetchInteger: glyphIndex+1 ofObject: xTable) - sourceX.		self clipRange.	"Must clip here"		(bbW &gt; 0 and:[bbH &gt; 0]) ifTrue: [			quickBlt ifTrue:[				self destMaskAndPointerInit.				self copyLoopPixMap.				"both, hDir and vDir are known to be &gt; 0"				affectedL := dx.				affectedR := dx + bbW.				affectedT := dy.				affectedB := dy + bbH.			] ifFalse:[self copyBits]].		destX := destX + width + kernDelta.	 ].	affectedL := left.	self showDisplayBits.	^bbObj</body><body package="HPSVM BitBlt Plugin" selector="primitiveDrawLoop:X:Y:">primitiveDrawLoop: rcvr X: xDeltaOop Y: yDeltaOop	"Invoke the line drawing primitive."	| xDelta yDelta |	self export: true.	xDelta := interpreterProxy integerValueOf: xDeltaOop.	yDelta := interpreterProxy integerValueOf: yDeltaOop.	self loadBitBltFrom: rcvr warping: false.	self drawLoopX: xDelta Y: yDelta.	self showDisplayBits.	^rcvr</body><body package="HPSVM BitBlt Plugin" selector="primitiveWarpBits:smoothing:">primitiveWarpBits: receiver smoothing: smoothingCountOop	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| smoothingCount |	self export: true.	smoothingCount := interpreterProxy integerValueOf: smoothingCountOop.	self loadBitBltFrom: receiver warping: true.	destDepth &lt; 16 ifTrue:		["The primitive code doesn't render colors to pixels.  This must		   be left to the image (e.g. nearest paint, ordered dither et al..."		 sourceDepth ~= destDepth ifTrue:			[^interpreterProxy primitiveFail].		smoothingCount &gt; 1 ifTrue:			["Smoothing is done in RGBA space, which can only be done			  if RGBA values don't have to be rendered to pixels."			 ^interpreterProxy primitiveFail].		"If there's no smoothing and the palettes match then the primitive moves		 pixels, avoiding mapping to RGBA entirely."		self failIfPalettesDoNotMatch].	self warpBitsSmoothing: smoothingCount.	self showDisplayBits.	^(combinationRule = 22 or: [combinationRule = 32])		ifTrue: [interpreterProxy integerObjectOf: bitCount]		ifFalse: [receiver]</body></methods><methods><class-id>HPSVM.BitBltSimulation class</class-id> <category>translation</category><body package="HPSVM BitBlt Plugin" selector="addMethodsToRetainTo:">addMethodsToRetainTo: aSet	"Add the selectors of any and all methods we want to ensure are not pruned as unreachable."	aSet		addAll: OpTable;		add: #byteArrayCopyBits:stride:width:x:y:source:stride:width:x:y:width:heigth:rule:;		add: #tileArrayCopyBits:stride:width:x:y:source:stride:width:x:y:width:heigth:rule:</body><body package="HPSVM BitBlt Plugin" selector="declareCVarsIn:">declareCVarsIn: aCCodeGenerator	super declareCVarsIn: aCCodeGenerator.	aCCodeGenerator var: 'opTable' declareC: 		(String streamContents:			[:s|			s	nextPutAll: 'oopInt opTable['; print: OpTableSize; nextPutAll: '] = {';				crtab: 2;				nextPut: $0.			OpTable do:				[:selector|				s nextPut: $, ; crtab: 2.				selector isNil					ifTrue: [s nextPut: $0]					ifFalse: [s	nextPutAll: '(oopInt)';								nextPutAll: (aCCodeGenerator cFunctionNameFor: selector)]].			s nextPut: $} ]).	aCCodeGenerator var: 'maskTable' declareC:		(String streamContents:			[:s|			s	nextPutAll: 'int maskTable[33] = {';				crtab: 2;				nextPut: $0.			(1 to: 31) do:				[:po2|				s nextPut: $,; crtab: 2; nextPutAll: '0x'.				(2 raisedTo: po2) - 1 printOn: s base: 16].			s nextPut: $,; crtab: 2; print: -1.			s nextPut: $} ]).	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable' declareC:'int warpBitShiftTable[32]'.	aCCodeGenerator		var: 'srcExpandedLookupTable' declareC: 'unsigned int srcExpandedLookupTable[256]';		var:'srcCmShifts' declareC:'int srcCmShifts[4]';		var:'srcCmMasks'  declareC:'unsigned int srcCmMasks[5]';		var: 'dstExpandedLookupTable' declareC: 'unsigned int dstExpandedLookupTable[256]';		var:'dstCmShifts' declareC:'int dstCmShifts[4]';		var:'dstCmMasks'  declareC:'unsigned int dstCmMasks[5]';		var:'cmLookupTable' declareC:'unsigned int *cmLookupTable'</body><body package="HPSVM BitBlt Plugin" selector="declareHeaderFilesIn:">declareHeaderFilesIn: aCCodeGenerator	super declareHeaderFilesIn: aCCodeGenerator.	aCCodeGenerator addHeaderFile: 'exBitBlt'</body><body package="HPSVM BitBlt Plugin" selector="moduleName">moduleName	^'BitBltPlugin'</body></methods><methods><class-id>HPSVM.BitBltSimulation class</class-id> <category>initialization</category><body package="HPSVM BitBlt Plugin" selector="initialize">initialize	"HPSVM.BitBltSimulation initialize"	self initializeRuleTable.	"Value of 1.0 in Warp's fixed-point representation"	BinaryPoint := 14.	FixedPt1 := 1 &lt;&lt; BinaryPoint. 	"Color map flags"	ColorMapPresent := 1.		"do we have one?"	ColorMapFixedPart := 2.		"does it have a fixed part?"	ColorMapIndexedPart := 4.	"does it have an indexed part?"	ColorMapNewStyle := 8.		"new style color map"</body><body package="HPSVM BitBlt Plugin" selector="initializeRuleTable">initializeRuleTable	"BitBltSimulation initializeRuleTable"	OpTable := #(		 "0" clearWord:with:		 "1" bitAnd:with:		 "2" bitAndInvert:with:		 "3" sourceWord:with:		 "4" bitInvertAnd:with:		 "5" destinationWord:with:		 "6" bitXor:with:		 "7" bitOr:with:		 "8" bitInvertAndInvert:with:		 "9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" setWord:with:		"16"	nil "unused - was old paint"		"17"	nil "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22"	nil "unused was OLDrgbDiff:with:"		"23"	nil "unused was OLDtallyIntoMap:with:"		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33"	nil "AS YET UNIMPLEMENTED was tallyIntoMap:with:"		"34" alphaBlendScaled:with:		"35"	nil "unused was alphaBlendScaled:with:"		"36"	nil "unused was alphaBlendScaled:with:"		"37" rgbMul:with:		"38" pixSwap:with:		"39" pixClear:with:		"40" fixAlpha:with:	).	OpTableSize := OpTable size + 1.  "0-origin indexing"</body><body package="HPSVM BitBlt Plugin" selector="test2">test2  "BitBltSimulation test2"	| f |	Display fillWhite: (0@0 extent: 300@140).	1 to: 12 do:		[:i | f := (Image extent: i@5) fillBlack.		0 to: 20 do:			[:x | f displayOn: Display					at: (x*13) @ (i*10)]]</body><body package="HPSVM BitBlt Plugin" selector="timingTest:">timingTest: extent  "BitBltSimulation timingTest: 640@480"	| f f2 map |	f := Image extent: extent depth: 8.	f2 := Image extent: extent depth: 8.	map := Bitmap new: 1 &lt;&lt; f2 depth.	^ Array with:	(Time millisecondsToRun: [100 timesRepeat:		[f fillWithColor: Graphics.ColorValue white]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copy: f boundingBox from: 0@0 in: f2 rule: RasterOp over]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copyBits: f boundingBox from: f2 at: 0@0 colorMap: map]])</body></methods><methods><class-id>HPSVM.BitBltSimulation class</class-id> <category>compiling</category><body package="HPSVM BitBlt Plugin" selector="pluginGlobalVariables">pluginGlobalVariables	"bigEndian is actually a manifest constant that is in an instance variable for testing."	^self instVarNames copyWithout: 'bigEndian'</body></methods><methods><class-id>HPSVM.BitBltSimulation class</class-id> <category>private</category><body package="HPSVM BitBlt Plugin" selector="selectorForPrimitive:">selectorForPrimitive: aSymbol	aSymbol == #copyBits ifTrue: [^#primitiveCopyBits:].	aSymbol == #copyBitsTranslucent ifTrue: [^#primitiveCopyBits:translucency:].	aSymbol == #displayString ifTrue: [^#primitiveDisplayString:string:from:to:map:xTable:kern:].	aSymbol == #drawLoop ifTrue: [^#primitiveDrawLoop:X:Y:].	aSymbol == #warpBits ifTrue: [^#primitiveWarpBits:smoothing:].	self error: 'unknown primitive'</body></methods><methods><class-id>HPSVM.BitBltSimulation class</class-id> <category>system simulation</category><body package="HPSVM BitBlt Plugin" selector="simulatorClass">simulatorClass	^BitBltSimulator</body></methods><methods><class-id>HPSVM.BitBltSimulation24bpp</class-id> <category>setup</category><body package="HPSVM BitBlt Plugin" selector="checkSourceOverlap">checkSourceOverlap	"check for possible overlap of source and destination"	"ar 10/19/1999: This method requires surfaces to be locked."	| t |	self inline: true.	(sourceForm = destForm and: [dy &gt;= sy]) ifTrue:		[dy &gt; sy ifTrue:			["have to start at bottom"			vDir := -1.			sy := sy + bbH - 1.			dy := dy + bbH - 1]		ifFalse:			[(dy = sy) &amp; (dx &gt; sx) ifTrue:				["y's are equal, but x's are backward"				hDir := -1.				sx := sx + bbW - 1.				"start at right"				dx := dx + bbW - 1.				"and fix up masks"				nWords &gt; 1 ifTrue: 					[t := mask1.					mask1 := mask2.					mask2 := t]]].		"Dest inits may be affected by this change"		destIndex := destDepth = 24						ifTrue: [destBits + (dy * destPitch) + (dx * 3)]						ifFalse: [destBits + (dy * destPitch) + ((dx // destPPW) *4)].		destDelta := (destPitch * vDir) - (4 * (nWords * hDir))]</body><body package="HPSVM BitBlt Plugin" selector="destMaskAndPointerInit">destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	self inline: true.	hDir := vDir := 1. "defaults for no overlap with source"	destDepth = 24 ifTrue:		[startBits := endBits := 0.		 mask1 := mask2 := AllOnes.		 nWords := bbW.		 destIndex := destBits + (dy * destPitch) + (dx * 3).		 destDelta := destPitch * vDir - (3 * (nWords * hDir)).  "byte addr delta"		 ^true].	pixPerM1 := destPPW - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits := destPPW - (dx bitAnd: pixPerM1).	mask1 := destMSB				ifTrue:[ AllOnes &gt;&gt; (32 - (startBits*destDepth))] 				ifFalse:[ AllOnes &lt;&lt; (32 - (startBits*destDepth))].	"how many pixels in last word"	endBits := ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	mask2 := destMSB 				ifTrue:[AllOnes &lt;&lt; (32 - (endBits*destDepth))] 				ifFalse:[AllOnes &gt;&gt; (32 - (endBits*destDepth))].	"determine number of words stored per line; merge masks if only 1"	bbW &lt; startBits		ifTrue: [mask1 := mask1 bitAnd: mask2.				mask2 := 0.				nWords := 1]		ifFalse: [nWords := (bbW - startBits) + pixPerM1 // destPPW + 1].	"calculate byte addr and delta, based on first word of data"	"Note pitch is bytes and nWords is longs, not bytes"	destIndex := destBits + (dy * destPitch) + ((dx // destPPW) * 4).	destDelta := destPitch * vDir - (4 * (nWords * hDir)).  "byte addr delta"</body><body package="HPSVM BitBlt Plugin" selector="sourceSkewAndPointerInit">sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	self inline: true.	sourceDepth = 24 ifTrue:		[preload := false.		 skew := 0.		 sourceIndex := sourceBits + (sy * sourcePitch) + (sx * 3).		 "calculate increments from end of 1 line to start of next"		 sourceDelta := (sourcePitch * vDir) - (3 * nWords * hDir).		 ^true].	pixPerM1 := destPPW - 1.  "A mask, assuming power of two"	sxLowBits := sx bitAnd: pixPerM1.	dxLowBits := dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir &gt; 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid := bbW min: destPPW - dxLowBits.		preload := (sxLowBits + dWid) &gt; pixPerM1]	ifFalse:		[dWid := bbW min: dxLowBits + 1.		preload := (sxLowBits - dWid + 1) &lt; 0].	"calculate right-shift skew from source to dest"	skew := sourceMSB				ifTrue:[(sxLowBits - dxLowBits) * destDepth] 				ifFalse:[(dxLowBits - sxLowBits) * destDepth].  " -32..32 "	preload ifTrue: 		[skew := skew &lt; 0					ifTrue: [skew+32]					ifFalse: [skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex := sourceBits + (sy * sourcePitch) + ((sx // (32//sourceDepth)) *4).	"calculate increments from end of 1 line to start of next"	sourceDelta := (sourcePitch * vDir) - (4 * (nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta := sourceDelta - (4*hDir)].</body></methods><methods><class-id>HPSVM.BitBltSimulation24bpp</class-id> <category>inner loop</category><body package="HPSVM BitBlt Plugin" selector="copyLoop">copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith destWord hsInc |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc := destDepth = 24 ifTrue: [hDir * 3] ifFalse: [hDir*4].  "Byte delta"	hsInc := sourceDepth = 24 ifTrue: [hDir * 3] ifFalse: [hDir*4].  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew := unskew := skewMask := 0]		ifFalse: [skew &lt; 0			ifTrue:				[unskew := skew+32.				skewMask := AllOnes &lt;&lt; (0-skew)]			ifFalse:				[skew = 0					ifTrue:						[unskew := 0.						skewMask := AllOnes]					ifFalse:						[unskew := skew-32.						skewMask := AllOnes &gt;&gt; skew]]].	notSkewMask := skewMask bitInvert32.	noHalftone		ifTrue:			[halftoneWord := AllOnes.			 halftoneHeight := 0]		ifFalse:			[y := dy.			 halftoneWord := self halftoneAt: 0.			 halftoneHeight = 1 ifTrue:				[halftoneHeight := 0]].	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight ~= 0 ifTrue:  "Otherwise, its always the same"			[halftoneWord := self halftoneAt: y.			y := y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord := self srcLongAt: sourceIndex.			sourceIndex := sourceIndex + hsInc]			ifFalse:			[prevWord := 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask := mask1.			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hsInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask := AllOnes.combinationRule = 3ifTrue: [(skew = 0) &amp; (halftoneWord = AllOnes)		ifTrue: 		["Very special inner loop for STORE mode with no skew -- just move words"		hDir = -1		ifTrue: ["Woeful patch: revert to older code for hDir = -1"				2 to: nWords-1 do: 					[ :word |					thisWord := self srcLongAt: sourceIndex.					sourceIndex := sourceIndex + hsInc.					self dstLongAt: destIndex put: thisWord.					destIndex := destIndex + hInc]]		ifFalse: [2 to: nWords-1 do: 					[ :word |  "Note loop starts with prevWord loaded (due to preload)"					self dstLongAt: destIndex put: prevWord.					destIndex := destIndex + hInc.					prevWord := self srcLongAt: sourceIndex.					sourceIndex := sourceIndex + hsInc]]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord := self srcLongAt: sourceIndex.			sourceIndex := sourceIndex + hsInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			self dstLongAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex := destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hsInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord := thisWord.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)							with: (self dstLongAt: destIndex).			self dstLongAt: destIndex put: mergeWord.			destIndex := destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords &gt; 1 ifTrue:			[destMask := mask2.			thisWord := self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex := sourceIndex + hsInc.			skewWord := ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + hInc].	sourceIndex := sourceIndex + sourceDelta.	destIndex := destIndex + destDelta]</body><body package="HPSVM BitBlt Plugin" selector="copyLoopNoSource">copyLoopNoSource	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	| halftoneWord mergeWord mergeFnwith destWord hInc |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc := destDepth = 24 ifTrue: [3] ifFalse: [4].	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord := AllOnes]			ifFalse: [halftoneWord := self halftoneAt: dy+i-1].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask := mask1.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: halftoneWord							with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr: 							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + hInc.		"This central horizontal loop requires no store masking"			destMask := AllOnes.			combinationRule = 3 ifTrue: ["Special inner loop for STORE"				destWord := halftoneWord.				2 to: nWords-1 do:[ :word |					self dstLongAt: destIndex put: destWord.					destIndex := destIndex + hInc].			] ifFalse:[ "Normal inner loop does merge"				2 to: nWords-1 do:[ :word | "Normal inner loop does merge"					destWord := self dstLongAt: destIndex.					mergeWord := self mergeFn: halftoneWord with: destWord.					self dstLongAt: destIndex put: mergeWord.					destIndex := destIndex + hInc].			].		"This last section, if used, requires masking of the destination store..."		nWords &gt; 1 ifTrue:			[destMask := mask2.			destWord := self dstLongAt: destIndex.			mergeWord := self mergeFn: halftoneWord with: destWord.			destWord := (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex := destIndex + hInc].	destIndex := destIndex + destDelta]</body><body package="HPSVM BitBlt Plugin" selector="copyLoopPixMap">copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	"ar 12/7/1999:	The loop has been rewritten to use only one pickSourcePixels call.	The idea is that the call itself could be inlined. If we decide not	to inline pickSourcePixels we could optimize the loop instead."	| skewWord halftoneWord mergeWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask mergeFnwith nPix srcShift dstShift destWord words srcShiftInc dstShiftInc dstShiftLeft |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	sourcePPW := 32//sourceDepth.	sourcePixMask := maskTable at: sourceDepth.	destPixMask := maskTable at: destDepth.	sourceIndex := sourceBits +					(sy * sourcePitch) + (sourceDepth = 24 ifTrue: [sx * 3] ifFalse: [(sx // sourcePPW) *4]).	scrStartBits := sourcePPW - (sx bitAnd: sourcePPW-1).	bbW &lt; scrStartBits		ifTrue: [nSourceIncs := 0]		ifFalse: [nSourceIncs := (bbW - scrStartBits)//sourcePPW + 1].	sourceDelta := sourcePitch - (nSourceIncs * 4).	"Note following two items were already calculated in destmask setup!"	startBits := destPPW - (dx bitAnd: destPPW-1).	endBits := ((dx + bbW - 1) bitAnd: destPPW-1) + 1.	bbW &lt; startBits ifTrue:[startBits := bbW].	"Precomputed shifts for pickSourcePixels"	srcShift := ((sx bitAnd: sourcePPW - 1) * sourceDepth).	dstShift := ((dx bitAnd: destPPW - 1) * destDepth).	srcShiftInc := sourceDepth.	dstShiftInc := destDepth.	dstShiftLeft := 0.	sourceMSB ifTrue:[		srcShift := 32 - sourceDepth - srcShift.		srcShiftInc := 0 - srcShiftInc].	destMSB ifTrue:[		dstShift := 32 - destDepth - dstShift.		dstShiftInc := 0 - dstShiftInc.		dstShiftLeft := 32 - destDepth].	1 to: bbH do: "here is the vertical loop"		[ :i |		"*** is it possible at all that noHalftone == false? ***"		noHalftone			ifTrue:[halftoneWord := AllOnes]			ifFalse: [halftoneWord := self halftoneAt: dy+i-1].		"setup first load"		srcBitShift := srcShift.		dstBitShift := dstShift.		destMask := mask1.		nPix := startBits.		"Here is the horizontal loop..."		words := nWords.			["pick up the word"			skewWord := self pickSourcePixels: nPix								srcMask: sourcePixMask destMask: destPixMask								srcShiftInc: srcShiftInc dstShiftInc: dstShiftInc.			"align next word to leftmost pixel"			dstBitShift := dstShiftLeft.			destMask = AllOnes ifTrue:["avoid read-modify-write"				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (self dstLongAt: destIndex).				self dstLongAt: destIndex put: (destMask bitAnd: mergeWord).			] ifFalse:[ "General version using dest masking"				destWord := self dstLongAt: destIndex.				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (destWord bitAnd: destMask).				destWord := (destMask bitAnd: mergeWord) bitOr:								(destWord bitAnd: destMask bitInvert32).				self dstLongAt: destIndex put: destWord.			].			destIndex := destIndex + (destDepth = 24 ifTrue: [3] ifFalse: [4]).			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask := mask2.						nPix := endBits]				ifFalse:["use fullword mask for inner loop"						destMask := AllOnes.						nPix := destPPW].			(words := words - 1) = 0] whileFalse.		"--- end of inner loop ---"		sourceIndex := sourceIndex + sourceDelta.		destIndex := destIndex + destDelta]</body><body package="HPSVM BitBlt Plugin" selector="warpLoopSmoothing:">warpLoopSmoothing: smoothingCount	"This version of the inner loop traverses an arbirary quadrilateral	 source, thus producing a general affine transformation."	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy pBx pBy	  xDelta yDelta nSteps nPix words destWord endBits	  mergeFnwith dstShiftInc dstShiftLeft |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith := self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	(interpreterProxy slotSizeOf: bitBltOop) &gt;= (RRWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	(nSteps := height-1) &lt;= 0 ifTrue: [nSteps := 1].	pAx := self fetchIntOrFloat: RRWarpBase ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+3 ofObject: bitBltOop.	deltaP12x := self deltaFrom: pAx to: words nSteps: nSteps.	deltaP12x &lt; 0 ifTrue: [pAx := words - (nSteps*deltaP12x)].	pAy := self fetchIntOrFloat: RRWarpBase+1 ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+4 ofObject: bitBltOop.	deltaP12y := self deltaFrom: pAy to: words nSteps: nSteps.	deltaP12y &lt; 0 ifTrue: [pAy := words - (nSteps*deltaP12y)].	pBx := self fetchIntOrFloat: RRWarpBase+9 ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+6 ofObject: bitBltOop.	deltaP43x := self deltaFrom: pBx to: words nSteps: nSteps.	deltaP43x &lt; 0 ifTrue: [pBx := words - (nSteps*deltaP43x)].	pBy := self fetchIntOrFloat: RRWarpBase+10 ofObject: bitBltOop.	words := self fetchIntOrFloat: RRWarpBase+7 ofObject: bitBltOop.	deltaP43y := self deltaFrom: pBy to: words nSteps: nSteps.	deltaP43y &lt; 0 ifTrue: [pBy := words - (nSteps*deltaP43y)].	(nSteps := width-1) &lt;= 0 ifTrue: [nSteps := 1].	destDepth &gt;= 24		ifTrue:			[startBits := endBits := 1]		ifFalse:			[startBits := destPPW - (dx bitAnd: destPPW-1).			 endBits := ((dx + bbW - 1) bitAnd: destPPW-1) + 1]. 	bbW &lt; startBits ifTrue:[startBits := bbW].	destY &lt; clipY ifTrue:[		"Advance increments if there was clipping in y"		pAx := pAx + (clipY - destY * deltaP12x).		pAy := pAy + (clipY - destY * deltaP12y).		pBx := pBx + (clipY - destY * deltaP43x).		pBy := pBy + (clipY - destY * deltaP43y)].	"Setup values for faster pixel fetching."	self warpLoopSetup.	destDepth = 24		ifTrue: [dstShiftInc := 0. self halt: 'HALT: really?!?!?!?!'.				  dstShiftLeft := 0]		ifFalse:			[destMSB				ifTrue:[dstShiftInc := 0 - destDepth.						dstShiftLeft := 32 - destDepth]				ifFalse:[dstShiftInc := destDepth.						dstShiftLeft := 0]].	1 to: bbH do:		[ :i | "here is the vertical loop..."		xDelta := self deltaFrom: pAx to: pBx nSteps: nSteps.		sx := xDelta &gt;= 0 ifTrue: [pAx] ifFalse: [pBx - (nSteps*xDelta)].		yDelta := self deltaFrom: pAy to: pBy nSteps: nSteps. 		sy := yDelta &gt;= 0 ifTrue: [pAy] ifFalse: [pBy - (nSteps*yDelta)].		dstBitShift := destDepth = 24							ifTrue: [0]							ifFalse:								[destMSB									ifTrue:[32 - ((dx bitAnd: destPPW - 1) + 1 * destDepth)]									ifFalse:[(dx bitAnd: destPPW - 1) * destDepth]].		(destX &lt; clipX) ifTrue:[			"Advance increments if there was clipping in x"			sx := sx + (clipX - destX * xDelta).			sy := sy + (clipX - destX * yDelta).		].		halftoneWord := noHalftone							ifTrue: [AllOnes]							ifFalse: [self halftoneAt: dy+i-1].		destMask := mask1.		nPix := startBits.		"Here is the inner loop..."		words := nWords.			["pick up word"			smoothingCount = 1 ifTrue:["Faster if not smoothing"				skewWord := self warpPickSourcePixels: nPix								xDeltah: xDelta yDeltah: yDelta								xDeltav: deltaP12x yDeltav: deltaP12y								dstShiftInc: dstShiftInc			] ifFalse:["more difficult with smoothing"				skewWord := self warpPickSmoothPixels: nPix						xDeltah: xDelta yDeltah: yDelta						xDeltav: deltaP12x yDeltav: deltaP12y						smoothing: smoothingCount						dstShiftInc: dstShiftInc.			].			"align next word access to left most pixel"			dstBitShift := dstShiftLeft.			destMask = AllOnes ifTrue:["avoid read-modify-write"				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (self dstLongAt: destIndex).				self dstLongAt: destIndex put: (destMask bitAnd: mergeWord).			] ifFalse:[ "General version using dest masking"				destWord := self dstLongAt: destIndex.				mergeWord := self mergeFn: (skewWord bitAnd: halftoneWord)								with: (destWord bitAnd: destMask).				destWord := (destMask bitAnd: mergeWord) bitOr:								(destWord bitAnd: destMask bitInvert32).				self dstLongAt: destIndex put: destWord.			].			destIndex := destIndex + (destDepth = 24 ifTrue: [3] ifFalse: [4]).			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask := mask2.						nPix := endBits]				ifFalse:["use fullword mask for inner loop"						destMask := AllOnes.						nPix := destPPW].			(words := words - 1) = 0] whileFalse.		"--- end of inner loop ---"		pAx := pAx + deltaP12x.		pAy := pAy + deltaP12y.		pBx := pBx + deltaP43x.		pBy := pBy + deltaP43y.		destIndex := destIndex + destDelta]</body></methods><methods><class-id>HPSVM.BitBltSimulation24bpp</class-id> <category>memory access</category><body package="HPSVM BitBlt Plugin" selector="dstLongAt:">dstLongAt: idx	| v |	self inline: true.	destDepth = 24 ifTrue:		[^(interpreterProxy byteAt: idx)		+ ((interpreterProxy byteAt: idx + 1) bitShift: 8)		+ ((interpreterProxy byteAt: idx + 2) bitShift: 16)].	v := interpreterProxy longAt: idx.	^destMSB ~= bigEndian		ifTrue: [interpreterProxy byteSwapped: v]		ifFalse: [v]</body><body package="HPSVM BitBlt Plugin" selector="dstLongAt:put:">dstLongAt: idx put: value	self inline: true.	destDepth = 24		ifTrue:			[interpreterProxy byteAt: idx put: value.			 interpreterProxy byteAt: idx + 1 put: (value bitShift: -8).			 interpreterProxy byteAt: idx + 2 put: (value bitShift: -16)]		ifFalse:			[interpreterProxy				longAt: idx				put: (destMSB ~= bigEndian						ifTrue: [interpreterProxy byteSwapped: value]						ifFalse: [value])]</body><body package="HPSVM BitBlt Plugin" selector="srcLongAt:">srcLongAt: idx	| v |	self inline: true.	sourceDepth = 24 ifTrue:		[^(interpreterProxy byteAt: idx)		+ ((interpreterProxy byteAt: idx + 1) bitShift: 8)		+ ((interpreterProxy byteAt: idx + 2) bitShift: 16)].	v := interpreterProxy longAt: idx.	^bigEndian ~= sourceMSB		ifTrue: [interpreterProxy byteSwapped: v]		ifFalse: [v]</body></methods><methods><class-id>HPSVM.BitBltSimulation24bpp</class-id> <category>combination rules</category><body package="HPSVM BitBlt Plugin" selector="pickSourcePixels:srcMask:destMask:srcShiftInc:dstShiftInc:">pickSourcePixels: nPixels srcMask: srcMask destMask: dstMask srcShiftInc: srcShiftInc dstShiftInc: dstShiftInc	"Pick nPix pixels starting at srcBitIndex from the source, map by the	color map, and justify them according to dstBitIndex in the resulting destWord."	| sourceWord destWord sourcePix destPix srcShift dstShift nPix hsInc |	self inline: true. "oh please"	hsInc := sourceDepth = 24 ifTrue: [3] ifFalse: [4].	sourceWord := self srcLongAt: sourceIndex.	destWord := 0.	srcShift := srcBitShift. "Hint: Keep in register"	dstShift := dstBitShift. "Hint: Keep in register"	nPix := nPixels. "always &gt; 0 so we can use do { } while(--nPix);"	(srcCmFlags bitAnd: ColorMapIndexedPart) ~= 0 ifTrue:[		"a little optimization for (pretty crucial) blits using indexed lookups only"		[	"grab, colormap and mix in pixel"			sourcePix := sourceWord &gt;&gt; srcShift bitAnd: srcMask.			destPix := self tableLookup: srcExpandedLookupTable at: (sourcePix bitAnd: srcCmMask).			destWord := destWord bitOr: (destPix bitAnd: dstMask) &lt;&lt; dstShift.			"adjust dest pix index"			dstShift := dstShift + dstShiftInc.			"adjust source pix index"			((srcShift := srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift := srcShift + 32] ifFalse:[srcShift := srcShift - 32].				sourceWord := self srcLongAt: (sourceIndex := sourceIndex + hsInc)].		(nPix := nPix - 1) = 0] whileFalse.	] ifFalse:[		[	"grab, colormap and mix in pixel"			sourcePix := sourceWord &gt;&gt; srcShift bitAnd: srcMask.			destPix := self mapSourcePixel: sourcePix.			destWord := destWord bitOr: (destPix bitAnd: dstMask) &lt;&lt; dstShift.			"adjust dest pix index"			dstShift := dstShift + dstShiftInc.			"adjust source pix index"			((srcShift := srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift := srcShift + 32] ifFalse:[srcShift := srcShift - 32].				sourceWord := self srcLongAt: (sourceIndex := sourceIndex + hsInc)].		(nPix := nPix - 1) = 0] whileFalse.	].	srcBitShift := srcShift. "Store back"	^destWord</body></methods><methods><class-id>HPSVM.BitBltSimulation24bpp</class-id> <category>pixel mapping</category><body package="HPSVM BitBlt Plugin" selector="warpLoopSetup">warpLoopSetup	"Setup values for faster pixel fetching."	| words warpSrcShift |	self inline: true.	sourceDepth = 24 ifTrue:		[warpSrcShift := 0. warpAlignShift := 0. ^true].	"warpSrcShift = log2(sourceDepth)"	warpSrcShift := 0.	words := sourceDepth. "recycle temp"	[words = 1] whileFalse:[		warpSrcShift := warpSrcShift + 1.		words := words &gt;&gt; 1].	"warpSrcMask = mask for extracting one pixel from source word"	warpSrcMask := maskTable at: sourceDepth.	"warpAlignShift: Shift for aligning x position to word boundary"	warpAlignShift := 5 - warpSrcShift.	"warpAlignMask: Mask for extracting the pixel position from an x position"	warpAlignMask := 1 &lt;&lt; warpAlignShift - 1.	"Setup the lookup table for source bit shifts"	"warpBitShiftTable: given an sub-word x value what's the bit shift?"	0 to: warpAlignMask do:[:i|		sourceMSB			ifTrue:[warpBitShiftTable at: i put: 32 - ( i + 1 &lt;&lt; warpSrcShift )]			ifFalse:[warpBitShiftTable at: i put: (i &lt;&lt; warpSrcShift)]].</body></methods><methods><class-id>HPSVM.BitBltSimulation24bpp</class-id> <category>interpreter interface</category><body package="HPSVM BitBlt Plugin" selector="loadBitBltDestForm">loadBitBltDestForm	"Load the dest form for BitBlt. Return false if anything is wrong, true otherwise."	| destBitsSize |	self inline: true.	((interpreterProxy isPointers: destForm)	and: [(interpreterProxy slotSizeOf: destForm) &gt; ImagePaletteIndex]) ifFalse:		[^interpreterProxy primitiveFail].	destBits := interpreterProxy fetchPointer: ImageBitsIndex ofObject: destForm.	destWidth := interpreterProxy fetchInteger: ImageWidthIndex ofObject: destForm.	destHeight := interpreterProxy fetchInteger: ImageHeightIndex ofObject: destForm.	(destWidth &gt;= 0 and: [destHeight &gt;= 0])		ifFalse: [^interpreterProxy primitiveFail].	destDepth := interpreterProxy fetchInteger: ImageBitsPerPixelIndex ofObject: destForm.	destMSB := destDepth &gt; 0.	destDepth := destDepth abs.	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isImmediateObject: destBits)		ifTrue:			[(interpreterProxy isIntegerObject: destBits) ifFalse: [^interpreterProxy primitiveFail].			"Query for actual surface dimensions"			(self queryDestSurface: (interpreterProxy integerValueOf: destBits)) ifFalse:				[^interpreterProxy primitiveFail].			destPPW := 32 // destDepth.			destBits := destPitch := 0]		ifFalse:			[(interpreterProxy isImmutableObject: destBits) ifTrue:					[^interpreterProxy primitiveFail].				destDepth = 24				ifTrue:					[destPPW := "1" nil. "maybe nil is a better choice!!"					 destPitch :=  (destWidth * 24 + 31 bitShift: -5) bitShift: 2]				ifFalse:					[destPPW := 32 // destDepth.					 destPitch := destWidth + (destPPW-1) // destPPW * 4].			destBitsSize := interpreterProxy byteSizeOf: destBits.			((interpreterProxy isBytes: destBits)			 and: [destBitsSize = (destPitch * destHeight)]) ifFalse:				[^interpreterProxy primitiveFail].			"Skip header since external bits don't have one"			destBits := self cCoerce: (interpreterProxy firstIndexableField: destBits) to:'oopInt'].	dstCmFlags := self loadColorMapFrom: (interpreterProxy													fetchPointer: ImagePaletteIndex													ofObject: destForm)						intoCLUT: dstExpandedLookupTable						shifts: dstCmShifts						masks: dstCmMasks.	dstCmMask := dstCmMasks at: 4.	^true</body><body package="HPSVM BitBlt Plugin" selector="loadBitBltSourceForm">loadBitBltSourceForm	"Load the source form for BitBlt. Return false if anything is wrong, true otherwise."	| sourceBitsSize |	self inline: true.	((interpreterProxy isPointers: sourceForm)	 and: [(interpreterProxy slotSizeOf: sourceForm) &gt; ImagePaletteIndex]) ifFalse:		[^interpreterProxy primitiveFail].	sourceBits := interpreterProxy fetchPointer: ImageBitsIndex ofObject: sourceForm.	sourceWidth := interpreterProxy fetchInteger: ImageWidthIndex ofObject: sourceForm.	sourceHeight := interpreterProxy fetchInteger: ImageHeightIndex ofObject: sourceForm.	(sourceWidth &gt;= 0 and: [sourceHeight &gt;= 0])		ifFalse: [^interpreterProxy primitiveFail ].	sourceDepth := interpreterProxy fetchInteger: ImageBitsPerPixelIndex ofObject: sourceForm.	sourceMSB := sourceDepth &gt; 0.	sourceDepth := sourceDepth abs.	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isImmediateObject: sourceBits)		ifTrue:			[(interpreterProxy isIntegerObject: sourceBits) ifFalse: [^interpreterProxy primitiveFail].			"Query for actual surface dimensions"			(self querySourceSurface: (interpreterProxy integerValueOf: sourceBits)) ifFalse:				[^interpreterProxy primitiveFail ].			sourcePPW := 32 // sourceDepth.			sourceBits := sourcePitch := 0]		ifFalse:			[sourceDepth = 24				ifTrue:					[sourcePPW := "1" nil. "maybe nil is a better choice!!"					 sourcePitch :=  (sourceWidth * 24 + 31 bitShift: -5) bitShift: 2]				ifFalse:					[sourcePPW := 32 // sourceDepth.					 sourcePitch := sourceWidth + (sourcePPW-1) // sourcePPW * 4].			sourceBitsSize := interpreterProxy byteSizeOf: sourceBits.			((interpreterProxy isBytes: sourceBits)				and: [sourceBitsSize = (sourcePitch * sourceHeight)])				ifFalse: [^interpreterProxy primitiveFail ].			"Skip header since external bits don't have one"			sourceBits := self cCoerce: (interpreterProxy firstIndexableField: sourceBits) to:'oopInt'].	srcCmFlags := self loadColorMapFrom: (interpreterProxy													fetchPointer: ImagePaletteIndex													ofObject: sourceForm)						intoCLUT: srcExpandedLookupTable						shifts: srcCmShifts						masks: srcCmMasks.	srcCmMask := srcCmMasks at: 4.	^true</body></methods><methods><class-id>HPSVM.BitBltSimulation24bpp class</class-id> <category>translation</category><body package="HPSVM BitBlt Plugin" selector="buildCodeGeneratorUpTo:">buildCodeGeneratorUpTo: aPluginClass	"Build a CCodeGenerator for the plugin.  This merges the superclass with this class via an egregious hack."	 | cg theClass |	cg := self codeGeneratorClass new initialize.	cg plugin: self.	"Add an extra declaration for module name"	cg declareModuleName: self moduleNameAndVersion.	theClass := self superclass copy.	self selectorsAndMethodsDo:		[:s :m| theClass methodDictionary at: s put: m].	[theClass == Object] whileFalse:		[cg addClass: theClass.		 theClass declareCVarsIn: cg.		 theClass := theClass superclass].	cg addUsedSelectorsInClass: InterpreterProxy.	^cg</body><body package="HPSVM BitBlt Plugin" selector="moduleName">moduleName	^'BitBltPlugin24bpp'</body></methods><methods><class-id>HPSVM.BitBltSimulator24bpp</class-id> <category>debug support</category><body package="HPSVM BitBlt Plugin" selector="dstLongAt:">dstLongAt: dstIndex	interpreterProxy isInterpreterProxy ifFalse:		[((dstIndex anyMask: 3)		 or: [dstIndex + 4 &lt; destBits		 or: [dstIndex &gt; (destBits + (destPitch * destHeight))]])			ifTrue:				[self error:'Out of bounds']].	^super dstLongAt: dstIndex</body><body package="HPSVM BitBlt Plugin" selector="dstLongAt:put:">dstLongAt: dstIndex put: value	interpreterProxy isInterpreterProxy ifFalse:		[((dstIndex anyMask: 3)		 or: [dstIndex &lt; destBits		 or: [dstIndex &gt;= (destBits + (destPitch * destHeight))]])			ifTrue:				[self error:'Out of bounds']].	^super dstLongAt: dstIndex put: value</body><body package="HPSVM BitBlt Plugin" selector="srcLongAt:">srcLongAt: srcIndex 	interpreterProxy isInterpreterProxy ifFalse: 		[((srcIndex anyMask: 3)		 or: [srcIndex + 4 &lt; sourceBits 		 or: [srcIndex &gt; (sourceBits + (sourcePitch * sourceHeight))]])			ifTrue:				[self error: 'Out of bounds']].	^super srcLongAt: srcIndex</body></methods><methods><class-id>HPSVM.BitBltSimulator24bpp</class-id> <category>initialize-release</category><body package="HPSVM BitBlt Plugin" selector="initialiseModule">initialiseModule	bigEndian := UninterpretedBytes isBigEndian.	opTable := OpTable.	maskTable := Array new: 32.	#(1 2 4 8 16 24 32) do:[:i| maskTable at: i put: (1 &lt;&lt; i)-1].	self initializeDitherTables.	warpBitShiftTable := CArrayAccessor on: (Array new: 32).	dstExpandedLookupTable := CArrayAccessor on: (DwordArray new: 256).	srcExpandedLookupTable := CArrayAccessor on: (DwordArray new: 256).	srcCmShifts := CArrayAccessor on: (DwordArray new: 4).	srcCmMasks := CArrayAccessor on: (DwordArray new: 5).	dstCmShifts := CArrayAccessor on: (DwordArray new: 4).	dstCmMasks := CArrayAccessor on: (DwordArray new: 5).	^super initialiseModule</body></methods><methods><class-id>HPSVM.BitBltSimulator24bpp</class-id> <category>as yet unclassified</category><body package="HPSVM BitBlt Plugin" selector="initializeDitherTables">initializeDitherTables	ditherMatrix4x4 := CArrayAccessor on:		#(	0	8	2	10			12	4	14	6			3	11	1	9			15	7	13	5).	ditherThresholds16 := CArrayAccessor on:#(0 2 4 6 8 10 12 14 16).	ditherValues16 := CArrayAccessor on: 		#(0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14		15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30).</body><body package="HPSVM BitBlt Plugin" selector="mergeFn:with:">mergeFn: arg1 with: arg2	^ self perform: (opTable at: combinationRule+1) with: arg1 with: arg2</body><body package="HPSVM BitBlt Plugin" selector="tableLookup:at:">tableLookup: table at: index	^ interpreterProxy longAt: (table + (index * 4))</body></methods><methods><class-id>HPSVM.BitBltSimulator24bpp class</class-id> <category>examples</category><body package="HPSVM BitBlt Plugin" selector="bitBltExampleDestDepth:sourceDepth:toWindow:where:">bitBltExampleDestDepth: destDepth sourceDepth: sourceDepth toWindow: aWindow where: aPoint 	"The classic BitBlt example to test combination rules."	| origins d s m |	origins := Array new writeStream.	(0 to: 3 * 40 by: 40) 		do: [:y | (0 to: 3 * 40 by: 40) do: [:x | origins nextPut: x @ y + 4]].	origins := origins contents.	d := Image extent: 41 * 4 asPoint depth: destDepth palette: (self paletteForDepth: destDepth abs).	s := Image extent: 32 asPoint depth: sourceDepth palette: (self paletteForDepth: sourceDepth abs).	m := Image extent: 32 asPoint depth: 1 palette: MappedPalette monochromeDefault.	0 to: 31 do:		[:x|		0 to: 31 do:			[:y| m atX: x y: y put: ((x+y) even ifTrue: [0] ifFalse: [1])]].	HPSVM.BitBltSimulator24bpp		doPrimitive: #copyBits		receiver: (RasterOp 				destinationImage: s				sourceImage: nil				halftoneImage: nil				combinationRule: RasterOp writeOnes				destOrigin: 8 asPoint				sourceOrigin: 0 @ 0				halftonePhase: 0 @ 0				extent: 16 asPoint				clipRect: s bounds).	origins with: (0 to: 15) do:		[:orig :rule |  | o |		o := orig + (1 @ 0).		HPSVM.BitBltSimulator24bpp			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: nil halftoneImage: nil						combinationRule: RasterOp writeOnes						destOrigin: o - 1 sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 34 asPoint clipRect: d bounds);			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: nil halftoneImage: nil						combinationRule: RasterOp writeZeros						destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 32 asPoint clipRect: d bounds);			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: nil halftoneImage: nil						combinationRule: RasterOp writeOnes						destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 16 @ 32 clipRect: d bounds).		HPSVM.BitBltSimulator24bpp			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: s halftoneImage: m						combinationRule: rule						destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 32 asPoint clipRect: d bounds)].	d displayOn: aWindow graphicsContext at: aPoint</body><body package="HPSVM BitBlt Plugin" selector="paletteForDepth:">paletteForDepth: depth	^depth &gt; 8 		ifTrue: 			[depth = 16 				ifTrue: 					[FixedPalette 						redShift: 11 redMask: 31						greenShift: 5 greenMask: 63						blueShift: 0 blueMask: 31]					ifFalse: 						[FixedPalette 							redShift: 16 redMask: 16rFF							greenShift: 8 greenMask: 16rFF							blueShift: 0 blueMask: 16rFF]]			ifFalse: 				[(depth = 1					ifTrue: [MonoMappedPalette]					ifFalse: [MappedPalette]) 							withColors: ((1 to: (2 raisedTo: depth)) collect:											[:i |											i even												ifTrue: [ColorValue white]												ifFalse: [ColorValue black]])]</body></methods><methods><class-id>HPSVM.BitBltSimulator24bpp class</class-id> <category>translation</category><body package="HPSVM BitBlt Plugin" selector="shouldBeTranslated">shouldBeTranslated"This class should not be translated "	^false</body></methods><methods><class-id>HPSVM.BitBltSimulator</class-id> <category>debug support</category><body package="HPSVM BitBlt Plugin" selector="dstLongAt:">dstLongAt: dstIndex	interpreterProxy isInterpreterProxy ifFalse:		[((dstIndex anyMask: 3)		 or: [dstIndex + 4 &lt; destBits		 or: [dstIndex &gt; (destBits + (destPitch * destHeight))]])			ifTrue:				[self error:'Out of bounds']].	^super dstLongAt: dstIndex</body><body package="HPSVM BitBlt Plugin" selector="dstLongAt:put:">dstLongAt: dstIndex put: value	interpreterProxy isInterpreterProxy ifFalse:		[((dstIndex anyMask: 3)		 or: [dstIndex &lt; destBits		 or: [dstIndex &gt;= (destBits + (destPitch * destHeight))]])			ifTrue:				[self error:'Out of bounds']].	^super dstLongAt: dstIndex put: value</body><body package="HPSVM BitBlt Plugin" selector="srcLongAt:">srcLongAt: srcIndex 	interpreterProxy isInterpreterProxy ifFalse: 		[((srcIndex anyMask: 3)		 or: [srcIndex + 4 &lt; sourceBits 		 or: [srcIndex &gt; (sourceBits + (sourcePitch * sourceHeight))]])			ifTrue:				[self error: 'Out of bounds']].	^super srcLongAt: srcIndex</body></methods><methods><class-id>HPSVM.BitBltSimulator</class-id> <category>initialize-release</category><body package="HPSVM BitBlt Plugin" selector="initialiseModule">initialiseModule	bigEndian := UninterpretedBytes isBigEndian.	opTable := OpTable.	maskTable := Array new: 32.	#(1 2 4 8 16 24 32) do:[:i| maskTable at: i put: (1 &lt;&lt; i)-1].	self initializeDitherTables.	warpBitShiftTable := CArrayAccessor on: (Array new: 32).	dstExpandedLookupTable := CArrayAccessor on: (DwordArray new: 256).	srcExpandedLookupTable := CArrayAccessor on: (DwordArray new: 256).	srcCmShifts := CArrayAccessor on: (DwordArray new: 4).	srcCmMasks := CArrayAccessor on: (DwordArray new: 5).	dstCmShifts := CArrayAccessor on: (DwordArray new: 4).	dstCmMasks := CArrayAccessor on: (DwordArray new: 5).	^super initialiseModule</body></methods><methods><class-id>HPSVM.BitBltSimulator</class-id> <category>as yet unclassified</category><body package="HPSVM BitBlt Plugin" selector="initializeDitherTables">initializeDitherTables	ditherMatrix4x4 := CArrayAccessor on:		#(	0	8	2	10			12	4	14	6			3	11	1	9			15	7	13	5).	ditherThresholds16 := CArrayAccessor on:#(0 2 4 6 8 10 12 14 16).	ditherValues16 := CArrayAccessor on: 		#(0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14		15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30).</body><body package="HPSVM BitBlt Plugin" selector="mergeFn:with:">mergeFn: arg1 with: arg2	^ self perform: (opTable at: combinationRule+1) with: arg1 with: arg2</body><body package="HPSVM BitBlt Plugin" selector="tableLookup:at:">tableLookup: table at: index	^ interpreterProxy longAt: (table + (index * 4))</body></methods><methods><class-id>HPSVM.BitBltSimulator class</class-id> <category>examples</category><body package="HPSVM BitBlt Plugin" selector="bitBltExampleDestDepth:sourceDepth:toWindow:where:">bitBltExampleDestDepth: destDepth sourceDepth: sourceDepth toWindow: aWindow where: aPoint 	"The classic BitBlt example to test combination rules."	| origins d s m |	origins := Array new writeStream.	(0 to: 3 * 40 by: 40) 		do: [:y | (0 to: 3 * 40 by: 40) do: [:x | origins nextPut: x @ y + 4]].	origins := origins contents.	d := Image extent: 41 * 4 asPoint depth: destDepth palette: (self paletteForDepth: destDepth abs).	s := Image extent: 32 asPoint depth: sourceDepth palette: (self paletteForDepth: sourceDepth abs).	m := Image extent: 32 asPoint depth: 1 palette: MappedPalette monochromeDefault.	0 to: 31 do:		[:x|		0 to: 31 do:			[:y| m atX: x y: y put: ((x+y) even ifTrue: [0] ifFalse: [1])]].	HPSVM.BitBltSimulator		doPrimitive: #copyBits		receiver: (RasterOp 				destinationImage: s				sourceImage: nil				halftoneImage: nil				combinationRule: RasterOp writeOnes				destOrigin: 8 asPoint				sourceOrigin: 0 @ 0				halftonePhase: 0 @ 0				extent: 16 asPoint				clipRect: s bounds).	origins with: (0 to: 15) do:		[:orig :rule |  | o |		o := orig + (1 @ 0).		HPSVM.BitBltSimulator			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: nil halftoneImage: nil						combinationRule: RasterOp writeOnes						destOrigin: o - 1 sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 34 asPoint clipRect: d bounds);			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: nil halftoneImage: nil						combinationRule: RasterOp writeZeros						destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 32 asPoint clipRect: d bounds);			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: nil halftoneImage: nil						combinationRule: RasterOp writeOnes						destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 16 @ 32 clipRect: d bounds).		HPSVM.BitBltSimulator			doPrimitive: #copyBits			receiver: (RasterOp 						destinationImage: d sourceImage: s halftoneImage: m						combinationRule: rule						destOrigin: o sourceOrigin: 0 @ 0 halftonePhase: 0 @ 0						extent: 32 asPoint clipRect: d bounds)].	d displayOn: aWindow graphicsContext at: aPoint</body><body package="HPSVM BitBlt Plugin" selector="paletteForDepth:">paletteForDepth: depth	^depth &gt; 8 		ifTrue: 			[depth = 16 				ifTrue: 					[FixedPalette 						redShift: 11 redMask: 31						greenShift: 5 greenMask: 63						blueShift: 0 blueMask: 31]					ifFalse: 						[FixedPalette 							redShift: 16 redMask: 16rFF							greenShift: 8 greenMask: 16rFF							blueShift: 0 blueMask: 16rFF]]			ifFalse: 				[(depth = 1					ifTrue: [MonoMappedPalette]					ifFalse: [MappedPalette]) 							withColors: ((1 to: (2 raisedTo: depth)) collect:											[:i |											i even												ifTrue: [ColorValue white]												ifFalse: [ColorValue black]])]</body></methods><methods><class-id>HPSVM.BitBltSimulator class</class-id> <category>translation</category><body package="HPSVM BitBlt Plugin" selector="shouldBeTranslated">shouldBeTranslated"This class should not be translated "	^false</body></methods><methods><class-id>HPSVM.VMMaker class</class-id> <category>generation</category><body package="HPSVM BitBlt Plugin" selector="generateBitBltPlugin">generateBitBltPlugin	"Make sure the output file does not exist, otherwise nothing is done"	self new		initializeAllExternal;		generateExternalPlugin: #BitBltSimulation</body></methods><initialize><class-id>HPSVM.BitBltSimulation</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>InterpreterPlugin</name><environment>HPSVM</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interpreterProxy moduleName </inst-vars><class-inst-vars>timeStamp </class-inst-vars><imports>			private Tools.Pragma			</imports><category>VMConstruction-Plugins</category><attributes><package>HPSVM Primitive Plugins</package></attributes></class></st-source>