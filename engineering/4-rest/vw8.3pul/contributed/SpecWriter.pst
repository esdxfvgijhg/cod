<?xml version="1.0"?><st-source><!-- Name: SpecWriterNotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: SpecWriter reads and writes specs for arbitrary objects.  The specs have a compact form which contain a key or legend of selectors for decoding each kind of class.  Arrays in the spec can therefore list only the class and the instance variables without having to repeat the assignment selectors for each instance.  This saves space for long lists of instances of the same class.DbIdentifier: bear73DbTrace: 57004PackageName: SpecWriterParcel: #('SpecWriter')ParcelName: SpecWriterPrintStringCache: (7.4.0.4,daves)Version: 7.4.0.4Date: 7:51:21 AM August 5, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 7:51:21 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SpecWriter</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectorLegend </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Packing List</category><attributes><package>SpecWriter</package></attributes></class><comment><class-id>Tools.SpecWriter</class-id><body>SpecWriter reads and writes specs for arbitrary objects.  The specs have a compact form which contain a key or legend of selectors for decoding each kind of class.  Arrays in the spec can therefore list only the class and the instance variables without having to repeat the assignment selectors for each instance.  This saves space for long lists of instances of the same class.Instance Variables:	selectorLegend	&lt;Dictionary&gt;	dictionary of selectors by class.  The sequence of selectors are used to process instance variable arrays when reifying stored objects.</body></comment><methods><class-id>Tools.SpecWriter</class-id> <category>util</category><body package="SpecWriter" selector="convertToLiteral:">convertToLiteral: anObject 	| literal |	literal := anObject asLiteral.	literal == anObject ifFalse: [self registerSelectorLegendFor: anObject].	^literal</body><body package="SpecWriter" selector="registerSelectorLegendFor:">registerSelectorLegendFor: anObject 	self selectorLegend at: anObject class fullyQualifiedReference		ifAbsentPut: [anObject class conversionSelectorsFromLiteralArray]</body><body package="SpecWriter" selector="scanForSelectorLegends:">scanForSelectorLegends: anObject 	anObject isLiteral ifTrue: [^self].	self registerSelectorLegendFor: anObject.	anObject isSequenceable 		ifTrue: [anObject do: [:each | self scanForSelectorLegends: each]]		ifFalse: 			[anObject class conversionSelectorsToLiteralArray 				do: [:selector | self scanForSelectorLegends: (anObject perform: selector)]]</body></methods><methods><class-id>Tools.SpecWriter</class-id> <category>printing</category><body package="SpecWriter" selector="printAsSpec:on:">printAsSpec: anObject on: aStream 	self		selectorLegend: Dictionary new;		scanForSelectorLegends: self selectorLegend;		scanForSelectorLegends: anObject.	aStream		nextPutAll: '#(';		print: self class fullyQualifiedReference;		crtab;		nextPutAll: '#selectorLegendFromKeyValuePairs: '.	self selectorLegend associationsAsLiteralKeyValuePairs storeOn: aStream.	aStream		crtab;		nextPutAll: '#reify: '.	(self convertToLiteral: anObject) storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Tools.SpecWriter</class-id> <category>converting</category><body package="SpecWriter" selector="reify:">reify: aLiteralObject 	^aLiteralObject class == Array 		ifTrue: [self reifyArray: aLiteralObject]		ifFalse: [aLiteralObject]</body><body package="SpecWriter" selector="reifyArray:">reifyArray: aLiteralArray 	aLiteralArray isEmpty ifTrue: [^aLiteralArray].	^aLiteralArray first isBindingReference 		ifTrue: [self reifySelectorKeyedArray: aLiteralArray]		ifFalse: [aLiteralArray collect: [:element | self reify: element]]</body><body package="SpecWriter" selector="reifySelectorKeyedArray:">reifySelectorKeyedArray: aLiteralArray 	| str bindingReference legend literalObject args result |	str := aLiteralArray readStream.	bindingReference := str next.	legend := self selectorLegend at: bindingReference.	literalObject := bindingReference value new.	legend do: 			[:selector | 			args := (str next: selector numArgs) collect: [:arg | self reify: arg].			result := literalObject perform: selector withArguments: args].	str atEnd ifFalse: [^self error: (#unexpectedElements &lt;&lt; #installer &gt;&gt; 'unexpected elements')].	^result</body></methods><methods><class-id>Tools.SpecWriter</class-id> <category>accessing</category><body package="SpecWriter" selector="selectorLegend">selectorLegend	^selectorLegend isNil ifTrue: [selectorLegend := Dictionary new] ifFalse: [selectorLegend]</body><body package="SpecWriter" selector="selectorLegend:">selectorLegend: aDictionary	selectorLegend := aDictionary</body><body package="SpecWriter" selector="selectorLegendFor:">selectorLegendFor: anObject 	^self selectorLegend at: anObject class fullyQualifiedReference</body></methods><methods><class-id>Tools.SpecWriter</class-id> <category>initialize-release</category><body package="SpecWriter" selector="fromLiteralArrayEncoding:">fromLiteralArrayEncoding: anArray 	| str next result args |	str := anArray readStream.	str next value == self class ifFalse: [^self error: (#wrongClass &lt;&lt; #installer &gt;&gt; 'wrong class')].	[str atEnd] whileFalse: 			[next := str next.			args := str next: next numArgs.			result := self perform: next withArguments: args].	^result</body><body package="SpecWriter" selector="selectorLegendFromKeyValuePairs:">selectorLegendFromKeyValuePairs: anArray 	self selectorLegend addAllFromKeyValuePairs: anArray</body></methods><methods><class-id>Tools.SpecWriter class</class-id> <category>instance creation</category><body package="SpecWriter" selector="decodeFromLiteralArray:">decodeFromLiteralArray: anArray 	^self new fromLiteralArrayEncoding: anArray</body></methods><methods><class-id>Tools.SpecWriter class</class-id> <category>deployment</category><body package="SpecWriter" selector="dynamicallyReferencedSelectors">dynamicallyReferencedSelectors	^#(#selectorLegendFor: #selectorLegendFromKeyValuePairs:)</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>accessing</category><body package="SpecWriter" selector="conversionSelectorsFromLiteralArray">conversionSelectorsFromLiteralArray	^#(#readFromString:)</body><body package="SpecWriter" selector="conversionSelectorsToLiteralArray">conversionSelectorsToLiteralArray	^#(#printString)</body></methods><methods><class-id>Core.Timestamp</class-id> <category>conversion</category><body package="SpecWriter" selector="convertToLiteral">convertToLiteral	^self printString</body><body package="SpecWriter" selector="readFromString:">readFromString: aString 	^self class readFrom: aString readStream</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>accessing</category><body package="SpecWriter" selector="conversionSelectorsFromLiteralArray">conversionSelectorsFromLiteralArray	^#(#addAllFromKeyValuePairs:)</body><body package="SpecWriter" selector="conversionSelectorsToLiteralArray">conversionSelectorsToLiteralArray	^#(#associationsAsLiteralKeyValuePairs)</body></methods><methods><class-id>Core.Dictionary</class-id> <category>adding</category><body package="SpecWriter" selector="addAllFromKeyValuePairs:">addAllFromKeyValuePairs: anArray 	anArray do: [:pair | self at: pair first put: pair last].	^self</body></methods><methods><class-id>Core.Dictionary</class-id> <category>converting</category><body package="SpecWriter" selector="associationsAsLiteralKeyValuePairs">associationsAsLiteralKeyValuePairs	^(self keys asArray collect: [:key | Array with: key with: (self at: key)]) 		asLiteral</body><body package="SpecWriter" selector="convertToLiteral">convertToLiteral	^Array with: self class fullyQualifiedReference		with: self associationsAsLiteralKeyValuePairs</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="SpecWriter" selector="convertToLiteral">convertToLiteral	^(self collect: [:element | element asLiteral]) asArray</body></methods><methods><class-id>Core.List class</class-id> <category>accessing</category><body package="SpecWriter" selector="aspectsForLiteralSpec">aspectsForLiteralSpec	^#()</body></methods><methods><class-id>Core.Object class</class-id> <category>accessing</category><body package="SpecWriter" selector="conversionSelectorsFromLiteralArray">conversionSelectorsFromLiteralArray	^self aspectsForLiteralSpec 		collect: [:string | (string copyWith: $:) asSymbol]</body><body package="SpecWriter" selector="conversionSelectorsToLiteralArray">conversionSelectorsToLiteralArray	^self aspectsForLiteralSpec collect: [:string | string asSymbol]</body><body package="SpecWriter" selector="selectorLegend">selectorLegend	^self fullyQualifiedReference -&gt; self conversionSelectorsFromLiteralArray</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="SpecWriter" selector="asLiteral">asLiteral	^self isLiteral ifTrue: [self] ifFalse: [self convertToLiteral]</body><body package="SpecWriter" selector="convertToLiteral">convertToLiteral	| getterSelectors literalCollection |	getterSelectors := self class conversionSelectorsToLiteralArray.	literalCollection := OrderedCollection new.	literalCollection add: self class fullyQualifiedReference.	getterSelectors 		do: [:getterSelector | literalCollection add: (self perform: getterSelector) asLiteral].	^literalCollection asArray</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>