<?xml version="1.0"?><st-source><!-- Name: OSProcessSignalHandlerNotice: Copyright (c) 2011 Holger KleinsorgenPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: OSProcessSignalHandler handles OS signals (interrupt/terminate etc) sent to VisualWorks, and announces them to interested parties.OS specific notes:- On Unix, clients have to provide a list of signal names, or use the predefined signal name lists- On Windows, both console events (Ctrl-C etc.) and events sent to application windows and unknown to the VM are handled.   Note that CTRL_LOGOFF_EVENT and CTRL_SHUTDOWN_EVENT are only passed to services. Consider using the package WinService.Example:OSProcessSignalHandler current	listenToLifecycleSignals;	when: OSProcessSignal do: [ : signal | Stdout nextPutAll: signal signalName, ' ' , signal code displayString; cr ];	when: OSProcessCloseSignal do: [ : signal | Stdout nextPutAll:  'Bye bye'; cr. ObjectMemory quit ];	yourselfContact: h . kleinsorgen - at - gmail . comCopyright (c) 2011 Holger KleinsorgenPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.PackageName: OSProcessSignalHandlerParcel: #('OSProcessSignalHandler')ParcelDirectory: OSProcessSignalHandlerVersion: (7.7).7Date: 11:14:45 AM July 18, 2014 --><time-stamp>From VisualWorksÂ®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:14:45</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OSProcessSignalHandler</name><environment>OS</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signalAnnouncements </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>UnixSignalHandler</name><environment>OS</environment><super>OS.OSProcessSignalHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signalProcesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessSignal</name><environment>OS</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessUser2Signal</name><environment>OS</environment><super>OS.OSProcessSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessUnknownSignal</name><environment>OS</environment><super>OS.OSProcessSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessCloseSignal</name><environment>OS</environment><super>OS.OSProcessSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessResumeSignal</name><environment>OS</environment><super>OS.OSProcessSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>WindowsSignalHandler</name><environment>OS</environment><super>OS.OSProcessSignalHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>callback suspended </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessBreakSignal</name><environment>OS</environment><super>OS.OSProcessSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessSuspendSignal</name><environment>OS</environment><super>OS.OSProcessSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSShutdownSignal</name><environment>OS</environment><super>OS.OSProcessCloseSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OsSignalHandlerError</name><environment>OS</environment><super>OS.OsError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><class><name>OSProcessUser1Signal</name><environment>OS</environment><super>OS.OSProcessSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OSProcessSignalHandler</package></attributes></class><shared-variable><name>SignalHandlers</name><environment>OS.OSProcessSignalHandler</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>OSProcessSignalHandler</package></attributes></shared-variable><shared-variable><name>Current</name><environment>OS.OSProcessSignalHandler</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>OSProcessSignalHandler</package></attributes></shared-variable><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="OSProcessSignalHandler">flushOSProcessSignalHandler	&lt;triggerAtSystemEvent: #returnFromSnapshot&gt;	OSProcessSignalHandler flushCurrent</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="OSProcessSignalHandler">SetConsoleCtrlHandler: pHandlerRoutine add: bAdd	&lt;C:BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE pHandlerRoutine, BOOL bAdd)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.OSProcessSignalHandler</class-id> <category>accessing</category><body package="OSProcessSignalHandler">knownSignalNames	" list of know signal names "	^ #()</body><body package="OSProcessSignalHandler">lifecycleSignalNames	" known signals related to interrupting/terminating the process or powering down/hibernating the system"	^ #()</body><body package="OSProcessSignalHandler">listenToKnownSignals	" listen to all known signals "	self listenToSignalsNamed: self knownSignalNames</body><body package="OSProcessSignalHandler">listenToLifecycleSignals	self listenToSignalsNamed: self lifecycleSignalNames</body><body package="OSProcessSignalHandler">listenToSignalNamed: signalNameStringOrSymbol 	" on Unix, we don't want to spawn processes for every possible signal, so clients have to provide a list of signal names.	on Windows, this is a no-op "</body><body package="OSProcessSignalHandler">listenToSignalsNamed: signalNames 	signalNames do: 		[: signalNameStringOrSymbol | 			self listenToSignalNamed: signalNameStringOrSymbol 		].</body></methods><methods><class-id>OS.OSProcessSignalHandler</class-id> <category>finalization</category><body package="OSProcessSignalHandler">mourn	SignalHandlers notNil ifTrue: [ SignalHandlers removeKey: self ifAbsent: [].].	[		self release	] on: OsSignalHandlerError do: [ : ex | 	]</body></methods><methods><class-id>OS.OSProcessSignalHandler</class-id> <category>initialize-release</category><body package="OSProcessSignalHandler">announceSignalNamed: signalName code: signalCode with: announcementClass	" augment / overwrite the signal -&gt; announcement mapping "	self signalAnnouncements at: signalCode put: [ announcementClass signalName: signalName ]</body><body package="OSProcessSignalHandler">announceSignalNamed: signalName with: announcementClass	" augment / overwrite the signal -&gt; announcement mapping "	self announceSignalNamed: signalName code: signalName with: announcementClass</body><body package="OSProcessSignalHandler">flush	" flush after snapshot. assume that registered callbacks are stale "</body><body package="OSProcessSignalHandler">initialize	" initialize OS callbacks if necessary "</body><body package="OSProcessSignalHandler">initializeSignalAnnouncements	" signalAnnouncements maps raw signal names/codes to announcement blocks "	signalAnnouncements := Dictionary new.</body><body package="OSProcessSignalHandler">release	" release the handler. assume that it's still active, so deregister callbacks etc. "</body></methods><methods><class-id>OS.OSProcessSignalHandler</class-id> <category>private</category><body package="OSProcessSignalHandler">handleHostEvent: aHostEventArray</body><body package="OSProcessSignalHandler">signalAnnouncements	signalAnnouncements isNil ifTrue: [ self initializeSignalAnnouncements ].	^ signalAnnouncements</body></methods><methods><class-id>OS.OSProcessSignalHandler class</class-id> <category>instance creation</category><body package="OSProcessSignalHandler">current	Current isNil ifTrue: [ Current := self new ].	^ Current</body><body package="OSProcessSignalHandler">currentOrNil	^ Current</body><body package="OSProcessSignalHandler">new	| handler |	handler := self concreteClass basicNew initialize.	self signalHandlers at: handler put: nil.	^ handler</body><body package="OSProcessSignalHandler">releaseCurrent	" release the handler. assume that it's still active, so deregister callbacks etc. "	Current notNil 		ifTrue: 		[	Current release.			Current := nil		].</body></methods><methods><class-id>OS.OSProcessSignalHandler class</class-id> <category>accessing</category><body package="OSProcessSignalHandler">concreteClass	| platform |	platform := OSHandle currentOS.	^ self allSubclasses detect: [ : class | class platforms includes: platform ] ifNone: [self ].</body><body package="OSProcessSignalHandler">platforms	^ #()</body></methods><methods><class-id>OS.OSProcessSignalHandler class</class-id> <category>private</category><body package="OSProcessSignalHandler">flushCurrent	" flush after snapshot. assume that registered callbacks are stale "	Current notNil ifTrue: [ Current flush ].	Current := nil.</body><body package="OSProcessSignalHandler">mournKeyOf: signalHandler	signalHandler key mourn</body><body package="OSProcessSignalHandler">signalHandlers	SignalHandlers isNil		ifTrue: [			SignalHandlers := EphemeronDictionary new.			SignalHandlers manager: self.		].	^ SignalHandlers</body></methods><methods><class-id>OS.UnixSignalHandler</class-id> <category>accessing</category><body package="OSProcessSignalHandler">knownSignalNames	" list of know signal names "	| knownObjectMemory knownManPage |	knownObjectMemory := ObjectMemory registrationNames.	knownManPage  := #(		SIGHUP		SIGINT		SIGQUIT		SIGILL		SIGABRT		SIGFPE		SIGKILL		SIGSEGV		SIGPIPE		SIGALRM		SIGTERM		SIGUSR1		SIGUSR2		SIGCHLD		SIGCONT		SIGSTOP		SIGTSTP		SIGTTIN		SIGTTOU	).	^ knownManPage select: [ : symbol | knownObjectMemory includes: symbol asString ]</body><body package="OSProcessSignalHandler">lifecycleSignalNames	^ #(SIGINT SIGTERM SIGQUIT)</body><body package="OSProcessSignalHandler">listenToSignalNamed: signalNameStringOrSymbol 	| signalNameString |	signalNameString := signalNameStringOrSymbol asString.	signalProcesses 		at: signalNameString		ifAbsentPut: 		[ | semaphore signalProcess |			semaphore := Semaphore new.			ObjectMemory registerObject: semaphore withEngineFor: signalNameString.			signalProcess :=				[						[	semaphore wait.						self handleSignal: signalNameString asSymbol					] repeat				] forkAt: Processor userInterruptPriority.			signalProcess name: signalNameString.			signalProcess		].</body><body package="OSProcessSignalHandler">listenToSignalsNamed: signalNames 	signalNames do: 		[: signalNameStringOrSymbol | 			self listenToSignalNamed: signalNameStringOrSymbol 		].</body></methods><methods><class-id>OS.UnixSignalHandler</class-id> <category>initialize-release</category><body package="OSProcessSignalHandler">flush	self release</body><body package="OSProcessSignalHandler">initialize	super initialize.	signalProcesses := Dictionary new.</body><body package="OSProcessSignalHandler">initializeSignalAnnouncements	signalAnnouncements := Dictionary new.	self announceSignalNamed: #SIGINT with: OSProcessBreakSignal.	self announceSignalNamed: #SIGTERM with: OSProcessCloseSignal.	self announceSignalNamed: #SIGUSR1 with: OSProcessUser1Signal.	self announceSignalNamed: #SIGUSR2 with: OSProcessUser2Signal.</body><body package="OSProcessSignalHandler">release	signalProcesses do: [ : process | process terminate ].	signalProcesses := signalProcesses class new.</body></methods><methods><class-id>OS.UnixSignalHandler</class-id> <category>private</category><body package="OSProcessSignalHandler">handleSignal: signalNameSymbol 	| announcement |	announcement := self signalAnnouncements at: signalNameSymbol ifPresent: [: block | block value ].	announcement isNil 		ifTrue: [ announcement := OSProcessUnknownSignal signalName: signalNameSymbol  ].	self announce: announcement.</body></methods><methods><class-id>OS.UnixSignalHandler class</class-id> <category>accessing</category><body package="OSProcessSignalHandler">platforms	^ #(unix)</body></methods><methods><class-id>OS.OSProcessSignal</class-id> <category>accessing</category><body package="OSProcessSignalHandler">signalName	^ signalName</body><body package="OSProcessSignalHandler">signalName: aSymbol 	signalName := aSymbol.</body></methods><methods><class-id>OS.OSProcessSignal class</class-id> <category>instance creation</category><body package="OSProcessSignalHandler">signalName: aSymbol	^ ( self new ) signalName: aSymbol;		yourself</body></methods><methods><class-id>OS.WindowsSignalHandler</class-id> <category>initialize-release</category><body package="OSProcessSignalHandler">flush	callback := nil.</body><body package="OSProcessSignalHandler">initialize	super initialize.	self registerCallback.	suspended := false.</body><body package="OSProcessSignalHandler">initializeSignalAnnouncements	signalAnnouncements := Dictionary new.	self announceSignalNamed: #CTRL_C_EVENT code: 0 with: OSProcessBreakSignal.	self announceSignalNamed: #CTRL_BREAK_EVENT code: 1 with: OSProcessBreakSignal.	self announceSignalNamed: #CTRL_CLOSE_EVENT code: 2 with: OSProcessCloseSignal.	"   Note that CTRL_LOGOFF_EVENT and CTRL_SHUTDOWN_EVENT are only passed to services. 	Consider using the package WinService. "	self announceSignalNamed: #CTRL_LOGOFF_EVENT code: 5 with: OSShutdownSignal.	self announceSignalNamed: #CTRL_SHUTDOWN_EVENT code: 6 with: OSShutdownSignal.</body><body package="OSProcessSignalHandler">release	| sys ok |	super release.	callback notNil 		ifTrue: 		[	sys := OSSystemSupport concreteClass new.			ok := sys SetConsoleCtrlHandler: callback add: 0.			ok = 1 				ifFalse: [ OsSignalHandlerError raiseSignal: #DeregisterFailed &lt;&lt; #osSignalHandler &gt;&gt; 'Removing signal callback failed' ].			callback := nil		].</body></methods><methods><class-id>OS.WindowsSignalHandler</class-id> <category>private</category><body package="OSProcessSignalHandler">handleHostEvent: aHostEventArray 	| kind hostEvent parameter |	hostEvent := aHostEventArray at: 10.	kind := hostEvent longAt: 9.	kind = 16r218 		ifTrue: 		[	" WM_POWERBROADCAST "			parameter := hostEvent longAt: 13.			^ self handlePowerBroadcast: parameter .		].</body><body package="OSProcessSignalHandler">handlePowerBroadcast: parameter 	parameter = 4 		ifTrue: 		[	suspended 				ifFalse: 				[	suspended := true.					self announce: ( OSProcessSuspendSignal signalName: #'PBT_APMSUSPEND'  )				].			^ self		].	parameter = 18 		ifTrue: 		[	suspended 				ifTrue: 				[	suspended := false.					^ self announce: ( OSProcessResumeSignal signalName: #'PBT_APMRESUMEAUTOMATIC' )				].			^ self		].</body><body package="OSProcessSignalHandler">handleSignal: dwCtrlType 	| announcement |	announcement := self signalAnnouncements at: dwCtrlType ifPresent: [: block | block value ].	announcement isNil 		ifTrue: [ announcement := OSProcessUnknownSignal signalName: #unknown ].	self announce: announcement.</body><body package="OSProcessSignalHandler">registerCallback	| sys ok |	sys := OSSystemSupport concreteClass new.	callback := CCallback 				do: 				[: dwCtrlType |					self handleSignal: dwCtrlType				]				ofType: sys PHANDLER_ROUTINE.	ok := sys SetConsoleCtrlHandler: callback add: 1.	ok = 1 ifFalse: [ OsSignalHandlerError raiseSignal: (#RegisterFailed &lt;&lt; #osSignalHandler &gt;&gt; 'Registering signal callback failed') ].</body></methods><methods><class-id>OS.WindowsSignalHandler</class-id> <category>accessing</category><body package="OSProcessSignalHandler">knownSignalNames	^ self lifecycleSignalNames</body><body package="OSProcessSignalHandler">lifecycleSignalNames	^ #(		" console handler "		CTRL_C_EVENT 		CTRL_BREAK_EVENT 		CTRL_CLOSE_EVENT		CTRL_LOGOFF_EVENT 		CTRL_SHUTDOWN_EVENT		" window event handler "		PBT_APMSUSPEND		PBT_APMRESUMEAUTOMATIC	)</body></methods><methods><class-id>OS.WindowsSignalHandler class</class-id> <category>accessing</category><body package="OSProcessSignalHandler">platforms	^ #(win32)</body></methods><methods><class-id>UI.WindowsInputManager</class-id> <category>notification</category><body package="OSProcessSignalHandler">processHostEvent: aHostEventArray	" be very careful, raising errors while handling unknown events can easily break down the system "	[ 		OSProcessSignalHandler currentOrNil ifNotNil: [: signalHandler | signalHandler handleHostEvent: aHostEventArray ]	] on: Error do: [: ex | ].	^ super processHostEvent: aHostEventArray</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>types</category><body package="OSProcessSignalHandler">PHANDLER_ROUTINE	&lt;C: typedef BOOL  (__stdcall * PHANDLER_ROUTINE)(DWORD dwCtrlType)&gt;</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>WindowsInputManager</name><environment>UI</environment><super>UI.NullInputManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports>			private UI.WindowsInputManagerDictionary.*			</imports><category>Internationalization</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Internationalization</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>OsError</name><environment>OS</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class></st-source>