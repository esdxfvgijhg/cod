<?xml version="1.0"?><st-source><!-- Name: WinServiceNotice: The MIT LicenseCopyright (c) 2007 Christian Schuckmann and Holger KleinsorgenPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.- - Blessed: Development- - By: klnsrgn- - On: 04.11.07 11:43:57uses ExternalInterfaceBashing. recompileMethods will screw up the interface if no sources are presentComment: Allows to run an image as a Windows service. Upon startup, the image needs to start the service handler:	(WinService serviceName: 'MyService')		startAsService: [ " start the service, e.g. open sockets " ]		postStartBlock: [ " evaluated after the socket has started " ]		shutdownBlock: [ " shut down, e.g. close sockets " ].This method does not return. The block startAsService should be as brief as possible. After the block has been evaluated, WinService sets the service status to 'running'. When startup fails, a WinServiceStartupError will be raised. The default action of this signal is to quit the image.Additional initializations can be performed in the postStartBlock.The shutdown block will be evaluated when the service is stopped (either by stopping the service or shutting down Windows). After the block has been evaluated, WinService sets the service status to 'stopped'. Startup and shutdown should not exceed a runtime of 15 seconds, otherwise Windows will report an error.To install a service:	(WinService serviceName: 'MyService')		installServiceWithParameters: ''   " string with command line parameters send to the executable " 		prerequisistes: #()   " collection of service names " 		autoStart: true " true if the service should be automatically started by Windows on startup " 		startNow: false " true if the service should be started after installation " To deinstall a service:	(WinService serviceName: 'MyService')		deinstallService(which is equivalent to entering "sc delete MyService" in a shell).The executable is running with system32 / SysWOW64 as current directory, so you might want to change the current directory on startup, e.g.    CEnvironment commandLine first asFilename directory beCurrentDirectory.Contact: 	c . schuckmann -at- i-views . de	h . kleinsorgen -at- i-views . deThe MIT LicenseCopyright (c) 2007 Christian Schuckmann and Holger KleinsorgenPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#any 'ExternalInterfaceBashing' ''))PackageName: WinServiceParcel: #('WinService')ParcelDirectory: WinServicePrerequisiteParcels: #(#('ExternalInterfaceBashing' ''))Version: (7.7).18Post-Load Block: 	[:package | WinServiceInterface bashInterface]Date: 11:15:02 AM July 18, 2014 --><time-stamp>From VisualWorksÂ®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:15:02</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WinServiceShutdownNotification</name><environment>OS</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WinService</category><attributes><package>WinService</package></attributes></class><comment><class-id>OS.WinServiceShutdownNotification</class-id><body>Raised before the service is shut down. It can be catched within the post start block.</body></comment><class><name>WinServiceError</name><environment>OS</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WinService</category><attributes><package>WinService</package></attributes></class><comment><class-id>OS.WinServiceError</class-id><body>Error class used by the Windows service interface</body></comment><class><name>WinServiceInterface</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceStatusHandle registerCallback dispatcherCallback </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.WinServiceInterfaceDictionary.*			</imports><category>ExternalInterface-New</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>advapi32.dll</item> <item>Kernel32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>WinService</package></attributes></class><comment><class-id>OS.WinServiceInterface</class-id><body>External interface for the Windows service API</body></comment><class><name>WinService</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceInterface serviceName shutdownActionBlock postStartProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WinService</category><attributes><package>WinService</package></attributes></class><comment><class-id>OS.WinService</class-id><body>Represents a Windows service running in the image. See the package comment for further instructions.</body></comment><class><name>WinServiceStartupError</name><environment>OS</environment><super>OS.WinServiceError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WinService</category><attributes><package>WinService</package></attributes></class><comment><class-id>OS.WinServiceStartupError</class-id><body>Raised when the service could not be started. Will quit the image when it is not handled.</body></comment><shared-variable><name>WinServiceInterfaceDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>WinService</package></attributes></shared-variable><shared-variable><name>RegisteredServices</name><environment>OS.WinService</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>WinService</package></attributes></shared-variable><methods><class-id>OS.WinServiceInterface</class-id> <category>procedures</category><body package="WinService">ChangeServiceConfig2W: hService with: dwInfoLevel with: lpInfo	&lt;C: BOOL _wincall ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">ChangeServiceConfigW: hService with: dwServiceType with: dwStartType with: dwErrorControl with: lpBinaryPathName with: lpLoadOrderGroup with: lpdwTagId with: lpDependencies with: lpServiceStartName with: lpPassword with: lpDisplayName	&lt;C: BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">CloseServiceHandle: hSCObject	&lt;C: BOOL CloseServiceHandle(SC_HANDLE hSCObject)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">ControlService: hService with: dwControl with: lpServiceStatus	&lt;C: BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">CreateServiceW: hSCManager with: lpServiceName with: lpDisplayName with: dwDesiredAccess with: dwServiceType with: dwStartType with: dwErrorControl with: lpBinaryPathName with: lpLoadOrderGroup with: lpdwTagId with: lpDependencies with: lpServiceStartName with: lpPassword	&lt;C:  SC_HANDLE _wincall CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">DeleteService: hService	&lt;C: BOOL DeleteService(SC_HANDLE hService)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">EnumDependentServicesW: hService with: dwServiceState with: lpServices with: cbBufSize with: pcbBytesNeeded with: lpServicesReturned	&lt;C: BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">EnumServicesStatusExW: hSCManager with: InfoLevel with: dwServiceType with: dwServiceState with: lpServices with: cbBufSize with: pcbBytesNeeded with: lpServicesReturned with: lpResumeHandle with: pszGroupName	&lt;C: BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">EnumServicesStatusW: hSCManager with: dwServiceType with: dwServiceState with: lpServices with: cbBufSize with: pcbBytesNeeded with: lpServicesReturned with: lpResumeHandle	&lt;C: BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">GetServiceDisplayNameW: hSCManager with: lpServiceName with: lpDisplayName with: lpcchBuffer	&lt;C: BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">GetServiceKeyNameW: hSCManager with: lpDisplayName with: lpServiceName with: lpcchBuffer	&lt;C: BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">LockServiceDatabase: hSCManager	&lt;C: SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">NotifyBootConfigStatus: BootAcceptable	&lt;C: BOOL NotifyBootConfigStatus(BOOL BootAcceptable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">OpenSCManagerA: lpMachineName with: lpDatabaseName with: dwDesiredAccess	&lt;C: SC_HANDLE _wincall OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">OpenSCManagerW: lpMachineName with: lpDatabaseName with: dwDesiredAccess	&lt;C: SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">OpenServiceW: hSCManager with: lpServiceName with: dwDesiredAccess	&lt;C: SC_HANDLE _wincall OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">QueryServiceConfig2W: hService with: dwInfoLevel with: lpBuffer with: cbBufSize with: pcbBytesNeeded	&lt;C: BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">QueryServiceConfigW: hService with: lpServiceConfig with: cbBufSize with: pcbBytesNeeded	&lt;C: BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">QueryServiceLockStatusW: hSCManager with: lpLockStatus with: cbBufSize with: pcbBytesNeeded	&lt;C: BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">QueryServiceObjectSecurity: hService with: dwSecurityInformation with: lpSecurityDescriptor with: cbBufSize with: pcbBytesNeeded	&lt;C: BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">QueryServiceStatus: hService with: lpServiceStatus	&lt;C: BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">QueryServiceStatusEx: hService with: InfoLevel with: lpBuffer with: cbBufSize with: pcbBytesNeeded	&lt;C: BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">RegisterServiceCtrlHandlerExW: lpServiceName with: lpHandlerProc with: lpContext	&lt;C: SERVICE_STATUS_HANDLE _wincall RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">RegisterServiceCtrlHandlerW: lpServiceName with: lpHandlerProc	&lt;C: SERVICE_STATUS_HANDLE _wincall RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">SetServiceObjectSecurity: hService with: dwSecurityInformation with: lpSecurityDescriptor	&lt;C: BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">SetServiceStatus: hServiceStatus with: lpServiceStatus	&lt;C: BOOL _wincall SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">StartServiceCtrlDispatcherW: lpServiceStartTable	&lt;C: BOOL _threaded _wincall StartServiceCtrlDispatcherW(SERVICE_TABLE_ENTRYW * lpServiceStartTable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">StartServiceW: hService with: dwNumServiceArgs with: lpServiceArgVectors	&lt;C: BOOL _wincall StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR * lpServiceArgVectors)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinService">UnlockServiceDatabase: ScLock	&lt;C: BOOL UnlockServiceDatabase(SC_LOCK ScLock)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>types</category><body package="WinService">BOOL	&lt;C: typedef long BOOL&gt;</body><body package="WinService">BYTE	&lt;C: typedef void * BYTE&gt;</body><body package="WinService">DISPATCH_TABLE	&lt;C: typedef SERVICE_TABLE_ENTRY DISPATCH_TABLE[2]&gt;</body><body package="WinService">DISPATCH_TABLEA	&lt;C: typedef SERVICE_TABLE_ENTRYA DISPATCH_TABLEA[2]&gt;</body><body package="WinService">DISPATCH_TABLEW	&lt;C: typedef SERVICE_TABLE_ENTRYW DISPATCH_TABLEW[2]&gt;</body><body package="WinService">DWORD	&lt;C: typedef unsigned long DWORD&gt;</body><body package="WinService">ENUM_SERVICE_STATUS	&lt;C: typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS&gt;</body><body package="WinService">ENUM_SERVICE_STATUSA	&lt;C: typedef struct _ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUSA&gt;</body><body package="WinService">ENUM_SERVICE_STATUSW	&lt;C: typedef struct _ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUSW&gt;</body><body package="WinService">ENUM_SERVICE_STATUS_PROCESS	&lt;C: typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS&gt;</body><body package="WinService">ENUM_SERVICE_STATUS_PROCESSA	&lt;C: typedef struct _ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESSA&gt;</body><body package="WinService">ENUM_SERVICE_STATUS_PROCESSW	&lt;C: typedef struct _ENUM_SERVICE_STATUS_PROCESSW ENUM_SERVICE_STATUS_PROCESSW&gt;</body><body package="WinService">LPBYTE	&lt;C: typedef BYTE * LPBYTE&gt;</body><body package="WinService">LPCSTR	&lt;C: typedef const char * LPCSTR&gt;</body><body package="WinService">LPCWSTR	&lt;C: typedef const WCHAR * LPCWSTR&gt;</body><body package="WinService">LPDWORD	&lt;C: typedef DWORD * LPDWORD&gt;</body><body package="WinService">LPENUM_SERVICE_STATUS	&lt;C: typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS&gt;</body><body package="WinService">LPENUM_SERVICE_STATUSA	&lt;C: typedef struct _ENUM_SERVICE_STATUSA * LPENUM_SERVICE_STATUSA&gt;</body><body package="WinService">LPENUM_SERVICE_STATUSW	&lt;C: typedef struct _ENUM_SERVICE_STATUSW * LPENUM_SERVICE_STATUSW&gt;</body><body package="WinService">LPENUM_SERVICE_STATUS_PROCESS	&lt;C: typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS&gt;</body><body package="WinService">LPENUM_SERVICE_STATUS_PROCESSA	&lt;C: typedef struct _ENUM_SERVICE_STATUS_PROCESSA * LPENUM_SERVICE_STATUS_PROCESSA&gt;</body><body package="WinService">LPENUM_SERVICE_STATUS_PROCESSW	&lt;C: typedef struct _ENUM_SERVICE_STATUS_PROCESSW * LPENUM_SERVICE_STATUS_PROCESSW&gt;</body><body package="WinService">LPHANDLER_FUNCTION	&lt;C: typedef VOID (__stdcall * LPHANDLER_FUNCTION)(DWORD dwControl)&gt;</body><body package="WinService">LPHANDLER_FUNCTION_EX	&lt;C: typedef DWORD (__stdcall * LPHANDLER_FUNCTION_EX)(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)&gt;</body><body package="WinService">LPQUERY_SERVICE_CONFIG	&lt;C: typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG&gt;</body><body package="WinService">LPQUERY_SERVICE_CONFIGA	&lt;C: typedef struct _QUERY_SERVICE_CONFIGA * LPQUERY_SERVICE_CONFIGA&gt;</body><body package="WinService">LPQUERY_SERVICE_CONFIGW	&lt;C: typedef struct _QUERY_SERVICE_CONFIGW * LPQUERY_SERVICE_CONFIGW&gt;</body><body package="WinService">LPQUERY_SERVICE_LOCK_STATUS	&lt;C: typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS&gt;</body><body package="WinService">LPQUERY_SERVICE_LOCK_STATUSA	&lt;C: typedef struct _QUERY_SERVICE_LOCK_STATUSA * LPQUERY_SERVICE_LOCK_STATUSA&gt;</body><body package="WinService">LPQUERY_SERVICE_LOCK_STATUSW	&lt;C: typedef struct _QUERY_SERVICE_LOCK_STATUSW * LPQUERY_SERVICE_LOCK_STATUSW&gt;</body><body package="WinService">LPSC_ACTION	&lt;C: typedef struct _SC_ACTION * LPSC_ACTION&gt;</body><body package="WinService">LPSC_HANDLE	&lt;C: typedef SC_HANDLE * LPSC_HANDLE&gt;</body><body package="WinService">LPSERVICE_DESCRIPTION	&lt;C: typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION&gt;</body><body package="WinService">LPSERVICE_DESCRIPTIONA	&lt;C: typedef struct _SERVICE_DESCRIPTIONA * LPSERVICE_DESCRIPTIONA&gt;</body><body package="WinService">LPSERVICE_DESCRIPTIONW	&lt;C: typedef struct _SERVICE_DESCRIPTIONW * LPSERVICE_DESCRIPTIONW&gt;</body><body package="WinService">LPSERVICE_FAILURE_ACTIONS	&lt;C: typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS&gt;</body><body package="WinService">LPSERVICE_FAILURE_ACTIONSA	&lt;C: typedef struct _SERVICE_FAILURE_ACTIONSA * LPSERVICE_FAILURE_ACTIONSA&gt;</body><body package="WinService">LPSERVICE_FAILURE_ACTIONSW	&lt;C: typedef struct _SERVICE_FAILURE_ACTIONSW * LPSERVICE_FAILURE_ACTIONSW&gt;</body><body package="WinService">LPSERVICE_MAIN_FUNCTION	&lt;C: typedef void (* LPSERVICE_MAIN_FUNCTION)(DWORD, LPSTR * )&gt;</body><body package="WinService">LPSERVICE_MAIN_FUNCTIONA	&lt;C: typedef VOID (* LPSERVICE_MAIN_FUNCTIONA)(DWORD dwNumServicesArgs, LPSTR * lpServiceArgVectors)&gt;</body><body package="WinService">LPSERVICE_MAIN_FUNCTIONW	&lt;C: typedef VOID (__stdcall * LPSERVICE_MAIN_FUNCTIONW)(DWORD dwNumServicesArgs, LPWSTR * lpServiceArgVectors)&gt;</body><body package="WinService">LPSERVICE_STATUS	&lt;C: typedef struct _SERVICE_STATUS * LPSERVICE_STATUS&gt;</body><body package="WinService">LPSERVICE_STATUS_PROCESS	&lt;C: typedef struct _SERVICE_STATUS_PROCESS * LPSERVICE_STATUS_PROCESS&gt;</body><body package="WinService">LPSERVICE_TABLE_ENTRY	&lt;C: typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY&gt;</body><body package="WinService">LPSERVICE_TABLE_ENTRYA	&lt;C: typedef struct _SERVICE_TABLE_ENTRYA * LPSERVICE_TABLE_ENTRYA&gt;</body><body package="WinService">LPSERVICE_TABLE_ENTRYW	&lt;C: typedef struct _SERVICE_TABLE_ENTRYW * LPSERVICE_TABLE_ENTRYW&gt;</body><body package="WinService">LPSTR	&lt;C: typedef char * LPSTR&gt;</body><body package="WinService">LPVOID	&lt;C: typedef void * LPVOID&gt;</body><body package="WinService">LPWSTR	&lt;C: typedef WCHAR * LPWSTR&gt;</body><body package="WinService">PSECURITY_DESCRIPTOR	&lt;C: typedef void * PSECURITY_DESCRIPTOR&gt;</body><body package="WinService">QUERY_SERVICE_CONFIG	&lt;C: typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG&gt;</body><body package="WinService">QUERY_SERVICE_CONFIGA	&lt;C: typedef struct _QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIGA&gt;</body><body package="WinService">QUERY_SERVICE_CONFIGW	&lt;C: typedef struct _QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIGW&gt;</body><body package="WinService">QUERY_SERVICE_LOCK_STATUS	&lt;C: typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS&gt;</body><body package="WinService">QUERY_SERVICE_LOCK_STATUSA	&lt;C: typedef struct _QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUSA&gt;</body><body package="WinService">QUERY_SERVICE_LOCK_STATUSW	&lt;C: typedef struct _QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUSW&gt;</body><body package="WinService">SC_ACTION	&lt;C: typedef struct _SC_ACTION SC_ACTION&gt;</body><body package="WinService">SC_ACTION_TYPE	&lt;C: typedef enum _SC_ACTION_TYPE SC_ACTION_TYPE&gt;</body><body package="WinService">SC_ENUM_TYPE	&lt;C: typedef enum _SC_ENUM_TYPE SC_ENUM_TYPE&gt;</body><body package="WinService">SC_HANDLE	&lt;C: typedef void * SC_HANDLE&gt;</body><body package="WinService">SC_LOCK	&lt;C: typedef LPVOID SC_LOCK&gt;</body><body package="WinService">SC_STATUS_TYPE	&lt;C: typedef enum _SC_STATUS_TYPE SC_STATUS_TYPE&gt;</body><body package="WinService">SECURITY_INFORMATION	&lt;C: typedef void * SECURITY_INFORMATION&gt;</body><body package="WinService">SERVICE_DESCRIPTION	&lt;C: typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION&gt;</body><body package="WinService">SERVICE_DESCRIPTIONA	&lt;C: typedef struct _SERVICE_DESCRIPTIONA SERVICE_DESCRIPTIONA&gt;</body><body package="WinService">SERVICE_DESCRIPTIONW	&lt;C: typedef struct _SERVICE_DESCRIPTIONW SERVICE_DESCRIPTIONW&gt;</body><body package="WinService">SERVICE_FAILURE_ACTIONS	&lt;C: typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS&gt;</body><body package="WinService">SERVICE_FAILURE_ACTIONSA	&lt;C: typedef struct _SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONSA&gt;</body><body package="WinService">SERVICE_FAILURE_ACTIONSW	&lt;C: typedef struct _SERVICE_FAILURE_ACTIONSW SERVICE_FAILURE_ACTIONSW&gt;</body><body package="WinService">SERVICE_STATUS	&lt;C: typedef struct _SERVICE_STATUS SERVICE_STATUS&gt;</body><body package="WinService">SERVICE_STATUS_HANDLE	&lt;C: typedef void * SERVICE_STATUS_HANDLE&gt;</body><body package="WinService">SERVICE_STATUS_PROCESS	&lt;C: typedef struct _SERVICE_STATUS_PROCESS SERVICE_STATUS_PROCESS&gt;</body><body package="WinService">SERVICE_TABLE_ENTRY	&lt;C: typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY&gt;</body><body package="WinService">SERVICE_TABLE_ENTRYA	&lt;C: typedef struct _SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRYA&gt;</body><body package="WinService">SERVICE_TABLE_ENTRYW	&lt;C: typedef struct _SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRYW&gt;</body><body package="WinService">VOID	&lt;C: typedef void VOID&gt;</body><body package="WinService">WCHAR	&lt;C: typedef unsigned short WCHAR&gt;</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>defines</category><body package="WinService">ERROR_CALL_NOT_IMPLEMENTED	&lt;C: #define ERROR_CALL_NOT_IMPLEMENTED 120&gt;</body><body package="WinService">NO_ERROR	&lt;C: #define NO_ERROR 0	&gt;</body><body package="WinService">SC_GROUP_IDENTIFIER	&lt;C: #define SC_GROUP_IDENTIFIER SC_GROUP_IDENTIFIERA	&gt;</body><body package="WinService">SC_GROUP_IDENTIFIERA	&lt;C: #define SC_GROUP_IDENTIFIERA 43	&gt;</body><body package="WinService">SC_GROUP_IDENTIFIERW	&lt;C: #define SC_GROUP_IDENTIFIERW L 43	&gt;</body><body package="WinService">SC_MANAGER_ALL_ACCESS	&lt;C: #define SC_MANAGER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_LOCK | SC_MANAGER_QUERY_LOCK_STATUS | SC_MANAGER_MODIFY_BOOT_CONFIG)	&gt;</body><body package="WinService">SC_MANAGER_CONNECT	&lt;C: #define SC_MANAGER_CONNECT 0x0001	&gt;</body><body package="WinService">SC_MANAGER_CREATE_SERVICE	&lt;C: #define SC_MANAGER_CREATE_SERVICE 0x0002	&gt;</body><body package="WinService">SC_MANAGER_ENUMERATE_SERVICE	&lt;C: #define SC_MANAGER_ENUMERATE_SERVICE 0x0004	&gt;</body><body package="WinService">SC_MANAGER_LOCK	&lt;C: #define SC_MANAGER_LOCK 0x0008	&gt;</body><body package="WinService">SC_MANAGER_MODIFY_BOOT_CONFIG	&lt;C: #define SC_MANAGER_MODIFY_BOOT_CONFIG 0x0020	&gt;</body><body package="WinService">SC_MANAGER_QUERY_LOCK_STATUS	&lt;C: #define SC_MANAGER_QUERY_LOCK_STATUS 0x0010	&gt;</body><body package="WinService">SERVICES_ACTIVE_DATABASE	&lt;C: #define SERVICES_ACTIVE_DATABASE SERVICES_ACTIVE_DATABASEA	&gt;</body><body package="WinService">SERVICES_ACTIVE_DATABASEA	&lt;C: #define SERVICES_ACTIVE_DATABASEA "ServicesActive"	&gt;</body><body package="WinService">SERVICES_ACTIVE_DATABASEW	&lt;C: #define SERVICES_ACTIVE_DATABASEW L "ServicesActive"	&gt;</body><body package="WinService">SERVICES_FAILED_DATABASE	&lt;C: #define SERVICES_FAILED_DATABASE SERVICES_FAILED_DATABASEA	&gt;</body><body package="WinService">SERVICES_FAILED_DATABASEA	&lt;C: #define SERVICES_FAILED_DATABASEA "ServicesFailed"	&gt;</body><body package="WinService">SERVICES_FAILED_DATABASEW	&lt;C: #define SERVICES_FAILED_DATABASEW L "ServicesFailed"	&gt;</body><body package="WinService">SERVICE_ACCEPT_HARDWAREPROFILECHANGE	&lt;C: #define SERVICE_ACCEPT_HARDWAREPROFILECHANGE 0x00000020	&gt;</body><body package="WinService">SERVICE_ACCEPT_NETBINDCHANGE	&lt;C: #define SERVICE_ACCEPT_NETBINDCHANGE 0x00000010	&gt;</body><body package="WinService">SERVICE_ACCEPT_PARAMCHANGE	&lt;C: #define SERVICE_ACCEPT_PARAMCHANGE 0x00000008	&gt;</body><body package="WinService">SERVICE_ACCEPT_PAUSE_CONTINUE	&lt;C: #define SERVICE_ACCEPT_PAUSE_CONTINUE 0x00000002	&gt;</body><body package="WinService">SERVICE_ACCEPT_POWEREVENT	&lt;C: #define SERVICE_ACCEPT_POWEREVENT 0x00000040	&gt;</body><body package="WinService">SERVICE_ACCEPT_PRESHUTDOWN	&lt;C: #define SERVICE_ACCEPT_PRESHUTDOWN 0x00000100	&gt;</body><body package="WinService">SERVICE_ACCEPT_SESSIONCHANGE	&lt;C: #define SERVICE_ACCEPT_SESSIONCHANGE 0x00000080	&gt;</body><body package="WinService">SERVICE_ACCEPT_SHUTDOWN	&lt;C: #define SERVICE_ACCEPT_SHUTDOWN 0x00000004	&gt;</body><body package="WinService">SERVICE_ACCEPT_STOP	&lt;C: #define SERVICE_ACCEPT_STOP 0x00000001	&gt;</body><body package="WinService">SERVICE_ACTIVE	&lt;C: #define SERVICE_ACTIVE 0x00000001	&gt;</body><body package="WinService">SERVICE_ADAPTER	&lt;C: #define SERVICE_ADAPTER 0x00000004	&gt;</body><body package="WinService">SERVICE_ALL_ACCESS	&lt;C: #define SERVICE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_START | SERVICE_STOP | SERVICE_PAUSE_CONTINUE | SERVICE_INTERROGATE | SERVICE_USER_DEFINED_CONTROL)	&gt;</body><body package="WinService">SERVICE_AUTO_START	&lt;C: #define SERVICE_AUTO_START 0x00000002	&gt;</body><body package="WinService">SERVICE_BOOT_START	&lt;C: #define SERVICE_BOOT_START 0x00000000	&gt;</body><body package="WinService">SERVICE_CHANGE_CONFIG	&lt;C: #define SERVICE_CHANGE_CONFIG 0x0002	&gt;</body><body package="WinService">SERVICE_CONFIG_DESCRIPTION	&lt;C: #define SERVICE_CONFIG_DESCRIPTION 1	&gt;</body><body package="WinService">SERVICE_CONFIG_FAILURE_ACTIONS	&lt;C: #define SERVICE_CONFIG_FAILURE_ACTIONS 2	&gt;</body><body package="WinService">SERVICE_CONTINUE_PENDING	&lt;C: #define SERVICE_CONTINUE_PENDING 0x00000005	&gt;</body><body package="WinService">SERVICE_CONTROL_CONTINUE	&lt;C: #define SERVICE_CONTROL_CONTINUE 0x00000003	&gt;</body><body package="WinService">SERVICE_CONTROL_DEVICEEVENT	&lt;C: #define SERVICE_CONTROL_DEVICEEVENT 0x0000000B	&gt;</body><body package="WinService">SERVICE_CONTROL_HARDWAREPROFILECHANGE	&lt;C: #define SERVICE_CONTROL_HARDWAREPROFILECHANGE 0x0000000C	&gt;</body><body package="WinService">SERVICE_CONTROL_INTERROGATE	&lt;C: #define SERVICE_CONTROL_INTERROGATE 0x00000004	&gt;</body><body package="WinService">SERVICE_CONTROL_NETBINDADD	&lt;C: #define SERVICE_CONTROL_NETBINDADD 0x00000007	&gt;</body><body package="WinService">SERVICE_CONTROL_NETBINDDISABLE	&lt;C: #define SERVICE_CONTROL_NETBINDDISABLE 0x0000000A	&gt;</body><body package="WinService">SERVICE_CONTROL_NETBINDENABLE	&lt;C: #define SERVICE_CONTROL_NETBINDENABLE 0x00000009	&gt;</body><body package="WinService">SERVICE_CONTROL_NETBINDREMOVE	&lt;C: #define SERVICE_CONTROL_NETBINDREMOVE 0x00000008	&gt;</body><body package="WinService">SERVICE_CONTROL_PARAMCHANGE	&lt;C: #define SERVICE_CONTROL_PARAMCHANGE 0x00000006	&gt;</body><body package="WinService">SERVICE_CONTROL_PAUSE	&lt;C: #define SERVICE_CONTROL_PAUSE 0x00000002	&gt;</body><body package="WinService">SERVICE_CONTROL_POWEREVENT	&lt;C: #define SERVICE_CONTROL_POWEREVENT 0x0000000D	&gt;</body><body package="WinService">SERVICE_CONTROL_PRESHUTDOWN	&lt;C: #define SERVICE_CONTROL_PRESHUTDOWN 0x0000000F	&gt;</body><body package="WinService">SERVICE_CONTROL_SESSIONCHANGE	&lt;C: #define SERVICE_CONTROL_SESSIONCHANGE 0x0000000E	&gt;</body><body package="WinService">SERVICE_CONTROL_SHUTDOWN	&lt;C: #define SERVICE_CONTROL_SHUTDOWN 0x00000005	&gt;</body><body package="WinService">SERVICE_CONTROL_STOP	&lt;C: #define SERVICE_CONTROL_STOP 0x00000001	&gt;</body><body package="WinService">SERVICE_DEMAND_START	&lt;C: #define SERVICE_DEMAND_START 0x00000003	&gt;</body><body package="WinService">SERVICE_DISABLED	&lt;C: #define SERVICE_DISABLED 0x00000004	&gt;</body><body package="WinService">SERVICE_DRIVER	&lt;C: #define SERVICE_DRIVER (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_RECOGNIZER_DRIVER)	&gt;</body><body package="WinService">SERVICE_ENUMERATE_DEPENDENTS	&lt;C: #define SERVICE_ENUMERATE_DEPENDENTS 0x0008	&gt;</body><body package="WinService">SERVICE_ERROR_CRITICAL	&lt;C: #define SERVICE_ERROR_CRITICAL 0x00000003	&gt;</body><body package="WinService">SERVICE_ERROR_IGNORE	&lt;C: #define SERVICE_ERROR_IGNORE 0x00000000	&gt;</body><body package="WinService">SERVICE_ERROR_NORMAL	&lt;C: #define SERVICE_ERROR_NORMAL 0x00000001	&gt;</body><body package="WinService">SERVICE_ERROR_SEVERE	&lt;C: #define SERVICE_ERROR_SEVERE 0x00000002	&gt;</body><body package="WinService">SERVICE_FILE_SYSTEM_DRIVER	&lt;C: #define SERVICE_FILE_SYSTEM_DRIVER 0x00000002	&gt;</body><body package="WinService">SERVICE_INACTIVE	&lt;C: #define SERVICE_INACTIVE 0x00000002	&gt;</body><body package="WinService">SERVICE_INTERACTIVE_PROCESS	&lt;C: #define SERVICE_INTERACTIVE_PROCESS 0x00000100	&gt;</body><body package="WinService">SERVICE_INTERROGATE	&lt;C: #define SERVICE_INTERROGATE 0x0080	&gt;</body><body package="WinService">SERVICE_KERNEL_DRIVER	&lt;C: #define SERVICE_KERNEL_DRIVER 0x00000001	&gt;</body><body package="WinService">SERVICE_NO_CHANGE	&lt;C: #define SERVICE_NO_CHANGE 4294967295	&gt;</body><body package="WinService">SERVICE_PAUSED	&lt;C: #define SERVICE_PAUSED 0x00000007	&gt;</body><body package="WinService">SERVICE_PAUSE_CONTINUE	&lt;C: #define SERVICE_PAUSE_CONTINUE 0x0040	&gt;</body><body package="WinService">SERVICE_PAUSE_PENDING	&lt;C: #define SERVICE_PAUSE_PENDING 0x00000006	&gt;</body><body package="WinService">SERVICE_QUERY_CONFIG	&lt;C: #define SERVICE_QUERY_CONFIG 0x0001	&gt;</body><body package="WinService">SERVICE_QUERY_STATUS	&lt;C: #define SERVICE_QUERY_STATUS 0x0004	&gt;</body><body package="WinService">SERVICE_RECOGNIZER_DRIVER	&lt;C: #define SERVICE_RECOGNIZER_DRIVER 0x00000008	&gt;</body><body package="WinService">SERVICE_RUNNING	&lt;C: #define SERVICE_RUNNING 0x00000004	&gt;</body><body package="WinService">SERVICE_RUNS_IN_SYSTEM_PROCESS	&lt;C: #define SERVICE_RUNS_IN_SYSTEM_PROCESS 0x00000001	&gt;</body><body package="WinService">SERVICE_START	&lt;C: #define SERVICE_START 0x0010	&gt;</body><body package="WinService">SERVICE_START_PENDING	&lt;C: #define SERVICE_START_PENDING 0x00000002	&gt;</body><body package="WinService">SERVICE_STATE_ALL	&lt;C: #define SERVICE_STATE_ALL (SERVICE_ACTIVE | SERVICE_INACTIVE)	&gt;</body><body package="WinService">SERVICE_STOP	&lt;C: #define SERVICE_STOP 0x0020	&gt;</body><body package="WinService">SERVICE_STOPPED	&lt;C: #define SERVICE_STOPPED 0x00000001	&gt;</body><body package="WinService">SERVICE_STOP_PENDING	&lt;C: #define SERVICE_STOP_PENDING 0x00000003	&gt;</body><body package="WinService">SERVICE_SYSTEM_START	&lt;C: #define SERVICE_SYSTEM_START 0x00000001	&gt;</body><body package="WinService">SERVICE_TYPE_ALL	&lt;C: #define SERVICE_TYPE_ALL (SERVICE_WIN32 | SERVICE_ADAPTER | SERVICE_DRIVER | SERVICE_INTERACTIVE_PROCESS)	&gt;</body><body package="WinService">SERVICE_USER_DEFINED_CONTROL	&lt;C: #define SERVICE_USER_DEFINED_CONTROL 256	&gt;</body><body package="WinService">SERVICE_WIN32	&lt;C: #define SERVICE_WIN32 (SERVICE_WIN32_OWN_PROCESS | SERVICE_WIN32_SHARE_PROCESS)	&gt;</body><body package="WinService">SERVICE_WIN32_OWN_PROCESS	&lt;C: #define SERVICE_WIN32_OWN_PROCESS 0x00000010	&gt;</body><body package="WinService">SERVICE_WIN32_SHARE_PROCESS	&lt;C: #define SERVICE_WIN32_SHARE_PROCESS 0x00000020	&gt;</body><body package="WinService">STANDARD_RIGHTS_REQUIRED	&lt;C: #define STANDARD_RIGHTS_REQUIRED 983040	&gt;</body><body package="WinService">_WINSVCNT_	&lt;C: #define _WINSVCNT_ 	&gt;</body><body package="WinService">_WINSVC_	&lt;C: #define _WINSVC_ 	&gt;</body><body package="WinService">__DATE__	&lt;C: #define __DATE__ "Samstag, 1. November 2008"	&gt;</body><body package="WinService">__FILE__	&lt;C: #define __FILE__ 	&gt;</body><body package="WinService">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="WinService">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="WinService">__TIME__	&lt;C: #define __TIME__ "11:41:11"	&gt;</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>comfy - status</category><body package="WinService">denyStopWhile: aBlock	self setServiceRunningUnstoppleStatus.	^ aBlock ensure: [ self setServiceRunningStatus ].</body><body package="WinService">forkPendingTickerProcess: statusCode	" tell SCM we're busy "	^ [ | counter waitHint |		counter := 1.		waitHint := 60000.		[	self setServiceStatus: statusCode checkPoint: counter waitHint: waitHint controlsAccepted: 0.			counter := counter + 1.			( Delay forMilliseconds: 10000) wait		] repeat	] forkAt: Processor lowIOPriority + 1</body><body package="WinService">forkShutdownPendingTickerProcess	" tell SCM we're busy "	^ self forkPendingTickerProcess: self SERVICE_STOP_PENDING</body><body package="WinService">forkStartupPendingTickerProcess	" tell SCM we're busy "	^ self forkPendingTickerProcess: self SERVICE_START_PENDING</body><body package="WinService">setServiceRunningStatus	self setServiceStatus: self SERVICE_RUNNING.</body><body package="WinService">setServiceRunningUnstoppleStatus	self setServiceStatus: self SERVICE_RUNNING checkPoint: 0 waitHint: 0 controlsAccepted: 0.</body><body package="WinService">setServiceStatus: statusCode	self setServiceStatus: statusCode checkPoint: 0 waitHint: 0</body><body package="WinService">setServiceStatus: statusCode checkPoint: checkPoint waitHint: waitHint 	| stopBits |	stopBits := self SERVICE_ACCEPT_STOP bitOr: self SERVICE_ACCEPT_SHUTDOWN.	OSHandle windowsVersion &gt;= 6 		ifTrue: 		[	" accept (and thus receive) preshutdown notification (requires &gt;= Vista) "			stopBits := stopBits bitOr: self SERVICE_ACCEPT_PRESHUTDOWN		].	self 		try: [ self setServiceStatus: statusCode checkPoint: checkPoint waitHint: waitHint controlsAccepted: stopBits ]		errorMessage: 'Failed to set service status'.</body><body package="WinService">setServiceStatus: statusCode checkPoint: checkPoint waitHint: waitHint controlsAccepted: controlsAccepted	| status |	status := self SERVICE_STATUS malloc.	status memberAt: #dwServiceType put: self SERVICE_WIN32.	status memberAt: #dwCurrentState put: statusCode.	status memberAt: #dwCheckPoint put: checkPoint.	status memberAt: #dwWaitHint put: waitHint.	status memberAt: #dwWin32ExitCode put: 0.	status memberAt: #dwServiceSpecificExitCode put: 0.	status memberAt: #dwControlsAccepted put: controlsAccepted.	self SetServiceStatus: serviceStatusHandle with: status.	status free.</body><body package="WinService">setServiceStoppedStatus	self setServiceStatus: self SERVICE_STOPPED.</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>structs</category><body package="WinService">_ENUM_SERVICE_STATUSA	&lt;C: struct _ENUM_SERVICE_STATUSA {			LPSTR lpServiceName, lpDisplayName;			SERVICE_STATUS ServiceStatus;		}&gt;</body><body package="WinService">_ENUM_SERVICE_STATUSW	&lt;C: struct _ENUM_SERVICE_STATUSW {			LPWSTR lpServiceName, lpDisplayName;			SERVICE_STATUS ServiceStatus;		}&gt;</body><body package="WinService">_ENUM_SERVICE_STATUS_PROCESSA	&lt;C: struct _ENUM_SERVICE_STATUS_PROCESSA {			LPSTR lpServiceName, lpDisplayName;			SERVICE_STATUS_PROCESS ServiceStatusProcess;		}&gt;</body><body package="WinService">_ENUM_SERVICE_STATUS_PROCESSW	&lt;C: struct _ENUM_SERVICE_STATUS_PROCESSW {			LPWSTR lpServiceName, lpDisplayName;			SERVICE_STATUS_PROCESS ServiceStatusProcess;		}&gt;</body><body package="WinService">_QUERY_SERVICE_CONFIGA	&lt;C: struct _QUERY_SERVICE_CONFIGA {			DWORD dwServiceType, dwStartType, dwErrorControl;			LPSTR lpBinaryPathName, lpLoadOrderGroup;			DWORD dwTagId;			LPSTR lpDependencies, lpServiceStartName, lpDisplayName;		}&gt;</body><body package="WinService">_QUERY_SERVICE_CONFIGW	&lt;C: struct _QUERY_SERVICE_CONFIGW {			DWORD dwServiceType, dwStartType, dwErrorControl;			LPWSTR lpBinaryPathName, lpLoadOrderGroup;			DWORD dwTagId;			LPWSTR lpDependencies, lpServiceStartName, lpDisplayName;		}&gt;</body><body package="WinService">_QUERY_SERVICE_LOCK_STATUSA	&lt;C: struct _QUERY_SERVICE_LOCK_STATUSA {			DWORD fIsLocked;			LPSTR lpLockOwner;			DWORD dwLockDuration;		}&gt;</body><body package="WinService">_QUERY_SERVICE_LOCK_STATUSW	&lt;C: struct _QUERY_SERVICE_LOCK_STATUSW {			DWORD fIsLocked;			LPWSTR lpLockOwner;			DWORD dwLockDuration;		}&gt;</body><body package="WinService">_SC_ACTION	&lt;C: struct _SC_ACTION {			SC_ACTION_TYPE Type;			DWORD Delay;		}&gt;</body><body package="WinService">_SERVICE_DESCRIPTIONA	&lt;C: struct _SERVICE_DESCRIPTIONA {			LPSTR lpDescription;		}&gt;</body><body package="WinService">_SERVICE_DESCRIPTIONW	&lt;C: struct _SERVICE_DESCRIPTIONW {			LPWSTR lpDescription;		}&gt;</body><body package="WinService">_SERVICE_FAILURE_ACTIONSA	&lt;C: struct _SERVICE_FAILURE_ACTIONSA {			DWORD dwResetPeriod;			LPSTR lpRebootMsg, lpCommand;			DWORD cActions;			SC_ACTION * lpsaActions;		}&gt;</body><body package="WinService">_SERVICE_FAILURE_ACTIONSW	&lt;C: struct _SERVICE_FAILURE_ACTIONSW {			DWORD dwResetPeriod;			LPWSTR lpRebootMsg, lpCommand;			DWORD cActions;			SC_ACTION * lpsaActions;		}&gt;</body><body package="WinService">_SERVICE_STATUS	&lt;C: struct _SERVICE_STATUS {			DWORD dwServiceType, dwCurrentState, dwControlsAccepted, dwWin32ExitCode, dwServiceSpecificExitCode, dwCheckPoint, dwWaitHint;		}&gt;</body><body package="WinService">_SERVICE_STATUS_PROCESS	&lt;C: struct _SERVICE_STATUS_PROCESS {			DWORD dwServiceType, dwCurrentState, dwControlsAccepted, dwWin32ExitCode, dwServiceSpecificExitCode, dwCheckPoint, dwWaitHint, dwProcessId, dwServiceFlags;		}&gt;</body><body package="WinService">_SERVICE_TABLE_ENTRYA	&lt;C: struct _SERVICE_TABLE_ENTRYA {			LPSTR lpServiceName;			LPSERVICE_MAIN_FUNCTIONA lpServiceProc;		}&gt;</body><body package="WinService">_SERVICE_TABLE_ENTRYW	&lt;C: struct _SERVICE_TABLE_ENTRYW {			LPWSTR lpServiceName;			LPSERVICE_MAIN_FUNCTIONW lpServiceProc;		}&gt;</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>comfy - install/deinstall</category><body package="WinService">deregisterService: serviceName 	self serviceHandleFor: serviceName accessLevel: self SERVICE_ALL_ACCESS do: [: serviceHandle | 		self DeleteService: serviceHandle 	].</body><body package="WinService">registerService: aString path: filePath	^ self registerService: aString path: filePath prerequisites: nil</body><body package="WinService">registerService: aString path: filePath prerequisites: prerequisites	^ self registerService: aString path: filePath prerequisites: prerequisites autoStart: false</body><body package="WinService">registerService: serviceName path: filePath prerequisites: prerequisites autoStart: isAutoStart 	^ self registerService: serviceName path: filePath prerequisites: prerequisites autoStart: isAutoStart startNow: isAutoStart</body><body package="WinService">registerService: serviceName path: filePath prerequisites: prerequisites autoStart: isAutoStart startNow: startNow 	| manager dependencies scHandle pServiceName pFilePath pDependencies |	dependencies := self createDependenciesArrayFrom: prerequisites.	manager := self try: [ self OpenSCManagerA: nil with: nil with: self SC_MANAGER_ALL_ACCESS ] errorMessage: 'Could not open service manager'.	[	pServiceName := serviceName gcCopyToHeapUnicode.		pFilePath := filePath gcCopyToHeapUnicode.		pDependencies := dependencies notNil 				ifTrue: [ dependencies gcCopyToHeap ]				ifFalse: [ nil ].		scHandle := self 				try: 				[	self 						CreateServiceW: manager						with: pServiceName						with: pServiceName						with: self SERVICE_ALL_ACCESS						with: self SERVICE_WIN32_OWN_PROCESS						with: ( isAutoStart 								ifTrue: [ self SERVICE_AUTO_START ]								ifFalse: [ self SERVICE_DEMAND_START ])						with: self SERVICE_ERROR_NORMAL						with: pFilePath						with: nil						with: nil						with: pDependencies						with: nil						with: nil				]				errorMessage: 'New service creation failed'.		self CloseServiceHandle: scHandle	] ensure: [ manager ifNotNil: [ self CloseServiceHandle: manager ]].	startNow 		ifTrue: 		[	( Delay forSeconds: 2 ) wait.			self startService: serviceName		].</body><body package="WinService">updateDescription: aString ofService: serviceName 	" Note: Not compatible with Windows NT "	self 		serviceHandleFor: serviceName		accessLevel: self SERVICE_ALL_ACCESS		do: 		[: serviceHandle | | description pDescription |			description := self SERVICE_DESCRIPTIONW gcMalloc.			pDescription := aString gcCopyToHeapUnicode.			description memberAt: #lpDescription put: pDescription.			self 				try: [ self ChangeServiceConfig2W: serviceHandle with: self SERVICE_CONFIG_DESCRIPTION with: description ]				errorMessage: 'Could not update service description'		].</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>comfy - events</category><body package="WinService">isStopOrShutdownEvent: event	^  event = self SERVICE_CONTROL_STOP or: [ event = self SERVICE_CONTROL_SHUTDOWN or: [ event = self SERVICE_CONTROL_PRESHUTDOWN ]]</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>enums</category><body package="WinService">_SC_ACTION_TYPE	&lt;C: enum _SC_ACTION_TYPE {			SC_ACTION_NONE, 			SC_ACTION_RESTART, 			SC_ACTION_REBOOT, 			SC_ACTION_RUN_COMMAND		}&gt;</body><body package="WinService">_SC_ENUM_TYPE	&lt;C: enum _SC_ENUM_TYPE {			SC_ENUM_PROCESS_INFO		}&gt;</body><body package="WinService">_SC_STATUS_TYPE	&lt;C: enum _SC_STATUS_TYPE {			SC_STATUS_PROCESS_INFO		}&gt;</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>comfy - start/stop</category><body package="WinService">startDispatcherWithEventHandler: aHandlerBlock serviceName: aString	" Compatibility only "	self startDispatcherWithEventHandler: aHandlerBlock serviceName: aString startupBlock: [ ]</body><body package="WinService">startDispatcherWithEventHandler: aHandlerBlock serviceName: aString startupBlock: startupBlock 	" The handler block will be evaluated for all Windows service events. It will receive three arguments:		- event control code (e.g. SERVICE_CONTROL_STOP) 		- event type		- event data	Important: Contrary to earlier versions (1.0.x) of this package, the handler block must 		- quit the image after stop/shutdown events are handled		- return an error code (usually NO_ERROR)	"	| dispatchTableEntry dispatchTableEntry2 dispatchTable |	dispatcherCallback := CCallback 			do: [: dword : lpstrptr | self registerWithEventHandler: aHandlerBlock serviceName: aString startupBlock: startupBlock ]			ofType: self LPSERVICE_MAIN_FUNCTIONW.	dispatchTable := self DISPATCH_TABLEW malloc.	dispatchTableEntry := dispatchTable refAt: 0.	dispatchTableEntry memberAt: #lpServiceName put: aString gcCopyToHeapUnicode.	dispatchTableEntry memberAt: #lpServiceProc put: dispatcherCallback.	dispatchTableEntry2 := dispatchTable refAt: 1.	dispatchTableEntry2 memberAt: #lpServiceName put: nil.	dispatchTableEntry2 memberAt: #lpServiceProc put: nil.	self try: [ self StartServiceCtrlDispatcherW: dispatchTable ] errorMessage: 'Failed to start control dispatcher'</body><body package="WinService">startService: serviceName 	self 		serviceHandleFor: serviceName		accessLevel: (self STANDARD_RIGHTS_REQUIRED bitOr: self SERVICE_START)		do: [: serviceHandle | self try: [ self StartServiceW: serviceHandle with: 0 with: nil ] errorMessage: 'Failed to start service ' , serviceName ].</body></methods><methods><class-id>OS.WinServiceInterface</class-id> <category>private</category><body package="WinService">createDependenciesArrayFrom: prerequisites 	| str |	^ ( prerequisites notNil and: [ prerequisites notEmpty ]) 		ifTrue: 		[	str := ByteArray new writeStream.			prerequisites do: [: prereq | str nextPutAll: (prereq asByteArrayEncoding: #'UCS-2'); nextPut: 0; nextPut: 0 ].			str nextPut: 0; nextPut: 0.			str contents		]		ifFalse: [ nil ]</body><body package="WinService">raiseServiceError: aMessage exception: anException 	| parameter |	parameter := anException parameter.	parameter notNil 		ifTrue: 		[	parameter class = SystemError 				ifTrue: [ parameter := parameter parameter ].			WinServiceError raiseSignal: aMessage , ' (' , anException description , ', error code: ' , parameter printString , ')'		]		ifFalse: [ WinServiceError raiseSignal: aMessage , ' (' , anException description , ')' ].</body><body package="WinService">registerWithEventHandler: handlerBlock serviceName: aString startupBlock: startupBlock 	| tickerProcess |	registerCallback := CCallback 			do: 			[: dwControl : dwEventType : lpEventData : lpContext |				" lpContext is nil, so it's unnecessary to pass it to the handler block "				handlerBlock value: dwControl value: dwEventType value: lpEventData			]			ofType: self LPHANDLER_FUNCTION_EX.	serviceStatusHandle := self 			try: [ self RegisterServiceCtrlHandlerExW: aString gcCopyToHeapUnicode with: registerCallback with: nil ]			errorMessage: 'Failed to register service control handler'.	[	tickerProcess := self forkStartupPendingTickerProcess.		startupBlock ensure: [ tickerProcess terminate ].		self setServiceRunningStatus	] 		on: Error		do: 		[: ex |			self setServiceStoppedStatus.			ex pass		].	Semaphore new wait.</body><body package="WinService">serviceHandleFor: serviceName accessLevel: accessLevel do: aBlock 	| manager serviceHandle pServiceName |	manager := self OpenSCManagerW: nil with: nil with: self SC_MANAGER_ALL_ACCESS.	[	pServiceName := serviceName gcCopyToHeapUnicode.		serviceHandle := self 				try: [ self OpenServiceW: manager with: pServiceName with: accessLevel ]				errorMessage: 'Failed to get handle to service ' , serviceName.		[ aBlock value: serviceHandle ] ensure: [ self CloseServiceHandle: serviceHandle ]	] ensure: [ manager ifNotNil: [ self CloseServiceHandle: manager ]].</body><body package="WinService">try: aBlock errorMessage: aMessage	^ aBlock on: self externalAccessFailedSignal , OsError do: [: ex | self raiseServiceError: aMessage exception: ex ]</body></methods><methods><class-id>OS.WinService</class-id> <category>install</category><body package="WinService">deinstallService	" deinstall a windows service "	self checkServiceName.	self log: 'Deinstalling service'.	self serviceInterfaceDo: [ : interface | 		interface deregisterService: self serviceName.		self log: 'Deinstalled service'.	]</body><body package="WinService">installServiceWithParameters: parametersString executable: executablePath prerequisistes: prerequisistes autoStart: autoStart startNow: startNow 	" Install a windows service.		executablePath : full path to executable (VM or packaged VM + image) 		parametersString: string with parameters send to the executable		prerequisistes: collection of service names		autoStart: true if the service should be automatically started by Windows on startup		startNow: true if the service should be started after installation	"	self checkServiceName.	self log: 'Installing service'.	self serviceInterfaceDo: 		[: interface | 			| serviceCommand |			serviceCommand := self createCommandLineForService: self serviceName executable: executablePath parameters: parametersString.			" Remove old service definition first "			[ interface deregisterService: self serviceName ] on: WinServiceError do: [: ex | ].			( Delay forSeconds: 2 ) wait.			" install service "			interface registerService: self serviceName path: serviceCommand prerequisites: prerequisistes autoStart: autoStart startNow: startNow.			self log: 'Installed service'		].</body><body package="WinService">installServiceWithParameters: parametersString prerequisistes: prerequisistes autoStart: autoStart startNow: startNow 	" install a windows service "	self 		installServiceWithParameters: parametersString		executable: self pathToExecutable		prerequisistes: prerequisistes		autoStart: autoStart		startNow: startNow.</body><body package="WinService">updateServiceDescription: aString	self serviceInterfaceDo: 		[: interface | 			interface updateDescription: aString ofService: self serviceName.		].</body></methods><methods><class-id>OS.WinService</class-id> <category>private</category><body package="WinService">checkServiceName	( self serviceName isNil or: [ self serviceName isEmpty ]) 		ifTrue: [ self error: 'No service name specified' ].</body><body package="WinService">createCommandLineForService: newServiceName executable: exePath parameters: parametersString 	" Create the command line that starts the service "	| stream |	stream := String new writeStream.	self printCommandPart: exePath asFilename asAbsoluteFilename asString on: stream.	stream nextPutAll: parametersString.	^ stream contents</body><body package="WinService">pathToExecutable	| exeSourceName |	exeSourceName := CEnvironment commandLine first.	( '*.exe' match: exeSourceName ignoreCase: true ) 		ifFalse: [ exeSourceName := exeSourceName , '.exe' ].	^ exeSourceName asFilename asAbsoluteFilename</body><body package="WinService">printCommandPart: aString on: aStream	(aString includes: Character space) 		ifTrue: [ aStream nextPut: $"; nextPutAll: aString; nextPut: $". ]		ifFalse: [ aStream nextPutAll: aString. ].</body><body package="WinService">quitService	" the service has been shut down. now quit the image "	[	self log: 'Quitting'.		ObjectMemory quit	] forkAt: Processor activeProcess priority - 1.</body><body package="WinService">registeredServices	" contains all registered services. necessary because this object should not be garbage collected "	RegisteredServices isNil ifTrue: [ RegisteredServices := Set new ].	^ RegisteredServices</body><body package="WinService">serviceInterfaceDo: aBlock 	OSHandle currentOS == #win32 		ifFalse: [ self error: 'Windows services not available on this OS (' , OSHandle currentPlatformID , ')' ].	serviceInterface isNil ifTrue: [ serviceInterface := WinServiceInterface new ].	^ aBlock value: serviceInterface</body><body package="WinService">shutDown	postStartProcess notNil ifTrue: [ postStartProcess interruptWith: [ WinServiceShutdownNotification raiseSignal ]].	shutdownActionBlock value.</body></methods><methods><class-id>OS.WinService</class-id> <category>startup/shutdown</category><body package="WinService">denyStopWhile: aBlock	self serviceInterfaceDo: [ : interface | interface denyStopWhile: aBlock ]</body><body package="WinService">startAsService: aStartUpBlock postStartBlock: postStartBlock shutdownBlock: aShutdownBlock 	" Start a service. Handle service shutdown requests.	startUpBlock is evaluated when the service is started, shutdownBlock when the service is stopped.	This method does not return (see #serviceStarted). "	shutdownActionBlock := aShutdownBlock.	self registeredServices add: self.	self serviceInterfaceDo: 		[: interface |			self log: 'Starting service'.			" note that startDispatcher is blocking and only returns after the service has stopped "			[	interface 					startDispatcherWithEventHandler: [: event : type : data | self handleEvent: event type: type ]					serviceName: self serviceName					startupBlock: 					[	aStartUpBlock value.						self log: 'Service started'.						postStartProcess :=							[	postStartBlock value.								self log: 'Post start finished'.								postStartProcess := nil							] fork					]			] 				on: Error				do: 				[: ex |					" Note that the defaultAction of WinServiceStartupError is to quit.					Applications that handle this startup error should quit, too "					WinServiceStartupError raiseSignal: 'Error in service ' , self serviceName , ': ' , ex description				].			" service finished "			Semaphore new wait		].</body><body package="WinService">startAsService: aStartUpBlock shutdownBlock: aShutdownBlock 	self startAsService: aStartUpBlock postStartBlock: nil shutdownBlock: aShutdownBlock.</body></methods><methods><class-id>OS.WinService</class-id> <category>accessing</category><body package="WinService">serviceName	^ serviceName</body><body package="WinService">serviceName: aServiceName 	serviceName := aServiceName.</body></methods><methods><class-id>OS.WinService</class-id> <category>logging</category><body package="WinService">log: aString	Transcript show: aString, ' [', (self serviceName ifNil: [ '']) displayString, ']';cr.</body><body package="WinService">logDebug: aString	self log: aString</body></methods><methods><class-id>OS.WinService</class-id> <category>events</category><body package="WinService">handleEvent: event type: type 	^ self serviceInterfaceDo: 		[: interface | | tickerProcess |			( interface isStopOrShutdownEvent: event ) 				ifTrue: 				[	self log: 'Service shutdown event: ' , event printString.					tickerProcess := interface forkShutdownPendingTickerProcess.					[ self shutDown ] ensure: [ tickerProcess terminate ].					interface setServiceStoppedStatus.					self log: 'Stopped service'.					self quitService.					interface NO_ERROR				]				ifFalse: 				[	event = interface SERVICE_CONTROL_INTERROGATE 						ifTrue: [ interface NO_ERROR ]						ifFalse: [ interface ERROR_CALL_NOT_IMPLEMENTED  ]				].					]</body></methods><methods><class-id>OS.WinService class</class-id> <category>instance creation</category><body package="WinService">serviceName: aServiceName 	^ ( self new ) serviceName: aServiceName;		yourself</body></methods><methods><class-id>OS.WinServiceStartupError</class-id> <category>private - actions</category><body package="WinService">defaultAction	ObjectMemory quit</body></methods><methods><class-id>OS.OSHandle class</class-id> <category>accessing</category><body package="WinService">windowsVersion	" returns the Windows version as LimitedPrecisionReal, or nil if another OS is running "	| currentPlatformID stream |	^ self currentOS = #win32 		ifTrue: 		[	currentPlatformID := self currentPlatformID.			stream := currentPlatformID readStream.			stream upTo: $V.			LimitedPrecisionReal readFrom: stream		]		ifFalse: [ nil ]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class></st-source>