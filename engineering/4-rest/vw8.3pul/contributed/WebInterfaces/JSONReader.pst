<?xml version="1.0"?><st-source><!-- Name: JSONReaderComment: This package is a simple port from a Squeak package found here:http://map1.squeakfoundation.org/package/d38bdc2d-e52a-4167-ae73-2cf438c65c2f/autoversion/1The Squeak code looks fairly old; I tested a few examples here:http://json.org/example.htmlAnd they worked.  To try parsing a JSON string, execute:Json readFrom: jsonString readStream.Where jsonString is JSON format.  This likely needs lots more testing before anyone tried to really use it :)DbIdentifier: psql_public_cst_2007DbTrace: 62346ExplicitPrerequisites: #()IgnoredPrerequisites: #()PackageName: JSONReaderParcel: #('JSONReader')ParcelName: JSONReaderPrintStringCache: (1.16,jamesr)Version: 1.16Date: 1:12:47 PM November 15, 2009 --><time-stamp>From VisualWorksÂ®, 7.7 of November 5, 2009 on November 15, 2009 at 1:12:47 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>JSON</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>JSON</category><attributes><package>JSONReader</package></attributes></name-space><comment><name-space-id>JSON</name-space-id><body></body></comment><class><name>JsonSyntaxError</name><environment>JSON</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JSON</category><attributes><package>JSONReader</package></attributes></class><comment><class-id>JSON.JsonSyntaxError</class-id><body>Class Json signals instances of me when an input stream contains invalid JSON input.</body></comment><class><name>JsonReader</name><environment>JSON</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>JSON</category><attributes><package>JSONReader</package></attributes></class><comment><class-id>JSON.JsonReader</class-id><body>This class reads and writes JSON format data - strings, numbers, boolean, nil, arrays and dictionaries. See http://www.crockford.com/JSON/index.html.</body></comment><shared-variable><name>CharacterEscapeMap</name><environment>JSON.JsonReader</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>JSON.JsonReader initializeCharacterEscapeMap</initializer><attributes><package>JSONReader</package></attributes></shared-variable><methods><class-id>JSON.JsonReader</class-id> <category>private</category><body package="JSONReader" selector="consume:returning:">consume: aString returning: anObject	aString do: [:c | self next == c ifFalse: [JsonSyntaxError new raiseSignal: 'Expected ''', aString, ''''] ].	^ anObject</body><body package="JSONReader" selector="interpretStringEscape">interpretStringEscape		| c |	c := self next.	c == $b ifTrue: [^Character backspace].	c == $n ifTrue: [^Character lf].	c == $f ifTrue: [^Character newPage].	c == $r ifTrue: [^Character cr].	c == $t ifTrue: [^Character tab].	c == $u		ifTrue:			[| valueStream |			valueStream := (self stream next: 4) readStream.			^Character value: (Integer readFrom: valueStream radix: 16)].	^c</body><body package="JSONReader" selector="next">next	^ self stream next</body><body package="JSONReader" selector="peek">peek	^ self stream peek</body><body package="JSONReader" selector="readArray">readArray	| a needComma |	a := OrderedCollection new.	needComma := false.	[		self skipWhitespace.		self peek == $] ifTrue: [self next. ^ a asArray].		needComma			ifTrue: [self peek == $, ifFalse: [JsonSyntaxError new raiseSignal: 'Missing comma'].					self next.]			ifFalse: [needComma := true]. 		a add: self readAny.	] repeat.</body><body package="JSONReader" selector="readDictionary">readDictionary	| m k v needComma |	m := Dictionary new.	needComma := false.	[		self skipWhitespace.		self peek == $} ifTrue: [self next. ^ m].		needComma			ifTrue: [self peek == $, ifFalse: [JsonSyntaxError new raiseSignal: 'Missing comma'].					self next. self skipWhitespace]			ifFalse: [needComma := true.].		self next == $" ifFalse: [JsonSyntaxError signal: 'Key in dictionary must be string'].		k := self readString.		self skipWhitespace.		self peek == $: ifFalse: [JsonSyntaxError signal: 'Missing colon'].		self next.		v := self readAny.		m at: k put: v.	] repeat.</body><body package="JSONReader" selector="readNumber">readNumber	| acc c |	acc := WriteStream on: String new.	[		c := self peek.		(c isNil not and: [self class numbersMayContain: c]) ifFalse: [			[^ acc contents asNumber] on: Error do: [JsonSyntaxError new raiseSignal: 'Invalid number']].		acc nextPut: c.		self next.	] repeat.</body><body package="JSONReader" selector="readString">readString	| s c |	s := WriteStream on: String new.	[		c := self next.		c == $\			ifTrue: [s nextPut: self interpretStringEscape.]			ifFalse: [c == $" ifTrue: [^ s contents.].					s nextPut: c]	] repeat.</body><body package="JSONReader" selector="skipComment">skipComment		self peek == $/ ifFalse: [^self].	self next.	self peek == $/		ifTrue: [self skipToEndOfLine]		ifFalse:			[self peek == $*				ifTrue:					[self next.					self skipCommentBody]				ifFalse: [JsonSyntaxError new raiseSignal: 'Invalid comment syntax']]</body><body package="JSONReader" selector="skipCommentBody">skipCommentBody	[		[self next == $*] whileFalse.		self peek == $/	] whileFalse.	self next. "skip that last slash"	self skipWhitespace.</body><body package="JSONReader" selector="skipToEndOfLine">skipToEndOfLine	[self peek == Character cr or: [self peek == Character lf]] whileFalse: [self next].	self skipWhitespace</body><body package="JSONReader" selector="skipWhitespace">skipWhitespace	[self peek isSeparator] whileTrue: [self next].	self skipComment.</body></methods><methods><class-id>JSON.JsonReader</class-id> <category>parsing</category><body package="JSONReader" selector="readAny">readAny	"This is the main entry point for the JSON parser. See also readFrom: on the class side."	| c |	self skipWhitespace.	c := self peek asLowercase.	c == ${ ifTrue: [self next. ^ self readDictionary].	c == $[ ifTrue: [self next. ^ self readArray].	c == $" ifTrue: [self next. ^ self readString].	c == $t ifTrue: [^ self consume: 'true' returning: true].	c == $f ifTrue: [^ self consume: 'false' returning: false].	c == $n ifTrue: [^ self consume: 'null' returning: nil].	(self class numbersMayContain: c) ifTrue: [^ self readNumber].	JsonSyntaxError new raiseSignal: 'Unknown Json input'</body></methods><methods><class-id>JSON.JsonReader</class-id> <category>accessing</category><body package="JSONReader" selector="stream">stream	"Answer the value of stream"	^ stream</body><body package="JSONReader" selector="stream:">stream: anObject	"Set the value of stream"	stream := anObject</body></methods><methods><class-id>JSON.JsonReader class</class-id> <category>constants</category><body package="JSONReader" selector="escapeForCharacter:">escapeForCharacter: c	^ CharacterEscapeMap at: c ifAbsent: [nil]</body></methods><methods><class-id>JSON.JsonReader class</class-id> <category>instance creation</category><body package="JSONReader" selector="readFrom:">readFrom: aStream	^ self new stream: aStream; readAny.</body><body package="JSONReader" selector="render:">render: anObject	| s |	s := WriteStream on: String new.	anObject jsonWriteOn: s.	^ s contents.</body></methods><methods><class-id>JSON.JsonReader class</class-id> <category>testing</category><body package="JSONReader" selector="numbersMayContain:">numbersMayContain: aChar		^aChar isDigit or: ['-+.eE' includes: aChar]</body></methods><methods><class-id>JSON.JsonReader class</class-id> <category>class initialization</category><body package="JSONReader" selector="initializeCharacterEscapeMap">initializeCharacterEscapeMap	^Dictionary new		at: $" put: $";		at: $\ put: $\;		at: Character backspace put: $b;		at: Character lf put: $n;		at: Character newPage put: $f;		at: Character cr put: $r;		at: Character tab put: $t;		yourself</body></methods><methods><class-id>Core.Dictionary</class-id> <category>converting</category><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aStream	aStream nextPutAll: '{'.	self keysAndValuesDo: [:key :value |		key jsonWriteOn: aStream.		aStream nextPutAll: ':'.		value jsonWriteOn: aStream.		aStream nextPutAll: ','].	self notEmpty ifTrue: [aStream skip: -1].	aStream nextPutAll: '}'</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aStream	aStream nextPutAll: '['.	self do: [:each | each jsonWriteOn: aStream] separatedBy: [aStream nextPutAll: ','].	aStream nextPutAll: ']'</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aStream	self printOn: aStream</body></methods><methods><class-id>Core.Interval</class-id> <category>converting</category><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aStream	aStream nextPutAll: '['.	start printOn: aStream.	aStream nextPutAll: ','.	stop printOn: aStream.	aStream nextPutAll: ']'</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="JSONReader" selector="asJson">asJson	| stream |	stream := WriteStream on: String new.	self jsonWriteOn: stream.	^stream contents</body><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aWriteStream 	aWriteStream nextPutAll: 'null'</body></methods><methods><class-id>Core.Boolean</class-id> <category>converting</category><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aStream	self printOn: aStream</body></methods><methods><class-id>Core.KeyedCollection</class-id> <category>converting</category><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aStream	aStream nextPutAll: '{'.	self keysAndValuesDo: [:key :value |		key jsonWriteOn: aStream.		aStream nextPutAll: ':'.		value jsonWriteOn: aStream.		aStream nextPutAll: ','].	self notEmpty ifTrue: [aStream skip: -1].	aStream nextPutAll: '}'</body></methods><methods><class-id>Core.Object class</class-id> <category>json</category><body package="JSONReader" selector="jsonInstVarNames">jsonInstVarNames	"override to customize what gets passed"	^self allInstVarNames</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="JSONReader" selector="asJson">asJson	| stream |	stream := WriteStream on: String new.	self jsonWriteOn: stream.	^stream contents</body><body package="JSONReader" selector="jsonInstVarNames">jsonInstVarNames	"override if we want to provide inst level customization"	^self class jsonInstVarNames</body><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: stream	| count vars |	stream nextPut: ${.	count := 1.	vars := self jsonInstVarNames.	vars do: [:each | | val msg |		msg := each asSymbol.		stream nextPutAll: '"', each, '"'.		stream nextPut: $:.		val := (self respondsTo: msg)			ifTrue: [self perform: msg]			ifFalse: [self instVarAt: count].		count := count + 1.		val jsonWriteOn: stream.		each = vars last			ifFalse: [stream nextPut: $,]].	stream nextPut: $}.	^stream contents</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="JSONReader" selector="jsonWriteOn:">jsonWriteOn: aStream	| replacement |	aStream nextPut: $".	self do: [:character |		(replacement := JSON.JsonReader escapeForCharacter: character)			ifNil: [ aStream nextPut: character ]			ifNotNil: [ aStream nextPut: $\; nextPut: replacement ].	].	aStream nextPut: $"</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class></st-source>