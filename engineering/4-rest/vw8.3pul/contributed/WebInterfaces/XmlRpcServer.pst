<?xml version="1.0"?><st-source><!-- Name: XmlRpcServerComment: Framework for creating XmlRpc Servers using the Web Toolkit. See HelloWorldExample comment and code to see how to createan XmlRpc serverDbIdentifier: psql_public_cst_2007DbTrace: 60202DevelopmentPrerequisites: #(#(#any 'Wave-Server' '') #(#any 'XmlRpcClient' '') #(#any 'WebToolkit' ''))PackageName: XmlRpcServerParcel: #('XmlRpcServer')ParcelName: XmlRpcServerPrerequisiteParcels: #(#('Wave-Server' '') #('XmlRpcClient' '') #('WebToolkit' ''))PrintStringCache: (1.8,jamesr)Version: 1.8Date: 3:20:29 PM October 21, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (oct09.3) of 16 October 2009 on 21 October 2009 at 15:20:29</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>XmlRpcServlet</name><environment>VisualWave</environment><super>VisualWave.SingleThreadModelServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>serverMethods </class-inst-vars><imports></imports><category>Network-XMLRPC-Server</category><attributes><package>XmlRpcServer</package></attributes></class><comment><class-id>VisualWave.XmlRpcServlet</class-id><body>XmlRpcServlet implements a WebToolkit (Servlet) based Xml-Rpc implementation.  To use, subclass XmlRpcServlet, create a dictionary of methods to respond to in the class method #serverMethods, and implement that API on the instance side of your class.</body></comment><class><name>HelloWorldExample</name><environment>Smalltalk</environment><super>VisualWave.XmlRpcServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XmlRpcServer</category><attributes><package>XmlRpcServer</package></attributes></class><comment><class-id>HelloWorldExample</class-id><body>A simple example to show how to create an XmlRpcServer. First create a subclass of XmlRpcServlet. Add what ever methods you need to the class. Second you must implement the class method allowedServerMethods. This methodreturns a dictionary. A key in the dictionary is the string that XmlRpc Clients will use to accessa method on your server. The value at the key is the symbol of the actual method that the string should use. Once your class is ready you can start the WaveHTTPRequestBroker (via the Server Console) and access your server. If you run a client on the same machine as the server than the fillowingwill access the HelloWorldExample server:| client |client := XmlRpcClient url: 'http://127.0.0.1:8008/servlet/HelloWorldExample'.client perform: 'hello'When delaling with servlets Webtool kit can be configured various ways. Servlet access can be restricted to registered servlets only and only servlets in a given name space can be accessed. The default is to allow access to all servlets in the Smalltalk namespace. This allows access to the HelloWorldExample. If you have problems check the settings on the VisualWave site. See WebAppDevGuide.pdf for details.</body></comment><class><name>IM_TextXml</name><environment>Smalltalk</environment><super>VisualWave.IM_TextHtml</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC-Server</category><attributes><package>XmlRpcServer</package></attributes></class><comment><class-id>IM_TextXml</class-id><body></body></comment><class><name>SimpleXmlAnswer</name><environment>Smalltalk</environment><super>VisualWave.SimpleAnswer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC-Server</category><attributes><package>XmlRpcServer</package></attributes></class><comment><class-id>SimpleXmlAnswer</class-id><body></body></comment><class><name>XmlRpcValidator</name><environment>Smalltalk</environment><super>VisualWave.XmlRpcServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC-Server</category><attributes><package>XmlRpcServer</package></attributes></class><comment><class-id>XmlRpcValidator</class-id><body>This class implements the XML_RPC validation suite by Dave Winer. The docs for the suite are at: http://www.xmlrpc.com/validator1Docs. To run the suite on this class first start the web server by using the Server Console.  Go to http://validator.xmlrpc.com/ and fill out the form with your server's information (machine name or IP, port and path) and click on the submit button. The test takes a while, but give useful results. If you are using the default settigng the server url will be:http://yourMachineNameOrIPAddress:8008/servlet/XmlRpcValidator</body></comment><methods><class-id>VisualWave.XmlRpcServlet</class-id> <category>executing</category><body package="XmlRpcServer" selector="doGet">doGet	^self executeMethod</body><body package="XmlRpcServer" selector="doPost">doPost	^self executeMethod</body><body package="XmlRpcServer" selector="executeMethod">executeMethod	"entry point"	| methodRequest xmlResult |	[methodRequest := self request webRequest httpRequest isNil		ifTrue: [self request xmlRpcRequest]		ifFalse: [self request webRequest httpRequest xmlRpcRequest].	xmlResult := self performRequest: methodRequest] 			on: Error			do: 				[:exception | 				xmlResult := self class 							runTimeError: ' Could not process request. ' , exception messageText].	self fillResponseWith: xmlResult asRpcXml asString</body></methods><methods><class-id>VisualWave.XmlRpcServlet</class-id> <category>private</category><body package="XmlRpcServer" selector="fillResponseWith:">fillResponseWith: xmlResult	response contentType: 'text/xml'.	response status: 200.	response contentLength: xmlResult size.	response write: xmlResult</body><body package="XmlRpcServer" selector="performRequest:">performRequest: xmlRpcRequest 	| rawAnswer methodList requestedMethod args requestedName | 	methodList := self class serverMethods.	args := xmlRpcRequest arguments.	requestedName := xmlRpcRequest methodName.	requestedMethod := methodList 		at: requestedName		ifAbsent: [^self class methodNotFoundError: requestedName ].	args := self possiblyFixArguments: args forName: requestedName .	requestedMethod := self possiblyFixRequestedMethod: requestedMethod forName: requestedName.		[rawAnswer := args isNil		ifTrue:[self perform: requestedMethod]		ifFalse:[self perform: requestedMethod				withArguments: args]]		on: Error		do: [:error | ^self class runTimeError: error messageText].	^XmlRpcMethodResult result: rawAnswer</body><body package="XmlRpcServer" selector="possiblyFixArguments:forName:">possiblyFixArguments: arguments forName: requestedName	"entry point for dealing with bozo clients"	^arguments</body><body package="XmlRpcServer" selector="possiblyFixRequestedMethod:forName:">possiblyFixRequestedMethod: requestedMethod forName: requestedName	"entry point for dealing with bozo clients"	^requestedMethod</body></methods><methods><class-id>VisualWave.XmlRpcServlet class</class-id> <category>errors</category><body package="XmlRpcServer" selector="methodNotFoundError:">methodNotFoundError: aMethodNameString	^XmlRpcMethodResult			errorCode: 1 			description: 'Method ' ,  aMethodNameString , ' not found'</body><body package="XmlRpcServer" selector="runTimeError:">runTimeError: aString	^XmlRpcMethodResult			errorCode: 2 			description: aString</body></methods><methods><class-id>VisualWave.XmlRpcServlet class</class-id> <category>utility</category><body package="XmlRpcServer" selector="allowedServerMethods">allowedServerMethods	"Return a dictionary	Key is the string the client will use to request the method	Value is the symbol for the method to actually call"	self subclassResponsibility</body><body package="XmlRpcServer" selector="reset">reset	"self reset"	serverMethods := nil</body><body package="XmlRpcServer" selector="serverMethods">serverMethods	serverMethods isNil ifTrue:[serverMethods := self allowedServerMethods].	^serverMethods</body></methods><methods><class-id>HelloWorldExample</class-id> <category>server actions</category><body package="XmlRpcServer" selector="hello">hello	^'Hi there'</body></methods><methods><class-id>HelloWorldExample class</class-id> <category>utility</category><body package="XmlRpcServer" selector="allowedServerMethods">allowedServerMethods	^(Dictionary new)		at: 'hello' put: #hello;		yourself</body></methods><methods><class-id>IM_TextXml</class-id> <category>accessing</category><body package="XmlRpcServer" selector="entityBytes">entityBytes	^rawHtml asString</body></methods><methods><class-id>IM_TextXml class</class-id> <category>accessing</category><body package="XmlRpcServer" selector="implementedType">implementedType	^'text/xml'</body></methods><methods><class-id>SimpleXmlAnswer</class-id> <category>sending</category><body package="XmlRpcServer" selector="sendHTTPEntityHeadersOver:">sendHTTPEntityHeadersOver: aStream 	"Minimal header needed: Content-Type"	aStream 		nextPutAll: 'Content-type: ';		nextPutAll: self mediaType;		crlf;		nextPutAll: 'Content-length: ';		nextPutAll: entityBytes size printString;		crlf.</body></methods><methods><class-id>SimpleXmlAnswer class</class-id> <category>instance creation</category><body package="XmlRpcServer" selector="xmlTextWith:">xmlTextWith: xmlByteArray	^self new		status: 200;		reasonString: 'OK'; 		mediaType: 'text/xml';		entityBytes: xmlByteArray</body></methods><methods><class-id>XmlRpcValidator</class-id> <category>server actions</category><body package="XmlRpcServer" selector="arrayOfStructsTest:">arrayOfStructsTest: anArray	^anArray 		inject: 0		into: [:subTotal :each | subTotal + (each at: 'curly')].</body><body package="XmlRpcServer" selector="countTheEntities:">countTheEntities: aString	| counts |	counts := Dictionary new.	counts		at: 'ctLeftAngleBrackets'		put: (aString occurrencesOf: $&lt;).	counts		at: 'ctRightAngleBrackets'		put: (aString occurrencesOf: $&gt;).                     	counts		at: 'ctAmpersands'		put: (aString occurrencesOf: $&amp;).	counts		at: 'ctApostrophes'		put: (aString occurrencesOf: $').	counts		at: 'ctQuotes'		put: (aString occurrencesOf: $").	^counts</body><body package="XmlRpcServer" selector="easyStructTest:">easyStructTest: aDictionary	^(aDictionary at: 'larry') + (aDictionary at: 'moe') + (aDictionary at: 'curly')</body><body package="XmlRpcServer" selector="echoStructTest:">echoStructTest: aDictionary	^aDictionary</body><body package="XmlRpcServer" selector="manyTypesTestNumber:boolean:string:double:date:base64:">manyTypesTestNumber: aNumber boolean: aBoolean string: aString double: aDouble date: aDateTime base64: encodedString	^OrderedCollection new		add: aNumber;		add: aBoolean;		add: aString;		add: aDouble;		add: aDateTime;		add: encodedString;		yourself.</body><body package="XmlRpcServer" selector="moderateSizeArrayCheck:">moderateSizeArrayCheck: anArray	^anArray first , anArray last</body><body package="XmlRpcServer" selector="nestedStructTest:">nestedStructTest:  aDictionary	^self easyStructTest: ((( aDictionary at: '2000') at: '04') at: '01')</body><body package="XmlRpcServer" selector="simpleStructReturnTest:">simpleStructReturnTest: aNumber	| result |	result := Dictionary new.	result		at: 'times10'		put: aNumber * 10.	result		at: 'times100'		put: aNumber * 100.	result		at: 'times1000'		put: aNumber * 1000.	^result</body></methods><methods><class-id>XmlRpcValidator class</class-id> <category>utility</category><body package="XmlRpcServer" selector="allowedServerMethods">allowedServerMethods	"Return a dictionary	Key is the string the client will use to request the method	Value is the symbol for the method to actually call"	"self reset"	^(Dictionary new)		at: 'validator1.arrayOfStructsTest' put: #arrayOfStructsTest:;		at: 'validator1.countTheEntities' put: #countTheEntities:;		at: 'validator1.easyStructTest' put: #easyStructTest:;		at: 'validator1.echoStructTest' put: #echoStructTest:;		at: 'validator1.manyTypesTest'			put: 'manyTypesTestNumber:boolean:string:double:date:base64:' asSymbol;		at: 'validator1.moderateSizeArrayCheck' put: #moderateSizeArrayCheck:;		at: 'validator1.nestedStructTest' put: #nestedStructTest:;		at: 'validator1.simpleStructReturnTest' put: #simpleStructReturnTest:;		yourself</body></methods><methods><class-id>VisualWave.WebRequest</class-id> <category>As yet unclassified</category><body package="XmlRpcServer" selector="xmlRpcRequest">xmlRpcRequest	responseStream text.	^httpRequest isNil		ifTrue: [XmlRpcMethodCall from: self rawContent readStream]		ifFalse: [httpRequest xmlRpcRequest]</body></methods><methods><class-id>VisualWave.IM_Generic</class-id> <category>xml-rpc </category><body package="XmlRpcServer" selector="xmlRpcRequest">xmlRpcRequest	^XmlRpcMethodCall from: entityBytes asString readStream</body></methods><methods><class-id>VisualWave.HTTPRequest</class-id> <category>xml-rpc </category><body package="XmlRpcServer" selector="xmlRpcRequest">xmlRpcRequest	^entity xmlRpcRequest</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WebRequest</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>httpRequest serverEnvironment queryData cookieData responseStream consumedPath unconsumedPath initiator entities webSite session isAnswered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Support-Web-Framework</category><attributes><package>Wave-Server</package></attributes></class><class><name>IM_TextHtml</name><environment>VisualWave</environment><super>VisualWave.IM_Text</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rawHtml </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Wave-Server</package></attributes></class><class><name>SingleThreadModelServlet</name><environment>VisualWave</environment><super>VisualWave.HttpServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request response session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Toolkit-Servlet</category><attributes><package>Servlet</package></attributes></class><class><name>IM_Generic</name><environment>VisualWave</environment><super>VisualWave.InternetMedia</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entityBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Wave-Server</package></attributes></class><class><name>SimpleAnswer</name><environment>VisualWave</environment><super>VisualWave.StatusedAnswer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mediaType entityBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Support-Web-Framework</category><attributes><package>Wave-Server</package></attributes></class><class><name>HTTPRequest</name><environment>VisualWave</environment><super>VisualWave.HTTPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method uri </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Wave-Server</package></attributes></class></st-source>