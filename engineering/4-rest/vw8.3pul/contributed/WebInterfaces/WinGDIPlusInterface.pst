<?xml version="1.0"?><st-source><!-- Name: WinGDIPlusInterfaceNotice: The MIT LicenseCopyright (c) 2004 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: Minimal interface to image functions of the GDI+ library of Windows.	image := GDIPlusImage fromFile: 'picture.png'.	image displayOn: aGraphicsContext at: position.DevelopmentPrerequisites: #(#(#any 'DLLCC' '') #(#any 'ExternalInterfaceBashing' ''))PackageName: WinGDIPlusInterfaceParcel: #('WinGDIPlusInterface')ParcelDirectory: WinGDIPlusInterfaceParcelName: WinGDIPlusInterfacePrerequisiteDescriptions: #(#(#name 'DLLCC') #(#name 'ExternalInterfaceBashing' #componentType #package))PrerequisiteParcels: #(#('DLLCC' '') #('ExternalInterfaceBashing' ''))Version: (7.7).10Post-Load Block: 	[:package | WinGDIPlusInterface postLoadInitialize ]Date: 1:10:59 PM July 26, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jul14.3) of 25. Juli 2014 on 26. Juli 2014 at 13:10:59</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>WinGDIPlus</name><environment>Graphics</environment><private>false</private><imports>			private Graphics.*			private Smalltalk.*			</imports><category>WinGDIPlusInterface</category><attributes><package>WinGDIPlusInterface</package></attributes></name-space><class><name>GDIPlusImage</name><environment>Graphics.WinGDIPlus</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bitmap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>WinGDIPlusInterface</package></attributes></class><comment><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id><body>GDIPlusImage wraps a GDIPlusBitmap. It implements a few methods of the Image protocol. But usually it should be treated as a VisualComponent.Instance Variables:	bitmap	&lt;GDIPlusBitmap&gt;	GDI+ bitmap</body></comment><class><name>GDIPlusBitmap</name><environment>Graphics.WinGDIPlus</environment><super>Graphics.UnmappableSurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hglobal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WinGDIPlusInterface</category><attributes><package>WinGDIPlusInterface</package></attributes></class><comment><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id><body>GDIPlusBitmap wraps a GDI+ image / bitmap. The handle is a pointer to the GpImage / GpBitmap.Instance Variables:	hglobal	&lt;CPointer&gt;	Optional HGLOBAL pointer of memory that was allocated for this bitmap.</body></comment><class><name>WinGDIPlusInterface</name><environment>Smalltalk</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>images libraryToken systemInterface </inst-vars><class-inst-vars>current isAvailable </class-inst-vars><imports>			private WinGDIPlusInterfaceDictionary.*			</imports><category>WinGDIPlusInterface</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>gdiplus.dll</item> <item>ole32.dll</item> <item>kernel32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>WinGDIPlusInterface</package></attributes></class><comment><class-id>WinGDIPlusInterface</class-id><body>Provides an interface to the Microsoft Windows GDI+ graphics library, gdiplus.dllhttp://msdn.microsoft.com/en-us/library/ms533969(v=VS.85).aspxMost procedures return a GpStatus value 0..21, described here:http://msdn.microsoft.com/en-us/library/ms534175%28v=VS.85%29.aspxInstance Variables:	images	&lt;WeakDictionary of: CPointer-&gt;GDIPlusBitmap&gt;	Bitmap registry (for finalization)	libraryToken	&lt;CPointer&gt;	Library token	systemInterface	&lt;Win32SystemSupport&gt; OS system support interface</body></comment><class><name>WinGDIPlusError</name><environment>Graphics.WinGDIPlus</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WinGDIPlusInterface</package></attributes></class><comment><class-id>Graphics.WinGDIPlus.WinGDIPlusError</class-id><body>Error that is raised when an API call fails, or when an invalid/released handle is encountered.</body></comment><shared-variable><name>WinGDIPlusInterfaceDictionary</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>WinGDIPlusInterface</package></attributes></shared-variable><methods><class-id>WinGDIPlusInterface</class-id> <category>procedures</category><body package="WinGDIPlusInterface">CLSIDFromString: lpsz with: pclsid	&lt;C: int CLSIDFromString(char * lpsz, char * pclsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">CreateStreamOnHGlobal: hGlobal with: fDeleteOnRelease with: ppstm	&lt;C: int CreateStreamOnHGlobal(HGLOBAL hGlobal, BOOL fDeleteOnRelease, IStream * ppstm)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipCloneImage: image with: cloneImage	&lt;C: int GdipCloneImage(GpImage *image, GpImage **cloneImage)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipCreateBitmapFromHBITMAP: hbm with: hpal with: bitmap	&lt;C: int GdipCreateBitmapFromHBITMAP(			HBITMAP hbm,			HPALETTE hpal,			GpBitmap** bitmap)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipCreateFromHDC: hdc with: graphics	&lt;C: int GdipCreateFromHDC(HDC hdc, GpGraphics * * graphics)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipCreateFromHWND: hwnd with: graphics	&lt;C: int GdipCreateFromHWND(HWND hwnd, GpGraphics * * graphics)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipDeleteGraphics: graphics	&lt;C: int GdipDeleteGraphics(GpGraphics * graphics)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipDisposeImage: image	&lt;C: int GdipDisposeImage(GpImage * image)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipDrawImageI: graphics with: image with: x with: y	&lt;C: int GdipDrawImageI(GpGraphics * graphics, GpImage * image, int x, int y)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipDrawImageRectI: graphics with: image with: x with: y with: width with: height	&lt;C: int GdipDrawImageRectI(GpGraphics * graphics, GpImage * image, int x, int y, int width, int height)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetImageHeight: image with: height	&lt;C: int GdipGetImageHeight(GpImage * image, unsigned int * height)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetImageRawFormat: image with: format	&lt;C: int GdipGetImageRawFormat(GpImage * image, GUID * format)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetImageThumbnail: image with: thumbWidth with: thumbHeight with: thumbImage with: callback with: callbackData	&lt;C: int GdipGetImageThumbnail(GpImage * image, unsigned int thumbWidth, unsigned int thumbHeight, GpImage * * thumbImage, unsigned long callback, void * callbackData)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetImageType: image with: type	&lt;C: int GdipGetImageType(GpImage * image, ImageType * type)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetImageWidth: image with: width	&lt;C: int GdipGetImageWidth(GpImage * image, unsigned int * width)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetPropertyCount: image with: numOfProperty	&lt;C: int GdipGetPropertyCount(GpImage *image, unsigned int * numOfProperty)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetPropertyIdList: image with: numOfProperty with: list	&lt;C: int GdipGetPropertyIdList(GpImage * image,  unsigned int numOfProperty, int * list)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetPropertyItem: image with: propId with: propSize with: buffer	&lt;C: int GdipGetPropertyItem(GpImage * image, int propId, unsigned int propSize, PropertyItem * buffer)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipGetPropertyItemSize: image with: propId with: size	&lt;C: int GdipGetPropertyItemSize(GpImage * image, int propId, unsigned int * size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipImageRotateFlip: image with: rfType	&lt;C: int GdipImageRotateFlip(GpImage * image, RotateFlipType rfType)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipLoadImageFromFile: filename with: image	&lt;C: int GdipLoadImageFromFile(unsigned char * filename, GpImage * * image)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipLoadImageFromStream: stream with: image	&lt;C: int GdipLoadImageFromStream(IStream stream, GpImage * * image)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipRemovePropertyItem: image with: propId	&lt;C: int GdipRemovePropertyItem(GpImage * image, int propId)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipSaveImageToFile: image with: filename with: _arg1 with: encoderParams	&lt;C: int GdipSaveImageToFile(GpImage * image, unsigned char * filename, unsigned char * _arg1, EncoderParameters * encoderParams)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipSaveImageToStream: image with: stream with: _arg1 with: encoderParams	&lt;C: int  GdipSaveImageToStream(GpImage *image, IStream* stream, unsigned char * _arg1, EncoderParameters* encoderParams)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipSetClipRectI: graphics with: x with: y with: width with: height with: combineMode	&lt;C: int GdipSetClipRectI(GpGraphics * graphics, int x, int y, int width, int height, CombineMode combineMode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdipSetPropertyItem: image with: item	&lt;C: int GdipSetPropertyItem(GpImage * image, PropertyItem * item)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdiplusShutdown: token	&lt;C: void GdiplusShutdown(ULONG_PTR token)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GdiplusStartup: token with: input with: output	&lt;C: int GdiplusStartup(ULONG_PTR * token, GdiplusStartupInput * input, GdiplusStartupOutput * output)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GetHGlobalFromStream: ppstm with: phglobal	&lt;C: int GetHGlobalFromStream(IStream * ppstm, HGLOBAL *phglobal)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GlobalAlloc: uFlags with: dwBytes	&lt;C: HGLOBAL GlobalAlloc(unsigned int uFlags, unsigned int dwBytes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GlobalFree: hMem	&lt;C: HGLOBAL GlobalFree(HGLOBAL hMem)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GlobalLock: hMem	&lt;C: char *  GlobalLock(HGLOBAL hMem)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">GlobalUnlock: hMem	&lt;C: BOOL GlobalUnlock(HGLOBAL hMem)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">StringFromGUID2: rguid with: lpsz with: cchMax	&lt;C: int StringFromGUID2(char * rguid, char * lpsz, int cchMax)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="WinGDIPlusInterface">gdiCreateCompatibleDC: hdc	&lt;C: HDC CreateCompatibleDC( 		 HDC hdc   // handle to DC	)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">gdiDeleteDC: hdc	&lt;C: BOOL DeleteDC(		 HDC hdc   // handle to DC	)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">gdiGlobalSize: hMem	&lt;C: unsigned int  GlobalSize(	  	__HGLOBAL hMem	)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WinGDIPlusInterface">gdiSelectObject: hdc with: hgdiobj	&lt;C: HANDLE SelectObject(	  HDC hdc,          // handle to DC	  HANDLE hgdiobj   // handle to object	)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="WinGDIPlusInterface">releaseWinGDIPlusInterface	&lt;triggerAtSystemEvent: #returnFromSnapshot&gt;	&lt;triggerAtSystemEvent: #aboutToSnapshot&gt;	WinGDIPlusInterface releaseCurrent</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id> <category>converting</category><body package="WinGDIPlusInterface">asCachedImage	" We're cheating here: 	The bitmap can be displayed quickly, so we return this image.	The bitmap cannot be recreated though, unlike real CachedImages"	^ self</body><body package="WinGDIPlusInterface">asGDIPlusImage	^ self</body><body package="WinGDIPlusInterface">asImage	^ self</body><body package="WinGDIPlusInterface">asNativeImage	" Returns an instance of a subclass of Image "	^ self bitmap asNativeImage</body><body package="WinGDIPlusInterface">asPixmap	" Returns a Pixmap "	^ self bitmap asPixmap</body><body package="WinGDIPlusInterface">asPixmapWithExtent: anExtent	" Returns a Pixmap with the given extent "	^ self bitmap asPixmapWithExtent: anExtent</body><body package="WinGDIPlusInterface">asRetainedMedium	^ self bitmap asRetainedMedium</body><body package="WinGDIPlusInterface">asThumbnailWidth: width height: height	^ self class bitmap: (self bitmap asThumbnailWidth: width height: height).</body><body package="WinGDIPlusInterface">clone	" create a clone of this image "	^ self class bitmap: self bitmap clone</body><body package="WinGDIPlusInterface">convertForGraphicsDevice: graphicsDevice	^ graphicsDevice canDisplayGDIBitmaps		ifTrue: [ self ]		ifFalse: [ self asNativeImage convertForGraphicsDevice: graphicsDevice ]</body><body package="WinGDIPlusInterface">convertToPalette: palette	^ self</body><body package="WinGDIPlusInterface">convertToScreenPalette	^ self</body><body package="WinGDIPlusInterface">shrunkenBy: scale 	"Answer a scaled-down copy of the receiver."	^ self class bitmap: ( self bitmap shrunkenBy: scale )</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id> <category>displaying</category><body package="WinGDIPlusInterface">displayOn: aGraphicsContext	^ self displayOn: aGraphicsContext at: 0@0</body><body package="WinGDIPlusInterface">displayOn: aGraphicsContext at: aPoint 	^ self bitmap displayOn: aGraphicsContext at: aPoint</body><body package="WinGDIPlusInterface">displayOn: aGraphicsContext at: aPoint enabled: aBoolean 	| copyGC shape image |	aBoolean 		ifTrue: [ self displayOn: aGraphicsContext at: aPoint ]		ifFalse: 		[	" compatibility only - this should be avoided "			copyGC := aGraphicsContext copy.			copyGC paint: ColorValue lightGray.			shape := bitmap asRetainedMedium asImage.			shape := CachedImage on: ( shape convertToCoverageWithOpaquePixel: ( shape atX: 0 y: 0 )).			image := OpaqueImage figure: bitmap asRetainedMedium shape: shape asRetainedMedium.			image displayOn: aGraphicsContext at: aPoint enabled: aBoolean		].</body><body package="WinGDIPlusInterface">displayOn: aGraphicsContext at: aPoint extent: anExtent	" displays the image, scaled to the given extent "	^ self bitmap displayOn: aGraphicsContext at: aPoint extent: anExtent</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id> <category>accessing</category><body package="WinGDIPlusInterface">extent	^ self bitmap extent</body><body package="WinGDIPlusInterface">height	^ self bitmap height</body><body package="WinGDIPlusInterface">image	^self asNativeImage</body><body package="WinGDIPlusInterface">mimeType	^ bitmap mimeType</body><body package="WinGDIPlusInterface">preferredBounds	^ self bitmap preferredBounds</body><body package="WinGDIPlusInterface">width	^ self bitmap width</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id> <category>testing</category><body package="WinGDIPlusInterface">isPixmap	^true</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id> <category>saving</category><body package="WinGDIPlusInterface">asByteArrayWithFormat: imageFormat 	" 'save' the image into a ByteArray and return it "	^ self bitmap asByteArrayWithFormat: imageFormat</body><body package="WinGDIPlusInterface">saveAs: aFilename format: imageFormat 	" Save the image in the given format.	See the 'constants' protocol of WinGDIPlusInterface. "	self bitmap saveAs: aFilename format: imageFormat</body><body package="WinGDIPlusInterface">saveAsBMPTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface bmp.</body><body package="WinGDIPlusInterface">saveAsGIFTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface gif.</body><body package="WinGDIPlusInterface">saveAsJPEGTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface jpeg.</body><body package="WinGDIPlusInterface">saveAsPNGTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface png.</body><body package="WinGDIPlusInterface">saveAsTIFFTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface tiff.</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id> <category>private</category><body package="WinGDIPlusInterface">bitmap	^ bitmap</body><body package="WinGDIPlusInterface">bitmap: aGDIPlusBitmap	bitmap := aGDIPlusBitmap</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage</class-id> <category>compatibility</category><body package="WinGDIPlusInterface">pngBytes	^ self asByteArrayWithFormat: WinGDIPlusInterface png</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusImage class</class-id> <category>instance creation</category><body package="WinGDIPlusInterface">bitmap: aGDIPlusBitmap	^ self new 		bitmap: aGDIPlusBitmap;		yourself</body><body package="WinGDIPlusInterface">fromBytes: bytes 	" Load a GDI+ image from a image data "	^WinGDIPlusInterface current loadImageFromBytes: bytes</body><body package="WinGDIPlusInterface">fromFile: filename	" Load a GDI+ image from a file "	^WinGDIPlusInterface current loadImageFromFile: filename</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>converting</category><body package="WinGDIPlusInterface">asCachedImage	^ self asImage</body><body package="WinGDIPlusInterface">asGDIPlusBitmap	^ self</body><body package="WinGDIPlusInterface">asGDIPlusImage	^ self asImage</body><body package="WinGDIPlusInterface">asImage	^ GDIPlusImage bitmap: self</body><body package="WinGDIPlusInterface">asNativeImage	" Returns an instance of a subclass of Image "	| pix image | 	pix := Pixmap extent: self extent on: Screen default.	image := Graphics.Image extent: pix extent					depth: pix depth					bitsPerPixel: pix bitsPerPixel					palette: pix palette.	self displayOn: pix graphicsContext.	pix contentsOfArea: pix bounds into: image bitsInstVar startingAt: 1.	^ image</body><body package="WinGDIPlusInterface">asPixmap	" Returns a Pixmap "	| pix |	pix := Pixmap extent: self extent on: Screen default.	self displayOn: pix graphicsContext at: 0@0.	^ pix</body><body package="WinGDIPlusInterface">asPixmapWithExtent: anExtent	" Returns a Pixmap with the given extent "	| pix |	pix := Pixmap extent: anExtent on: Screen default.	self displayOn: pix graphicsContext at: 0@0 extent: anExtent.	^ pix</body><body package="WinGDIPlusInterface">asRetainedMedium	" in the future we might return this bitmap instead of converting it into a Pixmap.	We don't know why the sender wants to convert us into a 'retained medium', though "	^ self asPixmap</body><body package="WinGDIPlusInterface">asThumbnailWidth: thumbnailWidth height: thumbnailHeight	self checkHandle.	^WinGDIPlusInterface current thumbnailFromGpImage: handle width: thumbnailWidth height: thumbnailHeight</body><body package="WinGDIPlusInterface">clone	" create a clone of this bitmap "	self checkHandle.	^ WinGDIPlusInterface current cloneGpImage: handle</body><body package="WinGDIPlusInterface">shrunkenBy: scale	| newExtent |	self checkHandle.	newExtent := self extent // scale.	^ WinGDIPlusInterface current thumbnailFromGpImage: handle width: newExtent x height: newExtent y</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>painting</category><body package="WinGDIPlusInterface">defaultBackgroundPaint	^ColorValue white</body><body package="WinGDIPlusInterface">defaultPaint	self shouldNotImplement</body><body package="WinGDIPlusInterface">defaultPaintPolicy	self shouldNotImplement</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>accessing</category><body package="WinGDIPlusInterface">bitsPerPixel	self shouldNotImplement</body><body package="WinGDIPlusInterface">depth	self shouldNotImplement</body><body package="WinGDIPlusInterface">mimeType	^ WinGDIPlusInterface current mimeTypeOfGpImage: handle</body><body package="WinGDIPlusInterface">paintBasis	self shouldNotImplement</body><body package="WinGDIPlusInterface">palette	self shouldNotImplement</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>private</category><body package="WinGDIPlusInterface">checkHandle	self validHandleDo: [ ] elseDo: [ WinGDIPlus.WinGDIPlusError raiseSignal: 'Bitmap has no valid handle' ].</body><body package="WinGDIPlusInterface">deviceContentsOfAreaOriginX: originX y: originY width: w height: h into: aByteArray startingAt: startingIndex	self shouldNotImplement</body><body package="WinGDIPlusInterface">gpImage	^ handle contents</body><body package="WinGDIPlusInterface">validHandleDo: handleBlock elseDo: elseBlock	(handle notNil and: [ handle isValid and: [ WinGDIPlusInterface current hasRegisteredGpImage: handle ]])		ifTrue: [ handleBlock value ]		ifFalse: [ elseBlock value ]</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>initialize-release</category><body package="WinGDIPlusInterface">hglobal: aHGlobal	hglobal := aHGlobal</body><body package="WinGDIPlusInterface">imagePointer: aGpImagePointer 	| extent |	handle := aGpImagePointer.	extent := WinGDIPlusInterface current extentOfGpImage: aGpImagePointer.	width := extent x.	height := extent y.</body><body package="WinGDIPlusInterface">privateClose	"Release allocated resources."	( hglobal notNil ) 		ifTrue: 		[	[ WinGDIPlusInterface current GlobalFree: hglobal ] on: Error do: [ : ex | ].			hglobal := nil		].	( handle notNil and: [ handle isValid ]) 		ifTrue: 		[	[ WinGDIPlusInterface current GdipDisposeImage: handle ] on: Error do: [ : ex | ].			handle := nil		].</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>saving</category><body package="WinGDIPlusInterface">asByteArrayWithFormat: imageFormat 	" 'save' the image into a ByteArray and return it "	self checkHandle.	^ WinGDIPlusInterface current saveGpImageToBytes: handle format: imageFormat</body><body package="WinGDIPlusInterface">saveAs: aFilename format: imageFormat 	self checkHandle.	WinGDIPlusInterface current saveGpImage: handle toFile: aFilename format: imageFormat.</body><body package="WinGDIPlusInterface">saveAsBMPTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface bmp.</body><body package="WinGDIPlusInterface">saveAsGIFTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface gif.</body><body package="WinGDIPlusInterface">saveAsJPEGTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface jpeg.</body><body package="WinGDIPlusInterface">saveAsPNGTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface png.</body><body package="WinGDIPlusInterface">saveAsTIFFTo: aFilename 	self saveAs: aFilename format: WinGDIPlusInterface tiff.</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>compatibility</category><body package="WinGDIPlusInterface">pngBytes	^ self asByteArrayWithFormat: WinGDIPlusInterface png</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap</class-id> <category>displaying</category><body package="WinGDIPlusInterface">displayOn: aGraphicsContext at: aPoint 	self displayOn: aGraphicsContext at: aPoint extent: width@height</body><body package="WinGDIPlusInterface">displayOn: aGraphicsContext at: aPoint extent: anExtent	" displays the image, scaled to the given extent "	self isOpen 		ifTrue: 		[	self 				validHandleDo: 				[						[ WinGDIPlusInterface current drawGpImage: handle width: anExtent x height: anExtent y onGraphicsContext: aGraphicsContext at: aPoint ] on: Error do: [: ex | ]				]				elseDo: [ ]		].</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap class</class-id> <category>private</category><body package="WinGDIPlusInterface">allocateHandleOn: aGraphicsDevice extent: aPoint	self shouldNotImplement</body><body package="WinGDIPlusInterface">imagePointer: aGpImagePointer	^self new imagePointer: aGpImagePointer; yourself</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap class</class-id> <category>instance creation - compatibility</category><body package="WinGDIPlusInterface">fromBytes: bytes 	" this actually returns a GDIPlusImage, not a bitmap "	^WinGDIPlusInterface current loadImageFromBytes: bytes</body><body package="WinGDIPlusInterface">fromFile: filename	" this actually returns a GDIPlusImage, not a bitmap "	^WinGDIPlusInterface current loadImageFromFile: filename</body></methods><methods><class-id>Graphics.WinGDIPlus.GDIPlusBitmap class</class-id> <category>constants - compatibility</category><body package="WinGDIPlusInterface">clsidImageFormatBMP	^WinGDIPlusInterface bmp</body><body package="WinGDIPlusInterface">clsidImageFormatGIF	^WinGDIPlusInterface gif</body><body package="WinGDIPlusInterface">clsidImageFormatJPEG	^WinGDIPlusInterface jpeg</body><body package="WinGDIPlusInterface">clsidImageFormatPNG	^WinGDIPlusInterface png</body><body package="WinGDIPlusInterface">clsidImageFormatTIFF	^WinGDIPlusInterface tiff</body></methods><methods><class-id>External.CStructureLayout</class-id> <category>accessing-align blocks</category><body package="WinGDIPlusInterface">defaultAlignBlock	"Answer the default alignment block used to align C types.  The block accepts two arguments; the structure layout object and the type to align.  It should return the index at which the argument type should be aligned in the given layout.  This aligns according to the most restrictive type."	^[:layout :type | layout allocate: type dataSize aligned: type dataSize]</body><body package="WinGDIPlusInterface">defaultArrayAlignBlock	"Answer the default array alignment block used to align C array types.  The block accepts two arguments: the structure layout object and the array type.  It should return the index at which the argument type should be aligned in the given layout.  The array is aligned according to the types of the array's elements."	^[:layout :arrayType | | typeLayout numOrNil size |		typeLayout := self class new.		typeLayout doType: arrayType referentType.		numOrNil := arrayType numElements.		numOrNil isNil			ifTrue: [size := 0]			ifFalse:				[typeLayout allocate: 0 aligned: typeLayout alignment.				size := typeLayout numBytes * numOrNil].		layout allocate: size aligned: typeLayout alignment]</body><body package="WinGDIPlusInterface">defaultStructAlignBlock	"Answer a default alignment block used to align C structures.  The block accepts two arguments: the structure layout object and the structure type to align.  It should return the index at which the argument type should begin.  This aligns according to the most restrictive type."	^[:layout :type | layout allocate: type dataSize aligned: type alignment]</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>types</category><body package="WinGDIPlusInterface">BOOL	&lt;C: typedef long BOOL&gt;</body><body package="WinGDIPlusInterface">CLSID	&lt;C: typedef GUID CLSID&gt;</body><body package="WinGDIPlusInterface">CombineMode	&lt;C: typedef enum {			CombineModeReplace, 			CombineModeIntersect, 			CombineModeUnion, 			CombineModeXor, 			CombineModeExclude, 			CombineModeComplement		} CombineMode&gt;</body><body package="WinGDIPlusInterface">DWORD	&lt;C: typedef void * DWORD&gt;</body><body package="WinGDIPlusInterface">EncoderParameters	&lt;C: typedef void * EncoderParameters&gt;</body><body package="WinGDIPlusInterface">GUID	&lt;C: typedef void * GUID&gt;</body><body package="WinGDIPlusInterface">GdiplusStartupInput	&lt;C: typedef void * GdiplusStartupInput&gt;</body><body package="WinGDIPlusInterface">GdiplusStartupOutput	&lt;C: typedef void * GdiplusStartupOutput&gt;</body><body package="WinGDIPlusInterface">GpBitmap	&lt;C: typedef void * GpBitmap&gt;</body><body package="WinGDIPlusInterface">GpGraphics	&lt;C: typedef void * GpGraphics&gt;</body><body package="WinGDIPlusInterface">GpImage	&lt;C: typedef void * GpImage&gt;</body><body package="WinGDIPlusInterface">GpStatus	&lt;C: typedef void * GpStatus&gt;</body><body package="WinGDIPlusInterface">HBITMAP	&lt;C: typedef unsigned long HBITMAP&gt;</body><body package="WinGDIPlusInterface">HDC	&lt;C: typedef unsigned long  HDC&gt;</body><body package="WinGDIPlusInterface">HGLOBAL	&lt;C: typedef unsigned long HGLOBAL&gt;</body><body package="WinGDIPlusInterface">HPALETTE	&lt;C: typedef unsigned long HPALETTE&gt;</body><body package="WinGDIPlusInterface">HWND	&lt;C: typedef unsigned long HWND&gt;</body><body package="WinGDIPlusInterface">IStream	&lt;C: typedef void * IStream&gt;</body><body package="WinGDIPlusInterface">ImageType	&lt;C: typedef void * ImageType&gt;</body><body package="WinGDIPlusInterface">PropertyItem	&lt;C: typedef struct PropertyItemStruct {			int id;			unsigned long length;			unsigned short type;			void * value;		} PropertyItem&gt;</body><body package="WinGDIPlusInterface">REAL	&lt;C: typedef double REAL&gt;</body><body package="WinGDIPlusInterface">RotateFlipType	&lt;C: typedef enum {			RotateNoneFlipNone, 			Rotate90FlipNone, 			Rotate180FlipNone, 			Rotate270FlipNone, 			RotateNoneFlipX, 			Rotate90FlipX, 			Rotate180FlipX, 			Rotate270FlipX		} RotateFlipType&gt;</body><body package="WinGDIPlusInterface">ULONG_PTR	&lt;C: typedef void * ULONG_PTR&gt;</body><body package="WinGDIPlusInterface">WCHAR	&lt;C: typedef unsigned short WCHAR&gt;</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>enums</category><body package="WinGDIPlusInterface">EncoderValue	&lt;C: enum EncoderValue {			EncoderValueColorTypeCMYK, 			EncoderValueColorTypeYCCK, 			EncoderValueCompressionLZW, 			EncoderValueCompressionCCITT3, 			EncoderValueCompressionCCITT4, 			EncoderValueCompressionRle, 			EncoderValueCompressionNone, 			EncoderValueScanMethodInterlaced, 			EncoderValueScanMethodNonInterlaced, 			EncoderValueVersionGif87, 			EncoderValueVersionGif89, 			EncoderValueRenderProgressive, 			EncoderValueRenderNonProgressive, 			EncoderValueTransformRotate90, 			EncoderValueTransformRotate180, 			EncoderValueTransformRotate270, 			EncoderValueTransformFlipHorizontal, 			EncoderValueTransformFlipVertical, 			EncoderValueMultiFrame, 			EncoderValueLastFrame, 			EncoderValueFlush, 			EncoderValueFrameDimensionTime, 			EncoderValueFrameDimensionResolution, 			EncoderValueFrameDimensionPage		}&gt;</body><body package="WinGDIPlusInterface">QualityMode	&lt;C: enum QualityMode {			QualityModeInvalid = -1, 			QualityModeDefault, 			QualityModeLow, 			QualityModeHigh		}&gt;</body><body package="WinGDIPlusInterface">__GpStatus	&lt;C: enum __GpStatus {			Ok, 			GenericError, 			InvalidParameter, 			OutOfMemory, 			ObjectBusy, 			InsufficientBuffer, 			NotImplemented, 			Win32Error, 			WrongState, 			Aborted, 			FileNotFound, 			ValueOverflow, 			AccessDenied, 			UnknownImageFormat, 			FontFamilyNotFound, 			FontStyleNotFound, 			NotTrueTypeFont, 			UnsupportedGdiplusVersion, 			GdiplusNotInitialized		}&gt;</body><body package="WinGDIPlusInterface">__ImageType	&lt;C: enum __ImageType {			ImageTypeUnknown, 			ImageTypeBitmap, 			ImageTypeMetafile		}&gt;</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>structs</category><body package="WinGDIPlusInterface">ImageCodecInfo	&lt;C: struct ImageCodecInfo {			CLSID Clsid;			GUID FormatID;			char * CodecName;			char * DllName;			char * FormatDescription;			char * FilenameExtension;			char * MimeType;			DWORD Flags, Version, SigCount, SigSize;			char * SigPattern;			char * SigMask;		}&gt;</body><body package="WinGDIPlusInterface">__GUID	&lt;C: struct __GUID {			unsigned long Data1;			unsigned short Data2, Data3;			unsigned char Data4[8];		}&gt;</body><body package="WinGDIPlusInterface">__GdiplusStartupInput	&lt;C: struct __GdiplusStartupInput {			unsigned int GdiplusVersion;			void* DebugEventCallback;			BOOL SuppressBackgroundThread, SuppressExternalCodecs;		}&gt;</body><body package="WinGDIPlusInterface">__GdiplusStartupOutput	&lt;C: struct __GdiplusStartupOutput {			void* NotificationHook, NotificationUnhook;		}&gt;</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>defines</category><body package="WinGDIPlusInterface">GMEM_DISCARDABLE	&lt;C: #define GMEM_DISCARDABLE 256	&gt;</body><body package="WinGDIPlusInterface">GMEM_FIXED	&lt;C: #define GMEM_FIXED 0x0000	&gt;</body><body package="WinGDIPlusInterface">GMEM_MOVEABLE	&lt;C: #define GMEM_MOVEABLE 0x0002	&gt;</body><body package="WinGDIPlusInterface">GMEM_NODISCARD	&lt;C: #define GMEM_NODISCARD 0x0020	&gt;</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>private</category><body package="WinGDIPlusInterface">checkErrorCode: errorCode message: errorMessage 	| unsignedCode |	errorCode = 0 		ifFalse: 		[	unsignedCode := errorCode &gt; 0 					ifTrue: [ errorCode ]					ifFalse: [ 16r100000000 + errorCode ].			WinGDIPlus.WinGDIPlusError raiseSignal: errorMessage , ' (Code: 0x' , ( unsignedCode printStringRadix: 16 ) , ')'		].</body><body package="WinGDIPlusInterface">createBitmapFromImage: aGpImagePointer 	| newBitmap |	newBitmap := WinGDIPlus.GDIPlusBitmap imagePointer: aGpImagePointer.	images at: aGpImagePointer put: newBitmap.	^ newBitmap</body><body package="WinGDIPlusInterface">graphicsForHDC: aHDC 	| graphicsPtr |	graphicsPtr := self GpGraphics gcMalloc.	^ ( self GdipCreateFromHDC: aHDC with: graphicsPtr ) = 0 		ifTrue: [ graphicsPtr contents ]		ifFalse: [ nil ]</body><body package="WinGDIPlusInterface">graphicsForHWND: aHWND 	| graphicsPtr |	graphicsPtr := self GpGraphics gcMalloc.	^ ( self GdipCreateFromHWND: aHWND with: graphicsPtr ) = 0 		ifTrue: [ graphicsPtr contents ]		ifFalse: [ nil ]</body><body package="WinGDIPlusInterface">graphicsForWindow: aWindow	| graphicsPtr |	graphicsPtr := self GpGraphics gcMalloc. 	^(self GdipCreateFromHWND: aWindow windowHandle with: graphicsPtr) = 0 ifTrue: [ graphicsPtr ] ifFalse: [ nil ]</body><body package="WinGDIPlusInterface">hGlobalFromBytes: bytes	| uFlags hGlobal memPointer |	uFlags := self GMEM_NODISCARD bitOr: self GMEM_MOVEABLE.	hGlobal := self GlobalAlloc: uFlags with: bytes size.	memPointer := self GlobalLock: hGlobal.	memPointer copyAt: 0 from: bytes size: bytes size startingAt: 1.	self GlobalUnlock: hGlobal.	^hGlobal</body><body package="WinGDIPlusInterface">hasRegisteredGpImage: aGpImagePointer	^ images includesKey: aGpImagePointer</body><body package="WinGDIPlusInterface">hdcOfPixmap: pixmap do: aBlock	self systemInterface gdiHDCOfPixmap: pixmap do: aBlock</body><body package="WinGDIPlusInterface">systemInterface	systemInterface isNil 		ifTrue: [ systemInterface := OSSystemSupport concreteClass new ].	^ systemInterface</body><body package="WinGDIPlusInterface">timestampFrom: dateTimeString 	"The format is YYYY:MM:DD HH:MM:SSwith time shown in 24-hour format, and the date and time separated by one blank character [20.H]. When the date and time are unknown, all the character spaces except colons (:) may be filled with blank characters, or else the Interoperability  field may be filled with blank  characters. The character string length is 20 bytes including NULL for termination. When the field is left blank, it is treated as unknown."	"eg. 1997:09:01 12:00:00"	| yearInteger monthInteger dayInteger timeStream date time |	( dateTimeString isNil or: [ dateTimeString size &lt; 19 ]) ifTrue: [ ^ nil ].	yearInteger := ( dateTimeString copyFrom: 1 to: 4 ) asInteger.	monthInteger := ( dateTimeString copyFrom: 6 to: 7 ) asInteger.	dayInteger := ( dateTimeString copyFrom: 9 to: 10 ) asInteger.	timeStream := dateTimeString readStream.	timeStream next: 11.	^ [	date := Date newDay: dayInteger monthNumber: monthInteger year: yearInteger.		time := Time readFrom: timeStream.		Timestamp fromDate: date andTime: time	] on: Error do: [: ex | nil ]</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>initialize-release</category><body package="WinGDIPlusInterface">shutdown	libraryToken notNil ifTrue:	[		images finalizeElements. "release memory of all images - last chance to do so"		self GdiplusShutdown: libraryToken contents.		libraryToken := nil.	].</body><body package="WinGDIPlusInterface">startup	| input output res |	input := self __GdiplusStartupInput gcMalloc.	input zeroFill.	input memberAt: #GdiplusVersion put: 1.	output := self __GdiplusStartupOutput gcMalloc.	output zeroFill.	libraryToken := self ULONG_PTR gcMalloc.	res := self GdiplusStartup: libraryToken with: input with: output.	res = 0 ifFalse: [ self error: 'GDI initialize failed' ].	images := WeakDictionary new.</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>GDI image functions</category><body package="WinGDIPlusInterface">cloneGpImage: aGpImagePointer 	" create a new cloned GDIPlusBitmap "	| clonedImagePointerPointer errorCode |	clonedImagePointerPointer := self GpImage pointerType gcMalloc.	errorCode := self GdipCloneImage: aGpImagePointer with: clonedImagePointerPointer.	self checkErrorCode: errorCode message: 'Unable to clone image'.	^ self createBitmapFromImage: clonedImagePointerPointer contents</body><body package="WinGDIPlusInterface">disposeGpImage: aGpImagePointer	| errorCode |	errorCode := self GdipDisposeImage: aGpImagePointer.	self checkErrorCode: errorCode message: 'Could not dispose image'.</body><body package="WinGDIPlusInterface">drawGpImage: aGpImagePointer width: width height: height onGraphicsContext: aGraphicsContext at: aPoint 	aGraphicsContext medium 		gdiGraphicsForInterface: self		do: 		[: graphics | | origin absolutePoint clippingBounds errorCode |			absolutePoint := aPoint + aGraphicsContext translation.			origin := aGraphicsContext deviceClippingBounds origin.			clippingBounds := aGraphicsContext deviceClippingBounds.			errorCode := self GdipSetClipRectI: graphics with: origin x with: origin y with: clippingBounds width with: clippingBounds height with: 0.			self checkErrorCode: errorCode message: 'Could not set clipping region'.			errorCode := self GdipDrawImageRectI: graphics with: aGpImagePointer with: absolutePoint x rounded with: absolutePoint y rounded with: width with: height.			self checkErrorCode: errorCode message: 'Could not draw image'		].</body><body package="WinGDIPlusInterface">extentOfGpImage: aGpImagePointer	| intPointer height width |	intPointer := CIntegerType unsignedInt gcMalloc.	self GdipGetImageHeight: aGpImagePointer with: intPointer.	height := intPointer contents.	self GdipGetImageWidth: aGpImagePointer with: intPointer.	width := intPointer contents.	^ width @ height</body><body package="WinGDIPlusInterface">gpImageFromBytes: bytes do: block 	" evaluate the block with a pointer to the image loaded from the byte array "	| hGlobal iStreamPointer imagePointerPointer errorCode imagePointer |	hGlobal := self hGlobalFromBytes: bytes.	iStreamPointer := self IStream gcMalloc.	self CreateStreamOnHGlobal: hGlobal with: 0 with: iStreamPointer.	imagePointerPointer := self GpImage pointerType gcMalloc.	errorCode := self GdipLoadImageFromStream: iStreamPointer contents with: imagePointerPointer.	self checkErrorCode: errorCode message: 'Unable to load image'.	imagePointer := imagePointerPointer contents.	^ [ block value: imagePointer ] ensure: 		[	self GlobalFree: hGlobal.			self GdipDisposeImage: imagePointer		]</body><body package="WinGDIPlusInterface">mimeTypeOfGpImage: aGpImagePointer 	| guidPointer guid |	guidPointer := self __GUID gcMalloc.	self GdipGetImageRawFormat: aGpImagePointer  with: guidPointer.	guid := guidPointer contents datum asByteArray.	guid = #[171 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/bmp' ].	guid = #[172 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/x-emf' ].	guid = #[173 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/x-wmf' ].	guid = #[174 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/jpeg' ].	guid = #[175 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/png' ].	guid = #[176 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/gif' ].	guid = #[177 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/tiff' ].	guid = #[181 60 107 185 40 7 211 17 157 123 0 0 248 30 243 46] ifTrue: [ ^'image/vnd.microsoft.icon' ].	^nil</body><body package="WinGDIPlusInterface">saveGpImage: aGpImagePointer toFile: aFilename format: imageFormat 	| errorCode |	errorCode := self GdipSaveImageToFile: aGpImagePointer with: aFilename asString gcCopyToHeapUnicode with: imageFormat gcCopyToHeap with: nil.	self checkErrorCode: errorCode message: 'Unable to save image'.</body><body package="WinGDIPlusInterface">saveGpImageToBytes: aGpImagePointer format: format 	| hGlobalPointer iStreamPointer errorCode memorySize bytes memPointer hGlobal iStream |	iStreamPointer := self IStream gcMalloc.	errorCode := self CreateStreamOnHGlobal: 0 with: 0 with: iStreamPointer.	self checkErrorCode: errorCode message: 'Unable to create image stream'.	iStream := iStreamPointer contents.	errorCode := self GdipSaveImageToStream: aGpImagePointer with: iStream with: format with: nil.	self checkErrorCode: errorCode message: 'Unable to save image'.	hGlobalPointer := self HGLOBAL gcMalloc.	errorCode := self GetHGlobalFromStream: iStream with: hGlobalPointer.	self checkErrorCode: errorCode message: 'Unable to get image data from stream'.	hGlobal := hGlobalPointer contents.	memorySize := self systemInterface gdiGlobalSize: hGlobal .	bytes := ByteArray new: memorySize.	memPointer := self GlobalLock: hGlobal.	memPointer copyAt: 0 to: bytes size: bytes size startingAt: 1.	self GlobalUnlock: hGlobal.	self GlobalFree: hGlobal.	^  bytes</body><body package="WinGDIPlusInterface">thumbnailFromGpImage: aGpImagePointer width: width height: height 	^ self createBitmapFromImage: (self thumbnailGpImageFromImage: aGpImagePointer width: width height: height)</body><body package="WinGDIPlusInterface">thumbnailGpImageFromImage: aGpImagePointer width: width height: height 	| thumbnailPointerPointer errorCode tempBytes |	thumbnailPointerPointer := self GpImage pointerType gcMalloc.	"if the orientation of the image is specified there is a chance that the embedded thumbnail has a wrong orientation - do not use it in this case"	( self image: aGpImagePointer hasProperty: 16r501B ) 		ifTrue: 		[	" the only way to get rid of the inner thumbnail"			tempBytes := self saveGpImageToBytes: aGpImagePointer format: self class png.			^ [	self 					gpImageFromBytes: tempBytes					do: 					[: tempGpImagePointer |						errorCode := self GdipGetImageThumbnail: tempGpImagePointer with: width with: height with: thumbnailPointerPointer with: 0 with: nil.						self checkErrorCode: errorCode message: 'Unable to create thumbnail image'.						thumbnailPointerPointer contents					]			] on: WinGDIPlus.WinGDIPlusError do: [: ex | nil ]		].	errorCode := self GdipGetImageThumbnail: aGpImagePointer with: width with: height with: thumbnailPointerPointer with: 0 with: nil.	self checkErrorCode: errorCode message: 'Unable to create thumbnail image'.	^ thumbnailPointerPointer contents</body><body package="WinGDIPlusInterface">thumbnailOfGpImage: aGpImagePointer	| bytes |	bytes := self property: 16r501B ofGpImage: aGpImagePointer.	bytes isNil ifTrue: [ ^nil ].	^self loadImageFromBytes: bytes</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>image properties</category><body package="WinGDIPlusInterface">dateTimeOfGpImage: aGpImagePointer 	^ self property: 16r132 ofGpImage: aGpImagePointer</body><body package="WinGDIPlusInterface">image: aGpImagePointer hasProperty: propertyID	| intPointer numProperties propIDsPointer status |	intPointer := CIntegerType unsignedInt gcMalloc.	status := self GdipGetPropertyCount: aGpImagePointer with: intPointer.	status = 0 ifFalse: [ ^false ].	numProperties := intPointer contents.	numProperties &gt; 0 ifFalse: [ ^false ].	propIDsPointer := CIntegerType int gcMalloc: numProperties.	status := self GdipGetPropertyIdList: aGpImagePointer with: numProperties with: propIDsPointer.	status = 0 ifFalse: [ ^false ].	0 to: numProperties - 1 do: [ : idx | (propIDsPointer at: idx) = propertyID ifTrue: [ ^true ]].	^false</body><body package="WinGDIPlusInterface">orientationOfGpImage: aGpImagePointer"Default = 11 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.5 = The 0th row is the visual left-hand side of of the image, and the 0th column is the visual top.6 = The 0th row is the visual right-hand side of of the image, and the 0th column is the visual top.7 = The 0th row is the visual right-hand side of of the image, and the 0th column is the visual bottom.8 = The 0th row is the visual left-hand side of of the image, and the 0th column is the visual bottom.""case 2: // The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.					GdipImageRotateFlip(img, RotateNoneFlipX);				case 3: // The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.					GdipImageRotateFlip(img, Rotate180FlipNone);				case 4: // The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side					GdipImageRotateFlip(img, RotateNoneFlipY);				case 5: // The 0th row is the visual left-hand side of of the image, and the 0th column is the visual top.					GdipImageRotateFlip(img, Rotate90FlipY);				case 6: // The 0th row is the visual right -hand side of of the image, and the 0th column is the visual top.					GdipImageRotateFlip(img, Rotate270FlipNone);				case 7: // The 0th row is the visual right -hand side of of the image, and the 0th column is the visual bottom.					GdipImageRotateFlip(img, Rotate270FlipY);				case 8: // The 0th row is the visual left-hand side of of the image, and the 0th column is the visual bottom					GdipImageRotateFlip(img, Rotate90FlipNone);"	| orientation |	orientation := self property: 16r112 ofGpImage: aGpImagePointer.	^orientation ifNil: [ 1 ]</body><body package="WinGDIPlusInterface">propertiesOfGpImage: aGpImagePointer	| intPointer numProperties propIDsPointer status propertyDictionary |	propertyDictionary := Dictionary new.	intPointer := CIntegerType unsignedInt gcMalloc.	status := self GdipGetPropertyCount: aGpImagePointer with: intPointer.	status = 0 ifFalse: [ ^propertyDictionary ].	numProperties := intPointer contents.	numProperties &gt; 0 ifFalse: [ ^propertyDictionary ].	propIDsPointer := CIntegerType int gcMalloc: numProperties.	status := self GdipGetPropertyIdList: aGpImagePointer with: numProperties with: propIDsPointer.	status = 0 ifFalse: [ ^propertyDictionary ].	0 to: numProperties - 1 do: [ : idx | (self property: (propIDsPointer at: idx) ofGpImage: aGpImagePointer) ifNotNil: [ : p |  propertyDictionary at: (propIDsPointer at: idx) put: p ] ].	^propertyDictionary</body><body package="WinGDIPlusInterface">property: propID ofGpImage: aGpImagePointer 	| imagePropertiesSizePointer propertyItemSize propertyItemPtr propertyItemFakePtr status type length valuePtr propertyItem bytes string |	imagePropertiesSizePointer := CIntegerType unsignedInt gcMalloc.	status := self GdipGetPropertyItemSize: aGpImagePointer with: propID with: imagePropertiesSizePointer.	status = 0 ifFalse: [ ^ nil ].	propertyItemSize := imagePropertiesSizePointer contents.	propertyItemFakePtr := CIntegerType unsignedChar gcMalloc: propertyItemSize.	status := self GdipGetPropertyItem: aGpImagePointer with: propID with: propertyItemSize with: propertyItemFakePtr.	propertyItemPtr := CCompositePointer new newDatum: propertyItemFakePtr datum ofType: self PropertyItem pointerType.	status = 0 ifFalse: [ ^ nil ].	propertyItem := propertyItemPtr contents.	propID = ( propertyItem memberAt: #id ) ifFalse: [ ^ nil ].	type := propertyItem memberAt: #type.	length := propertyItem memberAt: #length.	valuePtr := propertyItem memberAt: #value.	(type = 1 or: [ type = 7 ]) ifTrue: "PropertyTagTypeByte / PropertyTagTypeUndefined"		[	valuePtr type: CIntegerType unsignedChar pointerType.			bytes := ByteArray new: length.			valuePtr copyAt: 0 to: bytes size: length startingAt: 1.			^ bytes		].	type = 2 ifTrue: "PropertyTagTypeASCII"		[	valuePtr type: CIntegerType char pointerType.			string := valuePtr copyCStringFromHeap.			^length = 20 ifTrue: [ (self timestampFrom: string) ifNil: [ string ] ] ifFalse: [ string ] "kÃ¶nnte ein Timestamp sein"		].	type = 3 ifTrue: "PropertyTagTypeShort"		[	valuePtr type: CIntegerType unsignedShort pointerType.			^ valuePtr contents		].	type = 4 ifTrue: "PropertyTagTypeLong"		[	valuePtr type: CIntegerType unsignedLong pointerType.			^ valuePtr contents		].	type = 5 ifTrue: "PropertyTagTypeRational"		[	valuePtr type: CIntegerType unsignedLong pointerType.			^ (valuePtr at: 0) / (valuePtr at: 1)		].	type = 9 ifTrue: "PropertyTagTypeSLONG"		[	valuePtr type: CIntegerType long pointerType.			^ valuePtr contents		].	type = 10 ifTrue: "PropertyTagTypeSRational"		[	valuePtr type: CIntegerType long pointerType.			^ (valuePtr at: 0) / (valuePtr at: 1)		].	^ nil</body></methods><methods><class-id>WinGDIPlusInterface</class-id> <category>comfy</category><body package="WinGDIPlusInterface">bitmapFromPixmap: aPixmap	" Converts a Pixmap to a GDSIPlusBitmap "	| bitmapPointerPointer errorCode |	bitmapPointerPointer := self GpBitmap pointerType gcMalloc.	errorCode := self GdipCreateBitmapFromHBITMAP: aPixmap gdiHBitmap with: 0 with: bitmapPointerPointer.	self checkErrorCode: errorCode message: 'Could not create bitmap from pixmap'.	^ self createBitmapFromImage: bitmapPointerPointer contents</body><body package="WinGDIPlusInterface">loadImageFromBytes: bytes 	" Creates a GDIPlusImage from the picture byte array "	| hGlobal iStreamPointer imagePointerPointer newBitmap errorCode imagePointer |	hGlobal := self hGlobalFromBytes: bytes.	iStreamPointer := self IStream gcMalloc.	self CreateStreamOnHGlobal: hGlobal with: 0 with: iStreamPointer.	imagePointerPointer := self GpImage pointerType gcMalloc.	errorCode := self GdipLoadImageFromStream: iStreamPointer contents with: imagePointerPointer.	self checkErrorCode: errorCode message: 'Unable to load image'.	imagePointer := imagePointerPointer contents.	"  WeakDictionary&gt;&gt;at:put: creates a copy (Executor), so HGLOBAL must be set before registering the bitmap "	newBitmap := WinGDIPlus.GDIPlusBitmap imagePointer: imagePointer.	newBitmap hglobal: hGlobal.	images at: imagePointer put: newBitmap.	^ newBitmap asImage</body><body package="WinGDIPlusInterface">loadImageFromFile: filename 	" Creates a GDIPlusImage from the picture file "	| imagePointerPointer newBitmap errorCode |	imagePointerPointer := self GpImage pointerType gcMalloc.	errorCode := self GdipLoadImageFromFile: filename asString gcCopyToHeapUnicode with: imagePointerPointer.	self checkErrorCode: errorCode message: 'Unable to load image'.	newBitmap := self createBitmapFromImage: imagePointerPointer contents.	^ newBitmap asImage</body></methods><methods><class-id>WinGDIPlusInterface class</class-id> <category>class initialization</category><body package="WinGDIPlusInterface">flushAllCaches	current := nil.	^super flushAllCaches</body><body package="WinGDIPlusInterface">installOn: platformArray	current := nil. "do not re-use old instances!"	^super installOn: platformArray</body><body package="WinGDIPlusInterface">postLoadInitialize	self releaseCurrent.	self safeRecompileMethods.	self checkBashedExternalMethodSelectors.</body></methods><methods><class-id>WinGDIPlusInterface class</class-id> <category>accessing</category><body package="WinGDIPlusInterface">current	^current ifNil: [ 		current := self new startup; yourself.		isAvailable := true.		current	]</body><body package="WinGDIPlusInterface">isAvailable	^ isAvailable notNil		ifTrue: [ isAvailable ]		ifFalse: [			[				self current.				isAvailable			] on: Error do: [ : ex |				isAvailable := false.			].		].</body><body package="WinGDIPlusInterface">releaseCurrent	current notNil 		ifTrue: [ 			current shutdown. 			current := nil.		].	isAvailable := nil.</body></methods><methods><class-id>WinGDIPlusInterface class</class-id> <category>constants</category><body package="WinGDIPlusInterface">bmp	^#[0 244 124 85 4 26 211 17 154 115 0 0 248 30 243 46]</body><body package="WinGDIPlusInterface">gif	^#[2 244 124 85 4 26 211 17 154 115 0 0 248 30 243 46]</body><body package="WinGDIPlusInterface">jpeg	^#[1 244 124 85 4 26 211 17 154 115 0 0 248 30 243 46]</body><body package="WinGDIPlusInterface">png	^#[6 244 124 85 4 26 211 17 154 115 0 0 248 30 243 46]</body><body package="WinGDIPlusInterface">tiff	^#[5 244 124 85 4 26 211 17 154 115 0 0 248 30 243 46]</body></methods><methods><class-id>WinGDIPlusInterface class</class-id> <category>private</category><body package="WinGDIPlusInterface">internalTypeForMimeType: mimeType	mimeType = 'image/jpeg' ifTrue: [ ^ self jpeg ].	mimeType = 'image/png' ifTrue: [ ^ self png ].	mimeType = 'image/gif' ifTrue: [ ^ self gif ].	mimeType = 'image/bmp' ifTrue: [ ^ self bmp ].	mimeType = 'image/tiff' ifTrue: [ ^ self tiff ].	^nil</body></methods><methods><class-id>Graphics.Pixmap</class-id> <category>converting</category><body package="WinGDIPlusInterface">asGDIPlusBitmap	" Converts this pixmap into a GDI+ bitmap. 	This allows processing the pixmap with GDI+ functions, especially to save it to a file"	^ WinGDIPlusInterface current bitmapFromPixmap: self</body><body package="WinGDIPlusInterface">asGDIPlusImage	" Converts this pixmap into a GDI+ image. 	This allows processing the pixmap with GDI+ functions, especially to save it to a file"	^ self asGDIPlusBitmap asImage</body></methods><methods><class-id>Graphics.Pixmap</class-id> <category>private</category><body package="WinGDIPlusInterface">gdiGraphicsForInterface: gdiInterface do: aBlock 	gdiInterface hdcOfPixmap: self do: 		[: hdc | | graphics |			graphics := gdiInterface graphicsForHDC: hdc.			graphics notNil 				ifTrue: 				[						[ aBlock value: graphics ] ensure: [ gdiInterface GdipDeleteGraphics: graphics ]				]		].</body><body package="WinGDIPlusInterface">gdiHBitmap	^ ObjectMemory is64Bit		ifTrue: [ handle unsignedLongAt: 9 ]		ifFalse: [ handle unsignedLongAt: 5 ]</body></methods><methods><class-id>Graphics.Screen</class-id> <category>accessing</category><body package="WinGDIPlusInterface">canDisplayGDIBitmaps	^ true</body></methods><methods><class-id>Graphics.GraphicsMedium</class-id> <category>private</category><body package="WinGDIPlusInterface">gdiGraphicsForInterface: gdiInterface do: aBlock 	" evaluate the block with a GDI+ graphics pointer, if possible "</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>accessing</category><body package="WinGDIPlusInterface">gdiHDCOfPixmap: pixmap do: aBlock 	| hdc oldHDC |	hdc := self gdiCreateCompatibleDC: 0.	( hdc = 0 or: [ hdc isPointer and: [ hdc isNull ]]) 		ifTrue: [ ^ self ].	oldHDC := self gdiSelectObject: hdc with: pixmap gdiHBitmap.	[ aBlock value: hdc asInteger ] ensure: 		[	self gdiSelectObject: oldHDC with: pixmap gdiHBitmap.			self gdiDeleteDC: hdc		].</body></methods><methods><class-id>OS.OSSystemSupport</class-id> <category>accessing</category><body package="WinGDIPlusInterface">gdiHDCOfPixmap: pixmap do: aBlock	" evaluates the block with the HDC of the pixmap.	...which only works on Windows "</body></methods><methods><class-id>Graphics.Window</class-id> <category>private</category><body package="WinGDIPlusInterface">gdiGraphicsForInterface: gdiInterface do: aBlock 	| graphics |	graphics := gdiInterface graphicsForHWND: self windowHandle.	graphics notNil 		ifTrue: 		[				[ aBlock value: graphics ] ensure: [ gdiInterface GdipDeleteGraphics: graphics ]		].</body></methods><methods><class-id>Graphics.GraphicsDevice</class-id> <category>accessing</category><body package="WinGDIPlusInterface">canDisplayGDIBitmaps	" true if GDI bitmaps can be displayed on this device "	^ false</body></methods><methods><class-id>Graphics.PixelArray</class-id> <category>converting</category><body package="WinGDIPlusInterface">asGDIPlusBitmap	" Converts this image into a GDI+ bitmap.  "	^ self asRetainedMedium asGDIPlusBitmap</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>GraphicsDevice</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle colorPalette coveragePalette defaultFontPolicy defaultColorPolicy defaultCoveragePolicy defaultWidgetPolicy defaultPaintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>GraphicsMedium</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>UnmappableSurface</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Pixmap</name><environment>Graphics</environment><super>Graphics.UnmappableSurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>OSSystemSupport</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OSSystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Support</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>PixelArray</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Screen</name><environment>Graphics</environment><super>Graphics.HostGraphicsDevice</super><private>false</private><indexed-type>none</indexed-type><inst-vars>boundingBox subRegions resolution rendererName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class></st-source>