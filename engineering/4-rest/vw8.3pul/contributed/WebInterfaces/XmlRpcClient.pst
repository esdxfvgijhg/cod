<?xml version="1.0"?><st-source><!-- Name: XmlRpcClientComment: A simple implementation of the Xml-Rpc specification - see http://www.xmlrpc.com for details.  A simple example of usage:	| client ids feeds |	client := XmlRpcClient url: 'http://www.syndic8.com/xmlrpc.php'.	ids := client perform: 'syndic8.FindFeeds' with: 'Smalltalk'.	feeds := client perform: 'syndic8.GetFeedInfo' with: ids.	^feedsDbIdentifier: psql_public_cst_2007DbTrace: 67365DevelopmentPrerequisites: #(#(#any 'HTTP' '') #(#package 'NetworkAppUtilities' ''))KSignature: #('definedClasses' 9 'definedClassesHash' 7574078733 'extendedClasses' 16 'extendedClassesHash' 4192699540)PackageName: XmlRpcClientParcel: #('XmlRpcClient')ParcelName: XmlRpcClientPreReadBlock: [ Smalltalk.Core addImport: 	(SpecificNameSpaceImport 			pathString: 'Smalltalk.Net.Base64StreamEncoder').true]PrerequisiteParcels: #(#('HTTP' '') #('NetworkAppUtilities' ''))PrintStringCache: (9.118.hk.1,klnsrgn)Version: (9.114,jamesr)Pre-Load Block: 	[:pkg |]Pre-Read Block: 	[ Smalltalk.Core addImport: 	(SpecificNameSpaceImport 			pathString: 'Smalltalk.Net.Base64StreamEncoder').true]Date: 1:15:35 PM November 15, 2009 --><time-stamp>From VisualWorksÂ®, 7.7 of November 5, 2009 on November 15, 2009 at 1:15:35 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>XmlRpcFault</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorCode description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcFault</class-id><body>XML-RPC uses XML in the body of HTTP message to send back errors (faults) from RPCs. Instance Variables:	description	&lt;String&gt;	description of the fault	errorCode	&lt;Integer&gt;	number of the error. XML-RPC spec does not specify values. See below-1 = low level error0 = no error1 = server does not contain indicated object2 = requested method does not exist3 = not correct number of arguments for method</body></comment><class><name>XmlRpcMethodCall</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodName arguments </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.*			</imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcMethodCall</class-id><body>XmlRpcMethodCall contains needed information about a remote method call request. Translates the information from/to XML specified by the XML-RPC specInstance Variables:	arguments	&lt;Collection of: Object&gt;	arguments for remote method call, nil or empty collection for no arguments.	methodName	&lt;String&gt;	name of the remote method to call	objectLabel	&lt;String&gt;	key of the server object which is to execute this remote method</body></comment><class><name>XmlRpcParser</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcParser</class-id><body>Simple parser for XML-RPC XML. Since XML-RPC XML is so simple, implemeted parser from scratch to aid in porting code. This may be a mistake.Instance Variables:	source	&lt;ReadStream&gt;	 source of XML text to be parsedClass Variables:	PredefinedEntities	&lt;Dictionary&gt;	Standard XML predefined entities</body></comment><class><name>XmlRpcMethodResult</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcMethodResult</class-id><body>XmlRpcMethodResult represents the result of a remote method call. Converts self from/to proper XML.Instance Variables:	result	&lt;Object | anXmlRpcFault&gt;	result of a remote method or an XmlRpcFault if method call failed</body></comment><class><name>XmlRpcRemoteException</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcRemoteException</class-id><body>XmlRpcRemoteException thrown by XxlRpcProxy when an error occurs in executing a remote method.</body></comment><class><name>XmlRpcProcedureWrapper</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcProcedureWrapper</class-id><body>ProcedureWrapper maps XML-RPC requests for methods with positional arguments to Smalltalk style methods. Maps foo() to fooMaps foo(a) to foo: aMaps foo(a, b) to foo: #(a b )	"two or more arguments wrapped in collection"Note this means that all methods sent to the target must be either unary messages or keyword messages with only one keyword. The goal of this class is to allow Smalltalk objects appear to have the same method call syntax as C++ or Java objects. This class was needed in writting a XmlRpcValidator, which imlpements the XML-RPC validation tests. See XmlRpcServer class for an example usage.Instance Variables:	target	&lt;Object&gt; object that performs the method request</body></comment><class><name>XmlRpcClient</name><environment>Smalltalk</environment><super>Net.HttpRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Smalltalk.Net.MimeTypeDescriptor			</imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcClient</class-id><body>Simple HttpRequest with extensions for XML-RPC.Instance Variables:	httpVersion	&lt;String&gt;	HTTP/1.0, HTTP/1.1	method	&lt;String&gt;	POST, GET, etc	requestPath	&lt;String&gt;	url of the requested page. XML-RPC uses /RPC2 for this, but unless a request is going through a Web server this is ignored.</body></comment><class><name>XmlRpcParseError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcParseError</class-id><body>XmlRpcParseError is the exception thrown when a error occurs in parsing XMLRPC XML.</body></comment><class><name>XmlRpcDocumentation</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-XMLRPC</category><attributes><package>XmlRpcClient</package></attributes></class><comment><class-id>XmlRpcDocumentation</class-id><body>See class side methods for documentation for VW XmlRpc</body></comment><shared-variable><name>RpcXmlImplementationId</name><environment>XmlRpcClient</environment><private>false</private><constant>false</constant><category>constants</category><initializer> 'Smalltalk XMLRPC version 0.5 (', Smalltalk version, ')' </initializer><attributes><package>XmlRpcClient</package></attributes></shared-variable><shared-variable><name>PredefinedEntities</name><environment>XmlRpcParser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>XmlRpcClient</package></attributes></shared-variable><methods><class-id>XmlRpcFault</class-id> <category>accessing</category><body package="XmlRpcClient" selector="description">description	^description</body><body package="XmlRpcClient" selector="description:">description: aString	description := aString</body><body package="XmlRpcClient" selector="errorCode">errorCode	^errorCode</body><body package="XmlRpcClient" selector="errorCode:">errorCode: anInteger	errorCode := anInteger.</body></methods><methods><class-id>XmlRpcFault</class-id> <category>printing</category><body package="XmlRpcClient" selector="printOn:">printOn: aStream	aStream		nextPutAll: 'Fault(';		print: errorCode;		nextPutAll: ' ,';		print: description;		nextPutAll: ')'</body><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	| data |	aStream nextPutAll: '&lt;fault&gt;&lt;value&gt;'.	data := Dictionary new.	data at: 'faultCode' put: errorCode.	data at: 'faultString' put: description.	data printRpcXmlOn: aStream.	aStream nextPutAll: '&lt;/value&gt;&lt;/fault&gt;'</body></methods><methods><class-id>XmlRpcFault</class-id> <category>testing</category><body package="XmlRpcClient" selector="isXmlRpcFault">isXmlRpcFault	^true</body></methods><methods><class-id>XmlRpcFault class</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="errorCode:description:">errorCode: anInteger description: aString	^super new		errorCode: anInteger;		description: aString</body></methods><methods><class-id>XmlRpcMethodCall</class-id> <category>accessing</category><body package="XmlRpcClient" selector="arguments">arguments	^arguments</body><body package="XmlRpcClient" selector="arguments:">arguments: aCollection	arguments := aCollection</body><body package="XmlRpcClient" selector="method">method	^methodName asSymbol</body><body package="XmlRpcClient" selector="methodName">methodName	^methodName</body><body package="XmlRpcClient" selector="methodName:">methodName: aString	methodName := aString</body><body package="XmlRpcClient" selector="serverLabel">serverLabel	^(methodName includes: $.)		ifTrue:[(methodName tokensBasedOn: $.) first]		ifFalse:['']</body></methods><methods><class-id>XmlRpcMethodCall</class-id> <category>converting to xml</category><body package="XmlRpcClient" selector="asRpcXml">asRpcXml	| aStream numberOfArguments |	numberOfArguments := arguments isNil ifTrue: [1] ifFalse: [arguments size].	aStream := WriteStream on: (String new: numberOfArguments * 100 + 100).	self printRpcXmlOn: aStream.	^aStream contents</body><body package="XmlRpcClient" selector="methodNameXmlOn:">methodNameXmlOn: aStream	aStream		nextPutAll: '&lt;methodName&gt;';		nextPutAll: methodName asString;		nextPutAll: '&lt;/methodName&gt;'</body><body package="XmlRpcClient" selector="parameterXmlOn:">parameterXmlOn: aStream 	(arguments isNil or: [arguments isEmpty]) ifTrue: [^nil].	aStream		nextPutAll: '&lt;params&gt;';		cr;		tab.	arguments do: 			[:each | 			aStream nextPutAll: '&lt;param&gt;&lt;value&gt;'.			each printRpcXmlOn: aStream.			aStream nextPutAll: '&lt;/value&gt;&lt;/param&gt;'].	aStream		cr;		nextPutAll: '&lt;/params&gt;'</body></methods><methods><class-id>XmlRpcMethodCall</class-id> <category>printing</category><body package="XmlRpcClient" selector="printOn:">printOn: aStream 	self printRpcXmlOn: aStream</body><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream		nextPutAll: XmlRpcParser xmlVersion;		nextPutAll: '&lt;methodCall&gt;'.	self		methodNameXmlOn: aStream;		parameterXmlOn: aStream.	aStream nextPutAll: '&lt;/methodCall&gt;'</body></methods><methods><class-id>XmlRpcMethodCall</class-id> <category>initialize</category><body package="XmlRpcClient" selector="from:">from: aStream 	| parser |	parser := XmlRpcParser on: aStream.	parser processMethodCallFor: self</body></methods><methods><class-id>XmlRpcMethodCall class</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="from:">from: aStream	^super new from: aStream</body><body package="XmlRpcClient" selector="methodName:">methodName: aString 	^self 		methodName: aString		arguments: nil</body><body package="XmlRpcClient" selector="methodName:argument:">methodName: aString argument: anObject 	^self		methodName: aString		arguments: (Array with: anObject)</body><body package="XmlRpcClient" selector="methodName:arguments:">methodName: aString arguments: aCollection 	"Return an XmlRpcMthodCall object that represents a remote method call with	given methodName and arguments. The method call is to be executed by server object	associated with the server label"	^(super new)		methodName: aString;		arguments: aCollection</body></methods><methods><class-id>XmlRpcParser</class-id> <category>parsing basic xml</category><body package="XmlRpcClient" selector="endTag:">endTag: aString	"tag &lt;cat&gt;, then aString = cat"	source 		skipToAll: '&lt;/' , aString;		skipThrough: $&gt;.</body><body package="XmlRpcClient" selector="nextStartTag">nextStartTag	source skipThrough: $&lt;.	['/?!' includes: source peek ] whileTrue: [source skipThrough: $&lt;].	^source atEnd		ifTrue:[nil]		ifFalse: [source upTo: $&gt;]</body><body package="XmlRpcClient" selector="peek">peek	^source peek</body><body package="XmlRpcClient" selector="peekNextTag">peekNextTag	| startPosition tag |	startPosition := source position.	source skipThrough: $&lt;.	['?!' includes: source peek] whileTrue: [source skipThrough: $&lt;].	tag := source upTo: $&gt;.	source position: startPosition.	^tag</body><body package="XmlRpcClient" selector="skipComment">skipComment	source 		skipToAll: '--&gt;';		skip: 3</body><body package="XmlRpcClient" selector="skipWhiteSpace">skipWhiteSpace	source skipSeparators</body><body package="XmlRpcClient" selector="tagContents">tagContents	| contents |	contents := source  upTo: $&lt;.	"upTo: leaves stream after occurance of $&lt;"	source skip: -1.	^contents</body></methods><methods><class-id>XmlRpcParser</class-id> <category>parsing rpc xml </category><body package="XmlRpcClient" selector="processArray">processArray	| array expectedTag |	array := OrderedCollection new.	expectedTag := self nextStartTag.	(expectedTag = 'data'  or: [expectedTag = 'data /'])		ifFalse: 			[XmlRpcParseError raiseSignal: 'Missing &lt;data&gt; tag inside &lt;array&gt; tag'].	[self peekNextTag = 'value'] whileTrue: 			[self nextStartTag.			array addLast: self processValue.			self endTag: 'value'].	self endTag: 'array'.	^array</body><body package="XmlRpcClient" selector="processBase64">processBase64	^self tagContents decodeBase64</body><body package="XmlRpcClient" selector="processBoolean">processBoolean	| value val |	value := self tagContents trimSeparators.	value = '0' ifTrue: [^false].	value = '1' ifTrue: [^true].	val := value trimBlanks asLowercase.	val = 'true' ifTrue: [^true].	val = 'false' ifTrue: [^false].	XmlRpcParseError raiseSignal: 'Invalid value ' , value , ' for boolean'</body><body package="XmlRpcClient" selector="processDateTime">processDateTime		| value |	value := self tagContents trimSeparators. 	^Timestamp fromISO8601: value</body><body package="XmlRpcClient" selector="processDouble">processDouble	^self tagContents asNumber</body><body package="XmlRpcClient" selector="processInteger">processInteger	^self tagContents asNumber</body><body package="XmlRpcClient" selector="processMember">processMember	| tag key value |	2 timesRepeat: 			[tag := self nextStartTag.			tag = 'name' 				ifTrue: [key := self processName]				ifFalse: 					[tag = 'value' 						ifTrue: [value := self processValue]						ifFalse: [XmlRpcParseError raiseSignal: 'Invalid tag ' , tag , ' in &lt;member&gt;']]].	self endTag: 'member'.	^Association key: key value: value</body><body package="XmlRpcClient" selector="processName">processName	^self tagContents decodeRpcXml</body><body package="XmlRpcClient" selector="processObject">processObject	"Quick hack to experiment with sending all objects in XML-RPC"	| className variables objectClass |	self nextStartTag = 'class' 		ifTrue:[className := self processName]		ifFalse: [XmlRpcParseError raiseSignal: 'Missing &lt;className&gt; in &lt;object&gt;'].	self nextStartTag = 'instanceVariables'		ifTrue:			[self nextStartTag.			variables := self processStruct]		ifFalse: [XmlRpcParseError raiseSignal: 'Missing &lt;instanceVariables&gt; in &lt;object&gt;'].	objectClass := Smalltalk at: className asSymbol.	^objectClass xmlRpcNew: variables</body><body package="XmlRpcClient" selector="processParam">processParam	| tag value |	tag := self nextStartTag.	value := tag = 'value' 				ifTrue: [self processValue]				ifFalse: [XmlRpcParseError raiseSignal: 'Invalid tag ' , tag , ' in &lt;param&gt;'].	self endTag: 'param'.	^value</body><body package="XmlRpcClient" selector="processParams">processParams	| arguments |	arguments := OrderedCollection new.	[self peekNextTag = 'param'] whileTrue: 		[self nextStartTag.		arguments addLast: self processParam].	self endTag: 'params'.	^arguments asArray</body><body package="XmlRpcClient" selector="processString">processString	^self tagContents decodeRpcXml</body><body package="XmlRpcClient" selector="processStruct">processStruct	| struct |	struct := Dictionary new.	[self peekNextTag = 'member'] whileTrue: 		[self nextStartTag.		struct add: self processMember].	self endTag: 'struct'.	^struct</body><body package="XmlRpcClient" selector="processValue">processValue	| tag |	self peekNextTag = '/value' ifTrue: [^self processString].	tag := self nextStartTag.	(tag isXmlRpcInt) ifTrue: [^self processInteger].	tag isXmlRpcBoolean ifTrue: [^self processBoolean].	tag isXmlRpcString ifTrue: [^self processString].	tag isXmlRpcDouble ifTrue: [^self processDouble].	tag isXmlRpcArray ifTrue: [^self processArray].	tag isXmlRpcStruct ifTrue: [^self processStruct].	tag isXmlRpcDateTime ifTrue: [^self processDateTime].	tag isXmlRpcBase64 ifTrue: [^self processBase64].	tag isXmlRpcObject ifTrue: [^self processObject].	tag isXmlRpcNil ifTrue:[^nil].	XmlRpcParseError raiseSignal: 'Invalid tag ' , tag , ' in &lt;param&gt;'</body></methods><methods><class-id>XmlRpcParser</class-id> <category>parsing rpc xml method result</category><body package="XmlRpcClient" selector="processFault">processFault	| faultDictionary |	self nextStartTag = 'value' 		ifFalse: 			[XmlRpcParseError raiseSignal: 'Missing &lt;value&gt; tag inside &lt;fault&gt; tag'].	faultDictionary := self processValue.	^XmlRpcFault errorCode: (faultDictionary at: 'faultCode')		description: (faultDictionary at: 'faultString')</body><body package="XmlRpcClient" selector="processMethodResultFor:">processMethodResultFor: anRpcXmlMethodResult 	| tag result |	self nextStartTag = 'methodResponse' 		ifFalse: [XmlRpcParseError raiseSignal: 'Missing &lt;methodResponse&gt; tag'].	tag := self nextStartTag.	result := tag = 'params' 				ifTrue: [self processParams first]				ifFalse: 					[tag = 'fault' 						ifTrue: [self processFault]						ifFalse: 							[XmlRpcParseError raiseSignal: 'Invalid tag ' , tag , ' in method response']].	anRpcXmlMethodResult result: result</body></methods><methods><class-id>XmlRpcParser</class-id> <category>parsing rpc xml method call</category><body package="XmlRpcClient" selector="processMethodCallFor:">processMethodCallFor: anRpcXmlMethodCall 	| tag labelAndName arguments |	self nextStartTag = 'methodCall' 		ifFalse: [XmlRpcParseError raiseSignal: 'Missing &lt;methodCall&gt; tag'].	2 timesRepeat: 			[tag := self nextStartTag.			tag = 'methodName' ifTrue: [labelAndName := self processMethodName].			tag = 'params' ifTrue: [arguments := self processParams]].	 arguments := arguments isNil			ifTrue:[nil]			ifFalse:[arguments asArray].	labelAndName ifNil:  [XmlRpcParseError raiseSignal: 'Missing &lt;methodName&gt; tag'].	anRpcXmlMethodCall		methodName: labelAndName;		arguments: arguments</body><body package="XmlRpcClient" selector="processMethodName">processMethodName	| contents  |	contents := self tagContents.	self 		endTag: 'methodName';		skipWhiteSpace.	^contents</body></methods><methods><class-id>XmlRpcParser</class-id> <category>accessing</category><body package="XmlRpcClient" selector="atEnd">atEnd	^source atEnd</body><body package="XmlRpcClient" selector="source:">source: aStream	source := aStream</body></methods><methods><class-id>XmlRpcParser class</class-id> <category>utilities</category><body package="XmlRpcClient" selector="entityAt:">entityAt: aString 	^PredefinedEntities at: aString</body><body package="XmlRpcClient" selector="entityAt:ifAbsent:">entityAt: aString ifAbsent: aBlock 	^PredefinedEntities at: aString ifAbsent: aBlock</body><body package="XmlRpcClient" selector="entityAt:put:">entityAt: aString put: entityString 	"RpcXmlParser entityAt: 'lt' put: '&lt;' "	^PredefinedEntities at: aString put: entityString</body><body package="XmlRpcClient" selector="xmlVersion">xmlVersion	^'&lt;?xml version="1.0"?&gt;'</body></methods><methods><class-id>XmlRpcParser class</class-id> <category>class initialization</category><body package="XmlRpcClient" selector="initialize">initialize	"XmlRpcParser initialize"	"Standard entites defined in XML 1.0 spec, section 4.6 Predefined Entities"	PredefinedEntities := Dictionary new.	PredefinedEntities		at: 'lt' put: '&lt;';		at: '#60' put: '&lt;';		at: 'gt' put: '&gt;';		at: '#62' put: '&gt;';		at: 'amp' put: '&amp;';		at: '#38' put: '&amp;';		at: 'apos' put: '''';		at: '#39' put: '''';		at: 'quot' put: '"';		at: '#34' put: '"'</body></methods><methods><class-id>XmlRpcParser class</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="on:">on: aStream	^super new source: aStream</body></methods><methods><class-id>XmlRpcMethodResult</class-id> <category>accessing</category><body package="XmlRpcClient" selector="result">result	^result</body><body package="XmlRpcClient" selector="result:">result: anObject	result := anObject</body></methods><methods><class-id>XmlRpcMethodResult</class-id> <category>initialize</category><body package="XmlRpcClient" selector="from:">from: aStream 	| parser |	parser := XmlRpcParser on: aStream.	parser processMethodResultFor: self</body></methods><methods><class-id>XmlRpcMethodResult</class-id> <category>testing</category><body package="XmlRpcClient" selector="isXmlRpcFault">isXmlRpcFault	^result isXmlRpcFault</body></methods><methods><class-id>XmlRpcMethodResult</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream		nextPutAll: XmlRpcParser xmlVersion;		nextPutAll: '&lt;methodResponse&gt;'.	result isXmlRpcFault 		ifTrue: [result printRpcXmlOn: aStream]		ifFalse: 			[aStream nextPutAll: '&lt;params&gt;&lt;param&gt;&lt;value&gt;'.			result printRpcXmlOn: aStream.			aStream nextPutAll: '&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;'].	aStream nextPutAll: '&lt;/methodResponse&gt;'</body></methods><methods><class-id>XmlRpcMethodResult class</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="errorCode:description:">errorCode: anInteger description: aString 	"Return an XMlRpcMethodResult for an error in processing a method "	| fault |	fault := XmlRpcFault errorCode: anInteger description: aString.	^self result: fault</body><body package="XmlRpcClient" selector="from:">from: aStream	^super new from: aStream</body><body package="XmlRpcClient" selector="result:">result: anObject	^super new result: anObject</body></methods><methods><class-id>XmlRpcProcedureWrapper</class-id> <category>message handling</category><body package="XmlRpcClient" selector="perform:">perform: aSymbol	^target perform: aSymbol</body><body package="XmlRpcClient" selector="perform:withArguments:">perform: aSymbol withArguments: anArray	| method arguments |	method := aSymbol last ~= $:		ifTrue:[(aSymbol , ':') asSymbol]		ifFalse:[aSymbol asSymbol].	arguments := anArray size = 1		ifTrue:[anArray]		ifFalse:[Array with: anArray].	^target 		perform: method		withArguments: arguments</body></methods><methods><class-id>XmlRpcProcedureWrapper</class-id> <category>accessing</category><body package="XmlRpcClient" selector="target:">target: anObject	target := anObject</body></methods><methods><class-id>XmlRpcProcedureWrapper class</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="on:">on: anObject	^super new target: anObject</body></methods><methods><class-id>XmlRpcClient</class-id> <category>message handling</category><body package="XmlRpcClient" selector="perform:">perform: aRemoteMethodString	^self 		methodName: aRemoteMethodString;		execute</body><body package="XmlRpcClient" selector="perform:with:">perform: aRemoteMethodString with: argument	self 		methodName: aRemoteMethodString		argument: argument.	^self execute</body><body package="XmlRpcClient" selector="perform:with:with:">perform: aRemoteMethodString with: argument1 with: argument2	^self 		perform: aRemoteMethodString		withArguments: (Array with: argument1 with: argument2)</body><body package="XmlRpcClient" selector="perform:withArguments:">perform: aRemoteMethodString withArguments: aCollection	self 		methodName: aRemoteMethodString		arguments: aCollection.	^self execute</body></methods><methods><class-id>XmlRpcClient</class-id> <category>accessing</category><body package="XmlRpcClient" selector="execute">execute	| httpResponse |	httpResponse := super execute.	^(XmlRpcMethodResult from: (httpResponse contents  readStream)) result</body><body package="XmlRpcClient" selector="methodName:">methodName: methodNameString	"return an XML-RPC request for an XML-RPC server to execute the indicated	 metthod (no arguments) of the object associated with given label."	^self 		methodName: methodNameString		arguments: nil</body><body package="XmlRpcClient" selector="methodName:argument:">methodName: methodNameString argument: anObject	"return an XML-RPC request for an XML-RPC server to execute the indicated	 metthod (with one argument) of the object associated with given label."	^self 		methodName: methodNameString		arguments: (Array with: anObject)</body><body package="XmlRpcClient" selector="methodName:arguments:">methodName: methodNameString arguments: anOrderedCollection 	"return an XML-RPC request for an XML-RPC server to execute the indicated	 metthod (with arguments) of the object associated with given label."	|  requestedMethod |	requestedMethod := XmlRpcMethodCall 				methodName: methodNameString				arguments: anOrderedCollection.	self contents: requestedMethod asRpcXml.</body></methods><methods><class-id>XmlRpcClient</class-id> <category>initialize-release</category><body package="XmlRpcClient" selector="initialize">initialize	"Set the required headers for XmlRpc"	super initialize.	self contentType: MimeTypeDescriptor contentTypeXml.	self		fieldValueAt: 'User-Agent'		put: RpcXmlImplementationId</body></methods><methods><class-id>XmlRpcClient class</class-id> <category>examples</category><body package="XmlRpcClient" selector="addTwoExample">addTwoExample	"self addTwoExample"	^self validatorProxy 		perform: 'examples.addtwo' 		with: 5		with: 3</body><body package="XmlRpcClient" selector="getSmalltalkFeeds">getSmalltalkFeeds	"See http://www.syndic8.com/services.php for information on the server used."	"self getSmalltalkFeeds"		| client ids feeds |	client := XmlRpcClient url: 'http://www.syndic8.com/xmlrpc.php'.	ids := client perform: 'syndic8.FindFeeds' with: 'Smalltalk'.	feeds := client perform: 'syndic8.GetFeedInfo' with: ids.	^feeds</body><body package="XmlRpcClient" selector="getStateName:">getStateName: anInteger 	"Uses a userland server to return a name of a state"	"self getStateName: 8"	| proxy |	proxy := self host: 'betty.userland.com' port: 80 path: 'RPC2'.	^proxy perform: 'examples.getStateName' with: anInteger</body><body package="XmlRpcClient" selector="moderateSizeArrayCheckExample:">moderateSizeArrayCheckExample: anOrderedCollectionOfStrings	"See http://www.xmlrpc.com/validator1Docs for info on this remote method.	Returns first element concatenated with last element"	"self moderateSizeArrayCheckExample: #('a' 'dog' 'cat' )"	^self validatorProxy 		perform: 'validator1.moderateSizeArrayCheck' 		with: anOrderedCollectionOfStrings.</body><body package="XmlRpcClient" selector="multipleArgumentsExample">multipleArgumentsExample	"See http://www.xmlrpc.com/validator1Docs for info on this remote method.	Returns collection of 6 different types"	"self multipleArgumentsExample"	| arguments |	arguments := OrderedCollection new.	arguments		add: 10;		add: true;		add: 'aString';		add: 3.1415;		add: Timestamp now;		add: #[ 1 2 3].			^self validatorProxy 		perform: 'validator1.manyTypesTest' 		withArguments: arguments.</body><body package="XmlRpcClient" selector="simpleStructReturnExample">simpleStructReturnExample	"See http://www.xmlrpc.com/validator1Docs for info on this remote method.	Returns 10, 100, 1000 time the value sent"	"self simpleStructReturnExample"	^self validatorProxy 		perform: 'validator1.simpleStructReturnTest' 		with: 5.</body><body package="XmlRpcClient" selector="spellCheck">spellCheck	"See http://www.stuffeddog.com/speller/doc/rpc.html for information on the server used."	"self spellCheck"	| client |	client := self url: 'http://www.stuffeddog.com/speller/speller-rpc.cgi'.	^client 		perform: 'speller.spellCheck'		with: 'This is a ccat'		with: Array new</body><body package="XmlRpcClient" selector="time">time	"See http://www.xmlrpc.com/currentTime for information on the server"	"self time"	^(self  host: 'time.xmlrpc.com') 		perform: 'currentTime.getCurrentTime'</body><body package="XmlRpcClient" selector="validatorProxy">validatorProxy	"Return proxy to the XML-RPC validator server. See http://www.dscpl.com.au/xmlrpc-debugger.php	This proxy is for a well know XML-RPC server which runs all the time"	^self  url: 'http://xmlrpc.usefulinc.com/demo/server.php'</body></methods><methods><class-id>XmlRpcClient class</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="host:">host: aString	^self 		host: aString		port: 80		path: 'RPC2'</body><body package="XmlRpcClient" selector="host:path:">host: aString path: aPathString	^self 		host: aString 		port: 80		path: aPathString</body><body package="XmlRpcClient" selector="host:port:">host: aString port: anInteger 	^self 		host: aString 		port: anInteger		path: 'RPC2'</body><body package="XmlRpcClient" selector="host:port:path:">host: aString port: anInteger path: aPathString 	^self url: aString , ':' , anInteger printString , aPathString asHttpPath</body><body package="XmlRpcClient" selector="url:">url: aUrlString 	^super post: aUrlString addHttpProtocol.</body></methods><methods><class-id>XmlRpcDocumentation class</class-id> <category>documentation</category><body package="XmlRpcClient" selector="dataTypes">dataTypes	"The XMl-RPC spec indicates which data types can be sent to/from the server. Parameters in remote procedure calls and return types are restricted to these types. These data types and the Smalltalk types they mapped to are:XML-RPC type	-&gt; Smalltalk type&lt;int&gt;					SmallInteger&lt;boolean&gt;				true, false&lt;string&gt;				String&lt;double&gt;				Float&lt;dateTime.ios8601&gt;	Timestamp&lt;base64&gt;				ByteArray&lt;struct&gt;				Dictionary (key = member name, value = member value)&lt;array&gt;				OrderedCollectionThe mappings from Smalltalk to XML-RPC are the same except for:Smalltalk type	-&gt; XML-RPC typeInteger (including Large)	&lt;int&gt;Number					&lt;double&gt;SequenceableCollection	&lt;array&gt;Object						&lt;object&gt;	(extended type not in XML-RPC spec)nil							&lt;nil&gt;		(extended type not in XML-RPC spec)The XML-RPC spec indicates the range of &lt;int&gt; (four bytes, signed) and &lt;double&gt; (double precision). If a Smalltalk XML-RPC client/server talks to a non-Smalltalk server/client the extended range of &lt;int&gt; and &lt;double&gt; could cause problems. If this is a issue the Smalltalk client/Sever needs to restrict the values it sends.This implementation extends the XML-RPC spec by adding an Object tag. Handles only objects with instance variables and no circular references. The Object tag is experiemental. It will not work with clients/servers in other languages. If you wish to turn it off, replace the code in Object&gt;&gt;printRcpXmlOn: with self subclassResponsibility. "	self commentOnly</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream		nextPutAll: '&lt;int&gt;';		print: self;		nextPutAll: '&lt;/int&gt;'</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="XmlRpcClient" selector="addHttpProtocol">addHttpProtocol	^ (( 'http://*' match: self ) or: [ 'https://*' match: self ]) 		ifTrue: [ self ]		ifFalse: [ 'http://' , self ]</body><body package="XmlRpcClient" selector="asHttpPath">asHttpPath	| trimmed |	trimmed := self trimBlanks.	^trimmed first = $/		ifTrue:[trimmed]		ifFalse:['/' , trimmed]</body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="XmlRpcClient" selector="containsSubstring:">containsSubstring: aString	^(self 		indexOfSubCollection: aString 		startingAt: 1) &gt; 0</body><body package="XmlRpcClient" selector="isXmlRpcArray">isXmlRpcArray	^self = 'array' or: [(self copyWithout: Character space) = 'array/']</body><body package="XmlRpcClient" selector="isXmlRpcBase64">isXmlRpcBase64	^self = 'base64' or: [(self copyWithout: Character space) = 'base64/']</body><body package="XmlRpcClient" selector="isXmlRpcBoolean">isXmlRpcBoolean	^self = 'boolean' or: [(self copyWithout: Character space) = 'boolean/']</body><body package="XmlRpcClient" selector="isXmlRpcDateTime">isXmlRpcDateTime	^self = 'dateTime.iso8601' or: [(self copyWithout: Character space) = 'dateTime.iso8601/']</body><body package="XmlRpcClient" selector="isXmlRpcDouble">isXmlRpcDouble	^self = 'double' or: [(self copyWithout: Character space) = 'double/']</body><body package="XmlRpcClient" selector="isXmlRpcInt">isXmlRpcInt	^(self = 'int') | (self = 'i4') | ((self copyWithout: Character space) = 'int/')</body><body package="XmlRpcClient" selector="isXmlRpcNil">isXmlRpcNil	^self = 'nil' or: [(self copyWithout: Character space) = 'nil/']</body><body package="XmlRpcClient" selector="isXmlRpcObject">isXmlRpcObject	^self = 'object' or: [(self copyWithout: Character space) = 'object/']</body><body package="XmlRpcClient" selector="isXmlRpcString">isXmlRpcString	^self = 'string' or: [(self copyWithout: Character space) = 'string/']</body><body package="XmlRpcClient" selector="isXmlRpcStruct">isXmlRpcStruct	^self = 'struct' or: [(self copyWithout: Character space) = 'struct/']</body></methods><methods><class-id>Core.False</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream nextPutAll: '&lt;boolean&gt;0&lt;/boolean&gt;'</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="XmlRpcClient" selector="asRpcXml">asRpcXml	| aStream  |	aStream := (String new: 128) writeStream.	self printRpcXmlOn: aStream.	^aStream contents</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="XmlRpcClient" selector="isXmlRpcFault">isXmlRpcFault	^false</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	"Turn objects to XML-RPC Xml. The Object tag is experimental. To turn if off 	replace the code below with self subclassResponsibilty"	| names varData |	names := self class instVarNames.	varData := Dictionary new.	names 		keysAndValuesDo: [:index :name | varData at: name put: (self instVarAt: index)].	aStream		nextPutAll: '&lt;object&gt;&lt;class&gt;';		nextPutAll: self class name asString;		nextPutAll: '&lt;/class&gt;&lt;instanceVariables&gt;';		nextPutRpcXml: varData;		nextPutAll: '&lt;/instanceVariables&gt;&lt;/object&gt;'</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="fromBase64EncodedString:">fromBase64EncodedString: aString	"If aString is the base64 encoding of byte array X, then return X. See rfc 1521	 http://www.ietf.org/rfc/rfc1521.txt. section 5.2 for the base 64 encoding algorithm.	REW"	| input encoder stream result char |	input := aString asByteArray readStream.		encoder := (Base64StreamEncoder asEncoder) 		encoder: UnicodeCharacterEncoder new; 		yourself.	stream := EncodedStream 		on: input 		encodedBy: encoder.	result := (ByteArray new: aString size) writeStream.	[ (char := stream next) notNil ] 		whileTrue: [ result nextPut: char ].		" Convert from base64 to Unicode "	^result contents.</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="XmlRpcClient" selector="asBase64MimeEncoding">asBase64MimeEncoding	"Answer a String that is the Base64 encoding of self. See rfc 1521	 http://www.ietf.org/rfc/rfc1521.txt. Used to encode mime types	REW."	| output stream encoder |	output := (ByteArray new: self size) writeStream.	encoder := Base64StreamEncoder 		asEncoder encoder: UnicodeCharacterEncoder new; 		yourself.	stream := EncodedStream 		on: output 		encodedBy: encoder.	" Unicode bytes-&gt;base64 encoder "	stream nextPutAll: self.		stream close.						" This is needed to flush byte buffer "	^output contents asString</body></methods><methods><class-id>Core.ByteArray</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	"RPC XML Strings can not contain $&lt; &amp; $&amp;"	aStream		nextPutAll: '&lt;base64&gt;';		nextPutAll: self asBase64MimeEncoding;		nextPutAll: '&lt;/base64&gt;'</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream		nextPutAll: '&lt;array&gt;&lt;data&gt;';		cr.	self do: 			[:each | 			aStream				tab;				nextPutAll: '&lt;value&gt;';				nextPutRpcXml: each;				nextPutAll: '&lt;/value&gt;';				cr].	aStream nextPutAll: '&lt;/data&gt;&lt;/array&gt;'</body></methods><methods><class-id>Core.Double</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	"No exponents allowed in rpc xml representation of floats"	| integerPart fractionalPart fraction sign |	integerPart := self integerPart asInteger abs printString.	fractionalPart := self fractionPart abs printString.	sign := self &lt; 0 ifTrue: ['-'] ifFalse: [''].	"remove leading 0 in 0.1233d"	fraction := fractionalPart copyFrom: 2 to: fractionalPart size - 1.	aStream		nextPutAll: '&lt;double&gt;';		nextPutAll: sign;		nextPutAll: integerPart;		nextPutAll: fraction;		nextPutAll: '&lt;/double&gt;'</body></methods><methods><class-id>Core.Number</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	^self asDouble printRpcXmlOn: aStream</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream		nextPutAll: '&lt;struct&gt;';		cr.	self keysAndValuesDo: 			[:key :value | 			aStream				tab;				nextPutAll: '&lt;member&gt;';				nextPutAll: '&lt;name&gt;';				nextPutAll: key;				nextPutAll: '&lt;/name&gt;';				nextPutAll: '&lt;value&gt;';				nextPutAll: value asRpcXml;				nextPutAll: '&lt;/value&gt;&lt;/member&gt;';				cr].	aStream nextPutAll: '&lt;/struct&gt;'</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream nextPutAll: '&lt;dateTime.iso8601&gt;'.	TimestampPrintPolicy 		print: self		on: aStream		using: 'yyyymmddThh:mm:ss'.	aStream nextPutAll: '&lt;/dateTime.iso8601&gt;'</body></methods><methods><class-id>Core.Behavior</class-id> <category>instance creation</category><body package="XmlRpcClient" selector="xmlRpcNew:">xmlRpcNew: aDictionary	"Answer a new instance of the receiver instance variables initialized with values in the 	dictionary. Keys are the names of the variables. "	| object names |	object := self new.	names := self  instVarNames.	names keysAndValuesDo: 		[:index :name | 		object 			instVarAt: index			put: (aDictionary at: name ifAbsent: [nil])].	^object</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream nextPutAll: '&lt;nil&gt;&lt;/nil&gt;'</body></methods><methods><class-id>Core.WriteStream</class-id> <category>accessing</category><body package="XmlRpcClient" selector="nextPutRpcXml:">nextPutRpcXml: anObject 	anObject printRpcXmlOn: self</body></methods><methods><class-id>Core.Float</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	"No exponents allowed in rpc xml representation of floats"	| integerPart fractionalPart fraction sign |	integerPart := self integerPart asInteger abs printString.	fractionalPart := self fractionPart abs printString.	sign := self &lt; 0 ifTrue: ['-'] ifFalse: [''].	"remove leading 0 in 0.1233"	fraction := fractionalPart copyFrom: 2 to: fractionalPart size.	aStream		nextPutAll: '&lt;double&gt;';		nextPutAll: sign;		nextPutAll: integerPart;		nextPutAll: fraction;		nextPutAll: '&lt;/double&gt;'</body></methods><methods><class-id>Core.True</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	aStream nextPutAll: '&lt;boolean&gt;1&lt;/boolean&gt;'</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="XmlRpcClient" selector="asInteger">asInteger 	"Answer the number created by interpreting the receiver as the string	representation of a number.  First remove any leading seperators."	| stream |	stream := self string readStream.	stream skipSeparators.	^Integer  readFrom: stream</body><body package="XmlRpcClient" selector="decodeBase64">decodeBase64	"If self is the base64 mime encoding of byte array X, then return X. See rfc 1521	 http://www.ietf.org/rfc/rfc1521.txt. section 5.2 for the base 64 encoding algorithm"	^ByteArray fromBase64EncodedString: self</body><body package="XmlRpcClient" selector="decodeRpcXml">decodeRpcXml	"Three pass in worst case. If find is slow and/or have time reduce to single pass"	| decoded encoded entity |	(self includes: $;) ifFalse: [^self].	decoded := WriteStream on: (String new: self size).	encoded := ReadStream on: self.	decoded nextPutAll: (encoded upTo: $&amp;).	[encoded atEnd] whileFalse: 			[entity := encoded upTo: $;.			decoded 				nextPutAll: (XmlRpcParser entityAt: entity ifAbsent: ['&amp;' , entity, ';']).			decoded nextPutAll: (encoded upTo: $&amp;)].	^decoded contents</body><body package="XmlRpcClient" selector="dropSeparators">dropSeparators	"Return a copy of the receiver with all whitespace removed"	" 'a b	c d   ' dropSeparators"	^self select: [:c | c isSeparator not]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>printing</category><body package="XmlRpcClient" selector="printRpcXmlOn:">printRpcXmlOn: aStream 	"RPC XML Strings can not contain $&lt; &amp; $&amp;"	aStream nextPutAll: '&lt;string&gt;'.	self do: 			[:each | 			each = $&lt; 				ifTrue: [aStream nextPutAll: '&amp;lt;']				ifFalse: 					[each = $&amp; 						ifTrue: [aStream nextPutAll: '&amp;amp;']						ifFalse: 							[each = $&gt;								ifTrue: [aStream nextPutAll: '&amp;gt;']								ifFalse: [aStream nextPut: each]]]].	aStream nextPutAll: '&lt;/string&gt;'</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="XmlRpcClient" selector="trimSeparators">trimSeparators	"return a copy of the reciever without any spaces 	on front or back. Protect against all blanks"	| start stop |	start := 1.	stop := self size.		[start &gt; stop ifTrue: [^''].	(self at: start) isSeparator] 			whileTrue: [start := start + 1].	[(self at: stop) isSeparator] whileTrue: [stop := stop - 1].	^self copyFrom: start to: stop</body></methods><initialize><class-id>XmlRpcParser</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>HttpRequest</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>True</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>Magnitude-General</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>