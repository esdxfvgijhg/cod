<?xml version="1.0"?><st-source><!-- Name: WeaklingsNotice: Copyright 2003 - 2013 Travis GriggsThis utility is free to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This package provides a simple weak slot wrapper mechanism for objects. It implements both a simple value'able wrapper (Weakling) and full blown weak proxy (WeakProxy). You can send asWeakling or asWeakProxy to get instances.Weaklings respond to value/value:. They are handy for  wrapping an inst var, so that the containing object will not keep it around. The containing object must take care to deal with the case when the ivar does indeed go to nil.WeakProxy is a bit more ambitous as it obviates the client from having to send #value to the ivar everytime, using a DNU to forward the message. Care still has to be taken though, for at some point, those messages may start answering nil.- - Weaklings was written by Travis Griggs while at Key Technology and maintained by the same while at Cincom.DbIdentifier: bear73DbTrace: 401645DbUsername: tgriggsDbVersion: 19PackageName: WeaklingsParcel: #('Weaklings')ParcelName: WeaklingsPrintStringCache: (19,tgriggs)Version: 19Date: 10:18:36 AM April 10, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.1) of April 10, 2013 on April 10, 2013 at 10:18:36 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Weaklings</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Weaklings</category><attributes><package>Weaklings</package></attributes></name-space><class><name>WeakProxy</name><environment>Weaklings</environment><super></super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>slot lastRites </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Weaklings</category><attributes><package>Weaklings</package></attributes></class><comment><class-id>Weaklings.WeakProxy</class-id><body>This is an ambitious alternative to the Weakling sibling. Rather than wrap an object with an object that you have to use value/setValue: to get at the real value, I simply act as a proxy for him. I use doesNotUnderstand: to forward all messages I receive to my 'inner' object, the object you wanted as weak. I do the lastRites: directly myself, since we want to have very minimal API on myself.Instance Variables:	lastRites	&lt;nil | BlockClosure&gt;	optional one arg block that is evaluated when I am finalized allowing the programmer to add hooks for what happens when my value goes away	slot	&lt;Object&gt;	the object being proxied</body></comment><class><name>Weakling</name><environment>Weaklings</environment><super>Core.Object</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Weaklings</category><attributes><package>Weaklings</package></attributes></class><comment><class-id>Weaklings.Weakling</class-id><body>I am simple object wrapper for holding something weakly. I use value/setValue: interface to update my value. Unlike a normal object holding mechanism though, if I (and objects like me) are the only references to my value, I will not cause the value to be retained, but will rather set my value to nil and allow the GC to get rid of the value. I provide no finalization hook myself, but my subclass MournfulWeakling does. You can use the lastRites: API to turn me into one of those.Instance Variables:	value	&lt;Object&gt;	the object I reference weakly</body></comment><class><name>MournfulWeakling</name><environment>Weaklings</environment><super>Weaklings.Weakling</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>lastRites </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Weaklings</category><attributes><package>Weaklings</package></attributes></class><comment><class-id>Weaklings.MournfulWeakling</class-id><body>I am a specialization of my super that provides a hook for finalization behavior. A one arg block is attached to the reciever in such a way that when my value no longer has strong references, it is evaluated with my value as its argument. You can create one by sending lastRites: to my superclass, or just sending the same to any normal object. Consider the example:| array weakly |array := Array with: Object new.weakly := array first withLastRites: [:obj | Transcript print: 'Goodbye from ' , obj identityHash printString; cr ;endEntry].array at: 1 put: Object new.ObjectMemory globalGarbageCollect	The one thing of note is that we must store weakling in a local temp, otherwise the GC will collect it before it worries about what it references.Instance Variables:	lastRites	&lt;BlockClosure&gt;	a one arg block which is executed with the value of when the receiver is being finalized.</body></comment><methods><class-id>Weaklings.WeakProxy</class-id> <category>methods</category><body package="Weaklings">doesNotUnderstand: aMessage 	^slot perform: aMessage selector withArguments: aMessage arguments</body><body package="Weaklings">mourn	lastRites == nil ifFalse: [lastRites value: slot].	slot := nil</body><body package="Weaklings">printOn: aStream 	aStream		nextPut: $(;		print: slot;		nextPutAll: ') weakProxy'</body><body package="Weaklings">printString	| ws |	ws := String new writeStream.	self printOn: ws.	^ws contents</body></methods><methods><class-id>Weaklings.Weakling</class-id> <category>finalization</category><body package="Weaklings">mourn	value := nil</body></methods><methods><class-id>Weaklings.Weakling</class-id> <category>accessing</category><body package="Weaklings">hasLastRites	^false</body><body package="Weaklings">lastRites: aSingleArgBlock 	| mournful |	mournful := value withLastRites: aSingleArgBlock.	^self become: mournful</body><body package="Weaklings">setValue: anObject	value := anObject</body><body package="Weaklings">value	^value</body></methods><methods><class-id>Weaklings.Weakling</class-id> <category>printing</category><body package="Weaklings">printOn: aStream 	aStream		nextPut: $(;		print: value;		nextPutAll: ') weakly'</body></methods><methods><class-id>Weaklings.MournfulWeakling</class-id> <category>accessing</category><body package="Weaklings">hasLastRites	^true</body><body package="Weaklings">lastRites: aSingleArgBlock	lastRites := aSingleArgBlock</body></methods><methods><class-id>Weaklings.MournfulWeakling</class-id> <category>finalization</category><body package="Weaklings">mourn	lastRites value: value.	^super mourn</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Weaklings">asWeakling	^Weaklings.Weakling new setValue: self</body><body package="Weaklings">asWeakProxy	^self weakProxyWithLastRites: nil</body></methods><methods><class-id>Core.Object</class-id> <category>finalization</category><body package="Weaklings">isActiveEphemeron	"Answer if the receiver is active; i.e. answer if it has	 not been triggered and placed in the finalization queue."	&lt;primitive: 466&gt;	^self primitiveFailed</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Weaklings">weakProxyWithLastRites: aSingleArgBlock	^(Array with: self with: aSingleArgBlock) changeClassTo: Weaklings.WeakProxy</body><body package="Weaklings">withLastRites: aOneArgBlock 	^(Weaklings.MournfulWeakling new)		setValue: self;		lastRites: aOneArgBlock</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>