<?xml version="1.0"?><st-source><!-- Name: TetrisDbIdentifier: bear73DbTrace: 28447PackageName: TetrisParcel: #('Tetris')ParcelName: TetrisPrintStringCache: (7.1 - 1.0,kgreek)Version: 7.1 - 1.0WarningSuppressionBlock: [ :prerequisiteName |  true]Post-Load Block: 	[ :pkg |  TetrisGame open]Warning Suppression Block: 	[ :prerequisiteName |  true]Date: 9:37:04 AM September 25, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (sep09.4) of September 25, 2009 on September 25, 2009 at 9:37:04 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TetrisPiece</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin squares center </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece</class-id><body></body></comment><class><name>TetrisPiece2</name><environment>Smalltalk</environment><super>TetrisPiece</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece2</class-id><body></body></comment><class><name>TetrisFloorView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thePiece </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris Windows</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisFloorView</class-id><body>I am the little area under the main Tetris window that shows where each piece would be if itdropped as it is displayed right now.</body></comment><class><name>TetrisPiece6</name><environment>Smalltalk</environment><super>TetrisPiece</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece6</class-id><body></body></comment><class><name>TetrisRules</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisRules</class-id><body></body></comment><class><name>TetrisPiece7</name><environment>Smalltalk</environment><super>TetrisPiece</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece7</class-id><body></body></comment><class><name>TetrisHiScoreTable</name><environment>Smalltalk</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>theTable score rows hiScoreTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris Windows</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisHiScoreTable</class-id><body></body></comment><class><name>TetrisDroppedPieces</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>theArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisDroppedPieces</class-id><body></body></comment><class><name>TetrisPiece4</name><environment>Smalltalk</environment><super>TetrisPiece</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece4</class-id><body></body></comment><class><name>TetrisGame</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pluginConnection tetrisView piecePreviewView floorView scoreBuffer rowsBuffer levelBuffer pc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris Windows</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisGame</class-id><body>I am the top level UI class in the Tetris Game.File this into a VW 2.0 or 2.5 image.Press F1 to get the list of valid keys.To start a game, evaluate:  '  TetrisGame new open  '</body></comment><class><name>TetrisSquare</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>point color pixmap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisSquare</class-id><body></body></comment><class><name>TetrisPiece3</name><environment>Smalltalk</environment><super>TetrisPiece</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece3</class-id><body></body></comment><class><name>TetrisPiece5</name><environment>Smalltalk</environment><super>TetrisPiece</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece5</class-id><body></body></comment><class><name>TetrisModel</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pieceCreator startingLevel currentPiece floorView droppedPieces keyPresses score rows levels timer trigger </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris Windows</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisModel</class-id><body>I am the Model for the Tetris game.  Most of the functionality is done here.</body></comment><class><name>TetrisPiece1</name><environment>Smalltalk</environment><super>TetrisPiece</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiece1</class-id><body></body></comment><class><name>TetrisView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prevExtent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris Windows</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisView</class-id><body>I am the view upon which the Tetris game displays its squares.</body></comment><class><name>TetrisPiecePreviewView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thePiece </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris Windows</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPiecePreviewView</class-id><body>I am the window that shows the picture of the next piece that will drop.</body></comment><class><name>TetrisPieceCreator</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random nextPiece </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisPieceCreator</class-id><body></body></comment><class><name>TetrisController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisEventTime lastEventTime thisEvent lastEvent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tetris Windows</category><attributes><package>Tetris</package></attributes></class><comment><class-id>TetrisController</class-id><body>I am the controller for the TetrisModel and TetrisView classes.</body></comment><methods><class-id>TetrisPiece</class-id> <category>test for movement</category><body package="Tetris" selector="canDropOneOn:">canDropOneOn: aDroppedPieces	"Return false if moving any square down by one will place it outside the bounds or overwrite any dropped piece."	self squares do: [ :aSquare |		(aSquare canDropBy: 1 in: aDroppedPieces)			ifFalse: [ ^false ] ].	^true</body><body package="Tetris" selector="canMoveLeftOn:">canMoveLeftOn: aDroppedPieces	"Return false if moving any square to the left will place it outside the bounds or overwrite any dropped piece."	self squares do: [ :aSquare |		aSquare col = 1 ifTrue: [ ^false ].		( aDroppedPieces canAccommodateCol: (aSquare col - 1) row: (aSquare row)) ifFalse: [ ^false ] ].	^true</body><body package="Tetris" selector="canMoveRightOn:">canMoveRightOn: aDroppedPieces	"Return false if any square is currently in column 1; true otherwise."	self squares do: [ :aSquare |		aSquare col &gt;= TetrisRules columns ifTrue: [ ^false ].		(aDroppedPieces canAccommodateCol: (aSquare col + 1) row: (aSquare row)) ifFalse: [ ^false ] ].	^true</body><body package="Tetris" selector="canPlaceAtRow:onDroppedPieces:">canPlaceAtRow: anInteger onDroppedPieces: aDroppedPieces 	"This is asked each time a new piece is created. It examines the board	 to see if there is room for this piece at row &lt;anInteger&gt;. Answer false	 if the dropped pieces are occupying that area of the board."	self squares do:		[:aSquare |		(aDroppedPieces				canAccommodateCol: aSquare col				row: aSquare row + anInteger - 1)			ifFalse:				[^false]].	^true</body><body package="Tetris" selector="canRotate">canRotate	^true</body><body package="Tetris" selector="canRotateOn:">canRotateOn: aDroppedPieces	"Return false if rotating will overwrite any existing square or push outside the bounds; true otherwise."	self squares do: [ :each | | copiedSquare |		copiedSquare := each copy.		copiedSquare rotateAround: self center.		copiedSquare row &lt; 1 ifTrue: [ ^false ].		copiedSquare row &gt; TetrisRules rows ifTrue: [ ^false ].		copiedSquare col &lt; 1 ifTrue: [ ^false ].		copiedSquare col &gt; TetrisRules columns ifTrue: [ ^false ].		(aDroppedPieces canAccommodateCol: (copiedSquare col) row: (copiedSquare row) ) ifFalse: [ ^false ]. ].	^true</body><body package="Tetris" selector="rowsICanDropOn:">rowsICanDropOn: aDroppedPieces	"Return the number of rows that this piece can drop and not overwrite a filled square."	1 to: TetrisRules rows do: [ :aRow |		self squares do: [ :aSquare |			(aSquare canDropBy: aRow in: aDroppedPieces)				ifFalse: [ ^aRow - 1 ] ] ]</body></methods><methods><class-id>TetrisPiece</class-id> <category>drawing</category><body package="Tetris" selector="drawOn:">drawOn: aView	self squares do: [ :aSquare |		aSquare drawOn: aView ].	aView model floorView blackenBackground.	self squares do: [ :aSquare |		aSquare drawFlatOn: aView model floorView ]</body><body package="Tetris" selector="eraseOn:">eraseOn: aView	self squares do: [ :aSquare |		aSquare eraseOn: aView ].</body><body package="Tetris" selector="resize">resize	self squares do: [ :aSquare |		aSquare invalidate ].</body></methods><methods><class-id>TetrisPiece</class-id> <category>movement</category><body package="Tetris" selector="dropOn:">dropOn: aDroppedPieces	| rowsToDrop |	rowsToDrop := self rowsICanDropOn: aDroppedPieces.	self squares do: [ :aSquare |		aSquare row: (aSquare row + rowsToDrop).		aDroppedPieces add: aSquare ].	^rowsToDrop</body><body package="Tetris" selector="dropOne">dropOne	self origin: (self origin x) @ (self origin y + 1).	self squares do: [ :each | each row: (each row + 1) ]</body><body package="Tetris" selector="moveLeft">moveLeft	self origin: (self origin x) @ (self origin y - 1).	self squares do: [ :each | each col: (each col - 1) ]</body><body package="Tetris" selector="moveRight">moveRight	self origin: (self origin x + 1) @ (self origin y).	self squares do: [ :each | each col: (each col + 1) ]</body><body package="Tetris" selector="rotate">rotate	self squares do: [ :each | each rotateAround: self center ]</body></methods><methods><class-id>TetrisPiece</class-id> <category>initialize-release</category><body package="Tetris" selector="initialize">initialize	self origin: ((TetrisRules columns // 2) - 1) @ 1.	self squares: (OrderedCollection new: 4).	self points do: [ :each |		squares add: (TetrisSquare coordinates: each					color: self color) ].	self squares do: [ :aSquare |		aSquare col: (aSquare col + (TetrisRules columns * 0.4) asInteger ).		aSquare row: (aSquare row + 1) ].</body><body package="Tetris" selector="invalidate">invalidate	self squares do: [ :aSquare | aSquare invalidate ].</body></methods><methods><class-id>TetrisPiece</class-id> <category>squares</category><body package="Tetris" selector="leftmostSquare">leftmostSquare	| sq |	sq := squares first.	self squares do: [ :aSquare |		aSquare col &lt; sq col			ifTrue: [ sq := aSquare ] ].	^sq</body><body package="Tetris" selector="topmostSquare">topmostSquare	| sq |	sq := squares first.	self squares do: [ :aSquare |		aSquare col &lt; sq row			ifTrue: [ sq := aSquare ] ].	^sq</body></methods><methods><class-id>TetrisPiece</class-id> <category>accessor</category><body package="Tetris" selector="origin">origin	^origin</body><body package="Tetris" selector="origin:">origin: aPoint	origin := aPoint</body><body package="Tetris" selector="squares">squares	^squares</body><body package="Tetris" selector="squares:">squares: aCollection	squares := aCollection</body></methods><methods><class-id>TetrisPiece class</class-id> <category>pieces</category><body package="Tetris" selector="pieces">pieces	^self subclasses</body></methods><methods><class-id>TetrisPiece2</class-id> <category>directions</category><body package="Tetris" selector="center">center	^(self squares at: 2) point</body><body package="Tetris" selector="points">points	^Array with: 1@0 with: 2@0 with: 3@0 with: 2@1</body></methods><methods><class-id>TetrisPiece2</class-id> <category>constants</category><body package="Tetris" selector="color">color	^ColorValue gray</body></methods><methods><class-id>TetrisFloorView</class-id> <category>drawing</category><body package="Tetris" selector="blackenBackground">blackenBackground	| rect |	rect := self bounds.	rect displayFilledOn: self graphicsContext</body><body package="Tetris" selector="rectangleOfBlock:">rectangleOfBlock: aPoint 	^Rectangle		origin: aPoint x - 1 * self sizeOfSquare x @ (aPoint y - 1)		extent: self sizeOfSquare x @ self bounds height</body><body package="Tetris" selector="sizeOfSquare">sizeOfSquare	^((self bounds width / TetrisRules columns ) asInteger) @ (self bounds height )</body></methods><methods><class-id>TetrisPiece6</class-id> <category>directions</category><body package="Tetris" selector="center">center	^(self squares at: 2) point</body><body package="Tetris" selector="points">points	^Array with: 1@0 with: 2@0 with: 3@0 with: 3@1</body></methods><methods><class-id>TetrisPiece6</class-id> <category>constants</category><body package="Tetris" selector="color">color	^ColorValue purple</body></methods><methods><class-id>TetrisRules class</class-id> <category>sizes</category><body package="Tetris" selector="columns">columns	^10</body><body package="Tetris" selector="rows">rows	^20</body></methods><methods><class-id>TetrisRules class</class-id> <category>text</category><body package="Tetris" selector="copyrightMessage">copyrightMessage	^'Copyright 2001-1996 by Thomas Sattler\email: tom@sattler.com' withCRs .</body></methods><methods><class-id>TetrisRules class</class-id> <category>scoring</category><body package="Tetris" selector="entriesInHiScoreTable">entriesInHiScoreTable	^20</body><body package="Tetris" selector="extraPointsForEachRowOnADrop">extraPointsForEachRowOnADrop	^1</body><body package="Tetris" selector="pointsForClearingOneRow">pointsForClearingOneRow	^100</body><body package="Tetris" selector="pointsForDroppingOnePieceZeroRows">pointsForDroppingOnePieceZeroRows	^30</body><body package="Tetris" selector="pointsLostForPressingAnArrowKey">pointsLostForPressingAnArrowKey	^1</body></methods><methods><class-id>TetrisRules class</class-id> <category>levels</category><body package="Tetris" selector="levelCollection">levelCollection	^#( 11 17 25 35 37)</body><body package="Tetris" selector="startingLevel">startingLevel	^1</body><body package="Tetris" selector="subsequentLevelChange">subsequentLevelChange	^14</body></methods><methods><class-id>TetrisRules class</class-id> <category>timings</category><body package="Tetris" selector="millisecondsAtLevelZero">millisecondsAtLevelZero	^750</body><body package="Tetris" selector="percentageAtEachLevel">percentageAtEachLevel	^0.8</body></methods><methods><class-id>TetrisRules class</class-id> <category>flashing</category><body package="Tetris" selector="millisecondsToPauseDuringFlash">millisecondsToPauseDuringFlash	^250</body></methods><methods><class-id>TetrisPiece7</class-id> <category>directions</category><body package="Tetris" selector="canRotate">canRotate	^false</body><body package="Tetris" selector="center">center	^(self squares at: 1) point</body><body package="Tetris" selector="points">points	^Array with: 1@0 with: 2@1 with: 2@0 with: 1@1</body></methods><methods><class-id>TetrisPiece7</class-id> <category>constants</category><body package="Tetris" selector="color">color	^ColorValue cyan</body><body package="Tetris" selector="rotateAround:">rotateAround: aPoint	"Special case - this square does not need to rotate."	^self</body></methods><methods><class-id>TetrisHiScoreTable</class-id> <category>read</category><body package="Tetris" selector="addToHiScoreTable:">addToHiScoreTable: aName	"Create an array and add it to the table."	score value at: 3 put: aName.	hiScoreTable add: score.	hiScoreTable size &gt; TetrisRules entriesInHiScoreTable ifTrue:		[ hiScoreTable removeAtIndex: (TetrisRules entriesInHiScoreTable + 1) ].</body><body package="Tetris" selector="belongsInHiScoreTable">belongsInHiScoreTable	"Answer if the recent game is high enough to qualify for the hiscore table."	hiScoreTable size &lt; TetrisRules entriesInHiScoreTable ifTrue: [ ^true ].	^score key &gt; hiScoreTable last key</body><body package="Tetris" selector="buildHiScoreWidget">buildHiScoreWidget	| list index |	list := TwoDList columns: 4 rows: (hiScoreTable size + 1).	list at: 1 put: 'Score'; at: 2 put: 'Name'; at: 3 put: 'Date'; at: 4 put: 'Rows'.	1 to: hiScoreTable size do: [ :ix |		list at: (ix * 4 + 1) put: (hiScoreTable at: ix) key.		list at: (ix * 4 + 2) put: ((hiScoreTable at: ix) value at: 3).		list at: (ix * 4 + 3) put: ((hiScoreTable at: ix) value at: 2).		list at: (ix * 4 + 4) put: ((hiScoreTable at: ix) value at: 1) ].	self theTable selectionInTable tableHolder value: list.	(index := hiScoreTable indexOf: score) ~= 0 ifTrue:		[self theTable selectionInTable selectionIndex: 1@(index + 1)].	score := nil.	^list</body><body package="Tetris" selector="createHiScoreTable">createHiScoreTable	| dataObject dataStream bos |	dataObject := Dictionary new.	dataStream := 'tetris.hi' asFilename writeStream.	bos := self binaryObjectStorage onNew: dataStream.	[bos nextPut: dataObject]		ensure: [bos close]</body><body package="Tetris" selector="displayHiScoreTable">displayHiScoreTable	self readHiScoreTable.	self buildHiScoreWidget.	self showHiScoreTable.</body><body package="Tetris" selector="handleHiScoreTable">handleHiScoreTable	| myName  |	self readHiScoreTable.	self belongsInHiScoreTable ifTrue:		[ myName := Dialog						request: 'What is your name?'						initialAnswer: (hiScoreTable isEmpty										ifTrue: ['Tom Sattler']										ifFalse: [hiScoreTable first value last])						for: Dialog defaultParentWindow.		myName size &lt;= 0 ifTrue: [^self].		self addToHiScoreTable: myName.		self saveHiScoreTable ].	self buildHiScoreWidget.	self showHiScoreTable.</body><body package="Tetris" selector="readHiScoreTable">readHiScoreTable	"Read the file contents, initialize if not there."	| hiscoreFile bos  savedObject |	hiscoreFile := 'tetris.hi' asFilename.	hiscoreFile exists ifFalse:		[^hiScoreTable := SortedCollection sortBlock: [ :a :b | a key &gt; b key]].	bos := self binaryObjectStorage				onOldNoScan: hiscoreFile readStream.	[savedObject := bos contents]		ensure: [bos close].	hiScoreTable := savedObject at: 1</body><body package="Tetris" selector="saveHiScoreTable">saveHiScoreTable	"Write the hi score table back to disk."	|  dataStream bos |	dataStream := 'tetris.hi' asFilename writeStream.	bos := self binaryObjectStorage onNew: dataStream.	[bos nextPut: hiScoreTable]		ensure: [bos close]</body><body package="Tetris" selector="showHiScoreTable">showHiScoreTable	"Display the contents of the hi score list in a table on a dialog box."	self open.</body></methods><methods><class-id>TetrisHiScoreTable</class-id> <category>private</category><body package="Tetris" selector="binaryObjectStorage">binaryObjectStorage	^#{BinaryObjectStorage} valueIfUndefinedLoadFrom: 'BOSS'</body></methods><methods><class-id>TetrisHiScoreTable</class-id> <category>opening</category><body package="Tetris" selector="openAddingScore:rows:">openAddingScore: scoreInteger rows: rowsValueHolder	score := scoreInteger -&gt; (Array with: rowsValueHolder value with: Date today with: nil).	self handleHiScoreTable.</body><body package="Tetris" selector="postBuildWith:">postBuildWith: aBuilder       (aBuilder componentAt: #theTable) widget		showRGrid: true;		showCGrid: true;		formats: #(#right #left #left #right);		setColumnWidths: #(40 120 110 35).</body></methods><methods><class-id>TetrisHiScoreTable</class-id> <category>aspects</category><body package="Tetris" selector="theTable">theTable	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^theTable isNil		ifTrue:			[theTable := TableInterface new selectionInTable: SelectionInTable new]		ifFalse:			[theTable]</body></methods><methods><class-id>TetrisDroppedPieces</class-id> <category>adding - removing</category><body package="Tetris" selector="add:">add: aSquare	(theArray at: (aSquare point y)) at: (aSquare point x) put: aSquare</body><body package="Tetris" selector="pieceAtRow:column:">pieceAtRow: aRow column: aCol	^(self theArray at: aRow) at: aCol</body><body package="Tetris" selector="putNilAtRow:column:">putNilAtRow: aRow column: aCol	(self theArray at: aRow) at: aCol put: nil</body><body package="Tetris" selector="removeRow:">removeRow: rowNumber 	rowNumber to: 2 by: -1 do:		[:aRowNumber |		1 to: TetrisRules columns do:			[:aColumnNumber | | piece |			piece := self pieceAtRow: aRowNumber - 1 column: aColumnNumber.			piece isNil				ifFalse: 					[piece point y: aRowNumber.					 self add: piece]				ifTrue: [self putNilAtRow: aRowNumber column: aColumnNumber].			self putNilAtRow: aRowNumber - 1 column: aColumnNumber]]</body></methods><methods><class-id>TetrisDroppedPieces</class-id> <category>testing</category><body package="Tetris" selector="canAccommodateCol:row:">canAccommodateCol: aCol row: aRow	aRow &gt; TetrisRules rows ifTrue: [^false].	^(self pieceAtRow: aRow column: aCol) isNil</body><body package="Tetris" selector="filledRows">filledRows	| oc |	oc := OrderedCollection new.	1 to: TetrisRules rows do: [ :aRowNumber |		(self isFull: aRowNumber) ifTrue:			 [ oc add: aRowNumber] ].	^oc</body></methods><methods><class-id>TetrisDroppedPieces</class-id> <category>rows</category><body package="Tetris" selector="deleteAllFilledRows">deleteAllFilledRows	| rowsRemoved |	rowsRemoved := 0.	1 to: TetrisRules rows do: [ :aRowNumber |		(self isFull: aRowNumber) ifTrue:			 [ self removeRow: aRowNumber.			rowsRemoved := rowsRemoved + 1 ] ].	^rowsRemoved</body><body package="Tetris" selector="isEmpty:">isEmpty: aRowNumber	(self theArray at: aRowNumber) do: [ :aSquare |		aSquare isNil ifFalse: [ ^false ] ].	^true</body><body package="Tetris" selector="isFull:">isFull: aRowNumber	(self theArray at: aRowNumber) do: [ :aSquare |		aSquare isNil ifTrue: [ ^false ] ].	^true</body><body package="Tetris" selector="piecesInRow:">piecesInRow: rowNumber 	| oc |	oc := OrderedCollection new: TetrisRules columns.	1 to: TetrisRules columns do:		[:aColumnNumber | | piece |		piece := self pieceAtRow: rowNumber column: aColumnNumber.		oc addLast: piece].	^oc</body></methods><methods><class-id>TetrisDroppedPieces</class-id> <category>initialize - release</category><body package="Tetris" selector="initialize">initialize	theArray := Array new: TetrisRules rows .	1 to: (TetrisRules rows) do: [ :ix |		theArray at: ix put: (Array new: TetrisRules columns ) ].</body></methods><methods><class-id>TetrisDroppedPieces</class-id> <category>resizing</category><body package="Tetris" selector="resizeAll">resizeAll	1 to: TetrisRules rows do: [ :aRow |		1 to: TetrisRules columns do: [ :aCol |			(self pieceAtRow: aRow column: aCol) isNil				ifFalse: [ (self pieceAtRow: aRow column: aCol) invalidate ] ] ]</body></methods><methods><class-id>TetrisDroppedPieces</class-id> <category>accessor</category><body package="Tetris" selector="theArray">theArray	^theArray</body></methods><methods><class-id>TetrisPiece4</class-id> <category>directions</category><body package="Tetris" selector="center">center	^(self squares at: 2) point</body><body package="Tetris" selector="points">points	^Array with: 1@0 with: 2@0 with: 3@0 with: 1@1</body></methods><methods><class-id>TetrisPiece4</class-id> <category>constants</category><body package="Tetris" selector="color">color	^ColorValue yellow</body></methods><methods><class-id>TetrisGame</class-id> <category>title bar</category><body package="Tetris" selector="addPausedToTitleBar">addPausedToTitleBar	self label: (self tetrisLabel, ' (Paused)')</body><body package="Tetris" selector="removePausedFromTitleBar">removePausedFromTitleBar	self label: self tetrisLabel</body></methods><methods><class-id>TetrisGame</class-id> <category>change messages</category><body package="Tetris" selector="changeRequest">changeRequest	self tetrisView model timer terminate .	^true</body><body package="Tetris" selector="changedLevels">changedLevels	self levelBuffer value: self tetrisView model levels value printString.</body><body package="Tetris" selector="changedRows">changedRows	self rowsBuffer value: self tetrisView model rows value printString.</body><body package="Tetris" selector="changedScore">changedScore	self scoreBuffer value: self tetrisView model scoreIncludingRows printString.</body><body package="Tetris" selector="nextPieceChanged">nextPieceChanged	"The value of the next piece has changed.  Display it."	piecePreviewView drawUsing: pc value.</body></methods><methods><class-id>TetrisGame</class-id> <category>aspects</category><body package="Tetris" selector="floorView">floorView	^floorView</body><body package="Tetris" selector="levelBuffer">levelBuffer	^levelBuffer isNil		ifTrue: [levelBuffer := String new asValue]		ifFalse: [levelBuffer]</body><body package="Tetris" selector="piecePreviewView">piecePreviewView	^piecePreviewView</body><body package="Tetris" selector="rowsBuffer">rowsBuffer	^rowsBuffer isNil		ifTrue: [rowsBuffer := String new asValue]		ifFalse: [rowsBuffer]</body><body package="Tetris" selector="scoreBuffer">scoreBuffer	^scoreBuffer isNil		ifTrue: [scoreBuffer := String new asValue]		ifFalse: [scoreBuffer]</body><body package="Tetris" selector="tetrisView">tetrisView	^tetrisView</body></methods><methods><class-id>TetrisGame</class-id> <category>initialize-release</category><body package="Tetris" selector="initialize">initialize	| newModel |	tetrisView := TetrisView new.	piecePreviewView := TetrisPiecePreviewView new.	floorView := TetrisFloorView new.	newModel := TetrisModel new initialize.	newModel floorView: self floorView.	tetrisView model: newModel.	newModel score onChangeSend: #changedScore to: self.	newModel rows onChangeSend: #changedRows to: self.	newModel levels onChangeSend: #changedLevels to: self.	pc := tetrisView model pieceCreator nextPiece.	pc onChangeSend: #nextPieceChanged to: self</body></methods><methods><class-id>TetrisGame</class-id> <category>plug-in testing</category><body package="Tetris" selector="isAppletModel">isAppletModel	"Answer true if this is an AppletModel"	^true</body></methods><methods><class-id>TetrisGame</class-id> <category>plug-in spi</category><body package="Tetris" selector="pluginConnection">pluginConnection	"Answer the current InternetBrowserConnection used for communicating with	the plug-in by this application"	^#{VWPlugin.InternetBrowserConnection} ifDefinedDo: [:ibc| ibc current]</body><body package="Tetris" selector="pluginConnection:">pluginConnection: anInternetBrowserConnection	"Set the current InternetBrowserConnection used for communicating with	the plug-in by this application"	^self</body></methods><methods><class-id>TetrisGame</class-id> <category>opening</category><body package="Tetris" selector="postOpenWith:">postOpenWith: aBuilder	"Install the keyboard handler and force double buffering off."	super postOpenWith: aBuilder .	aBuilder window icon: ( Icon new image: self class myIcon  ).	aBuilder window keyboardProcessor keyboardHook: 				 [ :kbEvent :c | self tetrisView controller processKeyboardEvent: kbEvent ] .	aBuilder window damageRepairPolicy: WindowDisplayPolicy new</body></methods><methods><class-id>TetrisGame class</class-id> <category>parcel actions</category><body package="Tetris" selector="postLoadActionFor:">postLoadActionFor: aParcel	"Have something to use for postLoad processing"	self open.</body></methods><methods><class-id>TetrisSquare</class-id> <category>test for movement</category><body package="Tetris" selector="canDropBy:in:">canDropBy: anInteger in: droppedPieces	^droppedPieces canAccommodateCol: self col		row: (self row + anInteger)</body></methods><methods><class-id>TetrisSquare</class-id> <category>accessor</category><body package="Tetris" selector="col">col	^self point x</body><body package="Tetris" selector="col:">col: anInteger	self point x: anInteger</body><body package="Tetris" selector="color">color	^color</body><body package="Tetris" selector="color:">color: aColor	color := aColor</body><body package="Tetris" selector="pixmap">pixmap	^pixmap</body><body package="Tetris" selector="pixmap:">pixmap: aPixmap	pixmap := aPixmap</body><body package="Tetris" selector="point">point	^point</body><body package="Tetris" selector="point:">point: aPoint	point := aPoint</body><body package="Tetris" selector="row">row	^self point y</body><body package="Tetris" selector="row:">row: anInteger	^self point y: anInteger</body></methods><methods><class-id>TetrisSquare</class-id> <category>pixmap</category><body package="Tetris" selector="createPixmapWithBoard:">createPixmapWithBoard: aView	"Create the image that will be displayed on the board.  This only is done once, storing the pixmap		in the 'pixmap' ivar.  This speeds up drawing, since all squares do not have to be recreated each time."	|  gc rect |	pixmap := Pixmap extent: aView sizeOfSquare.	gc := pixmap graphicsContext.	gc paint: color.	rect := Rectangle origin: (0@0) extent: (aView sizeOfSquare).	rect displayFilledOn: gc.	self drawHilitingOn: rect ;		drawShadowingOn: rect.</body><body package="Tetris" selector="invalidate">invalidate	"Clear the pixmap so the square will be forced to create a new one the next time		it wants to draw itself."	pixmap := nil.</body></methods><methods><class-id>TetrisSquare</class-id> <category>drawing</category><body package="Tetris" selector="drawFlatOn:">drawFlatOn: aView	"This controls the drawing of the floor view, which is the little area below the main game view that shows where	the piece would land if it drops where it is.  This area has width but no depth, so this method draws the square	with a point y of zero."	|  gc |	gc := aView graphicsContext.	pixmap displayOn: gc at: (aView rectangleOfBlock: (Point x: point x y: 0)) origin.</body><body package="Tetris" selector="drawHilitingOn:">drawHilitingOn: rect	| insetRectangle polyline oc gc |	gc := pixmap graphicsContext.	gc paint: color asHiliteColor.	insetRectangle := rect insetBy: (rect height * 0.175) asInteger.	oc := OrderedCollection with: (rect origin) with: (rect topRight) with: (insetRectangle topRight) with: (insetRectangle topLeft).	oc addAll: (Array with: (insetRectangle bottomLeft) with: (rect bottomLeft) with: (rect origin) ).	polyline := Polyline vertices: oc.	polyline displayFilledOn: gc.</body><body package="Tetris" selector="drawOn:">drawOn: aView	|  gc |	pixmap isNil ifTrue: [ "Create new pixmap."		self createPixmapWithBoard: aView ].	gc := aView graphicsContext.	pixmap displayOn: gc at: (aView rectangleOfBlock: point) origin.</body><body package="Tetris" selector="drawShadowingOn:">drawShadowingOn: rect	| insetRectangle polyline oc gc |	gc := pixmap graphicsContext.	gc paint: color asShadowColor.	insetRectangle := rect insetBy: (rect height * 0.175) asInteger.	oc := OrderedCollection with: (rect topRight) with: (rect bottomRight) with: (rect bottomLeft) with: (insetRectangle bottomLeft).	oc addAll: (Array with: (insetRectangle bottomRight) with: (insetRectangle topRight) with: (rect topRight) ).	polyline := Polyline vertices: oc.	polyline displayFilledOn: gc</body><body package="Tetris" selector="eraseOn:">eraseOn: aView	| rect |	rect := (aView rectangleOfBlock: point) expandedBy: (1@1).	aView graphicsContext setDevicePaint: ColorValue black.	rect displayFilledOn: aView graphicsContext.	aView graphicsContext displayInteriorRectangularBorder: rect paint: (ColorValue black)</body></methods><methods><class-id>TetrisSquare</class-id> <category>movement</category><body package="Tetris" selector="offsetBy:">offsetBy: aPoint	| newSquare |	newSquare := self species new.	newSquare point: self point - aPoint.	newSquare color: self color.	newSquare pixmap: self pixmap.	^newSquare</body><body package="Tetris" selector="printOn:">printOn: aStream	aStream nextPutAll: 'aTetrisSquare at ', self point printString.	^aStream</body><body package="Tetris" selector="rotateAround:">rotateAround: centerPoint 	"Given &lt;aPoint&gt;, use that as the center, and rotate 90 degrees counterclockwise."	| diff |	diff := self point - centerPoint.	self point: centerPoint - (diff y negated @ diff x)</body></methods><methods><class-id>TetrisSquare class</class-id> <category>creation</category><body package="Tetris" selector="coordinates:color:">coordinates: aPoint color: aColor	"Create and return a new square, with the supplied attributes."	| me |	me := self new.	me point: aPoint;		color: aColor.	^me</body></methods><methods><class-id>TetrisPiece3</class-id> <category>directions</category><body package="Tetris" selector="center">center	^(self squares at: 1) point</body><body package="Tetris" selector="points">points	^Array with: 2@0 with: 3@0 with: 1@1 with: 2@1</body></methods><methods><class-id>TetrisPiece3</class-id> <category>constants</category><body package="Tetris" selector="color">color	^ColorValue blue</body></methods><methods><class-id>TetrisPiece5</class-id> <category>directions</category><body package="Tetris" selector="center">center	^(self squares at: 3) point</body><body package="Tetris" selector="points">points	^Array with: 1@0 with: 2@0 with: 2@1 with: 3@1</body></methods><methods><class-id>TetrisPiece5</class-id> <category>constants</category><body package="Tetris" selector="color">color	^ColorValue darkGreen</body></methods><methods><class-id>TetrisModel</class-id> <category>resizing</category><body package="Tetris" selector="boardWasResized">boardWasResized	| startTimer | 	startTimer := self gameIsActive .	startTimer ifTrue: [ self pauseTimer ].	self droppedPieces isNil ifTrue: [ ^nil ].	self droppedPieces resizeAll.	self currentPiece resize.	startTimer ifTrue: [self resetTimer ]</body></methods><methods><class-id>TetrisModel</class-id> <category>pieces</category><body package="Tetris" selector="buildNewPiece">buildNewPiece	"This creates a new piece and installs it as currentPiece.  Place it at row 2 if we can.  If not, try to		place it at row 1.  If it can't go there either, the game is over."	| piece |	piece := self newRandomPiece initialize.	( piece canPlaceAtRow: 2 onDroppedPieces: self droppedPieces )		ifTrue: [ piece dropOne ]		ifFalse:[ ( piece canPlaceAtRow: 1 onDroppedPieces: self droppedPieces )			ifFalse: [ ^self gameOver ] ].	self currentPiece: piece.	self drawCurrentPiece.	self resetTimer</body><body package="Tetris" selector="dropCurrentPiece">dropCurrentPiece 	| howmany |	self pauseTimer.	self eraseCurrentPiece.	howmany := self currentPiece dropOn: self droppedPieces.	self drawCurrentPiece.	self removeFilledRows.	self rowsPieceDropped: howmany.	self clearKeyBuffer.	self buildNewPiece</body><body package="Tetris" selector="newRandomPiece">newRandomPiece	"Create a new piece, randomly from the list of all subclasses of TetrisPiece, and return it."	^self pieceCreator getNewPiece</body><body package="Tetris" selector="removeFilledRows">removeFilledRows	| rowsRemoved |	rowsRemoved := self filledRows.	rowsRemoved isEmpty ifFalse: [ self changed: #flash with: rowsRemoved ].	rowsRemoved := self deleteAllFilledRows.	rowsRemoved &gt; 0		ifTrue: [ self rowsAdd: rowsRemoved.				self changed: #drawAllPieces with: self droppedPieces ]</body></methods><methods><class-id>TetrisModel</class-id> <category>dropped pieces</category><body package="Tetris" selector="canAccommodate:">canAccommodate: aPoint	"Return true if the square indicated by &lt;aPoint&gt; is blank; true if it is currently occupied."	aPoint y &gt; self droppedPieces size ifTrue: [ ^false ].	^((self droppedPieces at: aPoint y) at: aPoint x) isNil</body><body package="Tetris" selector="deleteAllFilledRows">deleteAllFilledRows	^self droppedPieces deleteAllFilledRows</body><body package="Tetris" selector="filledRows">filledRows	^self droppedPieces filledRows</body></methods><methods><class-id>TetrisModel</class-id> <category>accessing</category><body package="Tetris" selector="clearKeyBuffer">clearKeyBuffer	self keyPresses: 0</body><body package="Tetris" selector="currentPiece">currentPiece	^currentPiece</body><body package="Tetris" selector="currentPiece:">currentPiece: aTetrisPiece	currentPiece := aTetrisPiece</body><body package="Tetris" selector="droppedPieces">droppedPieces	^droppedPieces</body><body package="Tetris" selector="droppedPieces:">droppedPieces: aCollection	droppedPieces := aCollection</body><body package="Tetris" selector="floorView">floorView	^floorView</body><body package="Tetris" selector="floorView:">floorView: aView	floorView := aView</body><body package="Tetris" selector="incrementKeyPresses">incrementKeyPresses	self keyPresses: (self keyPresses + 1)</body><body package="Tetris" selector="keyPresses">keyPresses	keyPresses isNil ifTrue: [ keyPresses := 0 ].	^keyPresses</body><body package="Tetris" selector="keyPresses:">keyPresses: anInteger	keyPresses := anInteger</body><body package="Tetris" selector="levels">levels	levels isNil ifTrue: [ levels := 0 asValue ].	^levels</body><body package="Tetris" selector="pieceCreator">pieceCreator	pieceCreator isNil ifTrue:		[pieceCreator := TetrisPieceCreator new initialize].	^pieceCreator</body><body package="Tetris" selector="rows">rows	rows isNil ifTrue: [ rows := 0 asValue ].	^rows</body><body package="Tetris" selector="score">score	score isNil ifTrue: [ score := 0 asValue ].	^score</body><body package="Tetris" selector="timer">timer	^timer</body><body package="Tetris" selector="trigger">trigger	trigger isNil ifTrue: [ trigger := TetrisRules millisecondsAtLevelZero ] .	^trigger</body></methods><methods><class-id>TetrisModel</class-id> <category>game</category><body package="Tetris" selector="displayHiScoreTable">displayHiScoreTable	TetrisHiScoreTable new displayHiScoreTable</body><body package="Tetris" selector="gameIsActive">gameIsActive	^trigger &lt; 1</body><body package="Tetris" selector="gameIsOver">gameIsOver	^trigger = 0</body><body package="Tetris" selector="gameIsPaused">gameIsPaused	^trigger &lt; 2</body><body package="Tetris" selector="gameIsRunning">gameIsRunning	^trigger &gt; 0</body><body package="Tetris" selector="gameOver">gameOver	trigger := 0.	Dialog warn: 'Game Over'.	self handleHiScoreTable</body><body package="Tetris" selector="handleHiScoreTable">handleHiScoreTable	| hst |	hst := TetrisHiScoreTable new.	hst openAddingScore: self scoreIncludingRows rows: self rows</body><body package="Tetris" selector="pauseGame">pauseGame	self pauseTimer</body><body package="Tetris" selector="resumePausedGame">resumePausedGame	self resetTimer</body></methods><methods><class-id>TetrisModel</class-id> <category>drawing</category><body package="Tetris" selector="drawCurrentPiece">drawCurrentPiece	self changed: #draw with: self currentPiece</body><body package="Tetris" selector="eraseCurrentPiece">eraseCurrentPiece	self changed: #erase with: self currentPiece</body></methods><methods><class-id>TetrisModel</class-id> <category>piece movement</category><body package="Tetris" selector="dropCurrentPieceByOne">dropCurrentPieceByOne	self eraseCurrentPiece.	self currentPiece dropOne.	self drawCurrentPiece.</body><body package="Tetris" selector="moveCurrentPieceLeft">moveCurrentPieceLeft	self eraseCurrentPiece.	self currentPiece moveLeft.	self drawCurrentPiece.</body><body package="Tetris" selector="moveCurrentPieceRight">moveCurrentPieceRight	self eraseCurrentPiece.	self currentPiece moveRight.	self drawCurrentPiece.</body><body package="Tetris" selector="rotateCurrentPiece">rotateCurrentPiece	self eraseCurrentPiece.	self currentPiece rotate.	self drawCurrentPiece.</body></methods><methods><class-id>TetrisModel</class-id> <category>levels</category><body package="Tetris" selector="incrementLevel">incrementLevel	self levels value: self levels value + 1.</body><body package="Tetris" selector="levelForRows:">levelForRows: rowQty	| levelColl temp |	levelColl := TetrisRules levelCollection.	1 to: levelColl size do: [ :ix | rowQty &lt; (levelColl at: ix) ifTrue: [ ^ix ] ].	temp := rowQty - (levelColl last - TetrisRules subsequentLevelChange).	^(levelColl size) + (temp // 14) .</body><body package="Tetris" selector="maybeIncrementLevelFor:">maybeIncrementLevelFor: anInteger	"We just dropped &lt;anInteger&gt; number of rows.  See if we have to change levels."	(self levelForRows: self rows value) = (self levelForRows: (self rows value - anInteger))		ifTrue: [ ^nil ].	self levels value: (self levels value max: (self levelForRows: self rows value )).</body></methods><methods><class-id>TetrisModel</class-id> <category>initialize-release</category><body package="Tetris" selector="initialize">initialize	self installTimer.	self stopTimer.	self initializeScoring</body><body package="Tetris" selector="installTimer">installTimer	trigger := 0.	timer := [[(trigger &gt; 1				  and: [trigger &lt;= Time millisecondClockValue]) ifTrue: 						[[self requestedDropOne] uiEvent.						 self resetTimer].				(Delay forMilliseconds: 25) wait] repeat] fork</body></methods><methods><class-id>TetrisModel</class-id> <category>private</category><body package="Tetris" selector="initializeScoring">initializeScoring	self rows value: 0 .	self levels value: 1 .	self score value: 0</body><body package="Tetris" selector="millisecondsForNextDrop">millisecondsForNextDrop	"Return the number of milliseconds that we can allow before the piece drops again."	^(TetrisRules percentageAtEachLevel raisedTo: self levels value)		* TetrisRules millisecondsAtLevelZero</body><body package="Tetris" selector="rowsAdd:">rowsAdd: anInteger	self rows value: self rows value + anInteger.	self maybeIncrementLevelFor: anInteger</body><body package="Tetris" selector="scoreAdd:">scoreAdd: anInteger	self score value: self score value + anInteger.</body></methods><methods><class-id>TetrisModel</class-id> <category>game and scoring</category><body package="Tetris" selector="newGame">newGame	self initializeScoring .	self droppedPieces: TetrisDroppedPieces new initialize .	self changed: #eraseAll .	self startTimer .	self buildNewPiece</body><body package="Tetris" selector="rowsPieceDropped:">rowsPieceDropped: anInteger	"We are notified by the piece that it was dropped by &lt;anInteger&gt; rows.  Update scores accordingly."	| temp |	temp := anInteger * TetrisRules extraPointsForEachRowOnADrop.	temp := temp + TetrisRules pointsForDroppingOnePieceZeroRows.	temp := temp - (self keyPresses * TetrisRules pointsLostForPressingAnArrowKey).	self scoreAdd: temp</body><body package="Tetris" selector="scoreIncludingRows">scoreIncludingRows	^self score value + (TetrisRules pointsForClearingOneRow * self rows value)</body></methods><methods><class-id>TetrisModel</class-id> <category>timer</category><body package="Tetris" selector="nextHit">nextHit	^Time millisecondClockValue + self millisecondsForNextDrop asInteger</body><body package="Tetris" selector="pauseTimer">pauseTimer	self gameIsOver		ifFalse: [ trigger := 1 ]</body><body package="Tetris" selector="resetTimer">resetTimer	self gameIsOver		ifFalse: [ self startTimer ]</body><body package="Tetris" selector="startTimer">startTimer	trigger := self nextHit</body><body package="Tetris" selector="stopTimer">stopTimer	trigger := 0</body></methods><methods><class-id>TetrisModel</class-id> <category>keyboard messages</category><body package="Tetris" selector="requestedDropOne">requestedDropOne	self gameIsRunning ifFalse: [ Transcript cr; show: 'Game not running'.  ^nil ] .	(self currentPiece canDropOneOn: self droppedPieces)		ifTrue: [ self dropCurrentPieceByOne ]		ifFalse:[ self requestedDropPiece ]</body><body package="Tetris" selector="requestedDropPiece">requestedDropPiece	self dropCurrentPiece</body><body package="Tetris" selector="requestedMovePieceLeft">requestedMovePieceLeft	(self currentPiece canMoveLeftOn: self droppedPieces)		ifTrue: [ self moveCurrentPieceLeft.				self incrementKeyPresses ]</body><body package="Tetris" selector="requestedMovePieceRight">requestedMovePieceRight	(self currentPiece canMoveRightOn: self droppedPieces)		ifTrue: [ self moveCurrentPieceRight.				self incrementKeyPresses ]</body><body package="Tetris" selector="requestedRotatePiece">requestedRotatePiece	self currentPiece canRotate ifFalse: [ ^nil ] .	(self currentPiece canRotateOn: self droppedPieces)		ifTrue: [ self rotateCurrentPiece.				self incrementKeyPresses ].</body></methods><methods><class-id>TetrisPiece1</class-id> <category>directions</category><body package="Tetris" selector="center">center	^(self squares at: 2) point</body><body package="Tetris" selector="points">points	^Array with: 1@0 with: 2@0 with: 3@0 with: 4@0</body></methods><methods><class-id>TetrisPiece1</class-id> <category>constants</category><body package="Tetris" selector="color">color	^ColorValue darkRed.</body></methods><methods><class-id>TetrisView</class-id> <category>title bar</category><body package="Tetris" selector="addPausedToTitleBar">addPausedToTitleBar	self topComponent label: (self tetrisLabel, ' (Paused)' ).</body><body package="Tetris" selector="removePausedFromTitleBar">removePausedFromTitleBar	self topComponent label: self tetrisLabel</body><body package="Tetris" selector="tetrisLabel">tetrisLabel	^'Tetris for Visual Works'</body></methods><methods><class-id>TetrisView</class-id> <category>displaying</category><body package="Tetris" selector="blackenBackground">blackenBackground	| rect |	rect := self bounds.	rect displayFilledOn: self graphicsContext.</body><body package="Tetris" selector="collapse">collapse	"This is sent by my controller on an escape key"	self topComponent label: (self tetrisLabel, ' (Paused)' ).	self topComponent collapse</body><body package="Tetris" selector="displayOn:">displayOn: aGraphicsContext	self model isNil ifTrue: [^self].	self testWindowSizeForChange.	self drawAllPiecesWith: self model droppedPieces.	self drawCurrentPiece.</body><body package="Tetris" selector="drawCurrentPiece">drawCurrentPiece	"Draw the current piece at its proper location."	model currentPiece isNil		ifFalse: [ model currentPiece drawOn: self ].</body><body package="Tetris" selector="flashRows:">flashRows: aCollection 	"Indicate by flashing or color changing or whatever, that these 	 rows are about to disappear. Spooky, huh?"	aCollection do:		[:ix |		(model droppedPieces piecesInRow: ix) do:			[:aSquare | 			aSquare color: ((aSquare color blendWith: ColorValue white)								blendWith: ColorValue white).			aSquare pixmap: nil.			aSquare drawOn: self]].	(Delay forMilliseconds: TetrisRules millisecondsToPauseDuringFlash) wait</body></methods><methods><class-id>TetrisView</class-id> <category>squares</category><body package="Tetris" selector="canAccommodate:">canAccommodate: aPoint	"Return true if the square indicated by &lt;aPoint&gt; is blank; false if it is currently occupied."	aPoint y &lt; 1 ifTrue: [ ^false ].	aPoint y &gt; model droppedPieces size ifTrue: [ ^false ].	^((model droppedPieces at: aPoint y) at: aPoint x) isNil</body><body package="Tetris" selector="sizeOfSquare">sizeOfSquare	"Return the dimensions of a board square."	^(self bounds width / TetrisRules columns) asInteger @ (self bounds height / TetrisRules rows) asInteger</body></methods><methods><class-id>TetrisView</class-id> <category>controller accessing</category><body package="Tetris" selector="defaultControllerClass">defaultControllerClass	^TetrisController</body></methods><methods><class-id>TetrisView</class-id> <category>private</category><body package="Tetris" selector="drawAllPiecesWith:">drawAllPiecesWith: droppedPieces	self blackenBackground.	droppedPieces isNil ifTrue: [ ^nil ].	1 to: TetrisRules rows do:		[ :aRow |		1 to: TetrisRules columns do:			[ :aColumn |			(droppedPieces pieceAtRow: aRow column: aColumn) isNil ifFalse:				[ (droppedPieces pieceAtRow: aRow column: aColumn) drawOn: self ] ] ]</body><body package="Tetris" selector="rectangleOfBlock:">rectangleOfBlock: aPoint	"Take the point &lt;aPoint&gt;, and translate it into the rectangle that it should occupy in the grid."	^Rectangle origin: (aPoint x - 1  * self sizeOfSquare x) @ (aPoint y - 1  * self sizeOfSquare y)			extent: (self sizeOfSquare - 1 )</body><body package="Tetris" selector="testWindowSizeForChange">testWindowSizeForChange	| extent |	extent := self container bounds extent.	prevExtent isNil ifTrue: [ ^prevExtent := extent ].	prevExtent = extent ifTrue: [ ^self ].	prevExtent := extent.	self model boardWasResized</body></methods><methods><class-id>TetrisView</class-id> <category>updating</category><body package="Tetris" selector="drawWith:">drawWith: aPiece	aPiece drawOn: self</body><body package="Tetris" selector="eraseWith:">eraseWith: aPiece	aPiece eraseOn: self</body><body package="Tetris" selector="flashWith:">flashWith: aCollection	self flashRows: aCollection</body><body package="Tetris" selector="update:with:">update: anAspect with: anObject	anAspect == #draw				ifTrue: [ ^self drawWith: anObject ] .	anAspect == #flash				ifTrue: [ ^self flashWith: anObject ] .	anAspect == #drawAllPieces	ifTrue: [ ^self drawAllPiecesWith: anObject ] .	anAspect == #eraseAll			ifTrue: [ ^self blackenBackground ] .	anAspect == #erase				ifTrue: [ ^self eraseWith: anObject ]</body></methods><methods><class-id>TetrisView</class-id> <category>model accessing</category><body package="Tetris" selector="model:">model: aModel	super model: aModel.	self invalidate.</body></methods><methods><class-id>TetrisPiecePreviewView</class-id> <category>drawing</category><body package="Tetris" selector="blackenBackground">blackenBackground	| rect |	rect := self bounds.	rect displayFilledOn: self graphicsContext.</body><body package="Tetris" selector="displayOn:">displayOn: aGC	self blackenBackground.	thePiece isNil ifFalse: [ self drawCentered: thePiece ].</body><body package="Tetris" selector="drawUsing:">drawUsing: aPiece	thePiece := aPiece.	self displayOn: self graphicsContext</body></methods><methods><class-id>TetrisPiecePreviewView</class-id> <category>private</category><body package="Tetris" selector="drawCentered:">drawCentered: aPiece	"This draws the piece, centered, in the view."	| gc left top colStarter rowStarter |	gc := self graphicsContext.	left := self leftOffsetOf: aPiece.	top := self topOffsetOf: aPiece.	colStarter := aPiece leftmostSquare col.	rowStarter := aPiece topmostSquare row.	aPiece squares do: [ :aSquare |		aSquare createPixmapWithBoard: self.		aSquare pixmap displayOn: gc				at: ( aSquare col - colStarter * self sizeOfSquare x + left )				@  ( aSquare row - rowStarter * self sizeOfSquare y + top )	]</body><body package="Tetris" selector="leftOffsetOf:">leftOffsetOf: aPiece 	| colTemp cols |	colTemp := (aPiece squares collect: [:aSquare | aSquare col]) asSortedCollection.	cols := colTemp last - colTemp first + 1.	^self bounds width - (cols * self sizeOfSquare x) // 2</body><body package="Tetris" selector="rectangleOfBlock:">rectangleOfBlock: aPoint	"Take the point &lt;aPoint&gt;, and translate it into the rectangle that it should occupy in the grid."	^Rectangle origin: (aPoint x - 4  * self sizeOfSquare x) @ (aPoint y - 1  * self sizeOfSquare y)			extent: (self sizeOfSquare - 1 )</body><body package="Tetris" selector="sizeOfSquare">sizeOfSquare	^15@15</body><body package="Tetris" selector="topOffsetOf:">topOffsetOf: aPiece	| rowTemp rows |	rowTemp := (aPiece squares collect: [ :aSquare | aSquare row ] ) asSortedCollection.	rows := rowTemp last - rowTemp first + 1.	^self bounds height - ( rows * self sizeOfSquare y) // 2.</body></methods><methods><class-id>TetrisPieceCreator</class-id> <category>creation</category><body package="Tetris" selector="getNewPiece">getNewPiece	| swap new |	swap := self nextPiece value.	new := self randomPiece initialize.	self nextPiece value: new.	^swap.</body><body package="Tetris" selector="randomPiece">randomPiece	| upperLimit next randomInteger |	upperLimit := TetrisPiece pieces size - 1.	next := random next.	randomInteger := (next * upperLimit + 1) rounded.	^(TetrisPiece pieces at: randomInteger) new.</body></methods><methods><class-id>TetrisPieceCreator</class-id> <category>initialize</category><body package="Tetris" selector="initialize">initialize	random isNil ifTrue: [ random := Random new ].</body></methods><methods><class-id>TetrisPieceCreator</class-id> <category>accessor</category><body package="Tetris" selector="nextPiece">nextPiece	nextPiece isNil ifTrue: [ nextPiece := self randomPiece asValue ].	^nextPiece</body></methods><methods><class-id>TetrisController</class-id> <category>keyboard</category><body package="Tetris" selector="downWasPressed">downWasPressed	"The down arrow key was pressed.  Drop the piece."	model requestedDropPiece</body><body package="Tetris" selector="escWasPressed">escWasPressed	"The boss is approaching.  Collapse the game and look like I'm working."	model pauseGame.	view collapse.</body><body package="Tetris" selector="f1WasPressed">f1WasPressed	"Sorry, hitting F1 for help does not buy you more time."	self showHelpScreen</body><body package="Tetris" selector="f2WasPressed">f2WasPressed	"Reset the score and start a new game."	view removePausedFromTitleBar.	model newGame</body><body package="Tetris" selector="f3WasPressed">f3WasPressed	"Pause, or end pause." 	model gameIsPaused		ifTrue: [ model resumePausedGame.				view removePausedFromTitleBar ]		ifFalse:[ model pauseGame.				view addPausedToTitleBar ]</body><body package="Tetris" selector="f4WasPressed">f4WasPressed	"Show high score" 	model displayHiScoreTable</body><body package="Tetris" selector="leftWasPressed">leftWasPressed	model requestedMovePieceLeft</body><body package="Tetris" selector="rightWasPressed">rightWasPressed	model requestedMovePieceRight</body><body package="Tetris" selector="showHelpScreen">showHelpScreen	| str |	str:= ReadWriteStream on: String new .	str tab; nextPutAll: 'Tetris for Visual Works'; cr; cr;		nextPutAll: TetrisRules copyrightMessage; cr.	str tab; tab; nextPutAll: '-------Keys-------';  cr.	str nextPutAll: 'F2 - Start a New Game';  cr.	str nextPutAll: 'F3 - Toggle Pause';  cr.	str nextPutAll: 'esc- Pause and Collapse';  cr.	str tab; tab; nextPutAll: '------Arrows------';  cr.	str nextPutAll: 'Up - Rotate Piece';  cr.	str nextPutAll: 'Down - Drop Piece';  cr.	str nextPutAll: 'Left - Move Piece Left';  cr.	str nextPutAll: 'Right - Move Piece Right'.	Dialog warn: str contents.</body><body package="Tetris" selector="upWasPressed">upWasPressed	model requestedRotatePiece</body></methods><methods><class-id>TetrisController</class-id> <category>private</category><body package="Tetris" selector="flushKBAfterEachKey">flushKBAfterEachKey	^true</body><body package="Tetris" selector="maybeFlushKeyboardBuffer">maybeFlushKeyboardBuffer	self flushKBAfterEachKey ifTrue: [ "self sensor flushKeyboard" ] .</body></methods><methods><class-id>TetrisController</class-id> <category>control</category><body package="Tetris" selector="gameIsOver">gameIsOver	model isNil ifTrue: [ ^false ].	^self model gameIsOver</body><body package="Tetris" selector="gameIsPaused">gameIsPaused	model isNil ifTrue: [ ^false ].	^self model gameIsPaused</body><body package="Tetris" selector="gameIsRunning">gameIsRunning	model isNil ifTrue: [ ^false ].	^self model gameIsRunning</body><body package="Tetris" selector="isControlWanted">isControlWanted	"All keystrokes are handled by the top component, so don't let this class intercept them."	^false</body><body package="Tetris" selector="processKeyboardEvent:">processKeyboardEvent: anEvent	"The active keys (to which the game can respond) vary with the state of the game."	| char validKeys |	validKeys := #( Left Right Up Down F1 F2 F3 Esc ) .	self gameIsPaused ifTrue: [validKeys := #( F1 F2 F3 F4 Esc)] .	self gameIsRunning ifFalse: [validKeys := #( F1 F2 F3 F4 Esc )] .	self gameIsOver ifTrue: [validKeys := #( F1 F2 F3 F4 Esc )] .	char := anEvent keyValue.	"self sensor flushKeyboard ."	char = Character esc ifTrue: [char := #Esc].	(validKeys includes: char) ifTrue:		[self perform: (char asLowercase, 'WasPressed') asSymbol.		 self maybeFlushKeyboardBuffer.		 ^nil].	^anEvent</body></methods><methods><class-id>TetrisHiScoreTable class</class-id> <category>interface specs</category><body package="Tetris" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Tetris - High Score Table' 			#min: #(#Point 365 480 ) 			#max: #(#Point 365 480 ) 			#bounds: #(#Rectangle 219 64 584 544 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TableViewSpec 					#layout: #(#LayoutFrame 5 0 5 0 -5 1 -25 1 ) 					#name: #theTable 					#flags: 13 					#model: #theTable 					#showHGrid: true 					#showVGrid: true 					#selectionStyle: #row ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0.373464 0 0.949685 0 0.574939 0 0.997904 ) 					#name: #close 					#model: #closeRequest 					#label: 'Close' 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>TetrisGame class</class-id> <category>resources</category><body package="Tetris" selector="myIcon">myIcon	"UIMaskEditor new openOnClass: self andSelector: #myIcon"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 254 15 0 4 147 9 128 4 147 9 192 7 255 15 192 3 159 9 192 1 158 9 192 0 252 15 192 0 124 9 192 0 60 9 192 30 0 15 192 19 0 9 192 19 128 9 192 31 192 15 192 18 96 7 192 18 112 3 192 31 240 0 0 14 112 0 0 6 112 254 0 3 240 147 0 1 240 147 128 0 240 255 128 0 0 147 128 0 0 147 128 0 0 255 128 0 0 127 128 0 0 63 128 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>TetrisGame class</class-id> <category>interface specs</category><body package="Tetris" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Tetris for Visual Works' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 157 341 605 601 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0.333333 10 0 -10 1 0 0.95 ) ) 				#(#ArbitraryComponentSpec 					#layout: #(#LayoutFrame 11 0.333333 11 0 -11 1 0 0.95 ) 					#flags: 0 					#component: #tetrisView ) 				#(#GroupBoxSpec 					#layout: #(#Rectangle 24 32 154 212 ) ) 				#(#LabelSpec 					#layout: #(#Point 30 38 ) 					#label: 'Score:' ) 				#(#LabelSpec 					#layout: #(#Point 33 94 ) 					#label: 'Level:' ) 				#(#LabelSpec 					#layout: #(#Point 33 66 ) 					#label: 'Rows:' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 87 37 140 60 ) 					#name: #scoreField 					#model: #scoreBuffer 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 87 93 140 116 ) 					#name: #levelField 					#model: #levelBuffer 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 87 65 140 88 ) 					#name: #rowsField 					#model: #rowsBuffer 					#isReadOnly: true ) 				#(#ArbitraryComponentSpec 					#layout: #(#Rectangle 51 129 140 203 ) 					#component: #piecePreviewView ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0.333333 0 0.96 -10 1 -1 1 ) ) 				#(#ArbitraryComponentSpec 					#layout: #(#LayoutFrame 11 0.333333 0 0.96 -11 1 -1 1 ) 					#flags: 0 					#component: #floorView ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 0 0.0290179 0 0.865385 ) 					#label: 'Press F1 for Help' ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Tetris" selector="toolsTetris">toolsTetris	"Open tetris game."	&lt;menuItem: 'Tetris'		nameKey: nil		menu: #(#menuBar #tools)		position: 12.95&gt;	TetrisGame open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view sensor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>