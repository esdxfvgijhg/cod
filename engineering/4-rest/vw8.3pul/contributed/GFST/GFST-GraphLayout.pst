<?xml version="1.0"?><st-source><!-- Name: GF/ST GraphLayoutDbIdentifier: bear73DbTrace: 478157DbUsername: kgreekDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'GF/ST Base' ''))PackageName: GF/ST GraphLayoutParcel: #('GF/ST GraphLayout')ParcelName: GF/ST GraphLayoutPrerequisiteDescriptions: #(#(#name 'GF/ST Base' #componentType #package))PrerequisiteParcels: #(#('GF/ST Base' ''))PrintStringCache: (8.1 - 1,kgreek)Version: 8.1 - 1Date: 1:14:05 PM April 1, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (apr16.1) of April 1, 2016 on April 1, 2016 at 1:14:05 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>FwGraphNode</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwImplicitGraphNode</name><environment>Polymorphic</environment><super>Polymorphic.FwGraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwImplicitGraphNodeCollection</name><environment>Polymorphic</environment><super>Polymorphic.FwImplicitGraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collectionBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>GFDAGLayout</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layout nodeGOMap createNodeGOAction createLineGOAction createLabelGOAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFGraphDisplay</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>GFTreeLayout</name><environment>Polymorphic</environment><super>Polymorphic.GFDAGLayout</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFGraphDisplay</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwDynamicGraphLayoutBounds</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bounds margin graph wallForce marginForce </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwDAGLayout</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graph leafMargin rootMargin sideMargin horizontal minPCspace minSiblingSpace positions graphExtent extents extentAction inAction outAction lineAction labelAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>GFGraphNode</name><environment>Polymorphic</environment><super>Polymorphic.GFGroupGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graph node edges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFGraphDisplay</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>AbstractDAGComposer</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graph views leafMargin rootMargin sideMargin horizontal minPCspace minSiblingSpace positions graphExtent lines extents extentBlock inBlock outBlock labels labelPositions labelPositionBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>DAGComposer</name><environment>Polymorphic</environment><super>Polymorphic.AbstractDAGComposer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwDictionaryWithDefault</name><environment>Polymorphic</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>defaultBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel-FwGraphModelVW</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwGraph</name><environment>Polymorphic</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes nodeCreator type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwRootedGraph</name><environment>Polymorphic</environment><super>Polymorphic.FwGraph</super><private>false</private><indexed-type>none</indexed-type><inst-vars>roots </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwKeyedSet</name><environment>Polymorphic</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel-FwGraphModelVW</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwExplicitGraphNode</name><environment>Polymorphic</environment><super>Polymorphic.FwGraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>neighbors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwIterator</name><environment>Polymorphic</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwIdentityDictionaryWithDefault</name><environment>Polymorphic</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>defaultBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel-FwGraphModelVW</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwTreeLayout</name><environment>Polymorphic</environment><super>Polymorphic.FwDAGLayout</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwImplicitGraphNodeIterator</name><environment>Polymorphic</environment><super>Polymorphic.FwImplicitGraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iterator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwDynamicGraphLayout</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeMap edgeMap bounds zeroDistance scaleConstraint minConstraint nodes fixedNodeCount currentTime maxTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwDAGFrontier</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frontier bag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwDynamicGraphLayoutNode</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure position speed force edges moveable extent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwDynamicGraphLayoutEdge</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure weight fromNode toNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>FwLabelledExplicitGraphNode</name><environment>Polymorphic</environment><super>Polymorphic.FwExplicitGraphNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphModel</category><attributes><package>GF/ST GraphLayout</package></attributes></class><class><name>TreeComposer</name><environment>Polymorphic</environment><super>Polymorphic.AbstractDAGComposer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FwGraphLayout</category><attributes><package>GF/ST GraphLayout</package></attributes></class><shared-variable><name>InitializationBlocks</name><environment>Polymorphic.FwGraph</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxWeight</name><environment>Polymorphic.FwDynamicGraphLayoutNode</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxForce</name><environment>Polymorphic.FwDynamicGraphLayoutBounds</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxWeight</name><environment>Polymorphic.FwDynamicGraphLayoutEdge</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxForce</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MinForce</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>TimeStep</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxFriction</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxTimeScale</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxWeight</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MinFriction</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MaxInertia</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><shared-variable><name>MinInertia</name><environment>Polymorphic.FwDynamicGraphLayout</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST GraphLayout</package></attributes></shared-variable><methods><class-id>Polymorphic.FwGraphNode</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">= anObject    "Comparison is delegated to the value of the node.    Argument and receiver are reversed to dereference through other FwGraphNodes."    ^anObject = value</body><body package="GF/ST GraphLayout">degree    "How many edges does this node have?"    self subclassResponsibility</body><body package="GF/ST GraphLayout">hasEdgeTo: anObject    "Is there an edge from this node to anObject?"    self subclassResponsibility</body><body package="GF/ST GraphLayout">hash    ^value hash</body><body package="GF/ST GraphLayout">isLabelled    "Are the edges from this node labelled?"    self subclassResponsibility</body><body package="GF/ST GraphLayout">isLeaf    ^self degree = 0</body><body package="GF/ST GraphLayout">neighbors    "Return a collection of nodes connected to outgoing edges."    self subclassResponsibility</body><body package="GF/ST GraphLayout">neighborsAndLabelsDo: aBlock    "Evaluate aBlock for each node connected to an outgoing edge, and the label on that edge (nil if no label)."    "The default definition assumes no labels are present."    self neighborsDo: [ :n | aBlock value: n value: nil]</body><body package="GF/ST GraphLayout">neighborsDo: aBlock    "Evaluate aBlock for each node connected to an outgoing edge."    self subclassResponsibility</body><body package="GF/ST GraphLayout">printOn: aStream    ^value printOn: aStream</body><body package="GF/ST GraphLayout">value    ^value</body><body package="GF/ST GraphLayout">value: val    value := val</body></methods><methods><class-id>Polymorphic.FwImplicitGraphNode</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">neighbors    ^OrderedCollection accumulate: [ :incBlock | self neighborsDo: incBlock]</body><body package="GF/ST GraphLayout">neighborsDo: aBlock    self neighbors do: aBlock</body></methods><methods><class-id>Polymorphic.FwImplicitGraphNode class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">on: aValue collectionBlock: aBlock    ^FwImplicitGraphNodeCollection on: aValue collectionBlock: aBlock</body><body package="GF/ST GraphLayout">on: aValue iterator: anIterator    ^FwImplicitGraphNodeIterator on: aValue iterator: anIterator</body><body package="GF/ST GraphLayout">on: aValue iteratorBlock: iteratorBlock    ^FwImplicitGraphNodeIterator on: aValue iteratorBlock: iteratorBlock</body></methods><methods><class-id>Polymorphic.FwImplicitGraphNodeCollection</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">collectionBlock: aBlock    collectionBlock := aBlock</body><body package="GF/ST GraphLayout">degree    ^self neighbors size</body><body package="GF/ST GraphLayout">hasEdgeTo: anObject    ^self neighbors includes: anObject</body><body package="GF/ST GraphLayout">neighbors    ^collectionBlock value</body></methods><methods><class-id>Polymorphic.FwImplicitGraphNodeCollection class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">on: aValue collectionBlock: aBlock    ^(self new) value: aValue ; collectionBlock: aBlock</body></methods><methods><class-id>Polymorphic.GFDAGLayout</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">arrowGOAction	| lineGO |	^[:nodeGos :line |		    lineGO := GFDependentLineGO                        		arrowStartLocation: (GFLocator on: nodeGos key at: #absolute: with: (nodeGos key relative: line key))                       			stopLocation: (GFLocator on: nodeGos value at: #absolute: with: (nodeGos value relative: line value)).			nodeGos key addEdge: lineGO to: nodeGos value.	]</body><body package="GF/ST GraphLayout">centerLabelGOAction	| edge constraint label location |	^[:nodeLine :labelText |		edge := nodeLine key key edgeTo: nodeLine key value.		location := GFLocator on: edge at: #center.		label := GFTextGO text: labelText.		label center: edge center.		constraint :=GFPositionConstraint 								location: location								receiver: label								sending: #center:.	   	edge        	when: #damaged        	evaluate: constraint.		label	].</body><body package="GF/ST GraphLayout">graphExtent	^layout graphExtent</body><body package="GF/ST GraphLayout">horizOrthoArrowGOAction	| lineGO |	^[:nodeGos :line |		    lineGO := GFDependentOrthogonalPathGO                        		arrowStartLocation: (GFLocator on: nodeGos key at: #absolute: with: (nodeGos key relative: line key))                        		direction: GFOrthogonalPathGO directionRight                       			stopLocation: (GFLocator on: nodeGos value at: #absolute: with: (nodeGos value relative: line value))                        		direction: GFOrthogonalPathGO directionLeft.			nodeGos key addEdge: lineGO to: nodeGos value.	]</body><body package="GF/ST GraphLayout">horizOrthoLineGOAction	| lineGO |	^[:nodeGos :line |		    lineGO := GFDependentOrthogonalPathGO                        		startLocation: (GFLocator on: nodeGos key at: #absolute: with: (nodeGos key relative: line key))                        		direction: GFOrthogonalPathGO directionRight                       			stopLocation: (GFLocator on: nodeGos value at: #absolute: with: (nodeGos value relative: line value))                        		direction: GFOrthogonalPathGO directionLeft.			nodeGos key addEdge: lineGO to: nodeGos value.	]</body><body package="GF/ST GraphLayout">horizontal	layout horizontal</body><body package="GF/ST GraphLayout">init	| new nodeAndLineGo |	nodeGOMap := FwDictionaryWithDefault newWithDefaultValueBlock: [:node |									new := GFGraphNode forNode: node graph: layout graph.									createNodeGOAction evaluateWith: new.									new							  ].	self initLayout.	layout		setExtentAction: [:aNode | (nodeGOMap at: aNode) extent];		setLineAction: [:nodeAssoc :line |				createLineGOAction 					evaluateWith: (nodeGOMap at: nodeAssoc key) =&gt; (nodeGOMap at: nodeAssoc value)					with: line			];		setLabelAction: [:nodeAndLine :label |				nodeAndLineGo := ((nodeGOMap at: nodeAndLine key key)													=&gt; (nodeGOMap at: nodeAndLine key value)) =&gt; nodeAndLine value.				createLabelGOAction					evaluateWith: nodeAndLineGo					with: label			].</body><body package="GF/ST GraphLayout">initLayout	layout := FwDAGLayout new.</body><body package="GF/ST GraphLayout">layout	layout 		layoutNodes;		nodesAndPositionsDo: [:node :pos |			(nodeGOMap at: node) origin: pos		];		layoutLinesAndLabels.</body><body package="GF/ST GraphLayout">lineGOAction	| lineGO |	^[:nodeGos :line |		    lineGO := GFDependentLineGO                        		startLocation: (GFLocator on: nodeGos key at: #absolute: with: (nodeGos key relative: line key))                       			stopLocation: (GFLocator on: nodeGos value at: #absolute: with: (nodeGos value relative: line value)).			nodeGos key addEdge: lineGO to: nodeGos value.	]</body><body package="GF/ST GraphLayout">nodeGOs	^nodeGOMap values</body><body package="GF/ST GraphLayout">rootGOs	| roots |	roots := OrderedCollection new.	layout graph rootNodes do: [:each |		roots add: (nodeGOMap at: each).	].	^roots</body><body package="GF/ST GraphLayout">setCreateLabelGOAction: anAction	createLabelGOAction := anAction</body><body package="GF/ST GraphLayout">setCreateLineGOAction: anAction	createLineGOAction := anAction</body><body package="GF/ST GraphLayout">setCreateNodeGOAction: anAction	createNodeGOAction := anAction</body><body package="GF/ST GraphLayout">setGraph: anFwRootedGraph	layout setGraph: anFwRootedGraph</body><body package="GF/ST GraphLayout">setInterface: aGFDrawingInterface	layout := aGFDrawingInterface</body><body package="GF/ST GraphLayout">setLeafMargin: anInteger	layout setLeafMargin: anInteger</body><body package="GF/ST GraphLayout">setMargins: anInteger	layout setMargins: anInteger</body><body package="GF/ST GraphLayout">setMinParentChildSpace: anInteger	layout setMinParentChildSpace: anInteger</body><body package="GF/ST GraphLayout">setMinSiblingSpace: anInteger	layout setMinSiblingSpace: anInteger</body><body package="GF/ST GraphLayout">setRootMargin: anInteger	layout setRootMargin: anInteger</body><body package="GF/ST GraphLayout">setSideMargin: anInteger	layout setSideMargin: anInteger</body><body package="GF/ST GraphLayout">vertOrthoArrowGOAction	| lineGO |	^[:nodeGos :line |		    lineGO := GFDependentOrthogonalPathGO                        		arrowStartLocation: (GFLocator on: nodeGos key at: #absolute: with: (nodeGos key relative: line key))                        		direction: GFOrthogonalPathGO directionBottom                       			stopLocation: (GFLocator on: nodeGos value at: #absolute: with: (nodeGos value relative: line value))                        		direction: GFOrthogonalPathGO directionTop.			nodeGos key addEdge: lineGO to: nodeGos value.	]</body><body package="GF/ST GraphLayout">vertOrthoLineGOAction	| lineGO |	^[:nodeGos :line |		    lineGO := GFDependentOrthogonalPathGO                        		startLocation: (GFLocator on: nodeGos key at: #absolute: with: (nodeGos key relative: line key))                        		direction: GFOrthogonalPathGO directionBottom                       			stopLocation: (GFLocator on: nodeGos value at: #absolute: with: (nodeGos value relative: line value))                        		direction: GFOrthogonalPathGO directionTop.			nodeGos key addEdge: lineGO to: nodeGos value.	]</body><body package="GF/ST GraphLayout">vertical	layout vertical</body></methods><methods><class-id>Polymorphic.GFDAGLayout class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">forGraph: anFwRootedGraph	^self new setGraph: anFwRootedGraph</body><body package="GF/ST GraphLayout">layoutHorizontalRoots: anArray childrenBlock: childrenBlock goSelector: aSymbol	self		layoutRoots: anArray 		childrenBlock: childrenBlock		goSelector: aSymbol		isVertical: false		minParentChildSpace: 30		minSiblingSpace: 10		margins: 10</body><body package="GF/ST GraphLayout">layoutHorizontalRoots: anArray childrenBlock: childrenBlock goSelector: aSymbol label: aString 	self		layoutRoots: anArray		childrenBlock: childrenBlock		goSelector: aSymbol		isVertical: false		minParentChildSpace: 30		minSiblingSpace: 10		margins: 10		label: aString</body><body package="GF/ST GraphLayout">layoutRoots: anArray childrenBlock: aOneArgumentBlock goSelector: goCreationSymbol isVertical: aBoolean minParentChildSpace: minParentChildSpace minSiblingSpace: minSiblingSpace margins: margins 	| interface layout |	(layout := self forGraph: (FwRootedGraph ordered roots: anArray children: aOneArgumentBlock))		setCreateNodeGOAction: 			[:nodeGO | 			nodeGO cacheFlag: false.			nodeGO setGraphicObjects: (Array with: (nodeGO node value perform: goCreationSymbol))]; setCreateLineGOAction: layout arrowGOAction; setCreateLabelGOAction: [:nodeAndLineAssoc :label | ].	aBoolean		ifTrue: [layout vertical]		ifFalse: [layout horizontal].	layout setMinParentChildSpace: minParentChildSpace; setMinSiblingSpace: minSiblingSpace; setMargins: margins; layout.	interface := GFDrawingInterface openOn: ((GFDrawing new) drawingExtent: layout graphExtent; visibleArea: (0 @ 0 extent: layout graphExtent); yourself).	layout rootGOs do: [:each | each recursivelyAddTo: interface]</body><body package="GF/ST GraphLayout">layoutRoots: anArray childrenBlock: aOneArgumentBlock goSelector: goCreationSymbol isVertical: aBoolean minParentChildSpace: minParentChildSpace minSiblingSpace: minSiblingSpace margins: margins label: aString	| interface layout |	(layout := self forGraph: (FwRootedGraph ordered roots: anArray children: aOneArgumentBlock))		setCreateNodeGOAction: 			[:nodeGO | 			nodeGO cacheFlag: false.			nodeGO setGraphicObjects: (Array with: (nodeGO node value perform: goCreationSymbol))]; setCreateLineGOAction: layout arrowGOAction; setCreateLabelGOAction: [:nodeAndLineAssoc :label | ].	aBoolean		ifTrue: [layout vertical]		ifFalse: [layout horizontal].	layout setMinParentChildSpace: minParentChildSpace; setMinSiblingSpace: minSiblingSpace; setMargins: margins; layout.	interface := GFDrawingInterface openOn: ((GFDrawing new) drawingExtent: layout graphExtent; visibleArea: (0 @ 0 extent: layout graphExtent); yourself) withLabel: aString.	layout rootGOs do: [:each | each recursivelyAddTo: interface]</body><body package="GF/ST GraphLayout">layoutVerticalRoots: anArray childrenBlock: childrenBlock goSelector: aSymbol	self		layoutRoots: anArray 		childrenBlock: childrenBlock		goSelector: aSymbol		isVertical: true		minParentChildSpace: 30		minSiblingSpace: 10		margins: 10</body><body package="GF/ST GraphLayout">layoutVerticalRoots: anArray childrenBlock: childrenBlock goSelector: aSymbol label: aString	self		layoutRoots: anArray 		childrenBlock: childrenBlock		goSelector: aSymbol		isVertical: true		minParentChildSpace: 30		minSiblingSpace: 10		margins: 10		label: aString</body><body package="GF/ST GraphLayout">test	"	GFDAGLayout test	"	| interface layout |	(layout := self forGraph: FwRootedGraph exampleDAG)		setCreateNodeGOAction: [:nodeGO |				nodeGO cacheFlag: false.				nodeGO setGraphicObjects: (					Array with: (GFTextGO text: nodeGO node value)				).			];		setCreateLineGOAction: layout arrowGOAction;		setCreateLabelGOAction: [:nodeAndLineAssoc :label | ].	layout		setMinParentChildSpace: 30 ;		setMinSiblingSpace: 10 ;		setMargins: 10 ;		layout.	interface := GFDrawingInterface openOn: (GFDrawing new 																			drawingExtent: layout graphExtent;																			visibleArea: (0@0 extent: layout graphExtent);																			yourself).	layout rootGOs do: [:each | each recursivelyAddTo: interface].</body><body package="GF/ST GraphLayout">test2	"	GFDAGLayout test2	"	| interface layout |	(layout := self forGraph: FwRootedGraph exampleDAG)		setCreateNodeGOAction: [:nodeGO |				nodeGO cacheFlag: false.				nodeGO setGraphicObjects: (					Array with: (GFTextGO text: nodeGO node value )				).			];		setCreateLineGOAction: layout arrowGOAction;		setCreateLabelGOAction: [:nodeAndLineAssoc :label | ].	layout		vertical;		setMinParentChildSpace: 30 ;		setMinSiblingSpace: 10 ;		setMargins: 10 ;		layout.	interface := GFDrawingInterface openOn: (GFDrawing new 																			drawingExtent: layout graphExtent;																			visibleArea: (0@0 extent: layout graphExtent);																			yourself).	layout rootGOs do: [:each | each recursivelyAddTo: interface].</body></methods><methods><class-id>Polymorphic.GFDAGLayout class</class-id> <category>instance creation</category><body package="GF/ST GraphLayout">new	^super new init</body></methods><methods><class-id>Polymorphic.GFTreeLayout</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">initLayout	layout := FwTreeLayout new.</body></methods><methods><class-id>Polymorphic.GFTreeLayout class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">test	"	GFTreeLayout test	"	| interface layout |	(layout := self forGraph: FwRootedGraph exampleMediumLabelledTree)		setCreateNodeGOAction: [:nodeGO |				nodeGO cacheFlag: false.				nodeGO setGraphicObjects: (					Array with: (GFTextGO text: nodeGO node value name)				).			];		setCreateLineGOAction: layout horizOrthoLineGOAction;		setCreateLabelGOAction: [:nodeAndLineAssoc :label | ].	layout		setMinParentChildSpace:  20 ;		setMinSiblingSpace: 10 ;		setMargins: 5 ;		layout.	interface := GFDrawingInterface openOn: (GFDrawing new 																			drawingExtent: layout graphExtent;																			visibleArea: (0@0 extent: layout graphExtent);																			yourself).	layout rootGOs do: [:each | each recursivelyAddTo: interface].</body><body package="GF/ST GraphLayout">test2	"	GFTreeLayout test2	"	| interface layout |	(layout := self forGraph: FwRootedGraph exampleMediumLabelledTree)		setCreateNodeGOAction: [:nodeGO |				nodeGO cacheFlag: false.				nodeGO setGraphicObjects: (					Array with: (GFTextGO text: nodeGO node value name)				).			];		setCreateLineGOAction: layout vertOrthoLineGOAction;		setCreateLabelGOAction: [:nodeAndLineAssoc :label | ].	layout		vertical;		setMinParentChildSpace: 20 ;		setMinSiblingSpace: 10 ;		setMargins: 10 ;		layout.	interface := GFDrawingInterface openOn: (GFDrawing new 																			drawingExtent: layout graphExtent;																			visibleArea: (0@0 extent: layout graphExtent);																			yourself).	layout rootGOs do: [:each | each recursivelyAddTo: interface].</body><body package="GF/ST GraphLayout">test2a	"	GFTreeLayout test2a	"	| interface layout color | 	(layout := self forGraph: FwRootedGraph exampleMediumLabelledTree)		setCreateNodeGOAction: [:nodeGO |				nodeGO cacheFlag: false.				nodeGO setGraphicObjects: (					Array with: (GFTextGO text: nodeGO node value name)				).			];		setCreateLineGOAction: layout lineGOAction;		setCreateLabelGOAction: [:nodeLine :label |				label == #normal ifTrue: [color := Color yellow].				label == #variable ifTrue: [color := Color red].				label == #variableByte ifTrue: [color := Color blue].				(nodeLine key key edgeTo: nodeLine key value)					color: color.			].	layout 		setMinParentChildSpace: 20 ;		setMinSiblingSpace: 10 ;		setMargins: 10 ;		layout.	interface := GFDrawingInterface openOn: (GFDrawing new 																			drawingExtent: layout graphExtent;																			visibleArea: (0@0 extent: layout graphExtent);																			yourself).	layout rootGOs do: [:each | each recursivelyAddTo: interface].	interface redraw.</body></methods><methods><class-id>Polymorphic.FwDynamicGraphLayoutBounds</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addForcesTo: currentNode    | dist large |    large := MaxForce / 2.0.    (dist := currentNode left - self bounds left) &lt; 0.0        ifTrue: [currentNode addForce:                    ((((0.0 - dist) * self wallForce) + (self margin * self marginForce))min: large) @ 0.0]        ifFalse: [dist &lt; self margin            ifTrue: [currentNode addForce:                        ((self margin - dist) * self marginForce) @ 0.0]].    (dist := currentNode right - self bounds right) &gt; 0.0        ifTrue: [currentNode addForce:                    ((((0.0 - dist) * self wallForce) + (self margin * self marginForce))max: large negated) @ 0.0]        ifFalse: [(0.0 - dist) &lt; self margin            ifTrue: [currentNode addForce:                        ((self margin negated - dist) * self marginForce) @ 0.0]].    (dist := currentNode top - self bounds top) &lt; 0.0        ifTrue: [currentNode addForce:                    0.0 @ ((((0.0 - dist) * self wallForce) + (self margin * selfmarginForce)) min: large)]        ifFalse: [dist &lt; self margin            ifTrue: [currentNode addForce:                        0.0 @ ((self margin - dist) * self marginForce)]].    (dist := currentNode bottom - self bounds bottom) &gt; 0.0        ifTrue: [currentNode addForce:                    0.0 @ ((((0.0 - dist) * self wallForce) + (self margin * selfmarginForce)) max: large negated)]        ifFalse: [(0.0 - dist) &lt; self margin            ifTrue: [currentNode addForce:                        0.0 @ ((self margin negated - dist) * self marginForce)]]</body><body package="GF/ST GraphLayout">bottom    ^self bounds bottom</body><body package="GF/ST GraphLayout">bounds    "Answer the bounds of the receiver."    ^bounds</body><body package="GF/ST GraphLayout">bounds: aRectangle    "Set the receiver's bounds to be &lt;aRectangle&gt;."    bounds := aRectangle</body><body package="GF/ST GraphLayout">center    ^self bounds center</body><body package="GF/ST GraphLayout">graph    ^graph</body><body package="GF/ST GraphLayout">graph: aGraph    graph := aGraph</body><body package="GF/ST GraphLayout">height    ^self bounds height</body><body package="GF/ST GraphLayout">left    ^self bounds left</body><body package="GF/ST GraphLayout">margin    "Answer the margin of the receiver."    ^margin</body><body package="GF/ST GraphLayout">margin: aNumber    "Set the receiver's margin to be &lt;aNumber&gt;."    margin := aNumber</body><body package="GF/ST GraphLayout">marginForce    "Answer the margin force of the receiver."    ^marginForce</body><body package="GF/ST GraphLayout">marginForce: anObject    "Set the receiver's margin force to be &lt;anObject&gt;."    marginForce := anObject</body><body package="GF/ST GraphLayout">right    ^self bounds right</body><body package="GF/ST GraphLayout">setBounds: aRectangle    | ext |    ext := aRectangle extent.    self bounds: aRectangle.    self margin: (ext x min: ext y) asFloat / 10.0.    self wallForce: (ext x min: ext y) asFloat / 15.0.    self marginForce: 1.0</body><body package="GF/ST GraphLayout">top    ^self bounds top</body><body package="GF/ST GraphLayout">wallForce    "Answer the wall force of the receiver."    ^wallForce</body><body package="GF/ST GraphLayout">wallForce: anObject    "Set the receiver's wall force to be &lt;anObject&gt;."    wallForce := anObject</body><body package="GF/ST GraphLayout">width    ^self bounds width</body></methods><methods><class-id>Polymorphic.FwDAGLayout</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">buildExtents	| eBlock |	eBlock := horizontal						ifTrue: [ [ :node | extentAction evaluateWith: node ] ] 						ifFalse: [ [ :node | (extentAction evaluateWith: node) transpose] ].	extents := FwDictionaryWithDefault newWithDefaultValueBlock: eBlock</body><body package="GF/ST GraphLayout">graph	^graph</body><body package="GF/ST GraphLayout">graphExtent	^graphExtent</body><body package="GF/ST GraphLayout">horizontal	horizontal := true.	self initializeConnectionActions</body><body package="GF/ST GraphLayout">initialize	sideMargin := 10.	leafMargin := 10.	rootMargin := 10.	minPCspace := 10.	minSiblingSpace := 10.	horizontal := true.	self initializeConnectionActions</body><body package="GF/ST GraphLayout">initializeConnectionActions	horizontal		ifTrue: [			inAction := [ :nodAssoc :extent | 0 @ (extent y * 0.5) ].			outAction := [ :nodeAssoc :extent | (extent x) @ (extent y * 0.5) ]		]		ifFalse: [			inAction := [ :nodeAssoc :extent | (extent y * 0.5) @ 0 ].			outAction := [ :nodeAssoc :extent | (extent y * 0.5) @ (extent x) ]		]</body><body package="GF/ST GraphLayout">isHorizontal	^horizontal</body><body package="GF/ST GraphLayout">isVertical	^horizontal not</body><body package="GF/ST GraphLayout">layout	self layoutNodes; layoutLinesAndLabels.</body><body package="GF/ST GraphLayout">layoutLinesAndLabels	"Layout the lines' endpoints."	| start end lineAssoc nodeAssoc | 	positions keysAndValuesDo: [ :node :position |		node neighborsAndLabelsDo: [ :succ : label |			start := (position + (outAction 												evaluateWith: (node =&gt; succ) 												with: (extents at: node))) rounded.			end := ((positions at: succ) + (inAction 																evaluateWith: (succ =&gt; node)																with: (extents at: succ))) rounded.			lineAction				evaluateWith: (nodeAssoc := node =&gt; succ)				with: (lineAssoc := start =&gt; end).			label isNil ifFalse: [				labelAction					evaluateWith: (nodeAssoc =&gt; lineAssoc)					with: label.			].		]	]</body><body package="GF/ST GraphLayout">layoutNodes	"Layout the positions of the nodes in the graph."	| 	nodeOrder	heights	widths	maxHeight	maxItems	startX	extraYspace	totalHeight	maxWidth	thisHeight	nodes	yInc	startY	extent	pos	|	"First work out the breakdown into 'rows' and 'columns'."	nodeOrder := graph orderNodes.	self buildExtents.	"Calculate the height and maximum width of each column."	heights := Array new: nodeOrder size.	widths := Array new: nodeOrder size.	1 to: nodeOrder size do: [ :depth |		totalHeight := maxWidth := 0.		(nodeOrder at: depth) do: [ :v |			extent := (extents at: v).			totalHeight := totalHeight + extent y.			maxWidth := maxWidth max: extent x		].		heights at: depth put: totalHeight.		widths at: depth put: maxWidth	].		"Calculate the maximum height and number of items in	 the highest column. If there is more than column of the	 maximum height, take the highest number of items found.	"	maxHeight := 0.  maxItems := 0.	1 to: nodeOrder size do: [ :depth | 		(thisHeight := heights at: depth) &gt; maxHeight			ifTrue: [				maxHeight := thisHeight.				maxItems := maxItems max: (nodeOrder at: depth) size			]			ifFalse: [				thisHeight = maxHeight ifTrue: [					maxItems := maxItems max: (nodeOrder at: depth) size				]			]	].	"At last we can position each node.  Space is distributed evenly amongst nodes."	positions := Dictionary new.	extraYspace := (maxItems - 1) * minSiblingSpace.	maxHeight := maxHeight + extraYspace.	startX := rootMargin.	1 to: nodeOrder size do: [ :depth |		nodes := nodeOrder at: depth.		yInc := (maxHeight - (heights at: depth)) / nodes size.		startY := sideMargin + (yInc * 0.5).		nodes do: [ :node |			pos := (startX @ startY) rounded.			horizontal ifFalse: [pos := pos transpose].			positions at: node put: pos.			startY := startY + yInc + (extents at: node) y		].		startX := startX + (widths at: depth) + minPCspace	].	"This is the size of the whole thing."	graphExtent := (startX - minPCspace + leafMargin) 										@ ((sideMargin)* 2 + maxHeight).	horizontal ifFalse: [graphExtent := graphExtent transpose]</body><body package="GF/ST GraphLayout">leafMargin	^leafMargin</body><body package="GF/ST GraphLayout">minParentChildspace	^minPCspace</body><body package="GF/ST GraphLayout">minSiblingSpace	^minSiblingSpace</body><body package="GF/ST GraphLayout">nodesAndPositionsDo: aTwoArgBlock	positions keysAndValuesDo: aTwoArgBlock</body><body package="GF/ST GraphLayout">positions	^positions</body><body package="GF/ST GraphLayout">rootMargin	^rootMargin</body><body package="GF/ST GraphLayout">setExtentAction: anAction	extentAction := anAction</body><body package="GF/ST GraphLayout">setGraph: anFwRootedGraph	graph := anFwRootedGraph</body><body package="GF/ST GraphLayout">setInAction: anAction	inAction := anAction</body><body package="GF/ST GraphLayout">setLabelAction: anAction	"The labelAction is an action which takes two arguments.	 The first argument is ((node =&gt; successor) =&gt; label).	 The second argument is (startPosition =&gt; endPosition) which is the line connecting them.	"	labelAction := anAction</body><body package="GF/ST GraphLayout">setLeafMargin: anInteger	leafMargin := anInteger</body><body package="GF/ST GraphLayout">setLineAction: anAction	"The lineAction is an action which takes two arguments.	 The first argument is (node =&gt; successor).	 The second argument is (startPosition =&gt; endPosition).	"	lineAction := anAction</body><body package="GF/ST GraphLayout">setMargins: anInteger	sideMargin := anInteger.	leafMargin := anInteger.	rootMargin := anInteger</body><body package="GF/ST GraphLayout">setMinParentChildSpace: anInteger	minPCspace := anInteger</body><body package="GF/ST GraphLayout">setMinSiblingSpace: anInteger	minSiblingSpace := anInteger</body><body package="GF/ST GraphLayout">setOutAction: anAction	outAction := anAction</body><body package="GF/ST GraphLayout">setRootMargin: anInteger	rootMargin := anInteger</body><body package="GF/ST GraphLayout">setSideMargin: anInteger	sideMargin := anInteger</body><body package="GF/ST GraphLayout">sideMargin	^sideMargin</body><body package="GF/ST GraphLayout">vertical	horizontal := false.	self initializeConnectionActions</body></methods><methods><class-id>Polymorphic.FwDAGLayout class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">forGraph: anFwRootedGraph	^self new setGraph: anFwRootedGraph</body><body package="GF/ST GraphLayout">new	^super new initialize</body></methods><methods><class-id>Polymorphic.GFGraphNode</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addEdge: lineGO to: aGFGraphNode	edges at: aGFGraphNode put: lineGO</body><body package="GF/ST GraphLayout">addTo: anInterface	| nextGos |		nextGos := OrderedCollection new.	anInterface quietlyAddGO: self.	edges isNil ifTrue: [^#()].	edges do: [:each |		anInterface quietlyAddGO: each.		nextGos add: each stopObject	].	^nextGos</body><body package="GF/ST GraphLayout">edgeTo: aGFGraphNode	^edges at: aGFGraphNode</body><body package="GF/ST GraphLayout">isGFGraphNode	^true</body><body package="GF/ST GraphLayout">node	^node</body><body package="GF/ST GraphLayout">point: aPoint	^aPoint</body><body package="GF/ST GraphLayout">recursivelyAddTo: anInterface	| queue |	queue := OrderedCollection new.	queue add: self.	[queue isEmpty] whileFalse: [		queue addAll: (queue removeFirst addTo: anInterface).	].	self redraw.</body><body package="GF/ST GraphLayout">setGraph: anFWGraph	graph := anFWGraph</body><body package="GF/ST GraphLayout">setNode: aNode	node := aNode.	edges := Dictionary new.</body></methods><methods><class-id>Polymorphic.GFGraphNode</class-id> <category>printing</category><body package="GF/ST GraphLayout">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' : '.	node printOn: aStream</body></methods><methods><class-id>Polymorphic.GFGraphNode class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">forNode: anFwGraphNode graph: anFwGraph	^self new setNode: anFwGraphNode; setGraph: anFwGraph</body></methods><methods><class-id>Polymorphic.AbstractDAGComposer</class-id> <category>private</category><body package="GF/ST GraphLayout">initializeConnectionBlocks	horizontal		ifTrue:			[inBlock := [ :nodAssoc :extent | 0@(extent y * 0.5)].			outBlock := [ :nodeAssoc :extent | (extent x)@(extent y * 0.5)]]		ifFalse:			[inBlock := [ :nodeAssoc :extent | (extent y * 0.5)@0].			outBlock := [ :nodeAssoc :extent | (extent y * 0.5)@(extent x)]]</body><body package="GF/ST GraphLayout">leafMargin	^leafMargin</body><body package="GF/ST GraphLayout">minParentChildSpacing	^minPCspace</body><body package="GF/ST GraphLayout">minSiblingSpacing	^minSiblingSpace</body><body package="GF/ST GraphLayout">rootMargin	^rootMargin</body><body package="GF/ST GraphLayout">sideMargin	^sideMargin</body></methods><methods><class-id>Polymorphic.AbstractDAGComposer</class-id> <category>initialization-connections</category><body package="GF/ST GraphLayout">inBlock: aBlock	"This block can be used to calculate the end point of an edge entering a node.	The block will be passed:		1 Association 			key:  the view of the node at the end of the edge			value: the view of the node at the start of the edge		3 the extent of the bounding box of node 1.	See initializeConnectionBlocks for example.  Note that the extent is transposed if the graph is vertical."	inBlock := aBlock</body><body package="GF/ST GraphLayout">outBlock: aBlock	"This block can be used to calculate the start point of an edge leaving a node.	The block will be passed:		1 the view of the node at the start of the edge		2 the view of the node at the end of the edge		3 the extent of the bounding box of node 1.	See initializeConnectionBlocks for example.  Note that the extent is transposed if the graph is vertical."	outBlock := aBlock</body></methods><methods><class-id>Polymorphic.AbstractDAGComposer</class-id> <category>private-composing</category><body package="GF/ST GraphLayout">buildExtents	"extents will cache the maximum extent of a node in the plane."	| eBlock |	eBlock := horizontal				ifTrue: [[ :node | extentBlock value: (views at: node value)]] 				ifFalse: [[ :node | (extentBlock value: (views at: node value)) transpose]].	extents := FwDictionaryWithDefault newWithDefaultValueBlock: eBlock</body><body package="GF/ST GraphLayout">compose	"Before composing you must supply:		graph		extentBlock	Other items have default values."	Cursor wait showWhile:		[self positionNodes.		self positionLines.		self positionLabels]</body><body package="GF/ST GraphLayout">positionLabels	"Having placed the nodes and lines, now place the labels."	labelPositions := Dictionary new.	labelPositionBlock isNil ifTrue: [^self].	"no labels wanted"	self linesDo: [ :line :label |		label notNil			ifTrue: [labelPositions at: label put: (labelPositionBlock value: line value: label)]]</body><body package="GF/ST GraphLayout">positionLines	"Having placed the nodes, now calculate the lines' endpoints."	| nodeView succView start end labelView |	lines := OrderedCollection new.	self nodesAndPositionsDo: [ :node :position |		nodeView := views at: node value.		node neighborsAndLabelsDo: [ :succ : label |			succView := views at: succ value.			start := position 					+ (outBlock value: (nodeView =&gt; succView) value: (extents at: node)).			end := (positions at: succ)					+ (inBlock value: (succView =&gt; nodeView) value: (extents at: succ)).			labelView := label isNil ifFalse: [labels at: (Array with: (node =&gt; succ) with: label)].			lines add:				(Array with: (start =&gt; end) with: labelView)]]</body><body package="GF/ST GraphLayout">positionNodes	"Calculate the positions of the nodes in the graph."	self subclassResponsibility</body></methods><methods><class-id>Polymorphic.AbstractDAGComposer</class-id> <category>initialization</category><body package="GF/ST GraphLayout">centeredTextLabels	"Set label positioning to center on line."	| extent |	labelPositionBlock :=		[ :assoc :label |			extent := label extent.			(assoc key + assoc value - extent) // 2]</body><body package="GF/ST GraphLayout">extentBlock: e	extentBlock := e</body><body package="GF/ST GraphLayout">graph: g	graph := g</body><body package="GF/ST GraphLayout">horizontal	horizontal := true.	self initializeConnectionBlocks</body><body package="GF/ST GraphLayout">initialize	sideMargin := 10.	leafMargin := 10.	rootMargin := 10.	minPCspace := 10.	minSiblingSpace := 10.	horizontal := true.	self initializeConnectionBlocks</body><body package="GF/ST GraphLayout">labels: labelMap	labels := labelMap</body><body package="GF/ST GraphLayout">leafMargin: t	"Minimum space between leaves and frame."	leafMargin := t</body><body package="GF/ST GraphLayout">margins: m	sideMargin := m.	leafMargin := m.	rootMargin := m</body><body package="GF/ST GraphLayout">minParentChildSpacing: s	minPCspace := s</body><body package="GF/ST GraphLayout">minSiblingSpacing: s	minSiblingSpace := s</body><body package="GF/ST GraphLayout">orientation: symbol	horizontal := symbol == #horizontal.	self initializeConnectionBlocks</body><body package="GF/ST GraphLayout">rootMargin: t	"Space between roots and frame."	rootMargin := t</body><body package="GF/ST GraphLayout">sideMargin: t	"Minimum space between nodes and sides of frame (not leaf or root sides)."	sideMargin := t</body><body package="GF/ST GraphLayout">vertical	horizontal := false.	self initializeConnectionBlocks</body><body package="GF/ST GraphLayout">views: map	views := map</body></methods><methods><class-id>Polymorphic.AbstractDAGComposer</class-id> <category>accessing</category><body package="GF/ST GraphLayout">graphExtent	^graphExtent</body><body package="GF/ST GraphLayout">labelsAndPositionsDo: aBlock	"Evaluate aBlock for each label in the graph and its position."	labelPositions keysAndValuesDo: aBlock</body><body package="GF/ST GraphLayout">linesDo: aBlock	"Evaluate aBlock for each line's start and end point, and label (nil if none)."	lines do: [ :line | aBlock valueWithArguments: line]</body><body package="GF/ST GraphLayout">nodeViewsAndPositionsDo: aBlock	"Evaluate aBlock for each node in the graph and its position."	positions keysAndValuesDo: [ :node :position |		aBlock value: (views at: node value) value: position]</body><body package="GF/ST GraphLayout">nodesAndPositionsDo: aBlock	"Evaluate aBlock for each node in the graph and its position."	positions keysAndValuesDo: aBlock</body></methods><methods><class-id>Polymorphic.AbstractDAGComposer</class-id> <category>testing</category><body package="GF/ST GraphLayout">orientation	^horizontal ifTrue: [#horizontal] ifFalse: [#vertical]</body></methods><methods><class-id>Polymorphic.AbstractDAGComposer class</class-id> <category>instance creation</category><body package="GF/ST GraphLayout">new	^super new initialize</body></methods><methods><class-id>Polymorphic.DAGComposer</class-id> <category>private-composing</category><body package="GF/ST GraphLayout">nodeOrdering	"This method lays out the nodes into rows.  All nodes at the same depth in the DAG are on the same row.  The ordering within a row is determined by 'closeness' to predecessors."	| dl depths weights roots inc p rootList i node dld max sc |	"First partition the graph into sets of nodes at the same depth."	dl := graph depthList.	"Next build a map from nodes to depths."	depths := Dictionary new.	1 to: dl size do: [ :depth |		(dl at: depth) do: [ :nodex |			node := nodex. depths at: node put: depth]].	"The rest of the method calculates the ordering of nodes at a particular depth.	To do this, it weights each node with the sum of the weights of its immediate predecessors, and then orders by weight.	When weighting a node, this particular implementation only considers predecessors with depth one less than the node (should be fixed)."	weights := FwDictionaryWithDefault newWithDefaultValue: 0.0.	"First order the roots (nodes with depth 1).  This uses the ordering supplied by the graph."	roots := graph rootNodes.	p := inc := (roots size + 1.0) reciprocal.	rootList := Array new: roots size.	i := 1.	graph rootNodes do: [ :n |		weights at: n put: p.  p := p + inc.		rootList at: i put: n.  i := i + 1].	dl at: 1 put: rootList.	"Next weight each node at each depth based on the weights of the predecessors."	1 to: dl size - 1 do: [ :depth |		dld := dl at: depth.		1 to: dld size do: [ :li |			node := dld at: li.			node neighborsDo: [ :succ |				(depths at: succ) = (depth + 1)					ifTrue: [weights at: succ replace: [ :old | old + li]]]].		dl at: depth + 1 replace: [ :dln |			"The weights are normalised to be in the range (0,1)."			max := dln inject: 0.0 into: [ :maxSoFar :n | maxSoFar max: (weights at: n)].			dln do: [ :n | weights at: n replace: [ :old | old / max]].			"Sort by weight."			sc := SortedCollection sortBlock: [ :x :y | (weights at: x) &lt;= (weights at: y)].			sc addAll: dln.			sc asArray]].	^dl</body><body package="GF/ST GraphLayout">positionNodes	"Calculate the positions of the nodes in the graph."	| dl heights widths maxH maxItems startX extraYspace totalH maxW thisH nodes yInc startY extent pos |	"First work out the breakdown into 'rows' and 'columns'."	dl := self nodeOrdering.	self buildExtents.	"Calculate the height and maximum width of each column (imagine left-to-right layout)."	heights := Array new: dl size.	widths := Array new: dl size.	1 to: dl size do: [ :depth |		totalH := maxW := 0.		(dl at: depth) do: [ :v |			extent := (extents at: v).			totalH := totalH + extent y.			maxW := maxW max: extent x].		heights at: depth put: totalH.		widths at: depth put: maxW].		"Now calculate the maximum height and number of items in the highest column.	If there is more than column of the maximum height, take the highest number of items found."	maxH := 0.  maxItems := 0.	1 to: dl size do: [ :depth |		thisH := heights at: depth.		thisH &gt; maxH ifTrue: [maxH := thisH.  maxItems := (dl at: depth) size].		thisH = maxH ifTrue: [maxItems := maxItems max: (dl at: depth) size]].	"At last we can position each node.  Space is distributed evenly amongst nodes."	positions := Dictionary new.	extraYspace := (maxItems - 1) * self minSiblingSpacing.	maxH := maxH + extraYspace.	startX := self rootMargin.	1 to: dl size do: [ :depth |		nodes := dl at: depth.		yInc := (maxH - (heights at: depth)) / nodes size.		startY := self sideMargin + (yInc * 0.5).		nodes do: [ :node |			pos := (startX @ startY) rounded.			horizontal ifFalse: [pos := pos transpose].			positions at: node put: pos.			startY := startY + yInc + (extents at: node) y].		startX := startX + (widths at: depth) + self minParentChildSpacing].	"This is the size of the whole thing."	graphExtent := (startX - self minParentChildSpacing + self leafMargin) 					@ ((self sideMargin)* 2 + maxH).	horizontal ifFalse: [graphExtent := graphExtent transpose]</body></methods><methods><class-id>Polymorphic.FwDictionaryWithDefault</class-id> <category>initialization</category><body package="GF/ST GraphLayout">defaultBlock: aBlock	defaultBlock := aBlock</body></methods><methods><class-id>Polymorphic.FwDictionaryWithDefault</class-id> <category>accessing</category><body package="GF/ST GraphLayout">associationAt: key 	"Answer the association at key."	^super associationAt: key ifAbsent:		[| value |		value := defaultBlock value: key.		super at: key put: value.		super associationAt: key]</body><body package="GF/ST GraphLayout">at: key 	"Answer the value at key."	^super at: key ifAbsent:		[| value |		value := defaultBlock value: key.		super at: key put: value.		super at: key]</body></methods><methods><class-id>Polymorphic.FwDictionaryWithDefault</class-id> <category>copying</category><body package="GF/ST GraphLayout">copyEmpty: aSize	^(super copyEmpty: aSize) defaultBlock: defaultBlock</body></methods><methods><class-id>Polymorphic.FwDictionaryWithDefault class</class-id> <category>examples</category><body package="GF/ST GraphLayout">example	"FwDictionaryWithDefault example"	"| d |	d := FwDictionaryWithDefault example.	d at: #foo put: 2.	Transcript show: (d at: #foo) printString ; space ; show: (d at: #bar) printString"	"A dictionary of symbols whose default value is the number of characters in the symbol."	^FwDictionaryWithDefault newWithDefaultValueBlock: [ :key | key size]</body><body package="GF/ST GraphLayout">example2	"FwDictionaryWithDefault example2"	"| d |	d := FwDictionaryWithDefault example2.	#(1 2 3 5 7 11 13 17 19) do: [ :n | d at: n put: 1].	1 to: 20 do: [ :n | Transcript show: (d at: n) printString ; space]"	"A dictionary of whose default value is 0."	^FwDictionaryWithDefault newWithDefaultValue: 0</body></methods><methods><class-id>Polymorphic.FwDictionaryWithDefault class</class-id> <category>instance creation</category><body package="GF/ST GraphLayout">newIdentity	"Default map is identity."	^self newWithDefaultValueBlock: [ :x | x]</body><body package="GF/ST GraphLayout">newWithDefaultValue: aValue	^super new defaultBlock: [ :ignored | aValue]</body><body package="GF/ST GraphLayout">newWithDefaultValueBlock: aBlock	^super new defaultBlock: aBlock</body></methods><methods><class-id>Polymorphic.FwGraph</class-id> <category>queries</category><body package="GF/ST GraphLayout">includes: anObject    "Answer whether anObject is one of the receiver's elements."    ^nodes includes: anObject</body><body package="GF/ST GraphLayout">isEmpty    "Answer whether the receiver contains any elements."    ^nodes isEmpty</body><body package="GF/ST GraphLayout">isImplicit    "Is the node creator for implicit nodes?"    ^(type includes: #implicitCollection) or: [type includes: #implicitIteratorBlock]</body><body package="GF/ST GraphLayout">isLabelled    "Is the node creator for labelled nodes?"    ^type includes: #labelled</body><body package="GF/ST GraphLayout">nodeFor: anObject	^nodes at: anObject</body><body package="GF/ST GraphLayout">numberOfEdges    "This is commonly known as the size of the graph, but the	 size message returns the order (number of vertices), as	 this fits in better with Smalltalk usage.	"    ^(FwIterator on: self msg: #edgesDo:) size</body><body package="GF/ST GraphLayout">occurrencesOf: anObject    "Answer how many of the receiver's elements are equal to anObject."    ^(self includes: anObject) ifTrue: [1] ifFalse: [0]</body></methods><methods><class-id>Polymorphic.FwGraph</class-id> <category>iteration</category><body package="GF/ST GraphLayout">do: aBlock    self nodesDo: aBlock</body><body package="GF/ST GraphLayout">edgesDo: aBlock    self nodesDo: [ :node | node neighborsDo: [ :n | aBlock value: node =&gt; n ] ]</body><body package="GF/ST GraphLayout">nodesDo: aBlock    "No particular order."    nodes do: aBlock</body><body package="GF/ST GraphLayout">valuesDo: aBlock    "No particular order."    nodes do: [ :node | aBlock value: node value]</body></methods><methods><class-id>Polymorphic.FwGraph</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addNode: value    "Create a new GraphNode for the value (if necessary), and add it to the graph.	 You shouldn't be calling this unless you're sure what you're doing.  Better	 to add nodes by adding edges.	"    ^nodes at: value ifAbsent: [self add: (self newNodeOn: value)]</body><body package="GF/ST GraphLayout">arity: n    type := #(arity).    nodeCreator := (InitializationBlocks at: #arity) value: n</body><body package="GF/ST GraphLayout">arityLabelled: n    type := #(arity labelled).    nodeCreator := (InitializationBlocks at: #arityLabelled) value: n</body><body package="GF/ST GraphLayout">binary    type := #(binary).    nodeCreator := InitializationBlocks at: #binary</body><body package="GF/ST GraphLayout">binaryLabelled    type := #(binary labelled).    nodeCreator := InitializationBlocks at: #binaryLabelled</body><body package="GF/ST GraphLayout">implicitCollection: collectionBlock    type := #(implicitCollection).    nodeCreator := (InitializationBlocks at: #implicitCollection) 								value: self value: collectionBlock</body><body package="GF/ST GraphLayout">implicitIteratorBlock: iteratorBlock    type := #(implicitIteratorBlock).    nodeCreator := (InitializationBlocks at: #implicitIteratorBlock)								value: self value: iteratorBlock</body><body package="GF/ST GraphLayout">initialize    nodes := FwKeyedSet new</body><body package="GF/ST GraphLayout">newNodeOn: object    ^nodeCreator value: object</body><body package="GF/ST GraphLayout">nodeCreator: n    nodeCreator := n</body><body package="GF/ST GraphLayout">ordered    type := #(ordered).    nodeCreator := InitializationBlocks at: #ordered</body><body package="GF/ST GraphLayout">orderedLabelled    type := #(ordered labelled).    nodeCreator := InitializationBlocks at: #orderedLabelled</body><body package="GF/ST GraphLayout">removeEdgeFromNode: srcNode toNode: destNode ifAbsent: exceptionBlock    "Remove the given edge, evaluate exceptionBlock if it doesn't exist.     Assumes both the source and target of the edge must be in the graph.	"    (srcNode hasEdgeTo: destNode)        ifTrue: [			srcNode removeNeighbor: destNode.         	^self		]        ifFalse: [^exceptionBlock value]</body><body package="GF/ST GraphLayout">unordered    type := #(unordered).    nodeCreator := InitializationBlocks at: #unordered</body><body package="GF/ST GraphLayout">unorderedLabelled    type := #(unordered labelled).    nodeCreator := InitializationBlocks at: #unorderedLabelled</body></methods><methods><class-id>Polymorphic.FwGraph</class-id> <category>accessing</category><body package="GF/ST GraphLayout">edges    ^OrderedCollection accumulate: [ :incBlock | self edgesDo: incBlock]</body><body package="GF/ST GraphLayout">order    ^nodes size</body><body package="GF/ST GraphLayout">size    "The order of the graph."    ^nodes size</body></methods><methods><class-id>Polymorphic.FwGraph</class-id> <category>construction</category><body package="GF/ST GraphLayout">add: aGraphNode    ^nodes add: aGraphNode</body><body package="GF/ST GraphLayout">addEdge: edge    "Add an edge (represented by an Association)"    self addEdgeFrom: edge key to: edge value.    ^edge</body><body package="GF/ST GraphLayout">addEdge: edge label: label    "Add an edge (represented by an Association), with given label.     Assumes: (self nodeFor: edge key) isLabelled	"    self addEdgeFrom: edge key to: edge value label: label.    ^edge</body><body package="GF/ST GraphLayout">addEdgeFrom: source to: target    | src trgt |    src := self addNode: source.    trgt := self addNode: target.    src addNeighbor: trgt</body><body package="GF/ST GraphLayout">addEdgeFrom: source to: target label: label    "Assumes: (self nodeFor: edge key) isLabelled"    | src trgt |    src := self addNode: source.    trgt := self addNode: target.    src addNeighbor: trgt label: label</body><body package="GF/ST GraphLayout">remove: aGraphNode    "Remove the given node.     Assumes the node must be in the graph, and not the target of an edge.	"    ^self remove: aGraphNode ifAbsent: [self notFoundError]</body><body package="GF/ST GraphLayout">remove: aGraphNode ifAbsent: exceptionBlock    "Remove the given node, evaluate exceptionBlock if it's not part of the graph.	 Assumes the node shouldn't be the target of an edge.	"    ^nodes remove: aGraphNode ifAbsent: exceptionBlock</body><body package="GF/ST GraphLayout">removeEdge: edge    "Remove the given edge.     Assumes the edge must be in the graph.	"    ^self removeEdge: edge ifAbsent: [self notFoundError]</body><body package="GF/ST GraphLayout">removeEdge: edge ifAbsent: exceptionBlock    "Remove the given edge, evaluate exceptionBlock if it doesn't exist.     Assumes both the source and target of the edge must be in the graph.	"    ^self        removeEdgeFrom: edge key        to: edge value        ifAbsent: exceptionBlock</body><body package="GF/ST GraphLayout">removeEdgeFrom: src to: dest    "Remove the given edge.     Assumes the edge must be in the graph.	"    ^self removeEdgeFrom: src to: dest ifAbsent: [self notFoundError]</body><body package="GF/ST GraphLayout">removeEdgeFrom: src to: dest ifAbsent: exceptionBlock    "Remove the given edge.     Assumes both the source and target of the edge must be in the graph.	"    ^self 		removeEdgeFromNode: (self nodeFor: src)		toNode: (self nodeFor: dest)		ifAbsent: exceptionBlock</body></methods><methods><class-id>Polymorphic.FwGraph</class-id> <category>copying</category><body package="GF/ST GraphLayout">copyEmpty    "Return a graph of the same type with no nodes or edges."    ^self isImplicit        ifTrue: [self class ordered]        ifFalse: [self copy initialize]</body><body package="GF/ST GraphLayout">copyNodes: nodeBlock    "Make a copy with the same number of nodes and edges.     Each node is self is mapped though nodeBlock	"    ^self copyNodes: nodeBlock labels: nil</body><body package="GF/ST GraphLayout">copyNodes: nodeBlock  labels: labelBlock    "Make a copy with the same number of nodes and edges.     Each node is self is mapped though nodeBlock, labels (if used) are     mapped through labelBlock (if non-nil).	"    | newGraph map |    newGraph := self copyEmpty.    map := FwDictionaryWithDefault newWithDefaultValueBlock: nodeBlock.    self do: [ :node |        node neighborsAndLabelsDo: [ :n :label |            (labelBlock notNil and: [label notNil])                ifTrue: [					newGraph                 		addEdgeFrom: (map at: node value)                     	to: (map at: n value)                    	label: (labelBlock value: label)				]                ifFalse: [					newGraph                 		addEdgeFrom: (map at: node value)                    	to: (map at: n value)				]		]	].    ^newGraph</body></methods><methods><class-id>Polymorphic.FwGraph class</class-id> <category>instance creation</category><body package="GF/ST GraphLayout">arity: n    "Create a new ordered graph with fixed arity."    ^super new initialize arity: n</body><body package="GF/ST GraphLayout">arityLabelled: n    "Create a new labelled, ordered graph with fixed arity."    ^super new initialize arityLabelled: n</body><body package="GF/ST GraphLayout">binary    "Create an ordered graph with arity of 2 (ie each vertex has	 exactly two connecting edges).	"    ^super new initialize binary</body><body package="GF/ST GraphLayout">binaryLabelled    "Create an labelled, ordered graph with arity of 2 (ie each vertex has exactly	 two connecting edges).	"    ^super new initialize binaryLabelled</body><body package="GF/ST GraphLayout">implicitCollection: collectionBlock    "Create a new graph, using the structure implicit in existing objects.     Each node is the graph is accessed by evaluating collectionBlock to yield a	 collection of neighboring nodes.	"    ^super new initialize implicitCollection: collectionBlock</body><body package="GF/ST GraphLayout">implicitIteratorBlock: iteratorBlock    "Create a new graph, using the structure implicit in existing objects.     Each node is the graph is accessed by evaluating iteratorBlock to iterate over 	 a collection of neighboring nodes.	"    ^super new initialize implicitIteratorBlock: iteratorBlock</body><body package="GF/ST GraphLayout">new    ^self error: 'Graphs should not be created with new.'</body><body package="GF/ST GraphLayout">ordered    "Create a new ordered graph."    ^super new initialize ordered</body><body package="GF/ST GraphLayout">orderedLabelled    "Create a new labelled, ordered graph."    ^super new initialize orderedLabelled</body><body package="GF/ST GraphLayout">unordered    "Create a new unordered graph."    ^super new initialize unordered</body><body package="GF/ST GraphLayout">unorderedLabelled    "Create a new labelled, unordered graph."    ^super new initialize unorderedLabelled</body></methods><methods><class-id>Polymorphic.FwGraph class</class-id> <category>initialization</category><body package="GF/ST GraphLayout">initialize    "FwGraph initialize"    | d  iterator |    d := IdentityDictionary new.    d at: #binary put: [ :value | FwExplicitGraphNode binary: value].    d at: #arity put: [ :n | [ :value | FwExplicitGraphNode on: value arity: n]].    d at: #binaryLabelled put: [ :value | FwLabelledExplicitGraphNode binary: value].    d at: #ordered put: [ :value | FwExplicitGraphNode ordered: value].    d at: #unordered put: [ :value | FwExplicitGraphNode newOn: value].    d at: #arityLabelled put: [ :n | [ :value | FwLabelledExplicitGraphNode on: value arity: n]].    d at: #orderedLabelled put: [ :value | FwLabelledExplicitGraphNode ordered: value].    d at: #unorderedLabelled put: [ :value | FwLabelledExplicitGraphNode newOn: value].    d at: #implicitCollection put: [ :graph :collectionBlock |        [ :value |            FwImplicitGraphNode                on: value                collectionBlock: [(collectionBlock value: value)                                    collect: [ :node | graph addNode: node]]]].    d at: #implicitIteratorBlock put: [ :graph :iteratorBlock |        [ :value |            iterator := iteratorBlock value: value.            FwImplicitGraphNode                on: value                iteratorBlock: [ :aBlock | iterator value: [ :node | aBlock value: (graph addNode: node)]]]].    InitializationBlocks := d</body></methods><methods><class-id>Polymorphic.FwGraph class</class-id> <category>examples</category><body package="GF/ST GraphLayout">exampleGraph    "	FwGraph exampleGraph.	"    | d |    d := self unordered.    d addEdge: #r1 =&gt; #n1.    d addEdge: #r1 =&gt; #n2.    d addEdge: #r2 =&gt; #n2.    d addEdge: #n1 =&gt; #n3.    d addEdge: #n2 =&gt; #n3.    d addEdge: #n3 =&gt; #r1.    ^d</body><body package="GF/ST GraphLayout">exampleImplicitGraph    "	FwGraph exampleImplicitGraph.	"    | tree |    tree := self implicitCollection: [ :class | class subclasses].    Number withAllSubclasses do: [ :class | tree addNode: class].    ^tree</body><body package="GF/ST GraphLayout">exampleImplicitGraph2    "	FwGraph exampleImplicitGraph2	"    | tree |    tree := self implicitIteratorBlock: [ :class | 		[ :aBlock | class subclasses do: aBlock]	].    Number withAllSubclasses do: [ :class | tree addNode: class].    ^tree</body></methods><methods><class-id>Polymorphic.FwRootedGraph</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addEdgeFrom: source to: target    super addEdgeFrom: source to: target.    (roots includes: target) ifTrue: [ roots remove: target ifAbsent: [] ]</body><body package="GF/ST GraphLayout">addEdgeFrom: source to: target label: label    super addEdgeFrom: source to: target label: label.    (roots includes: target) ifTrue: [ roots remove: target ifAbsent: [] ]</body><body package="GF/ST GraphLayout">addRoot: root    "Add root as a root of the graph."    roots add: root.    ^nodes add: (self newNodeOn: root)</body><body package="GF/ST GraphLayout">breadthFirstDo: aBlock    "Evaluate aBlock for each set of nodes at a given	 depth in the graph.  A node is at depth n if the longest	 path to that node from a root has n steps.     Assumes the receiver is acyclic	"    | df current |    df := self frontier.    [current := df frontier copy. current isEmpty] whileFalse: [		aBlock value: current.        df removeAll: current	]</body><body package="GF/ST GraphLayout">buildFromRoots: rootCollection    "Build the graph with given roots.  The nodes should	 all be ImplicitGraphNodes, or have outgoing edges attached.	"    self roots: rootCollection.    self markDo: [ :junk | ]</body><body package="GF/ST GraphLayout">copyEmpty    "Return a new graph of the same type, with the same roots, but no edges."    | copy |    copy := super copyEmpty.    copy roots: (roots copyEmpty: roots size).    ^copy</body><body package="GF/ST GraphLayout">copyNodes: nodeBlock  labels: labelBlock    "Make a copy with the same number of nodes and edges.     Each node is self is mapped though nodeBlock, labels (if used) are     mapped through labelBlock (if non-nil).	"    | newGraph map |    newGraph := self copyEmpty.    map := FwDictionaryWithDefault newWithDefaultValueBlock: nodeBlock.    newGraph roots: (roots collect: [ :root | map at: root]).    self do: [ :node |        node neighborsAndLabelsDo: [ :n :label |            (labelBlock notNil and: [label notNil])                ifTrue: [					newGraph                  		addEdgeFrom: (map at: node value)                 		to: (map at: n value)                 		label: (labelBlock value: label)				]                ifFalse: [					newGraph                		addEdgeFrom: (map at: node value)                    	to: (map at: n value)				]		]	].    ^newGraph</body><body package="GF/ST GraphLayout">depthList    "Partitions the DAG, returning a SequenceableCollection of Sets	 of nodes in  the graph.  Element n in the SequenceableCollection	 is the Set of nodes in the graph reachable in n-1 steps by the	 longest route from a root.	"    ^OrderedCollection accumulate: [ :incBlock | self breadthFirstDo: incBlock]</body><body package="GF/ST GraphLayout">findOrphans    "Find all nodes that are not reachable from the roots."	| orphans |	self findRoots.	orphans := Set new: nodes size.	self nodesDo: [:each | orphans add: each].	self markDo: [:node | orphans remove: node].	^orphans</body><body package="GF/ST GraphLayout">findRoots    "Find all nodes that are not the targets of an edge and make them the roots."    roots := (Set new: nodes size) addAll: (nodes collect: [:each | each value]); yourself.    self nodesDo: [:node |        (self nodeFor: node) neighborsDo: [ :nb |            roots remove: nb value ifAbsent: []		]	]</body><body package="GF/ST GraphLayout">frontier    "Return an FwDAGFrontier object, capable of enumerating this DAG."    ^FwDAGFrontier frontierOn: self</body><body package="GF/ST GraphLayout">initialize    super initialize.    roots := Set new</body><body package="GF/ST GraphLayout">isCyclic    "Is the graph cyclic?"    | frontier remaining  next |    frontier := self rootNodes.    "Build a Bag of non-root nodes, each node once in the Bag for every predecessor."    remaining := Bag new.    nodes do: [ :node | remaining addAll: node neighbors].    [    	next := frontier anyIfNone: [^remaining isEmpty not].    	frontier remove: next.    	next neighborsDo: [ :neighbor |            (remaining removeOne: neighbor) = 0                ifTrue: [frontier add: neighbor]		].    	true    ] whileTrue.</body><body package="GF/ST GraphLayout">isEmpty    "Answer whether the receiver contains any elements."    ^roots isEmpty</body><body package="GF/ST GraphLayout">isTree    "Is the graph a tree (more accurately, a forest)?     It is if every node has at most one predecessor.	"    | visited |    visited := IdentitySet new: nodes size.    nodes do: [ :node |        node neighborsDo: [ :neighbor |            (visited includes: neighbor) ifTrue: [^false].            visited add: neighbor		]	].    ^true</body><body package="GF/ST GraphLayout">markDo: aBlock    "Visit each node in the graph once, applying aBlock.     A node is only visited after at least one of its predecessors,	 but not necessarily  after all the predecessors.	"    | todo visited  node |    todo := self rootNodes asSet.    visited := IdentitySet new: nodes size.    [todo isEmpty] whileFalse: [        node := todo any.        visited add: node.        aBlock value: node.        node neighborsDo: [ :child |      		(visited includes: child) ifFalse: [todo add: child]		].        todo remove: node	]</body><body package="GF/ST GraphLayout">orderNodes	"The receiver is a DAG.  Order the receiver's nodes into rows.	 All nodes at the same depth from the root  are on the same row.	 The ordering within a row is determined by 'closeness' to predecessors.	"	|	depthList	depths	weights	inc	curList	max	i	|	"Partition the graph into sets of nodes at the same depth	 and build a map from nodes to depths." 	depths := Dictionary new.	1 to: (depthList := self depthList) size do: [ :depth |		(depthList at: depth) do: [ :node | depths at: node put: depth]	].	"Calculate the ordering of nodes at a particular depth.	 Set the weight each node to be the sum of the weights of	 its immediate predecessors, and then order by weight.	 When weighting a node, this particular implementation only considers	 predecessors with depth one less than the node (should be fixed).	"	weights := FwDictionaryWithDefault newWithDefaultValue: 0.0.	"Order the roots" 	depthList at: 1 put: (Array new: roots size).	i := 1.	self rootNodes asArray inject: (inc := (roots size + 1.0) reciprocal) into: [ :weight :root |		weights at: root put: weight. 		(depthList at: 1) at: i put: root.		i := i + 1.		weight + inc.	].	"Weight each node at each depth based on the weights of the predecessors."	1 to: depthList size - 1 do: [ :depth |		curList := depthList at: depth.		1 to: curList size do: [ :i2 |			(curList at: i2) neighborsDo: [ :succ |				(depths at: succ) = (depth + 1)					ifTrue: [ weights at: succ replace: [ :old | old + i2] ]			]		].		depthList at: depth + 1 replace: [ :oldList |			"Normalize the weights to the range (0,1)."			max := oldList inject: 0.0 into: [ :maxSoFar :n | maxSoFar max: (weights at: n) ].			oldList do: [ :n | weights at: n replace: [ :old | old / max] ].			"Sort by weight."			(oldList asSortedCollection: [ :x :y | (weights at: x) &lt;= (weights at: y) ]) asArray		]	].	^depthList</body><body package="GF/ST GraphLayout">preOrderDo: aBlock    "Walk the graph, evaluating aBlock for each node.  Evaluate	 each node before its successors, but in no particular order	 when there is a choice.	 Requires that the receiver is not cyclic!	"    | frontier remaining  next |    frontier := self rootNodes asSet.    "Build a Bag of non-root nodes, each node once in the Bag for every predecessor."    remaining := Bag new.    nodes do: [ :node | remaining addAll: node neighbors].    [    	next := frontier anyIfNone: [^self].    	aBlock value: next.    	frontier remove: next.    	next neighborsDo: [ :neighbor |     		(remaining removeOne: neighbor) = 0        		ifTrue: [frontier add: neighbor]		].    	true    ] whileTrue: [].</body><body package="GF/ST GraphLayout">reduce    "Remove all redundant edges to form the transitive reduction.     Based on Algorithm 4 in 'An Algorithm for Finding a Minimum Equivalent Graph 	 of a Digraph', by D. M. Moyles and G. L. Thompson, JACM 16(3), July 1969, pp455-60 	 (with obvious simplifications for acyclic graphs).	"    self rootNodes do: [ :root | self reduceStep: root with: OrderedCollection new]</body><body package="GF/ST GraphLayout">reduceSlow    "Remove all redundant edges to form the transitive reduction.     Based on Algorithm 4 in 'An Algorithm for Finding a Minimum	 Equivalent Graph of a Digraph', by D. M. Moyles and G. L. Thompson,	 JACM 16(3), July 1969, pp455-60  (with obvious simplifications for acyclic graphs).     This version sometimes builds huge sets!!	"    | seqSet  newSeqSet  tail  |    seqSet := Set accumulate: [ :incBlock |                		self rootNodes do: [ :root | incBlock value: (Array with: root)]					].    [seqSet isEmpty] whileFalse: [         newSeqSet := Set new.        seqSet do: [ :seq |            tail := seq last.            tail neighborsDo: [ :neighbor |                seq do: [ :node |                    (node ~= tail and: [node hasEdgeTo: neighbor])                        ifTrue: [self removeEdgeFrom: node to: neighbor]				].                newSeqSet add: (seq copyWith: neighbor)			]		].        seqSet := newSeqSet	]</body><body package="GF/ST GraphLayout">reduceStep: node with: sofar    node degree = 0 ifTrue: [^self].    node neighbors copy do: [ :succ |        sofar do: [ :done |            (done hasEdgeTo: succ)                ifTrue: [self removeEdgeFrom: done to: succ]		].        sofar addLast: node.        self reduceStep: succ with: sofar.        sofar removeLast	]</body><body package="GF/ST GraphLayout">removeAllFrom: aNode    "Remove the subtree below aNode (and associated edges), excluding aNode itself.     Note that nodes are removed from the graph without being sent any messages.	"    self        walkFrom: aNode        pre: [ :junk | ]        post: [ :child |            child == aNode                ifTrue: [aNode neighbors copy do: [ :n | aNode removeNeighbor: n] ]                ifFalse: [self remove: child]		]</body><body package="GF/ST GraphLayout">rootNode    "Answer the GraphNode for the root.     Assumes roots size = 1	"    ^self nodeFor: roots soleElement</body><body package="GF/ST GraphLayout">rootNodes    "Return the GraphNodes for the roots."    ^roots collect: [ :root | self nodeFor: root]</body><body package="GF/ST GraphLayout">roots	^roots copy</body><body package="GF/ST GraphLayout">roots: aCollection    roots addAll: aCollection.    roots do: [ :root | self addNode: root]</body><body package="GF/ST GraphLayout">roots: rootNodes children: aBlock	"Build the grah with given rootNodes.	 Evaluate aBlock for each node to obtain a Collection of its children.	"		| child |	^self roots: rootNodes childrenGenerator:  [ :node | 		[ :iterationBlock |		child := aBlock value: node. 		child notNil ifTrue: [ child do: iterationBlock] ]	]</body><body package="GF/ST GraphLayout">roots: rootNodes children: aBlock label: labelBlock    "Build the graph with given rootNodes.     Evaluate aBlock for each node to obtain a Collection of its children.	"    ^self        roots: rootNodes        childrenGenerator: [ :node | [ :iterationBlock | (aBlock value: node) do: iterationBlock]]        label: labelBlock</body><body package="GF/ST GraphLayout">roots: rootNodes childrenGenerator: aBlock    "Build the graph with given rootNodes.     Evaluate aBlock for each node to obtain an iterator over a Collection of its 	 children."    ^self roots: rootNodes childrenGenerator: aBlock label: nil</body><body package="GF/ST GraphLayout">roots: rootNodes childrenGenerator: aBlock label: labelBlock    "Build the graph with given rootNodes.     Evaluate aBlock for each node to obtain an iterator over a Collection of its	 children.  Evaluate labelBlock (if not nil) for each node and child to obtain	 a label for  the edge.	"    | todo  node |    self roots: rootNodes.    todo := self roots.    [todo isEmpty] whileFalse: [        node := todo any.        (aBlock value: node) value: [ :child |     		(self includes: child) ifFalse: [todo add: child].        	labelBlock isNil         		ifTrue: [self addEdgeFrom: node to: child]            	ifFalse: [					self 						addEdgeFrom: node						to: child						label: (labelBlock value: node  value: child)				]		].    	todo remove: node	].    ^self</body><body package="GF/ST GraphLayout">roots: rootNodes childrenLabelGenerator: aBlock    "Build the graph with given rootNodes.  Evaluate aBlock for	 each node to obtain an iterator over a Collection of its children and labels.	"    | todo  node |    self roots: rootNodes.    todo := self roots.    [todo isEmpty] whileFalse: [        node := todo any.        (aBlock value: node) value: [ :child :label |       		(self includes: child) ifFalse: [todo add: child].         	self addEdgeFrom: node to: child label: label		].     	todo remove: node	].    ^self</body><body package="GF/ST GraphLayout">roots: rootNodes childrenMsg: msg    "Build the graph with given rootNodes.     Send msg to each node to obtain a Collection of its children.	"    ^self roots: rootNodes childrenGenerator: [ :node |		[ :iterationBlock | (node perform: msg) do: iterationBlock]	]</body><body package="GF/ST GraphLayout">walkFrom: node post: postBlock    "Recursively walk the subtree rooted at node.	 Walk the subtree below node, then apply postBlock to the node.	"    node neighborsDo: [ :child | self walkFrom: child post: postBlock].    postBlock value: node</body><body package="GF/ST GraphLayout">walkFrom: node pre: preBlock    "Recursively walk the subtree rooted at node.  Apply	 preBlock to each node, then walk the subtree below	 node.	"    preBlock value: node.    node neighborsDo: [ :child | self walkFrom: child pre: preBlock].</body><body package="GF/ST GraphLayout">walkFrom: node pre: preBlock post: postBlock    "Recursively walk the subtree rooted at node.  Apply	 preBlock to each node, then walk the subtree below	 node, then apply postBlock to the node.	"    preBlock value: node.    node neighborsDo: [ :child | self walkFrom: child pre: preBlock post: postBlock].    postBlock value: node</body><body package="GF/ST GraphLayout">walkPost: postBlock    "Recursively walk the tree(s).	 Walk the subtree below node, then apply postBlock to the node.	"    self rootNodes do: [ :root | self walkFrom: root post: postBlock ]</body><body package="GF/ST GraphLayout">walkPre: preBlock    "Recursively walk the tree(s).  Apply preBlock to each node,	 then walk the subtree below node.	"    self rootNodes do: [ :root | self walkFrom: root pre: preBlock ]</body><body package="GF/ST GraphLayout">walkPre: preBlock post: postBlock    "Recursively walk the tree(s).  Apply preBlock to each node,	 then walk the subtree below node, then apply postBlock to the node.	"    self rootNodes do: [ :root |        self walkFrom: root pre: preBlock post: postBlock	]</body></methods><methods><class-id>Polymorphic.FwRootedGraph class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">exampleDAG    "	FwRootedGraph exampleDAG.	"    | d |    d := self unordered.    d addRoot: #r1.    d addRoot: #r2.    d addEdge: #r1 =&gt; #n1.    d addEdge: #r1 =&gt; #n2.    d addEdge: #r2 =&gt; #n2.    d addEdge: #n1 =&gt; #n3.    d addEdge: #n2 =&gt; #n3.    ^d</body><body package="GF/ST GraphLayout">exampleImplicitLargeTree    "	FwRootedGraph exampleImplicitLargeTree	"    ^(self implicitCollection: [ :class |  		class == Class       		ifTrue: [#()]        	ifFalse: [class subclasses asSortedCollection: [ :x :y | x name &lt; y name]]	]) buildFromRoots: (Array with: Object)</body><body package="GF/ST GraphLayout">exampleImplicitSmallTree	"	FwRootedGraph exampleImplicitSmallTree	"    ^(self implicitCollection: [ :class | class subclasses]) buildFromRoots: (Set with: Number)</body><body package="GF/ST GraphLayout">exampleLargeLabelledTree    "	FwRootedGraph exampleLargeLabelledTree	"    ^(self unorderedLabelled)        roots: (Set with: Object)        children: [ :class | class subclasses]        label: [ :src :trg |      		trg isVariable           		ifTrue: [trg isBits ifTrue: [#variableByte] ifFalse: [#variable]]           		ifFalse: [#normal]		]</body><body package="GF/ST GraphLayout">exampleLargeTree    "	FwRootedGraph exampleLargeTree	"    ^(self ordered) roots: (Array with: Object) children: [ :class |		class == Class    		ifTrue: [#()]        	ifFalse: [class subclasses asSortedCollection: [ :x :y | x name &lt; y name]]	]</body><body package="GF/ST GraphLayout">exampleMediumLabelledTree    "	FwRootedGraph exampleMediumLabelledTree	"    ^(self unorderedLabelled)        roots: (Set with: Collection)        children: [ :class | class subclasses]        label: [ :src :trg |      		trg isVariable           		ifTrue: [trg isBits ifTrue: [#variableByte] ifFalse: [#variable]]           		ifFalse: [#normal]		]</body><body package="GF/ST GraphLayout">exampleSmallLabelledTree    "	FwRootedGraph exampleSmallLabelledTree	"    ^(self unorderedLabelled)        roots: (Set with: Magnitude)        children: [ :class | class subclasses]        label: [ :src :trg | trg applications first name]</body><body package="GF/ST GraphLayout">exampleSmallLabelledTree2    "	FwRootedGraph exampleSmallLabelledTree2	"    ^(self unorderedLabelled)        roots: (Set with: Magnitude)        children: [ :class | class subclasses]        label: [ :src :trg |      		trg isVariable           		ifTrue: [trg isBits ifTrue: [#variableByte] ifFalse: [#variable]]         		ifFalse: [#normal]		]</body><body package="GF/ST GraphLayout">exampleSmallTree    "	FwRootedGraph exampleSmallTree	"    ^(self unordered) roots: (Set with: Number) children: [ :class | class subclasses]</body><body package="GF/ST GraphLayout">exampleSmallTree2    "	FwRootedGraph exampleSmallTree2	"    ^(self unordered) roots: (Set with: Number) childrenMsg: #subclasses</body><body package="GF/ST GraphLayout">on: roots    "Each node should yield its children as a result of the children message; the 	 result of this message to an individual node must be constant.	"    ^(self implicitCollection: [ :node | node children]) buildFromRoots: roots</body><body package="GF/ST GraphLayout">onCopy: roots    "Each node should yield its children as a result of the children message; a copy 	 is made to build the graph.	"    ^(FwRootedGraph ordered) roots: roots childrenMsg: #children</body></methods><methods><class-id>Polymorphic.FwRootedGraph class</class-id> <category>examples</category><body package="GF/ST GraphLayout">exampleForest    "	FwRootedGraph exampleForest	"    ^(self unordered) roots: (Set with: Window with: ApplicationModel) children: [ :class | class subclasses]</body></methods><methods><class-id>Polymorphic.FwKeyedSet</class-id> <category>accessing</category><body package="GF/ST GraphLayout">at: key	^self at: key ifAbsent: [self notFoundError]</body><body package="GF/ST GraphLayout">at: key ifAbsent: aBlock	| index |	index := self find: key ifAbsent: [^aBlock value].	^self basicAt: index</body></methods><methods><class-id>Polymorphic.FwExplicitGraphNode</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addNeighbor: aNode    (neighbors includes: aNode)        ifFalse: [neighbors add: aNode]</body><body package="GF/ST GraphLayout">addNeighbor: aNode at: index    "pre: self isOrdered"    neighbors at: index put: aNode</body><body package="GF/ST GraphLayout">copy    | copy |    copy := super copy setNeighbors: neighbors copy.    ^copy</body><body package="GF/ST GraphLayout">degree    ^neighbors size</body><body package="GF/ST GraphLayout">hasEdgeTo: anObject    ^neighbors includes: anObject</body><body package="GF/ST GraphLayout">initializeFixed: arity    neighbors := Array new: arity</body><body package="GF/ST GraphLayout">initializeOrdered    neighbors := OrderedCollection new</body><body package="GF/ST GraphLayout">initializeUnordered    neighbors := Set new</body><body package="GF/ST GraphLayout">isLabelled    "Are the edges from this node labelled?"    ^false</body><body package="GF/ST GraphLayout">isOrdered    ^neighbors isSequenceable</body><body package="GF/ST GraphLayout">neighbors    ^neighbors</body><body package="GF/ST GraphLayout">neighborsDo: aBlock    neighbors do: aBlock</body><body package="GF/ST GraphLayout">removeNeighbor: aNode    neighbors remove: aNode</body><body package="GF/ST GraphLayout">setNeighbors: aCollection    neighbors := aCollection</body></methods><methods><class-id>Polymorphic.FwExplicitGraphNode class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">arity: n    "Create a new ordered node with fixed arity n."    ^super new initializeFixed: n</body><body package="GF/ST GraphLayout">binary    "Create a new binary node."    ^super new initializeFixed: 2</body><body package="GF/ST GraphLayout">binary: value    "Create a new binary node, and given value."    ^(super new) initializeFixed: 2 ; value: value</body><body package="GF/ST GraphLayout">new    "Create a new unordered node."    ^super new initializeUnordered</body><body package="GF/ST GraphLayout">newOn: value    "Create a new unordered node, and given value."    ^(super new) initializeUnordered ; value: value</body><body package="GF/ST GraphLayout">on: value arity: n    "Create a new ordered node with fixed arity n, and given value."    ^(super new) initializeFixed: n ; value: value</body><body package="GF/ST GraphLayout">ordered    "Create a new ordered node."    ^super new initializeOrdered</body><body package="GF/ST GraphLayout">ordered: value    "Create a new ordered node, and given value."    ^(super new) initializeOrdered ; value: value</body></methods><methods><class-id>Polymorphic.FwIterator</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">add: anObject    "FwIterators are read-only"    self shouldNotImplement</body><body package="GF/ST GraphLayout">asOrderedCollection    "Answer a new instance of OrderedCollection whose elements are the elements of    the receiver.  The order in which elements are added depends on the order in    which the receiver enumerates its elements.  In the case of unordered collections,    the ordering is not necessarily the same for multiple requests for the conversion."    | anOrderedCollection |    anOrderedCollection := OrderedCollection new.    self do: [:each | anOrderedCollection addLast: each].    ^anOrderedCollection</body><body package="GF/ST GraphLayout">block: aBlock    block := aBlock</body><body package="GF/ST GraphLayout">do: aBlock    block value: aBlock</body><body package="GF/ST GraphLayout">findFirst: aBlock    "Answer the index of the first element of the receiver    for which aBlock evaluates as true."    | index |    index := 1.    self do: [ :el | (aBlock value: el) ifTrue: [^index].  index := index + 1].    ^0</body><body package="GF/ST GraphLayout">findLast: aBlock    "Answer the index of the last element of the receiver    for which aBlock evaluates as true."    | index last |    index := 1.    last := 0.    self do: [ :el | (aBlock value: el) ifTrue: [last := index].  index := index + 1].    ^last</body><body package="GF/ST GraphLayout">identityIndexOf: anElement    "Answer the identity index of anElement within the receiver.  If the receiver does    not contain anElement, answer 0."    ^self identityIndexOf: anElement ifAbsent: [0]</body><body package="GF/ST GraphLayout">identityIndexOf: anElement ifAbsent: exceptionBlock    "Answer the identity index of anElement within the receiver.  If the receiver does    not contain anElement, answer the result of evaluating the exceptionBlock."    | index |    index := 1.    self do: [ :el | el == anElement ifTrue: [^index].  index := index + 1].    ^exceptionBlock value</body><body package="GF/ST GraphLayout">indexOf: anElement    "Answer the index of anElement within the receiver.  If the receiver does    not contain anElement, answer 0."    ^self indexOf: anElement ifAbsent: [0]</body><body package="GF/ST GraphLayout">indexOf: anElement ifAbsent: exceptionBlock    "Answer the index of anElement within the receiver.  If the receiver does    not contain anElement, answer the result of evaluating the exceptionBlock."    | index |    index := 1.    self do: [ :el | el = anElement ifTrue: [^index].  index := index + 1].    ^exceptionBlock value</body><body package="GF/ST GraphLayout">keysAndValuesDo: aBlock    "Evaluate aBlock with each of the receiver's key/value pairs    (e.g. indexes and elements) as the arguments."    | index |    index := 1.    self do: [:el | aBlock value: index value: el.  index := index + 1]</body><body package="GF/ST GraphLayout">remove: oldObject ifAbsent: anExceptionBlock    "FwIterators are read-only."    self shouldNotImplement</body><body package="GF/ST GraphLayout">size    ^self inject: 0 into: [:a :b | a + 1]</body><body package="GF/ST GraphLayout">species    ^OrderedCollection</body></methods><methods><class-id>Polymorphic.FwIterator class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">on: aBlock    ^self new block: aBlock</body><body package="GF/ST GraphLayout">on: collection msg: msg    ^self new block: [ :aBlock | collection perform: msg with: aBlock]</body></methods><methods><class-id>Polymorphic.FwIdentityDictionaryWithDefault</class-id> <category>initialization</category><body package="GF/ST GraphLayout">defaultBlock: aBlock	defaultBlock := aBlock</body></methods><methods><class-id>Polymorphic.FwIdentityDictionaryWithDefault</class-id> <category>accessing</category><body package="GF/ST GraphLayout">associationAt: key 	"Answer the association at key."	^super associationAt: key ifAbsent:		[| value |		value := defaultBlock value: key.		super at: key put: value.		super associationAt: key]</body><body package="GF/ST GraphLayout">at: key 	"Answer the value at key."	^super at: key ifAbsent:		[| value |		value := defaultBlock value: key.		super at: key put: value.		super at: key]</body></methods><methods><class-id>Polymorphic.FwIdentityDictionaryWithDefault</class-id> <category>copying</category><body package="GF/ST GraphLayout">copyEmpty: aSize	^(super copyEmpty: aSize) defaultBlock: defaultBlock</body></methods><methods><class-id>Polymorphic.FwIdentityDictionaryWithDefault class</class-id> <category>instance creation</category><body package="GF/ST GraphLayout">newIdentity	"Default map is identity."	^self newWithDefaultValueBlock: [ :x | x]</body><body package="GF/ST GraphLayout">newWithDefaultValue: aValue	^super new defaultBlock: [ :ignored | aValue]</body><body package="GF/ST GraphLayout">newWithDefaultValueBlock: aBlock	^super new defaultBlock: aBlock</body></methods><methods><class-id>Polymorphic.FwTreeLayout</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">boundingBoxes	"The default bounding box of a subtree is the extent	 of the root of the subtree"	| boxes h w boxesc ne |	boxes := FwDictionaryWithDefault newWithDefaultValueBlock: [ :nodex | extents at: nodex].	"Calculate bounding boxes of non-leaves."	graph walkPost: [ :node |		node isLeaf			ifFalse: [				h := w := 0.				node neighborsDo: [ :child |					boxesc := boxes at: child.					h := h + boxesc y + minSiblingSpace.					w := w max: boxesc x				].				ne := extents at: node.				h := (h - minSiblingSpace) max: ne y.				w := w + ne x + minPCspace.				boxes at: node put: w@h			]	].	^boxes</body><body package="GF/ST GraphLayout">layoutNodes	"Layout the positions of the nodes in the graph."	| boundingBoxes |	self buildExtents.	graphExtent := self 								positionFromOffsets: (self offsetsFromParentBB: (boundingBoxes := self boundingBoxes))								boundingBoxes: boundingBoxes.	horizontal ifFalse: [graphExtent := graphExtent transpose]</body><body package="GF/ST GraphLayout">offsetsFromParentBB: bbMap	"Calculate the offset of each node from its parent's	 subtree's bounding box, given the bounding box	 of each subtree.	"	| offset x y |	offset := Dictionary new.	graph walkPost: [ :node |		node isLeaf ifFalse: [			x := (extents at: node) x + minPCspace.			y := 0.			node neighborsDo: [ :child |				offset at: child put: x@y.				y := y + (bbMap at: child) y + minSiblingSpace			]		]	].	^offset</body><body package="GF/ST GraphLayout">positionFromOffsets: offsets boundingBoxes: bb	| x y maxX |	positions := Dictionary new.	"set up position(s) of root(s)."	x := rootMargin.	y := sideMargin.	maxX := 0.	graph rootNodes do: [ :root |		positions at: root put: x@y.	"remember where the last one is."		y := y + (bb at: root) y + minSiblingSpace.		maxX := maxX max: (bb at: root) x	].		graph		walkPre: [ :nodex |			"first pass calculates the position of each bounding box"			nodex neighborsDo: [ :child |				positions at: child put: (positions at: nodex) + (offsets at: child)			]		]	 	post: [ :node |			"now adjust for the nodes"	 		node isLeaf ifFalse: [				positions					at: node					replace: [ :old | old + (0@((bb at: node) y - (extents at: node) y / 2) rounded)]			]		].	horizontal ifFalse: [		positions keysDo: [ :nodey | positions at: nodey replace: [ :old | old transpose] ]	].	"return the extent"	^(rootMargin + maxX + leafMargin) @ (y - minSiblingSpace + sideMargin)</body></methods><methods><class-id>Polymorphic.FwImplicitGraphNodeIterator</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">degree    ^iterator size</body><body package="GF/ST GraphLayout">hasEdgeTo: anObject    ^iterator includes: anObject</body><body package="GF/ST GraphLayout">iterator: anIterator    iterator := anIterator</body><body package="GF/ST GraphLayout">neighborsDo: aBlock    iterator do: aBlock</body></methods><methods><class-id>Polymorphic.FwImplicitGraphNodeIterator class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">on: aValue iterator: anIterator    ^(self new) value: aValue ; iterator: anIterator</body><body package="GF/ST GraphLayout">on: aValue iteratorBlock: iteratorBlock    ^self on: aValue iterator: (FwIterator on: iteratorBlock)</body></methods><methods><class-id>Polymorphic.FwDynamicGraphLayout</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addEdge: anEdgeFigure from: fromNodeFigure to: toNodeFigure    "Add an edge to the graph associated with &lt;anEdgeFigure&gt; from the nodeassociated with &lt;fromNodeFigure&gt; to the node associated with&lt;toNodeFigure&gt;."    | toNode edge fromNode |    toNode := self nodeAt: toNodeFigure.    fromNode := self nodeAt: fromNodeFigure.    edge := FwDynamicGraphLayoutEdge forEdgeFigure: anEdgeFigure fromNode: fromNode toNode:toNode.    self edgeMap at: anEdgeFigure put: edge.    fromNode addEdge: edge.    toNode addEdge: edge.    ^edge</body><body package="GF/ST GraphLayout">addNode: aNodeFigure bounds: aRectangle    "Add a moveable node to the graph associated with &lt;aNodeFigure&gt; whoseinitial bounds are defined by &lt;aRectangle&gt;."    | node |    node := self nodeAt: aNodeFigure.    node initialBounds: aRectangle.    ^node</body><body package="GF/ST GraphLayout">bounds    "Answer the bounds of the receiver."    ^bounds</body><body package="GF/ST GraphLayout">computeMaxTime    ^MaxTimeScale * (self nodes size + 1)</body><body package="GF/ST GraphLayout">constructNodeList    | list i n |    list := Array new: self nodeMap size.    i := 0.    n := 0.    self nodeMap do:        [:each |        each isMoveable ifFalse: [n := n + 1].        list at: (i := i + 1) put: each].    self nodes: list.    self fixedNodeCount: n</body><body package="GF/ST GraphLayout">currentTime    ^currentTime</body><body package="GF/ST GraphLayout">currentTime: aNumber    currentTime := aNumber</body><body package="GF/ST GraphLayout">dynamicLayout: aBlock    "Attempt to find a satisfactory layout of the receiver's nodes by solving amechanical system simulation.  Evaluate &lt;aBlock&gt; each time through the loopwith the estimated percentage completed as its sole argument.  Answer aconstant indicating whether the simulation stopped at a stable state, wasterminated because it became unstable, or timed-out without reaching astable state."    | time force |    self hasMoveableNodes        ifFalse: [^self stopped].    time := TimeStep negated.    self maxTime: self computeMaxTime.    [time := time + TimeStep.    time &lt; self maxTime]        whileTrue:            [self currentTime: time.            force := self stepLayout.            aBlock value: time / self maxTime.            force &lt; MinForce                ifTrue: [^self stopped].            force &gt; MaxForce                ifTrue: [^self unstable]].    ^self timedOut</body><body package="GF/ST GraphLayout">edgeAt: anEdgeFigure    "Answer the edge associated with &lt;anEdgeFigure&gt;."    ^self edgeMap at: anEdgeFigure</body><body package="GF/ST GraphLayout">edgeMap    "Answer the edges of the receiver."    ^edgeMap</body><body package="GF/ST GraphLayout">edges    "Answer the edges of the receiver."    "^edges"</body><body package="GF/ST GraphLayout">fixedNodeCount    ^fixedNodeCount</body><body package="GF/ST GraphLayout">fixedNodeCount: anInteger    fixedNodeCount := anInteger</body><body package="GF/ST GraphLayout">hasMoveableNodes    ^(self nodes detect: [:each | each isMoveable] ifNone: [nil]) ~~ nil</body><body package="GF/ST GraphLayout">initialSize: size    nodeMap := IdentityDictionary new: size.    edgeMap := IdentityDictionary new: size.    bounds := FwDynamicGraphLayoutBounds new graph: self.    currentTime := maxTime := 0</body><body package="GF/ST GraphLayout">layout    "Compute the new layout."    ^self dynamicLayout: [:arg | ]</body><body package="GF/ST GraphLayout">layoutBounds: aRectangle    "Set the bounds within which nodes are to be placed to &lt;aRectangle&gt;."    self setConstantsForBounds: aRectangle</body><body package="GF/ST GraphLayout">layoutWithProgressReport: aBlock    "Compute the new layout.  Evaluate &lt;aBlock&gt; each time through the loop toreport progress.  Its argument is the percentage of estimated maximumrunning time."    ^self dynamicLayout: aBlock</body><body package="GF/ST GraphLayout">lengthOfVector: aPoint    ^(aPoint x squared + aPoint y squared) sqrt</body><body package="GF/ST GraphLayout">maxTime    ^maxTime</body><body package="GF/ST GraphLayout">maxTime: aNumber    maxTime := aNumber</body><body package="GF/ST GraphLayout">maxWeight    ^MaxWeight</body><body package="GF/ST GraphLayout">minConstraint    "Answer the minimum constraint of the receiver."    ^minConstraint</body><body package="GF/ST GraphLayout">minConstraint: aNumber    "Set the receiver's minimum constraint to be &lt;aNumber&gt;."    minConstraint := aNumber</body><body package="GF/ST GraphLayout">moveableNodesDo: aBlock    | nl n|    nl := self nodes.    1 to: nl size do:        [:i |        n := nl at: i.        n isMoveable            ifTrue: [aBlock value: n]]</body><body package="GF/ST GraphLayout">nodeAt: aNodeFigure    "Answer the node associated with &lt;aNodeFigure&gt;. Create one if necessary."    ^self nodeMap at: aNodeFigure ifAbsentPut: [FwDynamicGraphLayoutNode forNodeFigure:aNodeFigure]</body><body package="GF/ST GraphLayout">nodeMap    "Answer the Dictionary that associates figures with GraphNodes."    ^nodeMap</body><body package="GF/ST GraphLayout">nodes    "Answer the nodes of the receiver."    nodes == nil        ifTrue: [self constructNodeList].    ^nodes</body><body package="GF/ST GraphLayout">nodes: anArray    "Set the nodes of the receiver to &lt;anArray&gt;."    nodes := anArray</body><body package="GF/ST GraphLayout">placeNodes: aBlock	| list relateNode currentNode nRelated nUnrelated candidate center		relatedCenter unrelatedCenter  i result |	self hasMoveableNodes		ifFalse:			[aBlock value: 1.			^self stopped].	list := self nodes.	center := self bounds center.	[1 to: list size do:		[:inode |		relatedCenter := unrelatedCenter := 0.0 @ 0.0.		nRelated := nUnrelated := 0.		relateNode := list at: inode.		currentNode := list at: 1.		i := 0.		[i := i + 1.		currentNode := list at: i.		currentNode == relateNode] whileFalse:			[(currentNode edgeTo: relateNode) == nil				ifFalse:					[relatedCenter := relatedCenter + currentNode position.					nRelated := nRelated + 1]				ifTrue:					[unrelatedCenter := unrelatedCenter + currentNode position.					nUnrelated := nUnrelated + 1]].			nRelated = 0				ifFalse: [relatedCenter := relatedCenter / nRelated asFloat asPoint].			nUnrelated = 0				ifFalse: [unrelatedCenter := unrelatedCenter / nUnrelated asFloatasPoint].			(nRelated = 0 and: [nUnrelated = 0])				ifTrue: [candidate := center]				ifFalse: [nUnrelated = 0					ifTrue: [candidate := relatedCenter]					ifFalse: [nRelated = 0						ifTrue: [candidate := center * 2.0 - unrelatedCenter]						ifFalse: [candidate := relatedCenter * 2.0 - unrelatedCenter]]].			"perturb randomly, later"			candidate x - self bounds left &lt; self bounds margin				ifTrue: [candidate := (self bounds left + (2.0 * self bounds margin)) @candidate y].			self bounds right - candidate x &lt; self bounds margin				ifTrue: [candidate := (self bounds right - (self bounds margin * 2.0)) @candidate y].			candidate y - self bounds top &lt; self bounds margin				ifTrue: [candidate := candidate x @ (self bounds top + (2.0 * selfbounds margin))].			self bounds bottom - candidate y &lt; self bounds margin				ifTrue: [candidate := candidate x @ (self bounds bottom - (2.0 * selfbounds margin))].			relateNode position: candidate.			self nodes: (list copyFrom: 1 to: inode).			result := self dynamicLayout: [:arg | ].			aBlock value: inode / list size.			result = self stopped				ifFalse: [^result]]]		ensure: [self nodes: list].	^self stopped</body><body package="GF/ST GraphLayout">scaleConstraint    "Answer the scale constraint of the receiver."    ^scaleConstraint</body><body package="GF/ST GraphLayout">scaleConstraint: anumber    "Set the receiver's scale constraint to the given &lt;anumber&gt;."    scaleConstraint := anumber</body><body package="GF/ST GraphLayout">setConstantsForBounds: aRectangle    | ext |    self bounds setBounds: aRectangle.    ext := (aRectangle extent x min: aRectangle extent y) asFloat.    self zeroDistance: ((ext / 100.0) min: 1.0).    self scaleConstraint: ext / 3.5 / MaxWeight.    self minConstraint: ext / 7.0</body><body package="GF/ST GraphLayout">stepLayout	"Step the simulation."	| list friction inertia force maxForce currentNode relateNode oldSpeed one massFactor |	"Initialize."	massFactor := 0.0.	maxForce := 0.0.	force := 0.0 @ 0.0.	list := self nodes.	list do: [:each | each force: force."massFactor := massFactor + eachmass"].	massFactor := massFactor / list size.	friction := (MinFriction + (((MaxFriction - MinFriction) * selfcurrentTime) / self maxTime)) asPoint.	inertia := (MaxInertia - (((MaxInertia - MinInertia) * self currentTime) /self maxTime)) asPoint.	one := 1.0 @ 1.0.	"Calculate force between each pair of nodes."	1 to: list size - 1 do:		[:i |		currentNode := list at: i.		i + 1 to: list size do:			[:j |			relateNode := list at: j.			force := currentNode forceTo: relateNode for: self.			force := force / (list size + self fixedNodeCount) asFloat.			currentNode addForce: force.			relateNode addForce: force negated]].	"Add forces of walls."	self moveableNodesDo:		[:currentNode2 |		self bounds addForcesTo: currentNode2.		"Apply Newton's Law to step to t + dt."		oldSpeed := currentNode2 speed.		currentNode2 speed:			(one - friction) * oldSpeed + (inertia * currentNode2 force "* currentNode2mass / massFactor").		currentNode2 position:			currentNode2 position + ((0.5 * TimeStep asFloat) asPoint * (oldSpeed +currentNode2 speed)).		maxForce := maxForce max: (self lengthOfVector: currentNode2 force)].	^maxForce</body><body package="GF/ST GraphLayout">stopped    ^#stopped</body><body package="GF/ST GraphLayout">timedOut    ^#timedOut</body><body package="GF/ST GraphLayout">unstable    ^#unstable</body><body package="GF/ST GraphLayout">wallForce    ^self bounds wallForce</body><body package="GF/ST GraphLayout">zeroDistance    "Answer the zero distance of the receiver."    ^zeroDistance</body><body package="GF/ST GraphLayout">zeroDistance: aNumber    "Set the receiver's zero distance to be &lt;aNumber&gt;."    zeroDistance := aNumber</body></methods><methods><class-id>Polymorphic.FwDynamicGraphLayout class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">new    ^self new: 10</body><body package="GF/ST GraphLayout">new: size    ^super new initialSize: size</body></methods><methods><class-id>Polymorphic.FwDAGFrontier</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">frontier    ^frontier</body><body package="GF/ST GraphLayout">frontier: f bag: remaining    frontier := f.    bag := remaining</body><body package="GF/ST GraphLayout">remove: frontierObject    frontier remove: frontierObject.    frontierObject neighborsDo:        [ :neighbor |            (bag removeOne: neighbor) = 0                ifTrue: [frontier add: neighbor]].    ^frontierObject</body><body package="GF/ST GraphLayout">removeAll: collection    collection do: [ :n | self remove: n]</body></methods><methods><class-id>Polymorphic.FwDAGFrontier class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">frontierOn: rootedGraph    "Create a frontier object to enumerate the graph."    | remaining frontier |    "Build a Bag of non-root nodes, each node once in the Bag for every predecessor."    frontier := rootedGraph rootNodes asOrderedCollection.    remaining := Bag new.    rootedGraph nodesDo: [ :node | node neighborsDo: [ :n | remaining add: n]].    ^self new frontier: frontier bag: remaining</body></methods><methods><class-id>Polymorphic.FwDynamicGraphLayoutNode</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addEdge: anEdge    "Add &lt;anEdge&gt; to the receiver's edges.  &lt;anEdge&gt; represents an edge fromthe receiver to the node of &lt;anEdge&gt;."    | newEdges |    newEdges := self edges class new: self edges size + 1.    newEdges replaceFrom: 1 to: self edges size with: self edges startingAt: 1.    newEdges at: newEdges size put: anEdge.    self edges: newEdges</body><body package="GF/ST GraphLayout">addForce: aVector    self force: self force + aVector</body><body package="GF/ST GraphLayout">bottom    ^self position y + self extent y</body><body package="GF/ST GraphLayout">boundingBox    ^self position extentFromLeftTop: self extent</body><body package="GF/ST GraphLayout">center    | center |    center := self leftTop + self rightBottom.    center x: center x / 2.0.    center y: center y / 2.0.    ^center</body><body package="GF/ST GraphLayout">edgeTo: aNode    ^self edges detect: [:each | each connectsTo: aNode] ifNone: [nil]</body><body package="GF/ST GraphLayout">edges    "Answer the edges of the receiver."    ^edges</body><body package="GF/ST GraphLayout">edges: aCollectionOfEdges    "Set the receiver's edges to be &lt;aCollectionOfEdges&gt;."    edges := aCollectionOfEdges</body><body package="GF/ST GraphLayout">expansionFactor    ^0.0 @ 0.0</body><body package="GF/ST GraphLayout">extent    ^extent</body><body package="GF/ST GraphLayout">extent: aPoint    extent := aPoint</body><body package="GF/ST GraphLayout">figure    "Answer the figure of the receiver."    ^figure</body><body package="GF/ST GraphLayout">figure: aFigure    "Set the receiver's figure to be &lt;aFigure&gt;."    figure := aFigure</body><body package="GF/ST GraphLayout">force    "Answer the force of the receiver."    ^force</body><body package="GF/ST GraphLayout">force: aVector    "Set the receiver's force to be &lt;aVector&gt;."    force := aVector</body><body package="GF/ST GraphLayout">forceTo1: relateNode for: graph	| direction dist constraint edge |	direction := self vectorTo: relateNode.	dist := (graph lengthOfVector: direction) max: graph zeroDistance.	(self intersects: relateNode)		ifTrue: [constraint := (self intersect: relateNode) extent * ((graphminConstraint / 10.0 * direction x sign asFloat) @ (graph minConstraint /10.0 * direction y sign asFloat))]		ifFalse:			[(edge := self edgeTo: relateNode) == nil				ifTrue: [constraint := graph minConstraint + (MaxWeight * graphscaleConstraint)]				ifFalse: [constraint := graph minConstraint + ((MaxWeight - edge weight)* graph scaleConstraint)]].	^((constraint - dist) / dist) asPoint * direction</body><body package="GF/ST GraphLayout">forceTo: relateNode for: graph    | cb rb edge direction dist constraint |    cb := self boundingBox.    rb := relateNode boundingBox.    edge := self edgeTo: relateNode.    (cb intersects: rb)        ifTrue:            [direction := 0.0 @ 0.0.            (cb top between: rb top and: rb bottom)                ifTrue: [direction y: (rb bottom - cb top)].            (cb bottom between: rb top and: rb bottom)                ifTrue: [direction y: (rb top - cb bottom)].            (cb left between: rb left and: rb right)                ifTrue: [direction x: (rb right - cb left)].            (cb right between: rb left and: rb right)                ifTrue: [direction x: (rb left - cb right)].            direction = (0.0 @ 0.0)                ifTrue: [direction := cb extent].            direction := direction negated * graph wallForce * (((graph maxTime -graph currentTime) asFloat / graph maxTime asFloat * 10.0) min: 1.0).            constraint := 0.0]        ifFalse:            [direction := (self center - relateNode center).            constraint := (graph lengthOfVector: (cb extent max: rb extent)) + (edge== nil                ifTrue: [MaxWeight * graph scaleConstraint]                ifFalse: [(MaxWeight - edge weight) * graph scaleConstraint])].    dist := (graph lengthOfVector: direction) max: graph zeroDistance.    ^((constraint - dist) / dist) asPoint * direction</body><body package="GF/ST GraphLayout">initialBounds: aRectangle    self position: aRectangle leftTop.    self extent: aRectangle extent</body><body package="GF/ST GraphLayout">initialize    position := speed := force := 0.0 @ 0.0.    edges := #().    moveable := true</body><body package="GF/ST GraphLayout">intersect: aNode    ^(self leftTop rightMostAndLowest: aNode leftTop)        rightBottom: (self rightBottom leftMostAndHighest: aNoderightBottom)</body><body package="GF/ST GraphLayout">intersects: aNode    ^(self leftTop isLeftAndAbove: aNode rightBottom)        and: [aNode leftTop isLeftAndAbove: self rightBottom]</body><body package="GF/ST GraphLayout">isMoveable    "Answer true if the receiver's position can be adjusted."    ^self moveable</body><body package="GF/ST GraphLayout">left    ^self position x</body><body package="GF/ST GraphLayout">leftTop    ^self position</body><body package="GF/ST GraphLayout">mass    ^self extent x * self extent y</body><body package="GF/ST GraphLayout">moveable    "Answer the moveable of the receiver."    ^moveable</body><body package="GF/ST GraphLayout">moveable: aBoolean    "Set the receiver's moveable to be &lt;aBoolean&gt;."    moveable := aBoolean</body><body package="GF/ST GraphLayout">position    "Answer the position of the receiver."    ^position</body><body package="GF/ST GraphLayout">position: aPoint    "Set the receiver's position to be &lt;aPoint&gt;."    position := aPoint</body><body package="GF/ST GraphLayout">right    ^self position x + self extent x</body><body package="GF/ST GraphLayout">rightBottom    ^self position rightAndDown: self extent</body><body package="GF/ST GraphLayout">speed    "Answer the speed of the receiver."    ^speed</body><body package="GF/ST GraphLayout">speed: aVector    "Set the receiver's speed to be &lt;aVector&gt;."    speed := aVector</body><body package="GF/ST GraphLayout">top    ^self position y</body><body package="GF/ST GraphLayout">vectorTo: aNode    ^self center - aNode center    "use edges instead"</body></methods><methods><class-id>Polymorphic.FwDynamicGraphLayoutNode class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">forNodeFigure: aFigure    ^self new figure: aFigure</body><body package="GF/ST GraphLayout">new    ^super new initialize</body></methods><methods><class-id>Polymorphic.FwDynamicGraphLayoutEdge</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">connectsTo: aNode    ^self fromNode == aNode or: [self toNode == aNode]</body><body package="GF/ST GraphLayout">defaultWeight    ^MaxWeight</body><body package="GF/ST GraphLayout">figure    "Answer the figure of the receiver."    ^figure</body><body package="GF/ST GraphLayout">figure: aFigure    "Set the receiver's figure to be &lt;aFigure&gt;."    figure := aFigure</body><body package="GF/ST GraphLayout">fromNode    ^fromNode</body><body package="GF/ST GraphLayout">fromNode: aNode    fromNode := aNode</body><body package="GF/ST GraphLayout">initialize    weight := self defaultWeight</body><body package="GF/ST GraphLayout">toNode    ^toNode</body><body package="GF/ST GraphLayout">toNode: aNode    toNode := aNode</body><body package="GF/ST GraphLayout">weight    "Answer the weight of the receiver."    ^weight</body><body package="GF/ST GraphLayout">weight: aNumber    "Set the receiver's weight to be &lt;aNumber&gt;."    weight := aNumber</body></methods><methods><class-id>Polymorphic.FwDynamicGraphLayoutEdge class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">forEdgeFigure: anEdgeFigure fromNode: fromNode toNode: toNode    | new |    new := self new.    new figure: anEdgeFigure.    new fromNode: fromNode.    new toNode: toNode.    ^new</body><body package="GF/ST GraphLayout">forEdgeFigure: anEdgeFigure toGraphNode: aGraphNode    | new |    new := self new.    new figure: anEdgeFigure.    new node: aGraphNode.    ^new</body><body package="GF/ST GraphLayout">new    ^super new initialize</body></methods><methods><class-id>Polymorphic.FwLabelledExplicitGraphNode</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">addNeighbor: aNode    self shouldNotImplement</body><body package="GF/ST GraphLayout">addNeighbor: aNode at: index    self shouldNotImplement</body><body package="GF/ST GraphLayout">addNeighbor: aNode at: index label: label    "pre: self isOrdered"    ^super addNeighbor: aNode =&gt; label at: index</body><body package="GF/ST GraphLayout">addNeighbor: aNode label: label    ^super addNeighbor: aNode =&gt; label</body><body package="GF/ST GraphLayout">hasEdgeTo: anObject    ^neighbors anySatisfy: [ :assoc | assoc key = anObject]</body><body package="GF/ST GraphLayout">isLabelled    "Are the edges from this node labelled?"    ^true</body><body package="GF/ST GraphLayout">labelOfEdgeTo: anObject    "Return the label associated with the edge to anObject; otherwise signal an error."    ^(neighbors detect: [ :assoc | assoc key = anObject]) value</body><body package="GF/ST GraphLayout">labelOfEdgeTo: anObject ifNone: aBlock    "Return the label associated with the edge to anObject; return the value of the block is no such edge exists."    ^(neighbors detect: [ :assoc | assoc key = anObject] ifNone: [^aBlock value]) value</body><body package="GF/ST GraphLayout">neighbors    ^neighbors collect: [ :assoc | assoc key]</body><body package="GF/ST GraphLayout">neighborsAndLabelsDo: aBlock    "Evaluate aBlock for each node connected to an outgoing edge, and the label on that edge (nil if no label)."    ^neighbors do: [ :assoc | aBlock value: assoc key value: assoc value]</body><body package="GF/ST GraphLayout">neighborsDo: aBlock    ^neighbors do: [ :assoc | aBlock value: assoc key]</body><body package="GF/ST GraphLayout">removeNeighbor: aNode    neighbors remove: (neighbors detect: [ :assoc | assoc key = aNode])</body></methods><methods><class-id>Polymorphic.TreeComposer</class-id> <category>private-composing</category><body package="GF/ST GraphLayout">boundingBoxes	"The default bounding box of a subtree is the extent of the root of the subtree (which is correct for leaves, and will be fixed..."	| bb h w bbc ne |	bb := FwDictionaryWithDefault newWithDefaultValueBlock: [ :node | extents at: node].	"...calculate bounding boxes of non-leaves."	graph walkPost: [ :node |		node isLeaf			ifFalse: [					h := w := 0.					node neighborsDo:						[ :child |							bbc := bb at: child.							h := h + bbc y + self minSiblingSpacing.							w := w max: bbc x].					ne := extents at: node.					h := (h - self minSiblingSpacing) max: ne y.					w := w + ne x + self minParentChildSpacing.					bb at: node put: w@h]].	^bb</body><body package="GF/ST GraphLayout">offsetsFromParentBB: bbMap	"Calculate the offset of each node from its parent's subtree's bounding box, given the bounding box of each subtree."	| offset x y |	offset := Dictionary new.	graph walkPost:		[ :node |			node isLeaf				ifFalse: [						x := (extents at: node) x + self minParentChildSpacing.						y := 0.						node neighborsDo:							[ :child |								offset at: child put: x@y.								y := y + (bbMap at: child) y + self minSiblingSpacing]]].	^offset</body><body package="GF/ST GraphLayout">positionFromOffsets: offsets boundingBoxes: bb	| x y maxX |	positions := Dictionary new.	"set up position(s) of root(s)."	x := self rootMargin.	y := self sideMargin.	maxX := 0.	graph rootNodes do: [ :root |		positions at: root put: x@y.	"remember where the last one is."		y := y + (bb at: root) y + self minSiblingSpacing.		maxX := maxX max: (bb at: root) x].		graph		walkPre:	"first pass calculates the position of each bounding box"			[ :node |				node neighborsDo: [ :child |					positions at: child put: (positions at: node) + (offsets at: child)]]	 	post: 		"now adjust for the nodes"	 		[ :node |	 			node isLeaf	 				ifFalse: [positions at: node replace:	 							[ :old | old + (0@((bb at: node) y - (extents at: node) y / 2) rounded)]]].	horizontal		ifFalse:			[positions keysDo: [ :node | positions at: node replace: [ :old | old transpose]]].	"return the extent"	^(self rootMargin + maxX + self leafMargin) @ (y - self minSiblingSpacing + self sideMargin)</body><body package="GF/ST GraphLayout">positionNodes	"Calculate the positions of the nodes in the graph."	| bb orp |	self buildExtents.	bb := self boundingBoxes.  	orp := self offsetsFromParentBB: bb.	graphExtent := self positionFromOffsets: orp boundingBoxes: bb.	horizontal ifFalse: [graphExtent := graphExtent transpose]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>GF/ST</category><body package="GF/ST GraphLayout">at: aKey replace: aBlock	"Replace the value associated with aKey with the value	 of aBlock, evaluated with the previous value associated	 with the key as an argument	"	^self at: aKey put: (aBlock value: (self at: aKey))</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GF/ST GraphLayout">soleElementIfNot: aBlock	"Return the sole element if this is a singleton collection, otherwise evaluate the block."	^self size = 1		ifTrue: [self first]		ifFalse: [aBlock value]</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">accumulate: aBlock    | new |    new := self new.    aBlock value: [:each | new add: each].    ^new.</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">at: anInteger replace: aBlock	"Replace the value at anInteger with the value	 of aBlock, evaluated with the previous value at	 anInteger as an argument	"	^self at: anInteger put: (aBlock value: (self at: anInteger))</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="GF/ST GraphLayout">soleElement	"Return the sole element of this collection."	^self soleElementIfNot: [self error: 'This collection does not have exactly one element']</body><body package="GF/ST GraphLayout">soleElementIfNot: aBlock	"Return the sole element if this is a singleton collection, otherwise evaluate the block."	self size = 1		ifTrue: [self do: [ :el | ^el]]		ifFalse: [^aBlock value]</body></methods><methods><class-id>Polymorphic.GFTextGO</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">center: aPoint"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	self origin: (aPoint translatedByPoint: (self center negated)).</body></methods><methods><class-id>Core.Bag</class-id> <category>removing</category><body package="GF/ST GraphLayout">remove: oldObject howMany: count	"Remove count occurrences of oldObject from the receiver.  	Answer the number of remaining elements."	^self remove: oldObject howMany: count ifAbsent: [self notFoundError]</body><body package="GF/ST GraphLayout">remove: oldObject howMany: count ifAbsent: exceptionBlock	"Remove count occurrences of oldObject from the receiver.  Answer the number of remaining elements.  If the receiver contains less than count occurrences of oldObject, evalaute the exception block."	^(self includes: oldObject)		ifTrue: [| currentCount |				(currentCount := contents at: oldObject) &lt; count					ifTrue: [exceptionBlock value]					ifFalse: [currentCount = count								ifTrue: [contents removeKey: oldObject.										0]								ifFalse: [currentCount := currentCount - count.										contents at: oldObject put: currentCount.										currentCount]]]		ifFalse: [exceptionBlock value]</body><body package="GF/ST GraphLayout">removeOne: oldObject	"Remove oldObject as one of the receiver's elements.  If several of the elements are equal to oldObject, only one is removed.  Answer the number of remaining elements."	^self remove: oldObject howMany: 1</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="GF/ST GraphLayout">=&gt; anObject        "Answer a new instance of an Association        with key the receiver and value anObject."    ^Association key: self value: anObject</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">isGFGraphNode	^false</body></methods><methods><class-id>Core.Set class</class-id> <category>As yet unclassified</category><body package="GF/ST GraphLayout">accumulate: aBlock    | new |    new := self new.    aBlock value: [:each | new add: each].    ^new.</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="GF/ST GraphLayout">any	"Return any element in the Set."	^self anyIfNone: [self emptyCollectionError]</body><body package="GF/ST GraphLayout">anyIfNone: aBlock    "Return any element in the Set; evaluate aBlock is there is none"    self do: [ :element | ^element].    ^aBlock value</body></methods><initialize><class-id>Polymorphic.FwGraph</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Bag</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>GFGroupGO</name><environment>Polymorphic</environment><super>Polymorphic.GFImageGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphicObjects cacheFlag hostWidgets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>GFTextGO</name><environment>Polymorphic</environment><super>Polymorphic.GFGraphicObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>box text font color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>