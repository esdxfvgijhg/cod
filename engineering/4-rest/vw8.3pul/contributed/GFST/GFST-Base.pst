<?xml version="1.0"?><st-source><!-- Name: GF/ST BaseNotice: Copyright © 2002,2000,1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel contains the base classes of the GF/ST Graphics Framework for Smalltalk by Hal Hildebrand and others at Polymorphic Systems.  It is a HotDraw-like graphics framework which is very extensible and suited to producing direct-manipulation applications.DbIdentifier: bear73DbTrace: 488781DbUsername: kgreekDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'UIPainter' '') #(#any 'Tools-Workspace' ''))DialectVersion: VisualWorks 7.9PackageName: GF/ST BaseParcel: #('GF/ST Base')ParcelName: GF/ST BasePrerequisiteParcels: #(#('UIPainter' '') #('Tools-Workspace' ''))PrintStringCache: (8.2 - 1,kgreek)Version: 8.2 - 1Post-Load Block: 	[:pkg| Polymorphic.GFTool postLoadFrom: pkg ]Pre-Unload Block: 	[:pkg| Polymorphic.GFTool preUnloadFor: pkg ]Pre-Save Block: 	[:pkg| Polymorphic.GFTool preSaveFor: pkg ]Date: 1:14:04 PM April 1, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (apr16.1) of April 1, 2016 on April 1, 2016 at 1:14:04 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Polymorphic</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>GF/ST Base</category><attributes><package>GF/ST Base</package></attributes></name-space><class><name>GFHandle</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description releaseAction locator mementoType displayGO snapToGrid limit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFTrackHandle</name><environment>Polymorphic</environment><super>Polymorphic.GFHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sense change scrollFlag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFTrackHandle</class-id><body>	Description:	GFTrackHandle represents direct manipulation action that tracks mouse movement.When the mouse position is changed, the sense action is evaluated with the delta pointof this change.  The result of this action is then sent to the change action.	Instance Variables:	sense - &lt;Action&gt; An action evaluated with the delta point of the mouse movement.		If there is no target for this action, the owner of the handle is used.  If no sense		action is defined, the result of the sense is the delta point	change - &lt;Action&gt; An action evaluated with tthe result of the sense action.  If the		change has no target, the GO selected is used as the target of the action.	scrollFlag - &lt;Boolean&gt; Determines whether to scroll the display to track the mouse.</body></comment><class><name>GFTool</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icon cursor interface name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFTool</class-id><body>	Description:	GFTool represents the mode of interaction with the drawing.  It receivesall the user input, filters it, and determines who to send the input to (whetherto the selections, or the handles), and can perform actions on its own.  It is a relatively simple class, but with out it, representation of the current modeof interaction would be extremely hard to model.	Instance Variables:	icon - &lt;Icon&gt; The icon that represents the tool	cursor - &lt;CursorManager&gt; The cursor used by the tool	interface - &lt;GFDrawingInterface&gt; The interface the tool is for	name - &lt;String&gt; The textual description of the tool</body></comment><class><name>GFSelectionTool</name><environment>Polymorphic</environment><super>Polymorphic.GFTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFSelectionTool</class-id><body>	Description:	GFSelectionTool is used to select, and manipulate graphic objects</body></comment><class><name>GFFocusTool</name><environment>Polymorphic</environment><super>Polymorphic.GFSelectionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFFocusTool</class-id><body>	Description:	GFFocusTool is a specialization that disallows the selections of groups of graphic objects</body></comment><class><name>PsiEventModel</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars>eventsTriggered </class-inst-vars><imports></imports><category>PsiEventHandling</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.PsiEventModel</class-id><body>	Description: 		PsiEventModel tracks event handlers using its own event table instead of the class variablein Object, as is done with standard Digitalk events.  In this way, we can depend on garbagecollection to clean up events when an object is no longer referenced by anyone.  Withoutthis approach, you would be forced to send the #release message to all object's when you weredone with them, and efficiency would be compromised.	Instance Variables:	eventTable - &lt;IdentityDictionary with key: Symbol and value: KindOf: EvaluableAction&gt;			Holds the equivalent of the class variable EventHandlers in Object.</body></comment><class><name>GFGraphicObject</name><environment>Polymorphic</environment><super>Polymorphic.PsiEventModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container prev next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFAbstractPathGO</name><environment>Polymorphic</environment><super>Polymorphic.GFGraphicObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width color lineStyle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFST80</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFAbstractPathGO</class-id><body>	Description:		The GFAbstractPathGO is the abstract path that models graphic objectsbased on paths.  No instances are expected to be created of this class.The responsibilities of the class are related to the path color, width andstyle.  The display methods in this class merely set the pen informationcorrectly, without actually displaying anything.	Instance Variables:	width - &lt;Integer&gt; The width of the path	color - &lt;Color&gt; The color of the path	lineStyle - &lt;Integer&gt; The line style of the path	</body></comment><class><name>GFDirectedPathGO</name><environment>Polymorphic</environment><super>Polymorphic.GFAbstractPathGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startPlug stopPlug </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFPolylineGO</name><environment>Polymorphic</environment><super>Polymorphic.GFDirectedPathGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>points origin extent closed fillColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFSplineGO</name><environment>Polymorphic</environment><super>Polymorphic.GFPolylineGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controlPoints derivatives </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFMemento</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originator state type accessKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFMemento</class-id><body>GFMemento allows for the recording of state information whiletrying to preserve encapsulation.  It should only be created via oneof the #originator:state: variants.  GFMementos will only allow accessto the type and state information if the conditions for allowing accessare met.  Those conditions are: if a key symbol is provided the originatorand the object requesting the information must respond to the symbolin an == test.  If the key is nil, then the requesting object must be == to theoriginator.The default action is for a symbol to be stored into the 'type' field and the#restoreUsing: method will perform the type symbol using the state info asthe parameter.</body></comment><class><name>GFGOActionTool</name><environment>Polymorphic</environment><super>Polymorphic.GFTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFGOActionTool</class-id><body>	Description:	GFGOActionTool is used to perform arbitrary actions on selected Graphic Objects.	Instance Variables:	actionBlock - &lt;Action&gt; The action to evaluate on the selections</body></comment><class><name>GFScalingImage</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>src scale scaledImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFScalingImage</class-id><body>This class is needed to emulate the scaling of images.  This emulation is achieved by creating a copy of the source image located in 'src' and magnifying it by scale (the magnification is done via #gfMagnifyBy:).  This scaled image is then stored in 'scaledImage'. The scale can be set at anytime explicitly, but it is always checked against the graphicsContext's scale when it is displayed.  If the scales match, then the scaledImage is displayed, if they don't match, then a new scaled image is created and stored.  When the scale is set to 1@1 (or 1) then the scaledImage is released, set to nil and the original image in src is used to display.  If the graphicsContext that is being is not a GFScalingPen then it is assumed that it is some sort of printing pen (or more correctly, a pen that can handle sclaing itself) and the original image in src is used to display.Instance variables	src	&lt;Image&gt; the original image to be displayed	scale 	&lt;Number | Point&gt; the current scale	scaledImage	&lt;Image&gt; the scaled image if scale &lt;&gt; 1</body></comment><class><name>GFTextGO</name><environment>Polymorphic</environment><super>Polymorphic.GFGraphicObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>box text font color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFClosedPathGO</name><environment>Polymorphic</environment><super>Polymorphic.GFAbstractPathGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fillColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFClosedPathGO</class-id><body>	Description:		The GFClosedPathGO is an abstract class that models the commonbehavior and state of figures that are closed paths.  The primary responsibilityof this class is to keep track of the fill color used in the graphic object, and set up the pen correctly based on this information.	Instance Variables:	fillColor &lt;Color&gt; - The color to fill the closed area with.</body></comment><class><name>GFEllipseGO</name><environment>Polymorphic</environment><super>Polymorphic.GFClosedPathGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ellipse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFEllipseGO</class-id><body>	Description:	The GFEllipseGO represents a graphic object of an ellipse.  The classkeeps track of the rectangle that represents the ellipse.	Instance Variables:		ellipse - &lt;Rectangle&gt; The rectangle that represents the major and minor axis</body></comment><class><name>GFDamagedRegion</name><environment>Polymorphic</environment><super>Graphics.Rectangle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface-GFDisplay</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFDamagedRegion</class-id><body>	Description:	GFDamageRegion is a specialized rectangle to prevent the needless,and expensive creation of rectangles during damage operations	Instance Variables:	valid - &lt;Boolean&gt; Flag to signal whether the receiver contains a valid		region or not.</body></comment><class><name>GFAbstractEndPlug</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionOffset displayOffset displayPoint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFEvaluableActionEndPlug</name><environment>Polymorphic</environment><super>Polymorphic.GFAbstractEndPlug</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action shapeAction extent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFCachedGO</name><environment>Polymorphic</environment><super>Polymorphic.GFGraphicObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache origin </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFCachedGO</class-id><body>	GFCachedGO represents a graphic object that caches its display witha Bitmap.  This allows complicated graphics to be created once, and quickly displayed.	Instance Variables:	cache - &lt;Bitmap or GFGraphicObject&gt; Used to represent the display	origin - &lt;Point&gt; The origin of the graphic object</body></comment><class><name>GFCoordinateControl</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logicalUnit origin axisDirection scale extent grid useGrid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFCoordinateSystem</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFCoordinateControl</class-id><body>	Description:	The GFCoordinateControl represents a coordinate system, and the behaviorassociated with it.  The GFCoordinateControl uses the native coordinate systemof the host system, and has methods for converting to and from the nativecoordinate system and the user defined coordinate system.  The system alsocontrols the setup of pens to allow WISIWYG displays, scaling, etc.	Instance Variables:	logicalUnit - &lt;GFLogicalUnit&gt; The logical units of the pixels	origin - &lt;Point&gt; The origin of the defined coordinate system referenced		to the native coordinate system	axisDirection - &lt;Point&gt; The sign change required to convert from the native		coordinate systems axis to the defined coordinate system	scale - &lt;Point&gt; The multiplicative scale imposed on the system	extent - &lt;Point&gt; The extent of the native coordinate system	grid - &lt;Point&gt; The grid modulus	useGrid - &lt;Boolean&gt; Determines whether to snap points to the		grid modulus</body></comment><class><name>GFImageGO</name><environment>Polymorphic</environment><super>Polymorphic.GFCachedGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFImageGO</class-id><body>	Description:	GFImageGO represents an image (Bitmap or Icon).  The image is streched to fit the desired area.	Instance Variables:	extent - &lt;Point&gt; the extent of the displayed region</body></comment><class><name>GFGroupGO</name><environment>Polymorphic</environment><super>Polymorphic.GFImageGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphicObjects cacheFlag hostWidgets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFGroupGO</class-id><body>	Description:	GFGroupGO represents the grouping of graphic objects in a drawing.  The figuresare not individually manipulable, and their representation may be cached by a bitmap.	Instance Variables:	graphicObjects - &lt;IndexedCollection of: GFGraphicObject&gt; The components	cacheFlag - &lt;Boolean&gt; Determines whether the display is cached or not	hostWidgets - &lt;IndexedCollection of GFHostWidget&gt; special handling for						   	host widgets</body></comment><class><name>GFHostWidgetGO</name><environment>Polymorphic</environment><super>Polymorphic.GFGraphicObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>area hostWidget </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHostWidgets</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFHostWidgetGO</class-id><body>	Description:	GFHostWidgetGO is the graphic object representation of host operatingsystem widgets.  The major difference between regular GOs and host widgetGOs is that host widgets are always in the foreground.  You can't overlap themwith graphic objects.  This is a fundamental limitation that doesn't appear to be solvable.  However, any suggestions, solutions you might have, pleaseforward them to Polymorphic.  Also, because we can't really control the drawingof host GOs as efficiently as regular GOs, so they flash noticeably when displayed.The support provided is pretty basic.  This class is really a proof of concept,and a skeleton of what is needed to supply this kind of support under GF/ST	Instance Variables:	area - &lt;Rectangle&gt; The rectangle that represents the visible area of the		widget	hostWidget - &lt;Window&gt; The host component</body></comment><class><name>GFMultiheadedConstraint</name><environment>Polymorphic</environment><super>Core.EvaluableAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources sink action selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFMultiheadedConstraint</class-id><body>	Description:	GFMultiheadedConstraint is used to implment a constraint with multiplesources.	Instance Variables:	sources - &lt;Array of: Object&gt; These are the sources of the constraint	sink	- &lt;Object&gt; This is the target of the constraint	action - &lt;EvaluableAction&gt; This is the action to be evaluated that					implements the constraint.  It takes two arguments, the					first being the sources, the second being the sink.	selector - &lt;Symbol&gt; This is the selector of the message that the						sink performs to enforce the constraint.  The selector						takes one argument, which is the result of evaluating						the action.</body></comment><class><name>GFDrawingPane</name><environment>Polymorphic</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displaySystem scrollPoint pagePoint pen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface-GFDisplay-GFDisplay80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFButtonGO</name><environment>Polymorphic</environment><super>Polymorphic.GFImageGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>borderSelector centerOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFGraphicsDisplaySystem</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayPane interface damagedRegion mousePoint visibleArea hostActions minFactor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface-GFDisplay</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFGraphicsDisplaySystem</class-id><body>	Description:	GFGraphicsDisplaySystem is the model of the display system for GOFigure.It coordinates the display of the interface, scrolling action, mouse tracking action,etc.  In the great tradition of models, this is the model for the GFDrawingPane.All the action happens here.	Instance Variable	displayPane - &lt;GFDrawingPane&gt; The host object used to display 	interface - &lt;GFDrawingInterface&gt; The interface connected 	damagedRegion - &lt;GFDamagedRegion&gt; The region currently damaged	mousePoint - &lt;Point&gt; the current point	minFactor - &lt;Point&gt; Minimum factor used to prevent round off errors	visibleArea - &lt;Rectangle&gt; The visible scrolling area	hostActions - &lt;OrderedCollection of: Action&gt; Actions to evaluate for host widget display</body></comment><class><name>GFMessage</name><environment>Polymorphic</environment><super>Core.MessageSend</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFLineGO</name><environment>Polymorphic</environment><super>Polymorphic.GFDirectedPathGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFLogicalUnit</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolution </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFCoordinateSystem</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFLogicalUnit</class-id><body>	Description:	GFLogicalUnit is a stop gap measure until real units are implemented.	Instance Variables:	resolution - &lt;Point&gt; The point that represents the resolution in the x and y direction.		</body></comment><class><name>GFHundredthMillimeter</name><environment>Polymorphic</environment><super>Polymorphic.GFLogicalUnit</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFCoordinateSystem</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFHundredthMillimeter</class-id><body>	Description:	GFHundredthMillimeter represents logical units measured in 100ths of a millimeter.This class is a stop gap until real units are implemented (That means a major overhaulof Number, Point, and Rectangle arithmetic).</body></comment><class><name>GFRectangleGO</name><environment>Polymorphic</environment><super>Polymorphic.GFClosedPathGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rectangle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFRectangleGO</class-id><body>	Description:	The GFRectangleGO class represents the graphic object of a rectangle.	Instance Variables:	rectangle - &lt;Rectangle&gt; The rectangle</body></comment><class><name>Color</name><environment>Polymorphic</environment><super>Graphics.ColorValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFTwip</name><environment>Polymorphic</environment><super>Polymorphic.GFLogicalUnit</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFCoordinateSystem</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFTwip</class-id><body>	Description:	GFTwip represents logical units measured in 1440ths of an inch.This class is a stop gap until real units are implemented (That means a major overhaulof Number, Point, and Rectangle arithmetic).</body></comment><class><name>GFDoubleBufferingGraphicsDisplaySystem</name><environment>Polymorphic</environment><super>Polymorphic.GFGraphicsDisplaySystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scratch pen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface-GFDisplay</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFDoubleBufferingGraphicsDisplaySystem</class-id><body>	Description:	GFDoubleBufferingGraphicsDisplaySystem provides the smooth double bufferingdisplay.  It also consumes more resources.	Instance Variable	pen - &lt;GFPen&gt; The pen of the displayPane 	scratch - &lt;GFScratchBitmap&gt; The bitmap used for double buffering display </body></comment><class><name>GFScalingPen</name><environment>Polymorphic</environment><super>Graphics.ScreenGraphicsContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFScrollingTool</name><environment>Polymorphic</environment><super>Polymorphic.GFTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFQuadTreeElement</name><environment>Polymorphic</environment><super>Graphics.Rectangle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>upperL upperR lowerL lowerR leafData extent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFQuadTree</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFQuadTreeElement</class-id><body>	Description:	GFQuadTreeElement represents a node in a quadTree.  A quadTree organizesits elements by area, and therefore can efficiently access information by pointqueries, or by area queries.  The class is not as general as it could be, and ishighly specialized for use by GFDrawing.  Sue me. &lt;g&gt;	Instance Variables:	upperL - &lt;GFQuadTreeElement&gt; The upper left child	upperR - &lt;GFQuadTreeElement&gt; The upper right child	lowerL - &lt;GFQuadTreeElement&gt; The lower left child	lowerR - &lt;GFQuadTreeElement&gt; The lower right child	leafData - &lt;Set&gt; The collection of elements held by the tree	extent - &lt;Point&gt; The cached extent	</body></comment><class><name>GFThousandthInch</name><environment>Polymorphic</environment><super>Polymorphic.GFLogicalUnit</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFCoordinateSystem</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFThousandthInch</class-id><body>	Description:	GFThousandthInch represents logical units measured in 1000ths of an inch.This class is a stop gap until real units are implemented (That means a major overhaulof Number, Point, and Rectangle arithmetic).</body></comment><class><name>GFGoEndPlug</name><environment>Polymorphic</environment><super>Polymorphic.GFAbstractEndPlug</super><private>false</private><indexed-type>none</indexed-type><inst-vars>go </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFSelectionTrackHandle</name><environment>Polymorphic</environment><super>Polymorphic.GFTrackHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFSelectionTrackHandle</class-id><body>	Description:	GFSelectionTrackHandle is a specialization that operates on the selections	of a drawing as a whole, rather than on an individual basis. </body></comment><class><name>GFAbsoluteTrackHandle</name><environment>Polymorphic</environment><super>Polymorphic.GFSelectionTrackHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFAbsoluteTrackHandle</class-id><body>	Description:	GFAbsoluteTrackHandle is a specialization that operates with absolutemouse positions, rather than deltas from the previous mouse position.</body></comment><class><name>GFCategory</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icon name tools defaultTool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFCategory</class-id><body>	Description:		The GFCategory represents a category of tools used by a palette.	Instance Variables:	icon - &lt;Bitmap or Icon&gt; The visual representation of the category	name - &lt;String&gt; The textual name of the category	tools - &lt;Array of: GFTool&gt; The tools of the category	defaultTool - &lt;GFTool&gt; The default tool of the category</body></comment><class><name>GFDrawingInterface</name><environment>Polymorphic</environment><super>Polymorphic.PsiEventModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>palette selections handles drawing display hideHandles memento </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFCompositeGO</name><environment>Polymorphic</environment><super>Polymorphic.GFGraphicObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayBox graphicObjects visibleArea showVisibleArea visibleAreaLineColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFCompositeGO</class-id><body>	Description:	GFCompositeGo represents a composition of graphic objects.  These GOs may thenbe manipulated as a group, while maintaining the ability to manipulate individualGOs contained within the grouping.  The display of the contained GOs is clipped to thevisible area of the composite.	displayBox - &lt;Rectangle&gt; The cached display area	graphicObjects - &lt;SortedCollection of: GFGraphicObject&gt; Graphic objects sorted in Z order	visibleArea - &lt;Rectangle&gt; The clipping region	showVisibleArea - &lt;Boolean&gt; Determines whether to display the bounds of the visible area</body></comment><class><name>GFDrawing</name><environment>Polymorphic</environment><super>Polymorphic.GFCompositeGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstGO lastGO coordSystem displayGrid gridColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFConstraint</name><environment>Polymorphic</environment><super>Core.EvaluableAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action observedObjects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFConstraint</class-id><body> 	Description:	GFConstraint is a generic constraint mechanism.  It simply evaluates	an action when told to.	Instance Variables:	action - &lt;EvaluableAction&gt; The action to evaluate when the constraint					is fired.  The action takes no arguments.	observedObjects - &lt;Array of: Object&gt; The objects that the constraint is										dependent upon.</body></comment><class><name>GFFloatingPalette</name><environment>Polymorphic</environment><super>Tools.UIPalette</super><private>false</private><indexed-type>none</indexed-type><inst-vars>palette parent categories tools activeTool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFPalettes-GFPalettes80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFConnectionHandle</name><environment>Polymorphic</environment><super>Polymorphic.GFHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>findTargetAction targetPositionAction locatorGenerationAction connectedAction connectAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFConnectionHandle</class-id><body>	Description: 	GFConnectionHandle represents a manipulator used to connect two graphic objects.	Instance Variables:	findTargetAction - &lt;Action&gt; The action to be evaluated that finds the target graphic object.		The action accepts two arguments, the GFDrawingInterface and the target point currently		under the mousePoint.	targetPositionAction - &lt;Action&gt; The action to be evaluated that returns the target position		of the connection.  The action accepts two arguments, the graphic object to be connected,		and the target point under the mouse point	connectAction - &lt;Action&gt; The action to be evaluated that produces a connection graphic		object.  The action accepts two arguments, the start location and the stop location.	locationGenerationAction - &lt;Action&gt; The action to be evaluated that produces a locator		for the stop location.  The action accepts two arguments, the graphic object, and the		target point under the mouse point	connectedAction - &lt;Action&gt; The action to be evaluatd after the connection has been		made.  The action accepts two arguments, the connection produced by the connectAction,		and the location produced by the locationGenerationAction.</body></comment><class><name>GFPositionConstraint</name><environment>Polymorphic</environment><super>Core.EvaluableAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>location receiver settingMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFPositionConstraint</class-id><body>	Description:	GFPositionConstraint is an action that, when evaluated, enforcesa constraint of position.	Instance Variables:	receiver - &lt;GFGraphicObject&gt; This is the object whose position is constrained.	locator - &lt;GFLocator&gt; This is the locator of the constraint, which provides the										constraint point.	settingMessage - &lt;Symbol&gt; This is the selector the receiver performs to												  implement the constraint.  The argument of this												  message is the point provided by the locator.</body></comment><class><name>GFDrawingActionTool</name><environment>Polymorphic</environment><super>Polymorphic.GFTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activateBlock deactivateBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFDrawingActionTool</class-id><body>	Description:	GFDrawingActionTool is used to perform actions on the drawing as a whole	Instance Variables:	activateBlock - &lt;Action&gt; The action to perform when activated	deactivateBlock - &lt;Action&gt; The action to perform when deactivated</body></comment><class><name>GFPaneController</name><environment>Polymorphic</environment><super>UI.WidgetController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>doubleClickEvent activateControlLoop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFOrthogonalPathGO</name><environment>Polymorphic</environment><super>Polymorphic.GFPolylineGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start startDirection endDirection end </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFDependentOrthogonalPathGO</name><environment>Polymorphic</environment><super>Polymorphic.GFOrthogonalPathGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startConstraint stopConstraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>RGBColor</name><environment>Polymorphic</environment><super>Polymorphic.Color</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFPixmap</name><environment>Polymorphic</environment><super>Graphics.Pixmap</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFDependentLineGO</name><environment>Polymorphic</environment><super>Polymorphic.GFLineGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startConstraint stopConstraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFFontChooser</name><environment>Polymorphic</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>styleList familyList sizeList returnHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFRoundedRectangleGO</name><environment>Polymorphic</environment><super>Polymorphic.GFRectangleGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ellipse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFRoundedRectangleGO</class-id><body>	Description:	The GFRoundedRectangleGO class represents the graphic object of a rectanglethat has rounded corners.	Instance Variables:	ellipse - &lt;Point&gt; The point describing the ellipse used to generate the rounded corners</body></comment><class><name>ColorChooser</name><environment>Polymorphic</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>colorName colorValue cubesBrightness cubeColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface-GFDisplay-GFDisplay80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFLocator</name><environment>Polymorphic</environment><super>Polymorphic.GFMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFLocator</class-id><body>		Description:	The GFLocator class is a Message that evaluates to a point.Some specialized methods for copying and instance creationare provided.  Other than that, it's just a message.</body></comment><class><name>GFParameterizedTrackHandle</name><environment>Polymorphic</environment><super>Polymorphic.GFTrackHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeParameter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFHandles</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFParameterizedTrackHandle</class-id><body>	Description:	GFParameterizedTrackHandle is a specialization that allows an invariantparameter to be passed to the change action, which now accepts two arguments.	Instance Variables:	changeParameter - &lt;Object&gt; The object to be passed to the change action along		with the result of the sense action</body></comment><class><name>GFBoundedStack</name><environment>Polymorphic</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bound </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFBoundedStack</class-id><body>	Description:		The GFBoundedStack represents an stack that has a limit to how far it cangrow.  When this bound is reached, when new elements are added, the leastrecently added elements are discarded.	Instance Variables:	bound - &lt;Integer or UndefinedObject&gt; - The limit of the number of elements				 stored	Notes:	The bounded stack is a subclass of OrderedCollection, but elements shouldonly be added to the stack by the method push:.</body></comment><class><name>GFRectangle</name><environment>Polymorphic</environment><super>Graphics.Rectangle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFRectangle</class-id><body>This is an extremely simple extention of rectangle that holds onto a point that represents a scale.  Nothing is really done by the scale in the rectangle, it is used more for bookkeeping purposes only.  An example of how it is used is if the last time a GFRectangle was used and someone set the scale on it, if it is used again and the scales do not match, then some rescaling may need to occur.  It is argueable that this bookeeping should be done elsewhere, or that if 'scale' is going to exist here, it should be taken advantage of by the rectangle.  These arguements are philisophical and removed from the real world need in this case (it is a decision balenced with supporting GFST across three different vendor Smalltalk implementations and the specific need that this class is fulfilling).  GFTextGO uses a GFRectangle for it's bounding box.</body></comment><class><name>GFToolPalette</name><environment>Polymorphic</environment><super>Polymorphic.PsiEventModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>categories activeTool activeCategory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFPalettes</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFToolPalette</class-id><body>	Description: 		The GFToolPalette is a non-visual class that represents the notion of a palette of tools.The tools are held in categories.  When a tool is activated, it becomes the 'activeTool', and when acategory is activated, it becomes the 'activeCategory'.  The GFToolPalette can be displayed in aGFFloatingPaletteWindow; however, you can use a GFToolPalette in your application to helporganize and track tool selections without using the other two classes.	Instance Variables:	activeTool - &lt;GFTool&gt;  The currently active tool.	activeCategory - &lt;GFCategory&gt;  The currently active tool category.	categories - &lt;OrderedCollection of:  GFCategory&gt;  Holds the available categories that can be		selected.</body></comment><class><name>GFDrawingEditor</name><environment>Polymorphic</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface gfView currentCategory handle currentPoint currentTool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface-GFInterface80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFBezierGO</name><environment>Polymorphic</environment><super>Polymorphic.GFPolylineGO</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start end controlPoint1 controlPoint2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFDrawingView</name><environment>Polymorphic</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFInterface-GFInterface80</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFCreationTool</name><environment>Polymorphic</environment><super>Polymorphic.GFTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className creationSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFTools</category><attributes><package>GF/ST Base</package></attributes></class><comment><class-id>Polymorphic.GFCreationTool</class-id><body>	Description: 	GFCreationTool is used to create GFGraphicObjects.	Instance Variables:	className - &lt;Symbol&gt; The symbol of the class to create	creationSelector - &lt;Symbol&gt; The selector to send to the class</body></comment><class><name>GFEmptyRectangle</name><environment>Polymorphic</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST</category><attributes><package>GF/ST Base</package></attributes></class><class><name>GFOpaqueBitmap</name><environment>Polymorphic</environment><super>Graphics.OpaqueImage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GFST-GFSupport-GFSupport80</category><attributes><package>GF/ST Base</package></attributes></class><shared-variable><name>HandleSize</name><environment>Polymorphic.GFHandle</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>ConnectionDirections</name><environment>Polymorphic.GFOrthogonalPathGO</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>Bottom</name><environment>Polymorphic.GFOrthogonalPathGO</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>Left</name><environment>Polymorphic.GFOrthogonalPathGO</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>Right</name><environment>Polymorphic.GFOrthogonalPathGO</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>Top</name><environment>Polymorphic.GFOrthogonalPathGO</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>CopyBuffer</name><environment>Polymorphic.GFDrawingInterface</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>MinExtent</name><environment>Polymorphic.GFQuadTreeElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>MaxElements</name><environment>Polymorphic.GFQuadTreeElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>CopiedFigures</name><environment>Polymorphic.GFLocator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>ColorTable</name><environment>Polymorphic.GFGraphicObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>DefaultLineColor</name><environment>Polymorphic.GFGraphicObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>IconIds</name><environment>Polymorphic.GFTool</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>ToolIcons</name><environment>Polymorphic.GFTool</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><shared-variable><name>Flatness</name><environment>Polymorphic.GFSplineGO</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GF/ST Base</package></attributes></shared-variable><methods><class-id>Polymorphic.GFHandle</class-id> <category>GF/ST</category><body package="GF/ST Base">button1DoubleClickInvoke: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver has been invoked with by a  double click with the button 1 down"</body><body package="GF/ST Base">canBeConnected"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver can be connected or not"    ^false</body><body package="GF/ST Base">center"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the center of the display box"    ^self displayBox center</body><body package="GF/ST Base">containsPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver's area contains a point"    ^self displayBox containsPoint: aPoint</body><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the default handles of the receiver"        ^Array new</body><body package="GF/ST Base">description"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the textual description of the receiver"    ^description</body><body package="GF/ST Base">description: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the textual description of the receiver"    description := aString</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"        ^(displayGO == nil            ifTrue: [self origin extent: self extent]            ifFalse: [self origin extent: displayGO extent ])            expandByScalar: 2</body><body package="GF/ST Base">displayImage: aGFGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the graphic object used to display the receiver"    displayGO := aGFGO</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    displayGO == nil ifFalse: [        (displayGO basicTranslateBy: self origin -  displayGO displayBox origin)            displayWith: aPen.        ^self    ].    aPen        setLineWidthTo: 1;        blackFill;        white;        fastRectangleFilledOrigin: self origin extent: HandleSize</body><body package="GF/ST Base">displayWith: aPen at: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This is a revised version of the GFHandle drawing method. It is about twice as fast per    GFHandle as the original. The combination rule should be RasterOp reverse but that doesn't    reverse the Image on PCs and Macs. Check to see if the GFHandle is inside the visible    region because contestOfArea: fails otherwise."     displayGO == nil ifFalse: [        (displayGO basicTranslateBy: aPoint rounded - displayGO displayBox origin)            displayWith: aPen.        ^self    ].    aPen        setLineWidthTo: 1;        blackFill;        setForeColorTo: Color white;        place: aPoint rounded;        boxFilledOfSize: HandleSize</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"        ^displayGO == nil            ifTrue: [ HandleSize ]            ifFalse: [ displayGO extent ]</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	description := ' '.	snapToGrid := limit := true.</body><body package="GF/ST Base">invoke: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Invoke the receiver in the context of anInterface.    "    self storeMementoForInterface: anInterface.    self trackMouse: anInterface.    releaseAction notNil ifTrue: [ releaseAction evaluate ].</body><body package="GF/ST Base">invokeStep: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Priavte - Default is to do nothing"</body><body package="GF/ST Base">isActive"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver is an active manipulator"    ^true</body><body package="GF/ST Base">isFor: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the owner of the receiver is aGO"    ^self owner == aGO</body><body package="GF/ST Base">limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the reciever limits mouse input to the drawing extent     or not"    ^limit</body><body package="GF/ST Base">limit: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the limit state.  If aBoolean is true, the receiver will use mouse points     that are limited to the extent of the drawing    "    limit := aBoolean</body><body package="GF/ST Base">locator"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the locator for the receiver"    ^locator</body><body package="GF/ST Base">mementoType"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^mementoType</body><body package="GF/ST Base">mementoType: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    mementoType := aSymbol</body><body package="GF/ST Base">menu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the menu of the receiver"    | menu |    displayGO notNil        ifTrue: [ menu := displayGO triggerEvent: #getMenu ifNotHandled: [ nil ]]        ifFalse: [ menu := nil ].    menu isNil        ifTrue: [ locator receiver isGFGraphicObject                            ifTrue: [menu := locator receiver menu]].    ^menu</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"        ^locator asPoint - (self extent // 2) rounded</body><body package="GF/ST Base">owner"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the owner of the receiver"    ^locator receiver</body><body package="GF/ST Base">owner: aFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the owner of the receiver"    self setLocator: (locator copyOn: aFigure)</body><body package="GF/ST Base">releaseAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the action to be taken on the release of the receiver.  The action is     evaluated with no arguments    "    ^releaseAction == nil        ifTrue: [ [] ]        ifFalse: [ releaseAction ]</body><body package="GF/ST Base">releaseAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Specify the action to be taken on the release of the receiver.  The action is     evaluated with no arguments    "    releaseAction := anAction</body><body package="GF/ST Base">setLocator: aLocator"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Specify the locator of the receiver."    locator := aLocator.</body><body package="GF/ST Base">snapToGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the reciever snaps mouse input to the grid or not"    ^snapToGrid</body><body package="GF/ST Base">snapToGrid: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the snap state.  If aBoolean is true, the receiver will use mouse points     that are snapped to the grid of the drawing    "    snapToGrid := aBoolean</body><body package="GF/ST Base">storeMemento"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGO |    (locator isNil or: [ mementoType isNil ]) ifTrue: [ ^self ].    (aGO := locator receiver) storeMemento: (aGO perform: mementoType) for: aGO</body><body package="GF/ST Base">storeMementoForInterface: interface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^self storeMemento</body><body package="GF/ST Base">trackMouse: anInterface"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | oldPoint |    oldPoint := anInterface cursorPointSnapped: snapToGrid limit: limit.    anInterface        trackMouse: [:newPoint |            self invokeStep: newPoint - oldPoint.            oldPoint := newPoint.            anInterface repairDamage.             ]        uponRelease: nil        until: anInterface display buttonUpCheckBlock        scroll: false        preScrollDo: nil        snapToGrid: snapToGrid        limit: limit.</body></methods><methods><class-id>Polymorphic.GFHandle class</class-id> <category>GF/ST</category><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "GFHandle initialize"    HandleSize := 6 @ 6</body><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new initialize.</body><body package="GF/ST Base">on: aFigure at: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^self new setLocator: (GFLocator on: aFigure at: aSymbol)</body><body package="GF/ST Base">on: aFigure at: aSymbol with: anArgument"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^self new setLocator: (GFLocator on: aFigure at: aSymbol with: anArgument)</body></methods><methods><class-id>Polymorphic.GFTrackHandle</class-id> <category>GF/ST</category><body package="GF/ST Base">change: aGO by: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    change notNil ifTrue: [change evaluateIfNoTarget: aGO with: anObject]</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    super initialize.    scrollFlag := true.</body><body package="GF/ST Base">invokeStep: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    | anObject |    anObject := self sense: deltaPoint.    anObject notNil ifTrue: [self change: self owner by: anObject]</body><body package="GF/ST Base">scrollFlag: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    scrollFlag := aBoolean</body><body package="GF/ST Base">sense: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    ^sense isNil         ifTrue: [deltaPoint]           ifFalse: [sense evaluateIfNoTarget: self owner with: deltaPoint]</body><body package="GF/ST Base">setSense: senseAction change: changeAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - 'changeAction' and 'senseAction' can be 	&lt;Symbol | Block | Message&gt; or anything that responds to 	#evaluateIfNoTarget:with:"    sense := senseAction.    change := changeAction</body><body package="GF/ST Base">trackMouse: anInterface"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | oldPoint |    oldPoint := anInterface cursorPointSnapped: snapToGrid limit: limit.    anInterface        trackMouse: [:newPoint |            self invokeStep: newPoint - oldPoint.            newPoint = oldPoint ifFalse:			[oldPoint := newPoint.	            anInterface repairDamage]]        uponRelease: []        until: anInterface display buttonUpCheckBlock        scroll: scrollFlag        preScrollDo: nil        snapToGrid: snapToGrid        limit: limit.</body></methods><methods><class-id>Polymorphic.GFTrackHandle class</class-id> <category>GF/ST</category><body package="GF/ST Base">allCornersOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the handles used to control the four corners of aGO"    ^OrderedCollection new         add: (self topLeftOf: aGO);          add: (self topRightOf: aGO);         add: (self bottomLeftOf: aGO);        add: (self bottomRightOf: aGO);        yourself</body><body package="GF/ST Base">borderColorOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a TrackHandle that changes the border color of aGO"    ^(self           on: aGO        at: #offCenter:         with: 0@10          sense: #senseColor:           change: #borderColorBy:)            mementoType: #attributeMemento;            description: 'border color';            snapToGrid: false;            limit: false;            yourself</body><body package="GF/ST Base">bottomLeftOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle used to change the bottom left of aGO"    ^(self          on: aGO         at: #bottomLeft          sense: #senseBottomLeft:          change: #growBy:)            mementoType: #positionMemento;            description: 'change bottom left';            yourself</body><body package="GF/ST Base">bottomRightOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle used to change the bottom right of aGO"    ^(self           on: aGO         at: #bottomRight         sense: #senseBottomRight:        change: #growBy:)            mementoType: #positionMemento;            description: 'change bottom right';            yourself</body><body package="GF/ST Base">colorOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle used to change the color of aGO"    ^(self        on: aGO         at: #offCenter:         with: 10@0         sense: #senseColor:         change: #colorBy:)            mementoType: #attributeMemento;            description: 'fill color';            snapToGrid: false;            limit: false;            yourself</body><body package="GF/ST Base">on: aGO at: aSymbol change: changeAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"'changeAction' can be &lt;Symbol | Block | Message&gt; or anything that 	responds to #evaluateIfNoTarget:with:"    ^(self on: aGO at: aSymbol)        setSense: nil change: changeAction</body><body package="GF/ST Base">on: aGO at: aSymbol sense: senseAction change: changeAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"'changeAction' and 'senseAction' can be &lt;Symbol | Block | Message&gt; 	or anything that responds to #evaluateIfNoTarget:with:"    ^(self on: aGO at: aSymbol)          setSense: senseAction change: changeAction</body><body package="GF/ST Base">on: aGO at: aSymbol with: anArgument change: changeAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"'changeAction' can be &lt;Symbol | Block | Message&gt; or anything that 	responds to #evaluateIfNoTarget:with:"    ^(self on: aGO at: aSymbol with: anArgument)        setSense: nil change: changeAction</body><body package="GF/ST Base">on: aGO at: aSymbol with: anArgument sense: senseAction change: changeAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"'changeAction' and 'senseAction' can be &lt;Symbol | Block | Message&gt; 	or anything that responds to #evaluateIfNoTarget:with:"    ^(self on: aGO at: aSymbol with: anArgument)        setSense: senseAction change: changeAction</body><body package="GF/ST Base">positionOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle that changes the position of the receiver"     ^(self            on: aGO            at: #center            change: #translateBy:) mementoType: #positionMemento; yourself</body><body package="GF/ST Base">positionOfTopCenter: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle that changes the position of the go, based on the     top center of aGO    "    ^(self        on: aGO        at: #topCenter        change: #translateBy:) mementoType: #positionMemento; yourself</body><body package="GF/ST Base">roundedCornerOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle used to change the corner ellipse of a rounded rectangle"    ^(self        on: aGO         at: #offCenter:          with: 10@10        sense: #senseCornerEllipse:        change: #changeCornerEllipseBy:)            mementoType: #attributeMemento;            description: 'corner ellipse';            snapToGrid: false;            limit: false;            yourself</body><body package="GF/ST Base">topLeftOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle used to change the top left of aGO"    ^(self        on: aGO        at: #topLeft         sense: #senseTopLeft:         change: #growBy:)            mementoType: #positionMemento;            description: 'change top left';            yourself</body><body package="GF/ST Base">topRightOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle used to change the top right of aGO"    ^(self         on: aGO         at: #topRight           sense: #senseTopRight:           change: #growBy:)            mementoType: #positionMemento;            description: 'change top right';            yourself</body><body package="GF/ST Base">widthOf: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a handle that changes the border width of aGO"    ^(self        on: aGO        at: #offCenter:        with: -10@0        sense: #senseColor:        change: #borderWidthBy: )            mementoType: #attributeMemento;            description: 'border width';            snapToGrid: false;            limit: false;            yourself</body></methods><methods><class-id>Polymorphic.GFTool</class-id> <category>GF/ST</category><body package="GF/ST Base">activate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This message is sent when a tool is selected. The default    behavior is that changing tools cancels any selections"    interface noSelections</body><body package="GF/ST Base">asBitmap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^icon</body><body package="GF/ST Base">button1DoubleClick: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGO |    aGO := self graphicObjectAtPoint: aPoint.    aGO isNil        ifTrue: [self button1DoubleClickBackground]        ifFalse: [self button1DoubleClickGO: aGO]</body><body package="GF/ST Base">button1DoubleClickBackground"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Default is to do nothing"</body><body package="GF/ST Base">button1DoubleClickGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Default is to do nothing"</body><body package="GF/ST Base">button1Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGO |    aGO := self graphicObjectAtPoint: aPoint.    aGO isNil        ifTrue: [self button1DownBackground]        ifFalse: [self button1DownGO: aGO]</body><body package="GF/ST Base">button1DownBackground"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Default is to do nothing"</body><body package="GF/ST Base">button1DownGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Default is to do nothing"</body><body package="GF/ST Base">button1DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self button1Down: aPoint</body><body package="GF/ST Base">button2DoubleClick: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"</body><body package="GF/ST Base">button2Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"This method calls #button2downGO and #button2DownBackground.	If either of these methods handle the button event completely, they 	should return nil.  If they don't return nil, then the popup menu will be 	activated."    | aGO |    aGO := self graphicObjectAtPoint: aPoint.    (aGO isNil        ifTrue: [self button2DownBackground]        ifFalse: [self button2DownGO: aGO]) == nil		ifFalse: [ interface popupMenu ]</body><body package="GF/ST Base">button2DownBackground"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Default is to do nothing"</body><body package="GF/ST Base">button2DownGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Default is to do nothing"</body><body package="GF/ST Base">button2DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self button2Down: aPoint</body><body package="GF/ST Base">canCutCopyPaste"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^false</body><body package="GF/ST Base">colorChange"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"</body><body package="GF/ST Base">cursor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^cursor</body><body package="GF/ST Base">deactivate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This message is sent when the receiver tool is     no longer the active tool     Default is to do nothing.    "</body><body package="GF/ST Base">display"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Tools are given the opportunity to modify the view     after the drawing has been displayed.     The default is to do nothing.    "</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    icon displayWith: aPen</body><body package="GF/ST Base">drawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^interface drawing</body><body package="GF/ST Base">graphicObjectAtCursor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    ^interface graphicObjectAt: interface cursorPoint</body><body package="GF/ST Base">graphicObjectAtPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	 ^interface graphicObjectAt: aPoint</body><body package="GF/ST Base">handleAt: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	^interface handleAt: aPoint</body><body package="GF/ST Base">icon"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^icon</body><body package="GF/ST Base">interface: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    interface := anInterface</body><body package="GF/ST Base">model"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^interface model</body><body package="GF/ST Base">name"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^name</body><body package="GF/ST Base">processKeyboard: ev"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^ev</body><body package="GF/ST Base">releaseIcon"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    icon release.</body><body package="GF/ST Base">setIcon: anImage cursor: aCursor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    icon := anImage.    cursor := aCursor.    name := ''</body><body package="GF/ST Base">setIcon: anImage cursor: aCursor name: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    name := aString.    icon := anImage.    cursor := aCursor</body></methods><methods><class-id>Polymorphic.GFTool</class-id> <category>testing</category><body package="GF/ST Base">processesKeyboard"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^false</body></methods><methods><class-id>Polymorphic.GFTool class</class-id> <category>GF/ST</category><body package="GF/ST Base">getIcon: key"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| id directory filename |	IconIds == nil ifTrue: [ self initStockIconIds ].	id := IconIds at: key ifAbsent: [ ^self error: 'No such stock icon ID' ].	"First try the directory where it should be."	directory := LogicalFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'GFST' 'resource').	(filename := directory construct: id) definitelyExists ifTrue:		[^ToolIcons at: key put: (ImageReader fromFile: filename) image].	"Try the working directory"	(filename := 'resource' asFilename construct: id) definitelyExists ifTrue:		[^ToolIcons at: key put: (ImageReader fromFile: filename) image].	self error: ('Unable to find bmp file named &lt;1p&gt; for icon with id &lt;2p&gt;' expandMacrosWith: id with: key)</body><body package="GF/ST Base">icon: anImage cursor: aCursor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new setIcon: anImage cursor: aCursor name: ''</body><body package="GF/ST Base">icon: anImage cursor: aCursor class: aClass"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new setIcon: anImage cursor: aCursor name: ''</body><body package="GF/ST Base">icon: anImage cursor: aCursor class: aClass name: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new setIcon: anImage cursor: aCursor name: aString</body><body package="GF/ST Base">icon: anImage cursor: aCursor name: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new setIcon: anImage cursor: aCursor name: aString</body><body package="GF/ST Base">initStockIconIds"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"		IconIds := Dictionary new		add: (Association key: 'Rectangle' value: 'RECT.BMP');		add: (Association key: 'Select' value: 'SELECT.BMP');		add: (Association key: '3d' value: '3D.BMP');		add: (Association key: 'RoundedRectangle' value: 'RNDRECT.BMP');		add: (Association key: 'AboutMask' value: 'ABOUTMSK.BMP');		add: (Association key: 'ClosedGOs' value: 'CLSFIG.BMP');		add: (Association key: '3dMask' value: '3DMASK.BMP');		add: (Association key: 'Paragraph' value: 'PARA.BMP');		add: (Association key: 'Image' value: 'IMAGE.BMP');		add: (Association key: 'About' value: 'ABOUT.BMP');		add: (Association key: 'OrthogonalPath' value: 'ORTHOPTH.BMP');		add: (Association key: 'DrawingTool' value: 'DWNGTOOL.BMP');		add: (Association key: 'Button' value: 'BUTTON.BMP');		add: (Association key: 'Bezier' value: 'BEZIER.BMP');		add: (Association key: 'Inspector' value: 'INSPECT.BMP');		add: (Association key: 'Polyline' value: 'POLYLINE.BMP');		add: (Association key: 'SendToBack' value: 'SNDTOBCK.BMP');		add: (Association key: 'Help' value: 'HELP.BMP');		add: (Association key: 'Zorder' value: 'ZORDER.BMP');		add: (Association key: 'Ellipse' value: 'ELLIPSE.BMP');		add: (Association key: 'Line' value: 'LINE.BMP');		add: (Association key: 'HelpMask' value: 'HELPMASK.BMP');		add: (Association key: 'BringToFront' value: 'BTOFRNT.BMP');		add: (Association key: 'Spline' value: 'SPLINE.BMP');		add: (Association key: 'Arrow' value: 'ARROW.BMP');		add: (Association key: 'List' value: 'LIST.BMP');				add: (Association key: 'Lines' value: 'LINES.BMP');		add: (Association key: 'TextField' value: 'EDITFLD.BMP');		add: (Association key: 'Components' value: 'COMPS.BMP');		add: (Association key: 'InspectorMask' value: 'INSPMASK.BMP');		add: (Association key: 'EditField' value: 'EDITFLD.BMP');		add: (Association key: 'Text' value: 'TEXT.BMP');		add: (Association key: 'DrawingMask' value: 'DWNGMASK.BMP');		add: (Association key: 'Paths' value: 'PATHS.BMP');		add: (Association key: 'OrthogonalArrow' value: 'ORTHOARW.BMP');		yourself.	self allSubclasses do: [ :each | each setupIconIds ].	^IconIds</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self releaseStockIcons</body><body package="GF/ST Base">releaseStockIcons"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ToolIcons isNil ifFalse: [        ToolIcons do: [:each | each release].    ].    ToolIcons := Dictionary new.	IconIds := nil.</body><body package="GF/ST Base">setupIconIds"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Default is to do nothing.  However, this is where 	tools would register their tool and category icon information"</body><body package="GF/ST Base">stockIconFor: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^ToolIcons at: aString ifAbsent: [ self getIcon: aString ]</body></methods><methods><class-id>Polymorphic.GFTool class</class-id> <category>parcel load/unload/save</category><body package="GF/ST Base">postLoadFrom: aParcel	"Run the necessary initializers and open up the Welcome workspace."	| stream workspace |	GFGraphicObject initialize.	GFSplineGO initialize.	GFOrthogonalPathGO initialize.	GFHandle initialize.	GFDrawingInterface resetEventsTriggered.	GFQuadTreeElement initialize.	GFTool initialize.	aParcel namedObjects keysAndValuesDo:		[:key :image|		ToolIcons at: key put: image].	stream := TextStream on: (String new: 1024).	stream		emphasis: #bold;		nextPutAll: 'GF/ST R1.1 for VisualWorks 7.x'; cr;		emphasis: nil;		nextPutAll: 'Copyright (C) 2003-1999 Cincom Systems, Inc.'; cr;		nextPutAll: 'All Rights Reserved'; cr; cr;		cr;		emphasis: nil;		nextPutAll: 'To start up the GF/ST Demo Launcher, evaluate: '; cr;		emphasis: #bold;		nextPutAll: '      GFDemoLauncher open.'; cr;		emphasis: nil;		cr;		nextPutAll: 'To visually inspect any object, send it the message #psiVisualInspect.'; cr;		nextPutAll: 'For example:'; cr;		emphasis: #bold;		nextPutAll: '      Transcript psiVisualInspect.'; cr;		emphasis: nil;		cr;		nextPutAll: 'Note that the VisualInspector is in the GFST-VisualInspector.pcl parcel, and the GFDemoLauncher is in the GFST-Demo.pcl parcel.';		cr;		nextPutAll: 'All classes that the GF/ST parcels now have been moved to the Polymorphic namespace.'; cr;		cr.	workspace := Workspace new.	workspace currentTextPage documentModel value: stream contents.	workspace open.	workspace builder window label: 'GF/ST Installation Workspace'.	workspace builder window displayBox: (30@250 extent: 500@350).</body><body package="GF/ST Base">preSaveFor: aParcel 	"Include all the stock icons in the Parcel's named objects so	 we can initialize these on load without needing the .BMP files."	aParcel isParcel ifFalse: [^self].	self initStockIconIds.	IconIds keysDo:		[:key|		aParcel addObject: (self getIcon: key) named: key].	self releaseStockIcons</body><body package="GF/ST Base">preUnloadFor: aParcel	"Close any open applications."	| definedAppClasses |	definedAppClasses := aParcel definedClasses select: [:c| c inheritsFrom: ApplicationModel].	ScheduledControllers scheduledControllers do:		[:ctrlr |		((definedAppClasses contains: [:dac| ctrlr model isKindOf: dac])		or: [ctrlr view label = 'GF/ST Installation Workspace']) ifTrue:			[ctrlr closeAndUnschedule]]</body></methods><methods><class-id>Polymorphic.GFSelectionTool</class-id> <category>GF/ST</category><body package="GF/ST Base">button1DoubleClickGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    (aGO isActive and: [(interface isSelected: aGO) not])        ifTrue:[^self button1DoubleClickHandle: aGO].    aGO button1DoubleClick</body><body package="GF/ST Base">button1DoubleClickHandle: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    interface handleInvoked: aHandle.    aHandle button1DoubleClickInvoke: interface.    interface noHandleInvoked.</body><body package="GF/ST Base">button1DownBackground"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	self selectGroup</body><body package="GF/ST Base">button1DownGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    (aGO isActive and: [(interface isSelected: aGO) not])        ifTrue:[^self button1DownHandle: aGO].    self selectGO: aGO.    interface shouldDoDragDrop ifTrue: [^interface doButton1DragDrop].    self moveGO: aGO.</body><body package="GF/ST Base">button1DownHandle: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    interface handleInvoked: aHandle.    aHandle invoke: interface.    interface noHandleInvoked.</body><body package="GF/ST Base">graphicObjectAtPoint: aPoint"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | aGO |    (aGO := self handleAt: aPoint) isNil ifTrue: [          aGO := super graphicObjectAtPoint: aPoint    ].    ^aGO</body><body package="GF/ST Base">moveGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | hndl |    (hndl := aGO generatePositionHandle) notNil        ifTrue: [ self button1DownHandle: hndl ]</body><body package="GF/ST Base">rectangleFromUser"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Answer a rectangle obtained from the user."		| originPoint gridPoint rect pane |	originPoint := InputState default mousePoint.	gridPoint := 1@1.	self cursor		showWhile: 			[rect := Screen default				resizeRectangle: (Rectangle origin: originPoint extent: gridPoint )				minimumExtent: gridPoint				resizeIncrement: gridPoint				boundedBy: nil				whileButton: 0				isDown: true].		pane := interface display displayPane.		^(pane globalPointToLocal: (rect origin translatedBy: pane topComponent globalOrigin negated) ) extent: rect extent</body><body package="GF/ST Base">selectGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"        interface shiftDown                ifTrue: [interface toggleSelection: aGO]                ifFalse: [                    (interface isSelected: aGO) ifFalse: [                        interface selection: aGO                ]        ]</body><body package="GF/ST Base">selectGroup"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | aRectangle aCollection |    interface noSelections.    aRectangle := self rectangleFromUser.    aCollection := interface graphicObjectsIn: (interface unscaledRectangle: aRectangle).    interface shiftDown ifFalse: [interface selections: aCollection]        ifTrue: [interface toggleSelections: aCollection]</body></methods><methods><class-id>Polymorphic.GFSelectionTool class</class-id> <category>GF/ST</category><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self icon: (GFTool stockIconFor: 'Select') cursor: self gfCursorClass normal name: 'Selection'</body></methods><methods><class-id>Polymorphic.GFFocusTool</class-id> <category>GF/ST</category><body package="GF/ST Base">selectGroup"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    interface noSelections.</body></methods><methods><class-id>Polymorphic.PsiEventModel</class-id> <category>event table</category><body package="GF/ST Base">eventTable    "Answer the event table"    eventTable == nil ifTrue: [eventTable := self eventTableCreate].    ^eventTable</body><body package="GF/ST Base">eventTableForEdit        "Private - answer the table of event handlers for the receiver.        Allocate if necessary so that updates can be stored."    ^self eventTable</body><body package="GF/ST Base">privateSetEventTable: dictionary    "private "    eventTable := dictionary</body><body package="GF/ST Base">releaseEventTable    eventTable := nil</body></methods><methods><class-id>Polymorphic.PsiEventModel</class-id> <category>events</category><body package="GF/ST Base">actionForEvent: eventName        "Answer the action to evaluate when the event        named &lt;eventName&gt; is triggered by the receiver."    eventTable == nil ifTrue: [^nil].    ^eventTable        at: eventName asSymbol        ifAbsent: [nil]</body><body package="GF/ST Base">actionListForEvent: eventName        "Answer an editable list of actions that get evaluated        when the event named &lt;eventName&gt; is triggered."    eventTable == nil ifTrue: [^ActionSequence new].    ^(eventTable        at: eventName asSymbol        ifAbsent: [^ActionSequence new])            asActionSequence</body><body package="GF/ST Base">eventTableCopy        "Private - answer an empty dictionary for use as an event table."    ^eventTable isNil		ifTrue: [ eventTable ]		ifFalse: [ eventTable copy ]</body><body package="GF/ST Base">eventsHandled        "Answer the events for which there are actions        registered in the receiver's event table."    eventTable == nil ifTrue: [^#()].    ^eventTable keys</body><body package="GF/ST Base">hasActionForEvent: eventName        "Answer whether the receiver has an action registered for the        event named &lt;eventName&gt;."    eventTable == nil ifTrue: [^false].    ^eventTable includesKey: eventName asSymbol</body><body package="GF/ST Base">release: anObject    "anObject is no longer interested in changed Events"    self        removeAllActionsWithReceiver: anObject</body><body package="GF/ST Base">removeAction: anAction	eventTable == nil ifTrue: [^self].	eventTable keys do: [:each |		self 			removeActionsSatisfying: [:a | a = anAction]			forEvent: each	].</body><body package="GF/ST Base">removeActionsForEvent: eventName        "Remove all actions for the event named &lt;eventName&gt;."    eventTable == nil ifTrue: [^self].    eventTable removeKey: eventName asSymbol ifAbsent: [].    eventTable isEmpty        ifTrue: [self releaseEventTable]</body><body package="GF/ST Base">removeActionsSatisfying: aOneArgBlock forEvent: aSymbol        "Remove all actions for the event &lt;aSymbol&gt; that satisfy &lt;aOneArgBlock&gt;."    self        setActionList:            ((self actionListForEvent: aSymbol)                reject: [:anAction | aOneArgBlock value: anAction])        forEvent: aSymbol</body><body package="GF/ST Base">removeAllActionsWithReceiver: anObject        "Remove all actions for all events in the receiver's event table        which have &lt;anObject&gt; as their receiver."    eventTable == nil ifTrue: [^self].    eventTable keysDo: [ :event |        self removeActionsWithReceiver: anObject forEvent: event ]</body><body package="GF/ST Base">setActionList: actionSequence forEvent: eventName        "Set the list of actions that get evaluated when        the event named &lt;eventName&gt; is triggered by        the receiver to &lt;actionSequence&gt;."    | action |    action := actionSequence asMinimalRepresentation.    action == nil        ifTrue: [ self removeActionsForEvent: eventName ]        ifFalse: [            self eventTableForEdit                at: eventName asSymbol                put: action ]</body><body package="GF/ST Base">triggerEvent: eventName        "Trigger the event named &lt;eventName&gt;. Answer the value returned        by the most recently defined event handler action."	| action |	^(action := self actionForEvent: eventName)  == nil 		ifTrue: [ nil ]		ifFalse: [ action evaluate ]</body><body package="GF/ST Base">triggerEvent: eventName ifNotHandled: exceptionBlock        "Trigger the event named &lt;eventName&gt;.  If the event is        not handled, answer the value of &lt;exceptionBlock&gt;,        otherwise answer the value returned by the        most recently defined event handler action."    eventTable == nil ifTrue: [^exceptionBlock value].    ^(eventTable        at: eventName asSymbol        ifAbsent: [^exceptionBlock value]) evaluate</body><body package="GF/ST Base">triggerEvent: eventName withArguments: argumentList        "Trigger the event &lt;eventName&gt; using the        elements of the &lt;argumentList&gt; as the arguments.        Answer the value returned by the most recently        defined event handler action."	| action |	^(action := self actionForEvent: eventName) == nil		ifTrue: [ nil ]		ifFalse: [ action evaluateWithArguments: argumentList ]</body><body package="GF/ST Base">triggerEvent: eventName withArguments: argumentList ifNotHandled: exceptionBlock        "Trigger the event &lt;eventName&gt; using the elements of        the &lt;argumentList&gt; as the arguments.  If the event is        not handled, answer the value of &lt;exceptionBlock&gt;,        otherwise answer the value returned by the most        recently defined event handler action."    eventTable == nil ifTrue: [^exceptionBlock value].    ^(eventTable        at: eventName asSymbol        ifAbsent: [^exceptionBlock value]) evaluateWithArguments: argumentList</body><body package="GF/ST Base">updateEvent: eventName selector: selector arguments: argumentList        "Private - trigger the event named &lt;eventName&gt; using &lt;selector&gt;        as the message selector and the elements of the &lt;argumentList&gt;        as the arguments."    eventTable == nil ifTrue: [^nil].    (eventTable at: eventName asSymbol ifAbsent: [^nil])        asActionSequence            evaluateWithSelector: selector            withArguments: argumentList</body><body package="GF/ST Base">when: eventName evaluate: anAction        "Append &lt;anAction&gt; to the list of actions to evaluate        when the receiver triggers the event named &lt;eventName&gt;."    | actions |    (self canTriggerEvent: eventName)        ifFalse: [^self error: 'Bad event: ', eventName printString].    actions := self actionListForEvent: eventName.    (actions includes: anAction)        ifTrue: [^self].    self        setActionList: (actions copyWith: anAction)        forEvent: eventName</body><body package="GF/ST Base">when: eventName send: selector to: anObject        "Form an action with &lt;anObject&gt; as the receiver and        a &lt;selector&gt; as the message selector and append        it to the actions list for the event named &lt;eventName&gt;."   | arguments |    selector isSymbol        ifFalse: [^self error: 'Bad Selector: ', selector printString].    arguments := Array new: (MessageSend numberOfArgumentsFor: selector).    self        when: eventName        evaluate:            (MessageSend                receiver: anObject                selector: selector                arguments: arguments)</body><body package="GF/ST Base">when: eventName send: selector to: anObject withArguments: argumentList        "Form an action with &lt;anObject&gt; as the receiver,        a &lt;selector&gt; as the message selector, and the        elements of the &lt;argumentList&gt; as the arguments        and append it to the actions list for the event        named &lt;eventName&gt;."    | arguments |    selector isSymbol        ifFalse: [^self error: selector].    arguments := Array new: selector numArgs.    arguments        replaceFrom: 1        to: (arguments size min: argumentList size)        with: argumentList        startingAt: 1.    self        when: eventName        evaluate:            (MessageSend                receiver: anObject                selector: selector                arguments: arguments)</body></methods><methods><class-id>Polymorphic.PsiEventModel class</class-id> <category>triggering events</category><body package="GF/ST Base">canTriggerEvent: eventName        "Answer &lt;true&gt; if instances of the receiver can trigger an event        named &lt;eventName&gt;. "    ^self eventsTriggered includes: eventName asSymbol</body><body package="GF/ST Base">constructEventsTriggered        "Private - answer the set of events that instances of the        receiver can trigger."    ^Set with: #changed</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the events triggered"    eventsTriggered isNil ifTrue: [		eventsTriggered := self constructEventsTriggered.	].	eventsTriggered            add: #changed;            add: #changed:.    ^eventsTriggered</body><body package="GF/ST Base">initializeEventsTriggered        "Private - initialize all the events which can be triggered        by instances of the receiver."    eventsTriggered := nil.    self eventsTriggered</body><body package="GF/ST Base">resetEventsTriggered    self withAllSubclasses do: [:each | each initializeEventsTriggered].</body></methods><methods><class-id>Polymorphic.GFGraphicObject</class-id> <category>GF/ST</category><body package="GF/ST Base">&lt;= aGFGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | forward backward |    aGFGraphicObject isHostWidgetGO ifTrue: [^true].    forward := next.	backward := prev.    [forward == nil or: [backward == nil ]] whileFalse: [        forward == aGFGraphicObject ifTrue: [^true].		backward == aGFGraphicObject ifTrue: [^false ].        forward == nil ifFalse: [forward := forward nextGO].		backward == nil ifFalse: [backward := backward prevGO].    ].    backward == nil ifTrue: [ ^true ].	^false</body><body package="GF/ST Base">absolute: aFractionPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the point that represents the fraction of the receiver called     for by aFractionPoint.  For example, if aFractionPoint is 0.5@0.5,     the result will be the point representing the center of the receiver's area.    "    | aRectangle |    aRectangle := self displayBox.    ^(aRectangle extent * aFractionPoint rightAndDown: aRectangle origin) rounded</body><body package="GF/ST Base">addAfter: aGFGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add the receiver after aGFGraphicObject"    self unlink.    aGFGraphicObject == nil        ifTrue: [container firstGO isNil ifTrue: [container firstGO: self; lastGO: self] ifFalse: [self addBefore: container firstGO]]        ifFalse: [aGFGraphicObject insert: self].</body><body package="GF/ST Base">addBefore: aGFGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add the receiver before aGFGraphicObject"    self unlink.    aGFGraphicObject == nil ifTrue: [        container firstGO: self; lastGO: self.        ^self    ].    self nextGO: aGFGraphicObject.    self prevGO: aGFGraphicObject prevGO.    self prevGO isNil        ifTrue: [container firstGO: self]        ifFalse: [prev nextGO: self].    aGFGraphicObject prevGO: self.</body><body package="GF/ST Base">align: alignmentPoint with: relativePoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Align the receiver relative to the relativePoint, based on the     alignmentPoint.    "    self translateBy: (relativePoint leftAndUp: alignmentPoint) rounded</body><body package="GF/ST Base">alignToGrid: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Snap aPoint to the grid of the drawing in which the receiver is     contained.  This is a destructive operation.  IE, the point is modified     to be constrained to the grid.    "    ^container alignToGrid: aPoint</body><body package="GF/ST Base">attributeInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the collection of attribute information"    ^(OrderedCollection new)</body><body package="GF/ST Base">attributeMemento"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the memento that will restore the attributes of the receiver.     (Such things as color, line width, etc)    "    ^(GFMemento originator: self)        addAllActions: (self triggerEvent: #attributeState ifNotHandled: [self attributeInformation])</body><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    ^self subclassResponsibility</body><body package="GF/ST Base">bottom"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the bottom point of the receiver's area"    ^self displayBox bottom</body><body package="GF/ST Base">bottomCenter"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the center point of the bottom of the receiver's area"    ^self displayBox bottomCenter rounded</body><body package="GF/ST Base">bottomLeft"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the bottom left point of the receiver's area"    ^self displayBox bottomLeft</body><body package="GF/ST Base">bottomRight"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the bottom right point of the receiver's area"    ^self displayBox bottomRight</body><body package="GF/ST Base">boundingBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a rectangle that bounds the receiver's area"    ^self displayBox</body><body package="GF/ST Base">button1DoubleClick"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver has been double clicked with the button 1 down"    ^self triggerEvent: #button1DoubleClick</body><body package="GF/ST Base">canBeConnected"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver can be connected with another GO"    ^ true</body><body package="GF/ST Base">canMove"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver can move"    ^true</body><body package="GF/ST Base">center"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the center point of the receiver's area"    ^self displayBox center</body><body package="GF/ST Base">connectionPosition"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Return the position that a connection should be connected to me."     ^self center</body><body package="GF/ST Base">containedBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver's area is contained in aRectangle"    ^aRectangle contains: self displayBox</body><body package="GF/ST Base">container"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic object containing the receiver"    ^container</body><body package="GF/ST Base">container: aContainer"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the container of the receiver"    container := aContainer</body><body package="GF/ST Base">containsPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver's area contains a point"    ^self displayBox containsPoint: aPoint</body><body package="GF/ST Base">coordinateToNative: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a point in the coordinate system expressed     in the native coordinate system    "    ^container coordinateToNative: aPoint</body><body package="GF/ST Base">corner"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the corner point of the receiver's area"    ^self displayBox corner</body><body package="GF/ST Base">damageDuring: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver is going to damage the container during a block.      Allow the container to compensate for this.    "    container == nil        ifTrue: [aBlock evaluate]        ifFalse: [            container damage: self during: aBlock        ]</body><body package="GF/ST Base">damaged"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Signal that the entire area of the receiver has been damaged"    ^self damaged: self displayBox.</body><body package="GF/ST Base">damaged: anArea"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Nofify the container of the receiver that anArea has been damaged.     Raise the damaged event.  Answer the area damaged.    "    container == nil ifFalse: [        container damageRegion: anArea    ].    self triggerEvent: #damaged.    ^anArea</body><body package="GF/ST Base">delete"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Delete the receiver from the GO chain"    container == nil ifTrue: [^self].    next == nil ifFalse: [next prevGO: prev].    prev == nil ifFalse: [prev nextGO: next].    container lastGO == self ifTrue: [container lastGO: prev].    container firstGO == self ifTrue: [container firstGO: next].    next := prev := nil.</body><body package="GF/ST Base">deselect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver is no longer selected.  Raise the event notifying anyone     who wants to know    "    self triggerEvent: #deselect</body><body package="GF/ST Base">disableInteraction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Disable all interaction with the receiver GO"    self        disableMenu;        disableHandles;        disablePositionHandle</body><body package="GF/ST Base">disableMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Disable the generation of the menu by the receiver"    self when: #getMenu send: #noMenu to: self.</body><body package="GF/ST Base">disablePositionHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Disable the receiver from moving.  See #positionHandle for more     explanation.    "    self when: #needsPositionHandle send: #noPositionHandle to: self.</body><body package="GF/ST Base">display: rect with: pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self displayWith: pen</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^self origin copy extentWith: self extent</body><body package="GF/ST Base">displayPane"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	container == nil ifTrue: [^nil].	^container displayPane</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    self subclassResponsibility</body><body package="GF/ST Base">displayShapeWith: aPen at: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the mask of the receiver at aPoint.  See displayShapeWith:     for more information    "    | oldOrigin |    (oldOrigin := self origin copy) = aPoint ifFalse: [        self basicTranslateBy: aPoint - oldOrigin.    ].    self displayShapeWith: aPen.    self basicTranslateBy: (aPoint - oldOrigin) negated</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    ^self subclassResponsibility</body><body package="GF/ST Base">displayWith: aPen at: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the receiver's image at aPoint with aPen.  See #displayWith:     for more details    "    | oldOrigin |    (oldOrigin := self origin copy) = aPoint ifFalse: [        self basicTranslateBy: aPoint - oldOrigin.    ].    self displayWith: aPen.    self basicTranslateBy: (aPoint - oldOrigin) negated</body><body package="GF/ST Base">displayWith: aPen window: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the receiver if the receiver's area intersects aRectangle.     Subclasses should not override this.  Override #displayWith: instead.     "    (self displayBox intersects: aRectangle) ifTrue: [self displayWith: aPen].</body><body package="GF/ST Base">do: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Traverse the linked list of of graphic objects starting with the receiver"    | current |    current := self.    [current == nil] whileFalse: [        aBlock value: current.        current := current nextGO.    ].</body><body package="GF/ST Base">enableDefaultInteraction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Enable interaction with the receiver"    self enableMenu;        enableHandles;        enablePositionHandle</body><body package="GF/ST Base">enableMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Enable the generation of the menu."    self removeActionsSatisfying: [:event |        (event respondsTo: #receiver) and: [            event receiver == self and: [                event selector == #noMenu]]    ] forEvent: #getMenu</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^self subclassResponsibility</body><body package="GF/ST Base">finalize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Finalize the receiver"    self release</body><body package="GF/ST Base">graphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic object of the receiver.  Self, of course"    ^self</body><body package="GF/ST Base">graphicObjectAt: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic object whose display area contains a point"    ^(self containsPoint: aPoint)           ifTrue: [self]        ifFalse: [nil]</body><body package="GF/ST Base">graphicObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an array of graphic objects, the receiver has"    ^Array with: self</body><body package="GF/ST Base">grid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the grid used by the receiver"    ^container grid</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the points the receiver should snap to the grid used by     the receiver.     Subclasses should override this to implement their own behavior     towards the grid    "    self subclassResponsibility</body><body package="GF/ST Base">hasHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer if the receiver has host widgets"    ^false</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Don't need to do anything. Just here to support it in my subclasses."</body><body package="GF/ST Base">insert: aGFGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Insert aGFGraphicObject after the receiver"    aGFGraphicObject unlink.    aGFGraphicObject nextGO: next.    next == nil ifFalse: [next prevGO: aGFGraphicObject].    self nextGO: aGFGraphicObject.    aGFGraphicObject prevGO: self.    container lastGO == self ifTrue: [container lastGO: aGFGraphicObject].</body><body package="GF/ST Base">interface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Ask the container for the interface"    container == nil ifTrue: [^nil].    ^container interface</body><body package="GF/ST Base">intersects: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver's display area intersects with aRectangle"    ^self displayBox intersects: aRectangle</body><body package="GF/ST Base">isActive"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver interacts with a tool or not"    ^false</body><body package="GF/ST Base">isCompositeGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver is a composite graphic object or not"    ^false</body><body package="GF/ST Base">isConnectionGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver represents a connection between     two graphic objects    "     ^false</body><body package="GF/ST Base">isContainerGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver is a container of other GOs"    ^false</body><body package="GF/ST Base">isGFDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver is a GFDrawing"    ^false</body><body package="GF/ST Base">isGFGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver is a GFGraphicObject or not"    ^true</body><body package="GF/ST Base">isGroupGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver is a group GO or not"    ^false</body><body package="GF/ST Base">isHostWidgetGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the reciever is a host widget or not"    ^false</body><body package="GF/ST Base">kindsOfGOs"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an array of classes the receiver contains"    ^Array with: self class</body><body package="GF/ST Base">left"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the left point of the display area"    ^self displayBox left</body><body package="GF/ST Base">leftCenter"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the left center point of the receiver's display area"    ^self displayBox leftCenter rounded</body><body package="GF/ST Base">locator"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the locator for the receiver"    ^GFLocator on: self at: #center</body><body package="GF/ST Base">menu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the menu of the receiver"	^self triggerEvent: #getMenu ifNotHandled: [self standardMenu].</body><body package="GF/ST Base">metaObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Anwer the object which holds behavior for the receiver"    ^self triggerEvent: #getMetaObject</body><body package="GF/ST Base">metaObject: aMetaObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the object which holds behavior for the receiver"    self when: #getMetaObject send: #yourself to: aMetaObject.</body><body package="GF/ST Base">moveToFirst"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Make the receiver the first in the GO chain"    | fl |    self unlink.    (fl := container firstGO) == nil        ifTrue: [ container lastGO: self ]        ifFalse: [            fl == self ifFalse: [                fl prevGO: self.                self nextGO: fl.                self prevGO: nil]        ].    container firstGO: self.</body><body package="GF/ST Base">moveToLast"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Make the receiver the last in the GO chain"    | ll |    self unlink.    (ll := container lastGO) == nil        ifTrue: [container firstGO: self]        ifFalse: [            ll == self ifFalse: [                ll nextGO: self.                self prevGO: ll.                self nextGO: nil.]        ].     container lastGO: self</body><body package="GF/ST Base">nativeToCoordinate: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a point in the native coordinate system expressed     in the coordinate system defined by the container    "    ^container nativeToCoordinate: aPoint</body><body package="GF/ST Base">nextGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^next</body><body package="GF/ST Base">nextGO: aGFGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    aGFGraphicObject == self ifTrue: [ self error: 'This should not occur' ].    next := aGFGraphicObject.</body><body package="GF/ST Base">noMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer nil"    ^#noMenu</body><body package="GF/ST Base">offCenter: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the point offset from the center of the receiver's display     area by the deltaPoint    "     ^self center rightAndDown: deltaPoint</body><body package="GF/ST Base">offCorner: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the point offset from the receiver's corner by a deltaPoint"    ^self displayBox corner rightAndDown: deltaPoint</body><body package="GF/ST Base">offOrigin: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the point offset from the receiver's origin by a deltaPoint"    ^self displayBox origin rightAndDown: deltaPoint</body><body package="GF/ST Base">offTopLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the point offset from the receiver's top left corner by a deltaPoint"    ^self displayBox topLeft rightAndDown: deltaPoint</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"    ^self subclassResponsibility</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the information needed to restore the receiver's current position,     including z-order    "    ^(OrderedCollection new)        add: (self class gfMessageClass receiver: nil selector: #delete );        add: (self class gfMessageClass receiver: nil selector: #nextGO: arguments: (Array with: next));        add: (self class gfMessageClass receiver: nil selector: #prevGO: arguments: (Array with: prev));        add: (self class gfMessageClass receiver: nil selector: #container: arguments: (Array with: container ));        add: (self class gfMessageClass receiver: nil selector: #restoreOrder );        yourself</body><body package="GF/ST Base">positionMemento"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer a memento that will restore the receiver's position"    ^(GFMemento originator: self)        addAllActions: (self triggerEvent: #positionState ifNotHandled: [self positionInformation]).</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform any additional action after copy."    container := prev := next := nil.</body><body package="GF/ST Base">prevGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^prev</body><body package="GF/ST Base">prevGO: aGFGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    aGFGraphicObject == self ifTrue: [ self error: 'This should not occur'].    prev := aGFGraphicObject.</body><body package="GF/ST Base">redraw"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Redraw the receiver"    container == nil ifFalse: [container redraw]</body><body package="GF/ST Base">relative: anAbsolutePoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the fractional point representing anAbsolute point     relative to the receiver's extent.  For instance, if anAbsolutePoint     is the center of the receiver, this method will answer 0.5@0.5    "    | aRectangle |    aRectangle := self displayBox.    ^(anAbsolutePoint leftAndUp: aRectangle origin) * 1.0 / aRectangle extent</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Release the receiver"     self triggerEvent: #releasing.    super release.    self unlink.    container := nil.</body><body package="GF/ST Base">restoreFrom: aMemento"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Restore the receiver from aMemento"    self damageDuring: [super restoreFrom: aMemento].</body><body package="GF/ST Base">restoreOrder"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Restore the z-order of the receiver"    container privateAdd: self.    prev isNil        ifTrue: [ container firstGO: self ]        ifFalse: [ prev nextGO: self ].    next isNil        ifTrue: [ container lastGO: self ]        ifFalse: [ next prevGO: self ].</body><body package="GF/ST Base">right"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the right point of the display area"    ^self displayBox right</body><body package="GF/ST Base">rightCenter"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the right center point of the receiver"    ^self displayBox rightCenter rounded</body><body package="GF/ST Base">scaleBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Scale the receiver by the scale represented by aPoint"    self        align: self displayBox center        with: (self displayBox center scaleBy: aPoint)</body><body package="GF/ST Base">select"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver has been selected"    ^self triggerEvent: #select</body><body package="GF/ST Base">senseBottomLeft: deltaPoint"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	|growPoint |	growPoint := deltaPoint * Rectangle leftBottomGrowUnit.	^growPoint x @ 0 rightBottom: 0 @ growPoint y</body><body package="GF/ST Base">senseBottomRight: deltaPoint"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	| growPoint |	growPoint := deltaPoint * Rectangle rightBottomGrowUnit.	^0 @ 0 rightBottom: growPoint x @ growPoint y</body><body package="GF/ST Base">senseColor: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the vertical delta used to change color of the receiver"    ^deltaPoint y</body><body package="GF/ST Base">senseTopLeft: deltaPoint"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	| growPoint |	growPoint := deltaPoint * Rectangle leftTopGrowUnit.	^growPoint x @ growPoint y rightBottom: 0@0</body><body package="GF/ST Base">senseTopRight: deltaPoint"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	| growPoint |	growPoint := deltaPoint * Rectangle rightTopGrowUnit.	^0 @ growPoint y rightBottom: (growPoint x)@ 0</body><body package="GF/ST Base">snapToGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap the receiver to the grid"    self damageDuring: [        self gridPoints do: [ :pt | pt alignToGrid: self grid ]    ].</body><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^nil</body><body package="GF/ST Base">storeMemento: aMemento for: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Store a memento for anObject in the container of the receiver"    container notNil ifTrue: [ container storeMemento: aMemento for: anObject ]</body><body package="GF/ST Base">top"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the top point of the receiver's display box"    ^self displayBox top</body><body package="GF/ST Base">topCenter"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the top center point of the receiver's display box"    ^self displayBox topCenter rounded</body><body package="GF/ST Base">topLeft"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the top left point of the receiver's display area"    ^self displayBox topLeft</body><body package="GF/ST Base">topRight"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the top right point of the receiver's display are"    ^self displayBox topRight</body><body package="GF/ST Base">translateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "move me a distance of aPoint.    Don't override this method, override basicTranslateBy:, instead."    self damageDuring: [self basicTranslateBy: aPoint].    self triggerEvent: #translate</body><body package="GF/ST Base">translateTo: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Translate the receiver to aPoint"    self translateBy: (aPoint leftAndUp: self displayBox origin)</body><body package="GF/ST Base">translateToLocation: locator"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self translateTo: locator asPoint</body><body package="GF/ST Base">unlink"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove the receiver from the GO chain"    container == nil ifTrue: [^self].    next == nil ifFalse: [next prevGO: prev].    prev == nil ifFalse: [prev nextGO: next].    container lastGO == self ifTrue: [container lastGO: prev].    container firstGO == self ifTrue: [container firstGO: next].    next := prev := nil.</body><body package="GF/ST Base">willDamage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver is going to change its display in some way, damage     the receiver's entire display area    "    ^self willDamage: self displayBox</body><body package="GF/ST Base">willDamage: anArea"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver is going to change its display.  Notify the receiver's     container about the damaged area    "    container == nil ifFalse: [        container damageRegion: anArea    ].    ^anArea</body></methods><methods><class-id>Polymorphic.GFGraphicObject</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the default handles of the receiver"    ^GFSelectionTrackHandle allCornersOf: self</body><body package="GF/ST Base">defaultPositionHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"	^GFSelectionTrackHandle positionOf: self</body><body package="GF/ST Base">disableHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Disable the generation of handles by the receiver"    self when: #generateHandles send: #noHandles to: self.</body><body package="GF/ST Base">enableHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Enable the generation of handles."    self removeActionsSatisfying: [:event |        (event respondsTo: #receiver) and: [            event receiver == self and: [                event selector == #noHandles]]    ] forEvent: #generateHandles</body><body package="GF/ST Base">enablePositionHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Enable the ability of the receiver to move."    self removeActionsSatisfying: [:event |        (event respondsTo: #receiver) and: [            event receiver == self and: [                event selector == #noPositionHandle]]    ] forEvent: #needsPositionHandle</body><body package="GF/ST Base">generateHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the handles used by the receiver"    ^self        triggerEvent: #generateHandles        ifNotHandled: [self defaultHandles]</body><body package="GF/ST Base">generatePositionHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Generate the position handle for the receiver.  This handle is used	 by the tools to move the receiver around	"	^self		triggerEvent: #needsPositionHandle		ifNotHandled: [self defaultPositionHandle]</body><body package="GF/ST Base">noHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an empty array"    ^Array new</body><body package="GF/ST Base">noPositionHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This method is used as an empty method to return no handles when the position handle is disabled.  Answer nil"    ^nil</body></methods><methods><class-id>Polymorphic.GFGraphicObject</class-id> <category>private</category><body package="GF/ST Base">scale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^container == nil 		ifTrue: [ 1@1 ]		ifFalse: [ container scale ]</body></methods><methods><class-id>Polymorphic.GFGraphicObject</class-id> <category>display</category><body package="GF/ST Base">displayOn: aGC"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self displayWith: aGC</body></methods><methods><class-id>Polymorphic.GFGraphicObject</class-id> <category>conversion</category><body package="GF/ST Base">asGFEndPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^GFGoEndPlug fromGO: self</body></methods><methods><class-id>Polymorphic.GFGraphicObject</class-id> <category>scaling</category><body package="GF/ST Base">unscaledExtent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self extent</body></methods><methods><class-id>Polymorphic.GFGraphicObject</class-id> <category>testing</category><body package="GF/ST Base">isVisible	^container isNil		ifTrue: [true]		ifFalse: [container isVisible]</body></methods><methods><class-id>Polymorphic.GFGraphicObject class</class-id> <category>GF/ST</category><body package="GF/ST Base">boundingRectangleForPoints: arrayOfPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a Rectangle that bounds the supplied array of Points."    | origin corner v |    origin := corner := arrayOfPoints first.    1 to: arrayOfPoints size do: [:i |        v := arrayOfPoints at: i.        origin := origin min: v.        corner := corner max: v].    ^Rectangle origin: origin corner: corner</body><body package="GF/ST Base">clearColors"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	ColorTable := nil.	DefaultLineColor := nil.</body><body package="GF/ST Base">colorTable"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	ColorTable == nil ifTrue: [ self initializeColorTable ].	^ColorTable</body><body package="GF/ST Base">defaultLineColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"This is the default line color to be used when creating and initializing	GFGraphicObjects"		DefaultLineColor == nil ifTrue: [ self defaultLineColor: RGBColor black ].	^DefaultLineColor</body><body package="GF/ST Base">defaultLineColor: color"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Sets the default line color to be used in the creation and initialization of	GFGraphicObjects"	DefaultLineColor := color</body><body package="GF/ST Base">eventsTriggered	"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the events triggered"	eventsTriggered isNil 		ifTrue: 			[(eventsTriggered := Set new)				addAll: self superclass eventsTriggered;				add: #button1DoubleClick;				add: #select;				add: #deselect;				add: #getMetaObject;				add: #getMenu;				add: #getMenuPerformer;				add: #damaged;				add: #generateHandles;				add: #needsPositionHandle;				add: #translate;				add: #positionState;				add: #attributeState;				add: #releasing].	^eventsTriggered</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "GFGraphicObject initialize"    self initializeColorTable.    self resetEventsTriggered</body><body package="GF/ST Base">initializeColorTable"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "GFGraphicObject initializeColorTable"    ColorTable := OrderedCollection new.    ColorTable        add: Color white;        add: Color gray;        add: Color darkGray;        add: Color black;        add: Color blue;        add: Color darkBlue;        add: Color brown;        add: Color cyan;        add: Color darkCyan;        add: Color green;        add: Color darkGreen;        add: Color pink;        add: Color darkPink;        add: Color red;        add: Color darkRed;        add: Color yellow.</body><body package="GF/ST Base">vertices: aPointArray intersectsRectangle: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer true if any of the line segments described by the pointArray intersects the supplied rectangle."    | left top right bottom x1 x2 y1 y2 point i size |    left := (aRectangle left) rounded.    top := (aRectangle top) rounded.    right := (aRectangle right) rounded.    bottom := (aRectangle bottom) rounded.    point := aPointArray at: 1.    x1 := (point x) rounded.    y1 := (point y) rounded.    size := aPointArray size.    i := 2.    [i &gt; size or:        [point := aPointArray at: i.        x2 := (point x) rounded.        y2 := (point y) rounded.        self visibleX1: x1 y1: y1 x2: x2 y2: y2 inLeft: left top: top right: right bottom: bottom]]    whileFalse: [x1 := x2. y1 := y2. i := i + 1].    ^i &lt;= size</body><body package="GF/ST Base">visibleX1: x1 y1: y1 x2: x2 y2: y2 inLeft: left top: top right: right bottom: bottom"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Test to see whether the line segment (x1, y1, x2, y2) intersects the rectangle    (left, top, right, bottom).  Answer true if the line intersects, false otherwise."    "This is an adaptation of the 'clipping by midpoint subdivision' algorithm.    A faster implementation would keep track of the endpoint visibility, and a more    general implementation would return an intersection point useful for clipping."    | mx my |    "Test for trivial exclusion."    ((x1 &lt; left and: [x2 &lt; left])        or: [(x1 &gt;= right and: [x2 &gt;= right])                or: [(y1 &lt; top and: [y2 &lt; top])                        or: [y1 &gt;= bottom and: [y2 &gt;= bottom]]]])        ifTrue: [^false].    "Test for trivial inclusion."    (((x1 &gt;= left and: [x1 &lt; right])        and: [y1 &gt;= top and: [y1 &lt; bottom]])        or: [(x2 &gt;= left and: [x2 &lt; right])                and: [y2 &gt;= top and: [y2 &lt; bottom]]])        ifTrue: [^true].    "Otherwise, subdivide at midpoint and test both sections."    mx := x2 + x1 // 2.    my := y2 + y1 // 2.    "If the line is so short that it can't be divided, and yet the tests    were inconclusive, both endpoints must have been outside the    rectangle, and so we assume the line does not intersect the region"    ((mx = x1 or: [mx = x2]) and:            [my = y1 or: [my = y2]])        ifTrue: [^false].    ^(self visibleX1: x1 y1: y1 x2: mx y2: my inLeft: left top: top right: right bottom: bottom)        or: [self visibleX1: mx y1: my x2: x2 y2: y2 inLeft: left top: top right: right bottom: bottom]</body></methods><methods><class-id>Polymorphic.GFGraphicObject class</class-id> <category>instance creation</category><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new initialize.</body></methods><methods><class-id>Polymorphic.GFAbstractPathGO</class-id> <category>GF/ST</category><body package="GF/ST Base">attributeInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the collection of attribute information"    ^(super attributeInformation)        add: (self class gfMessageClass receiver: nil selector: #color: arguments: (Array with: color));        add: (self class gfMessageClass receiver: nil selector: #width: arguments: (Array with: width));        yourself</body><body package="GF/ST Base">choosePathColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Choose the path color for the receiver"    | newColor |    self storeMemento: (self attributeMemento) for: self.    (newColor := Color pickAColor) == nil ifFalse: [        self damageDuring: [color := newColor].        self redraw.    ].</body><body package="GF/ST Base">color"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the path color of the receiver"    ^color</body><body package="GF/ST Base">color: aColorValue"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the path color of the receiver"    color := aColorValue</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^super displayBox expandedByScalar: width</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    "Subclasses should call this before doing their own    specific display, sos we get the shared behavior here"    aPen        setStyle: lineStyle        color: Color black        width: self width.</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Subclasses should call this before doing their own    specific display, sos we get the shared behavior here"    aPen        setStyle: lineStyle        color: color        width: self width.</body><body package="GF/ST Base">growBy: aValue"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Do nothing, as the paths don't really 'grow' this way"    ^self</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Initialize to default values"    width := 1.    color := self class defaultLineColor.    lineStyle := 0</body><body package="GF/ST Base">lineStyle: aLineStyle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the line style of the receiver"    lineStyle := aLineStyle</body><body package="GF/ST Base">setBorderWidth: w"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the width of the path"    | interface |    self storeBorderMemento.    ((interface := self interface) isSelected: self)            ifTrue: [ (interface handlesFor: self) do: [ :handle | interface hideHandle: handle ]].    self damageDuring: [self width: w]</body><body package="GF/ST Base">setLineStyle: aLineStyle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the line style of the receiver"    | interface |    ((interface := self interface) isSelected: self)            ifTrue: [ (interface handlesFor: self) do: [ :handle | interface hideHandle: handle ]].    self damageDuring: [self lineStyle: aLineStyle]</body><body package="GF/ST Base">storeBorderMemento"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - store the border memento of the receiver"    self        storeMemento: ((GFMemento originator: self)                                        addActionSelector: #width: with: width)        for: self.</body><body package="GF/ST Base">width"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the width of the path.  In Windows, only a    lineStyle of 0 will be able to extend    outside of the bounds of the area that is being drawn"    ^(lineStyle == 0 or: [ lineStyle == 6 ])        ifTrue: [ width ]        ifFalse: [ 1 ]</body><body package="GF/ST Base">width: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the width of the receiver"    width := anInteger</body></methods><methods><class-id>Polymorphic.GFAbstractPathGO</class-id> <category>menus</category><body package="GF/ST Base">appendLineColorItemTo: aMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Append the line color selector to aMenu"    ^aMenu        addItemLabel: 'Line Color...' value: #choosePathColor;        yourself</body><body package="GF/ST Base">appendLineStyleItemTo: aMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Append the line style item to aMenu"    ^aMenu        appendMenu: self styleMenu;        yourself</body><body package="GF/ST Base">pathMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the path menu of the receiver"    ^Menu new        addItemLabel: '1 pixel' value: [self setBorderWidth: 1];        addItemLabel: '2 pixel' value: [self setBorderWidth: 2];        addItemLabel: '3 pixel' value: [self setBorderWidth: 3];        addItemLabel: '4 pixel' value: [self setBorderWidth: 4];        addItemLabel: '5 pixel' value: [self setBorderWidth: 5];        yourself</body><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    | menu |    (menu := Menu new)        addItem: ((MenuItem labeled: 'Line Width') submenu: self pathMenu).	"menu addItem: ((MenuItem labeled: 'Line Style') submenu: self styleMenu)."    self appendLineColorItemTo: menu.    ^menu</body><body package="GF/ST Base">styleMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the style menu of the receiver"	^Menu new</body></methods><methods><class-id>Polymorphic.GFAbstractPathGO</class-id> <category>private</category><body package="GF/ST Base">scaledWidth"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This is a Private method for the use of displayBox adjustment"	| factor scale |	^(scale := self scale asPoint) = (1@1)			ifTrue: [ width ]			ifFalse: [ (factor := scale max) &gt; 1 					ifTrue: [  (factor + width) ceiling ]					ifFalse: [ (((width + width) / factor) ceiling) ]]</body></methods><methods><class-id>Polymorphic.GFDirectedPathGO</class-id> <category>accessing</category><body package="GF/ST Base">lineStart"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^startPlug == nil 		ifTrue: [ self startPoint ]		ifFalse: [ self startPoint + startPlug connectionOffset ]</body><body package="GF/ST Base">lineStop"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^stopPlug == nil 		ifTrue: [ self stopPoint ]		ifFalse: [ self stopPoint + stopPlug connectionOffset ]</body><body package="GF/ST Base">startPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^startPlug</body><body package="GF/ST Base">startPlug: aLineEndPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	startPlug := aLineEndPlug.</body><body package="GF/ST Base">startPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self subclassResponsibility</body><body package="GF/ST Base">startPoint: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self subclassResponsibility</body><body package="GF/ST Base">stopPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^stopPlug</body><body package="GF/ST Base">stopPlug: aLineEndPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	stopPlug := aLineEndPlug.</body><body package="GF/ST Base">stopPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self subclassResponsibility</body><body package="GF/ST Base">stopPoint: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self subclassResponsibility</body></methods><methods><class-id>Polymorphic.GFDirectedPathGO</class-id> <category>bounds</category><body package="GF/ST Base">containsPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(self startContainsPoint: pt) or: [ self stopContainsPoint: pt ]</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| displayBox |	startPlug == nil ifFalse: [		displayBox := self startBox.		stopPlug == nil ifFalse: [ displayBox := displayBox merge:  self stopBox ].		^displayBox.	].	stopPlug == nil ifFalse: [^self stopBox].	^GFEmptyRectangle new</body><body package="GF/ST Base">startContainsPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^startPlug == nil 		ifTrue: [ false ]		ifFalse: [ startPlug containsPoint: pt ]</body><body package="GF/ST Base">stopContainsPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^stopPlug == nil 		ifTrue: [ false ]		ifFalse: [ stopPlug containsPoint: pt ]</body></methods><methods><class-id>Polymorphic.GFDirectedPathGO</class-id> <category>private</category><body package="GF/ST Base">startBox"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^startPlug displayBox</body><body package="GF/ST Base">stopBox"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^stopPlug displayBox</body></methods><methods><class-id>Polymorphic.GFDirectedPathGO</class-id> <category>copying</category><body package="GF/ST Base">copy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| new rDict |	new := super copy. "Note: this does the #postCopy"	(startPlug == nil and: [ stopPlug == nil]) ifTrue: [ ^new ].	rDict := (Dictionary new) at: self put: new; yourself.	startPlug == nil 		ifFalse: [ 			new startPlug copyUsing: rDict.			new startPlug displayPoint: new startPoint ].	stopPlug == nil 		ifFalse: [ 			new stopPlug copyUsing: rDict.			new stopPlug displayPoint: new stopPoint ].	^new</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved""Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Perform any additional action after copy."	super postCopy.	startPlug := startPlug copy.	stopPlug := stopPlug copy.</body></methods><methods><class-id>Polymorphic.GFDirectedPathGO</class-id> <category>display</category><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved""Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Display a mask for the receiver.  The mask is black and white, where	 black represents the opaque area, and white represents the transparent	 area	"	super displayShapeWith: aPen.	startPlug == nil ifFalse: [ startPlug displayShapeWith: aPen ].	stopPlug == nil ifFalse: [ stopPlug displayShapeWith: aPen ]</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"The central display routine.  Display the image of the receiver,	 using aPen.  The receiver should make no assumptions regarding	 the state of the pen, and is not responsible for resetting the pen	 to the previous state.	"	startPlug == nil ifFalse: [ startPlug displayWith: aPen ].	stopPlug == nil ifFalse: [ stopPlug displayWith: aPen ].	super displayWith: aPen.</body></methods><methods><class-id>Polymorphic.GFDirectedPathGO</class-id> <category>plug macros</category><body package="GF/ST Base">endArrowPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the endPlug used to display an arrow head at the end of the line"	| plug |	plug := (GFMessage new		receiver: self;		selector: #displayEndArrowWith:for:) asGFEndPlug.	plug shapeAction: 		(GFMessage new			receiver: self;			selector: #displayEndArrowShapeWith:for:).	^plug</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>plug macros</category><body package="GF/ST Base">basicDisplayEndArrowWith: pen for: plug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an arrow head at the end of the line"	| arrow1 arrow2 vector u aPoint start stop plugBox oldJoin |	stop := points last.	start := (points at: points size - 1).	(vector := stop - start) = (0@0)		ifTrue: [			u := 0@1.			aPoint := stop - ((1@0) * width * 7).		]		ifFalse: [			u := vector normal unitVector.			aPoint := stop - (vector unitVector "* width" * 7)		].	arrow1 := (aPoint + (u * ("width *" 3))) rounded.	arrow2 := (aPoint - (u * ("width *" 3))) rounded.	plugBox := ((((arrow1 copy becomeLeftMostAndHighest: arrow2)									becomeLeftMostAndHighest: stop) corner: (							((arrow1 copy becomeRightMostAndLowest: arrow2) 									becomeRightMostAndLowest: stop))) expandByScalar: width * 2).	plug extent: plugBox extent.	plug displayOffset: plugBox origin - stop.	plug displayPoint: stop.	oldJoin := pen joinStyle.	pen		setStyle: lineStyle		color: color		width: self width.	pen joinStyle: pen class joinMiter.	pen fastPolygonFilled: (Array with: stop with: arrow1 with: arrow2 with: stop).	pen joinStyle: oldJoin</body><body package="GF/ST Base">displayEndArrowShapeWith: pen for: plug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an arrow head at the end of the line"	pen blackFill.	self basicDisplayEndArrowWith: pen for: plug</body><body package="GF/ST Base">displayEndArrowWith: pen for: plug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an arrow head at the end of the line"	color isNil		ifTrue: [ pen blackFill ]		ifFalse: [ pen setFillColorTo: color ].	self basicDisplayEndArrowWith: pen for: plug</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>translation</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Translate the receiver by aPoint"	"Origin must move also."	| lim |	lim := points last == points first			ifTrue: [ 1] ifFalse: [ 0].	1 to: points size - lim do: [:i | (points at: i) translatedByPoint: aPoint].	origin translatedByPoint: aPoint.</body><body package="GF/ST Base">translatePoints: pointArray by: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Translate the points in a pointArray by aPoint"	| translated |	translated := pointArray deepCopy.	translated do: [:each | each translatedByPoint: aPoint].	^translated</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>bounds</category><body package="GF/ST Base">containsPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether or not the receiver's area contains a point"		^((self displayBox containsPoint: aPoint)			and: [(self lineHitBy: aPoint)				or: [ closed ]]) or: [super containsPoint: aPoint]</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the display area of the receiver"	^super displayBox merge: ((Rectangle origin: origin extent: extent) expandByScalar: width)</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>accessing</category><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the extent of the display area of the receiver"	^extent</body><body package="GF/ST Base">fillColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the fill color of the receiver"	^fillColor</body><body package="GF/ST Base">fillColor: aColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the fill color of the receiver"	fillColor := aColor</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the points the receiver should snap to the grid used by	 the receiver.	 Subclasses should override this to implement their own behavior	 towards the grid	"	^points</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the origin of the receiver"	^origin</body><body package="GF/ST Base">point: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the point indexed by anInteger"	^points at: anInteger</body><body package="GF/ST Base">points"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^points</body><body package="GF/ST Base">points: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Set the points of the receiver"	points := aCollection.	self recalculateBoundingBox.	self checkClosed</body><body package="GF/ST Base">points: aPointCollection width: anInteger color: aColorValue closed: aBoolean fillColor: anotherColorValue"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - initialize the receiver to the desired state"	points := aPointCollection.	width := anInteger.	color := aColorValue.	closed := aBoolean.	fillColor := anotherColorValue.	self recalculateBoundingBox.	self checkClosed.</body><body package="GF/ST Base">rounded"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Round the receiver's points"	1 to: points size do: [:i |		points at: i put: (points at: i) rounded.	].</body><body package="GF/ST Base">startPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^points first</body><body package="GF/ST Base">startPoint: aPoint	self shouldNotImplement</body><body package="GF/ST Base">stopPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^points last</body><body package="GF/ST Base">stopPoint: aPoint	self shouldNotImplement</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>displaying</category><body package="GF/ST Base">basicDisplayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"The central display routine.  Display the image of the receiver,	 using aPen.  The receiver should make no assumptions regarding	 the state of the pen, and is not responsible for resetting the pen	 to the previous state.	"	| pointArray | 	(startPlug ~~ nil or: [ stopPlug ~~ nil ])		ifTrue: [ pointArray := points copy.					 pointArray at: 1 put: self lineStart.					pointArray at: (points size) put: self lineStop ]		ifFalse: [ pointArray := points ].	closed		ifTrue: [			fillColor == nil				ifTrue: [ aPen fastPolyline: pointArray ]				ifFalse: [ aPen fastPolygonFilled: pointArray] ]		ifFalse: [aPen fastPolyline: pointArray].</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Display a mask for the receiver.  The mask is black and white, where	 black represents the opaque area, and white represents the transparent	 area	"	"Display a shape on aPen that corresponds to my image"	super displayShapeWith: aPen.	closed ifTrue: [ 			aPen setFillColorTo: RGBColor black ].	self basicDisplayWith: aPen</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"The central display routine.  Display the image of the receiver,	 using aPen.  The receiver should make no assumptions regarding	 the state of the pen, and is not responsible for resetting the pen	 to the previous state.	"	super displayWith: aPen.	closed ifTrue: [ 			aPen setFillColorTo: fillColor ].	self basicDisplayWith: aPen.</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>state manipulation</category><body package="GF/ST Base">chooseFillColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Choose the fill color of the receiver"	| newColor |	self storeMemento: (self attributeMemento) for: self.	(newColor := Color pickAColor) == nil ifFalse: [		self damageDuring: [fillColor := newColor].	].</body><body package="GF/ST Base">closed: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set my instance variable closed to aBoolean *only* if the last point in my points collection	is the same as the first point, i.e. I'm a closed figure."	points first = points last ifTrue: [closed := aBoolean]</body><body package="GF/ST Base">makeClosed"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the receiver a closed polyline"	self checkClosed ifTrue: [ ^self ].	self storeMemento: (self positionMemento) for: self.	self damageDuring:  [ 		points addLast: points first.			self closed: true	].	self redraw.</body><body package="GF/ST Base">makeOpen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the reeiver an open polyline"	(self checkClosed not or: [ points size &lt; 3 ])  ifTrue: [ ^self ].	self storeMemento: (self positionMemento) for: self.	self damageDuring:		[points removeLast.		closed := false].	self redraw.</body><body package="GF/ST Base">movePoint: i by: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the point indexed by i by a deltaPoint"	self damageDuring: [		(points at: i) translatedByPoint: deltaPoint.		self recalculateBoundingBox	].</body><body package="GF/ST Base">resetPoints: listOfPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Reset the points of the receiver to a listOfPoints"	closed := listOfPoints first == listOfPoints last.	self points: listOfPoints</body><body package="GF/ST Base">rotateBy: anAngle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Rotate the GFPolylineGO about its center by the given angle in radians."	| newX newY center  |	center := self center.	self damageDuring: [		points := points collect: [:point |			newX := center x + (point x - center x * anAngle cos)							- (point y - center y * anAngle sin).			newY := center y + (point y - center y * anAngle cos)							+ (point x - center x * anAngle sin).			newX @ newY		].	].	self triggerEvent: #rotate</body><body package="GF/ST Base">scaleBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Scale the receiver by aPoint"	self damageDuring: [self resetPoints: (points collect: [:each | (each scaleBy: aPoint) rounded])].	self triggerEvent: #resize with: self</body><body package="GF/ST Base">snapToGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Snap the receiver to the grid"	super snapToGrid.	self recalculateBoundingBox.</body><body package="GF/ST Base">transparent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the receiver transparent"	self storeMemento: (self attributeMemento) for: self.	self damageDuring: [fillColor := nil].</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>private</category><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	super initialize.	closed := false.</body><body package="GF/ST Base">quietlyRecalculateBoundingBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private -  Whenever any of my points change, I need to recalculate	my origin and extent."	"Origin is the smallest x and y values I have in my points collection.	Don't forget about the line width."	origin := (points inject: points first into: [:aPoint :minPoint | minPoint min: aPoint])		- (width // 2) rounded.	"Extent is the maximum extent as a Point.	Don't forget to add some for the width of the line."	extent := (points inject: points first into: [:aPoint :maxPoint | maxPoint max: aPoint])		+ (width // 2 + 0.5) rounded - origin.</body><body package="GF/ST Base">recalculateBoundingBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self quietlyRecalculateBoundingBox.	"I have changed myself so I need to trigger the #damaged event"	self triggerEvent: #damaged with: self.</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>queries</category><body package="GF/ST Base">checkClosed"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - this has the side effect of setting the closed instVar"	^closed := points first = points last</body><body package="GF/ST Base">isClosedGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether the receiver is a closed path or not"	^closed</body><body package="GF/ST Base">lineHitBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the line segement hit by aPoint"	| beginP |	beginP := points first copy.	2 to: points size do: [:i |		(((beginP rectangleWith: (points at: i) copy)			expandedByScalar: width * 2) containsPoint: aPoint)			ifTrue: [^true].		beginP := (points at: i) copy.	].	^false</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>menus</category><body package="GF/ST Base">appendPolyLineItemsTo: aMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Append the poly line specific items to aMenu"    ^aMenu        addItemLabel: 'Fill Color...' value: (MessageSend receiver: self selector: #chooseFillColor);        addItemLabel: 'Transparent' value: (MessageSend receiver: self selector: #transparent);        addItemGroupLabels: #( 'Make Closed') values: (Array with: (MessageSend receiver: self selector: #makeClosed));        addItemLabel: 'Make Open' value: (MessageSend receiver: self selector: #makeOpen);        yourself</body><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    | menu |    menu := super standardMenu.    self appendPolyLineItemsTo: menu.    ^menu</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>copying</category><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Perform any additional action after copy."	super postCopy.	points := points deepCopy.	origin := origin copy.	extent := extent copy.</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>mementos</category><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the position information of the receiver"	^(super positionInformation)		add: (self class gfMessageClass receiver: nil selector: #resetPoints: arguments: (Array with: (self storagePoints)));		yourself</body><body package="GF/ST Base">storagePoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the points relevant to position information"	| pts |	pts := points deepCopy.	self isClosedGO ifTrue: [ pts at: 1 put: ( pts last) ].	^pts</body></methods><methods><class-id>Polymorphic.GFPolylineGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"	| hndls lim |	lim := points last == points first			ifTrue: [ 1] ifFalse: [ 0].	hndls := Array new: points size - lim.	1 to: hndls size do: [:i |		hndls			at: i			put: ((GFParameterizedTrackHandle						on: self						at: #point:						with: i						change: #movePoint:by:						with: i) mementoType: #positionMemento)	].	^hndls</body></methods><methods><class-id>Polymorphic.GFPolylineGO class</class-id> <category>accessing</category><body package="GF/ST Base">arrowCreationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver"	^(GFCreationTool		icon: (GFTool stockIconFor: 'Polyline')		cursor: self gfCursorClass crossHair		class: self		name: 'Polyline Arrow') setCreationSelector: #createArrowNotifying: ; yourself</body><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver"	^GFCreationTool		icon: (GFTool stockIconFor: 'Polyline')		cursor: self gfCursorClass crossHair		class: self		name: 'Polyline'</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the events triggered"	eventsTriggered isNil ifTrue: [		(eventsTriggered := Set new)			addAll: self superclass eventsTriggered;			add: #rotate.	].	^eventsTriggered</body></methods><methods><class-id>Polymorphic.GFPolylineGO class</class-id> <category>instance creation</category><body package="GF/ST Base">createArrowNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| points aPen lastPoint curPoint color go |	lastPoint := curPoint := anInterface cursorPoint.	points := OrderedCollection new.	(aPen := anInterface pen)		setForeColorTo: (color := self defaultLineColor);		displayLineFrom: lastPoint to: curPoint.	points add: curPoint.	anInterface		trackMouseUntilLBDoubleClick: [:newPoint |			anInterface drawing damageRegion:				((lastPoint rectangleWith: curPoint)					expandedByPoint: 2 @ 2).			anInterface repairDamage.			aPen setForeColorTo: color.			points size &gt; 1 ifTrue: [ aPen displayPolyline: points ].		aPen displayLineFrom: lastPoint to: (curPoint := newPoint).		]		uponRelease: [			lastPoint == curPoint ifFalse: [ points add: curPoint copy ].			lastPoint := curPoint.		].	go := self withPoints: points.	go stopPlug: go endArrowPlug.	^go</body><body package="GF/ST Base">createNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| points aPen lastPoint curPoint color |	lastPoint := curPoint := anInterface cursorPoint.	points := OrderedCollection new.	(aPen := anInterface pen)		setForeColorTo: (color := self defaultLineColor);		displayLineFrom: lastPoint to: curPoint.	points add: curPoint.	anInterface		trackMouseUntilLBDoubleClick: [:newPoint |			anInterface drawing damageRegion:				((lastPoint rectangleWith: curPoint)					expandedByPoint: 2 @ 2).			anInterface repairDamage.			aPen setForeColorTo: color.			points size &gt; 1 ifTrue: [ aPen displayPolyline: points ].		aPen displayLineFrom: lastPoint to: (curPoint := newPoint).		]		uponRelease: [			lastPoint == curPoint 				ifFalse: [points add: curPoint copy].			lastPoint := curPoint.		].	^self withPoints: points</body><body package="GF/ST Base">withPoints: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a new instance of the receiver"	^self new initialize		points: aCollection</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>accessing</category><body package="GF/ST Base">controlPoint: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the control point at anInteger"	^controlPoints at: anInteger</body><body package="GF/ST Base">controlPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the list of points that the spline is required to pass through"	^controlPoints</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the points the receiver should snap to the grid used by	 the receiver.	 Subclasses should override this to implement their own behavior	 towards the grid	"	^controlPoints asArray</body><body package="GF/ST Base">lineStart	^points first</body><body package="GF/ST Base">lineStop	^points last</body><body package="GF/ST Base">setControlPoints: listOfPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Set the control points of the receiver"	controlPoints := listOfPoints.	self recalculatePoints</body><body package="GF/ST Base">startPoint	^controlPoints first</body><body package="GF/ST Base">stopPoint	^controlPoints last</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>private</category><body package="GF/ST Base">computeBounds"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the bounding rectangle for the receiver."	^self class boundingRectangleForPoints: points</body><body package="GF/ST Base">computeCurve"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Compute an array for the derivatives at each knot."	| size extras values cPoints |	size := controlPoints size.	cPoints := self controlPointsForComputation.	self isCyclic		ifTrue:    "for cyclic curves"			[extras := 2.        "add 2 extra points to each end."			values := Array new: 2*extras + size.			1 to: extras do:				[:i |				values at: i put: (cPoints at: size-extras + i - 1).				values at: size+extras+i put: (cPoints at: i + 1)].			values replaceFrom: extras+1 to: extras+size with: cPoints]		ifFalse: [extras := 0.				values := cPoints].	derivatives := Array new: 3.	1 to: 3 do: [:i | derivatives at: i put: (Array new: values size)].	self derivs: values		first: (derivatives at: 1)		second: (derivatives at: 2)		third: (derivatives at: 3).	extras &gt; 0 ifTrue:        "remove extra points"		[1 to: 3 do:			[:i | derivatives at: i put: ((derivatives at: i) copyFrom: extras+1 to: extras+size)]]</body><body package="GF/ST Base">computePoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Method for computing a polyline that approximates the GFSplineGO"	| steps a b c d t endX endY pointsStream cPoints|	pointsStream := WriteStream on: (Array new: 40).	cPoints := self controlPointsForComputation.	pointsStream nextPut: cPoints first copy.	1 to: cPoints size - 1 do: [:k | "for each knot"		"taylor series coefficients"		d := cPoints at: k.		c := (derivatives at: 1) at: k.		b := ((derivatives at: 2) at: k) / 2.0.		a := ((derivatives at: 3) at: k) / 6.0.			"guess stepping parameter"		steps := ((derivatives at: 2) at: k) abs + ((derivatives at: 2) at: k+1) abs.		steps := 1 max: (steps x + steps y) // Flatness.		1 to: steps do: [:j |			t := j asFloat / steps " asFloat".			endX := a x * t + b x * t + c x * t + d x.			endY := a y * t + b y * t + c y * t + d y.			pointsStream nextPut: (endX @ endY) rounded		].		pointsStream nextPut: (cPoints at: k+1) rounded.	].	points := pointsStream contents.	"1 to: (points := pointsStream contents) size do: [:i |		points at: i put: (points at: i) rounded	]."	self recalculateBoundingBox.	^points</body><body package="GF/ST Base">controlPointsForComputation	| cPoints |	cPoints := controlPoints.	startPlug == nil		ifFalse: [ 			cPoints := controlPoints copy.			cPoints at: 1 put: (controlPoints at: 1) + self startPlugOffset ].	stopPlug == nil		ifFalse:[			cPoints == controlPoints ifTrue: [ cPoints := controlPoints copy ].			cPoints at: cPoints size put: cPoints last + self stopPlugOffset ].		^cPoints</body><body package="GF/ST Base">derivs: values first: first second: second third: third"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Compute the first, second and third derivatives at each point in the array values."	| size v b |	size := values size.	size &gt; 2 ifTrue:		[v := Array new: size.		v at: 1 put: 4.0.		b := Array new: size.		b at: 1 put: (values first-((values at: 2)*2.0)+(values at: 3)) * 6.0.		2 to: size - 2 do:			[:i |			v at: i put: 4.0-(1.0/(v at: i - 1)).			b at: i put: ((values at: i)-((values at: i+1)*2.0)				+(values at: i+2)) * 6.0 - ((b at: i - 1)/(v at: i - 1))].		second at: size - 1 put: (b at: size - 2)/(v at: size - 2).		size - 2 to: 2 by: -1 do:			[:i |			second at: i put: (b at: i - 1)-(second at: i+1)/(v at: i - 1)]].	second at: 1 put: (0.0 @ 0.0).	second at: size put: (0.0 @ 0.0).	1 to: size - 1 do:		[:i |		first at: i put: (values at: i+1)-(values at: i)-((second at: i)*2.0			+(second at: i+1)/6.0).		third at: i put: (second at: i+1)-(second at: i)].</body><body package="GF/ST Base">recalculatePoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Recalculate the points of the receiver"	self		computeCurve;		computePoints;		recalculateBoundingBox</body><body package="GF/ST Base">startPlugOffset	^startPlug == nil 		ifTrue: [ 0@0 ]		ifFalse: [ startPlug connectionOffset ]</body><body package="GF/ST Base">stopPlugOffset	^stopPlug == nil 		ifTrue: [ 0@0 ]		ifFalse: [ stopPlug connectionOffset ]</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>queries</category><body package="GF/ST Base">isCyclic"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether the receiver is cyclic, i.e., folds back on itself."	^controlPoints size &gt; 3 and: [controlPoints first = controlPoints last]</body><body package="GF/ST Base">makeClosed"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the reeiver a closed polyline"	(self checkClosed or: [ controlPoints size &lt; 3]) ifTrue: [ ^self ].	self storeMemento: (self positionMemento) for: self.	self damageDuring:			[ controlPoints addLast: controlPoints first.			self recalculatePoints.			self closed: true].	self redraw.</body><body package="GF/ST Base">outlineIntersects: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer true if the receiver intersects the supplied rectangle."	^self class vertices: points intersectsRectangle: aRectangle</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>comparing</category><body package="GF/ST Base">= anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether the receiver and the argument are equal."	^self class == anObject class and:		[controlPoints = anObject controlPoints]</body><body package="GF/ST Base">hash	^controlPoints hash</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>mementos</category><body package="GF/ST Base">resetPoints: listOfPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Reset the points of the receiver to a listOfPoints"	self damageDuring: [ closed := listOfPoints first == listOfPoints last.									   self setControlPoints: listOfPoints ]</body><body package="GF/ST Base">storagePoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the points relevant to position information"	| pts |	pts := controlPoints deepCopy asOrderedCollection.	self isClosedGO ifTrue: [ pts at: 1 put: ( pts last) ].	^pts</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>state manipulation</category><body package="GF/ST Base">makeOpen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the reeiver an open polyline"	(self checkClosed or: [ controlPoints size &gt; 2] ) ifFalse: [ ^self ].	self storeMemento: (self positionMemento) for: self.	self damageDuring:		[ controlPoints removeLast.		 self recalculatePoints.		 closed := false].	self redraw.</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"	| hndls lim |	lim := controlPoints last == controlPoints first			ifTrue: [ 1] ifFalse: [ 0].	hndls := Array new: controlPoints size - lim.	1 to: hndls size do: [:i |		hndls			at: i			put: ((GFParameterizedTrackHandle						on: self						at: #controlPoint:						with: i						change: #moveControlPoint:by:						with: i) mementoType: #positionMemento)	].	^hndls</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>translation</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Translate the receiver by aPoint"	| lim |	super basicTranslateBy: aPoint.	lim := controlPoints last == controlPoints first			ifTrue: [ 1] ifFalse: [ 0].	1 to: controlPoints size - lim do: [:i | (controlPoints at: i) translatedByPoint: aPoint].</body><body package="GF/ST Base">moveControlPoint: i by: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move control point i by a deltaPoint"	self damageDuring: [		(controlPoints at: i) translatedByPoint: deltaPoint.		self recalculatePoints	].</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>conversion</category><body package="GF/ST Base">asPolylineGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer an approximation of the curve as a PolylineGO."	^GFPolylineGO withPoints: points</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>copying</category><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Perform any additional action after copy."	super postCopy.	controlPoints := controlPoints deepCopy.	derivatives := derivatives deepCopy.</body></methods><methods><class-id>Polymorphic.GFSplineGO</class-id> <category>scaling</category><body package="GF/ST Base">scaleBy: scale"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Scale the receiver by aPoint"	self damageDuring: [		1 to: points size do: [:i |			points at: i put: (points at: i) * scale.		].		1 to: controlPoints size do: [:i |			controlPoints at: i put: (controlPoints at: i) * scale.		].		origin := origin * scale.		extent := extent * scale.	].	self triggerEvent: #resize with: self</body></methods><methods><class-id>Polymorphic.GFSplineGO class</class-id> <category>instance creation</category><body package="GF/ST Base">controlPoints: listOfPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a new instance of the receiver"	^self new setControlPoints: listOfPoints</body><body package="GF/ST Base">withPoints: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a new instance of the receiver"	^self controlPoints: aCollection</body></methods><methods><class-id>Polymorphic.GFSplineGO class</class-id> <category>initialization</category><body package="GF/ST Base">initialize"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"GFSplineGO initialize"	Flatness := 40.</body></methods><methods><class-id>Polymorphic.GFSplineGO class</class-id> <category>accessing</category><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver"	^GFCreationTool		icon: (GFTool stockIconFor: 'Spline')		cursor: self gfCursorClass crossHair		class: self		name: 'Spline'</body></methods><methods><class-id>Polymorphic.GFMemento</class-id> <category>GF/ST</category><body package="GF/ST Base">accessKey: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The accessKey can only be set before the originator of a memento    is set.  The accessKey is used, if one is provided, in the method    #allowAccessFor:"    originator == nil ifTrue: [ accessKey := aSymbol ]</body><body package="GF/ST Base">addAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add an action to the state of the memento"    state add: anAction.</body><body package="GF/ST Base">addActionReceiver: receiver selector: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create and add an action to the state of the memento"	^self addAction: (self class gfMessageClass receiver: receiver selector: aSymbol arguments: #()).</body><body package="GF/ST Base">addActionReceiver: receiver selector: aSymbol arguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create and add an action to the state of the memento"    ^self addAction: (self class gfMessageClass receiver: receiver selector: aSymbol arguments: anArray).</body><body package="GF/ST Base">addActionReceiver: receiver selector: aSymbol with: anArgument"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create and add an action to the state of the memento"    ^self addActionReceiver: receiver selector: aSymbol arguments: (Array with: anArgument)</body><body package="GF/ST Base">addActionReceiver: receiver selector: aSymbol with: arg1 with: arg2"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create and add an action to the state of the memento"    ^self addActionReceiver: receiver selector: aSymbol arguments: (Array with: arg1 with: arg2)</body><body package="GF/ST Base">addActionSelector: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create and add an action to the state of the memento.  The receiver is	not specified which means that when this action is replayed, the object	that is restoring from the memento will be used as the receiver."	^self addActionSelector: aSymbol arguments: #()</body><body package="GF/ST Base">addActionSelector: aSymbol arguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create and add an action to the state of the memento.  The receiver is    no specified which means that when this action is replayed, the object    that is restoring from the memento will be used as the receiver."    ^self addAction: (self class gfMessageClass selector: aSymbol arguments: anArray).</body><body package="GF/ST Base">addActionSelector: aSymbol with: anArgument"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create and add an action to the state of the memento.  The receiver is    no specified which means that when this action is replayed, the object    that is restoring from the memento will be used as the receiver."    ^self addActionSelector: aSymbol arguments: (Array with: anArgument)</body><body package="GF/ST Base">addActionSelector: aSymbol with: arg1 with: arg2"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create and add an action to the state of the memento.  The receiver is    no specified which means that when this action is replayed, the object    that is restoring from the memento will be used as the receiver."    ^self addActionSelector: aSymbol arguments: (Array with: arg1 with: arg2)</body><body package="GF/ST Base">addAllActions: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add a collection of actions to the state"    state addAll: aCollection.</body><body package="GF/ST Base">allowAccessFor: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This method checks to see if anObject should be allowed to see the    internals of the memento.    If the accessKey is nil, anObject must be == to the originator.  If the    accessKey is not nil, then it is assumed that the originator will respond    to the key, and if anObject repsonds to the key and the objects they return    are = then access is allowed.   A good example of this is if the accessKey    is the symbol #class, then any object of the same class can access the    memento. "    accessKey isNil ifTrue: [^anObject == originator].    (anObject respondsTo: accessKey) ifFalse: [^false].    ^(anObject perform: accessKey) = (originator perform: accessKey)</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    state := OrderedCollection new.</body><body package="GF/ST Base">originator: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Originator can only be set ONCE, when the memento is created"    originator == nil        ifTrue: [ originator := anObject ]        ifFalse: [ self error: 'GFMemento already has an originator' ]</body><body package="GF/ST Base">restore "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This restoration method will dig its own originator out and restore it    from the memento."    type notNil ifTrue: [^originator perform: type with: state ].    state do: [ :each | each evaluateIfNoTarget: originator]</body><body package="GF/ST Base">restore: anObject "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Restore anObject according to the state information held within the    state collection."    (self allowAccessFor: anObject) ifFalse: [ ^nil ].    type notNil ifTrue: [^anObject perform: type with: state ].    state do: [ :each | each evaluateIfNoTarget: anObject]</body><body package="GF/ST Base">state: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This is where the state information for the memento is stored.  The    implementation here is that the state information will be a collection    of actions to be performed on whatever object wants to use the    memento to restore itself to some state.  See the comments in #type    for alternate ways to store state information."    state := aCollection.</body><body package="GF/ST Base">stateFor: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "If access is allowed, return the state information."    (self allowAccessFor: anObject)        ifTrue: [ ^state ]        ifFalse: [ ^nil ].</body><body package="GF/ST Base">type: aType"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Type should only be specified if some alternate restoration    procedure is going to be used.    aType should be a selector that restoring object will understand.    If a type is specified, it is used as a selector sent to the restoring    object with state as the parameter.  An example of this would be if    state was a point, the restoring object was a rectangle and aType    was #extent:.  Given this setup, when the memento is restored,    the restoring object (aRectangle) is told to perform #extent: with    a point as the argument.  "    type := aType</body></methods><methods><class-id>Polymorphic.GFMemento class</class-id> <category>GF/ST</category><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new initialize</body><body package="GF/ST Base">originator: o"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new originator: o</body><body package="GF/ST Base">originator: o accessKey: key"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(self new) accessKey: key; originator: o</body><body package="GF/ST Base">originator: o state: s"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self originator: o state: s type: nil</body><body package="GF/ST Base">originator: o state: s type: t"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new state: s; type: t; originator: o</body><body package="GF/ST Base">originator: o state: s type: t accessKey: key"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new accessKey: key; type: t; originator: o; state: s</body></methods><methods><class-id>Polymorphic.GFGOActionTool</class-id> <category>GF/ST</category><body package="GF/ST Base">button1DownGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Evaluate my actionBlock with aGO as the argument 	to the block. Also need my interface so that the block can make 	the changes known to the interface."    ^actionBlock value: aGO value: interface</body><body package="GF/ST Base">setActionBlock: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Set my actionBlock to aBlock"    actionBlock := aBlock</body></methods><methods><class-id>Polymorphic.GFGOActionTool class</class-id> <category>GF/ST</category><body package="GF/ST Base">bringToFront"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGAT |    aGAT := self icon: (GFTool stockIconFor: 'BringToFront') cursor: self gfCursorClass normal name: 'Bring to front'.    ^aGAT setActionBlock: [:aGO :aView | aView bringToFront: aGO].</body><body package="GF/ST Base">sendToBack"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGAT |    aGAT := self icon: (GFTool stockIconFor: 'SendToBack') cursor: self gfCursorClass normal name: 'Send to back'.    ^aGAT setActionBlock: [:aGO :aView | aView sendToBack: aGO].</body></methods><methods><class-id>Polymorphic.GFScalingImage</class-id> <category>accessing</category><body package="GF/ST Base">asRetainedMedium"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self scaling		ifTrue: [ scaledImage asRetainedMedium ]		ifFalse: [ src asRetainedMedium ]</body><body package="GF/ST Base">extent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self scaling		ifTrue: [ scaledImage extent ]		ifFalse: [ src extent ]</body><body package="GF/ST Base">isOpen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^true</body><body package="GF/ST Base">paintBasis"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self scaling 		ifTrue: [ scaledImage paintBasis ]		ifFalse: [ src paintBasis ]</body><body package="GF/ST Base">scale: value"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	scale = value ifTrue: [^self ].	scale := value asPoint.	src isNil ifFalse: [ self scaleImage ]</body><body package="GF/ST Base">scaledExtent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^scale 		ifTrue: [ scaledImage extent ]		ifFalse: [ self unscaledExtent ]</body><body package="GF/ST Base">source: image"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	src := image.	scale isNil ifFalse: [ self scaleImage ]</body><body package="GF/ST Base">unscaledExtent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^src extent</body></methods><methods><class-id>Polymorphic.GFScalingImage</class-id> <category>private</category><body package="GF/ST Base">scaleImage"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| tmp |	scaledImage notNil ifTrue: [ tmp := scaledImage ].	self scaling		ifTrue: [ scaledImage := src gfMagnifiedBy: scale ]		ifFalse: [ scaledImage := nil ].	tmp release.</body><body package="GF/ST Base">scaling"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(scale x = 1 and: [ scale y = 1 ]) not</body><body package="GF/ST Base">showNow"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"for debugging purposes only!!!"	| gc |	gc := ScheduledControllers activeController view graphicsContext.	self displayOn: gc.</body></methods><methods><class-id>Polymorphic.GFScalingImage</class-id> <category>copying</category><body package="GF/ST Base">clone"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self copy</body><body package="GF/ST Base">copy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self class sourceImage: src copy scale: scale copy</body></methods><methods><class-id>Polymorphic.GFScalingImage</class-id> <category>displaying</category><body package="GF/ST Base">displayAt: aPoint with: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self displayOn: aPen at: aPoint</body><body package="GF/ST Base">displayIn: aRect with: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	aPen gfExecute: [ self displayOn: aPen at: aRect origin ]		clipRect: (aRect intersect: aPen clippingBounds)</body><body package="GF/ST Base">displayOn: gc "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		self displayOn: gc at: 0@0</body><body package="GF/ST Base">displayOn: gc at: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	gc isGFScalingPen 		ifTrue: [ self scale: gc scale.				self scaling					ifTrue: [ scaledImage displayOn: gc at: (gc scalePoint: aPoint) ]					ifFalse: [ src displayOn: gc at: aPoint ]. ]		ifFalse: [  src displayOn: gc at: aPoint ].</body></methods><methods><class-id>Polymorphic.GFScalingImage class</class-id> <category>instance creation</category><body package="GF/ST Base">fromUser"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self sourceImage: Image fromUser scale: (1.0@1.0)</body><body package="GF/ST Base">sourceImage: image scale: scale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scalingImage |	scalingImage := self new.	scalingImage scale: scale.	scalingImage source: image.	^scalingImage</body></methods><methods><class-id>Polymorphic.GFTextGO</class-id> <category>GF/ST</category><body package="GF/ST Base">attributeInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the collection of attribute information"    ^(super attributeInformation)        add: (self class gfMessageClass receiver: nil selector: #setFont: arguments: (Array with: font));        add: (self class gfMessageClass receiver: nil selector: #color: arguments: (Array with: color));        add: (self class gfMessageClass receiver: nil selector: #text: arguments: (Array with: text));        yourself</body><body package="GF/ST Base">basicDisplayWith: aPen font: curFont"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"		"Private - the common display routine used both by displayWIth: 	and displayShapeWIth:"	| dBox |	dBox := self displayBox.	aPen gfExecute: [ aPen quickDisplayText: text at: (dBox topLeft leftAndDown: curFont basePoint)]			clipRect: (aPen clipRectanglesIntersect: (dBox logicalToDevice: aPen)).</body><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    box translatedByPoint: aPoint</body><body package="GF/ST Base">box"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^box</body><body package="GF/ST Base">color"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^color</body><body package="GF/ST Base">color: aColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    color := aColor</body><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the default handles of the receiver"    ^(super defaultHandles) add: (GFConnectionHandle on: self at: #center); yourself</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"	| ext |	ext := box extent.    ^box deepCopy expandedByPoint: ((0.03 * ext x) rounded max: 3)@((0.03 * ext y) rounded max: 2)</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^box extent</body><body package="GF/ST Base">font"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^font isNil ifTrue: [ self class defaultFont ] ifFalse: [ font ]</body><body package="GF/ST Base">font: newFont"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self setFont: newFont.	self damageDuring: [].</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the points the receiver should snap to the grid used by     the receiver.     Subclasses should override this to implement their own behavior     towards the grid    "    ^Array with: box leftTop</body><body package="GF/ST Base">growBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Ignore, text can't grow like this"    ^self</body><body package="GF/ST Base">guessExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the extent of the receiver to an approximated guess"	| tPen |	self font installOn: (tPen := Pixmap new pen).	box scale: tPen scale.	box extent: ((tPen font stringWidth: text ) @ tPen font height).	tPen medium release.</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	super initialize.	color := self class defaultLineColor.	box := GFRectangle origin: 0@0 extent: 1@1.</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"    ^box origin</body><body package="GF/ST Base">origin: pt"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    box origin: pt extent: box extent</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the position information of the receiver"    ^(super positionInformation)        add: (self class gfMessageClass receiver: nil selector: #setBox: arguments: (Array with: box deepCopy));        yourself</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform any additional action after copy."	super postCopy.    box := box deepCopy.</body><body package="GF/ST Base">promptForTextUsingInterface: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Prompt for the text of the receiver"    | newText hasContainer |    newText := self class gfPrompterClass prompt: 'Enter Text' default: self text.    newText isNil ifTrue: [ ^self ].    hasContainer := container notNil.    hasContainer        ifTrue: [            self storeMemento: (self attributeMemento) for: self.            self interface hideHandles.            self willDamage ].	text := newText.	self setExtentUsingInterface: anInterface.	hasContainer ifTrue: [            self redraw.            self damageDuring: [].            self interface unhideHandles].</body><body package="GF/ST Base">setBox: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - aRect should be the same kind of object that 'box' is initialized to	in #initialize  If it isn't, something is being done wrong."    box := aRect.</body><body package="GF/ST Base">setExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the extent of the receiver"	| pen displayFont |	self interface isNil ifTrue: [ ^self guessExtent ].	box scale: (pen := self interface display pen) scale.	self font isFontDescription		ifTrue: [  pen installFont: self font. 				displayFont := pen font.				^box extent: ( pen unscalePoint: ((displayFont stringWidth: text ) @ displayFont height))].	displayFont := self font.	box extent: ((displayFont stringWidth: text ) @ displayFont height)</body><body package="GF/ST Base">setExtentFrom: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the extent of the receiver"	| displayFont |	box scale: aPen scale.	displayFont := aPen font.	box extent: ( aPen unscalePoint: ((displayFont stringWidth: text ) @ displayFont height))</body><body package="GF/ST Base">setExtentUsingInterface: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the extent of the receiver"	| pen displayFont |	self font installOn: (pen := anInterface display pen). 	displayFont := pen font.	box extent: ((displayFont stringWidth: text ) @ displayFont height).</body><body package="GF/ST Base">setFont: newFont"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    font := newFont.    self setExtent.</body><body package="GF/ST Base">setText: aText"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    text := aText</body><body package="GF/ST Base">text"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^text isNil ifTrue: [ String new ] ifFalse: [ text ]</body><body package="GF/ST Base">text: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    self setText: aString.    self setExtent</body><body package="GF/ST Base">text: aString usingInterface: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    self setText: aString.    self setExtentUsingInterface: anInterface</body></methods><methods><class-id>Polymorphic.GFTextGO</class-id> <category>display</category><body package="GF/ST Base">basicDisplayWith: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		"Private - the common display routine used both by displayWIth: 	and displayShapeWIth:"	| dBox |	"Note: 'box' is supposed to be a GFRectangle which does know scale.	Also, keep in mind that scale is only used as a 'bookkeeping' measure	and does not change any other behavior of rectangle.  See class comments	for GFRectangle for more information.  This scale checking is needed 	because when it comes to text, the actual size of it is dependent upon the scale	and the scalability of the font that will be used to display it.  The actual font that is	used is a function of the textGO's font and the pen's scale."	box scale = aPen scale		ifFalse: [ self setExtentFrom: aPen ].	dBox := self displayBox.	aPen quickDisplayText: text in: dBox</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "	| oldFont |	aPen setForeColorTo: RGBColor black.	oldFont := aPen font.	aPen installFont: self font.	self basicDisplayWith: aPen.    oldFont notNil ifTrue: [ aPen font: oldFont ]</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "	aPen setBackgroundTransparent.	aPen installFont: self font.	aPen setForeColorTo: color.	self basicDisplayWith: aPen</body></methods><methods><class-id>Polymorphic.GFTextGO</class-id> <category>user interface</category><body package="GF/ST Base">choosePathColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Choose the color of the text"    | newColor |    self storeMemento: (self attributeMemento) for: self.    (newColor := Color pickAColor) == nil ifFalse: [        self damageDuring: [color := newColor]    ].</body><body package="GF/ST Base">promptForFont"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Prompt the user for the font"	"This needs to be rewritten for VW"    |  newFont hasContainer |    newFont := GFFontChooser pickAFontDefaultValue: 					(self font isFontDescription 							ifTrue: [ self font ]							ifFalse: [ self font fontDescription ]).    newFont isNil ifTrue: [ ^self ].    hasContainer := container notNil.    hasContainer ifTrue: [                self storeMemento: (self attributeMemento) for: self.                self interface hideHandles.                self willDamage ].    self setFont: newFont.    hasContainer ifTrue: [            self redraw.            self damageDuring: [].            self interface unhideHandles].</body><body package="GF/ST Base">promptForText"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Prompt for the text of the receiver"    | newText hasContainer |    newText := self class gfPrompterClass prompt: 'Enter Text' default: self text.    newText isNil ifTrue: [ ^self ].    hasContainer := container notNil.    hasContainer        ifTrue: [            self storeMemento: (self attributeMemento) for: self.            self interface hideHandles.            self willDamage ].    text := newText.    hasContainer ifTrue: [    		self setExtent.            self redraw.            self damageDuring: [].            self interface unhideHandles].</body></methods><methods><class-id>Polymorphic.GFTextGO</class-id> <category>menus</category><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    ^Menu new        addItemLabel: 'Edit Text...' value: (MessageSend receiver: self selector: #promptForText);        addItemLabel: 'Edit Font...' value: (MessageSend receiver: self selector: #promptForFont);        addItemGroupLabels: #('Line Color...') values: (Array with: (MessageSend receiver: self selector: #choosePathColor));	yourself</body></methods><methods><class-id>Polymorphic.GFTextGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">createNotifying: anInterface 	"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| pt textGO |	pt := anInterface cursorPoint.	textGO := self new initialize.	textGO box origin: pt.	anInterface protectDialogDuring: 		[textGO promptForTextUsingInterface: anInterface].	^textGO</body><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the tool designed to create the receiver"    ^GFCreationTool        icon: (GFTool stockIconFor: 'Text')        cursor: self gfCursorClass crossHair        class: self        name: 'Text'</body><body package="GF/ST Base">text: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"    ^self new text: aString</body><body package="GF/ST Base">text: aString usingInterface: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"    ^self new text: aString usingInterface: anInterface</body></methods><methods><class-id>Polymorphic.GFTextGO class</class-id> <category>defaults</category><body package="GF/ST Base">defaultFont	^Screen default defaultFontPolicy defaultFont fontDescription copy name: nil</body></methods><methods><class-id>Polymorphic.GFClosedPathGO</class-id> <category>GF/ST</category><body package="GF/ST Base">attributeInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the attribute information for the receiver"    ^(super attributeInformation)        add: (self class gfMessageClass receiver: nil selector: #fillColor: arguments: (Array with: fillColor));        yourself</body><body package="GF/ST Base">borderColor: aColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the border color of the receiver"    self damageDuring: [color := aColor]</body><body package="GF/ST Base">borderColorBy: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Change the border color of the receiver"    | index |    self damageDuring: [        index := (((anInteger abs / 5) truncated) min: ColorTable size) max: 1.        anInteger &lt; 0 ifTrue: [ index := (ColorTable size - index) max: 1 ].        color := ColorTable at: index.    ]</body><body package="GF/ST Base">borderSize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the line width of the receiver.     In Windows, only a lineStyle of 0 will be able to extend     outside of the bounds of the area that is being drawn    "	"For the ST80 version, scaling must be taken into consideration"	| factor scale |	^(scale := self scale asPoint) = (1@1)			ifTrue: [ (2 + width) bitShift: -1 ]			ifFalse: [ (factor := scale max) &gt; 1 					ifTrue: [  (factor + width) ceiling bitShift: -1 ]					ifFalse: [ ((1 + width / factor) ceiling) bitShift: -1 ]]</body><body package="GF/ST Base">borderWidth: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the border width of the receiver"    self damageDuring: [width := anInteger].</body><body package="GF/ST Base">borderWidthBy: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Change the border width of the receiver by anInteger"    self borderWidth: ((width + (anInteger // 4) min: 25) max: 1)</body><body package="GF/ST Base">chooseFillColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Choose the fill color of the receiver"    | newColor |    self storeMemento: (self attributeMemento) for: self.    (newColor := Color pickAColor) == nil ifFalse: [        fillColor := newColor.        self damaged; redraw.    ].</body><body package="GF/ST Base">colorBy: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Change the fill color of the receiver by anInteger"    | index |   self damageDuring: [        index := (((anInteger abs / 5) truncated) min: self class colorTable size) max: 1.        anInteger &lt; 0 ifTrue: [ index := (ColorTable size - index) max: 1 ].        fillColor := ColorTable at: index.    ].</body><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the default handles of the receiver"    ^(super defaultHandles)        add: ((GFSelectionTrackHandle colorOf: self) scrollFlag: false);        add: ((GFSelectionTrackHandle borderColorOf: self) scrollFlag: false);        add: ((GFSelectionTrackHandle widthOf: self) scrollFlag: false);        add: (GFConnectionHandle on: self at: #center);        yourself</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    super displayShapeWith: aPen.    aPen setBackColorTo: RGBColor black.</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    super displayWith: aPen.    aPen setFillColorTo: fillColor.</body><body package="GF/ST Base">fillColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the fill color of the receiver"    ^fillColor</body><body package="GF/ST Base">fillColor: aColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the fill color of the receiver"    fillColor := aColor</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	super initialize.	fillColor := RGBColor white.</body><body package="GF/ST Base">isClosedGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver is a closed path or not"    ^true</body><body package="GF/ST Base">transparent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Make the receiver transparent"    self storeMemento: (self attributeMemento) for: self.    self damageDuring: [fillColor := nil].</body><body package="GF/ST Base">width: w color: c fillColor: fc"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the values for the receiver"    width := w.    color := c.    fillColor := fc.</body></methods><methods><class-id>Polymorphic.GFClosedPathGO</class-id> <category>menus</category><body package="GF/ST Base">appendClosedPathItemsTo: aMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Append the closed path menu items to aMenu"    ^aMenu        addItemGroupLabels: #( 'Fill Color...') values: (Array with: (MessageSend receiver: self selector: #chooseFillColor));        addItemLabel: 'Transparent' value: (MessageSend receiver: self selector: #transparent);        yourself</body><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    | menu |    menu := super standardMenu.    self appendClosedPathItemsTo: menu.    ^menu</body></methods><methods><class-id>Polymorphic.GFEllipseGO</class-id> <category>GF/ST</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    ellipse translatedByPoint: aPoint</body><body package="GF/ST Base">center"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the center point of the receiver's display area"    ^ellipse center</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^ellipse expandByScalar: self borderSize</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    super displayShapeWith: aPen.    fillColor == nil        ifTrue: [aPen drawEllipse: ellipse]        ifFalse: [aPen ellipse: ellipse].</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    super displayWith: aPen.    fillColor == nil        ifTrue: [aPen drawEllipse: ellipse ]        ifFalse: [aPen ellipse: ellipse].</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^ellipse extent rounded</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the points that should be snapped to the grid"    ^Array        with: ellipse topLeft        with: ellipse bottomRight</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Grow the receiver, based on aRectangle"    self damageDuring: [ellipse expandByRectangle: aRectangle].    self triggerEvent: #resize with: self.</body><body package="GF/ST Base">growNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Used in the creation of the receiver"	| aHandle |	aHandle := GFTrackHandle bottomRightOf: self.	aHandle mementoType: nil.	anInterface addGO: self.	anInterface addHandle: aHandle.	aHandle invoke: anInterface.    "Remove GO because it is going to be added later."    anInterface drawing remove: self.    anInterface removeHandle: aHandle</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"    ^ellipse origin copy</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the position information of the receiver"    ^(super positionInformation)        add: (self class gfMessageClass receiver: nil selector: #setEllipse: arguments: (Array with: ellipse deepCopy));        yourself</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform any additional action after copy."    super postCopy.    ellipse := ellipse deepCopy</body><body package="GF/ST Base">scaleBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Scale the receiver by aPoint"	self damageDuring: [ellipse := (ellipse scaleBy: aPoint) rounded].	self triggerEvent: #resize with: self</body><body package="GF/ST Base">senseBottomLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftBottomGrowUnit.    (ellipse extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((ellipse bottom down: (y := growPoint y)) isAboveEqual: ellipse top) ifTrue: [ y := 0 ].    ^x @ 0 rightBottom: 0 @ y</body><body package="GF/ST Base">senseBottomRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightBottomGrowUnit.    (ellipse extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((ellipse bottom down: (y := growPoint y)) isAboveEqual: ellipse top) ifTrue: [ y := 0 ].    ^0 @ 0 rightBottom: (x @ y)</body><body package="GF/ST Base">senseTopLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftTopGrowUnit.    (ellipse extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((ellipse top up: (y := growPoint y)) isBelowEqual: ellipse bottom) ifTrue: [ y := 0 ].    ^x @ y rightBottom: 0 @ 0</body><body package="GF/ST Base">senseTopRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightTopGrowUnit.    (ellipse extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((ellipse top up: (y := growPoint y)) isBelowEqual: ellipse bottom) ifTrue: [ y := 0 ].    ^0 @ y rightBottom: x @ 0</body><body package="GF/ST Base">setEllipse: anEllipse"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the ellipse of the receiver"    ellipse := anEllipse</body></methods><methods><class-id>Polymorphic.GFEllipseGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">createNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create a new instance, notifying anInterface of the action"    | aGO origin corner |    origin := anInterface cursorPoint.    anInterface usesGrid                        ifTrue: [ corner := origin rightAndDown: anInterface grid. ]                        ifFalse: [ corner := origin rightAndDown: (1@1) ].    aGO := self ellipse: (Rectangle leftTop: origin rightBottom: corner).    aGO growNotifying: anInterface.    ^aGO</body><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the tool designed to create the receiver"    ^GFCreationTool        icon: (GFTool stockIconFor: 'Ellipse')        cursor: self gfCursorClass crossHair        class: self        name: 'Ellipse'</body><body package="GF/ST Base">ellipse: anEllipse"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create a new instance of the receiver"    ^(self new initialize)        setEllipse: anEllipse</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the events triggered"    eventsTriggered isNil ifTrue: [        (eventsTriggered := Set new)            addAll: self superclass eventsTriggered;            add: #resize.    ].    ^eventsTriggered</body></methods><methods><class-id>Polymorphic.GFDamagedRegion</class-id> <category>GF/ST</category><body package="GF/ST Base">initializeFrom: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    self makeValid.    ^super initializeFrom: aRectangle</body><body package="GF/ST Base">invalidate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    valid := false.</body><body package="GF/ST Base">makeValid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    valid := true.</body><body package="GF/ST Base">valid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^valid</body></methods><methods><class-id>Polymorphic.GFDamagedRegion class</class-id> <category>GF/ST</category><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new invalidate</body></methods><methods><class-id>Polymorphic.GFAbstractEndPlug</class-id> <category>displaying</category><body package="GF/ST Base">displayBox"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^((self displayPoint + self displayOffset) extendedByScalar: -1) extent: (self extent + (1@1))</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Display a mask for the receiver.  The mask is black and white, where	 black represents the opaque area, and white represents the transparent	 area	"	^self subclassResponsibility</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self subclassResponsibility</body></methods><methods><class-id>Polymorphic.GFAbstractEndPlug</class-id> <category>accessing</category><body package="GF/ST Base">connectionOffset"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^connectionOffset == nil 		ifTrue: [ Point zero ]		ifFalse: [ connectionOffset ]</body><body package="GF/ST Base">connectionOffset: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	connectionOffset := aPoint</body><body package="GF/ST Base">containsPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self displayBox containsPoint: pt</body><body package="GF/ST Base">displayOffset"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayOffset == nil 		ifTrue: [ Point zero ]		ifFalse: [ displayOffset ]</body><body package="GF/ST Base">displayOffset: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	displayOffset := aPoint</body><body package="GF/ST Base">displayPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayPoint == nil 		ifTrue: [ Point zero ]		ifFalse: [ displayPoint ]</body><body package="GF/ST Base">displayPoint: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	displayPoint := aPoint</body><body package="GF/ST Base">extent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self subclassResponsibility</body></methods><methods><class-id>Polymorphic.GFAbstractEndPlug</class-id> <category>copying</category><body package="GF/ST Base">copyUsing: replacementDictionary"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This method is to provide the mapping of 	the old endPlug to the new endPlug.  This 	is needed if the new endPlug needs to go	through and substitute itself anywhere that 	the old endPlug is at in the network of objects.	The default is to do nothing."</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	connectionOffset := connectionOffset copy.	displayOffset := displayOffset copy.	displayPoint := displayPoint copy.</body></methods><methods><class-id>Polymorphic.GFEvaluableActionEndPlug</class-id> <category>accessing</category><body package="GF/ST Base">extent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	extent == nil ifTrue: [^Point zero].	^extent</body><body package="GF/ST Base">extent: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	extent := aPoint</body><body package="GF/ST Base">setAction: anEvaluableAction"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	action := anEvaluableAction</body><body package="GF/ST Base">setAction: displayAction shapeAction: theShapeAction"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self 		setAction: displayAction;		shapeAction: theShapeAction</body><body package="GF/ST Base">shapeAction: anEvaluableAction"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	shapeAction := anEvaluableAction</body></methods><methods><class-id>Polymorphic.GFEvaluableActionEndPlug</class-id> <category>copying</category><body package="GF/ST Base">copyUsing: rDict"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	action == nil ifFalse: [ action := action copyUsing: rDict ].	shapeAction == nil ifFalse: [ shapeAction := shapeAction copyUsing: rDict ].</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	super postCopy.	extent := extent copy.</body></methods><methods><class-id>Polymorphic.GFEvaluableActionEndPlug</class-id> <category>displaying</category><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	shapeAction evaluateWith: aPen with: self</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	action evaluateWith: aPen with: self</body></methods><methods><class-id>Polymorphic.GFEvaluableActionEndPlug class</class-id> <category>instance creation</category><body package="GF/ST Base">fromAction: anEvaluableAction"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self fromAction: anEvaluableAction shapeAction: anEvaluableAction</body><body package="GF/ST Base">fromAction: theDisplayAction shapeAction: theShapeAction"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self new setAction: theDisplayAction shapeAction: theShapeAction</body></methods><methods><class-id>Polymorphic.GFCachedGO</class-id> <category>GF/ST</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    origin translatedByPoint: aPoint.</body><body package="GF/ST Base">damageCache"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Mark my cache as damaged."    cache release.    cache := nil</body><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the default handles of the receiver"    ^(super defaultHandles)        add: (GFConnectionHandle on: self at: #center);        yourself</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    "Fill my cache if it was empty or damaged. Then copy my cache directly to aGC."    cache == nil ifTrue: [self fillCache].    cache displayAt: self origin with: aPen.</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    cache isNil ifTrue: [self fillCache].    ^cache extent</body><body package="GF/ST Base">fillCache"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Draw each of my component Figures onto my cache."    ^self subclassResponsibility</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the points the receiver should snap to the grid used by     the receiver.     Subclasses should override this to implement their own behavior     towards the grid    "    ^Array with: origin</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Grow the receiver based on aRectangle"    | displayBox |    self damageDuring: [        origin := (self displayBox expandByRectangle: aRectangle) leftTop.    ].    self triggerEvent: #resize with: self.</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"    ^origin</body><body package="GF/ST Base">origin: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    origin := aPoint</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform any additional action after copy."    super postCopy.    cache release.    cache := nil.    origin := origin copy.</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Release the receiver"    super release.    cache release.</body></methods><methods><class-id>Polymorphic.GFCoordinateControl</class-id> <category>initialize-release</category><body package="GF/ST Base">initializePen: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Initialize aPen's coordinate system to the receiver's coordinate system"    "aPen setAnisotropicMapMode."    logicalUnit initializePen: aPen scale: scale.</body></methods><methods><class-id>Polymorphic.GFCoordinateControl</class-id> <category>GF/ST</category><body package="GF/ST Base">alignToGrid: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap aPoint to the grid of the drawing in which the receiver is     contained.  This is a destructive operation.  IE, the point is modified     to be constrained to the grid.    "    ^((aPoint alignToGrid: grid) max: 0@0) min: extent</body><body package="GF/ST Base">coordinateToNative: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Convert a point in the receiver's coordinate system to a point     in the 'native' coordinate system of the receiver.  Answer the converted     point    "    ^aPoint + origin * axisDirection negated</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the receiver"    ^extent</body><body package="GF/ST Base">extent: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    extent := aPoint</body><body package="GF/ST Base">grid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^grid</body><body package="GF/ST Base">grid: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    grid := aPoint</body><body package="GF/ST Base">initHighEnglish"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    logicalUnit := GFThousandthInch highResolution</body><body package="GF/ST Base">initHighMetric"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    logicalUnit := GFHundredthMillimeter highResolution</body><body package="GF/ST Base">initLowEnglish"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    logicalUnit := GFThousandthInch lowResolution</body><body package="GF/ST Base">initLowMetric"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    logicalUnit := GFHundredthMillimeter lowResolution</body><body package="GF/ST Base">initTwips"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    logicalUnit := GFTwip new</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    origin := 0@0.    axisDirection := 1@1.    scale := 1.    logicalUnit := GFThousandthInch defaultResolution.    extent := logicalUnit screenExtent.    grid := 10@10.    useGrid := false.</body><body package="GF/ST Base">nativeToCoordinate: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Convert a point in the 'native' coordinate system to a point     in the coordinate system of the receiver.  Answer the converted     point    "    ^aPoint - origin * axisDirection</body><body package="GF/ST Base">scale"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the scaling factor for the receiver. The scaling factor is a point,     and can be different for the X and Y coordinates    "    ^scale</body><body package="GF/ST Base">scale: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the scaling factor of the receiver.  The scaling factor is a point,     and can be different for the X and Y coordinates    "    scale := aPoint</body><body package="GF/ST Base">setOrigin: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the reciever's origin.  The origin is in the native format of the coordinate     system.  Under windows this is 0,0 in the upper left, with x increasing     to the right, and y increasing downward.    "    origin := aPoint.</body><body package="GF/ST Base">setXIncreasingLeft"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the X access increasing from right to left"    axisDirection x: -1</body><body package="GF/ST Base">setXIncreasingRight"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the X access increasing from left to right"    axisDirection x: 1</body><body package="GF/ST Base">setYIncreasingDown"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the Y access increasing from top to bottom"    axisDirection y: 1</body><body package="GF/ST Base">setYIncreasingUp"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the Y access increasing from bottom to top"    axisDirection y: -1</body><body package="GF/ST Base">snapToGrid: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the grid point nearest to the grid of the receiver"    ^((aPoint snapToGrid: grid)max: 0@0) min: extent</body><body package="GF/ST Base">snapToGrid: aPoint if: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the grid point nearest to the grid of the receiver if snap is true,     and limit it to the extent of the receiver if limit is true"    | p |    p := aPoint.    useGrid &amp; snap ifTrue: [p := aPoint snapToGrid: grid].    limit ifTrue: [^(p max: 0@0) min: extent].    ^p</body><body package="GF/ST Base">toggleUseGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    useGrid := useGrid not.</body><body package="GF/ST Base">useGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^useGrid</body><body package="GF/ST Base">useGrid: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    useGrid := aBoolean</body></methods><methods><class-id>Polymorphic.GFCoordinateControl</class-id> <category>scaling</category><body package="GF/ST Base">scaledPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| tScale |	tScale := scale asPoint.	^(tScale x * (pt x)) rounded @ ((tScale y * (pt y)) rounded)</body><body package="GF/ST Base">scaledRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Rectangle origin: (self scaledPoint: rect origin) corner: (self scaledPoint: rect corner)</body><body package="GF/ST Base">unscaledPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| tScale |	tScale := scale asPoint.	^( pt x / (tScale x)) rounded @ (( pt y / (tScale y)) rounded)</body><body package="GF/ST Base">unscaledRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Rectangle origin: (self unscaledPoint: rect origin) corner: (self unscaledPoint: rect corner)</body></methods><methods><class-id>Polymorphic.GFCoordinateControl class</class-id> <category>GF/ST</category><body package="GF/ST Base">highEnglish"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new initHighEnglish</body><body package="GF/ST Base">highMetric"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new initHighMetric</body><body package="GF/ST Base">lowEnglish"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new initLowEnglish</body><body package="GF/ST Base">lowMetric"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new initLowMetric</body><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new initialize</body><body package="GF/ST Base">twips"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new initTwips</body></methods><methods><class-id>Polymorphic.GFImageGO</class-id> <category>GF/ST</category><body package="GF/ST Base">copy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self class origin: self origin copy image: cache clone.</body><body package="GF/ST Base">damageCache"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Don't damage my cache because I can't get it back"</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    "Because I am a rectilinear figure, just color the area        that is my bounding Rectangle."    aPen        black;        blackFill;        rectangleFilled: self displayBox</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    "Fill my cache if it was empty or damaged. Then copy my cache directly to aGC."    cache == nil ifTrue: [self fillCache].    cache displayIn: self displayBox with: aPen</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^extent</body><body package="GF/ST Base">fillCache"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This method should not be called as GFImageGOs are created as Image fromUser."</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the points the receiver should snap to the grid used by     the receiver.     Subclasses should override this to implement their own behavior     towards the grid    "    ^Array        with: origin        with: extent</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Grow the receiver based on aRectangle"    | displayBox |    self damageDuring: [        displayBox := self displayBox expandByRectangle: aRectangle.        origin := displayBox leftTop.        extent := displayBox extent.    ].    self triggerEvent: #resize with: self.</body><body package="GF/ST Base">origin: aPoint image: anImage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    origin := aPoint.    cache := anImage.    extent := anImage extent + (1@1).</body><body package="GF/ST Base">origin: originPoint imageToScale: anImage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"   ^self origin: originPoint image: (GFScalingImage sourceImage: anImage scale: 1)</body><body package="GF/ST Base">senseBottomLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftBottomGrowUnit.    (extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    (extent y down: (y := growPoint y)) &lt;= 1 ifTrue: [ y := 0 ].    ^x @ 0 rightBottom: 0 @ y</body><body package="GF/ST Base">senseBottomRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightBottomGrowUnit.    (extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    (extent y down: (y := growPoint y)) &lt;= 1 ifTrue: [ y := 0 ].    ^0 @ 0 rightBottom: (x @ y)</body><body package="GF/ST Base">senseTopLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftTopGrowUnit.    (extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    (extent y down: (y := growPoint y)) &lt;= 1 ifTrue: [ y := 0 ].    ^x @ y rightBottom: 0 @ 0</body><body package="GF/ST Base">senseTopRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightTopGrowUnit.    (extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    (extent y down: (y := growPoint y)) &lt;= 1 ifTrue: [ y := 0 ].    ^0 @ y rightBottom: x @ 0</body></methods><methods><class-id>Polymorphic.GFImageGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the tool designed to create the receiver"    ^GFCreationTool        icon: (GFTool stockIconFor: 'Image')        cursor: self gfCursorClass crossHair        class: self        name: 'Image'</body><body package="GF/ST Base">origin: origin image: aBitmap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"   ^self new origin: origin image: aBitmap</body><body package="GF/ST Base">origin: origin imageToScale: anImage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"   ^self new origin: origin image: (GFScalingImage sourceImage: anImage scale: 1)</body></methods><methods><class-id>Polymorphic.GFImageGO class</class-id> <category>instance creation</category><body package="GF/ST Base">createNotifying: anInterface 	"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| aGO origin |	origin := anInterface cursorPoint.	aGO := self new origin: origin				image: (Image 						extent: 0 @ 0						depth: 1						palette: MappedPalette whiteBlack).	anInterface protectDialogDuring: 		[Dialog warn: 'Please select a Bitmap from the screen'.		aGO origin: origin imageToScale: Image fromUser.		aGO damaged].	^aGO</body></methods><methods><class-id>Polymorphic.GFGroupGO</class-id> <category>GF/ST</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    origin translatedByPoint: aPoint.    graphicObjects do: [ :each | each basicTranslateBy: aPoint; damaged ]</body><body package="GF/ST Base">cacheFlag"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether receiver caches or not"    ^cacheFlag</body><body package="GF/ST Base">cacheFlag: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set whether the receiver caches or not"    cacheFlag := aBoolean.     self damageCache</body><body package="GF/ST Base">copy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self class graphicObjects: (graphicObjects collect: [:each | each copy])</body><body package="GF/ST Base">damage: aFigure during: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	cacheFlag 		ifTrue: [ aBlock value ]		ifFalse: [ super damageDuring: aBlock ].</body><body package="GF/ST Base">damageCache"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Mark my cache as damaged."	cache release.	cache := nil</body><body package="GF/ST Base">damageRegion: anArea"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	cacheFlag ifFalse: [self damaged: anArea]</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    "Display the shape of my image on aPen. Do this by having each of my    component graphicObjects display their shapes on aPen."    graphicObjects do: [:each | each displayShapeWith: aPen]</body><body package="GF/ST Base">do: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Traverse the list of graphic objects, including with the receiver"    aBlock value: self.    graphicObjects do: [:each | each do: aBlock]</body><body package="GF/ST Base">firstGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	graphicObjects isNil ifTrue: [^nil].	^graphicObjects isEmpty ifTrue: [nil] ifFalse: [graphicObjects first]</body><body package="GF/ST Base">firstGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    aGO == nil ifTrue: [ ^self ].    graphicObjects remove: aGO ifAbsent: [].    graphicObjects add: aGO.</body><body package="GF/ST Base">graphicObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an array of graphic objects, the receiver has"        ^graphicObjects</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Grow the receiver based on aRectangle"    | oldOrigin |    cacheFlag ifTrue: [^super growBy: aRectangle].    oldOrigin := origin.    self damageDuring: [        cache := nil.        self graphicObjects do: [ :each | each growBy: aRectangle].    ].    self triggerEvent: #resize with: self.</body><body package="GF/ST Base">hasHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer if the receiver has host widgets"    ^hostWidgets size ~~ 0</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    super initialize.    cacheFlag := true.</body><body package="GF/ST Base">isContainerGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer true since this GO can contain other GO's"    ^true</body><body package="GF/ST Base">isGroupGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver is a group GO or not"    ^true</body><body package="GF/ST Base">kindsOfGOs"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an array of classes the receiver contains"    ^self graphicObjects inject: (Set with: self class) into: [:sum :each |        sum addAll: each kindsOfGOs; yourself    ]</body><body package="GF/ST Base">lastGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	graphicObjects isNil ifTrue: [^nil].	^graphicObjects isEmpty ifTrue: [nil] ifFalse: [graphicObjects last]</body><body package="GF/ST Base">lastGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    aGO == nil ifTrue: [ ^self ].    graphicObjects remove: aGO ifAbsent: [].    graphicObjects add: aGO.</body><body package="GF/ST Base">origin: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"the origin of the GroupGO has been changed, relay this change to the 	components of the GroupGO"	| diff |	diff := aPoint - self origin.	graphicObjects do: [:each | each basicTranslateBy: diff ].	^super origin: aPoint.</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the position information of the receiver"    | pi |    pi := super positionInformation.    pi add: (self class gfMessageClass receiver: nil selector: #restoreCache).    pi add: (self class gfMessageClass receiver: nil selector: #translateTo: arguments: (Array with: self displayBox corner copy)).    pi add: (self class gfMessageClass receiver: nil selector: #damageDuring: arguments: (Array with: [])).    ^pi</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Release the receiver"    graphicObjects size &gt; 0 		ifTrue:  [			graphicObjects do: [:each |        			each removeDependent: self.    		]		].    cache == self ifTrue: [cache := nil].    super release</body><body package="GF/ST Base">removeHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove the host widget embedded in the receiver"    graphicObjects asOrderedCollection do: [:each |        each hasHostWidget ifTrue: [each removeHostWidget]    ]</body><body package="GF/ST Base">restoreCache"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Restore the cache of the receiver"    graphicObjects do: [:each |         each basicTranslateBy: self origin negated.    ].    self fillCache.    graphicObjects do: [:each |        each basicTranslateBy: self origin    ]</body><body package="GF/ST Base">restoreHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	graphicObjects do: [ :each | each hasHostWidget ifTrue: [ each restoreHostWidget ]].</body><body package="GF/ST Base">scaleBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Scale the receiver by aPoint"    "GFGroupGOs cant be scaled."</body><body package="GF/ST Base">setGraphicObjects: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Set the graphic objects of the receiver"    origin := aCollection first displayBox origin copy.    1 to: aCollection size do: [:i |        origin := origin becomeMostOriginal: (aCollection at: i) displayBox origin.        (aCollection at: i) container: self.        (aCollection at: i) prevGO: ((i &lt; aCollection size)                ifTrue: [ aCollection at: i + 1 ]                ifFalse: [ nil ]).        (aCollection at: i) nextGO: ((i &gt; 1)                ifTrue: [ aCollection at: i - 1 ]                ifFalse: [ nil ]).    ].    hostWidgets := OrderedCollection new.    graphicObjects := aCollection asSortedCollection.    graphicObjects do: [:each |        each hasHostWidget            ifTrue: [                hostWidgets add: each.            ].            each basicTranslateBy: origin negated.    ].    self fillCache.    graphicObjects do: [:each | each basicTranslateBy: origin]</body></methods><methods><class-id>Polymorphic.GFGroupGO</class-id> <category>private</category><body package="GF/ST Base">containsPoint: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"  	^(super containsPoint: aPoint) 		ifTrue: [ self hasHostWidget  					ifTrue: [ | go | go := hostWidgets detect: [ :each | (each containsPoint: aPoint)] ifNone: [nil]. 							go == nil  								ifFalse: [ go startUpHostComponent. ] 					]. 					true] 		ifFalse: [ false ]</body><body package="GF/ST Base">fillCache"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Draw each of my component Figures onto my cache. My cache is an    OpaqueFigure so collect the images and their shapes from each of    my component graphicObjects."    |  mask  box figure |    cache release.    box := graphicObjects first graphicObjects first displayBox.    extent := (graphicObjects inject: box into: [:sum :each |                            sum merge: each displayBox                        ]) extent.	extent extendedByScalar: 1.    cacheFlag        ifTrue: [            figure := Pixmap extent: extent.            mask := Mask extent: extent.            "mask pen fill: mask boundingBox color: RGBColor white."            graphicObjects do: [:each |                each isHostWidgetGO ifFalse: [                       each displayWith: figure pen                ]            ].            graphicObjects do: [:each |                each isHostWidgetGO ifFalse: [                       each displayShapeWith: mask pen                ]            ].            cache := GFOpaqueBitmap figure: (GFScalingImage sourceImage: figure asImage scale: self scale) shape: (GFScalingImage sourceImage: mask asImage scale: self scale)        ]</body></methods><methods><class-id>Polymorphic.GFGroupGO</class-id> <category>display</category><body package="GF/ST Base">displayWith: aPen "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"      "The central display routine.  Display the image of the receiver,      using aPen.  The receiver should make no assumptions regarding      the state of the pen, and is not responsible for resetting the pen      to the previous state.     "      | box  |     (cacheFlag and: [ aPen isGFScalingPen ])  		ifTrue: [			(cache == nil or: [cache isOpen not ]) ifTrue: [ self restoreCache ]. "such as when we return from a snapshot" 			super displayWith: aPen copy. 			hostWidgets do: [ :each | each displayWith: aPen]. 			^self].     cache == nil ifTrue: [         "Re-establish my extent, and cache it ;)"         box := graphicObjects first displayBox.           graphicObjects inject: box into: [:sum :each |             each displayWith: aPen.             sum mergeWith: each displayBox.         ].         origin := box origin.         extent := box extent.         ^cache := box.     ].      ^graphicObjects do: [ :each | each displayWith: aPen ].</body></methods><methods><class-id>Polymorphic.GFGroupGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">graphicObjects: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"    ^self new setGraphicObjects: aCollection</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO</class-id> <category>GF/ST</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    area translatedByPoint: aPoint.	self setHostWidgetBounds: area</body><body package="GF/ST Base">clientExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the area extent in device coordinates"    ^area extent logicalToDevice: self interface pen.</body><body package="GF/ST Base">clientOrigin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the origin of the area in device coordinates"    ^area origin logicalToDevice: self interface pen.</body><body package="GF/ST Base">clientRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the area in device coordinates"	container == nil ifTrue: [ ^area ].	^area  logicalToDevice: self interface pen.</body><body package="GF/ST Base">connectWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Connect the widget to the display pane"	self privateConnectWidget</body><body package="GF/ST Base">copy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	| newMe b |	newMe := super copy.	hostWidget spec addTo: (b := UIBuilder new) withPolicy: self class defaultLookPolicy.	b component model value: hostWidget widget model value copy.	newMe privateSetHostWidget: b wrapper.	^newMe</body><body package="GF/ST Base">deselect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Deselect the receiver.  Enable the host widget"    super deselect.    hostWidget == nil ifFalse: [hostWidget enable.							self redraw]</body><body package="GF/ST Base">dispatchesKeyboard"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self interface isNil ifTrue: [ ^false ].	^self interface display dispatchesKeyboard</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^area deepCopy</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "	aPen setBackColorTo: RGBColor black.	aPen fastRectangleFilled: area</body><body package="GF/ST Base">edgeDecorationPolicy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^LookPreferences edgeDecorationPolicy</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^area extent</body><body package="GF/ST Base">graphicsContextFor: hostComp"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| pen |	pen := self interface pen copy.	pen paintPreferences: self paintPreferences.	^pen</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the points of the receiver that should be snapped to the     grid    "    ^Array        with: area topLeft        with: area bottomRight</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Grow the receiver based on aRectangle"    self damageDuring: [		area expandByRectangle: aRectangle.		self setHostWidgetBounds: area.		hostWidget layoutComponentSubtreeIfNeeded.		hostWidget widget invalidateIntrinsicContentSize    ].</body><body package="GF/ST Base">growNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Used in the creation of the receiver"	| aHandle |	self connectWidget.	aHandle := GFTrackHandle bottomRightOf: self.	aHandle mementoType: nil.	anInterface addHandle: aHandle.	self class gfCursorClass crossHair changeFor: [aHandle invoke: anInterface].	anInterface removeHandle: aHandle.</body><body package="GF/ST Base">hasHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer if the receiver has host widgets"    ^true</body><body package="GF/ST Base">invalidateRectangle: aRectangle repairNow: aBoolean forComponent: comp"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Do nothing for now"	| pen interface |	(interface := self interface) == nil ifTrue: [ ^self ].	pen := interface pen.	pen gfExecute: [ self displayWith: pen ] clipRect: aRectangle.</body><body package="GF/ST Base">isEnabled	^hostWidget widgetState isEnabled</body><body package="GF/ST Base">isHostWidgetGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer false because this is not TRULY a host component, but one	emulated by VW and thus can and needs to be treated differently than true host	platform components such as the components available through VSE"    ^false</body><body package="GF/ST Base">isOpen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^container ~~ nil</body><body package="GF/ST Base">localPointToGlobal: point"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self interface displayPane localPointToGlobal: point</body><body package="GF/ST Base">medium	^container container displayPane</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"    ^area origin</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the position information of the receiver"	| messageClass |	messageClass := self class gfMessageClass.	^(super positionInformation)		add: (messageClass receiver: nil selector: #setArea: arguments: (Array with: area deepCopy));		add: (messageClass receiver: nil selector: #resetHostWidget);		yourself</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform any additional action after copy."    super postCopy.    area := area deepCopy</body><body package="GF/ST Base">privateConnectWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Connect the widget to the display pane"	self dispatchesKeyboard ifFalse: [ ^self ].	self interface display keyboardProcessor == nil ifTrue: [^self].	self interface display displayPane controller evenIfKeyPressed: false.	hostWidget widget controller keyboardProcessor: self interface display keyboardProcessor.	self interface display keyboardProcessor sendKeyboardTo: hostWidget widget</body><body package="GF/ST Base">privateSetHostWidget: aHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    (hostWidget := aHostWidget)         container: self.	self setHostWidgetTranslation.</body><body package="GF/ST Base">removeHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Remove the host widget from the keyboardProcessor"    self interface keyboardProcessor removeKeyboardReceiver: hostWidget widget controller</body><body package="GF/ST Base">restoreHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	self privateSetHostWidget: hostWidget.	self privateConnectWidget.</body><body package="GF/ST Base">senseBottomLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftBottomGrowUnit.    (area extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((area bottom down: (y := growPoint y)) isAboveEqual: area top) ifTrue: [ y := 0 ].    ^x @ 0 rightBottom: 0 @ y</body><body package="GF/ST Base">senseBottomRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightBottomGrowUnit.    (area extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((area bottom down: (y := growPoint y)) isAboveEqual: area top) ifTrue: [ y := 0 ].    ^0 @ 0 rightBottom: (x @ y)</body><body package="GF/ST Base">senseTopLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftTopGrowUnit.    (area extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((area top up: (y := growPoint y)) isBelowEqual: area bottom) ifTrue: [ y := 0 ].    ^x @ y rightBottom: 0 @ 0</body><body package="GF/ST Base">senseTopRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightTopGrowUnit.    (area extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((area top up: (y := growPoint y)) isBelowEqual: area bottom) ifTrue: [ y := 0 ].    ^0 @ y rightBottom: x @ 0</body><body package="GF/ST Base">setArea: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    area := aRectangle</body><body package="GF/ST Base">setButtonActionWhen: event send: selector to: receiver"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	hostWidget widget controller model:		((PluggableAdaptor on: self)			getBlock: [:m | true ]			putBlock: [ :m :v | receiver perform: selector ]			updateBlock: [:m :v :p | true]).</body><body package="GF/ST Base">setHostWidget: aHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	(hostWidget := aHostWidget)		container: self;		bounds: area.	self setHostWidgetTranslation</body><body package="GF/ST Base">setHostWidgetTranslation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	self interface isNil ifTrue: [ ^self ].</body><body package="GF/ST Base">setProperty"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	"NoOp"</body><body package="GF/ST Base">snapToGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap the receiver to the grid"    super snapToGrid.    self updateWidget.</body><body package="GF/ST Base">topComponent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self interface displayPane topComponent</body><body package="GF/ST Base">updateAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    ^self class gfMessageClass receiver: self selector: #updateWidget</body><body package="GF/ST Base">updateWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	self setHostWidgetBounds: area</body><body package="GF/ST Base">widget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^hostWidget</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO</class-id> <category>menu</category><body package="GF/ST Base">standardMenu "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	hostWidget isEnabled		ifTrue: [				self startUpHostComponent.			^#noMenu ]		ifFalse:  [ ^super standardMenu ]</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	hostWidget isEnabled 		ifTrue: [ ^self noHandles ]		ifFalse: [ ^super defaultHandles ].</body><body package="GF/ST Base">generatePositionHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Generate the position handle for the receiver.  This handle is used     by the tools to move the receiver around    "	^hostWidget isEnabled		ifTrue: [self updateWidget.				self startUpHostComponent.				nil ]		ifFalse: [ super generatePositionHandle ].</body><body package="GF/ST Base">noPositionHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self startUpHostComponent.	^nil.</body><body package="GF/ST Base">startUpHostComponent	"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		self interface dispatchesKeyboard 		ifTrue: [self interface keyboardProcessor requestActivationFor: hostWidget widget controller]</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO</class-id> <category>displaying</category><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    "If the host widget isn't valid, just display the area of the widget.     otherwise, blank out the area, and notify the display system to     update the widget after all drawing has taken place    "    (hostWidget isNil or: [hostWidget isValid not])        ifTrue: [            aPen gfFill: area color: self interface displayPane backColor.        ]        ifFalse: [| pen |		pen := aPen copy.		pen paintPreferences: hostWidget paintPreferences.		hostWidget displayOn: pen        ].</body><body package="GF/ST Base">graphicsDevice"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self interface == nil ifTrue: [ ^Screen default ].	^self interface display graphicsDevice</body><body package="GF/ST Base">paintPreferences"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self interface == nil ifTrue: [ ^Screen default defaultPaintPreferences ].	^self interface display paintPreferences copy</body><body package="GF/ST Base">setHostWidgetBounds: newArea"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	hostWidget newBounds: newArea containingBounds: self displayBox</body><body package="GF/ST Base">widgetPolicy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self interface == nil ifTrue: [ ^Screen default defaultWidgetPolicy ].	^self interface display widgetPolicy</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO</class-id> <category>updating</category><body package="GF/ST Base">resetHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self updateWidget</body><body package="GF/ST Base">subtreeNeedsLayout	container ifNotNil: #subtreeNeedsLayout</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO</class-id> <category>selection</category><body package="GF/ST Base">select"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The receiver has been selected"	    hostWidget isNil ifFalse: 		[hostWidget widget getController viewHasCursor			ifFalse: [hostWidget disable].		super select.		self updateWidget.		self interface repairDamage].</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO</class-id> <category>private</category><body package="GF/ST Base">changedPreferredGeometryForComponent: aVisualComponent</body></methods><methods><class-id>Polymorphic.GFHostWidgetGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">area: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new setArea: aRectangle</body><body package="GF/ST Base">buttonCreationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(GFCreationTool        icon: (GFTool stockIconFor: 'Button')        cursor: self gfCursorClass crossHair        class: self        name: 'Button') setCreationSelector: #createButtonNotifying: ; yourself</body><body package="GF/ST Base">createButtonNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self createNotifying: anInterface using: self defaultButtonWidget.</body><body package="GF/ST Base">createListNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self createNotifying: anInterface using: self defaultListWidget.</body><body package="GF/ST Base">createNotifying: anInterface using: aHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGO origin corner |    origin := anInterface cursorPoint.    anInterface usesGrid                        ifTrue: [ corner := origin rightAndDown: anInterface grid. ]                        ifFalse: [ corner := origin rightAndDown: (1@1) ].    aGO := self area: (Rectangle leftTop: origin rightBottom: corner).    anInterface drawing add: aGO.    aGO setHostWidget: aHostWidget.    aGO growNotifying: anInterface.    anInterface removeGO: aGO.     ^aGO</body><body package="GF/ST Base">createParagraphNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self createNotifying: anInterface using: self defaultParagraphWidget.</body><body package="GF/ST Base">createTextFieldNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self createNotifying: anInterface using: self defaultEntryFieldWidget.</body><body package="GF/ST Base">defaultButtonWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| lp builder spec |	lp := self defaultLookPolicy.	builder := UIBuilder new.	spec := ActionButtonSpec			model: nil			label: 'Label'			layout: ((0@0)				extent:					(60@30))			properties: #(#opaque #tabable).	lp actionButton: spec into: builder.	^builder wrapper</body><body package="GF/ST Base">defaultEntryFieldWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| lp builder spec |	lp := self defaultLookPolicy.	builder := UIBuilder new.	spec := InputFieldSpec			layout: ((10@10)				extent:					(60@30)).	spec isOpaque: true.	lp inputField: spec into: builder.	builder component model value: 'Text'.	^builder wrapper</body><body package="GF/ST Base">defaultListWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| lp builder spec |	lp := self defaultLookPolicy.	builder := UIBuilder new.	spec := SequenceViewSpec			layout: ((10@10)				extent:					(60@30)).	spec isOpaque: true.	lp listView: spec into: builder.	builder component model value: self sampleList.	^builder wrapper</body><body package="GF/ST Base">defaultLookPolicy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^UILookPolicy new</body><body package="GF/ST Base">defaultParagraphWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| lp builder spec |	lp := self defaultLookPolicy.	builder := UIBuilder new.	spec := TextEditorSpec			layout: ((10@10)				extent:					(60@30)).	spec isOpaque: true.	spec tabable: true.	lp textView: spec into: builder.	builder component model value: 'Paragraph'.	^builder wrapper"	| lp textField  dec wrapper widget |	lp := self defaultLookPolicy.	widget := textField := lp textViewClass new. 	textField editText: 'Paragraph'.	lp class useSystemFontsOnWidgets		ifTrue: [textField setTextStyle: lp class systemWidgetTextStyle].	textField widgetState isOpaque: true.	dec := textField inDefaultEdgeDecorator.	textField := BoundedWrapper on: dec.	dec useVerticalScrollBar;		useHorizontalScrollBar.	wrapper := SpecWrapper on: textField.	wrapper widget: widget.	^wrapper"</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the events triggered"    eventsTriggered isNil ifTrue: [        (eventsTriggered := Set new)            addAll: self superclass eventsTriggered;            add: #resize.    ].    ^eventsTriggered</body><body package="GF/ST Base">listCreationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(GFCreationTool        icon: (GFTool stockIconFor: 'List')        cursor: self gfCursorClass crossHair        class: self        name: 'List') setCreationSelector: #createListNotifying: ; yourself</body><body package="GF/ST Base">paragraphCreationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(GFCreationTool        icon: (GFTool stockIconFor: 'Paragraph')        cursor: self gfCursorClass crossHair        class: self        name: 'Paragraph') setCreationSelector: #createParagraphNotifying: ; yourself</body><body package="GF/ST Base">sampleList"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(List new)		add: 'name';		add: 'age';		add: 'phone';		add: 'address';		add: 'state';		add: 'zip';		add: 'I.Q.';		yourself</body><body package="GF/ST Base">textFieldCreationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(GFCreationTool        icon: (GFTool stockIconFor: 'TextField')        cursor: self gfCursorClass crossHair        class: self        name: 'TextField') setCreationSelector: #createTextFieldNotifying: ; yourself</body></methods><methods><class-id>Polymorphic.GFMultiheadedConstraint</class-id> <category>GF/ST</category><body package="GF/ST Base">addSource: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    sources add: aGO.    aGO        when: #damaged        evaluate: self.    self evaluate</body><body package="GF/ST Base">addSource: aGO event: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    sources add: aGO.    aGO        when: aSymbol        evaluate: self.    self evaluate</body><body package="GF/ST Base">evaluate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^sink        perform: selector        with: (action evaluateWithArguments: (Array with: sources with: sink))</body><body package="GF/ST Base">evaluateWithArguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self evaluate</body><body package="GF/ST Base">for: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    sink := aGO.    sources := OrderedCollection new.    selector := #changed:</body><body package="GF/ST Base">for: aGO action: actionBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    sink := aGO.    sources := OrderedCollection new.    action := actionBlock.    selector := #changed:</body><body package="GF/ST Base">for: aGO action: actionBlock send: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    sink := aGO.    sources := OrderedCollection new.    action := actionBlock.    selector := aSymbol</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    sources do: [:each |        each removeAction: self.    ].    sources := sink := action := selector := nil.</body></methods><methods><class-id>Polymorphic.GFMultiheadedConstraint class</class-id> <category>GF/ST</category><body package="GF/ST Base">for: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new for: aGO</body><body package="GF/ST Base">for: aGO action: actionBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new for: aGO action: actionBlock</body><body package="GF/ST Base">for: aGO action: actionBlock send: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new for: aGO action: actionBlock send: aSymbol</body></methods><methods><class-id>Polymorphic.GFDrawingPane</class-id> <category>GF/ST</category><body package="GF/ST Base">amountToPageLeft"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Answer the number of pixels for         horizontal page scrolling."    ^pagePoint x</body><body package="GF/ST Base">amountToPageUp"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Answer the number of pixels for         vertical page scrolling."    ^pagePoint y</body><body package="GF/ST Base">amountToScrollLeft"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Answer the number of pixels         for horizontal scrolling."    ^scrollPoint x</body><body package="GF/ST Base">amountToScrollUp"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Answer the number of pixels         for vertical scrolling."    ^scrollPoint y</body><body package="GF/ST Base">backColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self backgroundColor</body><body package="GF/ST Base">button1DoubleClick: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - button 1 has been double clicked."    displaySystem interface button1DoubleClick: (displaySystem transformPoint: aPoint).</body><body package="GF/ST Base">button1Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved""Private - Left button has been pressed down."	| point |	point := displaySystem transformPoint: aPoint.	displaySystem interface button1Down: point.</body><body package="GF/ST Base">button1DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved""Private - Left button and shift key are both down"	| point |	point := displaySystem transformPoint: aPoint.	self setFocus.    ( self isLocalDragSource and: [ self isDragButton: 1 ] )        ifTrue: [ self dragOnMove: true location: point ].    displaySystem interface button1DownShift: point.</body><body package="GF/ST Base">button1Move: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - The user moved the mouse to aPoint         while holding down button 1."</body><body package="GF/ST Base">button2Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved""Private - Right button has been pressed down."	| point |	point := displaySystem transformPoint: aPoint.	"self setFocus."   " ( self isLocalDragSource and: [ self isDragButton: 2 ] )        ifTrue: [ self dragOnMove: true location: point ]."    displaySystem interface button2Down: point.</body><body package="GF/ST Base">button2DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved""Private - Right button and shift key are both down"	| point |	point := displaySystem transformPoint: aPoint.	self setFocus.    ( self isLocalDragSource and: [ self isDragButton: 2 ] )        ifTrue: [ self dragOnMove: true location: point ].    displaySystem interface button2DownShift: point.</body><body package="GF/ST Base">button2Move: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - The user moved the mouse to aPoint         while holding down button 2."</body><body package="GF/ST Base">buttonDown: pt 	"Copyright (C) 1993-1996 Polymorphic Software, Inc. All Rights Reserved"	| sensor |	(sensor := controller sensor) redButtonPressed ifTrue: [sensor ctrlDown			ifTrue: [self startDragAt: pt]			ifFalse: [self button1Down: pt]]</body><body package="GF/ST Base">clearDisplaySystem"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	displaySystem := nil</body><body package="GF/ST Base">currentCursor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    displaySystem == nil ifTrue: [^super currentCursor].    ^displaySystem interface cursorAt: Cursor offset</body><body package="GF/ST Base">deactivate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - The receiver has been deactivated."</body><body package="GF/ST Base">display: invalidRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Display the receiver pane contents."	displaySystem displayViewRectangle: (self unscaleRectangle: invalidRectangle)</body><body package="GF/ST Base">displayOn: gc"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self displayOn: gc while:[self display: gc clippingBounds]</body><body package="GF/ST Base">displayOn: aGraphicsContext while: aBlock	| window |	window := self topComponent.	window ifNil: [^nil].	window damageRepairPolicy class = DoubleBufferingWindowDisplayPolicy		ifTrue: 			[| oldPanePen oldSystemPen |			oldPanePen := pen.			oldSystemPen := displaySystem pen.			pen := GFScalingPen on: aGraphicsContext medium.			pen translation: aGraphicsContext translation.			displaySystem setDisplayPen: pen copy.			aBlock ensure: 					[pen := oldPanePen.					oldSystemPen ifNotNil:[displaySystem setDisplayPen: oldSystemPen]]]		ifFalse: [aBlock value]</body><body package="GF/ST Base">displayWindow	"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Let the owner process the display event        or draw all the retained segments."	(self hasActionForEvent: #display)		ifTrue: [self triggerEvent: #display]		ifFalse: [displaySystem displayAll]</body><body package="GF/ST Base">doButton1DragDrop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | sourceLocation |	sourceLocation := self dragSourceLocation.	self dragOnMove: nil location: nil.	( self doDragDropAt: sourceLocation button: 1 )</body><body package="GF/ST Base">doPopupMenuAt: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    super doPopupMenuAt: aPoint.    self sendDeferredEvent: #redraw</body><body package="GF/ST Base">downcastEvent: ev with: value from: sender"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	ev == #bounds ifTrue: [ displaySystem == nil ifFalse: [ displaySystem reset ] ].	^super downcastEvent: ev with: value from: sender</body><body package="GF/ST Base">graphicsToolClass"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Answer the graphics tool class used by the receiver."    ^GraphicsContext</body><body package="GF/ST Base">initGraphics"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    super initGraphics.	self graphicsContext fill: self backColor.    displaySystem setDisplayPen: self graphicsContext.</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	super initialize.	scrollPoint := 8@8.	pagePoint := 64@64.	displaySystem := GFDoubleBufferingGraphicsDisplaySystem forDisplayPane: self.</body><body package="GF/ST Base">menu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^displaySystem interface menu</body><body package="GF/ST Base">pagePoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the point that represents the amount to page the receiver	 during scrolling	"	pagePoint := aPoint.</body><body package="GF/ST Base">pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| gc |	self topComponent == nil ifTrue: [ ^nil ].	pen isNil ifTrue: [		gc := self graphicsContext.		pen := GFScalingPen on: gc medium.		pen translation: gc translation].	^pen</body><body package="GF/ST Base">popupMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^displaySystem interface popupMenu</body><body package="GF/ST Base">redraw"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Redraw the receiver"    displaySystem interface redraw</body><body package="GF/ST Base">scrollHorizontal: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Scroll the pane right by anInteger         number of pixels (if positive) or left by         the absolute value of anInteger (if negative)."    self scrollTopCorner: anInteger  @ 0</body><body package="GF/ST Base">scrollPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the point that represents the amount to scroll the receiver	 during scrolling	"	scrollPoint := aPoint.</body><body package="GF/ST Base">scrollTopCorner: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| scrolledPoint |	"Private - This method is expecting a delta point to scroll by"	scrollPoint &gt; 0 			ifFalse: [ scrolledPoint := aPoint ]			ifTrue: [ scrolledPoint := aPoint roundTo: scrollPoint ]. 	self container scrollBy: scrolledPoint</body><body package="GF/ST Base">scrollTopCornerTo: aNewCorner"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Scroll topCorner to aNewCorner"   	displaySystem scrollTopCornerTo: aNewCorner</body><body package="GF/ST Base">scrollVertical: anInteger"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Scroll the pane up by anInteger         number of pixels (if positive) or down by         the absolute value of anInteger (if negative)."		self scrollTopCorner: 0 @ anInteger</body><body package="GF/ST Base">scrollingRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    ^displaySystem scrollingRectangle</body><body package="GF/ST Base">setDisplaySystem: anPsiGraphicsDisplaySystem"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    displaySystem := anPsiGraphicsDisplaySystem.</body><body package="GF/ST Base">setInterface: aGFDrawingInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	displaySystem setInterface: aGFDrawingInterface.	aGFDrawingInterface setDefaultTool.</body><body package="GF/ST Base">shouldDoDragDrop: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^( self isLocalDragSource and: [ self dragOnMove] )</body><body package="GF/ST Base">totalLength"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    ^displaySystem length</body><body package="GF/ST Base">totalWidth"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    ^displaySystem width</body><body package="GF/ST Base">unscaleRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scale |	self scaling ifFalse: [ ^rect ].	scale := self scale.	^Rectangle origin: (rect origin / scale) floor extent: ((rect extent / scale) ceiling max: (1@1))</body><body package="GF/ST Base">update"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Redisplay the receiver window."    (self hasActionForEvent: #needsContents)        ifFalse: [^self displayWindow].    self triggerEvent: #needsContents.    self invalidateRectangle: self bounds</body><body package="GF/ST Base">updateRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    |  |	self graphicsContext notNil ifTrue: [		displaySystem initDisplayPen: self pen.     ].    displaySystem resizeDisplayPaneRectangle: self bounds.	(self container isNil or: [ self container isScrollingContainer not]) ifTrue: [ ^self ].	self container updateControls.	self container scroll: 				((self container dataExtent + (self container translation - self container visibleExtent)) min: (0@0)) negated.</body></methods><methods><class-id>Polymorphic.GFDrawingPane</class-id> <category>private</category><body package="GF/ST Base">scale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displaySystem interface scale asPoint.</body><body package="GF/ST Base">scalePoint: point"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scale |	self scaling ifFalse: [ ^point ].	scale := self scale.	^point x: (point x * scale x) rounded  y: (point y * scale y) rounded</body><body package="GF/ST Base">scaleRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scale |	self scaling ifFalse: [ ^rect ].	scale := self scale.	^Rectangle origin: (rect origin * scale) ceiling extent: (rect extent * scale) ceiling</body><body package="GF/ST Base">scaling"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displaySystem workPen scaling</body></methods><methods><class-id>Polymorphic.GFDrawingPane</class-id> <category>bounds accessing</category><body package="GF/ST Base">bounds: aRectangle	super bounds: aRectangle.	displaySystem ifNotNil: [ displaySystem reset ]</body><body package="GF/ST Base">preferredBounds"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	displaySystem isNil ifTrue: [ ^super preferredBounds ].	^(0@0 extent: (displaySystem extent * displaySystem interface scale))</body><body package="GF/ST Base">translation"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self container translation + (self localPointToGlobal: self bounds origin)</body></methods><methods><class-id>Polymorphic.GFDrawingPane</class-id> <category>private-keyboard</category><body package="GF/ST Base">dispatchesKeyboard"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self topComponent == nil ifTrue: [ ^false ].	^self topComponent dispatchesKeyboard</body><body package="GF/ST Base">keyboardProcessor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self topComponent keyboardProcessor</body><body package="GF/ST Base">processKeyboard: ev"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Let the active tool dispatch the event"	^displaySystem interface activeTool processKeyboard: ev</body><body package="GF/ST Base">processKeyboardEvent: ev"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Let the active tool dispatch the event"	^displaySystem interface activeTool processKeyboard: ev</body></methods><methods><class-id>Polymorphic.GFDrawingPane</class-id> <category>controller accessing</category><body package="GF/ST Base">defaultController	"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(super defaultController)		enableYellowButton: true;		controlBlock: 				[:pt :button | 				button == #wentDown					ifTrue: [self button1Down: pt]					ifFalse: [button == #doubleClick ifTrue: [self button1DoubleClick: pt]]];		evenIfKeyPressed: true</body><body package="GF/ST Base">defaultControllerClass"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^GFPaneController</body></methods><methods><class-id>Polymorphic.GFDrawingPane</class-id> <category>initialize-release</category><body package="GF/ST Base">release"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self changed: #releasing.	super release.	displaySystem release</body></methods><methods><class-id>Polymorphic.GFDrawingPane class</class-id> <category>GF/ST</category><body package="GF/ST Base">forInterface: anPsiDrawingInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new setInterface: anPsiDrawingInterface</body></methods><methods><class-id>Polymorphic.GFButtonGO</class-id> <category>private</category><body package="GF/ST Base">origin: aPoint image: anImage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    origin := aPoint.    cache := anImage.    self extent: anImage extent.</body><body package="GF/ST Base">origin: aPoint image: anImage mask: aMask"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    origin := aPoint.    cache := GFOpaqueBitmap figure: (GFScalingImage sourceImage: anImage scale: self scale) shape: (GFScalingImage sourceImage: (aMask palette: CoveragePalette monoMaskPalette) scale: self scale).    self extent: anImage extent.</body></methods><methods><class-id>Polymorphic.GFButtonGO</class-id> <category>GF/ST</category><body package="GF/ST Base">borderSelector"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the method by which the receiver draws the border"    ^borderSelector isNil ifTrue: [ borderSelector := #drawOutRect3D: ] ifFalse: [ borderSelector ]</body><body package="GF/ST Base">buttonHandleSending: selector to: owner"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | handle |    borderSelector := nil.    self setState: true.    self redraw.    handle := GFAbsoluteTrackHandle on: self at: #center sense: #containsPoint: change: #setState:.    handle scrollFlag: false.    handle releaseAction: [ (self borderSelector == #drawPushedRect3D:)                                                ifTrue: [ owner perform: selector ].                                          self setState: false.                                          self redraw. ].    ^handle</body><body package="GF/ST Base">centerOffset"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^centerOffset</body><body package="GF/ST Base">centerOffset: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    centerOffset := aPoint</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^borderSelector ~~ nil        ifTrue: [ super displayBox expandedByPoint: 3@3 ]        ifFalse: [ super displayBox ]</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Display a mask for the receiver.  The mask is black and white, where	 black represents the opaque area, and white represents the transparent	 area	"	"Because I am a rectilinear figure, just color the area		that is my bounding Rectangle."	aPen		color: RGBColor white;		fillColor: RGBColor white;		rectangle: self displayBox</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    "Fill my cache if it was empty or damaged. Then copy my cache directly to aGC."    | offset color box |    cache == nil ifTrue: [self fillCache].    aPen setStyle: 0            color: (color := Color buttonFace)            width: 1.    borderSelector ~~ #drawOutRect3D:                ifTrue: [ offset := 2@2 ]                ifFalse: [ offset := 1@1 ].    aPen setFillColorTo: color.    aPen fastRectangleFilled: (box := self displayBox).    aPen gfExecute:                [ cache displayAt: (self origin + offset + centerOffset)                             with: aPen.]                clipRect: (box logicalToDevice: aPen).    aPen perform: self borderSelector with: box.</body><body package="GF/ST Base">extent: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    extent := aPoint.    centerOffset := (self extent - cache extent)//2.</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Grow the receiver based on aRectangle"    | topCorner bottomCorner |    self damageDuring: [        (topCorner := aRectangle leftTop) ~= (0@0) ifTrue: [ origin leftAndUp: topCorner ].        (bottomCorner := aRectangle rightBottom) ~= (0@0) ifTrue: [ self extent: (extent rightAndDown: bottomCorner) ].    ].    self triggerEvent: #resize with: self</body><body package="GF/ST Base">setState: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | toggled |    toggled := false.    aBoolean        ifTrue: [ borderSelector ~~ #drawPushedRect3D:                            ifTrue: [ borderSelector := #drawPushedRect3D:.                                           self damaged.                                           toggled := true ]]        ifFalse: [ borderSelector ~~ #drawOutRect3D:                            ifTrue: [ borderSelector := #drawOutRect3D:.                                           self damaged.                                           toggled := true ]].    toggled ifTrue: [ self damaged ].</body><body package="GF/ST Base">snapToGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap the receiver to the grid"    super snapToGrid.    self extent: extent.</body><body package="GF/ST Base">whenClickedSend: selector to: receiver"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    self when: #generateHandles send: #noHandles to: self.    self when: #needsPositionHandle send: #buttonHandleSending:to: to: self with: selector with: receiver.    borderSelector := #drawOutRect3D:.    self damaged.</body></methods><methods><class-id>Polymorphic.GFButtonGO class</class-id> <category>instance creation</category><body package="GF/ST Base">fromGO: go"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"    | button bitmap mask |    button := self new.    bitmap := GFOpaqueBitmap screenExtent: go displayBox extent.    mask := Image screenExtent: go displayBox extent.    go displayWith: bitmap pen at: 0@0.    go displayShapeWith: mask pen at: 0@0.    bitmap setMask: mask.    button origin: go displayBox origin copy image: bitmap.    ^button</body></methods><methods><class-id>Polymorphic.GFGraphicsDisplaySystem</class-id> <category>GF/ST</category><body package="GF/ST Base">addHostAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Add anAction the the host actions"	hostActions add: anAction</body><body package="GF/ST Base">button1DoubleClickCheckBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| ctrl |	ctrl := displayPane controller.	^[ (ctrl checkAndResetDoubleClick == nil) not]</body><body package="GF/ST Base">buttonUpCheckBlock"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^[ | ctrl |	(ctrl := displayPane controller).	ctrl sensor redButtonPressed not]</body><body package="GF/ST Base">ctrlDown"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayPane controller sensor ctrlDown</body><body package="GF/ST Base">cursorPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^mousePoint</body><body package="GF/ST Base">cursorPointSnapped: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the mousePoint.	 Snap the mouse point to the grid if snap is true, and limit the point to	 the extent of the drawing if limit is true	"	mousePoint := interface 								snapMousePoint: mousePoint								if: snap								limit: limit.	^mousePoint</body><body package="GF/ST Base">damageRegion: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Combine aRectangle in the damaged region"    damagedRegion valid        ifFalse: [damagedRegion initializeFrom: aRectangle]        ifTrue: [damagedRegion mergeWith: aRectangle].</body><body package="GF/ST Base">dispatchesKeyboard"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayPane dispatchesKeyboard</body><body package="GF/ST Base">displayAll"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Display all"    self display: (0@0 extent: (interface totalWidth @ interface totalHeight)).</body><body package="GF/ST Base">displayHandles: handles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| dispPen |	dispPen := self pen.	dispPen nonScaledTranslation: displayPane translation.	dispPen nonScalingClippingRectangle: displayPane clippingBox.	1 to: handles size do: [:i |		(handles at: i) displayWith: dispPen     	].</body><body package="GF/ST Base">displayPane"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^displayPane</body><body package="GF/ST Base">displayPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayPane graphicsContext</body><body package="GF/ST Base">displayViewRectangle: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| hHandles adjustedRect |	adjustedRect := aRect expandedByPoint: self adjustedMinFactor.	hHandles := interface handlesToDisplayInRect: adjustedRect.	self damageRegion: (displayPane pen unscaleRectangle: adjustedRect); 		repairDamage;		displayHandles: hHandles</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^interface extent</body><body package="GF/ST Base">graphicsDevice	^displayPane container graphicsDevice</body><body package="GF/ST Base">hideHandles: handles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Hide the collection of handles"    1 to: handles size do: [:i |        self damageRegion: (handles at: i) displayBox    ].    self repairDamage</body><body package="GF/ST Base">initDisplayPen: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	interface == nil ifTrue: [ ^self ].	interface drawing coordinateSystem initializePen: aPen.</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    damagedRegion := GFDamagedRegion origin: 0@0 corner: 0@0. 	mousePoint := 0@0.	hostActions := OrderedCollection new.	minFactor := 1@1.</body><body package="GF/ST Base">interface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^interface</body><body package="GF/ST Base">keyboardProcessor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayPane keyboardProcessor</body><body package="GF/ST Base">length"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^self extent y</body><body package="GF/ST Base">minFactor: win view: view"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	| v w gcd |	w := win.	v := view.	[(gcd := w gcd: v) = 1] whileFalse: [		w := w // gcd.		v := v // gcd.	].	^w</body><body package="GF/ST Base">paintPreferences"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayPane container paintPreferences</body><body package="GF/ST Base">pen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^displayPane pen</body><body package="GF/ST Base">penMedium"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self pen medium</body><body package="GF/ST Base">quietlyHideHandles: handles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Hide the collection of handles"    1 to: handles size do: [:i |        self damageRegion: (handles at: i) displayBox    ].</body><body package="GF/ST Base">redrawVisible"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self damageRegion: (self pen unscaleRectangle: self displayPane bounds); repairDamage.</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    super release.    displayPane := nil.</body><body package="GF/ST Base">repairDamage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    damagedRegion valid ifFalse: [^self].    self display: (damagedRegion expandedByPoint: minFactor).    damagedRegion invalidate.</body><body package="GF/ST Base">reset"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self initDisplayPen: self pen.	self setMinFactor.	self setScrollUnits.	displayPane updateRectangle; invalidate.</body><body package="GF/ST Base">scale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self pen scale</body><body package="GF/ST Base">scrollTopCorner: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	displayPane scrollTopCorner: pt.	"self translateVisibleArea: pt."</body><body package="GF/ST Base">scrollTopCornerTo: aNewCorner"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - Scroll the visibleArea to aNewCorner"    self scrollTopCorner: (self visibleArea leftTop rightAndDown: aNewCorner + 1)</body><body package="GF/ST Base">scrollingRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^0@0 extent: interface extent</body><body package="GF/ST Base">setDisplayPane: aPsiDrawingPane"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	displayPane := aPsiDrawingPane.    displayPane setDisplaySystem: self.</body><body package="GF/ST Base">setDisplayPen: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self initDisplayPen: aPen; setScrollUnits</body><body package="GF/ST Base">setInterface: anPsiDrawingInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    interface := anPsiDrawingInterface.	interface setDisplaySystem: self</body><body package="GF/ST Base">setMinFactor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	interface isNil 		ifTrue: [ minFactor := 1@1 ]		ifFalse: [ minFactor := ((1@1) * interface drawing scale) max: (1@1) ]</body><body package="GF/ST Base">setMousePoint: aPoint snapToGrid: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the mousePoint.  Answer the snapped and limited mouse point.	 Snap the mouse point to the grid if snap is true, and limit the point to	 the extent of the drawing if limit is true	"	mousePoint := interface 								snapMousePoint: aPoint								if: snap								limit: limit.	^mousePoint</body><body package="GF/ST Base">setScrollUnits</body><body package="GF/ST Base">shiftDown"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^displayPane controller sensor shiftDown</body><body package="GF/ST Base">sizingFrom: oldPoint to: newPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scrollX scrollY y x maxPoint |	self updateVisibleArea.	((visibleArea containsPoint: newPoint) or: [ newPoint &gt; interface drawingExtent ])		ifTrue: [^self ].	maxPoint := newPoint min: interface drawingExtent.	scrollX := scrollY := 0.	maxPoint y &lt; (y := visibleArea top) 		ifTrue: [ scrollY := maxPoint y - y ]		ifFalse: [ maxPoint y &gt; (y := visibleArea bottom) ifTrue: [ scrollY := maxPoint y - y ] ].	maxPoint x &lt; (x := visibleArea left) 		ifTrue: [ scrollX := maxPoint x - x ]		ifFalse: [ maxPoint x &gt; (x := visibleArea right) ifTrue: [ scrollX := maxPoint x - x ] ].	self scrollTopCorner: scrollX @ scrollY.</body><body package="GF/ST Base">topCorner"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^self visibleArea leftTop</body><body package="GF/ST Base">trackMouse: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating aBlock for every point"    ^self trackMouse: aBlock scroll: true snapToGrid: true.</body><body package="GF/ST Base">trackMouse: trackBlock preScrollDo: preScrollBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating trackBlock for every point and evaluate the     preScroll block for every point before scrolling the display.     the display scrolls to accomidate the tracking, snaps the mouse points	 to the drawing's grid, as well as limiting them to the drawing's extent.	"	^self 		trackMouse: trackBlock 		uponRelease: [] 		until: self buttonUpCheckBlock		scroll: true		preScrollDo: preScrollBlock		snapToGrid: true		limit: true</body><body package="GF/ST Base">trackMouse: trackBlock preScrollDo: preScrollBlock snapToGrid: snap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating trackBlock for every point and evaluate the     preScroll block for every point before scrolling the display.     the display scrolls to accomidate the tracking, snaps the mouse points	 to the drawing's grid, as well as limiting them to the drawing's extent.	"	^self 		trackMouse: trackBlock 		uponRelease: [] 		until: self buttonUpCheckBlock		scroll: true		preScrollDo: preScrollBlock		snapToGrid: snap		limit: true</body><body package="GF/ST Base">trackMouse: aBlock scroll: scrollFlag"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating aBlock for every point.	  Scroll the display to accomidate the tracking if scroll is true.	  The mouse point tracked is snapped to the grid of the drawing.	"	^self trackMouse: aBlock scroll: scrollFlag snapToGrid: true.</body><body package="GF/ST Base">trackMouse: trackBlock scroll: scrollFlag snapToGrid: snap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating trackBlock for every point.	  Scroll the display to accomidate the tracking if scroll is true,	  snaping the mouse point to the grid of the drawing if snap	  is true.  The mouse point is limited to the extent of the drawing.	"	^self 		trackMouse: trackBlock 		uponRelease: nil		until: self buttonUpCheckBlock		scroll: scrollFlag		preScrollDo: nil		snapToGrid: snap		limit: true</body><body package="GF/ST Base">trackMouse: aBlock snapToGrid: snap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating aBlock for every point.	  Scroll the display to accomidate the tracking, snapping	  the mouse point to the grid of the drawing if snap is true..	"    ^self trackMouse: aBlock scroll: true snapToGrid: snap.</body><body package="GF/ST Base">trackMouse: trackBlock uponRelease: releaseBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating the trackBlock for every point.     When the button is released, evaluate the releaseBlock.	 The display is scrolled to accomidate the tracking, and the mouse	 point is snapped to the grid.  The mouse points tracked are limited	 to the extent of the drawing.    "    self        trackMouse: trackBlock        uponRelease: releaseBlock        until: self buttonUpCheckBlock		scroll: true		preScrollDo: nil		snapToGrid: true		limit: true</body><body package="GF/ST Base">trackMouse: trackBlock uponRelease: releaseBlock until: stopBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating the trackBlock for every point.     The mouse is tracked until the stopBlock evaluates true.  Upon     release of the mouse button, the releaseBlock is evaluated. 	 The display is scrolled to accomidate the tracking if scroll is true.	 The mouse point is snapped to the drawing grid if snap is true.	 The mouse points tracked are limited to the extent of the drawing	 if limit is true.    "	^self 		trackMouse: trackBlock 		uponRelease: releaseBlock		until: stopBlock		scroll: true		preScrollDo: nil		snapToGrid: true		limit: true</body><body package="GF/ST Base">trackMouse: trackBlock uponRelease: releaseBlock until: stopBlock scroll: scroll preScrollDo: preScrollBlock snapToGrid: snap limit: limit 	"Copyright (C) 1993-1995 Polymorphic Software, Inc. 	All Rights Reserved"	"The central mouse tracking routine. 		Track the mouse point, evaluating the trackBlock for 	every point. 	The mouse is tracked until the stopBlock evaluates true. Upon 	release of the mouse button, the releaseBlock is evaluated. 	The display is scrolled to accomidate the tracking if scroll is true. 	If scrolling is enabled, the preScrollBlock is evaluated before scrolling 	the display with the previous point tracked as the argument. 	The mouse point is snapped to the drawing grid if snap is true. 	The mouse points tracked are limited to the extent of 	the drawing 	if limit is true. 	"	| oldPoint buttonUpCheckBlock respondToButtonDown |	oldPoint := nil.	buttonUpCheckBlock := self buttonUpCheckBlock.	respondToButtonDown := false.	(displayPane controller) 		checkAndResetDoubleClick; 		deactivateControlLoop.	interface hideHandlesWhile: [stopBlock			whileFalse: 				[| sensor pt |				sensor := displayPane controller sensor.				respondToButtonDown := respondToButtonDown or: [sensor redButtonPressed].				(pt := sensor mousePoint) ~= oldPoint					ifTrue: 						[scroll							ifTrue: 								[oldPoint == nil ifFalse: [preScrollBlock == nil ifFalse: [preScrollBlock value: oldPoint]].								self sizingFrom: oldPoint to: pt].						self							transformPoint: pt							snapToGrid: snap							limit: limit.						trackBlock value: mousePoint].								(respondToButtonDown and: [buttonUpCheckBlock value])					ifTrue: 						[respondToButtonDown := false.						releaseBlock == nil ifFalse: [releaseBlock value]].				oldPoint := mousePoint.				false]].	displayPane controller activateControlLoop</body><body package="GF/ST Base">trackMouseUntilLBDoubleClick: trackBlock uponRelease: releaseBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating the trackBlock for every point.     When the left button is released, evaluate the releaseBlock.     Continue tracking until the Left mouse button is double clicked    "	self		trackMouse: trackBlock		uponRelease: releaseBlock		until: self button1DoubleClickCheckBlock.	"This is here for the case that the trackBlock was evaluated in-between clicks of a double click event"	releaseBlock == nil ifFalse: [releaseBlock value].</body><body package="GF/ST Base">transformPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	mousePoint := aPoint deviceToLogical: self pen.	interface newMousePoint: mousePoint.	^mousePoint</body><body package="GF/ST Base">transformPoint: aPoint snapToGrid: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform aPoint from the device coordinates to the logical coordinates.	 Snap the mouse point to the grid if snap is true, and limit the point to	 the extent of the drawing if limit is true	"	mousePoint := interface 								snapMousePoint: (aPoint deviceToLogical: self pen)								if: snap								limit: limit.	^mousePoint</body><body package="GF/ST Base">updateVisibleArea"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		^visibleArea := displayPane clippingBox</body><body package="GF/ST Base">visibleArea"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	visibleArea == nil ifTrue: [		displayPane == nil ifTrue: [ ^0@0 extent: 100@100 ].		self updateVisibleArea.	].	^visibleArea</body><body package="GF/ST Base">visibleRectangle"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	^self visibleArea deepCopy</body><body package="GF/ST Base">width"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^self extent x</body><body package="GF/ST Base">workPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^GFScalingPen on: self penMedium</body></methods><methods><class-id>Polymorphic.GFGraphicsDisplaySystem</class-id> <category>displaying</category><body package="GF/ST Base">display: clipRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	| dispPen |	displayPane topComponent == nil ifTrue: [ ^self ].	dispPen := displayPane pen.	dispPen nonScaledTranslation: displayPane translation.	dispPen nonScalingClippingRectangle: (displayPane bounds intersect: (dispPen scaleRectangle: clipRect)).	dispPen gfFillOrigin: clipRect origin extent: clipRect extent color: displayPane backColor.	interface drawing display: clipRect with: dispPen.	interface showHandles.</body><body package="GF/ST Base">resizeDisplayPaneRectangle: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	visibleArea == nil ifTrue: [		^visibleArea := 0@0 extent: (aRect extent deviceToLogical: self pen)	].	visibleArea := visibleArea leftTop extent: (aRect extent deviceToLogical: self pen).</body><body package="GF/ST Base">setScale: aScalingFactor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"NoOp.  The scaling is done in the initializing of the pen via the drawing"</body></methods><methods><class-id>Polymorphic.GFGraphicsDisplaySystem</class-id> <category>private</category><body package="GF/ST Base">adjustedMinFactor	"Adjust minFactor for one pixel better in damage rectangle bounds for any fractional scale coordinate.  This has been observed to improve redraw when scrolling"	| adjustedFactor |	adjustedFactor := minFactor.	self scale x asFloat fractionPart &gt; 0 ifTrue:[adjustedFactor := adjustedFactor + (1@0)].	self scale y asFloat fractionPart &gt; 0 ifTrue:[adjustedFactor := adjustedFactor + (0@1)].	^adjustedFactor</body></methods><methods><class-id>Polymorphic.GFGraphicsDisplaySystem class</class-id> <category>GF/ST</category><body package="GF/ST Base">forDisplayPane: aPsiDisplayPane"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new setDisplayPane: aPsiDisplayPane</body><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new initialize</body></methods><methods><class-id>Polymorphic.GFMessage</class-id> <category>GF/ST</category><body package="GF/ST Base">= aMessage"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer &lt;true&gt; if the receiver and &lt;aMessage&gt; are equal.        Two objects are equal if they have the same behavior at the        current point in time. Objects that are equal at one time may        not be equal at some later time.        Invariants: two objects that compare equal must have equal        hash values."    ^self == aMessage        or: [self class == aMessage class            and: [self receiver == aMessage receiver            and: [self selector == aMessage selector            and: [self arguments = aMessage arguments]]]]</body><body package="GF/ST Base">argumentAt: anIndex"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer the argument at position &lt;anIndex&gt;."    ^self arguments at: anIndex</body><body package="GF/ST Base">argumentAt: anIndex put: anObject"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Set the argument at position &lt;anIndex&gt; to &lt;anObject&gt;."    self arguments at: anIndex put: anObject</body><body package="GF/ST Base">arguments: anArray"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Set the arguments array for the message."    args := anArray</body><body package="GF/ST Base">collectArguments: evaluationArguments"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Private - answer the action arguments with which to evaluate        the receiver, collecting from the &lt;evaluationArguments&gt;        and the predefined arguments in the receiver. "    | predefinedArgs |    predefinedArgs := self arguments.    ^(evaluationArguments size = predefinedArgs size)        ifTrue: [evaluationArguments]        ifFalse:            [( predefinedArgs isNil                ifTrue: [ predefinedArgs := Array new: (self class numberOfArgumentsFor: selector) ]                ifFalse: [predefinedArgs copy] )                    replaceFrom: 1                    to: (evaluationArguments size min: predefinedArgs size)                    with: evaluationArguments                    startingAt: 1]</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| rslt |	receiver == nil ifTrue: [		receiver := newTarget.		rslt := self evaluate.		receiver := nil.		^rslt	].	^self evaluate</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget withArguments: anArray"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| rslt |	receiver == nil ifTrue: [		receiver := newTarget.		rslt := self evaluateWithArguments: anArray.		receiver := nil.		^rslt	].	^self evaluateWithArguments: anArray</body><body package="GF/ST Base">evaluateWithArguments: anArray"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer the result of sending the message represented by        the receiver."    ^self receiver        perform: self selector        withArguments: (self collectArguments: anArray)</body><body package="GF/ST Base">hash"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer an integer hash value for the receiver. Invariants:        the hash value of an object must be constant over time;        two objects that compare equal must have equal hash values."     ^self receiver hash + self selector hash + self arguments hash</body><body package="GF/ST Base">initializeFrom: aMessage"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"    "Initialize the receiver to be equivalent to aMessage."    self receiver: aMessage receiver.    self selector: aMessage selector.    self arguments: aMessage arguments.</body><body package="GF/ST Base">isAppropriateActionFor: anObject"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	receiver isNil ifFalse: [^true].	^anObject respondsTo: selector</body><body package="GF/ST Base">isMessage"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer whether the receiver is a kind of Message."    ^true</body><body package="GF/ST Base">perform"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer the result of sending the message represented by the receiver."    ^self value</body><body package="GF/ST Base">performDeferred"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Perform the expression by requeueing the request."    [ self perform ] fork</body><body package="GF/ST Base">printOn: aStream"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Append a text representation of the receiver to aStream."    aStream nextPutAll: self class name,        '(', receiver class printString, '&gt;&gt;',        selector printString, ')'</body><body package="GF/ST Base">receiver: anObject selector: aSymbol arguments: anArray"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Set the recevier to anObject, selector to aSymbol,         and arguments to anArray."    self receiver: anObject.    self selector: aSymbol.    self arguments: anArray.</body><body package="GF/ST Base">selector: aSymbol"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Set the message selector."    selector := aSymbol</body><body package="GF/ST Base">send"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"    "Send the directed message specified by the receiver."    ^self receiver        perform: self selector        withArguments: self arguments</body><body package="GF/ST Base">sendTo: anObject"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"    "Send the message specified by the receiver to anObject."    ^anObject        perform: self selector        withArguments: self arguments</body><body package="GF/ST Base">value: value1 value: value2"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Use Parts version for base image"        "Answer the result of evaluating the receiver with two arguments. "    ^self evaluateWithArguments: (Array with: value1 with: value2)</body></methods><methods><class-id>Polymorphic.GFMessage class</class-id> <category>GF/ST</category><body package="GF/ST Base">numberOfArgumentsFor: aSelector"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer the number of arguments required by a message whose        selector is &lt;aSelector&gt;, assuming &lt;aSelector&gt; is a legal        method selector."    aSelector first isLetter        ifTrue: [ ^aSelector occurrencesOf: $: ].   ( #(         = ~= == ~~ &gt; &gt;= &lt; &lt;=   " comparison operations "        + - *  / \\  //                    " arithmetic operations "       &amp; |                                 " logical operations "       @ ,                                " miscellaneous "        ) includes: aSelector asSymbol)            ifTrue: [^1].    ^aSelector occurrencesOf: $:</body><body package="GF/ST Base">receiver: receiver selector: selector"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer an instance of the receiver representing a message        sent to the &lt;receiver&gt; with the given message &lt;selector&gt; and        no arguments."    ^self new        receiver: receiver        selector: selector        arguments: (Array new: (self numberOfArgumentsFor: selector))</body><body package="GF/ST Base">receiver: receiver selector: selector arguments: argumentArray"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer an instance of the receiver representing a message        sent to the &lt;receiver&gt; with the given message &lt;selector&gt;        and the arguments in the &lt;argumentArray&gt;."    ^self new        receiver: receiver        selector: selector        arguments: argumentArray</body><body package="GF/ST Base">selector: selector arguments: arguments"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"     "Answer a new instance of the receiver with the specified     selector and arguments."    ^self new        selector: selector ;        arguments: arguments</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>accessing</category><body package="GF/ST Base">connectedObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether or not the receiver represents a connection between	 two graphic objects	"	^Array 		with: self startObject		with: self stopObject</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the points the receiver should snap to the grid used by	 the receiver.	 Subclasses should override this to implement their own behavior	 towards the grid	"	^Array		with: start		with: stop</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the origin of the receiver"	^self displayBox origin</body><body package="GF/ST Base">start: aPoint stop: bPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Note, aPoint and bPoint is now MY points"	start := aPoint.	stop := bPoint.</body><body package="GF/ST Base">startPlug	^startPlug</body><body package="GF/ST Base">startPlug: aLineEndPlug	super startPlug: aLineEndPlug.	startPlug displayPoint: start</body><body package="GF/ST Base">startPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, start is MY point.  Be careful of changing the point's	value, because, it will change me"		^start asPoint</body><body package="GF/ST Base">startPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	start := aPoint.	startPlug == nil ifFalse: [		startPlug displayPoint: start.	].</body><body package="GF/ST Base">stopPlug	^stopPlug</body><body package="GF/ST Base">stopPlug: aLineEndPlug	super stopPlug: aLineEndPlug.	stopPlug displayPoint: stop</body><body package="GF/ST Base">stopPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, stop is MY point.  Be careful of changing the point's	value, because, it will change me"	^stop asPoint</body><body package="GF/ST Base">stopPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	stop := aPoint.	stopPlug == nil ifFalse: [		stopPlug displayPoint: stop.	].</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>copying</category><body package="GF/ST Base">copy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| new |	new := super copy.	startPlug == nil ifFalse: [ new startPlug displayPoint: new startPoint ].	stopPlug == nil ifFalse: [ new stopPlug displayPoint: new stopPoint ].	^new</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Perform any additional action after copy."	super postCopy.	start := start copy.	stop := stop copy.</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>display</category><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Display a mask for the receiver.  The mask is black and white, where	 black represents the opaque area, and white represents the transparent	 area	"	"Display a shape on aPen that corresponds to my image, a  line."	super displayShapeWith: aPen.	aPen		setLineWidthTo: width;		black;		displayLineFrom: start to: stop</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"The central display routine.  Display the image of the receiver,	 using aPen.  The receiver should make no assumptions regarding	 the state of the pen, and is not responsible for resetting the pen	 to the previous state.	"	super displayWith: aPen.	aPen displayLineFrom: self lineStart to: self lineStop.</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>translation</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Translate the receiver by aPoint"	start translatedByPoint: aPoint.	stop translatedByPoint: aPoint.	startPlug == nil ifFalse: [ startPlug displayPoint: start ].	stopPlug == nil ifFalse: [ stopPlug displayPoint: stop ].</body><body package="GF/ST Base">moveStartBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the start point by a deltaPoint"	self damageDuring: [start translatedByPoint: deltaPoint].	startPlug == nil ifFalse: [ startPlug displayPoint: start ].	self triggerEvent: #moveStart</body><body package="GF/ST Base">moveStopBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the stop point by a deltaPoint"	self damageDuring: [stop translatedByPoint: deltaPoint].	stopPlug == nil ifFalse: [ stopPlug displayPoint: stop ].	self triggerEvent: #moveEnd</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>private</category><body package="GF/ST Base">startBox	^(start + startPlug displayOffset) extent: startPlug extent</body><body package="GF/ST Base">stopBox	^(stop + stopPlug displayOffset) extent: stopPlug extent</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>plug macros</category><body package="GF/ST Base">basicDisplayEndArrowWith: pen for: plug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an arrow head at the end of the line"	| arrow1 arrow2 vector u aPoint plugBox oldJoin |	(vector := stop - start) = (0@0)		ifTrue: [			u := 0@1.			aPoint := stop - ((1@0) * width * 7).		]		ifFalse: [			u := vector normal unitVector.			aPoint := stop - (vector unitVector "* width" * 7)		].	arrow1 := (aPoint + (u * ("width *" 3))) rounded.	arrow2 := (aPoint - (u * ("width *" 3))) rounded.	plugBox :=  ((((arrow1 copy becomeLeftMostAndHighest: arrow2)									becomeLeftMostAndHighest: stop) corner: (							((arrow1 copy becomeRightMostAndLowest: arrow2) 									becomeRightMostAndLowest: stop))) expandByScalar: width *2).	plug extent: plugBox extent.	plug displayOffset: plugBox origin - stop.	plug displayPoint: stop.	oldJoin := pen joinStyle.	pen		setStyle: lineStyle		color: color		width: self width.	pen joinStyle: pen class joinMiter.	pen fastPolygonFilled: (Array with: stop with: arrow1 with: arrow2 with: stop).	pen joinStyle: oldJoin</body><body package="GF/ST Base">displayEndArrowShapeWith: pen for: plug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an arrow head at the end of the line"	pen blackFill.	self basicDisplayEndArrowWith: pen for: plug</body><body package="GF/ST Base">displayEndArrowWith: pen for: plug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an arrow head at the end of the line"	color isNil		ifTrue: [ pen blackFill ]		ifFalse: [ pen setFillColorTo: color ].	self basicDisplayEndArrowWith: pen for: plug</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>mementos</category><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the position information of the receiver"	^(super positionInformation)			add: (self class gfMessageClass receiver: nil selector: #startPoint: arguments: (Array with: start copy));			add: (self class gfMessageClass receiver: nil selector: #stopPoint: arguments: (Array with: stop copy));			yourself.</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>queries</category><body package="GF/ST Base">distanceTo: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the orthogonal distance from the receiver to aPoint"	| p q d a b c |	p := self startPoint.	q := self stopPoint.	d := p - q.	a := 1.	b := (d x / d y) negated.	c := (p x + (p x - q x / (q y - p y) * p y)) negated.	^(aPoint x * a + (aPoint y * b) + c) abs / (a squared + b squared) sqrt</body><body package="GF/ST Base">isHorizontalOrVertical"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer if the receiver is horizontal or vertical"	| p q |	p := self startPoint.	q := self stopPoint.	^(p x = q x) | (p y = q y)</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"		^Array with: ((GFTrackHandle						on: self						at: #startPoint						change: #moveStartBy:)							mementoType: #positionMemento;							description: 'move start position')				with: ((GFTrackHandle								on: self								at: #stopPoint								change: #moveStopBy:)									mementoType: #positionMemento;									description: 'move stop position')</body></methods><methods><class-id>Polymorphic.GFLineGO</class-id> <category>bounds</category><body package="GF/ST Base">containsPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether or not the receiver's area contains a point"	^(super containsPoint: aPoint) or: [		((self displayBox expandBy: 3@3) containsPoint: aPoint)			and: [self isHorizontalOrVertical or: [(self distanceTo: aPoint)					&lt; 6]]].</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^super displayBox merge: ((start rectangleWith: stop) expandByScalar: width)</body></methods><methods><class-id>Polymorphic.GFLineGO class</class-id> <category>accessing</category><body package="GF/ST Base">arrowCreationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver with an arrow end plug"		^(GFCreationTool				icon: (GFTool stockIconFor: 'Arrow')				cursor: self gfCursorClass crossHair				class: self				name: 'Arrow') setCreationSelector: #createArrowNotifying: ; yourself</body><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver"	^GFCreationTool		icon: (GFTool stockIconFor: 'Line')		cursor: self gfCursorClass crossHair		class: self		name: 'Line'</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the events triggered"	eventsTriggered isNil ifTrue: [		(eventsTriggered := Set new)			addAll: self superclass eventsTriggered;			add: #moveStart;			add: #moveEnd.	].	^eventsTriggered</body></methods><methods><class-id>Polymorphic.GFLineGO class</class-id> <category>instance creation</category><body package="GF/ST Base">arrowStart: start stop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance of the receiver"	| go |	go := self new start: start stop: stop.	go stopPlug: go endArrowPlug.	^go</body><body package="GF/ST Base">arrowStartLocation: startLocation stopLocation: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance of the receiver"	| aFigure |	aFigure := self start: startLocation asPoint stop: stopLocation asPoint.	aFigure stopPlug: aFigure endArrowPlug.	startLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: startLocation receiver: aFigure sending: #startPoint:).	stopLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #stopPoint:).	^aFigure</body><body package="GF/ST Base">createArrowNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance with an arrow end plug, notifying anInterface of the action"	| startPoint stopPoint  aGFLineGO aPen |	startPoint := stopPoint := anInterface cursorPoint.	(aPen := anInterface pen)		setForeColorTo: self defaultLineColor;		displayLineFrom: startPoint to: stopPoint.	anInterface trackMouse: [:newPoint |		anInterface drawing damageRegion:			((startPoint rectangleWith: stopPoint)				expandedByPoint: 2 @ 2).		anInterface repairDamage.		aPen 			setForeColorTo: self defaultLineColor;			displayLineFrom: startPoint to: (stopPoint := newPoint).	].	startPoint = stopPoint ifFalse: [		aGFLineGO := self start: startPoint stop: stopPoint.		aGFLineGO stopPlug: aGFLineGO endArrowPlug.		^aGFLineGO 	].	^nil</body><body package="GF/ST Base">createNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| startPoint stopPoint  aGFLineGO aPen |	startPoint := stopPoint := anInterface cursorPoint.	(aPen := anInterface pen)		setForeColorTo: self defaultLineColor;		displayLineFrom: startPoint to: stopPoint.	anInterface trackMouse: [:newPoint |		anInterface drawing damageRegion:			((startPoint rectangleWith: stopPoint)				expandedByPoint: 2 @ 2).		anInterface repairDamage.		aPen 			setForeColorTo: self defaultLineColor;			displayLineFrom: startPoint to: (stopPoint := newPoint).	].	startPoint = stopPoint ifFalse: [		aGFLineGO := self start: startPoint stop: stopPoint.		^aGFLineGO	].	^nil</body><body package="GF/ST Base">start: start stop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance of the receiver"	^(self new start: start stop: stop)</body><body package="GF/ST Base">startLocation: startLocation stopLocation: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance of the receiver"	| aFigure |	aFigure := self start: startLocation asPoint stop: stopLocation asPoint.	startLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: startLocation receiver: aFigure sending: #startPoint:).	stopLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #stopPoint:).	^aFigure</body></methods><methods><class-id>Polymorphic.GFLogicalUnit</class-id> <category>GF/ST</category><body package="GF/ST Base">resolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^resolution</body><body package="GF/ST Base">resolution: aNumber"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    resolution := aNumber</body></methods><methods><class-id>Polymorphic.GFHundredthMillimeter</class-id> <category>GF/ST</category><body package="GF/ST Base">initializePen: aPen scale: scale "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Initialize aPen to the receiver's resolution, scaled accordingly    "	| winExt viewExt |	winExt := (100.0 @ 100.0 / resolution * 100) rounded.	viewExt := ((Screen default resolution) * scale * 100) rounded.	aPen newScale: (viewExt / winExt).</body><body package="GF/ST Base">printOn: aStream"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    resolution printOn: aStream.    aStream space nextPutAll: ' hundredths of a millimeter'.</body><body package="GF/ST Base">screenExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the screen extent measured in the receiver's units"    ^(self class gfDisplay pen inchSize * 100.0 / resolution) rounded</body></methods><methods><class-id>Polymorphic.GFHundredthMillimeter class</class-id> <category>GF/ST</category><body package="GF/ST Base">defaultResolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new resolution: 1000.0@1000.0 / ((Screen default resolution * (10 / 254.0)) rounded)</body><body package="GF/ST Base">highResolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new resolution: 1@1</body><body package="GF/ST Base">lowResolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new resolution: 10@10</body></methods><methods><class-id>Polymorphic.GFRectangleGO</class-id> <category>GF/ST</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    rectangle translatedByPoint: aPoint</body><body package="GF/ST Base">bounceDisplayShapeOn: aPen at: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Yep.  Bounce the #displayShapeOn:at: to the super class"    super displayShapeOn: aPen at: aPoint.</body><body package="GF/ST Base">bounceDisplayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Yep.  Bounce the displayShapeWith: to the superclass"    super displayShapeWith: aPen.</body><body package="GF/ST Base">bounceDisplayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Yep.  Bounce the #displayWith: method to the superclass"    super displayWith: aPen.</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^rectangle expandByScalar: self borderSize</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    super displayShapeWith: aPen.    fillColor == nil        ifTrue: [aPen drawRectangle: rectangle]        ifFalse: [aPen fastRectangleFilled: rectangle].</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    super displayWith: aPen.    fillColor == nil        ifTrue: [aPen drawRectangle: rectangle]        ifFalse: [aPen fastRectangleFilled: rectangle]</body><body package="GF/ST Base">extent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self displayBox extent</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the points of the receiver that should be snapped to the     grid    "    ^Array        with: rectangle topLeft        with: rectangle bottomRight</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Grow the receiver based on aRectangle"    self damageDuring: [        rectangle expandByRectangle: aRectangle.    ].    self triggerEvent: #resize with: self</body><body package="GF/ST Base">growNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Used in the creation of the receiver"	| aHandle |	aHandle := GFTrackHandle bottomRightOf: self.	aHandle mementoType: nil.	anInterface addHandle: aHandle.	self class gfCursorClass crossHair change.	aHandle invoke: anInterface.	self class gfCursorClass normal change.	anInterface removeHandle: aHandle</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"    ^rectangle origin copy</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the position information of the receiver"    ^(super positionInformation)        add: (self class gfMessageClass receiver: nil selector: #setRectangle: arguments: (Array with: rectangle deepCopy));        yourself</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform any additional action after copy."    super postCopy.    rectangle := rectangle deepCopy</body><body package="GF/ST Base">scaleBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Scale the receiver by aPoint"	self damageDuring: [		rectangle := (rectangle scaleBy: aPoint) rounded.	].	self triggerEvent: #resize with: self</body><body package="GF/ST Base">senseBottomLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftBottomGrowUnit.    (rectangle extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((rectangle bottom down: (y := growPoint y)) isAboveEqual: rectangle top) ifTrue: [ y := 0 ].    ^x @ 0 rightBottom: 0 @ y</body><body package="GF/ST Base">senseBottomRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightBottomGrowUnit.    (rectangle extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((rectangle bottom down: (y := growPoint y)) isAboveEqual: rectangle top) ifTrue: [ y := 0 ].    ^0 @ 0 rightBottom: (x @ y)</body><body package="GF/ST Base">senseTopLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftTopGrowUnit.    (rectangle extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((rectangle top up: (y := growPoint y)) isBelowEqual: rectangle bottom) ifTrue: [ y := 0 ].    ^x @ y rightBottom: 0 @ 0</body><body package="GF/ST Base">senseTopRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightTopGrowUnit.    (rectangle extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((rectangle top up: (y := growPoint y)) isBelowEqual: rectangle bottom) ifTrue: [ y := 0 ].    ^0 @ y rightBottom: x @ 0</body><body package="GF/ST Base">setRectangle: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Set the receiver's rectangle to atRectangle.  Note: This rectangle    becomes the receiver's PRIVATE rectangle.  The receiver will change    the point values at will    "    rectangle := aRectangle</body></methods><methods><class-id>Polymorphic.GFRectangleGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">createNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create an instance of the receiver notifying anInterface"    | aGO origin corner |    origin := anInterface cursorPoint.	corner := origin rightAndDown: 1@1.    aGO := self rectangle: (Rectangle leftTop: origin rightBottom: corner).    anInterface drawing add: aGO.    aGO growNotifying: anInterface.    anInterface drawing remove: aGO.     ^aGO</body><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the tool designed to create instances of the receiver"    ^GFCreationTool        icon: (GFTool stockIconFor: 'Rectangle')        cursor: self gfCursorClass crossHair        class: self        name: 'Rectangle'</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the events triggered"    eventsTriggered isNil ifTrue: [        (eventsTriggered := Set new)            addAll: self superclass eventsTriggered;            add: #resize.    ].    ^eventsTriggered</body><body package="GF/ST Base">rectangle: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create a new instance of the receiver"    ^(self new initialize) setRectangle: aRectangle</body></methods><methods><class-id>Polymorphic.Color</class-id> <category>coverage</category><body package="GF/ST Base">coverage"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This is here only to facilitate mapping colors to a mono palette for a mask.	This is taking a simplistic view that everything that is not black, is transparent	(a return value of 1 = not transparent and 0 = transparent)"	^((red == 0) &amp; (blue == 0) &amp; (green == 0))		ifTrue: [ 1 ]		ifFalse: [ 0 ].</body></methods><methods><class-id>Polymorphic.Color class</class-id> <category>instance creation</category><body package="GF/ST Base">black"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Color red: 0 green: 0 blue: 0</body><body package="GF/ST Base">buttonBorder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^SymbolicPaint pushButtonBorder</body><body package="GF/ST Base">buttonFace"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^SymbolicPaint pushButtonBackground</body><body package="GF/ST Base">buttonHilite"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^SymbolicPaint pushButtonHilite</body><body package="GF/ST Base">buttonShadow"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^SymbolicPaint pushButtonShadow</body><body package="GF/ST Base">pickAColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| cv |	cv := Color black asValue.	^(ColorChooser openUsingColorHolder: cv) 		ifTrue: [ cv value ]		ifFalse: [nil ].</body><body package="GF/ST Base">pickAColor: string initialColor: color"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"ignore the parameters for now"	^self pickAColor</body></methods><methods><class-id>Polymorphic.GFTwip</class-id> <category>GF/ST</category><body package="GF/ST Base">initializePen: aPen scale: scale "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Initialize aPen to the receiver's resolution, scaled accordingly"    	| winExt viewExt |	winExt := (1440.0 @ 1440.0 / resolution * 100) rounded.	viewExt := ((Screen default resolution) * scale * 100) rounded.	aPen newScale: (viewExt / winExt).</body><body package="GF/ST Base">printOn: aStream"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    resolution printOn: aStream.    aStream space nextPutAll: ' twips'.</body><body package="GF/ST Base">screenExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the screen extent measured in the receiver's units"    ^(self class gfDisplay pen inchSize * 1440.0 / resolution) rounded</body></methods><methods><class-id>Polymorphic.GFTwip class</class-id> <category>GF/ST</category><body package="GF/ST Base">defaultResolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new resolution: 14400.0 @1440.0 / Screen default resolution</body><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new resolution: 1</body></methods><methods><class-id>Polymorphic.GFDoubleBufferingGraphicsDisplaySystem</class-id> <category>GF/ST</category><body package="GF/ST Base">display: clipRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	|  sPen origin extent adRect scalingFactor |	displayPane topComponent == nil ifTrue: [ ^self ].	(sPen := scratch pen) nonScaledTranslation: displayPane container translation.	sPen paintPreferences: displayPane paintPreferences.	scalingFactor := sPen scale * minFactor.	origin := (clipRect origin truncateTo: scalingFactor) - minFactor.	"minFactor is added in twice because this is dealing with the extent of the rectangle which has already	been offset by one factor of minFactor due to the relocation of the origin"	extent := ((clipRect corner roundUpTo: scalingFactor) + (minFactor / sPen scale max)) - origin.	sPen clippingRectangle: (adRect := origin extent: extent).	sPen gfFillOrigin: origin extent: extent color: displayPane backColor.	interface drawing display: adRect with: sPen.	self updateDisplayPaneOrigin: origin extent: extent.	interface showHandles.</body><body package="GF/ST Base">displayHandles: handles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	pen == nil ifTrue: [^self].	pen nonScaledTranslation: displayPane translation.	pen nonScalingClippingRectangle: displayPane clippingBox.	handles do: [:each |		each displayWith: pen     ].</body><body package="GF/ST Base">displayPen	^pen</body><body package="GF/ST Base">displayViewRectangle: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	pen == nil ifTrue:[ displayPane initGraphics.					  self newScratchExtent: displayPane clippingBox extent ].	^super displayViewRectangle: aRect</body><body package="GF/ST Base">initDisplayPen: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	interface == nil ifTrue: [^self].	pen := GFScalingPen on: aPen medium.	interface drawing coordinateSystem initializePen: pen.	scratch pen paintPreferences: pen paintPreferences.</body><body package="GF/ST Base">initPen: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	interface == nil ifTrue: [^self].	interface drawing coordinateSystem initializePen: aPen.	aPen paintPreferences: displayPane paintPreferences.</body><body package="GF/ST Base">initialize"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved        Private"	super initialize.    self newScratchExtent: 100@100.</body><body package="GF/ST Base">newScratchExtent: extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	scratch release.	scratch := GFPixmap extent: extent + (8@8).	self initPen: scratch pen.	pen == nil ifFalse: [		scratch pen fill: displayPane backColor.		self initDisplayPen: pen. 	].</body><body package="GF/ST Base">pen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^pen</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    super release.    scratch release.	scratch := pen := nil.</body><body package="GF/ST Base">repairDamage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	pen == nil ifTrue: [^self].	scratch isOpen ifFalse: [ ^self reset ].	^super repairDamage</body><body package="GF/ST Base">reset"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	pen == nil ifTrue: [^self].	self newScratchExtent: scratch extent.	self 		initDisplayPen: pen;		initPen: scratch pen.	displayPane updateRectangle; invalidate.</body><body package="GF/ST Base">resizeDisplayPaneRectangle: aRect 	"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	super resizeDisplayPaneRectangle: aRect.	self newScratchExtent: aRect extent</body><body package="GF/ST Base">setDisplayPen: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	pen := aPen.	super setDisplayPen: aPen.</body><body package="GF/ST Base">updateDisplayPaneOrigin: origin extent: extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| sPen |	sPen := scratch pen.	pen nonScaledTranslation: displayPane translation.	pen nonScalingClippingRectangle: displayPane bounds.	sPen scaledDo: [:sPenScale | pen scaledDo: [:penScale | pen fastCopyRectangularAreaOrigin: (origin * sPenScale) rounded extent: (extent * sPenScale) rounded from: sPen]].</body><body package="GF/ST Base">widgetPolicy	^displayPane container widgetPolicy</body><body package="GF/ST Base">workPen	^scratch pen</body></methods><methods><class-id>Polymorphic.GFDoubleBufferingGraphicsDisplaySystem</class-id> <category>uilayout</category><body package="GF/ST Base">subtreeNeedsLayout	pen ifNotNil: #subtreeNeedsLayout</body></methods><methods><class-id>Polymorphic.GFScalingPen</class-id> <category>accessing</category><body package="GF/ST Base">checkScale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	(scaleX = 1.0 and: [ scaleY = 1.0 ]) 		ifTrue: [ scale := false ]		ifFalse: [ scale := true ]</body><body package="GF/ST Base">clipRight"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Create and answer the right edge of my clipping rectangle, or of the	bounds of my display medium if not clipping, in my coordinate system."	^clipOriginX == nil		ifTrue: [medium width - offsetX ]		ifFalse: [clipOriginX + clipWidth - offsetX ]</body><body package="GF/ST Base">intersectClip: aRectangle"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Set the clipping region to the intersection of the current clipping rectangle	with the supplied rectangle."	clipOriginX == nil		ifTrue:			[clipOriginX := (aRectangle left * scaleX + offsetX) floor.			clipOriginY := (aRectangle top * scaleY + offsetY) floor.			clipWidth := (aRectangle width * scaleX) ceiling.			clipHeight := (aRectangle height * scaleY) ceiling]		ifFalse:			[ "Open-coded for speed"			| iox ioy icx icy ccx ccy |			iox := (aRectangle left * scaleX + offsetX) floor.			ioy := (aRectangle top * scaleY + offsetY) floor.			icx := (aRectangle right * scaleX + offsetX) ceiling.			icy := (aRectangle bottom * scaleY + offsetY) ceiling.			ccx := clipOriginX + clipWidth.			ccy := clipOriginY + clipHeight.			iox &gt; clipOriginX ifTrue: [clipOriginX := iox].			ioy &gt; clipOriginY ifTrue: [clipOriginY := ioy].			icx &lt; ccx				ifTrue: [clipWidth := icx - clipOriginX]				ifFalse:	[clipWidth := ccx - clipOriginX].			icy &lt; ccy				ifTrue: [clipHeight := icy - clipOriginY]				ifFalse:	[clipHeight := ccy - clipOriginY]]</body><body package="GF/ST Base">newScale: newScale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	scaleX := newScale asPoint x.	scaleY := newScale asPoint y.	self checkScale.</body><body package="GF/ST Base">nonScaledTranslation: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	offsetX := aPoint x rounded.	offsetY := aPoint y rounded</body><body package="GF/ST Base">nonScalingClippingRectangle: aRectangleOrNil "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Set the clipping region to aRectangleOrNil. If aRectangleOrNil is nil, 	no clipping occurs other than clipping to the bounds of the display 	medium."	aRectangleOrNil isNil		ifTrue: [clipOriginX := clipOriginY := clipWidth := clipHeight := nil]		ifFalse:			[clipOriginX := (aRectangleOrNil left + offsetX) rounded.			clipOriginY := (aRectangleOrNil top + offsetY) rounded.			clipWidth := (aRectangleOrNil width) rounded.			clipHeight := (aRectangleOrNil height) rounded]</body><body package="GF/ST Base">scaleBy: newScale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	super scaleBy: newScale.	(scaleX = 1.0 and: [ scaleY = 1.0 ]) 		ifTrue: [ scale := false ]		ifFalse: [ scale := true ]</body><body package="GF/ST Base">scaling"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^scale</body></methods><methods><class-id>Polymorphic.GFScalingPen</class-id> <category>private-scaling</category><body package="GF/ST Base">displayCharacterOfIndex: characterIndex at: aPoint 	"Display the glyph found at characterIndex in the current font at aPoint."	self scaledDo: 		[:blockScale | 		self 			primDisplayCharacterOfIndex: characterIndex 			at: aPoint * blockScale]</body><body package="GF/ST Base">displayGeneralArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	" Display a wide arc with proper cap styles.	originPoint and extentPoint have integer	coordinates; startAngle and sweepAngle	are floats. "	| cpt rpt points a1 a2 delta pointCount ang |	rpt := extentPoint.	cpt := originPoint * 2 + rpt.	pointCount := extentPoint x + extentPoint y // 6 max: 8.	a1 := (startAngle * 4) rounded.	ang := (sweepAngle * 4) rounded.	ang &lt; 0 ifTrue: [a1 := a1 + ang.  ang := ang negated].	a1 := a1 \\ 1440.	delta := ang min: 1440.	a2 := a1 + delta.	lineWidth &lt;= 1		ifTrue:			[" Just enumerate the arc, and display it as a polyline. "			points := OrderedCollection new: pointCount.			self collectArcRadius: rpt from: a1 to: a2 do:				[:xr :yr | points addLast: (xr + cpt x bitShift: -1) @ (yr + cpt y bitShift: -1)].			self displayPolyline: points asArray]		ifFalse:			[" Accumulate each side of the band separately.			points accumulates the outside of the band			in clockwise order; reversePoints accumulates			the inside in counter-clockwise order. "			| rin rout pf pl rf rl psize |			points := OrderedCollection new: pointCount * 2.			rin := rpt - (lineWidth @ lineWidth).			rout := rpt + ((lineWidth + 1) @ (lineWidth + 1)).			self collectArcRadius: rin from: a1 to: a2 do:				[:xr :yr | points addLast: (xr + cpt x bitShift: -1) @ (yr + cpt y bitShift: -1)].			psize := points size.			self collectArcRadius: rout from: a2 to: a1 do:				[:xr :yr | points addLast: (xr + cpt x bitShift: -1) @ (yr + cpt y bitShift: -1)].			pf := points first.  pl := points at: psize.			rf := points at: psize + 1.  rl := points last.			(delta ~= 1440 and: [capStyle = self class capProjecting])				ifTrue:					[" Adjust the endpoints to create the cap. "					self adjustProjectingCapFrom: rf to: pl.					self adjustProjectingCapFrom: pf to: rl].			points addLast: pf.			super primDisplayPolygon: points asArray at: 0@0.			(delta ~= 1440 and: [capStyle = self class capRound])				ifTrue:					[self displayPrimDotOfDiameter: lineWidth at: (pf + rl // 2).					self displayPrimDotOfDiameter: lineWidth at: (pl + rf // 2)]]</body><body package="GF/ST Base">displayGeneralPolyline: points"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	" Display wide lines, using the appropriate	line width, cap style, and join style. "	| count closed proj poly this next last round poly2 prev |	count := points size.	count = 0 ifTrue: [^self].	this := points first.	last := points last.	" If the path is closed, we use a join rather than two caps. "	closed := this = last.	closed ifFalse:		[capStyle = self class capRound ifTrue:			[self displayPrimDotOfDiameter: lineWidth at: this]].	proj := (capStyle = self class capProjecting and: [closed not]) and: [self scale max &gt; 0.5 ] .	poly := Array new: 4.	1 to: 4 do: [:i | poly at: i put: 0 @ 0].	round := joinStyle = self class joinRound.	round		ifTrue: [poly2 := poly]  "poly and poly2 are never used at the same time"		ifFalse:			[poly2 := Array new: 4.			1 to: 4 do: [:i | poly2 at: i put: 0 @ 0]].	" Remove redundant points at end of polyline. "	[count &gt; 1 and: [(points at: count - 1) = last]]		whileTrue: [count := count - 1].	prev := nil.	2 to: count do: [:i |		next := points at: i.		(self displayWideLineSetup: poly from: this to: next)			ifTrue:				[" Make projecting caps if needed. "				proj ifTrue:					[prev isNil ifTrue: [self adjustProjectingCapFrom: (poly at: 1) to: (poly at: 2)].					i = count ifTrue: [self adjustProjectingCapFrom: (poly at: 3) to: (poly at: 4)]].				round					ifTrue:						[self primDisplayPolygon: poly at: 0@0.						prev == nil ifFalse:							[self displayPrimDotOfDiameter: lineWidth at: this]]					ifFalse:						[prev == nil							ifTrue:								[closed									ifTrue:										[count &gt; i  "i.e., at least 3 points"											ifTrue:												[(self displayWideLineSetup: poly2 from: (points at: count - 1) to: this)													ifTrue:  [self displayWideLineJoinFrom: poly2 to: poly]]]									ifFalse: [super primDisplayPolygon: poly at: 0@0]]							ifFalse: [self displayWideLineJoinFrom: poly2 to: poly]].				prev := poly.				poly := poly2.				poly2 := prev.				prev := this.				this := next]].	closed		ifTrue:			[(round or: [prev isNil and: [capStyle ~= self class capButt]])  "single point"				ifTrue: [self displayPrimDotOfDiameter: lineWidth at: this]]		ifFalse:			[capStyle = self class capRound ifTrue:				[self displayPrimDotOfDiameter: lineWidth at: this]]</body><body package="GF/ST Base">displayString: aString from: startIndex to: endIndex at: aPoint 	"Copyright (C) 1993-1996 Polymorphic Software, Inc. All Rights Reserved"	"Display the substring of aString from startIndex to endIndex. Place 	the left end of the text baseline at aPoint. Use the default font and 	paint."	self scaledDo: 		[:blockScale | 		self font			displayString: aString			from: startIndex			to: endIndex			at: aPoint * blockScale			on: self]</body><body package="GF/ST Base">displayWideLineJoinFrom: poly1 to: poly2"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	" Display an appropriate join at	the point where two wide lines meet.	The incoming line is described	by the polygon poly1 (created by	displayWideLineSetup...);	the outgoing line is described	by the polygon poly2. "	| et1 el1 et2 el2 out1 bpoly |	" The polygon for the line p --&gt; q	is always drawn in clockwise order as	(p+w2), (p-w2), (q-w2), (q+w2).	Start by figuring out which are the	`outside' points at the join: it will	always be the trailing point of one	end-line and the leading point of the other.	Since the polygon is drawn clockwise,	the outside point is always to the	left of the other end-line; point (x,y)	is to the left of the line (x0,y0) --&gt; (x1,y1)	iff (x-x0)*(y1-y0) &gt; (y-y0)*(x1-x0). "	et1 := poly1 at: 3.  el1 := poly1 at: 4.	et2 := poly2 at: 1.  el2 := poly2 at: 2.	(et2 x - et1 x) * (el1 y - et1 y) &gt; ((et2 y - et1 y) * (el1 x - et1 x))		ifTrue: [out1 := el1]		ifFalse: [out1 := et1].	bpoly := Array new: 5.	bpoly at: 2 put: out1.	bpoly at: 4 put: (poly2 at: 3).	bpoly at: 5 put: (poly2 at: 4).	joinStyle = self class joinBevel		ifTrue:  "use bevel join"			[bpoly at: 1 put: et2.			bpoly at: 3 put: el2]		ifFalse:			[| t1 u1 v1 out2 t2 u2 v2 cnum cdenom crit |			" To decide between miter and bevel join,			we first note that the miter limit, M, is defined as			using miter joins only if 1/sin(phi/2) &lt;= M;			what we want is a value T such that we only use			miter joins if tan(phi) &gt;= T (with suitable caveats			when T &lt; 0).  Using the half-angle and angle-sum			formulas, we find that T = sqrt(M*M-1)*2/(M*M-2).			Since the only value of the miter limit that we			currently implement is 10.0, forcing bevels at angles			less than roughly 11 degrees, we simply store			the value of T for M=10.0 in a class variable. "			" To compute the angle between the two lines,			we note that if tan(a)=v1/u1 and tan(b)=v2/u2, then			tan(a-b) = (v1*u2 - u1*v2) / (u1*u2 + v1*v2).			Since what we really want is tan(|a-b|),			we have to take the absolute value of the numerator. "			out1 == el1				ifTrue: [t1 := poly1 at: 1.  out2 := et2.  t2 := poly2 at: 4]				ifFalse: [t1 := poly1 at: 2.  out2 := el2.  t2 := poly2 at: 3].			u1 := out1 x - t1 x.  v1 := out1 y - t1 y.			u2 := out2 x - t2 x.  v2 := out2 y - t2 y.			cnum := (u1 * v2) - (u2 * v1).			cdenom := (v1 * v2) + (u1 * u2).			" We want to use a miter join iff cnum/cdenom &gt;= MiterCheck.			If MiterCheck &gt;= 0, any negative value of cnum/cdenom			uses a miter join; if MiterCheck &lt; 0, we always do the			comparison. "			crit := cnum abs.			cdenom &lt; 0 ifTrue: [crit := crit negated.  cdenom := cdenom negated].			(MiterCheck * cdenom &lt;= crit or: [crit &lt; 0 and: [MiterCheck &gt;= 0]])				ifFalse:  "use bevel join"					[bpoly at: 1 put: et2.					bpoly at: 3 put: el2]				ifTrue:  "use miter join"					[" Compute the intersection of					the two outside edges. "					| num1 num2 cross |					num1 := (v1 * out1 x) - (u1 * out1 y).					num2 := (v2 * out2 x) - (u2 * out2 y).					cross :=						((u1 * num2) - (u2 * num1) + (cnum // 2) // cnum) @						((v1 * num2) - (v2 * num1) + (cnum // 2) // cnum).					out2 = et2						ifTrue: [bpoly at: 3 put: el2.  bpoly at: 1 put: cross]						ifFalse: [bpoly at: 3 put: cross.  bpoly at: 1 put: et2]]].	super primDisplayPolygon: bpoly at: 0@0</body><body package="GF/ST Base">installFont: aFont"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| fontToInstall fontScale oldSize desc |	fontScale := scaleX min: scaleY.	oldSize := (desc := aFont fontDescription) pixelSize.	scale ifTrue: [ fontToInstall := desc pixelSize: (oldSize * fontScale) rounded ] 		ifFalse: [ fontToInstall := aFont ].	fontToInstall installOn: self.	desc pixelSize: oldSize.</body><body package="GF/ST Base">isGFScalingPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^true</body><body package="GF/ST Base">quickDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self gfExecute: [ self quickDisplayText: text at: (aRect origin leftAndDown: (self unscalePoint: self font basePoint)) ] clipRect: aRect</body><body package="GF/ST Base">scalePoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^scale 		ifTrue: [ (scaleX * (pt x)) rounded @ ((scaleY * (pt y)) rounded) ]		ifFalse: [ pt ]</body><body package="GF/ST Base">scalePointCeiling: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^scale 		ifTrue: [ (scaleX * (pt x)) ceiling @ ((scaleY * (pt y)) ceiling) ]		ifFalse: [ pt ]</body><body package="GF/ST Base">scalePointFloor: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^scale 		ifTrue: [ (scaleX * (pt x)) floor @ ((scaleY * (pt y)) floor) ]		ifFalse: [ pt ]</body><body package="GF/ST Base">scaleRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		scale ifFalse: [ ^rect ].	^Rectangle origin: (self scalePoint: rect origin) corner: (self scalePoint: rect corner)</body><body package="GF/ST Base">scaledDo: drawBlock	"drawBlock takes one argument, a scale point, and contains a drawing operation scaled by that point. First we set the pen to be unscaled, then perform the block (which itself scales the draw operation's arguments by the block's scale argument), then set the pen to be scaled again"	| oldScalePoint |		[oldScalePoint := scaleX @ scaleY.		scale := false.		scaleX := 1.		scaleY := 1.		drawBlock value: oldScalePoint]	ensure:		[scale := true.		scaleX := oldScalePoint x.		scaleY := oldScalePoint y]</body><body package="GF/ST Base">unscalePoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^scale 		ifTrue: [ ((pt x) / scaleX) rounded @ (((pt y) / scaleY) rounded) ]		ifFalse: [ pt ]</body><body package="GF/ST Base">unscaleRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		scale ifFalse: [ ^rect ].	^Rectangle origin: (self unscalePoint: rect origin) corner: (self unscalePoint: rect corner)</body></methods><methods><class-id>Polymorphic.GFScalingPen</class-id> <category>displaying-not scaled</category><body package="GF/ST Base">superDisplayRectangle: aRectangle "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display a rectangle. This operation is equivalent to displaying a	polygon with five vertices:  the top-left, top-right, bottom-right,	bottom-left, and top-left of aRectangle.	Use the default paint."	super		primDisplayRectangleOrigin: aRectangle topLeft		extent: aRectangle extent</body></methods><methods><class-id>Polymorphic.GFScalingPen</class-id> <category>initialize-release</category><body package="GF/ST Base">initialize"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self checkScale.	self joinStyle: self class joinRound</body><body package="GF/ST Base">setOffsetFrom: pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	offsetX := pen offsetX.	offsetY := pen offsetY.</body></methods><methods><class-id>Polymorphic.GFScalingPen</class-id> <category>primitives-simple shapes</category><body package="GF/ST Base">primDisplayLineFrom: startPoint to: endPoint "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display a line between startPoint and endPoint.	Use the current line width, cap style, join style, and paint."	scale		ifTrue: [ self scaledDo: [:blockScale | super primDisplayLineFrom: (startPoint* blockScale) rounded to: (endPoint* blockScale) rounded]]		ifFalse: [ super primDisplayLineFrom: startPoint to: endPoint]</body><body package="GF/ST Base">primDisplayPolygon: pointCollection at: aPoint "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Fill the polygon whose vertices are specified by pointCollection, 	translated by aPoint, with the current paint."		scale		ifTrue: [ self scaledDo: [ :blockScale | super primDisplayPolygon: (pointCollection collect: [ :each | (each * blockScale) rounded]) at: (aPoint * blockScale) rounded]] 		ifFalse: [ super primDisplayPolygon: pointCollection at: aPoint ]</body><body package="GF/ST Base">primDisplayPolyline: pointCollection at: aPoint "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display the polyline whose vertices are specified by pointCollection,	translated by aPoint.	If the first and last vertices do not coincide, the polyline is considered	to be open.  The endpoints will be drawn with caps and the	intervening vertices drawn with joins.  If the first and last vertices do	coincide, the polyline is considered to be closed, and all vertices	will be drawn using joins.	Use the current line width, cap style, join style, and paint."		scale		ifTrue: [ self scaledDo: [ :blockScale | super primDisplayPolyline: (pointCollection collect: [ :each |  (each * blockScale) rounded]) at: (aPoint * blockScale) rounded]]		ifFalse: [ super primDisplayPolyline: pointCollection at: aPoint ]</body><body package="GF/ST Base">primDisplayRectangleOrigin: originPoint extent: extentPoint "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display the rectangle with the top left corner extent. Use the 	current paint."	scale		ifTrue: [ self scaledDo: [:blockScale | super primDisplayRectangleOrigin: (originPoint * blockScale) rounded extent: (extentPoint * blockScale) rounded]]		ifFalse: [ super primDisplayRectangleOrigin: originPoint extent: extentPoint]</body><body package="GF/ST Base">primDisplayRectangularBorderOrigin: originPoint extent: extentPoint "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display the rectangular border with the specified top left corner 	and extent. Use the current line width, cap style, join style, and paint."	scale		ifTrue: [ self scaledDo: [:blockScale | super primDisplayRectangularBorderOrigin: (originPoint * blockScale) rounded extent: (extentPoint * blockScale) rounded]]		ifFalse: [ super primDisplayRectangularBorderOrigin: originPoint extent: extentPoint ]</body></methods><methods><class-id>Polymorphic.GFScalingPen</class-id> <category>primitives-curves</category><body package="GF/ST Base">primCopyMaskedArea: aMask from: aGraphicsContext sourceOffset: srcOffsetPoint destinationOffset: destOffsetPoint 	scale 		ifTrue: 			[self scaledDo: 					[:blockScale | 					super 						primCopyMaskedArea: aMask						from: aGraphicsContext						sourceOffset: srcOffsetPoint * blockScale						destinationOffset: destOffsetPoint * blockScale]]		ifFalse: 			[super 				primCopyMaskedArea: aMask				from: aGraphicsContext				sourceOffset: srcOffsetPoint				destinationOffset: destOffsetPoint]</body><body package="GF/ST Base">primDisplayArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an elliptical arc defined by the bounding rectangle of the 	ellipse and by the starting angle and angle of sweep for the arc. "	scale		ifTrue: [ self scaledDo: [ :blockScale | super primDisplayArcBBoxOrigin: (originPoint * blockScale) rounded extent: (extentPoint * blockScale) rounded startAngle: startAngle sweepAngle: sweepAngle ]]		ifFalse: [ super primDisplayArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle  ]</body><body package="GF/ST Base">primDisplayWedgeBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display an elliptical wedge bounded by a zero-width arc and the 	zero-width line segments from the center of the ellipse to the ends 	of the arc. "	scale		ifTrue: [ self scaledDo: [ :blockScale | super primDisplayWedgeBBoxOrigin: (originPoint * blockScale) rounded extent: (extentPoint * blockScale) rounded startAngle: startAngle sweepAngle: sweepAngle]]		ifFalse: [ super primDisplayWedgeBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle  ]</body></methods><methods><class-id>Polymorphic.GFScalingPen</class-id> <category>uilayout</category><body package="GF/ST Base">subtreeNeedsLayout	medium ifNotNil: #subtreeNeedsLayout</body></methods><methods><class-id>Polymorphic.GFScalingPen class</class-id> <category>instance creation</category><body package="GF/ST Base">on: medium	^(super on: medium) checkScale</body></methods><methods><class-id>Polymorphic.GFScrollingTool class</class-id> <category>GF/ST</category><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self icon: self flatHand cursor: self gfCursorClass upDown name: 'Scroll'</body></methods><methods><class-id>Polymorphic.GFQuadTreeElement</class-id> <category>GF/ST</category><body package="GF/ST Base">add: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO to the receiver QuadTree."    | aRect |    aRect := aGO displayBox.    self outside: aRect.    ^self add: aGO boundedBy: aRect</body><body package="GF/ST Base">add: newGO after: oldGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO to the receiver QuadTree."    newGO addAfter: oldGO.    self add: newGO</body><body package="GF/ST Base">add: newFigure before: oldFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aFigure from the receiver QuadTree."    newFigure addBefore: oldFigure.    self add: newFigure</body><body package="GF/ST Base">add: aGO boundedBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Adds aGO to the quadtree region. If the region is divided, recursively call this method     until the end of the tree is reached."    (self isDivided)        ifTrue: [ "If the region is divided"            (aRectangle intersects: upperL) ifTrue: [upperL add: aGO boundedBy: aRectangle].            (aRectangle intersects: upperR) ifTrue: [upperR add: aGO boundedBy: aRectangle].            (aRectangle intersects: lowerL) ifTrue: [lowerL add: aGO boundedBy: aRectangle].            (aRectangle intersects: lowerR) ifTrue: [lowerR add: aGO boundedBy: aRectangle]        ]        ifFalse: [    "If it is not divided"            ((leafData size &lt;= MaxElements) or: [extent &lt;= MinExtent])                ifTrue: [leafData add: aGO]                ifFalse: [                    self divide.                    leafData do: [:each | self add: each boundedBy: each displayBox].                    leafData := (Set new: MaxElements).                    self add: aGO boundedBy: aRectangle                ]        ]</body><body package="GF/ST Base">add: aGO rectangle: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO from the receiver QuadTree."    self outside: aRectangle.    ^self add: aGO boundedBy: aRectangle</body><body package="GF/ST Base">addFirst: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO from the receiver QuadTree."    aGO moveToLast.    self add: aGO</body><body package="GF/ST Base">asOrderedCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | coll |    coll := Set new: 100.    self do: [:each | coll add: each].    ^coll asOrderedCollection</body><body package="GF/ST Base">bringToFront: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO from the receiver QuadTree."    | rect |    self remove: aGO rectangle: (rect := aGO damaged).    aGO moveToLast.    self add: aGO rectangle: rect.</body><body package="GF/ST Base">conflict: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Returns a collection of images whose boundingBoxes are in conflict with aRect in the receiver."    | returnCol |    self conflictsWith: aRect using: (returnCol := Set new: 10).    ^returnCol asSortedCollection</body><body package="GF/ST Base">conflictorsOf: aRect using: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Add leaf nodes that conflict with aRect to aCollection"     leafData do: [:checkLeaf |            (checkLeaf intersects: aRect)                ifTrue: [ aCollection add: checkLeaf ]].</body><body package="GF/ST Base">conflictsWith: aRect using: aSet"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Returns a collection of Leaves with which aRect is in 	conflict in the receiver GFQuadTreeElement."	(aRect contains: self)		ifTrue: [ ^self do: [ :each | aSet add: each ] ].     (self isDivided)        ifTrue: [            (aRect intersects: upperL) ifTrue: [upperL conflictsWith: aRect using: aSet].            (aRect intersects: upperR) ifTrue: [upperR conflictsWith: aRect using: aSet].            (aRect intersects: lowerL) ifTrue: [lowerL conflictsWith: aRect using: aSet].            (aRect intersects: lowerR) ifTrue: [lowerR conflictsWith: aRect using: aSet]]        ifFalse: [self conflictorsOf: aRect using: aSet].</body><body package="GF/ST Base">contents"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Returns a collection of all images in the receiver GFQuadTreeElement."    | returnCol |    returnCol := Set new: 100.    self do: [ :eachImage | returnCol add: eachImage].    ^returnCol</body><body package="GF/ST Base">countTrees: numTrees"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Counts the total number of trees in the receiver, increments numTrees for the receiver plus any subtrees, and returns this value."    | myTrees |    myTrees := numTrees.    self isDivided ifTrue: [            myTrees := myTrees + 1.            myTrees := upperL countTrees: myTrees.            myTrees := upperR countTrees: myTrees.            myTrees := lowerL countTrees: myTrees.            myTrees := lowerR countTrees: myTrees.    ].    ^myTrees</body><body package="GF/ST Base">detect: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform a detect on the leaf nodes in the quadTree"    |r|    (self isDivided) ifTrue: [        (r := upperL detect: aBlock) == nil ifFalse: [^r].        (r := upperR detect: aBlock) == nil ifFalse: [^r].        (r := lowerL detect: aBlock) == nil ifFalse: [^r].        (r := lowerR detect: aBlock) == nil ifFalse: [^r].        ^nil    ].    leafData do: [:leaf | (aBlock value: leaf) ifTrue: [^leaf]].    ^nil.</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "display the quadtree quadrants and leaves with aPen"    | aSet |    "display the leaves"    aSet := Set new.    self leaves: aSet.    aPen black.    aSet do: [:aGO | aPen drawRectangle: aGO displayBox].    "display the quadrants"    aPen setForeColorTo: Color red.    aPen setLineWidthTo: 1.    (self quadrants: OrderedCollection new) do: [:aRect |        aPen drawRectangle: aRect    ].</body><body package="GF/ST Base">divide"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Divides the receiver QuadTree into its four QuadTree 	branches.  The quadrants are overlapped by one pixel to account 	for the Rectangle&gt;&gt;containsPoints: anomaly of excluding the right 	and lower edges."    upperL := (GFQuadTreeElement origin: self origin corner: self center).    upperR := (GFQuadTreeElement origin: self center x @ self top corner: self corner x @ self center y).    lowerL := (GFQuadTreeElement origin: self left @ self center y corner: self center x @ self corner y).    lowerR := (GFQuadTreeElement origin: self center corner: self corner)</body><body package="GF/ST Base">do: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform a 'do' on the leaf nodes in the quadTree"    (self isDivided)        ifTrue: [            upperL do: aBlock.            upperR do: aBlock.            lowerL do: aBlock.            lowerR do: aBlock        ]        ifFalse: [leafData do: [:leaf | aBlock value: leaf]].</body><body package="GF/ST Base">enlarge"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Enlarge the receiver QuadTree by a factor of four to 	become newQuadTree."    | subTree |    (subTree := GFQuadTreeElement origin: (0@0) corner: self corner)        upperL: upperL        lowerL: lowerL        upperR: upperR        lowerR: lowerR        leafData: leafData.    "double my size"    self rightBottom: (self corner + self extent).    self initialize.    self divide.    upperL := subTree.</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^extent</body><body package="GF/ST Base">extent: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    extent := aPoint</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Initialize the internal state of the quadtree."    leafData := (Set new: 25).    extent := super extent.    upperL := nil.    lowerL := nil.    upperR := nil.    lowerR := nil.</body><body package="GF/ST Base">isDivided"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Returns true if the receiver GFQuadTreeElement has 	been divided into GFQuadTreeElement branches, else returns false."    ^upperL ~~ nil</body><body package="GF/ST Base">leaves: aSet"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - collect the leaves of the quadtree"    self isDivided        ifTrue: [            upperL leaves: aSet.            upperR leaves: aSet.            lowerL leaves: aSet.            lowerR leaves: aSet        ]        ifFalse: [aSet addAll: leafData]</body><body package="GF/ST Base">outside: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Checks the receiver QuadTreeElement and expand it to 	contain aRectangle if aRectangle lies outside the receiver."    ((aRectangle corner x &lt;= corner x) and: [        aRectangle corner y &lt;= corner y]) ifFalse: [            self enlarge.            self outside: aRectangle    ]</body><body package="GF/ST Base">pointContainer: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Returns the first Leaf which contains aPoint in the receiver GFQuadTreeElement."    self isDivided ifTrue: [        (upperL containsPoint: aPoint) ifTrue: [^(upperL pointContainer: aPoint)].        (upperR containsPoint: aPoint) ifTrue: [^(upperR pointContainer: aPoint)].        (lowerL containsPoint: aPoint) ifTrue: [^(lowerL pointContainer: aPoint)].        (lowerR containsPoint: aPoint) ifTrue: [^(lowerR pointContainer: aPoint)].        ^nil    ].    leafData asSortedCollection reverseDo: [:each |        (each containsPoint: aPoint) ifTrue: [^each].    ].    ^nil</body><body package="GF/ST Base">pointContainers: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Returns the Leaf which contains aPoint in the receiver GFQuadTreeElement."    self isDivided        ifTrue: [            (upperL containsPoint: aPoint) ifTrue: [^(upperL pointContainers: aPoint)].            (upperR containsPoint: aPoint) ifTrue: [^(upperR pointContainers: aPoint)].            (lowerL containsPoint: aPoint) ifTrue: [^(lowerL pointContainers: aPoint)].            (lowerR containsPoint: aPoint) ifTrue: [^(lowerR pointContainers: aPoint)].            ^OrderedCollection new: 0        ]        ifFalse: [^leafData select: [ :checkLeaf | checkLeaf containsPoint: aPoint]].</body><body package="GF/ST Base">quadrants: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - collect the boundaries of the quadrants in the quadtree"    aCollection add: (self origin extent: extent).    self isDivided ifTrue: [        upperL quadrants: aCollection.        upperR quadrants: aCollection.        lowerL quadrants: aCollection.        lowerR quadrants: aCollection    ].    ^aCollection</body><body package="GF/ST Base">remove: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Removes aGO from the receiver QuadTree."    ^self remove: aGO boundedBy: aGO displayBox</body><body package="GF/ST Base">remove: aLeaf boundedBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Removes aLeaf from the receiver QuadTree."     self isDivided        ifTrue: [            (aRectangle intersects: upperL) ifTrue: [                upperL remove: aLeaf boundedBy: aRectangle.            ].            (aRectangle intersects: upperR) ifTrue: [                upperR remove: aLeaf boundedBy: aRectangle.            ].            (aRectangle intersects: lowerL) ifTrue: [                lowerL remove: aLeaf boundedBy: aRectangle.            ].            (aRectangle intersects: lowerR) ifTrue: [                lowerR remove: aLeaf boundedBy: aRectangle.            ]        ]        ifFalse: [leafData remove: aLeaf ifAbsent: [nil]].</body><body package="GF/ST Base">remove: aGO ifAbsent: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | removed |    "Removes aGO from the receiver QuadTree."    aGO unlink.    ^(removed := self remove: aGO boundedBy: aGO displayBox) isNil        ifTrue: [ aBlock value ]        ifFalse: [ removed ]</body><body package="GF/ST Base">remove: aGO rectangle: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Removes aGO from the receiver QuadTree."    ^self remove: aGO boundedBy: aRectangle</body><body package="GF/ST Base">sendToBack: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO from the receiver QuadTree."    | rect |    self remove: aGO rectangle: (rect := aGO damaged).    aGO moveToFirst.    self add: aGO rectangle: rect.</body><body package="GF/ST Base">size"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Returns the number of Leaves in the receiver GFQuadTreeElement."    | count |    count := 0.    (self isDivided)        ifTrue: [            count := count +  upperL size.            count := count +  upperR size.            count := count +  lowerL size.            count := count +  lowerR size        ]        ifFalse: [count := leafData size].    ^count</body><body package="GF/ST Base">upperL: ul lowerL: ll upperR: ur lowerR: lr leafData: ld"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    upperL := ul.    lowerL := ll.    upperR := ur.    lowerR := lr.    leafData := ld.</body></methods><methods><class-id>Polymorphic.GFQuadTreeElement class</class-id> <category>GF/ST</category><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Initializes the class variables of the receiver."    "GFQuadTreeElement initialize"    MaxElements := 25.    MinExtent := 64@64.</body><body package="GF/ST Base">newTree"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Creates an instance of the receiver of minimum size and origin of 0@0."    ^(self origin: 0@0 extent: 512@512) initialize</body><body package="GF/ST Base">origin: originPoint corner: cornerPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a GFQuadTreeElement with origin and corner points described by originPoint and cornerPoint."    ^(super origin: originPoint corner: cornerPoint) initialize.</body></methods><methods><class-id>Polymorphic.GFThousandthInch</class-id> <category>GF/ST</category><body package="GF/ST Base">initializePen: aPen scale: scale "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Initialize aPen to the receiver's resolution, scaled accordingly    "	| winExt viewExt |	winExt := (1000.0 @ 1000.0 / resolution * 100) rounded.	viewExt := ((Screen default resolution) * scale * 100) rounded.	aPen newScale: (viewExt / winExt).</body><body package="GF/ST Base">printOn: aStream"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    resolution printOn: aStream.    aStream space nextPutAll: ' thousands of an inch'.</body><body package="GF/ST Base">screenExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the screen extent measured in the receiver's units"	"hard coded size for now for porting purposes"    ^((12@9.5) * 1000.0 / resolution) rounded</body></methods><methods><class-id>Polymorphic.GFThousandthInch class</class-id> <category>GF/ST</category><body package="GF/ST Base">defaultResolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new resolution: 1000.0 @1000.0 / Screen default resolution</body><body package="GF/ST Base">highResolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new resolution: 1@1</body><body package="GF/ST Base">lowResolution"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new resolution: 10@10</body></methods><methods><class-id>Polymorphic.GFGoEndPlug</class-id> <category>copying</category><body package="GF/ST Base">postCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	go := go copy</body></methods><methods><class-id>Polymorphic.GFGoEndPlug</class-id> <category>displaying</category><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display a mask for the receiver.  The mask is black and white, where	 black represents the opaque area, and white represents the transparent	 area	"	go displayShapeWith: aPen at: self displayPoint + self displayOffset</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	go displayWith: aPen at: self displayPoint + self displayOffset</body></methods><methods><class-id>Polymorphic.GFGoEndPlug</class-id> <category>accessing</category><body package="GF/ST Base">displayPoint: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	super displayPoint: aPoint.	go == nil ifFalse: [ go translateTo: (aPoint  - self displayOffset)]</body><body package="GF/ST Base">extent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^go extent</body><body package="GF/ST Base">go"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^go</body><body package="GF/ST Base">setGO: aGo"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	go notNil ifTrue: [ go release ].	go := aGo.</body></methods><methods><class-id>Polymorphic.GFGoEndPlug class</class-id> <category>instance creation</category><body package="GF/ST Base">fromGO: aGO"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self new setGO: aGO</body></methods><methods><class-id>Polymorphic.GFSelectionTrackHandle</class-id> <category>GF/ST</category><body package="GF/ST Base">sense: deltaPoint for: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"        ^sense isNil                ifTrue: [deltaPoint]                ifFalse: [sense evaluateIfNoTarget: anObject with: deltaPoint]</body><body package="GF/ST Base">storeMementoForInterface: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    | gos mems mem |    (anInterface isNil or: [ mementoType isNil ]) ifTrue: [ ^self ].    mems := (gos := anInterface selections) collect: [ :each | each perform: mementoType ].    mem := GFMemento originator: self.    1 to: mems size do: [ :i |          mem            addActionReceiver: (gos at: i)                   selector: #restoreFrom:                  with: (mems at: i)    ].    locator receiver storeMemento: mem for: self</body><body package="GF/ST Base">trackMouse: anInterface"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | oldPoint selections delta |    selections := anInterface selections.    oldPoint := anInterface cursorPointSnapped: snapToGrid limit: limit.    anInterface        trackMouse: [:newPoint |            delta := newPoint - oldPoint.            delta isZero ifFalse:			[selections do: [:each |                        ((sense isNil or: [sense isAppropriateActionFor: each ])							and: [ change isAppropriateActionFor: each ])                       			ifTrue: [ self change: each by: (self sense: delta for: each)]                        ].	            scrollFlag ifTrue: [ oldPoint := newPoint ].      	         anInterface repairDamage ]]        uponRelease: nil        until: anInterface display buttonUpCheckBlock        scroll: scrollFlag        preScrollDo: nil        snapToGrid: snapToGrid        limit: limit.</body></methods><methods><class-id>Polymorphic.GFAbsoluteTrackHandle</class-id> <category>GF/ST</category><body package="GF/ST Base">trackMouse: anInterface"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | selections oldPoint |    selections := anInterface selections.    oldPoint := anInterface cursorPointSnapped: snapToGrid limit: limit.    anInterface trackMouse: [:newPoint |        selections do: [:each |                    (sense isNil or: [sense isAppropriateActionFor: each])                        ifTrue: [ self change: each by: (self sense: newPoint for: each)]                    ].        anInterface repairDamage    ]  scroll: scrollFlag.</body></methods><methods><class-id>Polymorphic.GFCategory</class-id> <category>GF/ST</category><body package="GF/ST Base">addTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Add a tool to the receiver"	tools add: aTool.</body><body package="GF/ST Base">allToolsDo: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Evaluate aBlock with all the tools in the receiver"	1 to: tools size do: [:i |		aBlock value: (tools at: i)	].</body><body package="GF/ST Base">asBitmap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^icon</body><body package="GF/ST Base">colorChange"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"</body><body package="GF/ST Base">defaultTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	defaultTool == nil ifTrue: [^tools first].	^defaultTool</body><body package="GF/ST Base">defaultTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	(tools includes: aTool) ifFalse: [tools add: aTool].	defaultTool := aTool.</body><body package="GF/ST Base">icon"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^icon</body><body package="GF/ST Base">includesTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^tools includes: aTool</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	tools := OrderedCollection new.</body><body package="GF/ST Base">name"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^name</body><body package="GF/ST Base">removeTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^tools remove: aTool ifAbsent: []</body><body package="GF/ST Base">setIcon: anIcon"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	icon := anIcon.</body><body package="GF/ST Base">setIcon: anIcon name: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	icon := anIcon.	name := aString.</body><body package="GF/ST Base">setName: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	name := aString</body><body package="GF/ST Base">tools"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^tools</body></methods><methods><class-id>Polymorphic.GFCategory class</class-id> <category>GF/ST</category><body package="GF/ST Base">icon: anImage name: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new setIcon: anImage name: aString</body><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^super new initialize</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>displaying</category><body package="GF/ST Base">display"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    ^display</body><body package="GF/ST Base">displayAll"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display everything"    display == nil ifTrue: [^self].    display displayAll</body><body package="GF/ST Base">displayGrid: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Tell the drawing to display the grid based on aBoolean"    drawing displayGrid: aBoolean.    self displayAll.</body><body package="GF/ST Base">displayHandlesInRect: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the handles to be displayed that intersect	aRect"    (drawing == nil or: [ hideHandles &gt; 0 ]) ifTrue: [^handles species new].    ^handles select: [:each | each displayBox intersects: aRect]</body><body package="GF/ST Base">displayObject: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display aGo"    aGO damaged.    self redraw</body><body package="GF/ST Base">displayPane"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the physical pane used to display the drawing"    ^display displayPane</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the drawing with aPen"    [self hideHandles.    drawing displayWith: aPen.]    ensure: [ self unhideHandles ]</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>control</category><body package="GF/ST Base">button1DoubleClick: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Left button has been double clicked."    | tool |    (tool := self activeTool) == nil ifTrue: [        ^self defaultButton1DoubleClick: aPoint    ].    ^tool button1DoubleClick: aPoint.</body><body package="GF/ST Base">button1Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Left button has been pressed down."    | tool |    (tool := self activeTool) == nil ifTrue: [        ^self defaultButton1Down: aPoint    ].    ^tool button1Down: aPoint.</body><body package="GF/ST Base">button1DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Left button and shift key are both down"    | tool |    (tool := self activeTool) == nil ifTrue: [        ^self defaultButton1DownShift: aPoint    ].    ^tool button1DownShift: aPoint.</body><body package="GF/ST Base">button2DoubleClick: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Right button has been double clicked."    | tool |    (tool := self activeTool) == nil ifTrue: [        ^self defaultButton2DoubleClick: aPoint    ].    ^tool button2DoubleClick: aPoint.</body><body package="GF/ST Base">button2Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Right button has been pressed down."    | tool |    (tool := self activeTool) == nil ifTrue: [        ^self defaultButton2Down: aPoint    ].    ^tool button2Down: aPoint.</body><body package="GF/ST Base">button2DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Right button and shift key are both down"    | tool |    (tool := self activeTool) == nil ifTrue: [        ^self defaultButton2DownShift: aPoint    ].    ^tool button2DownShift: aPoint.</body><body package="GF/ST Base">defaultButton1DoubleClick: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Left button has been double clicked.     Default action is to do nothing.    "</body><body package="GF/ST Base">defaultButton1Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Left button has been pressed down.     Default action is to do nothing.    "</body><body package="GF/ST Base">defaultButton1DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Left button and shift key are both down     Default action is to do nothing.    "</body><body package="GF/ST Base">defaultButton2DoubleClick: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Left button has been double clicked.     Default action is to do nothing.    "</body><body package="GF/ST Base">defaultButton2Down: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Right button has been pressed down.     Default action is to do nothing.    "</body><body package="GF/ST Base">defaultButton2DownShift: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Right button and shift key are both down     Default action is to do nothing.    "</body><body package="GF/ST Base">protectDialogDuring: aBlock 	"Temporarily revise the widget tracker control block to ensure any dialog opened in aBlock follows a select button release.  This prevents a dialog from consuming a release event that the widget tracker must detect to ungrab mouse events"	| paneController formerControlBlock |	paneController := self display displayPane controller.	formerControlBlock := paneController controlBlock.	paneController sensor redButtonPressed 		ifTrue: 			[paneController controlBlock: 					[:point :button | 					button == #wentUp 						ifTrue: [aBlock ensure: [paneController controlBlock: formerControlBlock]]						ifFalse: [formerControlBlock value: point value: button]]]		ifFalse: [aBlock value]</body><body package="GF/ST Base">setDrawingExtent: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	drawing drawingExtent: aPoint.	display reset.</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>GF/ST</category><body package="GF/ST Base">activeTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the active tool of the interface"    ^palette == nil        ifTrue: [ nil ]        ifFalse: [ palette activeTool ]</body><body package="GF/ST Base">bringToFront: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Bring the graphic object to the foreground.  Display the result"    aGO container lastGO == aGO ifTrue: [ ^self ].    self storeMemento: aGO positionMemento  for: aGO.    aGO damaged.    aGO moveToLast.    self redraw</body><body package="GF/ST Base">captureCursorPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	display captureCursorPoint</body><body package="GF/ST Base">checkConnector: connector forConnectionIn: cutCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    ^((cutCollection includes: connector startObject)       or: [ cutCollection includes: connector stopObject ])            or: [ (cutCollection detect: [ :each | each isContainerGO                                                                            ifTrue: [ self checkConnector: connector forConnectionIn: each graphicObjects ]                                                                            ifFalse: [ false ]]                                            ifNone: [nil]) notNil]</body><body package="GF/ST Base">clearObject: aGO while: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Update aGO during the evaluation of aBlock"    "Handles must be hidden"    self hideHandlesWhile: [        aGO damageDuring: aBlock.    ].    self repairDamage</body><body package="GF/ST Base">close: aPane"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    self release.    ^nil</body><body package="GF/ST Base">compose"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Compose all the selected graphicObjects into a GFCompositeGO."    | aCollection aCGO mem |    aCollection := self sortedSelections.    aCollection isEmpty ifTrue: [^self].    (mem := GFMemento originator: self)        addActionSelector: #restoreFrom:             with: (self cutMementoFor: aCollection).    self noSelections.    aCollection := aCollection select: [ :each | each isConnectionGO not ].    drawing removeAll: aCollection.    aCGO := GFCompositeGO graphicObjects: aCollection.    drawing add: aCGO.    aCGO damaged.    self repairDamage.    self selection: aCGO.    mem        addActionSelector: #removeHandlesFor: with: aCGO;           addActionSelector: #removeGO: with: aCGO.    self storeMemento: mem for: self.</body><body package="GF/ST Base">compose: aCollection in: aComposite"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Compose aCollection into aComposite."    | newCollection aCGO state |    aCollection isEmpty ifTrue: [^self].    newCollection := aCollection select: [ :each | each isConnectionGO not ].    drawing removeAll: newCollection.    aCGO := aComposite setGOs: newCollection visibleArea: aComposite visibleArea.    drawing add: aCGO.    aCGO damageDuring: [].    self repairDamage.</body><body package="GF/ST Base">connectorsUsing: go"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the connectors using a go"    | connectionCollection goArray |    connectionCollection := OrderedCollection new.    goArray := Array with: go.    "The following checks to see if a connectionGO is connected to one of the     objects about to be cut, if it is, it should be added to the collection of     objects to be cut, it should also be included in the collection for the cut     memento"    drawing graphicObjects        do: [ :each |                (((each isConnectionGO)                    and: [ (connectionCollection includes: each) not ])                        and: [ self checkConnector: each forConnectionIn: goArray] )                                                ifTrue: [ connectionCollection add: each ]].    ^connectionCollection</body><body package="GF/ST Base">controlDown"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^display controlDown</body><body package="GF/ST Base">copiesFromSource: source"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create a collection of GOs that are copies of GOs in the source collection"    | newFigures mem newGO connections figures final keys etCopy newValue |		connections := IdentityDictionary new.	figures := IdentityDictionary new: source size.	final := OrderedCollection new: source size.	source 		do: [ :each | 					newGO := each copy.					final addLast: newGO.					each isConnectionGO 						ifTrue: [ connections at: each put: newGO].					figures at: each put: newGO ].	"If one of the the connections connects to an object not in the 	source, remove it from the connections and figures list"	connections copy keysDo: [ :key |			key connectedObjects do: [ :each | 				(figures includesKey: each) 						ifFalse: [ final remove: (figures at: key ifAbsent: [ nil ]) ifAbsent: [nil].															connections removeKey: key ifAbsent: [nil].															figures removeKey: key ifAbsent: [nil]. ]]].	figures keysAndValuesDo: [ :go1 :go2 | 		go2 privateSetEventTable: (etCopy := go1 eventTableCopy).		etCopy == nil ifFalse: [			go2 eventTable keysAndValuesDo: [ :key :value |				newValue := value copyUsing: figures.				newValue notNil 					ifTrue: [ go2 eventTable at: key put: newValue  ]					ifFalse: [ go2 eventTable removeKey: key ]]]].	^final</body><body package="GF/ST Base">copy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    self copyAll: self sortedSelections.</body><body package="GF/ST Base">copyAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | anArray aRectangle |    palette activeTool canCutCopyPaste ifTrue: [^palette activeTool copy].    anArray := aCollection asArray.    anArray isEmpty ifTrue: [^self].    aRectangle := anArray                                inject: anArray first displayBox                                into: [:sum :each | sum merge: each displayBox].	anArray := self copiesFromSource: anArray.	CopyBuffer :=		anArray collect: [:each |			each basicTranslateBy: 0@0 - aRectangle origin		]</body><body package="GF/ST Base">cursorAt: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the cursor appropriate at aPoint"    ^palette notNil ifTrue: [ palette cursorAt: aPoint ]</body><body package="GF/ST Base">cursorPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^display cursorPoint</body><body package="GF/ST Base">cursorPointSnapped: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap the cursor point to the grid if snap and limit it to the extent if limit"    ^display cursorPointSnapped: snap limit: limit</body><body package="GF/ST Base">cut"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Cut the selected GOs from the drawing"    | cutCollection |    palette activeTool canCutCopyPaste ifTrue: [^palette activeTool cut].    cutCollection := OrderedCollection new.    cutCollection addAll: self selections.    "The following checks to see if a connectionGO is connected to one of the     objects about to be cut, if it is, it should be added to the collection of     objects to be cut, it should also be included in the collection for the cut     memento"    drawing graphicObjects do: [ :each |        (((each isConnectionGO)            and: [ (cutCollection includes: each) not ])                 and: [ self checkConnector: each forConnectionIn: cutCollection] )            ifTrue: [ cutCollection add: each ]    ].    self storeMemento: (self cutMementoFor: cutCollection) for: self.	"hideHandles should always either be balenced with an #unhideHandles	method or a #noSelections method so that the hideHandles count is 	maintained."	self hideHandles.    cutCollection do: [ :each | each hasHostWidget ifTrue: [ each removeHostWidget]].    self copyAll: cutCollection.    self removeAllGOs: cutCollection.    self noSelections.</body><body package="GF/ST Base">cutMementoFor: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | mem |    mem := GFMemento originator: self.    aCollection do: [ :each |            mem                addActionReceiver: each                    selector: #restoreFrom:                    with: each positionMemento.    ].    mem        addActionSelector: #quietlyAddAll:            with: aCollection;        addActionSelector: #repairDamage.    ^mem</body><body package="GF/ST Base">damageRegion: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Record aRect as a damaged area of the drawing"    display == nil ifTrue: [^self].    display damageRegion: aRect.</body><body package="GF/ST Base">decompose"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Decompose the selected composite in the drawing into its individual     graphic objects    "    | aCollection mem |    mem := GFMemento originator: self.    aCollection := self selections.    aCollection copy do: [ :each | each isCompositeGO ifFalse: [ aCollection remove: each ]].    aCollection isEmpty ifTrue: [^self].    self noSelections.    self selections: (        aCollection inject: Set new into: [:sum :each |            each                hideVisibleAreaIndicator;                damaged.           mem                addActionSelector: #compose:in:                    with: each graphicObjects copy                    with: each.            each graphicObjects reverseDo: [:aGO |                mem                    addActionSelector: #removeHandlesFor:                           with: aGO.                drawing add: aGO.                each insert: aGO.                aGO                    removeDependent: each;                    damaged.            ].            each unlink.            drawing remove: each.            sum addAll: each graphicObjects.            each release.            sum        ]    ).    self storeMemento: mem for: self.</body><body package="GF/ST Base">disableMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Disable the menu of the drawing"    drawing notNil ifTrue: [ drawing when: #getMenu send: #noMenu to: self ].</body><body package="GF/ST Base">doButton1DragDrop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^display doButton1DragDrop</body><body package="GF/ST Base">drawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^drawing</body><body package="GF/ST Base">drawingExtent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^drawing drawingExtent</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^drawing extent</body><body package="GF/ST Base">firstGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the bottom go of the drawing"    ^drawing firstGO</body><body package="GF/ST Base">firstGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the bottom go of the drawing"    drawing firstGO: aGO.</body><body package="GF/ST Base">fixedScaleMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	^Menu new		addItemLabel: '25%' value: (MessageSend receiver: self selector: #scale: argument: 25);		addItemLabel: '50%' value: (MessageSend receiver: self selector: #scale: argument: 50);		addItemLabel: '75%' value: (MessageSend receiver: self selector: #scale: argument: 75);		addItemLabel: '100%' value: (MessageSend receiver: self selector: #scale: argument: 100);		addItemLabel: '125%' value: (MessageSend receiver: self selector: #scale: argument: 125);		addItemLabel: '150%' value: (MessageSend receiver: self selector: #scale: argument: 150);		addItemLabel: '200%' value: (MessageSend receiver: self selector: #scale: argument: 200);		yourself</body><body package="GF/ST Base">graphicObjectAt: selectionPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic object under the selectionPoint"    (drawing == nil  or: [ selectionPoint == nil ]) ifTrue: [^nil].    ^drawing graphicObjectAt: selectionPoint ifAbsent: [nil]</body><body package="GF/ST Base">graphicObjectAtCursor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic object under the cursor"    ^self graphicObjectAt: self cursorPoint</body><body package="GF/ST Base">graphicObjectsIn: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic objects contained by aRectangle"    ^drawing graphicObjectsIn: aRectangle</body><body package="GF/ST Base">graphicallyInspect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	#{Polymorphic.PsiVisualInspector} 		ifDefinedDo: 			[:psiVisualInspector|			|theInspector|			theInspector := psiVisualInspector open.			(self class gfMessageClass				receiver: [self selections do: [:each | theInspector addObject: each]]		   		selector: #value ) performDeferred]</body><body package="GF/ST Base">grid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the grid used by the drawing"    ^drawing grid</body><body package="GF/ST Base">gridMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| menu |	menu := (Menu new)		addItemLabel: 'Use Grid' value: (MessageSend receiver: self selector: #toggleUseGrid);		addItemLabel: 'Snap Selections' value: (MessageSend receiver: self selector: #snapSelectionsToGrid);		addItemLabel: 'Display Grid' value: (MessageSend receiver: self selector: #toggleDisplayGrid);		addItemLabel: 'Set Grid Size...' value: (MessageSend receiver: self selector: #setGridSize);		addItemLabel: 'Grid Color...' value: (MessageSend receiver: self selector: #setGridColor).	(menu someMenuItemLabeled: 'Use Grid') indication: [self drawing usesGrid ].	(menu someMenuItemLabeled: 'Display Grid') indication: [self drawing displayGrid ].	^menu</body><body package="GF/ST Base">group"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Group the selected graphic objects into a group figure"    | aCollection aGroup mem |    aCollection := self sortedSelections.    aCollection isEmpty ifTrue: [^self].       (mem := GFMemento originator: self)          addActionSelector: #restoreFrom:              with: (self cutMementoFor: aCollection).    self noSelections.    aCollection := aCollection select: [ :each | each isConnectionGO not ].    drawing removeAll: aCollection.    aGroup := GFGroupGO graphicObjects: aCollection asOrderedCollection reversed.    drawing add: aGroup.    aGroup damaged.    self repairDamage.    self selection: aGroup.       mem        addActionSelector: #removeHandlesFor:            with: aGroup;        addActionSelector: #removeGO:            with: aGroup.    self storeMemento: mem for: self.</body><body package="GF/ST Base">group: aCollection in: aGroup"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Group aCollection of graphic objects into aGroup"    | newCollection |    aCollection isEmpty ifTrue: [^self].    newCollection := aCollection select: [ :each | each isConnectionGO not ].    drawing removeAll: newCollection.    aGroup setGraphicObjects: newCollection.    drawing add: aGroup.    aGroup damageDuring: [].    self repairDamage.</body><body package="GF/ST Base">handlesToDisplayInRect: aRect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the handles to be displayed that intersect	aRect"    (drawing == nil or: [ hideHandles &gt; 0 ]) ifTrue: [^handles species new].    ^handles select: [:each | each displayBox intersects: aRect]</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    handles := OrderedCollection new.    hideHandles := 0.    selections := OrderedCollection new.    memento := GFBoundedStack bound: 15</body><body package="GF/ST Base">initializePalette"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    self palette: self class defaultPalette</body><body package="GF/ST Base">interface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "We are the interface"</body><body package="GF/ST Base">isSelected: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer if aGO is selected"    ^selections includes: aGO.</body><body package="GF/ST Base">lastGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the top go of the drawing"    ^drawing lastGO</body><body package="GF/ST Base">lastGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the top go of the drawing"    drawing lastGO: aGO.</body><body package="GF/ST Base">mementoForNewGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the memento used to remove aGO from the drawing"    | mem |    (mem := GFMemento originator: self)        addActionSelector: #removeHandlesFor:            with: aGO;           addActionSelector: #removeGO:            with: aGO;        addActionReceiver: aGO            selector: #release.    aGO isHostWidgetGO ifTrue: [        mem addActionReceiver: aGO selector: #removeHostWidget    ].    ^mem</body><body package="GF/ST Base">menu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | menu |    menu := Menu new.    menu	addItemLabel: '&amp;Undo'  value: (MessageSend receiver: self selector: #undo);	addItemGroupLabels: #( 'Cu&amp;t' ) values: (Array with: (MessageSend receiver: self selector: #cut ));	addItemLabel: '&amp;Copy' value: (MessageSend receiver: self selector: #copy);	addItemLabel: '&amp;Paste' value: (MessageSend receiver: self selector: #paste);	addItemGroupLabels: #( 'Print (use pixmap)') values: (Array with: (MessageSend receiver: self selector: #outputToPrinterNoFonts )); 	addItemLabel: 'Print (use fonts)' value: (MessageSend receiver: self selector: #outputToPrinter);	addItemGroupLabels: #( '&amp;Group' ) values: (Array with: (MessageSend receiver: self selector: #group));	addItemLabel: '&amp;Ungroup' value: (MessageSend receiver: self selector: #ungroup);	addItemGroupLabels: #( '&amp;Compose' ) values: (Array with: (MessageSend receiver: self selector: #compose));	addItemLabel: '&amp;Decompose' value: (MessageSend receiver: self selector: #decompose).	#{Compiler} ifDefinedDo: 		[:compiler|		menu			addItemGroupLabels: #( 'Visual Inspect') values: (Array with: (MessageSend receiver: self selector: #graphicallyInspect));			addItemLabel: 'Inspect' value: (MessageSend receiver: self selector: #normalInspect)].    ^menu</body><body package="GF/ST Base">menuBarCollectionForView: aView"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(OrderedCollection new)        add:            ((Menu                labels: 'E\uxit' replaceEscapeCharacters                selectors: #(close))                owner: aView;                title: '\uFile' replaceEscapeCharacters            );		add: self scaleMenu;		add: self gridMenu;        add: self popupMenu;        yourself</body><body package="GF/ST Base">menuLabel"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    ^'Drawing'</body><body package="GF/ST Base">newMousePoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "A new mouse point has been generated.  Notify anyone interested"    self        triggerEvent: #mousePointChanged        with: (drawing nativeToCoordinate: aPoint).</body><body package="GF/ST Base">noMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^#noMenu</body><body package="GF/ST Base">noSelections"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove all selections from the receiver"    self hideHandles.    selections do: [ :each | each deselect ].    selections := OrderedCollection new.    handles := OrderedCollection new.    hideHandles := 0.</body><body package="GF/ST Base">noUndo"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Don't record undo information"    memento := nil.</body><body package="GF/ST Base">normalInspect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| sels |	sels := self selections.	sels size = 1 		ifTrue: [ sels first inspect ]		ifFalse: [ sels inspect ].</body><body package="GF/ST Base">outputToPrinter"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Output the drawing to the printer"    drawing outputToPrinter</body><body package="GF/ST Base">outputToPrinterNoFonts"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Output the drawing to the printer"    drawing outputToPrinterNoFonts</body><body package="GF/ST Base">palette"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the palette of tools the receiver has available"    palette == nil ifTrue: [self initializePalette].    ^palette</body><body package="GF/ST Base">palette: aGFToolPalette"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set my palette to aGFToolPalette"    palette := aGFToolPalette.    palette setInterface: self.</body><body package="GF/ST Base">paste"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Paste the GOs in the copy buffer into the drawing"    | newFigures aPoint mem newGO connections figures |    palette activeTool canCutCopyPaste ifTrue: [^palette activeTool paste].    CopyBuffer isNil ifTrue: [ ^self ].		aPoint := self cursorPoint.	figures := self copiesFromSource: CopyBuffer.	newFigures := figures collect: [ :each | each translateBy: aPoint ].	self addAndSelectAll: newFigures.	mem := GFMemento originator: self.	mem addActionSelector: #removeAllGOs: arguments: (Array with: newFigures).	self storeMemento: mem for: self</body><body package="GF/ST Base">pen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display's pen"    ^display pen</body><body package="GF/ST Base">popupMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aFigure m myMenu myPerformer pane |    pane := self displayPane.    myMenu := drawing menu.    myPerformer := drawing triggerEvent: #getMenuPerformer ifNotHandled: [ self ].    myMenu == #noMenu ifTrue: [ ^nil ].    ((aFigure := self graphicObjectAtCursor) == nil or: [ (m := aFigure menu) == nil ] )		ifTrue: [			myMenu notNil				ifTrue: [(myMenu startUpForView: pane) evaluateIfNoTarget: myPerformer .					^self redraw].			^self].	m == #noMenu ifTrue: [ ^nil ].	myMenu notNil 		ifTrue: [ m addItemGroup: (Array with: ((MenuItem labeled: self menuLabel) submenu: myMenu)) ].	(m startUpForView: pane) evaluateIfNoTarget: aFigure.	self redraw</body><body package="GF/ST Base">redraw"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Redraw the receiver"    display == nil ifTrue: [^self].    self hideHandlesWhile: [ display repairDamage ]</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    super release.    selections := nil.    handles notNil ifTrue: [ handles do: [ :hndl | hndl release ]].    handles := nil.    self releasePalette.    memento := nil.    display release.    drawing release.    self releaseDrawing</body><body package="GF/ST Base">releaseDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    drawing isNil ifTrue: [^self].    drawing container: nil.    drawing := nil.</body><body package="GF/ST Base">releasePalette"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    palette release</body><body package="GF/ST Base">repairDamage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Repair the damage to the display"    display isNil ifTrue: [^self].    display repairDamage</body><body package="GF/ST Base">scale: percent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the scale of the drawing"    self setScale: (percent / 100.0).</body><body package="GF/ST Base">scaleMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(Menu new)		addItemLabel: 'Zoom In' value: (MessageSend receiver: self selector: #zoomIn);		addItemLabel: 'Zoom Out' value: (MessageSend receiver: self selector: #zoomOut);		addItem: ((MenuItem labeled: 'Scale') submenu: self fixedScaleMenu);		yourself</body><body package="GF/ST Base">selectAll"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Select everything"    self selections: drawing graphicObjects</body><body package="GF/ST Base">selectTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Make aTool the active tool"    self palette selectTool: aTool.    ^aTool interface: self.</body><body package="GF/ST Base">selection: aGo"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the selection to aGO"    self selections: (Array with: aGo)</body><body package="GF/ST Base">selectionContainsPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the selected gos contain aPoint"    self selections        detect: [:each | each containsPoint: aPoint]        ifNone: [^false].    ^true</body><body package="GF/ST Base">selectionRegion"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the region bounding the selected gos"    | aCollection |    aCollection := self selections.    aCollection isEmpty ifTrue: [^0 @ 0 extent: 0 @ 0].    ^aCollection inject: aCollection first displayBox into: [:sum :each | sum merge: each displayBox]</body><body package="GF/ST Base">selections"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the selected gos"    ^selections</body><body package="GF/ST Base">selections: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the selections of the receiver to aCollection of GOs"    self noSelections.    self addHandlesForAll: aCollection.    self showHandles.    self triggerEvent: #select.</body><body package="GF/ST Base">sendToBack: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Send aGO to the back"    aGO container firstGO == aGO ifTrue: [ ^self ].    self storeMemento: aGO positionMemento  for: aGO.    aGO damaged.    aGO moveToFirst.    self redraw</body><body package="GF/ST Base">setComponent: aDrawing"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	drawing := aDrawing.	aDrawing container: self.</body><body package="GF/ST Base">setDefaultTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Make the default tool of the palette active"    self palette setDefaultTool</body><body package="GF/ST Base">setDisplaySystem: aGFDisplaySystem"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the display system of the receiver"    display := aGFDisplaySystem</body><body package="GF/ST Base">setDrawing: aDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set my drawing to aDrawing."    self releaseDrawing.    drawing := aDrawing.    drawing installInInterface: self.    drawing container: self.</body><body package="GF/ST Base">setGridColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Prompt for and choose the grid color for the drawing"    | color |    color := Color pickAColor: 'Choose Grid Color' initialColor: drawing gridColor.    color isNil ifTrue: [^self].    drawing gridColor: color.    display redrawVisible.</body><body package="GF/ST Base">setGridSize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Prompt for and set the grid size of the drawing"    | grid |    grid := self class gfPrompterClass prompt: 'Enter grid size' default: drawing grid x printString.    (grid == nil or: [grid isEmpty]) ifTrue: [^self].    grid := (grid asInteger) max: 1.    drawing grid: grid@grid.    display redrawVisible.</body><body package="GF/ST Base">setMousePoint: aPoint snapToGrid: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the mousePoint.  Answer the snapped and limited mouse point.	 Snap the mouse point to the grid if snap is true, and limit the point to	 the extent of the drawing if limit is true	"	^display setMousePoint: aPoint snapToGrid: snap limit: limit</body><body package="GF/ST Base">setScale: aScalingFactor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the scale of the drawing.  Display the result"	drawing setScale: aScalingFactor; damageAll.	display setScale: aScalingFactor; reset.	self repairDamage.</body><body package="GF/ST Base">shiftDown"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^display shiftDown</body><body package="GF/ST Base">shouldDoDragDrop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^false</body><body package="GF/ST Base">showHandle: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Show a specific handle regardless of the hideHandles count"    display showHandles: (Array with: aHandle)</body><body package="GF/ST Base">showHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the handles"    hideHandles &gt; 0 ifFalse: [ display displayHandles: handles ]</body><body package="GF/ST Base">showQuad"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    drawing graphicObjectsQuad displayWith: display pen</body><body package="GF/ST Base">snapGOsToGrid: gos"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap the gos to the grid of the drawing"    gos do: [ :each | each snapToGrid ].    self redraw.</body><body package="GF/ST Base">snapMousePoint: aPoint if: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap aPoint to the grid if snap, and limit it to the extent of the     drawing if limit.    "    | p |    p := drawing snapToGrid: aPoint if: snap limit: limit.    self newMousePoint: p.    ^p</body><body package="GF/ST Base">snapSelectionsToGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap the selected GOs to the drawing's grid"    [self hideHandles.    self snapGOsToGrid: self selections.]    ensure: [ self unhideHandles ]</body><body package="GF/ST Base">sortedSelections"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(drawing graphicObjects select: [:each | selections includes: each]) asSortedCollection</body><body package="GF/ST Base">storeMemento: aMemento for: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    memento == nil ifFalse: [        memento push: (Array with: anObject with: aMemento)    ].</body><body package="GF/ST Base">toggleDisplayGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Toggle the display of the grid.  Display the result"    drawing displayGrid: drawing displayGrid not.    display redrawVisible.</body><body package="GF/ST Base">toggleSelection: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Toggle the selection of aGO"	(self isSelected: aGO)		ifTrue: [self removeHandlesFor: aGO]		ifFalse: [self addHandlesFor: aGO].	self triggerEvent: #select</body><body package="GF/ST Base">toggleSelections: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Toggle the seletion of aCollection of GOs"    aCollection do: [:each | self toggleSelection: each]</body><body package="GF/ST Base">toggleUseGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Toggle the use of the grid in the drawing"    drawing toggleUseGrid</body><body package="GF/ST Base">tools"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer all the tools"    ^palette allTools</body><body package="GF/ST Base">totalHeight"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the total height of the drawing"    drawing == nil ifTrue: [^1024].    ^drawing drawingExtent y</body><body package="GF/ST Base">totalWidth"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the total width of the drawing"    drawing == nil ifTrue: [^1024].    ^drawing drawingExtent x</body><body package="GF/ST Base">undo"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Undo the last action"    | mem |    (memento == nil or: [memento isEmpty]) ifTrue: [ ^self bell ].    mem := memento pop.    self hideHandlesWhile: [            (mem at: 1) restoreFrom: (mem at: 2)    ].    self redraw.</body><body package="GF/ST Base">undoLevel: bound"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the undo level of the receiver"    memento == nil ifTrue: [        memento := GFBoundedStack bound: bound.    ].</body><body package="GF/ST Base">ungroup"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Ungroup the selected group into its component graphic objects"    | aCollection mem |    mem := GFMemento originator: self.    aCollection := self selections.    aCollection isEmpty ifTrue: [^self].    self noSelections.    self selections: (aCollection inject: Set new into: [:sum :each |                each isGroupGO                    ifTrue: [                        mem                            addActionSelector: #group:in:                                with: each graphicObjects copy                                with: each.                        drawing remove: each.                        each graphicObjects asArray do: [:aGO |                            aGO unlink.                               mem                                addActionSelector: #removeHandlesFor:                                       with: aGO.                              drawing add: aGO                        ].                        sum addAll: each graphicObjects.                        each unlink; release.                        sum                    ]                    ifFalse: [ sum ]]).        self storeMemento: mem for: self.</body><body package="GF/ST Base">useGrid: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set whether the drawing uses a grid or not"    drawing useGrid: aBoolean</body><body package="GF/ST Base">usesGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the drawing uses a grid or not"    ^drawing usesGrid</body><body package="GF/ST Base">visibleRectangle"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the area currently visible on the display surface"    ^display visibleRectangle</body><body package="GF/ST Base">zoomIn"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Zoom the receiver, increasing the drawing's size by 10%"    self setScale: (drawing scale + 0.1).</body><body package="GF/ST Base">zoomOut"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Zoom out the receiver, decreasing the drawing's size by 10%"    self setScale: ((drawing scale - 0.1) max: 0.1).</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>adding GOs</category><body package="GF/ST Base">addAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add all the graphic objects in aCollection to the receiver, display the result"    self quietlyAddAll: aCollection; repairDamage.</body><body package="GF/ST Base">addAndSelectAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add all the graphic objects in aCollection to the drawing and select     the graphic objects added.    "    self noSelections.    self addAll: aCollection.    self selections: aCollection</body><body package="GF/ST Base">addGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add a graphic object to the drawing.  Display the result"    drawing add: aGO.    aGO damaged.    self repairDamage</body><body package="GF/ST Base">addGOBehindAll: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO behind all other graphicObjects, display the result"    drawing addLast: aGO.    aGO damaged.    self repairDamage</body><body package="GF/ST Base">quietlyAddAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aCollection of GOs into the receiver, but don't redraw"    aCollection do: [:each |   each container == nil                                                ifTrue: [ drawing add: each ]                                                ifFalse: [ each container add: each ].											each hasHostWidget ifTrue: [ each restoreHostWidget ].                                            each damaged].</body><body package="GF/ST Base">quietlyAddGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO to the drawing, but don't redraw"    drawing add: aGO.    aGO damaged.</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>tracking</category><body package="GF/ST Base">trackMouse: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse activity using aBlock.  Scroll the display to follow     the mouse    "    ^display trackMouse: aBlock scroll: true</body><body package="GF/ST Base">trackMouse: aBlock preScrollDo: preScrollBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse activity with aBlock.  Before scrolling the     display, evaluate aBlock.    "    ^display trackMouse: aBlock preScrollDo: preScrollBlock</body><body package="GF/ST Base">trackMouse: aBlock preScrollDo: preScrollBlock snapToGrid: snap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse activity with aBlock that receivers the current point.     Before scrolling the display, evaluate the preScrollBlock.  Snap the mouse     points to the grid if snap    "    ^display trackMouse: aBlock preScrollDo: preScrollBlock snapToGrid: snap</body><body package="GF/ST Base">trackMouse: aBlock scroll: scrollFlag"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse activity with aBlock that receives the mouse point.     Scroll the display if scrollFlag    "    ^display trackMouse: aBlock scroll: scrollFlag</body><body package="GF/ST Base">trackMouse: trackBlock    uponRelease: releaseBlock    until: stopBlock    scroll: scroll    preScrollDo: preScrollBlock    snapToGrid: snap    limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating the trackBlock for every point.     The mouse is tracked until the stopBlock evaluates true.  Upon     release of the mouse button, the releaseBlock is evaluated.     The display is scrolled to accomidate the tracking if scroll is true.     If scrolling is enabled, the preScrollBlock is evaluated before scrolling     the display with the previous point tracked as the argument.     The mouse point is snapped to the drawing grid if snap is true.     The mouse points tracked are limited to the extent of the drawing     if limit is true.    "    ^display trackMouse: trackBlock            uponRelease: releaseBlock            until: stopBlock            scroll: scroll            preScrollDo: preScrollBlock            snapToGrid: snap            limit: limit</body><body package="GF/ST Base">trackMouseUntilLBDoubleClick: trackBlock uponRelease: releaseBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Track the mouse point, evaluating the trackBlock for every point.     When the left button is released, evaluate the releaseBlock.     Continue tracking until the Left mouse button is double clicked    "    ^display trackMouseUntilLBDoubleClick: trackBlock uponRelease: releaseBlock</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>handles</category><body package="GF/ST Base">addHandle: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aHandle to the receiver, display the result"    handles add: aHandle.    self showHandles</body><body package="GF/ST Base">addHandleNoUpdate: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aHandle to the receiver, do not display the result"    handles add: aHandle.</body><body package="GF/ST Base">addHandlesFor: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add all the handles for a graphic object.  Select the object"    selections add: aGO.    aGO select.    handles addAll: aGO generateHandles.</body><body package="GF/ST Base">addHandlesForAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add all the handles for aCollection of graphic objects"    aCollection do: [:each | self addHandlesFor: each]</body><body package="GF/ST Base">handleAt: selectionPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the handle hit by the selectionPoint"    drawing == nil ifTrue: [^nil].    ^handles detect: [:each | each containsPoint: selectionPoint]        ifNone: [nil]</body><body package="GF/ST Base">handleInvoked: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Notify anyone interested that aHandle is being invoked"    self triggerEvent: #handleInvoked with: aHandle</body><body package="GF/ST Base">handlesFor: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the active handles associated with aGO"    ^handles select: [:each | each isFor: aGO]</body><body package="GF/ST Base">hideHandle: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Hide aHandle on myself by redrawing it in the background color.    Dont refresh here so that when many handles are hidden, we    only have to refresh once.  Don't mess with the hideHandles count either"    self damageRegion: aHandle displayBox</body><body package="GF/ST Base">hideHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This is the method that should be used to hide all handles en masse.    It increments the hideHandles count.  This method should be balanced    by a call to #unhideHandles to decrement the hideHandles count or a 	call to #noSelections to reset the hideHandles count."    hideHandles := hideHandles + 1.    display hideHandles: handles.</body><body package="GF/ST Base">hideHandlesWhile: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Hide the active handles during the evaluation of anAction"    (handles notNil and: [handles isEmpty])        ifTrue: [ anAction evaluate ]        ifFalse: [ [self hideHandles.                     anAction evaluate.]                     ensure: [ self unhideHandles ]]</body><body package="GF/ST Base">noHandleInvoked"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Notify anyone interested that no handle is invoked"    self triggerEvent: #noHandleInvoked</body><body package="GF/ST Base">quietlyRemoveHandlesFor: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove all the handles for aGO"    selections remove: aGO ifAbsent: [].    aGO deselect.    (self handlesFor: aGO) do: [:each | self removeHandleNoUpdate: each]</body><body package="GF/ST Base">removeHandle: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove aHandle from the active handles of the receiver.  Display the     result    "    handles remove: aHandle ifAbsent: [^self].    self hideHandle: aHandle.    self repairDamage</body><body package="GF/ST Base">removeHandleNoUpdate: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This deletes aHandle, but will not show up until view gets repaired.    Useful when you wish to delete many handles and have it appear    like one quick delete stage."    handles remove: aHandle ifAbsent: [^self].    self hideHandle: aHandle.</body><body package="GF/ST Base">removeHandlesFor: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove all the handles for aGO"    selections remove: aGO ifAbsent: [].    aGO deselect.    (self handlesFor: aGO) do: [:each | self removeHandle: each]</body><body package="GF/ST Base">unhideHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Reveal the handles"    hideHandles := 0 max: (hideHandles - 1).    self showHandles</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>scaling</category><body package="GF/ST Base">scale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^drawing scale</body><body package="GF/ST Base">scaledPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^drawing scaledPoint: pt</body><body package="GF/ST Base">scaledRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^drawing scaledRectangle: rect</body><body package="GF/ST Base">unscaledPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^drawing unscaledPoint: pt</body><body package="GF/ST Base">unscaledRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^drawing unscaledRectangle: rect</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>keyboard</category><body package="GF/ST Base">dispatchesKeyboard"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^display dispatchesKeyboard</body><body package="GF/ST Base">keyboardProcessor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^display keyboardProcessor</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>removing GOs</category><body package="GF/ST Base">quietlyRemoveAllGOs: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove all graphic objects in aCollection"    aCollection do: [:each |        self quietlyRemoveHandlesFor: each.        each damaged; deselect.        each container remove: each.    ].</body><body package="GF/ST Base">quietlyRemoveGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove aGO from the drawing, but don't repair the display"    (self isSelected: aGO) ifTrue: [        self quietlyRemoveHandlesFor: aGO    ].    aGO damaged.    aGO unlink.    drawing remove: aGO.</body><body package="GF/ST Base">removeAllGOs: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove all graphic objects in aCollection"    self quietlyRemoveAllGOs: aCollection.    self redraw.</body><body package="GF/ST Base">removeGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove aGO from the drawing.  Redisplay"    self quietlyRemoveGO: aGO.    self repairDamage.</body><body package="GF/ST Base">removeNoUpdate: aFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This deletes aFigure, but will not show up until view gets repaired.    Useful when you wish to delete many figures and have it appear    like one quick delete stage."    aFigure damaged.    drawing remove: aFigure</body><body package="GF/ST Base">removeSelections"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove the selections from the drawing"    | aCollection |    aCollection := self selections.    self removeAllGOs: aCollection.    self noSelections</body></methods><methods><class-id>Polymorphic.GFDrawingInterface</class-id> <category>uilayout</category><body package="GF/ST Base">subtreeNeedsLayout	display ifNotNil: #subtreeNeedsLayout</body></methods><methods><class-id>Polymorphic.GFDrawingInterface class</class-id> <category>GF/ST</category><body package="GF/ST Base">copyBuffer: aGOArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the copy buffer to aGOArray"        CopyBuffer := aGOArray</body><body package="GF/ST Base">defaultPalette"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default palette of the tools I can use."	| palette selectionTool |	selectionTool := GFSelectionTool new.	palette := GFToolPalette new.	palette		addCategory: ((GFCategory icon: (GFTool stockIconFor: 'Zorder') name: 'Z-Ordering Tools')									defaultTool: selectionTool;									addTool: GFGOActionTool bringToFront;									addTool: GFGOActionTool sendToBack;									yourself);		addCategory: ((GFCategory icon: (GFTool stockIconFor: 'Lines') name: 'Line Tools')									defaultTool: selectionTool;									addTool: GFLineGO creationTool;									addTool: GFLineGO arrowCreationTool;									yourself);		addCategory: ((GFCategory icon: (GFTool stockIconFor: 'ClosedGOs') name: 'Closed Path Tools')									defaultTool: selectionTool;									addTool: GFRectangleGO creationTool;									addTool: GFRoundedRectangleGO creationTool;									addTool: GFEllipseGO creationTool;									addTool: GFImageGO creationTool;									yourself);		addCategory: ((GFCategory icon: (GFTool stockIconFor: 'Paths') name: 'Path Tools')									defaultTool: selectionTool;									addTool: GFBezierGO creationTool;									addTool: GFPolylineGO creationTool;									addTool: GFOrthogonalPathGO creationTool;									addTool: GFOrthogonalPathGO arrowCreationTool;									addTool: GFSplineGO creationTool;									yourself);		addCategory: ((GFCategory icon: (GFTool stockIconFor: 'Components') name: 'Host Widgets')									defaultTool: selectionTool;									addTool: GFTextGO creationTool;									addTool: GFHostWidgetGO buttonCreationTool;									addTool: GFHostWidgetGO textFieldCreationTool;									addTool: GFHostWidgetGO paragraphCreationTool;									addTool: GFHostWidgetGO listCreationTool;									yourself).	^palette</body><body package="GF/ST Base">drawingClass"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^GFDrawing</body><body package="GF/ST Base">eventsTriggered	"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	eventsTriggered isNil 		ifTrue: 			[(eventsTriggered := Set new)				addAll: self superclass eventsTriggered;				add: #mousePointChanged;				add: #getMenu;				add: #getMenuPerformer;				add: #handleInvoked;				add: #noHandleInvoked;				add: #select].	^eventsTriggered</body><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new initialize</body><body package="GF/ST Base">newWithDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self on: self drawingClass new</body><body package="GF/ST Base">on: aDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | interface |    interface := self new.    interface setDrawing: aDrawing.    ^interface</body><body package="GF/ST Base">open"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "GFDrawingInterface open"    ^self openOn: self drawingClass new</body><body package="GF/ST Base">openOn: aDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self openOn: aDrawing withLabel: 'Drawing'</body><body package="GF/ST Base">openOn: aDrawing withLabel: aLabel"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | interface |    interface := self new.    interface setDrawing: aDrawing.    GFDrawingEditor openOn: aDrawing withInterface: interface withLabel: aLabel.    ^interface</body><body package="GF/ST Base">openWithLabel: aLabel"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self openOn: self drawingClass new withLabel: aLabel</body></methods><methods><class-id>Polymorphic.GFCompositeGO</class-id> <category>GF/ST</category><body package="GF/ST Base">add: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO to the receiver"    aGO container: self.    (graphicObjects includes: aGO) ifFalse: [ graphicObjects add: aGO ].</body><body package="GF/ST Base">add: newGO behind: oldGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add the newGO behind the oldGO"    newGO container: self.    oldGO notNil ifTrue: [ oldGO insert: newGO].    self add: newGO</body><body package="GF/ST Base">addAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add all the gos in aCollection to the receiver"    aCollection reverseDo: [:each | self addLast: each]</body><body package="GF/ST Base">addLast: newGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add newGO behind all others"    graphicObjects isEmpty        ifTrue: [ self add: newGO ]        ifFalse: [ self add: newGO behind: graphicObjects last ]</body><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Translate the receiver by aPoint"    visibleArea translatedByPoint: aPoint.    graphicObjects do: [:each | each translateBy: aPoint].    displayBox := nil.</body><body package="GF/ST Base">bringToFront: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Move aGO to the front in z-order"    aGO moveToLast</body><body package="GF/ST Base">collectGOs: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Collect all the goes using aBlock"    ^graphicObjects asOrderedCollection collect: aBlock.</body><body package="GF/ST Base">componentChanged"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "aFigure is one of my figures and it has changed in some way (likely it moved). This    message does *not* get sent when I get changed, though"    self damaged.</body><body package="GF/ST Base">copy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGO |    aGO := super copy.    aGO setGOs: (self collectGOs: [:each | each copy])        visibleArea: visibleArea deepCopy.    showVisibleArea ifTrue: [aGO showVisibleAreaIndicator].    ^aGO</body><body package="GF/ST Base">damage: aFigure during: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Since I don't keep a cache, I can ignore this."    aFigure willDamage.    aBlock value.    aFigure damaged.</body><body package="GF/ST Base">damageAllGOs"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Damage all the gos in the receiver"    self graphicObjectsDo: [:each | each damaged].</body><body package="GF/ST Base">damageRegion: aRegion"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Damage the region in the receiver"    container == nil ifTrue: [^self].    container damageRegion: aRegion</body><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    "Cache the displayBox"    displayBox == nil ifTrue: [        displayBox := super displayBox expandedByPoint: 1@1.    ].    ^displayBox</body><body package="GF/ST Base">displayVisibleAreaWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Display the visible area rectangle"    showVisibleArea ifFalse: [^self].    aPen setLineWidthTo: 1; black; fastRectangle: visibleArea.</body><body package="GF/ST Base">extent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the display area of the receiver"    ^(visibleArea extent + 0.5) rounded</body><body package="GF/ST Base">firstGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	graphicObjects isNil ifTrue: [^nil].	^graphicObjects isEmpty ifTrue: [nil] ifFalse: [graphicObjects first]</body><body package="GF/ST Base">firstGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    aGO == nil ifTrue: [ ^self ].    graphicObjects remove: aGO ifAbsent: [].    graphicObjects add: aGO.</body><body package="GF/ST Base">graphicObjectAt: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphicObject at aPoint"    | go |    (go := graphicObjects pointContainer: aPoint) == nil ifTrue: [^super graphicObjectAt: aPoint].    ^go graphicObjectAt: aPoint.</body><body package="GF/ST Base">graphicObjectAt: aPoint ifAbsent: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic object at aPoint, if none, answer the value     of evaluating aBlock"    | go |    (go := graphicObjects pointContainer: aPoint) == nil ifTrue: [^aBlock value].    ^go graphicObjectAt: aPoint.</body><body package="GF/ST Base">graphicObjectBefore: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic object before aGO"    self graphicObjects before: aGO ifNone: [nil]</body><body package="GF/ST Base">graphicObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an array of graphic objects, the receiver has"        ^graphicObjects</body><body package="GF/ST Base">graphicObjectsDo: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Iterate over the graphic objects in the receiver"    ^graphicObjects copy do: aBlock</body><body package="GF/ST Base">graphicObjectsIn: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic objects containedIn aRectangle"    ^(graphicObjects conflict: aRectangle) select: [:each | each containedBy: aRectangle]</body><body package="GF/ST Base">graphicObjectsIntersecting: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the graphic objects intersecting aRectangle"    ^graphicObjects conflict: aRectangle</body><body package="GF/ST Base">graphicObjectsReverseDo: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Iterate over the graphic objects in reverse order"    ^graphicObjects reverseDo: aBlock</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the points the receiver should snap to the grid used by     the receiver.     Subclasses should override this to implement their own behavior     towards the grid    "    Array        with: displayBox leftTop        with: displayBox rightBottom</body><body package="GF/ST Base">growBy: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Change the size of my visibleArea (not less than a reasonable minimum) and reset the    visible figures within it."    (visibleArea origin &lt; aRectangle origin negated        or: [visibleArea extent &lt; aRectangle extent negated])        ifTrue: [^self].    self damageDuring: [        visibleArea expandByRectangle: aRectangle.        "flush the displayBox cache"        displayBox := nil.    ].    self triggerEvent: #resize with: self.</body><body package="GF/ST Base">hideVisibleAreaIndicator"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Hide the visible area indicator"    showVisibleArea := false.    self damaged</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    graphicObjects := SortedCollection new.    showVisibleArea := false.	visibleAreaLineColor := self class defaultLineColor.</body><body package="GF/ST Base">injectFigures: initialValue into: aBinaryBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Private - For each element in the receiver graphicObjects collection,         evaluate aBinaryBlock with that element as the argument.         Starting with initialValue, the block is also provided with its         own value from the previous evaluation.  Answer this value         at the end of the block evaluations."     | answer |    answer := initialValue.    graphicObjects do: [ :element |        answer := aBinaryBlock            value: answer            value: element].    ^answer</body><body package="GF/ST Base">isCompositeGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^true</body><body package="GF/ST Base">isContainerGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer true since I can contain other GOs"    ^true</body><body package="GF/ST Base">kindsOfGOs"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an array of classes the receiver contains"    ^self graphicObjects inject: (Set with: self class) into: [:sum :each |        sum addAll: each kindsOfGOs; yourself    ]</body><body package="GF/ST Base">lastGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	graphicObjects isNil ifTrue: [^nil].	^graphicObjects isEmpty ifTrue: [nil] ifFalse: [graphicObjects last]</body><body package="GF/ST Base">lastGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    aGO == nil ifTrue: [ ^self ].    graphicObjects remove: aGO ifAbsent: [].    graphicObjects add: aGO.</body><body package="GF/ST Base">linkGraphicObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | gos |    graphicObjects size &lt; 2 ifTrue: [ ^self ].    gos := OrderedCollection new: graphicObjects size.    graphicObjects do: [ :each | gos add: each ].    gos first unlink.    gos last unlink.    1 to: gos size - 1 do: [ :i |         (gos at: i) insert: (gos at: i + 1)].    graphicObjects := gos asSortedCollection.</body><body package="GF/ST Base">origin"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the origin of the receiver"    ^(visibleArea origin - 0.5) rounded</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the position information of the receiver"    | pi |    pi := super positionInformation.    pi add: (self class gfMessageClass                    receiver: nil                    selector: #setGOs:visibleArea:                    arguments: (Array with: (graphicObjects copy) with: visibleArea deepCopy)).    graphicObjects asOrderedCollection            do: [ :each | pi add: (self class gfMessageClass                                                receiver: each                                                selector: #restoreFrom:                                                arguments: (Array with: each positionMemento))].    pi add: (self class gfMessageClass                    receiver: nil                    selector: #damageDuring:                    arguments: (Array with: [])).    ^pi</body><body package="GF/ST Base">privateAdd: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    self add: aGO</body><body package="GF/ST Base">quietlyRemoveAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove all gos in aCollection from the receiver"    aCollection do: [:each | self quietlyRemove: each]</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Release the receiver"    super release.    graphicObjects notNil ifTrue: [self graphicObjectsDo: [ :each | each release: self ]].    graphicObjects := nil.</body><body package="GF/ST Base">remove: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove aGO as a component of the receiver."    graphicObjects remove: aGO ifAbsent: [].    aGO        container: container;        removeDependent: self.    aGO unlink.</body><body package="GF/ST Base">removeAll: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove all gos in aCollection from the receiver"    aCollection do: [:each | self remove: each]</body><body package="GF/ST Base">resetVisibleArea"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Reset the visible area"    self damageDuring: [        self visibleArea: (self injectFigures: self firstGO displayBox deepCopy into: [:rect :each |                                        rect mergeWith: each displayBox]).    ].    self triggerEvent: #resetVisibleArea with: self.</body><body package="GF/ST Base">restoreHostWidget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	graphicObjects do: [ :each | each hasHostWidget ifTrue: [ each restoreHostWidget ]].</body><body package="GF/ST Base">sendToBack: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Send aGo to the back"    aGO moveToFirst</body><body package="GF/ST Base">senseBottomLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftBottomGrowUnit.    (visibleArea extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((visibleArea bottom down: (y := growPoint y)) isAboveEqual: visibleArea top) ifTrue: [ y := 0 ].    ^x @ 0 rightBottom: 0 @ y</body><body package="GF/ST Base">senseBottomRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's bottom     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightBottomGrowUnit.    (visibleArea extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((visibleArea bottom down: (y := growPoint y)) isAboveEqual: visibleArea top) ifTrue: [ y := 0 ].    ^0 @ 0 rightBottom: (x @ y)</body><body package="GF/ST Base">senseTopLeft: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     left point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle leftTopGrowUnit.    (visibleArea extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((visibleArea top up: (y := growPoint y)) isBelowEqual: visibleArea bottom) ifTrue: [ y := 0 ].    ^x @ y rightBottom: 0 @ 0</body><body package="GF/ST Base">senseTopRight: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the rectangle used to grow the receiver's top     right point, based on a deltaPoint    "    | x y growPoint |	growPoint := deltaPoint * Rectangle rightTopGrowUnit.    (visibleArea extent x right: (x := growPoint x)) &lt;= 1 ifTrue: [ x := 0 ].    ((visibleArea top up: (y := growPoint y)) isBelowEqual: visibleArea bottom) ifTrue: [ y := 0 ].    ^0 @ y rightBottom: x @ 0</body><body package="GF/ST Base">setGOs: aCollection visibleArea: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    graphicObjects := aCollection.    visibleArea := aRectangle.    displayBox := nil.    self graphicObjectsDo: [:each |        each container: self.        each when: #damaged send: #componentChanged to: self    ].    self linkGraphicObjects.    showVisibleArea := true.</body><body package="GF/ST Base">showVisibleAreaIndicator"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the receiver to display the visible area indicator"    showVisibleArea := true.    self damaged</body><body package="GF/ST Base">showingVisibleArea"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether I am currently showing my visibleArea."    ^showVisibleArea</body><body package="GF/ST Base">toggleVisibleAreaIndicator"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Toggle the visible area indicator"    showVisibleArea := showVisibleArea not.    self damaged</body><body package="GF/ST Base">visibleArea"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^visibleArea</body><body package="GF/ST Base">visibleArea: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    visibleArea := aRectangle.    displayBox := nil.</body><body package="GF/ST Base">visibleAreaLineColor "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^visibleAreaLineColor</body><body package="GF/ST Base">visibleAreaLineColor: color"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	visibleAreaLineColor := color</body></methods><methods><class-id>Polymorphic.GFCompositeGO</class-id> <category>display</category><body package="GF/ST Base">display: rect with: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.     Draw each of my graphicObjects, clipping to the visibleArea"    showVisibleArea ifTrue: [        aPen setStyle: 0                color: self visibleAreaLineColor                width: 1.        aPen drawRectangle: visibleArea    ].    aPen gfExecute: [        self graphicObjectsDo: [:each | (each intersects: rect) ifTrue: [ each display: rect with: aPen ]].    ] clipRect: (aPen clippingBounds intersect: (visibleArea logicalToDevice: aPen))</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    "Draw each of my graphicObjects, clipping to the visibleArea"    self displayVisibleAreaWith: aPen.    aPen gfExecute: [            (self graphicObjectsIn: displayBox) reverseDo: [:each |       		each displayShapeWith: aPen].    ] clipRect: (aPen clippingBounds intersect: (visibleArea logicalToDevice: aPen))</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.     Draw each of my graphicObjects, clipping to the visibleArea"    showVisibleArea ifTrue: [        aPen setStyle: 0                color: self visibleAreaLineColor                width: 1.        aPen drawRectangle: visibleArea    ].    aPen gfExecute: [        self graphicObjectsDo: [:each | each displayWith: aPen].    ] clipRect: (aPen clippingBounds intersect: (visibleArea logicalToDevice: aPen))</body></methods><methods><class-id>Polymorphic.GFCompositeGO</class-id> <category>menus</category><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    | item |	item := MenuItem labeled: 'show visible area'.	showVisibleArea 		ifTrue: [ item beOn ]		ifFalse: [ item beOff ].	^(Menu new)		addItem: item value: (MessageSend receiver: self selector: #toggleVisibleAreaIndicator);		yourself</body></methods><methods><class-id>Polymorphic.GFCompositeGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the events triggered"    eventsTriggered isNil ifTrue: [        (eventsTriggered := Set new)            addAll: self superclass eventsTriggered;            add: #resetVisibleArea.    ].    ^eventsTriggered</body><body package="GF/ST Base">graphicObjects: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new ComposedGO with each graphicObject in aCollection as a visible graphicObject of the    composition. Set the visibleArea to cover all the graphicObjects."    | aRectangle |    aRectangle := aCollection inject: aCollection first displayBox into: [:sum :each | sum merge: each displayBox].    ^self visibleArea: aRectangle graphicObjects: aCollection</body><body package="GF/ST Base">visibleArea: aRectangle graphicObjects: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new instance of the receiver"    ^self new setGOs: aCollection visibleArea: aRectangle</body></methods><methods><class-id>Polymorphic.GFDrawing</class-id> <category>GF/ST</category><body package="GF/ST Base">add: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add aGO to the receiver"        aGO container: self.        graphicObjects add: aGO.        aGO moveToLast</body><body package="GF/ST Base">add: newGO after: oldGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add the newGO behind the oldGO"        newGO container: self.        graphicObjects add: newGO after: oldGO.</body><body package="GF/ST Base">add: newGO behind: oldGO	^self add: newGO after: oldGO</body><body package="GF/ST Base">addLast: newFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Add newGO behind all others"    self add: newFigure behind: lastGO</body><body package="GF/ST Base">alignToGrid: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap aPoint to the grid of the drawing in which the receiver is     contained.  This is a destructive operation.  IE, the point is modified     to be constrained to the grid.    "    ^coordSystem alignToGrid: aPoint</body><body package="GF/ST Base">bounds: object</body><body package="GF/ST Base">coordinateSystem"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the coordinate system the receiver uses"    ^coordSystem</body><body package="GF/ST Base">coordinateToNative: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a point in the coordinate system expressed     in the native coordinate system    "    ^coordSystem coordinateToNative: aPoint</body><body package="GF/ST Base">copy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | aGFDrawing |    aGFDrawing := self class new initialize.    GFLocator copyWhile: [self graphicObjects reverseDo: [:each | aGFDrawing add: each copy]].    ^aGFDrawing</body><body package="GF/ST Base">damage: aGO during: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Damage aGO during the evaluation of aBlock"    | removed |    graphicObjects remove: aGO rectangle: aGO willDamage.    aBlock value.    graphicObjects add: aGO rectangle: aGO damaged.</body><body package="GF/ST Base">damageAll"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Damage the entire area of the receiver"    self damageRegion: (0@0 extent: self drawingExtent)</body><body package="GF/ST Base">damageRegion: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Damage the region in the receiver"    self triggerEvent: #damageRegion.    ^super damageRegion: aRectangle</body><body package="GF/ST Base">displayGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver displays the grid or not"    ^displayGrid</body><body package="GF/ST Base">displayGrid: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set whether the receiver displays a grid or not"    displayGrid := aBoolean</body><body package="GF/ST Base">drawingExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the extent of the drawing area"    ^coordSystem extent</body><body package="GF/ST Base">drawingExtent: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the extent of the drawing area"	visibleArea := visibleArea origin corner: aPoint.	^coordSystem extent: aPoint</body><body package="GF/ST Base">firstGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^firstGO</body><body package="GF/ST Base">firstGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    firstGO := aGO</body><body package="GF/ST Base">flushCoordinateCaches	"do nothing"</body><body package="GF/ST Base">graphicObjectAfter: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    self graphicObjects after: aGO ifNone: [nil]</body><body package="GF/ST Base">graphicObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer an array of graphic objects, the receiver has"    ^graphicObjects asOrderedCollection</body><body package="GF/ST Base">graphicObjectsDo: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Iterrate over the graphic objects in the receiver"    | start stop current nextGO |    start := self firstGO.    stop := self lastGO.    start == nil ifTrue: [ ^self ].    current := start.    [current ~~ stop] whileTrue: [ nextGO := current nextGO.													aBlock value: current.													current := nextGO ].    aBlock value: current.</body><body package="GF/ST Base">graphicObjectsQuad"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^graphicObjects</body><body package="GF/ST Base">grid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the grid point of the receiver"    ^coordSystem grid</body><body package="GF/ST Base">grid: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the grid point of the receiver"    coordSystem grid: aPoint</body><body package="GF/ST Base">gridColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the color of the grid"    ^gridColor</body><body package="GF/ST Base">gridColor: aColor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the grid color of the receiver"    gridColor := aColor</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    super initialize.    displayGrid := true.    coordSystem := GFCoordinateControl new.    visibleArea := 0@0 extent: coordSystem extent.    graphicObjects := GFQuadTreeElement                        origin: visibleArea origin                        corner: visibleArea corner.    displayGrid := false.    gridColor := Color black.</body><body package="GF/ST Base">installInInterface: anEditor"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "This can be overriden to change the tools, menu, etc. of the interface."</body><body package="GF/ST Base">isGFDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^true</body><body package="GF/ST Base">lastGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^lastGO</body><body package="GF/ST Base">lastGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    lastGO := aGO</body><body package="GF/ST Base">nativeToCoordinate: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a point in the native coordinate system expressed     in the coordinate system defined by the receiver    "    ^coordSystem nativeToCoordinate: aPoint</body><body package="GF/ST Base">newGraphicsDevice: gd</body><body package="GF/ST Base">occupiedExtent"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the maximum extent occupied by the receiver"    | pt |    pt := 0@0.    self graphicObjectsDo: [ :each | pt := pt rightMostAndLowest: each displayBox corner ].    ^pt</body><body package="GF/ST Base">outputToPrinter: ps useFonts: useFonts"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "send nil as the pages to be printed indicating that all    pages should be printed"    [self outputPages: nil toPrinter: ps useFonts: useFonts	]		ensure:			[ ps flush; print]</body><body package="GF/ST Base">outputToPrinterNoFonts"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self outputToPrinter: (Printer startPrintJobNamed: 'GFSTPRNT') useFonts: false</body><body package="GF/ST Base">preferredBounds	^Rectangle origin: Point zero extent: self drawingExtent</body><body package="GF/ST Base">privateAdd: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    aGO container: self.    (graphicObjects asOrderedCollection includes: aGO) ifFalse: [ graphicObjects add: aGO ].</body><body package="GF/ST Base">quietlyRemove: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove aGO as a component of the receiver."    aGO damaged; deselect.    graphicObjects remove: aGO ifAbsent: [].    aGO        container: nil;        removeDependent: self.    aGO unlink.</body><body package="GF/ST Base">redraw"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Redraw the receiver"    self triggerEvent: #redraw with: self.    ^super redraw</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Release the receiver"	| gos |	gos := graphicObjects.	super release.	gos notNil ifTrue: [ gos do: [:each | each isGFGraphicObject ifTrue: [each release]]].	firstGO := nil.	lastGO := nil.	"JST 16.08.95 preserve graphicObjects to ensure release"</body><body package="GF/ST Base">remove: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Remove aGO as a component of the receiver."    aGO willDamage.    graphicObjects remove: aGO ifAbsent: [].    aGO        container: nil;        removeDependent: self.    aGO unlink.</body><body package="GF/ST Base">scale"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the scale of the receiver"    ^coordSystem scale</body><body package="GF/ST Base">scaledPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^coordSystem scaledPoint: pt</body><body package="GF/ST Base">scaledRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^coordSystem scaledRectangle: rect</body><body package="GF/ST Base">setScale: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the scale of the receiver"    coordSystem scale: aPoint</body><body package="GF/ST Base">snapToGrid: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap aPoint to the grid of the receiver"    ^coordSystem snapToGrid: aPoint.</body><body package="GF/ST Base">snapToGrid: aPoint if: snap limit: limit"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Snap aPoint to the grid of the receiver if snap is true,     limit aPoint to the extent of the receiver if limit is true    "    ^coordSystem snapToGrid: aPoint if: snap limit: limit.</body><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^self interface menu</body><body package="GF/ST Base">toggleUseGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Toggle the use of the grid"    coordSystem toggleUseGrid</body><body package="GF/ST Base">unscaledPoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^coordSystem unscaledPoint: pt</body><body package="GF/ST Base">unscaledRectangle: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^coordSystem unscaledRectangle: rect</body><body package="GF/ST Base">useGrid: aBoolean"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set whether the receiver uses the grid for points or not"    coordSystem useGrid: aBoolean</body><body package="GF/ST Base">usesGrid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether the receiver uses the grid to snap points or not"    ^coordSystem useGrid</body></methods><methods><class-id>Polymorphic.GFDrawing</class-id> <category>printing</category><body package="GF/ST Base">outputPages: pages toPrinter: printJob"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self outputPages: pages toPrinter: printJob useFonts: true</body><body package="GF/ST Base">outputPages: pages toPrinter: printJob useFonts: useFonts"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Output the receiver to the printer specified by printerOrName,        which may be either an instance of Printer, or a String specifying        a printer name, or nil (in which case the default printer is selected).        pages should either be nil indicating that all pages should be        printed or a collection of numbers indicating which pages should        be printed out.        The number of pages to be printed depends upon where the extent        of the rightmost and lowest GO is in the drawing.  Pages are identified        by numbers as follows (again, the number of rows and columns that        are available to be printed is a function of the location of the right        and leftmost GO):        1, 2, 3, ... , n        n+1, n+2, n+3, ..."	| pgc pageExtent curPage startPage myExtent |	pgc := printJob graphicsContext.	coordSystem initializePen: pgc.	pgc useFonts: useFonts.	pageExtent := (printJob bounds extent / coordSystem scale) floor.	curPage := 1.	startPage := true.	myExtent := 0@0.	self graphicObjectsDo: [ :each | myExtent := myExtent rightMostAndLowest: each displayBox corner ].	self class gfCursorClass execute changeFor: [		0 to: myExtent y by: pageExtent y do: [ :curY |			0 to: myExtent x by: pageExtent x do: [ :curX |				startPage					ifTrue: [ startPage := false ]					ifFalse: [ pgc newPage ].				pgc translation: ((curX asInteger) @ (curY asInteger)) negated.				(pages == nil or: [ pages includes: curPage]) ifTrue: [					self printOn: pgc in: ((curX @ curY) extent: pageExtent)].				curPage := curPage + 1.		 ]].	].	pgc translation: 0@0</body><body package="GF/ST Base">outputToPrinter"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self outputToPrinter: (Printer startPrintJobNamed: 'GFSTPRNT') useFonts: true</body><body package="GF/ST Base">outputToPrinter: ps"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self outputToPrinter: ps useFonts: true</body><body package="GF/ST Base">printOn: aPen in: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central printing routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.     Draw each of my graphicObjects, clipping to the visibleArea"	| clip |	clip := aPen useFonts.	self displayVisibleAreaWith: aPen; displayGridIn: (aRectangle extent: (aRectangle extent min: self drawingExtent)) with: aPen.	(graphicObjects conflict: aRectangle) do: 		[:each |		clip ifTrue: [ aPen clippingRectangle: aRectangle ].		each displayWith: aPen.		].</body></methods><methods><class-id>Polymorphic.GFDrawing</class-id> <category>display</category><body package="GF/ST Base">display: aRectangle with: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Collect all host components and return a collection of them so that	their non-client areas can be updated later"	self displayVisibleAreaWith: aPen; displayGridIn: (aRectangle intersect: self preferredBounds) with: aPen.	 (graphicObjects conflict: aRectangle) do: [:each |		each display: aRectangle with: aPen	].</body><body package="GF/ST Base">displayGridIn: aRectangle with: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - display the grid of the receiver withing aRectangle"    | track bottomY grid rightX rect |    displayGrid ifFalse: [^self].    aPen        setStyle: 0        color: gridColor        width: 1.    aPen intersectClip: aRectangle.    rect := aRectangle expandBy: self grid.    grid := self grid.    track := (self snapToGrid: rect leftTop) x @ rect leftTop y.    bottomY :=  rect leftBottom y.    rect width // coordSystem grid x + 1 timesRepeat: [        aPen displayLineFrom: track to: (track x @ bottomY).        track x: (track x right: grid x)    ].    track := rect leftTop x @ (self snapToGrid: rect leftTop) y.    rightX := rect rightTop x.    rect height  // coordSystem grid y + 1 timesRepeat: [        aPen displayLineFrom: track to: (rightX @ track y).        track y: (track y down: grid y)    ].</body><body package="GF/ST Base">isVisible	^true</body></methods><methods><class-id>Polymorphic.GFDrawing</class-id> <category>uilayout</category><body package="GF/ST Base">subtreeNeedsLayout	container ifNotNil: #subtreeNeedsLayout</body></methods><methods><class-id>Polymorphic.GFDrawing class</class-id> <category>GF/ST</category><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the events triggered"    eventsTriggered isNil ifTrue: [        (eventsTriggered := Set new)            addAll: self superclass eventsTriggered;            add: #redraw;            add: #damageRegion.    ].    ^eventsTriggered</body></methods><methods><class-id>Polymorphic.GFConstraint</class-id> <category>GF/ST</category><body package="GF/ST Base">copyUsing: figures"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| newObjects newAction |	observedObjects notNil		ifTrue: [ 			newObjects := observedObjects copy.			1 to: observedObjects size do: [ :i | figures includesKey: (observedObjects at: i)					ifTrue: [ newObjects at: i put: (figures at: (observedObjects at: i))]]].	newAction := action copyUsing: figures.		^self class new privateAction: newAction forObjects: newObjects</body><body package="GF/ST Base">evaluate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^action evaluate</body><body package="GF/ST Base">evaluateWithArguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^action asPoint</body><body package="GF/ST Base">for: anAction on: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    action := anAction.    observedObjects := aCollection.    observedObjects do: [:each |        each            when: #damaged            evaluate: self    ]</body><body package="GF/ST Base">for: anAction on: aCollection event: event"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    action := anAction.    observedObjects := aCollection.    observedObjects do: [:each |        each            when: event            evaluate: self    ]</body><body package="GF/ST Base">privateAction: newAction forObjects: newObjects"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	action := newAction.	observedObjects := newObjects</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    observedObjects do: [:each |        each removeAction: self    ].    observedObjects := action := nil.</body></methods><methods><class-id>Polymorphic.GFConstraint class</class-id> <category>GF/ST</category><body package="GF/ST Base">for: anAction on: aCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new for: anAction on: aCollection</body><body package="GF/ST Base">for: anAction on: aCollection event: event"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new for: anAction on: aCollection event: event</body></methods><methods><class-id>Polymorphic.GFFloatingPalette</class-id> <category>private</category><body package="GF/ST Base">categoryAdaptorFor: cat"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(PluggableAdaptor on: self currentModeHolder)				getBlock: 					[:m | 					cat == palette activeCategory]				putBlock:					[:m :v |					self newCategory: cat value: v]				updateBlock: [:m :v :p | true]</body><body package="GF/ST Base">checkTools: newTool"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Keep in mind that at this point, activeTool is not really the active tool, it has not been updated yet.  The activeTool for the palette however IS set correctly."	activeTool ~~ nil			ifTrue: [ activeTool invalidate.					(self isSelectionTool: newTool) 					ifTrue: [ 						activeTool := (builder componentAt: #selectTool) widget.						activeTool invalidate ] ].	parent currentTool value: palette activeTool name.</body><body package="GF/ST Base">isSelectionActive"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self isSelectionTool: palette activeTool</body><body package="GF/ST Base">isSelectionTool: tool"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^tool name = 'Selection'</body><body package="GF/ST Base">newCategory: cat value: value"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| oldCat newCat |	oldCat := categories detect: [ :each | each isSelected ] ifNone: [ nil ].	self setSelectTool.	palette selectCategory: cat.	newCat := categories detect: [ :each | each isSelected ] ifNone: [ nil ].	oldCat == nil ifFalse: [ oldCat invalidateRectangle: oldCat bounds repairNow: true ].		newCat == nil ifFalse: [ newCat invalidateRectangle: newCat bounds repairNow: true ].	parent currentCategory value: cat name.	self populateTools: cat spec: (self class interfaceSpecFor: #iconPrototypeSpec)</body><body package="GF/ST Base">selectedTool: tool value: val"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| oldTool |	oldTool := tools detect: [ :each | each widget isSelected ] ifNone: [nil].	val 		ifTrue: [palette selectTool: tool]		ifFalse: [ self useSelectTool ].	oldTool == nil ifFalse: [ oldTool invalidateRectangle: oldTool bounds repairNow: true].	activeTool := tools detect: [ :each | each widget isSelected] ifNone: [nil].	activeTool == nil ifFalse: [activeTool invalidateRectangle: activeTool bounds repairNow: true].</body><body package="GF/ST Base">setCursor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	parent gfView controller cursor: palette activeTool cursor</body><body package="GF/ST Base">toolAdaptorFor: tool"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(PluggableAdaptor on: self currentModeHolder)				getBlock: 					[:m | 					palette activeTool == tool ]				putBlock:					[:m :v |					self selectedTool: tool value: v.					tool activate]				updateBlock: [:m :v :p | true]</body></methods><methods><class-id>Polymorphic.GFFloatingPalette</class-id> <category>accessing</category><body package="GF/ST Base">palette: aPalette"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	palette := aPalette.	palette when: #selectTool send: #checkTools: to: self</body><body package="GF/ST Base">parent: aParentWindow"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	parent := aParentWindow</body></methods><methods><class-id>Polymorphic.GFFloatingPalette</class-id> <category>private-icons</category><body package="GF/ST Base">activeSpecs"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	activeSpecs == nil ifTrue: [ activeSpecs := OrderedCollection new ].</body><body package="GF/ST Base">adaptButton: newButtonSpec toRepresent: cat"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Given aSpec and a prototype spec create a new spec for a 	button containing proper label and model. Add 	visual to the dictionary in builder."	| sName iconName |	sName := cat name.	iconName := (sName , 'Icon') asSymbol.	newButtonSpec model: sName asSymbol.	builder visualAt: iconName put: cat icon.	newButtonSpec label: iconName.	builder aspectAt: sName asSymbol put: (self adaptorFor: sName)</body><body package="GF/ST Base">adaptCategoryButton: newButtonSpec toRepresent: cat"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Given aSpec and a prototype spec create a new spec for a 	button containing proper label and model. Add 	visual to the dictionary in builder."	| sName iconName |	sName := cat name.	iconName := (sName , 'Icon') asSymbol.	newButtonSpec model: sName asSymbol.	builder visualAt: iconName put: cat icon.	newButtonSpec label: iconName.	builder aspectAt: sName asSymbol put: (self categoryAdaptorFor: cat)</body><body package="GF/ST Base">adaptToolButton: newButtonSpec toRepresent: tool"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Given aSpec and a prototype spec create a new spec for a 	button containing proper label and model. Add 	visual to the dictionary in builder."	| sName iconName |	sName := tool name.	iconName := (sName , 'Icon') asSymbol.	newButtonSpec model: sName asSymbol.	builder visualAt: iconName put: tool icon.	newButtonSpec label: iconName.	builder aspectAt: sName asSymbol put: (self toolAdaptorFor: tool)</body><body package="GF/ST Base">initializeCategories"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	categories := OrderedCollection new.</body><body package="GF/ST Base">numberOfColumns"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"The palette has fixed width == 2 icons"	^2</body><body package="GF/ST Base">populateSpec: prototypeSpec "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Replicate a prototype spec by creating clones and changing the layout.	Also send adapt&lt;Category|Tool&gt;Button:toRepresent: message to change	a button's properties.	For now the layout algorithm is two icons in a row in the window."	| w h  p  firstX rows middleOffset  rect |	self initializeCategories.	rect := (prototypeSpec layout rectangleRelativeTo: builder window bounds preferred: nil).	w := rect width.	h := rect height + 3.	middleOffset := -2 * (w + 1).	p := rect topLeft.	p x: p x - w.	firstX := p x.	palette categories		do: 			[:cat | 			| newButtonSpec |			newButtonSpec := prototypeSpec copy.			newButtonSpec layout: prototypeSpec layout copy.			(newButtonSpec layout) 				leftOffset: newButtonSpec layout leftOffset + p x - middleOffset;				rightOffset: newButtonSpec layout rightOffset + p x - middleOffset;				topOffset: newButtonSpec layout topOffset + p y;				bottomOffset: newButtonSpec layout bottomOffset + p y.			self adaptCategoryButton: newButtonSpec toRepresent: cat.			builder add: newButtonSpec.			categories add: builder component.			p := p + (0 @ h).			p x: firstX			].	rows := palette categories size.	palette categories do: [ :cat | 							(cat tools detect: [ :tool | self isSelectionTool: tool ] ifNone: [nil] ) == nil								ifTrue: [ rows := rows max: cat tools size]								ifFalse: [ rows := rows max: (cat tools size -1)] ].	rows := rows -1.	p := 0 @ ((rows * h) + 7).	p := builder window minimumSize + p.	p x: w * 2 + 10.	(builder window) changeExtent: p; minimumSize: p; maximumSize: p.	self newCategory: palette activeCategory value: true</body><body package="GF/ST Base">populateTools: cat spec: prototypeSpec "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Replicate a prototype spec by creating clones and changing the layout.	Also send adaptButton:toRepresent: message to chage button's properties.	For now the layout algorithm is three icons in a row centered in the window."	| w h p firstX middleOffset rect |	self resetTools.	(prototypeSpec layout)		leftFraction: 0.0;		rightFraction: 0.0.	rect := (prototypeSpec layout rectangleRelativeTo: builder window bounds preferred: nil).	w := rect width.	h := rect height + 3.	middleOffset := -2 * w - 4.	p := rect topLeft + (4@0).	p y: (builder componentAt: #iconView) bounds origin y + p y.	firstX := p x.	cat tools		do: 			[:tool | 			| newButtonSpec |			(self isSelectionTool: tool) ifFalse: [				newButtonSpec := prototypeSpec copy.				newButtonSpec layout: prototypeSpec layout copy.				(newButtonSpec layout) 					leftOffset: newButtonSpec layout leftOffset + p x - middleOffset;					rightOffset: newButtonSpec layout rightOffset + p x - middleOffset;					topOffset: newButtonSpec layout topOffset + p y;					bottomOffset: newButtonSpec layout bottomOffset + p y.				self adaptToolButton: newButtonSpec toRepresent: tool.				builder add: newButtonSpec.				tools add: builder wrapper.				p := p + (0 @ h).				p x: firstX				]			].	"rows := palette categories size max: tools size.	p := (w * 2 + 10) @ ((rows * h) + 7 + windowHeight).	box := builder window displayBox extent: p.	(builder window) minimumSize: p; maximumSize: p; displayBox: box"</body><body package="GF/ST Base">resetTools"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	tools == nil 		ifFalse: [tools do: [ :tool | 				CurrentMode removeDependent: tool widget model.				tool container remove: tool ]].	tools := OrderedCollection new.</body><body package="GF/ST Base">updateActiveSpecs"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self activeSpecs</body></methods><methods><class-id>Polymorphic.GFFloatingPalette</class-id> <category>actions</category><body package="GF/ST Base">setSelectTool"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	palette categories detect: [ :cat | | selectTool | 	(selectTool := (cat tools detect: [ :tool | self isSelectionTool: tool ] ifNone: [nil])) == nil 		ifTrue: [ false ]		ifFalse: [ palette selectTool: selectTool. true ] ].	activeTool := (builder componentAt: #selectTool) widget.	activeTool invalidate.</body><body package="GF/ST Base">useSelectTool"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This method is to be called by the selection button itself.	the only thing that it adds is to update the tool pane to indicate that	the selection tool is the currently active tool.  Right now, the categories	also put their descriptions in the toolName field which may be slightly 	misleading since you can have the selection tool be active, but not 	displayed as the currently active tool according to the toolName field"	| oldTool |	oldTool := tools detect: [ :each | each widget isSelected ] ifNone: [nil].	self setSelectTool.	oldTool == nil ifFalse: [ oldTool invalidate ].	parent currentTool value: palette activeTool name.</body></methods><methods><class-id>Polymorphic.GFFloatingPalette</class-id> <category>initialize-release</category><body package="GF/ST Base">initialize"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Make sure that toolName is in sync with	the current selection."	toolName := String new  asValue.	self currentModeHolder onChangeSend: #newSpec to: self.</body><body package="GF/ST Base">preBuildWith: aBuilder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Make sure that toolName is in sync with	the current selection."	self updateActiveSpecs.	self class currentMode: #{SelectModeTracker} value new. 	builder aspectAt: #Sticky put: UIPainterController stickyMode.	builder aspectAt: #select put:		((PluggableAdaptor on: self currentModeHolder)			getBlock: [:m | self isSelectionActive]			putBlock: 				[:m :v | 				self useSelectTool]			updateBlock: [:m :v :p | true]).</body></methods><methods><class-id>Polymorphic.GFFloatingPalette class</class-id> <category>resources</category><body package="GF/ST Base">iconPrototypeSpec"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a prototype of an action button. This spec is copied 	modified and populated on the palette's window."	^#(#ActionButtonSpec #layout: #(#LayoutFrame -19 0.0 1 0 19 0.0 38 0 ) #flags: 0 #name: #specIcon #tabable: false #hasCharacterOrientedLabel: false #isDecorated: true #defaultable: false)</body></methods><methods><class-id>Polymorphic.GFFloatingPalette class</class-id> <category>opening</category><body package="GF/ST Base">openUsingPalette: aPalette"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	(self new palette: aPalette) open.</body><body package="GF/ST Base">openUsingPalette: aPalette on: parent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| new builder |	new := self new.	new palette: aPalette.	new parent: parent.	builder := new allButOpenInterface: #windowSpec.	"OS/2 PM  can't make decorated windows narrower than 128 pixels."	(UIPainter preferenceFor: #hostWindowManager) value == #'OS/2 PM'		ifTrue:			[builder window changeExtent: 128@builder window bounds height.			builder window minimumSize x: 128.			builder window maximumSize x:128].	parent notNil		ifTrue: [builder openAt: (self palettePlaceNear: parent builder window for: builder window extent)]		ifFalse: [builder open].	builder window label: 'GF/ST'.	"MS Windows needs to be told twice if the window is thinner than 100	pixels."	(UIPainter preferenceFor: #hostWindowManager) value == #MSWindows		ifTrue:			[builder window displayBox: builder window displayBox].	^builder window</body></methods><methods><class-id>Polymorphic.GFConnectionHandle</class-id> <category>GF/ST</category><body package="GF/ST Base">connectTo: target in: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Connect the target in the context of the interface"    | aConnectionGO targetLocator |    targetLocator := locatorGenerationAction evaluateWith: target key with: target value.    aConnectionGO := connectAction evaluateWith: locator with: targetLocator.    anInterface hideHandlesWhile: [anInterface addGO: aConnectionGO].    anInterface storeMemento: (anInterface mementoForNewGO: aConnectionGO) for: anInterface.    ^aConnectionGO</body><body package="GF/ST Base">connectionPositionOf: aFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - The default way to find the connection location"    ^aFigure connectionPosition</body><body package="GF/ST Base">findTarget: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Find the target of the connection. Return an association with the GO 	as the key and the targetPoint as the value if a GO is targeted,  return	nil otherwise"    | aGO  myCenter aPen targetPoint color rect |    aPen := anInterface pen.    targetPoint := myCenter := self center.	color := GFGraphicObject defaultLineColor.	rect := 0@0 extent: 1@1.    anInterface trackMouse: [:newPoint |        anInterface            damageRegion: (rect := (Rectangle vertex: myCenter vertex: targetPoint)                                expandedByScalar: 2);            repairDamage.        aGO := findTargetAction                        evaluateWithArguments: (Array with: anInterface with: newPoint).        targetPoint := (aGO isNil                                    ifTrue: [newPoint]                                    ifFalse: [targetPositionAction evaluateWith: aGO]).        aPen            setStyle: 0			color: color			width: 1;            displayLineFrom: myCenter to: targetPoint.    ].    anInterface        damageRegion: rect;        repairDamage.    aGO isNil ifTrue: [^nil].    ^Association key: aGO value: targetPoint</body><body package="GF/ST Base">graphicObjectIn: anInterface at: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - The default way to find a graphic object to connect to"    ^anInterface graphicObjectAt: aPoint</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    super initialize.    snapToGrid := false.    description := 'connection'.    findTargetAction := self class gfMessageClass                                        receiver: self                                        selector: #graphicObjectIn:at:.    targetPositionAction := self class gfMessageClass                                            receiver: self                                            selector: #connectionPositionOf:.    connectAction := self class gfMessageClass                                    receiver: GFDependentLineGO                                    selector: #startLocation:stopLocation:.    locatorGenerationAction :=  self class gfMessageClass                                                    receiver: self                                                    selector: #locatorFor:at:.</body><body package="GF/ST Base">locatorFor: aGO at: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - The default way to acquire a locator for aGO"    ^aGO locator</body><body package="GF/ST Base">setConnectAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the action to be evaluated that produces a connection graphic     object.  The action accepts two arguments, the start location     and the stop location.    "    connectAction := anAction</body><body package="GF/ST Base">setConnectedAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the action to be evaluatd after the connection has been     made.  The action accepts two arguments, the connection     produced by the connectAction, and the location produced     by the locationGenerationAction.    "    connectedAction := anAction</body><body package="GF/ST Base">setFindTargetAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the action to be evaluated that finds the target graphic object.     The action accepts two arguments, the GFDrawingInterface and     the target point currently under the mousePoint.    "    findTargetAction := anAction</body><body package="GF/ST Base">setLocatorGenerationAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the action to be evaluated that produces a locator     for the stop location.  The action accepts two arguments,     the graphic object, and the target point under the mouse point    "    locatorGenerationAction := anAction</body><body package="GF/ST Base">setTargetPositionAction: anAction"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the action to be evaluated that returns the target position     of the connection.  The action accepts two arguments, the     graphic object to be connected, and the target point under     the mouse point.    "    targetPositionAction := anAction</body><body package="GF/ST Base">trackMouse: anInterface"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | target connection |    target := self findTarget: anInterface.    target isNil ifTrue: [^anInterface showHandles].    connection := self connectTo: target in: anInterface.    connectedAction isNil ifFalse: [        connectedAction            evaluateIfNoTarget: self owner            withArguments: (Array with: connection with: target key)    ]</body></methods><methods><class-id>Polymorphic.GFPositionConstraint</class-id> <category>GF/ST</category><body package="GF/ST Base">copyUsing: figures"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"It is assumed that the receiver of this constraint and 	its locator are in the figures dictionary.  If they are	not, then this constraint should not be copied"	| newReceiver newLocatorReceiver newLocator newConstraint |	newReceiver := figures at: receiver ifAbsent: [ nil ].	newLocatorReceiver := figures at: location receiver ifAbsent: [ nil ].	(newReceiver == nil or: [ newLocatorReceiver == nil ]) ifTrue: [ ^nil ].	newLocator := location copyUsing: figures.	newConstraint := self class location: newLocator receiver: newReceiver sending: (settingMessage copyUsing: figures).	newReceiver replaceConstraint: self with: newConstraint.	^newConstraint</body><body package="GF/ST Base">evaluate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    receiver damageDuring: [        receiver perform: settingMessage with: location asPoint.    ].</body><body package="GF/ST Base">evaluateWithArguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self evaluate</body><body package="GF/ST Base">location: lctn receiver: rcvr sending: selector"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    location := lctn.    receiver := rcvr.    settingMessage := selector.</body><body package="GF/ST Base">locator"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the locator for the receiver"    ^location</body><body package="GF/ST Base">receiver"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^receiver</body><body package="GF/ST Base">receiver: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    receiver := anObject</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    location == nil ifFalse: [ location receiver removeAction: self ].    location := receiver := settingMessage := nil</body><body package="GF/ST Base">selector"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^settingMessage</body></methods><methods><class-id>Polymorphic.GFPositionConstraint class</class-id> <category>GF/ST</category><body package="GF/ST Base">location: lctn receiver: rcvr sending: msg"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^self new location: lctn receiver: rcvr sending: msg</body></methods><methods><class-id>Polymorphic.GFDrawingActionTool</class-id> <category>GF/ST</category><body package="GF/ST Base">activate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "When GFDrawingActionTools are activated, their activateBlock gets evaluated with the    Drawing as an argument."    activateBlock value: interface drawing.</body><body package="GF/ST Base">activateBlock: aBlock deactivateBlock: dBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    activateBlock := aBlock.    deactivateBlock := dBlock</body><body package="GF/ST Base">button1DownBackground"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Do the same thing as when I am activated."    self activate</body><body package="GF/ST Base">button1DownGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Do the same thing as when I am activated."    self activate</body><body package="GF/ST Base">deactivate"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "When GFDrawingActionTools are deactivated, their deactivateBlock gets evaluated with the    Drawing as an argument."    deactivateBlock value: interface drawing.</body></methods><methods><class-id>Polymorphic.GFPaneController</class-id> <category>event dispatching</category><body package="GF/ST Base">activateControlLoop"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This is a flag to be used as an indication that when 	a double click event (or something similar) is registered 	via some means (i.e. #downcastEvent* ) other than 	provided by the superclass, WidgetController.  This will 	start off the controlLoop body.  This method also has the 	responsibility of starting the controlLoopBoby if there is 	a 'pendingEvent'.  So far, the definition of a pending 	event is a doubleclick event that has not been reset"	activateControlLoop := true.	self pendingEventPeek		ifTrue: [ self controlLoopBody ].</body><body package="GF/ST Base">checkAndResetDoubleClick	"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| event |	view ifNotNil: 			[| manager |			manager := view topComponent windowManager.			manager hasPendingEvents 				ifTrue: 					[| ev |					(ev := manager eventQueue next) isDoubleClickEvent 						ifTrue: [doubleClickEvent := ev]]].	^doubleClickEvent 		ifNil: [nil]		ifNotNil: 			[event := doubleClickEvent.			doubleClickEvent := nil.			event]</body><body package="GF/ST Base">deactivateControlLoop"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"please see the comments for #activateControlLoop for	a more complete description of the usage of this flag"	activateControlLoop := false</body><body package="GF/ST Base">doubleClickEventPeek"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^doubleClickEvent ~~ nil</body><body package="GF/ST Base">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	aKey == #doubleClick		ifTrue: [ self setDoubleClickAt: aPoint.				^true].	^super downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator</body><body package="GF/ST Base">pendingEventPeek"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self doubleClickEventPeek</body><body package="GF/ST Base">processKeyboardEvent: ev"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^view processKeyboard: ev</body><body package="GF/ST Base">setDoubleClickAt: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	doubleClickEvent := #doubleClick-&gt;aPoint. 	activateControlLoop == true		ifTrue: [ self controlLoopBody ].</body></methods><methods><class-id>Polymorphic.GFPaneController</class-id> <category>control</category><body package="GF/ST Base">activate"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"</body><body package="GF/ST Base">buttonPressed"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self doubleClickEventPeek or: [ super buttonPressed ]</body><body package="GF/ST Base">controlLoopBody"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	" Reimplement the control loop	so that we can provide	keyboard information. "	self sensor keyboardPressed		ifTrue: [ view processKeyboard: self sensor keyboardEvent ]		ifFalse: [ self privateControlLoopBody ]</body><body package="GF/ST Base">deactivate"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"</body><body package="GF/ST Base">privateControlLoopBody"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	" Reimplement the control loop	so that we can provide	mouse button transition information. "	| previousState state |	state := self buttonPressed.	state ifTrue:		[" Signal start of control with button down.		Assume the button just went down. "		self doubleClickEventPeek			ifTrue: [ | ev | 				ev := self checkAndResetDoubleClick.				controlBlock 					value: ev value					value: ev key.				[self sensor anyButtonPressed] whileTrue: [].]			ifFalse: [					controlBlock					value: self sensor cursorPoint					value: #down]].	[previousState := state.	self poll.	state := self buttonPressed.	controlBlock		value: self sensor cursorPoint		value: (state				ifTrue: [previousState ifTrue: [#down] ifFalse: [#wentDown]]				ifFalse: [previousState ifTrue: [#wentUp] ifFalse: [#up]]).	self isControlActive]		whileTrue.	state ifTrue:		[" Signal end of control with button down. "		controlBlock			value: self sensor cursorPoint			value: #up]</body><body package="GF/ST Base">testForControl"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(evenIfKeyPressed or: [self sensor keyboardPressed not])		and: [self sensor blueButtonPressed not		and: [(enableYellowButton or: [self sensor yellowButtonPressed not])		and: [self view topComponent controller isControlActive]]]</body></methods><methods><class-id>Polymorphic.GFPaneController</class-id> <category>private</category><body package="GF/ST Base">flushCoordinateCaches"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| pressed |	pressed := evenIfKeyPressed.	super flushCoordinateCaches.	pressed notNil ifTrue: [ evenIfKeyPressed := pressed ].</body><body package="GF/ST Base">redButtonPressed"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self sensor redButtonPressed</body></methods><methods><class-id>Polymorphic.GFPaneController</class-id> <category>accessing</category><body package="GF/ST Base">evenIfKeyPressed: aBoolean"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	evenIfKeyPressed := aBoolean</body></methods><methods><class-id>Polymorphic.GFPaneController</class-id> <category>event driven</category><body package="GF/ST Base">doubleClickEvent: event 	event redButtonPressed ifFalse: [^nil].	self isActive ifTrue: 		[controlBlock 			value: (self sensor mousePointFor: event)			value: #doubleClick]</body><body package="GF/ST Base">yellowButtonPressedEvent: event 	(self isActive and: [enableYellowButton])		ifTrue: [^view button2Down: (self sensor mousePointFor: event)]</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>accessing</category><body package="GF/ST Base">end"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	^end</body><body package="GF/ST Base">endDirection: aDirection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the end direction.  Note!  aDirection must be one of the class variable	 constants in this class"	endDirection := aDirection</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the points the receiver should snap to the grid used by	 the receiver.	 Subclasses should override this to implement their own behavior	 towards the grid	"	^Array		with: start		with: end</body><body package="GF/ST Base">start: sPoint direction: sDir end: ePoint direction: eDir"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	start := sPoint.	startDirection := sDir.	end := ePoint.	endDirection := eDir.	self connect.</body><body package="GF/ST Base">startDirection: aDirection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the start direction.  Note!  aDirection must be one of the class variable	 constants in this class"	startDirection := aDirection</body><body package="GF/ST Base">startDirection: sDir endDirection: eDir"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	self damageDuring: [			startDirection := sDir.			endDirection := eDir ].</body><body package="GF/ST Base">startPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^start asPoint</body><body package="GF/ST Base">startPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	start := aPoint</body><body package="GF/ST Base">stopPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^end asPoint</body><body package="GF/ST Base">stopPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	end := aPoint</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>menus</category><body package="GF/ST Base">appendPolyLineItemsTo: aMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Append the poly line specific items to aMenu"    ^aMenu</body><body package="GF/ST Base">flipMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the menu for the flip options"    ^Menu new		addItemLabel: 'flip vertical' value: (MessageSend receiver: self selector: #flipVertical);		addItemLabel: 'flip horizontal' value: (MessageSend receiver: self selector: #flipHorizontal);		yourself</body><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    ^super standardMenu        addItemGroup: (Array with: ((MenuItem labeled:'Start Direction') submenu: self startDirectionMenu));        addItem: ((MenuItem labeled:'Stop Direction') submenu: self stopDirectionMenu);        addItem: ((MenuItem labeled:'Flip') submenu: self flipMenu);        yourself.</body><body package="GF/ST Base">startDirectionMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    ^Menu new        addItemLabel: 'from left' value: (MessageSend receiver: self selector: #leftStart);        addItemLabel: 'from right' value: (MessageSend receiver: self selector: #rightStart);        addItemLabel: 'from top' value: (MessageSend receiver: self selector: #topStart);        addItemLabel: 'from bottom' value: (MessageSend receiver: self selector: #bottomStart);        yourself</body><body package="GF/ST Base">stopDirectionMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    ^Menu new		addItemLabel: 'from left' value: (MessageSend receiver: self selector: #leftStop);		addItemLabel: 'from right' value: (MessageSend receiver: self selector: #rightStop);		addItemLabel: 'from top' value: (MessageSend receiver: self selector: #topStop);		addItemLabel: 'from bottom' value: (MessageSend receiver: self selector: #bottomStop);		yourself</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>mementos</category><body package="GF/ST Base">attributeInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the collection of attribute information"	^(super attributeInformation)			add: (self class gfMessageClass						receiver: nil						selector:  #startDirection:endDirection:						arguments: (Array with: startDirection with: endDirection));			 yourself</body><body package="GF/ST Base">resetPoints: pts"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Reset the points of the receiver to a listOfPoints"	start := pts at: 1.	startDirection := pts at: 2.	end := pts at: 3.	endDirection := pts at: 4.</body><body package="GF/ST Base">storagePoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the points relevant to position information"	^Array with: start copy with: startDirection with: end copy with: endDirection</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>private</category><body package="GF/ST Base">connect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Calculate the line segments of the receiver"	self quietlyConnect.	self triggerEvent: #damaged.</body><body package="GF/ST Base">connectBottom: transformedPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	transformedPoint y &gt; 0			ifTrue: [self shape4PD: transformedPoint]			ifFalse: [self shape6P: transformedPoint sign: -1]</body><body package="GF/ST Base">connectLeft: transformedPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	(transformedPoint y &gt; 0)			ifTrue: [				(transformedPoint x &gt; 0)					ifTrue: [self shape3P: transformedPoint]					ifFalse: [self shape5PB: transformedPoint sign: -1]			]			ifFalse: [self shape5PB: transformedPoint sign: -1]</body><body package="GF/ST Base">connectRight: transformedPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	transformedPoint y &gt; 0			ifTrue: [				transformedPoint x &gt; 0					ifTrue: [self shape5PB: transformedPoint sign: 1]					ifFalse: [self shape3P: transformedPoint]			]			ifFalse: [self shape5PB: transformedPoint sign: 1]</body><body package="GF/ST Base">connectTop: transformedPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	(transformedPoint x &lt; -20 or: [transformedPoint x &gt; 20])			ifTrue: [self shape4PU: transformedPoint]			ifFalse: [self shape6P: transformedPoint sign: 1]</body><body package="GF/ST Base">directTransform: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Translates and rotates aPoint according to the endDirection"	| sPoint |	sPoint := start asPoint.	startDirection == Left ifTrue: [		^(aPoint y - sPoint y) @ (sPoint x - aPoint x)	].	startDirection == Right ifTrue: [		^(sPoint y - aPoint y) @ (aPoint x - sPoint x)	].	startDirection == Bottom ifTrue: [		^(aPoint x - sPoint x) @ (aPoint y - sPoint y)	].	"startDirection must be: Top"	^(sPoint x - aPoint x) @ (sPoint y - aPoint y).</body><body package="GF/ST Base">inverseTransform: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Translates and rotates aPoint according to the outPadDirection"	| sPoint |	sPoint := start asPoint.	startDirection == Left ifTrue: [		^aPoint			x: sPoint x - aPoint y			y: sPoint y + aPoint x	].	startDirection == Right ifTrue: [		^aPoint			x: sPoint x + aPoint y			y: sPoint y - aPoint x	].	startDirection == Bottom ifTrue: [		^aPoint		x: sPoint x + aPoint x		y: sPoint y + aPoint y	].	"startDirection must be: Top"	^aPoint			x: sPoint x - aPoint x			y: sPoint y - aPoint y.</body><body package="GF/ST Base">quietlyConnect"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Calculate the line segments of the receiver"	self		perform: ((ConnectionDirections at: startDirection) at: endDirection)		with: (self directTransform: end asPoint).	1 to: points size do: [:i | self inverseTransform: (points at: i)].	self quietlyRecalculateBoundingBox</body><body package="GF/ST Base">shape3P: tPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	points := Array with: (0 @ 0) with: (0 @ tPoint y) with: tPoint.</body><body package="GF/ST Base">shape4PD: tPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	points := Array with: (0 @ 0) with: (0 @ 12) with: (tPoint x @ 12) with: tPoint.</body><body package="GF/ST Base">shape4PU: tPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	points := Array					with: (0 @ 0)					with: (tPoint y &lt;= 0 ifTrue: [0 @ 12] ifFalse: [0 @ (tPoint y + 12)])					with: (tPoint y &lt;= 0 ifTrue: [tPoint x @ 12] ifFalse: [tPoint x @ (tPoint y + 12)])					with: tPoint.</body><body package="GF/ST Base">shape5PB: tPoint sign: sign"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	points := Array new: 5.	points		at: 1 put: (0 @ 0);		at: 2 put: (0 @ 12).	(sign * tPoint x &lt; 20)		ifTrue: [points at: 3 put: (sign * 12 + tPoint x @ 12)]		ifFalse: [			sign * tPoint x &lt; 0				ifTrue: [points at: 3 put: (sign * 12) @ 12]				ifFalse: [points at: 3 put: (sign * 12 + tPoint x) @ 12].		].	points		at: 4 put: (points at: 3) x @ tPoint y;		at: 5 put: tPoint</body><body package="GF/ST Base">shape5PT: tPoint sign: sign"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	points := Array new: 5.	points		at: 1 put: (0 @ 0);		at: 2 put: (0 @ 12);		at: 3 put: (12 * sign + tPoint x @ 12);		at: 4 put: (points at: 2) x @ tPoint y;		at: 5 put: tPoint</body><body package="GF/ST Base">shape6P: tPoint sign: sign"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"	| xM |	xM := tPoint x // 2.	points := Array new: 6.	points		at: 1 put: (0 @ 0);		at: 2 put: (0 @ 12).	tPoint y &lt; 0		ifTrue: [			tPoint x &gt; 0				ifTrue: [					xM abs &gt; 20						ifTrue: [points at: 3 put: xM @ 12]						ifFalse: [points at: 3 put: 20 @ 12]				]				ifFalse: [					xM abs &gt; 20						ifTrue: [points at: 3 put: xM @ 12]						ifFalse: [points at: 3 put: -20 @ 12]				]		]		ifFalse: [			tPoint x &gt; 0				ifTrue: [					xM &gt; 20						ifTrue: [points at: 3 put: xM @ 12]						ifFalse: [points at: 3 put: -20 @ 12]				]				ifFalse: [					xM &gt; 20						ifTrue: [points at: 3 put: xM @ 12]						ifFalse: [points at: 3 put: 20 @ 12]				]		].	points		at: 4 put: (points at: 3) x @ (sign * 12 + tPoint y);		at: 5 put: tPoint x @ (points at: 4) y;		at: 6 put: tPoint.</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>copying</category><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Perform any additional action after copy."	super postCopy.	start := start copy.	end := end copy.</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>translation</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Translate the receiver by aPoint"	super basicTranslateBy: aPoint.	start translatedByPoint: aPoint.	end translatedByPoint: aPoint.</body><body package="GF/ST Base">moveStartBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the start point by a deltaPoint"	self damageDuring: [start translatedByPoint: deltaPoint].	self triggerEvent: #moveStart</body><body package="GF/ST Base">moveStopBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the stop point by a deltaPoint"	self damageDuring: [end translatedByPoint: deltaPoint].	self triggerEvent: #moveEnd</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>state manipulation</category><body package="GF/ST Base">bottomStart"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the start direction from the bottom"	self storeMemento: self attributeMemento for: self.	self damageDuring: [startDirection := Bottom].</body><body package="GF/ST Base">bottomStop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the stop direction from the bottom"	self storeMemento: self attributeMemento for: self.	self damageDuring: [endDirection := Bottom].</body><body package="GF/ST Base">flipHorizontal"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self storeMemento: self attributeMemento for: self.	self damageDuring: [		startDirection := (Array with: Right with: Left with: Bottom with: Top) at: startDirection.		endDirection := (Array with: Right with: Left with: Bottom with: Top) at: endDirection.	].</body><body package="GF/ST Base">flipVertical"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self storeMemento: self attributeMemento for: self.	self damageDuring: [		startDirection := (Array with: Left with: Right with: Top with: Bottom) at: startDirection.		endDirection := (Array with: Left with: Right with: Top with: Bottom) at: endDirection.	].</body><body package="GF/ST Base">leftStart"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the start direction from the left"	self storeMemento: self attributeMemento for: self.	self damageDuring: [startDirection := Left]</body><body package="GF/ST Base">leftStop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the stop direction from the left"	self storeMemento: self attributeMemento for: self.	self damageDuring: [endDirection := Left]</body><body package="GF/ST Base">makeClosed"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the reeiver a closed polyline"	"should not make closed"	^self</body><body package="GF/ST Base">makeOpen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the reeiver an open polyline"	"should not make open (it should already be open)"	^self</body><body package="GF/ST Base">rightStart"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the start direction from the right"	self storeMemento: self attributeMemento for: self.	self damageDuring: [startDirection := Right]</body><body package="GF/ST Base">rightStop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the stop direction from the right"	self storeMemento: self attributeMemento for: self.	self damageDuring: [endDirection := Right]</body><body package="GF/ST Base">topStart"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the start direction from the top"	self storeMemento: self attributeMemento for: self.	self damageDuring: [startDirection := Top]</body><body package="GF/ST Base">topStop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the stop direction from the top"	self storeMemento: self attributeMemento for: self.	self damageDuring: [endDirection := Top]</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>damaging</category><body package="GF/ST Base">damaged"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Signal that the entire area of the receiver has been damaged"	self quietlyConnect.	^super damaged</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>queries</category><body package="GF/ST Base">checkClosed"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - this has the side effect of setting the closed instVar"	"by definition, this is not a closed shape"	^false</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"		^Array with: ((GFTrackHandle						on: self						at: #startPoint						change: #moveStartBy:)							mementoType: #positionMemento;							description: 'move start position')				with: ((GFTrackHandle								on: self								at: #stopPoint								change: #moveStopBy:)									mementoType: #positionMemento;									description: 'move stop position')</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO class</class-id> <category>instance creation</category><body package="GF/ST Base">arrowStartLocation: startLocation direction: startDirection stopLocation: stopLocation direction: stopDirection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						start: startLocation						direction: startDirection asPoint						stop: stopLocation						direction: stopDirection asPoint.	aFigure stopPlug: aFigure endArrowPlug.	startLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: startLocation receiver: aFigure sending: #startPoint:).	stopLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #stopPoint:).	^aFigure</body><body package="GF/ST Base">arrowStartLocationBottom: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Bottom						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">arrowStartLocationBottom: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Bottom						stopLocation: stopLocation asPoint						direction: Left.	^aFigure</body><body package="GF/ST Base">arrowStartLocationBottom: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Bottom						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">arrowStartLocationBottom: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Bottom						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">arrowStartLocationLeft: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">arrowStartLocationLeft: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Left.	^aFigure</body><body package="GF/ST Base">arrowStartLocationLeft: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">arrowStartLocationLeft: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">arrowStartLocationRight: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">arrowStartLocationRight: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Left.	^aFigure</body><body package="GF/ST Base">arrowStartLocationRight: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">arrowStartLocationRight: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">arrowStartLocationTop: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">arrowStartLocationTop: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Left.	^aFigure</body><body package="GF/ST Base">arrowStartLocationTop: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">arrowStartLocationTop: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						arrowStartLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">bottomStart: start bottomStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Bottom			end: stop			direction: Bottom)</body><body package="GF/ST Base">bottomStart: start leftStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Bottom			end: stop			direction: Left)</body><body package="GF/ST Base">bottomStart: start rightStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Bottom			end: stop			direction: Right)</body><body package="GF/ST Base">bottomStart: start topStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Bottom			end: stop			direction: Top)</body><body package="GF/ST Base">createArrowNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| startPoint stopPoint aPen startDir stopDir go |	startPoint := stopPoint := anInterface cursorPoint.	(aPen := anInterface pen)		setForeColorTo: self defaultLineColor;		displayLineFrom: startPoint to: stopPoint.	startDir := #top.	startDir == nil ifTrue: [^self].	anInterface trackMouse: [:newPoint |		anInterface drawing damageRegion:			((startPoint rectangleWith: stopPoint)				expandedByPoint: 2 @ 2).		anInterface repairDamage.		aPen 			setForeColorTo: self defaultLineColor;			displayLineFrom: startPoint to: (stopPoint := newPoint).	].	stopDir := #left.	stopDir == nil ifTrue: [^nil].	startPoint = stopPoint ifFalse: [		go := self					perform: (startDir, 'Start:', stopDir, 'Stop:') asSymbol					with: startPoint					with: stopPoint.		go stopPlug: go endArrowPlug.		^go	].	^nil</body><body package="GF/ST Base">createNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| startPoint stopPoint aPen startDir stopDir |	startPoint := stopPoint := anInterface cursorPoint.	(aPen := anInterface pen)		setForeColorTo: self defaultLineColor;		displayLineFrom: startPoint to: stopPoint.	startDir := #top.	startDir == nil ifTrue: [^self].	anInterface trackMouse: [:newPoint |		anInterface drawing damageRegion:			((startPoint rectangleWith: stopPoint)				expandedByPoint: 2 @ 2).		anInterface repairDamage.		aPen 			setForeColorTo: self defaultLineColor;			displayLineFrom: startPoint to: (stopPoint := newPoint).	].	stopDir := #left.	stopDir == nil ifTrue: [^nil].	startPoint = stopPoint ifFalse: [		^self			perform: (startDir, 'Start:', stopDir, 'Stop:') asSymbol			with: startPoint			with: stopPoint	].	^nil</body><body package="GF/ST Base">leftStart: start bottomStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Left			end: stop			direction: Bottom)</body><body package="GF/ST Base">leftStart: start leftStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Left			end: stop			direction: Left)</body><body package="GF/ST Base">leftStart: start rightStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Left			end: stop			direction: Right)</body><body package="GF/ST Base">leftStart: start topStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Left			end: stop			direction: Top)</body><body package="GF/ST Base">rightStart: start bottomStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Right			end: stop			direction: Bottom)</body><body package="GF/ST Base">rightStart: start leftStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Right			end: stop			direction: Left)</body><body package="GF/ST Base">rightStart: start rightStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Right			end: stop			direction: Right)</body><body package="GF/ST Base">rightStart: start topStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Right			end: stop			direction: Top)</body><body package="GF/ST Base">start: start direction: startDirection stop: stop direction: stopDirection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: startDirection			end: stop			direction: stopDirection)</body><body package="GF/ST Base">startLocation: startLocation direction: startDirection stopLocation: stopLocation direction: stopDirection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						start: startLocation						direction: startDirection asPoint						stop: stopLocation						direction: stopDirection asPoint.	startLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: startLocation receiver: aFigure sending: #startPoint:).	stopLocation receiver		when: #damaged		evaluate: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #stopPoint:).	^aFigure</body><body package="GF/ST Base">startLocationBottom: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Bottom						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">startLocationBottom: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Bottom						stopLocation: stopLocation asPoint						direction: Left.	^aFigure</body><body package="GF/ST Base">startLocationBottom: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Bottom						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">startLocationBottom: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Bottom						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">startLocationLeft: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">startLocationLeft: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Left.	^aFigure</body><body package="GF/ST Base">startLocationLeft: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">startLocationLeft: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Left						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">startLocationRight: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">startLocationRight: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Left.	^aFigure</body><body package="GF/ST Base">startLocationRight: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">startLocationRight: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Right						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">startLocationTop: startLocation stopLocationBottom: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Bottom.	^aFigure</body><body package="GF/ST Base">startLocationTop: startLocation stopLocationLeft: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Left.	^aFigure</body><body package="GF/ST Base">startLocationTop: startLocation stopLocationRight: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Right.	^aFigure</body><body package="GF/ST Base">startLocationTop: startLocation stopLocationTop: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						startLocation: startLocation						direction: Top						stopLocation: stopLocation						direction: Top.	^aFigure</body><body package="GF/ST Base">topStart: start bottomStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Top			end: stop			direction: Bottom)</body><body package="GF/ST Base">topStart: start leftStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Top			end: stop			direction: Left)</body><body package="GF/ST Base">topStart: start rightStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Top			end: stop			direction: Right)</body><body package="GF/ST Base">topStart: start topStop: stop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^(self new			start: start			direction: Top			end: stop			direction: Top)</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO class</class-id> <category>accessing</category><body package="GF/ST Base">arrowCreationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver"	^(GFCreationTool		icon: (GFTool stockIconFor: 'OrthogonalArrow')		cursor: self gfCursorClass crossHair		class: self		name: 'Orthogonal Arrow') setCreationSelector: #createArrowNotifying: ; yourself</body><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver"	^GFCreationTool		icon: (GFTool stockIconFor: 'OrthogonalPath')		cursor: self gfCursorClass crossHair		class: self		name: 'Orthogonal Path'</body><body package="GF/ST Base">directionBottom"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^Bottom</body><body package="GF/ST Base">directionLeft"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^Left</body><body package="GF/ST Base">directionRight"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^Right</body><body package="GF/ST Base">directionTop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^Top</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the events triggered"	eventsTriggered isNil ifTrue: [		(eventsTriggered := Set new)			addAll: self superclass eventsTriggered;			add: #moveStart;			add: #moveEnd.	].	^eventsTriggered</body></methods><methods><class-id>Polymorphic.GFOrthogonalPathGO class</class-id> <category>initialization</category><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"GFOrthogonalPathGO initialize"	ConnectionDirections := Array new: 4.	ConnectionDirections		at: 1 put: #(connectTop: connectBottom: connectRight: connectLeft:);		at: 2 put: #(connectBottom: connectTop: connectLeft: connectRight:);		at: 3 put: #(connectLeft: connectRight: connectTop: connectBottom:);		at: 4 put: #(connectRight: connectLeft: connectBottom: connectTop:).	Left := 1.	Right := 2.	Bottom := 3.	Top := 4.</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>accessing</category><body package="GF/ST Base">connectedObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether or not the receiver represents a connection between	 two graphic objects	"	^Array 		with: self startObject		with: self stopObject</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the points the receiver should snap to the grid used by	 the receiver.	 Subclasses should override this to implement their own behavior	 towards the grid	"	"Dependent lines should only be altered by the constraints"	^Array new</body><body package="GF/ST Base">setStartConstraint: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	startConstraint := anObject</body><body package="GF/ST Base">setStopConstraint: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	stopConstraint := anObject</body><body package="GF/ST Base">startConstraint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^startConstraint</body><body package="GF/ST Base">startConstraint: aConstraint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	startConstraint := aConstraint</body><body package="GF/ST Base">startObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the graphic object connected to the start of the receiver"	^startConstraint locator receiver</body><body package="GF/ST Base">startObject: startObj stopObject: stopObj"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| startLocator stopLocator |	self 		setStartConstraint:			(GFPositionConstraint				location: (startLocator := ((startConstraint locator copy) receiver: startObj))				receiver: self				sending: startConstraint selector);		setStopConstraint:			(GFPositionConstraint				location: (stopLocator := ((stopConstraint locator copy) receiver: stopObj))				receiver: self				sending: stopConstraint selector).	startObj		when: #damaged		evaluate: startConstraint.	stopObj		when: #damaged		evaluate: stopConstraint.</body><body package="GF/ST Base">startPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	super startPoint: aPoint.	self triggerEvent: #moveStart</body><body package="GF/ST Base">stopConstraint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^stopConstraint</body><body package="GF/ST Base">stopConstraint: aConstraint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	stopConstraint := aConstraint</body><body package="GF/ST Base">stopObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the graphic object connected to the stop of the receiver"	^stopConstraint locator receiver</body><body package="GF/ST Base">stopPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	super stopPoint: aPoint.	self triggerEvent: #moveEnd</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>mementos</category><body package="GF/ST Base">becomeConnectorType: connectionClass selector: sel"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver to the connection class using the selector	  to set the stop and end points	"	| startLocator stopLocator newPath |	startLocator := startConstraint locator.	stopLocator := stopConstraint locator.	startLocator receiver release: startConstraint.	stopLocator receiver release: stopConstraint.	newPath := connectionClass perform: sel withArguments: (Array with: startLocator with: stopLocator).	newPath width: width.	newPath color: color.	container add: newPath.	self insert: newPath.	self container remove: self.	self unlink.	newPath damaged; redraw.	^newPath</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the position information of the receiver"	^(super positionInformation)		add: (self class gfMessageClass receiver: nil selector: #startConstraint: arguments: (Array with: startConstraint copy));		add: (self class gfMessageClass receiver: nil selector: #stopConstraint: arguments: (Array with: stopConstraint copy));		add: (self class gfMessageClass receiver: nil selector: #restoreConstraints);		yourself</body><body package="GF/ST Base">restoreConstraints"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	startConstraint locator receiver release: self.	stopConstraint locator receiver release: self.	startConstraint locator receiver			when: #damaged			evaluate: startConstraint.	stopConstraint locator receiver			when: #damaged			evaluate: stopConstraint.</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>translation</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Ignore this message - the only way to move me is to move my end points"</body><body package="GF/ST Base">moveStartBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the start point by a deltaPoint"	"Ignore this message - the only way to move me is to move my end points"</body><body package="GF/ST Base">moveStopBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the stop point by a deltaPoint"	"Ignore this message - the only way to move me is to move my end points"</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>transformation</category><body package="GF/ST Base">becomeDependentArrow"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver into a dependent arrow"	| state newPath |	state := OrderedCollection new.	self preTransformInfoInto: state.	newPath := self becomeConnectorType: GFDependentLineGO							  selector: #arrowStartLocation:stopLocation: .	self postTransformInfoInto: state using: newPath.	^newPath</body><body package="GF/ST Base">becomeDependentLine"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Transform the receiver into a dependent line"    | state newPath |    state := OrderedCollection new.    self preTransformInfoInto: state.    newPath := self becomeConnectorType: GFDependentLineGO                              selector: #startLocation:stopLocation: .    self postTransformInfoInto: state using: newPath.    ^newPath</body><body package="GF/ST Base">becomeDependentOrthogonalArrow"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver into a dependent orthogonal arrow"	| state newPath |	state := OrderedCollection new.	self preTransformInfoInto: state.	newPath :=self becomeConnectorType: GFDependentOrthogonalPathGO						 selector: #arrowStartLocationRight:stopLocationLeft: .	newPath startDirection: startDirection endDirection: endDirection.	self postTransformInfoInto: state using: newPath.	^newPath</body><body package="GF/ST Base">becomeDependentOrthogonalPath"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver into a dependent orthogonal path"	| state newPath |	stopPlug == nil ifTrue: [^self].	state := OrderedCollection new.	self preTransformInfoInto: state.	newPath :=self becomeConnectorType: GFDependentOrthogonalPathGO						 selector: #startLocationRight:stopLocationLeft: .	newPath startDirection: startDirection endDirection: endDirection.	self postTransformInfoInto: state using: newPath.	^newPath</body><body package="GF/ST Base">postTransformInfoInto: state using: newPath"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set up the memento that can restore the previous go back after the	 transformation	"	| mem |	(mem := GFMemento originator: newPath interface)		addActionReceiver: newPath			selector: #willDamage;		addActionReceiver: newPath container			 selector: #remove:			  with: newPath;		   addActionReceiver: newPath			  selector: #release.	state do: [ :action | mem addAction: action ].	newPath interface storeMemento: mem for: newPath interface.</body><body package="GF/ST Base">preTransformInfoInto: state"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set up the memento that can restore the receiver back after the	 transformation	"	state add: (self class gfMessageClass						receiver: self interface						selector: #restoreFrom:						arguments: (Array with: (self interface cutMementoFor: (Array with: self)))).</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>queries</category><body package="GF/ST Base">isConnectionGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether or not the receiver represents a connection between	 two graphic objects	"	^true</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>menus</category><body package="GF/ST Base">displayBox"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the display area of the receiver"    ^(Rectangle origin: origin extent: extent) expandByScalar: self scaledWidth</body><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    ^super standardMenu        addItemGroup: (Array with: ((MenuItem labeled:'Transform') submenu: self transformMenu));        yourself</body><body package="GF/ST Base">transformMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the transform menu of the receiver"	| menu |	menu := Menu new.	menu 		addItemLabel: 'Line' value: (MessageSend receiver: self selector: #becomeDependentLine);		addItemLabel: 'Arrow' value: (MessageSend receiver: self selector: #becomeDependentArrow).        stopPlug  == nil		ifTrue: [ menu addItemLabel: 'Orthogonal Arrow' value: (MessageSend receiver: self selector: #becomeDependentOrthogonalArrow)]		ifFalse: [ menu addItemLabel: 'Orthogonal Line' value: (MessageSend receiver: self selector: #becomeDependentOrthogonalPath)].	^menu</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>releasing</category><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Release the receiver"	stopConstraint release.	startConstraint release.	super release.	stopConstraint := nil.	startConstraint := nil.</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>constraints</category><body package="GF/ST Base">replaceConstraint: old with: new"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	startConstraint == old ifTrue: [ startConstraint := new ].	stopConstraint == old ifTrue: [ stopConstraint := new ].</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"	^#()</body></methods><methods><class-id>Polymorphic.GFDependentOrthogonalPathGO class</class-id> <category>instance creation</category><body package="GF/ST Base">arrowStartLocation: startLocation direction: startDirection stopLocation: stopLocation direction: stopDirection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						start: startLocation						direction: startDirection						stop: stopLocation						direction: stopDirection.	aFigure stopPlug: aFigure endArrowPlug.	aFigure startConstraint: (GFPositionConstraint location: startLocation receiver: aFigure sending: #startPoint:).	aFigure stopConstraint: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #stopPoint:).	startLocation receiver		when: #damaged		evaluate: (aFigure startConstraint).	stopLocation receiver		when: #damaged		evaluate: (aFigure stopConstraint).	^aFigure</body><body package="GF/ST Base">startLocation: startLocation direction: startDirection stopLocation: stopLocation direction: stopDirection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| aFigure |	aFigure := self						start: startLocation						direction: startDirection						stop: stopLocation						direction: stopDirection.	aFigure startConstraint: (GFPositionConstraint location: startLocation receiver: aFigure sending: #startPoint:).	aFigure stopConstraint: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #stopPoint:).	startLocation receiver		when: #damaged		evaluate: (aFigure startConstraint).	stopLocation receiver		when: #damaged		evaluate: (aFigure stopConstraint).	^aFigure</body></methods><methods><class-id>Polymorphic.GFPixmap</class-id> <category>pen</category><body package="GF/ST Base">pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^pen == nil 		ifTrue: [ pen := (GFScalingPen on: self) initialize]		ifFalse: [ pen ]</body><body package="GF/ST Base">release"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	pen := nil.	^super release</body></methods><methods><class-id>Polymorphic.GFPixmap</class-id> <category>accessing</category><body package="GF/ST Base">depthChangeMemento	"Return a block, which after this pixmap has been killed by a platform depth change, will resurrect it in-place."	| image |	(self isOpen not or: [self width isNil or: [self height isNil]])		ifTrue: [^nil].	[image := self asImage] on: Error do: [^nil].	^	[| risenOne |	self		close;		release.	risenOne := self class extent: image extent.	risenOne graphicsContext copyImage: image to: Point zero.	self oneWayBecome: risenOne]</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>accessing</category><body package="GF/ST Base">connectedObjects"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer whether or not the receiver represents a connection between     two graphic objects    "    ^Array 		with: self startObject		with: self stopObject</body><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the points the receiver should snap to the grid used by	 the receiver.	 Subclasses should override this to implement their own behavior	 towards the grid	"	"Dependent lines should only be altered by the constraints"	^#()</body><body package="GF/ST Base">setStartConstraint: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	startConstraint := anObject</body><body package="GF/ST Base">setStopConstraint: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	stopConstraint := anObject</body><body package="GF/ST Base">startConstraint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^startConstraint</body><body package="GF/ST Base">startObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the graphic object connected to the start of the receiver"	^startConstraint locator receiver</body><body package="GF/ST Base">startObject: startObj stopObject: stopObj	| startLocator stopLocator |	self 		setStartConstraint:			(GFPositionConstraint				location: (startLocator := ((startConstraint locator copy) receiver: startObj))				receiver: self				sending: startConstraint selector);		setStopConstraint:			(GFPositionConstraint				location: (stopLocator := ((stopConstraint locator copy) receiver: stopObj))				receiver: self				sending: stopConstraint selector).	startObj		when: #damaged		evaluate: startConstraint.	stopObj		when: #damaged		evaluate: stopConstraint.</body><body package="GF/ST Base">startPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Note, aPoint is now MY point"    super startPoint: aPoint.    self triggerEvent: #moveStart.</body><body package="GF/ST Base">stopConstraint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	^stopConstraint</body><body package="GF/ST Base">stopObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the graphic object connected to the stopping point of the receiver"	^stopConstraint locator receiver</body><body package="GF/ST Base">stopPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Note, aPoint is now MY point"    super stopPoint: aPoint.    self triggerEvent: #moveEnd.</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>mementos</category><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the position information of the receiver"	^(super positionInformation)		add: (self class gfMessageClass receiver: nil selector: #setStartConstraint: arguments: (Array with: startConstraint copy));		add: (self class gfMessageClass receiver: nil selector: #setStopConstraint: arguments: (Array with: stopConstraint copy));		add: (self class gfMessageClass receiver: nil selector: #restoreConstraints);		yourself</body><body package="GF/ST Base">restoreConstraints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	startConstraint locator receiver release: self.	startConstraint locator receiver		when: #damaged		evaluate: startConstraint.	stopConstraint locator receiver release: self.	stopConstraint locator receiver		when: #damaged		evaluate: stopConstraint.</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>translation</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Ignore this message - the only way to move me is to move my end points"</body><body package="GF/ST Base">moveStartBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the start point by a deltaPoint"	"Ignore this message - the only way to move me is to move my end points"</body><body package="GF/ST Base">moveStopBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the stop point by a deltaPoint"	"Ignore this message - the only way to move me is to move my end points"</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>transformation</category><body package="GF/ST Base">becomeConnectorType: connectionClass selector: sel"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver to the connection class using the selector	  to set the stop and end points	"	| startLocator stopLocator newPath |	startLocator := startConstraint locator.	stopLocator := stopConstraint locator.	startLocator receiver release: startConstraint.	stopLocator receiver release: stopConstraint.	newPath := connectionClass perform: sel withArguments: (Array with: startLocator with: stopLocator).	newPath width: width.	newPath color: color.	container add: newPath.	self insert: newPath.	self container remove: self.	self unlink.	newPath damaged; redraw.	^newPath</body><body package="GF/ST Base">becomeDependentArrow"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver into a dependent arrow"	| state newPath |	state := OrderedCollection new.	self preTransformInfoInto: state.	newPath := self becomeConnectorType: GFDependentLineGO							  selector: #arrowStartLocation:stopLocation: .	self postTransformInfoInto: state using: newPath.	^newPath</body><body package="GF/ST Base">becomeDependentLine"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| state newPath |	"Transform the receiver into a dependent line"	stopPlug == nil ifTrue: [^self].	state := OrderedCollection new.	self preTransformInfoInto: state.	newPath := self becomeConnectorType: GFDependentLineGO							  selector: #startLocation:stopLocation: .	self postTransformInfoInto: state using: newPath.	^newPath</body><body package="GF/ST Base">becomeDependentOrthogonalArrow"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver into a dependent orthogonal arrow"	| state newPath |	state := OrderedCollection new.	self preTransformInfoInto: state.	newPath :=self becomeConnectorType: GFDependentOrthogonalPathGO			selector: #arrowStartLocationRight:stopLocationLeft: .	self postTransformInfoInto: state using: newPath.	^newPath</body><body package="GF/ST Base">becomeDependentOrthogonalPath"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Transform the receiver into a dependent orthogonal path"	| state newPath |	state := OrderedCollection new.	self preTransformInfoInto: state.	newPath :=self becomeConnectorType: GFDependentOrthogonalPathGO			selector: #startLocationRight:stopLocationLeft: .	self postTransformInfoInto: state using: newPath.	^newPath</body><body package="GF/ST Base">postTransformInfoInto: state using: newPath"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set up the memento that can restore the previous go back after the	 transformation	"	| mem |	(mem := GFMemento originator: newPath interface)		   addActionReceiver: newPath			selector: #willDamage;		  addActionReceiver: newPath container			   selector: #remove:			   with: newPath;		addActionReceiver: newPath			selector: #release.	state do: [ :action | mem addAction: action ].	newPath interface storeMemento: mem for: newPath interface.</body><body package="GF/ST Base">preTransformInfoInto: state"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set up the memento that can restore the receiver back after the	 transformation	"	state add: (self class gfMessageClass						receiver: self interface						selector: #restoreFrom:						arguments: (Array with: (self interface cutMementoFor: (Array with: self)))).</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>queries</category><body package="GF/ST Base">isConnectionGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether or not the receiver represents a connection between	 two graphic objects	"	^true</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>menus</category><body package="GF/ST Base">standardMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the standard menu of the receiver"    ^super standardMenu        addItemGroup: 		(Array with:			((MenuItem labeled: 'Transform') submenu: self transformMenu));        yourself</body><body package="GF/ST Base">transformMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the transform menu of the receiver"	| menu |	menu := Menu new.	        stopPlug  == nil		ifTrue: [ menu addItemLabel: 'Arrow' value: (MessageSend receiver: self selector: #becomeDependentArrow)]		ifFalse: [ menu addItemLabel: 'Line' value: (MessageSend receiver: self selector: #becomeDependentLine)].	^menu		addItemLabel: 'Orthogonal Line' value: (MessageSend receiver: self selector: #becomeDependentOrthogonalPath);		addItemLabel: 'Orthogonal Arrow' value: (MessageSend receiver: self selector: #becomeDependentOrthogonalArrow);		yourself</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>releasing</category><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Release the receiver"	stopConstraint release.	startConstraint release.	super release.	stopConstraint := nil.	startConstraint := nil.</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>constraints</category><body package="GF/ST Base">constrainStartPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	super startPoint: aPoint.	self triggerEvent: #moveStart.</body><body package="GF/ST Base">constrainStopPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Note, aPoint is now MY point"	self stopPoint: aPoint.	self triggerEvent: #moveEnd.</body><body package="GF/ST Base">replaceConstraint: old with: new	startConstraint == old ifTrue: [ startConstraint := new ].	stopConstraint == old ifTrue: [ stopConstraint := new ].</body></methods><methods><class-id>Polymorphic.GFDependentLineGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"	^#()</body></methods><methods><class-id>Polymorphic.GFDependentLineGO class</class-id> <category>instance creation</category><body package="GF/ST Base">arrowStartLocation: startLocation stopLocation: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance of the receiver"	| aFigure |	aFigure := self start: startLocation asPoint stop: stopLocation asPoint.	aFigure stopPlug: aFigure endArrowPlug.	aFigure setStartConstraint: (GFPositionConstraint location: startLocation receiver: aFigure sending: #constrainStartPoint:).	aFigure setStopConstraint: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #constrainStopPoint:).	startLocation receiver		when: #damaged		evaluate: aFigure startConstraint.	stopLocation receiver		when: #damaged		evaluate: aFigure stopConstraint.	^aFigure</body><body package="GF/ST Base">startLocation: startLocation stopLocation: stopLocation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance of the receiver"	| aFigure |	aFigure := self start: startLocation asPoint stop: stopLocation asPoint.	aFigure setStartConstraint: (GFPositionConstraint location: startLocation receiver: aFigure sending: #constrainStartPoint:).	aFigure setStopConstraint: (GFPositionConstraint location: stopLocation receiver: aFigure sending: #constrainStopPoint:).	startLocation receiver		when: #damaged		evaluate: aFigure startConstraint.	stopLocation receiver		when: #damaged		evaluate: aFigure stopConstraint.	^aFigure</body></methods><methods><class-id>Polymorphic.GFFontChooser</class-id> <category>initialize-release</category><body package="GF/ST Base">postOpenWith: aBuilder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self familyList selection: self familyList selection.	self sizeList selection: self sizeList selection.	self styleList selection: self styleList selection.</body><body package="GF/ST Base">preBuildWith: aBuilder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self familyList selection isNil ifTrue: [ self familyList selection: 'system' ].	self sizeList selection isNil ifTrue: [self sizeList selection: 12 ].	self styleList selection isNil ifTrue: [self styleList selection: 'regular' ].	self familyList selectionHolder onChangeSend: #changedAttribute to: self.	self styleList selectionHolder onChangeSend: #changedAttribute to: self.	self sizeList selectionHolder onChangeSend: #changedAttribute to: self.</body><body package="GF/ST Base">setFontDescription: fd"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self familyList selection: fd family.	self sizeList selection: (self convertSize: fd).	self styleList selection: (self convertStyle: fd)</body></methods><methods><class-id>Polymorphic.GFFontChooser</class-id> <category>private</category><body package="GF/ST Base">bold"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| sel |	sel := self styleList selection.	^sel == nil 		ifTrue: [0.0 ]		ifFalse: [ ('*bold*' match: sel) 					ifTrue: [ 0.9]					ifFalse: [0.0 ] ].</body><body package="GF/ST Base">changedAttribute"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setSample</body><body package="GF/ST Base">convertSize: fd"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(fd pixelSize / self sizeAdjustment) floor</body><body package="GF/ST Base">convertStyle: fd"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| retString |	fd boldness &gt; 0.7 ifTrue: [ retString := 'bold' ].	fd italic ifTrue: [ retString isNil						ifTrue: [ retString := String new ] 						ifFalse: [ retString := retString , ' ' ].					retString := retString, 'italic'].	^retString isNil 		ifTrue: [ self class styleList first ]		ifFalse: [ retString ]</body><body package="GF/ST Base">createAttributes"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| font ta|	font := FontDescription new family: self family; boldness: self bold; italic: self italic.	font pixelSize: self size.	returnHolder notNil ifTrue: [ returnHolder value: font ].	ta := TextAttributes defaultFontQuery: font.	ta baseline: 48.	^ta</body><body package="GF/ST Base">createSampleLabel"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Label with: self class sampleString attributes: self createAttributes.</body><body package="GF/ST Base">family"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| sel |	sel := self familyList selection.	^sel == nil 		ifTrue: [self familyList list first ]		ifFalse: [ sel ].</body><body package="GF/ST Base">fontValueHolder: fontHolder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	returnHolder := fontHolder.	returnHolder value notNil ifTrue: [ self setFontDescription: returnHolder value ].</body><body package="GF/ST Base">italic"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| sel |	sel := self styleList selection.	^sel == nil 		ifTrue: [false ]		ifFalse: [ ('*italic*' match: sel) 					ifTrue: [ true]					ifFalse: [false ] ].</body><body package="GF/ST Base">setSample"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	(self builder componentAt: #sample) widget label: self createSampleLabel.</body><body package="GF/ST Base">size"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| sel |	sel := self sizeList selection.	^sel == nil 		ifTrue: [ 19 ]		ifFalse: [ (sel * self sizeAdjustment) ceiling ].</body><body package="GF/ST Base">sizeAdjustment"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Screen default preferredFontClass sizeAdjustment</body></methods><methods><class-id>Polymorphic.GFFontChooser</class-id> <category>aspects</category><body package="GF/ST Base">familyList"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^familyList isNil		ifTrue:			[familyList := SelectionInList new list: self class familyList]		ifFalse:			[familyList]</body><body package="GF/ST Base">sizeList"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sizeList isNil		ifTrue:			[sizeList := SelectionInList new list: self class sizeList]		ifFalse:			[sizeList]</body><body package="GF/ST Base">styleList"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^styleList isNil		ifTrue:			[styleList := SelectionInList new list: self class styleList]		ifFalse:			[styleList]</body></methods><methods><class-id>Polymorphic.GFFontChooser class</class-id> <category>opening</category><body package="GF/ST Base">openUsingFontDescriptionHolder: fontHolder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(super new) 		fontValueHolder: fontHolder;		open.</body><body package="GF/ST Base">pickAFont"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"GFFontChooser pickAFont"	^self pickAFontDefaultValue: nil</body><body package="GF/ST Base">pickAFontDefaultValue: fd"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| vh |	vh := fd asValue.	^(GFFontChooser openUsingFontDescriptionHolder: vh) 		ifTrue: [ vh value ]		ifFalse: [nil ].</body></methods><methods><class-id>Polymorphic.GFFontChooser class</class-id> <category>lists</category><body package="GF/ST Base">familyList"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| list |	list := List new.	list addAll: ((Screen default defaultFontPolicy availableFonts collect: [ :each | each family ]) asSet asSortedCollection).	^list</body><body package="GF/ST Base">sizeList"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| list |	list := List new.	list addAll: #(8 9 10 11 12 14 16 18 20 22 24 26 28 36 48 72).	^list</body><body package="GF/ST Base">styleList"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| list |	list := List new.	list addAll: #( 'regular' 'italic' 'bold' 'bold italic').	^list</body></methods><methods><class-id>Polymorphic.GFFontChooser class</class-id> <category>constants</category><body package="GF/ST Base">sampleString"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^'AaBbYyZz'</body></methods><methods><class-id>Polymorphic.GFRoundedRectangleGO</class-id> <category>GF/ST</category><body package="GF/ST Base">attributeInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the collection of attribute information"    ^(super attributeInformation)        add: (self class gfMessageClass receiver: nil selector: #cornerEllipse: arguments: (Array with: ellipse deepCopy));        yourself</body><body package="GF/ST Base">changeCornerEllipseBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Change the receiver ellipse based on a point"    self damageDuring: [        ellipse := (aPoint + (50@50))  max: 0 @ 0.    ].</body><body package="GF/ST Base">cornerEllipse: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the rounding of the corner to be an ellipse whose major and minor     axes are defined by aPoint.    "    ellipse := aPoint.</body><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the default handles of the receiver"    ^(super defaultHandles)        add: ((GFSelectionTrackHandle roundedCornerOf: self) scrollFlag: false);        yourself</body><body package="GF/ST Base">displayShapeWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display a mask for the receiver.  The mask is black and white, where     black represents the opaque area, and white represents the transparent     area    "    rectangle extent = (0@0) ifTrue: [^self].    super bounceDisplayShapeWith: aPen.    fillColor == nil        ifTrue: [            aPen                drawRoundRectangle: rectangle                corner: ellipse.        ]        ifFalse: [            aPen                roundRect: rectangle                corner: ellipse.        ]</body><body package="GF/ST Base">displayWith: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The central display routine.  Display the image of the receiver,     using aPen.  The receiver should make no assumptions regarding     the state of the pen, and is not responsible for resetting the pen     to the previous state.    "    super bounceDisplayWith: aPen.    fillColor == nil        ifTrue: [            aPen                drawRoundRectangle: rectangle                corner: ellipse.        ]        ifFalse: [            aPen                roundRect: rectangle                corner: ellipse.        ]</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    super initialize.    ellipse := 20 @ 20.</body><body package="GF/ST Base">positionInformation"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Answer the position information of the receiver"    ^(super positionInformation)        add: (self class gfMessageClass receiver: nil selector: #cornerEllipse: arguments: (Array with: ellipse deepCopy));        yourself</body><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Perform any additional action after copy."    super postCopy.    ellipse := ellipse deepCopy</body><body package="GF/ST Base">senseCornerEllipse: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the point that represents the corner ellipse"    ^aPoint</body><body package="GF/ST Base">setRectangle: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Set the receiver's rectangle"    rectangle := aRectangle origin extent: (aRectangle width max: 1) @ (aRectangle height max: 1)</body></methods><methods><class-id>Polymorphic.GFRoundedRectangleGO class</class-id> <category>GF/ST</category><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the creation tool designed to create instances of the receiver"    ^GFCreationTool        icon: (GFTool stockIconFor: 'RoundedRectangle')        cursor: self gfCursorClass crossHair        class: self        name: 'Rounded Rectangle'</body><body package="GF/ST Base">rectangle: aRectangle cornerEllipse: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Create a new instance of the receiver"    ^(self new        width: 1        color: RGBColor black        fillColor: RGBColor white)            setRectangle: aRectangle;            cornerEllipse: aPoint</body></methods><methods><class-id>Polymorphic.ColorChooser</class-id> <category>private</category><body package="GF/ST Base">changedColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	colorValue value saturation = 0					ifTrue: [(builder componentAt: #hue) beInvisible.							(builder componentAt: #hueLabel) beInvisible]					ifFalse: [(builder componentAt: #hue) beVisible.							(builder componentAt: #hueLabel) beVisible].	colorValue value brightness = 0.0					ifTrue: [(builder componentAt: #saturation) beInvisible.							(builder componentAt: #saturationLabel) beInvisible]					ifFalse: [(builder componentAt: #saturation) beVisible.							(builder componentAt: #saturationLabel) beVisible].</body><body package="GF/ST Base">changedColorName"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| cn cv |	cn := colorName value.	cv := RGBColor perform: cn.	cv notNil ifTrue: [colorValue value: cv]</body><body package="GF/ST Base">changedCubesBrightness"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	cubesBrightness value = 1 ifTrue: [^self].	cubeColors do:		[:v |		| c |		c := v value.		v value: (RGBColor hue: c hue saturation: c saturation brightness: 1.0 - cubesBrightness value)].</body><body package="GF/ST Base">setUpVisuals"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved" 	| cp ext lead grays r c v sats y brightness x |	(builder componentAt: #theActualColor) widget		add: (ColoredArea model: colorValue) in: (0@0 corner: 1@1).	cp := builder componentAt: #colorSpace.	ext := 14.	lead := 2.	grays :=  #(1 0.94 0.86 0.8 0.7 0.6 0.43 0 ).  	"these values are gama corrected using ((i/7)**(1/2.3))and hand edited to overlap with the system"	0 to: 7 do:		[:i |		r := (0@((i)*ext)+ (lead@lead)) extent: ext@ext - (lead@lead).		c := ValueHolder with: (RGBColor brightness: (grays at: i+1)).		v := ColoredArea new.		v controller: ColoredAreaController new.		v model: colorValue.		v select: c.		cp widget add: v in: r].			cubeColors := OrderedCollection new.	brightness := 1.0 - cubesBrightness value.	sats := 8* brightness.	y := 0.	1 to: sats do:		[:s |		| saturation |		saturation := s asFloat / sats.		x := 1.		#(0 30 60 90 120 150 180 210 240 270 300 330) do:			[:h | 			| hue |			hue := h asFloat /360.0.			r := ((x*ext)@(y*ext)+ (lead@lead) + (2@0)) extent: ext@ext - (lead@lead).			c := ValueHolder with: (RGBColor hue: hue saturation: saturation brightness: brightness).			v := ColoredArea new.			v controller: ColoredAreaController new.			v model: colorValue.			v select: c.			cubeColors add: c.			cp widget add: v in: r.			x := x + 1].		y := y + 1].</body></methods><methods><class-id>Polymorphic.ColorChooser</class-id> <category>initialize-release</category><body package="GF/ST Base">colorValueHolder: aValueHolder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	colorValue := aValueHolder</body><body package="GF/ST Base">postBuildWith: aBuilder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	super postBuildWith: aBuilder.	self setUpVisuals.	(builder componentAt: #saturation) beInvisible.	(builder componentAt: #saturationLabel) beInvisible.	(builder componentAt: #hue) beInvisible.	(builder componentAt: #hueLabel) beInvisible.</body><body package="GF/ST Base">setup"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self colorValue.	colorName := ValueHolder with: String new.	cubesBrightness := 0.0 asValue.	colorValue onChangeSend: #changedColor to: self.	cubesBrightness onChangeSend: #changedCubesBrightness to: self.	colorName onChangeSend: #changedColorName to: self.</body></methods><methods><class-id>Polymorphic.ColorChooser</class-id> <category>aspects</category><body package="GF/ST Base">brightness"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(PluggableAdaptor on: colorValue)		getBlock: [:m | m value brightness]		putBlock: 			[:m :v | 			m value:				(RGBColor					hue: m value hue					saturation: m value saturation					brightness: v).			v = 0				ifTrue: 					[(self builder componentAt: #saturation) beInvisible.					(self builder componentAt: #saturationLabel) beInvisible]				ifFalse: 					[(self builder componentAt: #saturation) beVisible.					(self builder componentAt: #saturationLabel) beVisible]]		updateBlock: [:m :a :p | true]</body><body package="GF/ST Base">colorName"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^colorName isNil		ifTrue:			[colorName := nil asValue]		ifFalse:			[colorName]</body><body package="GF/ST Base">colorValue"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	colorValue == nil ifTrue: [ colorValue := ValueHolder with: RGBColor black ].	^colorValue</body><body package="GF/ST Base">hue"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(PluggableAdaptor on: colorValue)		getBlock: [:m | m value hue]		putBlock:			[:m :v |			m value:				(RGBColor					hue:  v					saturation: m value saturation					brightness: m value brightness)]		updateBlock: [:m :a :p | true].</body><body package="GF/ST Base">saturation"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(PluggableAdaptor on: colorValue)			getBlock: [:m | m value saturation]			putBlock:					[:m :v |					m value:							(RGBColor							hue: m value hue							saturation:  v							brightness: m value brightness)]			updateBlock: [:m :a :p | true].</body><body package="GF/ST Base">sliderModel"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^cubesBrightness</body></methods><methods><class-id>Polymorphic.ColorChooser class</class-id> <category>opening</category><body package="GF/ST Base">new"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^super new setup</body><body package="GF/ST Base">openUsingColorHolder: colorHolder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(super new) 		colorValueHolder: colorHolder;		setup;		open.</body></methods><methods><class-id>Polymorphic.GFLocator</class-id> <category>GF/ST</category><body package="GF/ST Base">arguments: anArray"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		"Set the arguments array for the message."		anArray == nil ifTrue: [args := #()]. 	args := anArray</body><body package="GF/ST Base">asPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self evaluate</body><body package="GF/ST Base">copy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^CopiedFigures notNil                ifTrue: [self copyOn: (GFLocator copyAt: receiver)]                ifFalse: [super copy]</body><body package="GF/ST Base">copyOn: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^self species receiver: anObject selector: selector arguments: args</body><body package="GF/ST Base">setReceiver: anObject selector: aSymbol arguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    receiver := anObject.    selector := aSymbol.    args := anArray</body></methods><methods><class-id>Polymorphic.GFLocator class</class-id> <category>GF/ST</category><body package="GF/ST Base">copyAt: aFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^self copyAt: aFigure ifAbsent: [aFigure copy]</body><body package="GF/ST Base">copyAt: aFigure ifAbsent: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "^CopiedFigures at: aFigure ifAbsent:                [CopiedFigures at: aFigure put: aBlock value]"^CopiedFigures == nil                ifTrue:                        [aBlock value]                ifFalse:                        [CopiedFigures at: aFigure ifAbsentPut: aBlock ]</body><body package="GF/ST Base">copyWhile: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a copy of aFigure preserving the identity of shared Figures."        | anObject |        CopiedFigures := IdentityDictionary new.        anObject := aBlock value.        CopiedFigures := nil.        ^anObject</body><body package="GF/ST Base">on: anObject at: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"		^self receiver: anObject selector: aSymbol arguments: #()</body><body package="GF/ST Base">on: anObject at: aSymbol with: anArgument"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^self receiver: anObject selector: aSymbol arguments: (Array with: anArgument)</body></methods><methods><class-id>Polymorphic.GFParameterizedTrackHandle</class-id> <category>GF/ST</category><body package="GF/ST Base">change: aGO by: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    ^change notNil ifTrue: [       (change isAppropriateActionFor: aGO)            ifTrue: [                change                    evaluateIfNoTarget:aGO                    with: changeParameter                    with: anObject            ]    ]</body><body package="GF/ST Base">changeParameter: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    changeParameter := anObject</body></methods><methods><class-id>Polymorphic.GFParameterizedTrackHandle class</class-id> <category>GF/ST</category><body package="GF/ST Base">on: aFigure at: aSymbol change: changeSelector with: changeArg"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(self on: aFigure at: aSymbol)        setSense: nil change: changeSelector;        changeParameter: changeArg</body><body package="GF/ST Base">on: aFigure at: aSymbol sense: senseSelector change: changeSelector with: changeArg"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(self on: aFigure at: aSymbol)        setSense: senseSelector change: changeSelector;        changeParameter: changeArg</body><body package="GF/ST Base">on: aFigure at: aSymbol with: anArgument change: changeSelector with: changeArg"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(self on: aFigure at: aSymbol with: anArgument)        setSense: nil change: changeSelector;        changeParameter: changeArg</body><body package="GF/ST Base">on: aFigure    at: aSymbol    with: anArgument    sense: senseSelector    change: changeSelector    with: changeArg"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^(self on: aFigure at: aSymbol with: anArgument)            setSense: senseSelector change: changeSelector;            changeParameter: changeArg</body></methods><methods><class-id>Polymorphic.GFBoundedStack</class-id> <category>GF/ST</category><body package="GF/ST Base">bound"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the bound of the receiver.  The bound is the limit to the number     of elements the receiver can store    "    ^bound</body><body package="GF/ST Base">bound: maxSize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the bound of the receiver.  The bound is the limit to the number     of elements the receiver can store    "    bound := maxSize</body><body package="GF/ST Base">copyEmpty: maxSize	| new |	new := super copyEmpty: maxSize.	new bound: bound.	^new</body><body package="GF/ST Base">noBound"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the receiver to have no bounds - ie, the receiver can grow without     limit    "    bound := nil.</body><body package="GF/ST Base">pop"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the last element of the receiver, after removing it"    ^self removeLast</body><body package="GF/ST Base">push: anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer anObject.  Add anObject to the receiver.     If the reciever is now beyond its bound,     remove the least recently pushed element    "    self add: anObject.    bound == nil ifFalse: [        self size &gt; bound ifTrue: [self removeFirst].    ].    ^anObject</body><body package="GF/ST Base">top"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the most recently pushed element of the receiver"    ^self last</body></methods><methods><class-id>Polymorphic.GFBoundedStack class</class-id> <category>GF/ST</category><body package="GF/ST Base">bound: maxSize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a new GFBoundedStack, bounded by     the maxSize    "    ^(super new: maxSize) bound: maxSize</body><body package="GF/ST Base">infinite"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer a GFBoundedStack that can grow without limit"    ^super new.</body></methods><methods><class-id>Polymorphic.GFRectangle</class-id> <category>scale</category><body package="GF/ST Base">scale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"please read the class comments for more information"	^self scaled		ifTrue: [ scale ]		ifFalse: [ 1.0 @ 1.0 ]</body><body package="GF/ST Base">scale: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"'scale' must be a point"	"please read the class comments for more information"	scale := aPoint asPoint</body><body package="GF/ST Base">scaled"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"please read the class comments for more information"	^scale == nil or: [ scale ~= (1.0@1.0) ]</body></methods><methods><class-id>Polymorphic.GFRectangle</class-id> <category>copying</category><body package="GF/ST Base">deepCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| new |	new := self class origin: origin copy corner: corner copy.	scale notNil		ifTrue: [ new scale: scale copy ].	^new</body></methods><methods><class-id>Polymorphic.GFToolPalette</class-id> <category>GF/ST</category><body package="GF/ST Base">activeCategory"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the currently selected category"	activeCategory isNil ifTrue: [		self selectCategory: categories first.	].	^activeCategory</body><body package="GF/ST Base">activeTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the active tool of the receiver"	activeTool == nil ifTrue: [		activeTool := self activeCategory defaultTool.	].    ^activeTool</body><body package="GF/ST Base">addAndSelectCategory: aCategory "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Add and select aCategory of tools to the receiver"    self addCategory: aCategory.	self selectCategory: aCategory.</body><body package="GF/ST Base">addCategory: aCategory "Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Add aCategory of tools to the receiver"    categories add: aCategory.     self triggerEvent: #addCategory.</body><body package="GF/ST Base">allTools"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer all the tools in the receiver"	| allTools |	allTools := Set new.	self allToolsDo: [:each |		allTools add: each	].	^allTools asOrderedCollection</body><body package="GF/ST Base">allToolsDo: aBlock"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Iterate over all tools in the receiver, evaluating	 aBlock with each as the argument.	"	categories do: [:each |		each allToolsDo: aBlock	].</body><body package="GF/ST Base">categories"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^categories</body><body package="GF/ST Base">cursorAt: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the cursor of the active tool"    activeTool == nil ifFalse: [        ^activeTool cursor    ].    ^self class gfCursorClass normal</body><body package="GF/ST Base">focusToolOnly	"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self addAndSelectCategory: (GFCategory new defaultTool: GFFocusTool new).</body><body package="GF/ST Base">init"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private"    categories := OrderedCollection new.</body><body package="GF/ST Base">release"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self allToolsDo: [:each | each interface: nil].</body><body package="GF/ST Base">removeCategory: aCategory"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    categories remove: aCategory.    self triggerEvent: #removedCategory.</body><body package="GF/ST Base">selectCategory: aCategory"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Select aCategory"	activeCategory := aCategory.    self triggerEvent: #selectCategory with: aCategory</body><body package="GF/ST Base">selectTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    activeTool == nil ifFalse: [activeTool deactivate].    activeTool := aTool.	aTool isNil ifTrue: [^self].    self triggerEvent: #selectTool with: aTool</body><body package="GF/ST Base">setDefaultTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	activeCategory isNil ifTrue: [		self selectCategory: categories first	].    self selectTool: activeCategory defaultTool.</body><body package="GF/ST Base">setInterface: aPsiDrawingInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self allToolsDo: [:each |		each interface: aPsiDrawingInterface	].</body></methods><methods><class-id>Polymorphic.GFToolPalette class</class-id> <category>GF/ST</category><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    eventsTriggered isNil ifTrue: [        (eventsTriggered := Set new)            addAll: super eventsTriggered;			add: #selectCategory;            add: #selectTool;            add: #addedCategory;            add: #addedToolToCategory;            add: #removedCategory;            add: #removedToolFromCategory.    ].    ^eventsTriggered</body><body package="GF/ST Base">new"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super new init</body></methods><methods><class-id>Polymorphic.GFDrawingEditor</class-id> <category>view</category><body package="GF/ST Base">gfView"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	gfView isNil ifTrue: [ gfView := GFDrawingPane forInterface: self interface ].	^gfView</body><body package="GF/ST Base">interface"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	interface isNil ifTrue: [ interface := GFDrawingInterface newWithDrawing ].	^interface</body><body package="GF/ST Base">scaleIn"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	interface zoomIn</body><body package="GF/ST Base">scaleOut"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	interface zoomOut</body></methods><methods><class-id>Polymorphic.GFDrawingEditor</class-id> <category>accessing</category><body package="GF/ST Base">interface: anInterface"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	interface := anInterface</body><body package="GF/ST Base">label: aString"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"</body></methods><methods><class-id>Polymorphic.GFDrawingEditor</class-id> <category>aspects</category><body package="GF/ST Base">clearHandleInfo"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self handle value: String new.</body><body package="GF/ST Base">currentCategory"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^currentCategory isNil		ifTrue:			[currentCategory := String new asValue]		ifFalse:			[currentCategory]</body><body package="GF/ST Base">currentPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^currentPoint isNil		ifTrue:			[currentPoint := String new asValue]		ifFalse:			[currentPoint]</body><body package="GF/ST Base">currentTool"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^currentTool isNil		ifTrue:			[currentTool := String new asValue]		ifFalse:			[currentTool]</body><body package="GF/ST Base">handle"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^handle isNil		ifTrue:			[handle := String new asValue]		ifFalse:			[handle]</body><body package="GF/ST Base">menuBar"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(Menu new)		addItem: ((MenuItem labeled: '&amp;File') submenu: self class fileMenu);		addItem: ((MenuItem labeled: '&amp;View') submenu: self interface scaleMenu);		addItem: ((MenuItem labeled: '&amp;Grid') submenu: self interface gridMenu);		addItem: ((MenuItem labeled: '&amp;Drawing') submenu: self interface menu);		yourself</body><body package="GF/ST Base">newMousePoint: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self currentPoint value: aPoint printString</body><body package="GF/ST Base">setHandleInfo: aHandle"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self handle value: aHandle description</body></methods><methods><class-id>Polymorphic.GFDrawingEditor</class-id> <category>private</category><body package="GF/ST Base">adjustPalette"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Default is to do nothing"</body><body package="GF/ST Base">outputToPrinter"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	interface outputToPrinter</body><body package="GF/ST Base">value: aMessageSend"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"The drawing editor gets sent this message with a message send	as a result of having a menu pick off of the menubar menu."	^aMessageSend value.</body></methods><methods><class-id>Polymorphic.GFDrawingEditor</class-id> <category>initialize-release</category><body package="GF/ST Base">postBuildWith: aBuilder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"put beveled borders on the status fields"	| offset layout |	offset := nil.	self class statusPanes		do: [ :comp | | spec |			spec := aBuilder componentAt: comp.			"spec component border: BeveledBorder inset1."			layout := spec layout.			offset == nil ifTrue: [					offset := (spec widget lineGrid "+ 3") negated + layout bottomOffset.].			layout topOffset: offset ].	layout := (aBuilder componentAt: #divider1) layout.	layout topOffset: offset - 3.	layout bottomOffset: offset + 3.	(aBuilder componentAt: #region) widget lineColor: SymbolicPaint hilite.	(aBuilder componentAt: #region) layout topOffset: offset - 2.	(aBuilder componentAt: #view) layout bottomOffset: offset - 3.	self interface when: #handleInvoked send: #setHandleInfo: to: self.	self interface when: #noHandleInvoked send: #clearHandleInfo to: self.	self interface when: #mousePointChanged send: #newMousePoint: to: self.</body><body package="GF/ST Base">postOpenWith: aBuilder"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| paletteWindow |	self adjustPalette.	paletteWindow := (GFFloatingPalette openUsingPalette: self interface palette on: self).	builder window application: self.	paletteWindow application: self.	builder window beMaster.	paletteWindow beSlave.</body></methods><methods><class-id>Polymorphic.GFDrawingEditor class</class-id> <category>components</category><body package="GF/ST Base">statusPanes"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^#(tool category handleInfo point)</body></methods><methods><class-id>Polymorphic.GFDrawingEditor class</class-id> <category>opening</category><body package="GF/ST Base">openOn: aDrawing withInterface: interface withLabel: aLabel"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| new |	new := self new.	new interface: interface; label: aLabel.	^self openOn: new</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>state manipulation</category><body package="GF/ST Base">makeClosed"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the reeiver a closed polyline"	"should not make closed"	^self</body><body package="GF/ST Base">makeOpen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Make the reeiver an open polyline"	"should not make open (it shoud already be open)"	^self</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>queries</category><body package="GF/ST Base">checkClosed"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"by definition, this is not a closed shape"	^false</body><body package="GF/ST Base">outlineIntersects: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer true if the receiver intersects the supplied rectangle."	^self class vertices: points intersectsRectangle: aRectangle</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>comparison</category><body package="GF/ST Base">= anObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer whether the receiver and the argument are equal."	^self class == anObject class and:		[start = anObject startPoint and:			[end = anObject stopPoint and:				[controlPoint1 = anObject controlPoint1 and:					[controlPoint2 = anObject controlPoint2]]]]</body><body package="GF/ST Base">hash	^start hash 		bitXor: (end hash bitXor: (controlPoint1 hash bitXor: controlPoint2 hash))</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>translation</category><body package="GF/ST Base">basicTranslateBy: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Translate the receiver by aPoint"	super basicTranslateBy: aPoint.	start translatedByPoint: aPoint.	end translatedByPoint: aPoint.	controlPoint1 translatedByPoint: aPoint.	controlPoint2 translatedByPoint: aPoint.</body><body package="GF/ST Base">moveControlPoint1By: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self damageDuring: [		controlPoint1 translatedByPoint: deltaPoint.		self computePoints.	].</body><body package="GF/ST Base">moveControlPoint2By: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self damageDuring: [		controlPoint2 translatedByPoint: deltaPoint.		self computePoints.	].</body><body package="GF/ST Base">moveStartBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the start point by a deltaPoint"	self damageDuring: [		start translatedByPoint: deltaPoint.		self computePoints.	].	self triggerEvent: #moveStart</body><body package="GF/ST Base">moveStartPointBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	self damageDuring: [		start translatedByPoint: deltaPoint.		self computePoints.	].</body><body package="GF/ST Base">moveStopBy: deltaPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Move the stop point by a deltaPoint"	self damageDuring: [		end translatedByPoint: deltaPoint.		self computePoints.	].	self triggerEvent: #moveEnd</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>mementos</category><body package="GF/ST Base">gridPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the points the receiver should snap to the grid used by	 the receiver.	 Subclasses should override this to implement their own behavior	 towards the grid	"	^Array			with: start			with: end			with: controlPoint1			with: controlPoint2</body><body package="GF/ST Base">resetPoints: listOfPoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Reset the points of the receiver to a listOfPoints"	self damageDuring:			[ self					setStart: (listOfPoints at: 1)					stop: (listOfPoints at: 2)					controlPoint1: (listOfPoints at: 3)					controlPoint2: (listOfPoints at: 4).				self computePoints ]</body><body package="GF/ST Base">storagePoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the points relevant to position information"	^Array			with: start copy			with: end copy			with: controlPoint1 copy			with: controlPoint2 copy</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>private</category><body package="GF/ST Base">computeBounds"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Answer the bounding rectangle for the receiver."	^self class boundingRectangleForPoints: self computePoints.</body><body package="GF/ST Base">computePoints"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Private - Compute an array of points which are vertices of a polyline fitted to the	curve."	| ws boundingRect |	ws := WriteStream on: (Array new: 50).	ws nextPut: start.	self		flattenX0: self lineStart x		y0: self lineStart y		x1: controlPoint1 x		y1: controlPoint1 y		x2: controlPoint2 x		y2: controlPoint2 y		x3: self lineStop x		y3: self lineStop y		toStream: ws.	1 to: (points := ws contents) size do: [:i | points at: i put: (points at: i) rounded].	self recalculateBoundingBox.	^points</body><body package="GF/ST Base">flattenX0: ax0 y0: ay0 x1: ax1 y1: ay1 x2: ax2 y2: ay2 x3: x3 y3: y3 toStream: ws"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"We compute the maximum distance of the curve from the line	pt0-&gt;pt3 conservatively by observing that since the curve is	enclosed by the quadrilateral of its control points, we can simply	compute the distances of pt1 and pt2 from the line. The distance of	(xi,yi) from the line is abs(N)/sqrt(D), where N =	dy*(xi-x0)-dx*(yi-y0) and D = dx*dx+dy*dy. However, since we	are only interested in whether this is greater than the flatness F,	we let t=dy/dx, and testing abs(N1) &gt; sqrt(D1)*F, where	N1=t*(xi-x0)-(yi-y0) and D1 = 1+t*t. (If dx=0, we just test	abs(xi-x0) &gt; F.)"	"To speed up the computations, we represent all the coordinates,	and the flatness factor (but not the squared flatness), as integers	scaled by ScaleFactor, rather than in floating point.  The squared flatness	is scaled, but still in floating point."	"An attempt was made to speed up the computation by open coding for	#abs, this however made DT V32 quickly crash because of the deeply	nested ifTrue:ifFalse: and was backed out of."	| x0 y0 x1 y1 x2 y2 t d dist dx3 dy3 x01 y01 x12 y12 x1p y1p xm ym |	x0 := ax0.  y0 := ay0.	x1 := ax1.  y1 := ay1.	x2 := ax2.  y2 := ay2.	[" In the code below, we open-code a lot of	what would otherwise be invocations of abs.	Also, the sqrt primitive is incredibly slow.	We would do better to use two iterations of	Newton's method to compute (1.0 + (t * t)) sqrt,	by computing a := 1.0 + (t * t), b := 1.0 + a,	and result := (0.25 * b) + (a / b).  This result	is good to about 1 part in 600.  However,	we have faith that sqrt will be improved.... "	x3 = x0		ifTrue:			["x3 = x0, i.e. dx = 0"			(x1 - x0) abs &lt;= 0.5 and: [(x2 - x0) abs &lt;= 0.5]]		ifFalse:			[			dx3 := x3 - x0.			dy3 := y3 - y0.			" The following is open code for dx3 abs &gt;= dy3 abs "			"(dx3 &gt;= 0 ifTrue: [dx3] ifFalse: [0 - dx3]) &gt;=			 (dy3 &gt;= 0 ifTrue: [dy3] ifFalse: [0 - dy3])"			" resubstituting dx3 abs &gt;= dy3 abs"			(dx3 abs) &gt;= (dy3 abs)				ifTrue:					[t := dy3 asFloat / dx3.					d := ((1.0 + (t * t)) sqrt * 0.5) rounded.					dist := (t * (x1 - x0)) rounded - (y1 - y0).					" The following is open code for dist abs &lt;= d "					"(dist &gt;= 0 ifTrue: [dist &lt;= d] ifFalse: [dist + d &gt;= 0])"					dist abs &lt;= d   "resubstituting"            and:						[dist := (t * (x2 - x0)) rounded - (y2 - y0).						"dist &gt;= 0 ifTrue: [dist &lt;= d] ifFalse: [dist + d &gt;= 0]"						dist abs &lt;= d   "resubstituting"				]]				ifFalse:					[t := dx3 asFloat / dy3.					d := ((1.0 + (t * t)) sqrt * 0.5) rounded.					dist := (t * (y1 - y0)) rounded - (x1 - x0).					("dist &gt;= 0 ifTrue: [dist &lt;= d] ifFalse: [dist + d &gt;= 0]"						dist abs &lt;= d  "resubstituting"  ) and:						[dist := (t * (y2 - y0)) rounded - (x2 - x0).						"dist &gt;= 0 ifTrue: [dist &lt;= d] ifFalse: [dist + d &gt;= 0]"						dist abs &lt;= d   "resubstituting" ]]]]	  whileFalse:		["Curve isn't flat enough.  Break into two pieces and recur.		Algorithm is from 'The Beta2-split: A special case of the		Beta-spline Curve and Surface Representation,' B. A. Barsky		and A. D. DeRose, IEEE, 1985, courtesy of Crispin Goswell		(Rutherford Labs) and L. Peter Deutsch (Aladdin Enterprises)."		x01 := (x0 + x1) bitShift: -1.  y01 := (y0 + y1) bitShift: -1.		x12 := (x1 + x2) bitShift: -1.  y12 := (y1 + y2) bitShift: -1.		x2"x23" := (x2 + x3) bitShift: -1.  y2"y23" := (y2 + y3) bitShift: -1.		x1p := (x01 + x12) bitShift: -1.  y1p := (y01 + y12) bitShift: -1.		x1"x2p" := (x12 + x2) bitShift: -1.  y1"y2p" := (y12 + y2) bitShift: -1.		xm := (x1p + x1) bitShift: -1.  ym := (y1p + y1) bitShift: -1.		self			flattenX0: x0 y0: y0			x1: x01 y1: y01			x2: x1p y2: y1p			x3: xm y3: ym			toStream: ws.		"Substitute iteration for the second recursion."		x0 := xm.  y0 := ym].	ws nextPut: (x3 asFloat)@ (y3 asFloat)</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>handles</category><body package="GF/ST Base">defaultHandles"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the default handles of the receiver"		^Array			with: ((GFTrackHandle						on: self						at: #startPoint						change: #moveStartBy:)							mementoType: #positionMemento;							description: 'move start position')			with: ((GFTrackHandle						on: self						at: #stopPoint						change: #moveStopBy:)							mementoType: #positionMemento;							description: 'move stop position')			with: ((GFTrackHandle						on: self						at: #controlPoint1						change: #moveControlPoint1By:)							mementoType: #positionMemento;							description: 'control point 1')			with: ((GFTrackHandle						on: self						at: #controlPoint2						change: #moveControlPoint2By:)							mementoType: #positionMemento;							description: 'control point 2')</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>accessing</category><body package="GF/ST Base">controlPoint1"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the point that controls the direction in which the line will	leave the start point."	^controlPoint1</body><body package="GF/ST Base">controlPoint2"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the point that controls the direction from which the line will	approach the end point."	^controlPoint2</body><body package="GF/ST Base">setStart: startPt stop: endPt controlPoint1: control1 controlPoint2: control2"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the instance variables; used at instance-creation."	start := startPt.	end := endPt.	controlPoint1 := control1.	controlPoint2 := control2.	self computePoints.</body><body package="GF/ST Base">startPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the start point of the curve"	^start asPoint</body><body package="GF/ST Base">stopPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the termination point of the curve"	^end asPoint</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>conversion</category><body package="GF/ST Base">asLineGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a line that interpolates the endpoints of the curve."	^GFLineGO from: start to: end</body><body package="GF/ST Base">asPolylineGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer an approximation of the curve as a PolylineGO."	^GFPolylineGO withPoints: points</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>menus</category><body package="GF/ST Base">appendPolyLineItemsTo: aMenu"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Append the poly line specific items to aMenu"    ^aMenu</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>copying</category><body package="GF/ST Base">postCopy"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Perform any additional action after copy."	super postCopy.	start := start copy.	end := end copy.	controlPoint1 := controlPoint1 copy.	controlPoint2 := controlPoint2 copy.</body></methods><methods><class-id>Polymorphic.GFBezierGO</class-id> <category>scaling</category><body package="GF/ST Base">scaleBy: scale"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Scale the receiver by aPoint"	self damageDuring: [		start := start * scale.		end := end * scale.		controlPoint1 := controlPoint1 * scale.		controlPoint2 := controlPoint2 * scale.		1 to: points size do: [:i |			points at: i put: (points at: i) * scale.		].		origin := origin * scale.		extent := extent * scale.	].	self triggerEvent: #resize with: self</body></methods><methods><class-id>Polymorphic.GFBezierGO class</class-id> <category>instance creation</category><body package="GF/ST Base">createNotifying: anInterface"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Create a new instance, notifying anInterface of the action"	| startPoint stopPoint aPen |	startPoint := stopPoint := anInterface cursorPoint.	(aPen := anInterface pen)		setForeColorTo: self defaultLineColor;		displayLineFrom: startPoint to: stopPoint.	anInterface trackMouse: [:newPoint |		anInterface drawing damageRegion:			((startPoint rectangleWith: stopPoint)				expandedByPoint: 2 @ 2).		anInterface repairDamage.		aPen 			setForeColorTo: self defaultLineColor;			displayLineFrom: startPoint to: (stopPoint := newPoint).	].	startPoint = stopPoint ifTrue: [^nil].	^self start: startPoint stop: stopPoint</body><body package="GF/ST Base">start: start stop: end"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a new instance of the receiver"	^self		start: start		stop: end		controlPoint1: start + (10 @ 10)		controlPoint2: end + (10 @ 10)</body><body package="GF/ST Base">start: start stop: stop controlPoint1: controlPoint1 controlPoint2: controlPoint2"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a new instance of the receiver"	^self new		setStart: start		stop: stop		controlPoint1: controlPoint1		controlPoint2: controlPoint2</body></methods><methods><class-id>Polymorphic.GFBezierGO class</class-id> <category>accessing</category><body package="GF/ST Base">creationTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the tool designed to create the receiver"	^GFCreationTool		icon: (GFTool stockIconFor: 'Bezier')		cursor: self gfCursorClass crossHair		class: self		name: 'Bezier'</body><body package="GF/ST Base">eventsTriggered"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the events triggered"	eventsTriggered isNil ifTrue: [		(eventsTriggered := Set new)			addAll: self superclass eventsTriggered;			add: #resize;			add: #moveStart;			add: #moveEnd.	].	^eventsTriggered</body></methods><methods><class-id>Polymorphic.GFDrawingView</class-id> <category>GF/ST</category><body package="GF/ST Base">drawingPane"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^GFDrawingPane forInterface: interface</body><body package="GF/ST Base">handleInvoked: aHandle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "A handle has been invoked, update the status pane"    (self statusPane statusBoxAt: #handle) contents: aHandle description</body><body package="GF/ST Base">initWindowSize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the initial window extent."     ^375@300 min: Screen default bounds extent</body><body package="GF/ST Base">initialize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    super initialize.    label := 'Drawing'.    interface := GFDrawingInterface newWithDrawing.</body><body package="GF/ST Base">menuBarCollection"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Answer the collection of menu items"    ^(OrderedCollection new)        add:            ((Menu                labels: 'E\uxit' replaceEscapeCharacters                selectors: #(close))                owner: self;                title: '\uFile' replaceEscapeCharacters            );        add: interface popupMenu;        yourself</body><body package="GF/ST Base">minimumSize"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^375@300</body><body package="GF/ST Base">mousePoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "The mouse point has been updated"    (self statusPane statusBoxAt: #mousePoint) contents: aPoint printString</body><body package="GF/ST Base">noHandleInvoked"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Clear the handle description"    (self statusPane statusBoxAt: #handle) contents: ''</body><body package="GF/ST Base">openOn: drawing withInterface: anInterface withLabel: aLabel"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| wrapper aWindow drawingPane |	interface := anInterface.	label := aLabel.	interface setDrawing: drawing.	drawingPane := GFDrawingPane forInterface: interface.	wrapper := BorderDecorator on: drawingPane.	wrapper 		useHorizontalScrollBar;		useVerticalScrollBar.	aWindow := ScheduledWindow model: nil label: label minimumSize: 375@300.	aWindow component: wrapper.	drawingPane bounds:(0@0 extent: 373@300).	aWindow open.</body><body package="GF/ST Base">pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self graphicsContext</body><body package="GF/ST Base">pressedCategory: aCategory"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the description of the pressed category"    (self statusPane statusBoxAt: #category) contents: aCategory name</body><body package="GF/ST Base">pressedTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the description of the pressed tool"    (self statusPane statusBoxAt: #tool) contents: aTool name</body><body package="GF/ST Base">selectedCategory: aCategory"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the description of the selected category of tools"    (self statusPane statusBoxAt: #category) contents: aCategory name.    (self statusPane statusBoxAt: #tool) contents: ''.</body><body package="GF/ST Base">selectedTool: aTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Display the description of the seleted tool"    (self statusPane statusBoxAt: #tool) contents: aTool name</body><body package="GF/ST Base">setDefaultTool"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the default tool of the interface.  Defer the event, as it's a floating pane     opened later    "    (Message receiver: interface selector: #setDefaultTool) performDeferred.</body><body package="GF/ST Base">setLabel"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "self topComponent label: label"</body></methods><methods><class-id>Polymorphic.GFDrawingView class</class-id> <category>opening</category><body package="GF/ST Base">openOn: drawingPane withInterface: interface withLabel: label"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| wrapper aWindow |	wrapper := BorderDecorator on: drawingPane at: 0@0.	wrapper 		useHorizontalScrollBar;		useVerticalScrollBar.	aWindow := ScheduledWindow model: nil label: label minimumSize: 375@300.	aWindow component: wrapper.	drawingPane bounds:(0@0 extent: 373@300).	aWindow open.</body></methods><methods><class-id>Polymorphic.GFCreationTool</class-id> <category>GF/ST</category><body package="GF/ST Base">button1DownBackground"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"    | createdGO |    (createdGO := self createGO) isNil ifTrue: [ ^self].    self isSticky ifFalse: [        interface            setDefaultTool            selection: createdGO.    ].</body><body package="GF/ST Base">button1DownGO: aGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Just create a GO on top of the existing GO - a reasonable 	default behavior."	^self button1DownBackground</body><body package="GF/ST Base">createGO"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private - Create a graphicObject and add it to the drawing."    | aGO |    interface cursorPointSnapped: true limit: true.    aGO :=self creationClass perform: self creationSelector with: interface.    aGO notNil        ifFalse: [^nil]        ifTrue: [interface addGO: aGO].    interface storeMemento: (interface mementoForNewGO: aGO) for: interface.    ^aGO</body><body package="GF/ST Base">creationClass"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	^(BindingReference pathString: className) value</body><body package="GF/ST Base">creationSelector"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	^creationSelector isNil ifTrue: [ #createNotifying: ] ifFalse: [ creationSelector ]</body><body package="GF/ST Base">isSticky"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^interface shiftDown	or: [#{UIPainterController} 			ifDefinedDo: [:painterController |  painterController modeIsSticky] 			elseDo: [false]]</body><body package="GF/ST Base">setClassName: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	className := aSymbol</body><body package="GF/ST Base">setCreationSelector: aSymbol"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Private"	creationSelector := aSymbol</body></methods><methods><class-id>Polymorphic.GFCreationTool class</class-id> <category>GF/ST</category><body package="GF/ST Base">cursor: aCursor class: aClass"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^(self cursor: aCursor) setClassName: aClass fullyQualifiedReference asSymbol</body><body package="GF/ST Base">icon: anImage cursor: aCursor class: aClass"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^(self icon: anImage cursor: aCursor name: '') setClassName: aClass fullyQualifiedReference asSymbol</body><body package="GF/ST Base">icon: anImage cursor: aCursor class: aClass name: aString"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        ^(self icon: anImage cursor: aCursor name: aString) setClassName: aClass fullyQualifiedReference asSymbol</body></methods><methods><class-id>Polymorphic.GFEmptyRectangle</class-id> <category>merging</category><body package="GF/ST Base">merge: aRectangle"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^aRectangle</body></methods><methods><class-id>Polymorphic.GFOpaqueBitmap</class-id> <category>testing</category><body package="GF/ST Base">isOpen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^shape isOpen</body></methods><methods><class-id>Polymorphic.GFOpaqueBitmap</class-id> <category>GF/ST</category><body package="GF/ST Base">boundingBox"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self bounds</body><body package="GF/ST Base">displayAt: aPoint with: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    ^super displayOn: aPen at: aPoint</body><body package="GF/ST Base">displayIn: aRect with: aPen"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Display the receiver in aRect using aPen."    aPen intersectClip: aRect.	self displayOn: aPen at: aRect origin</body><body package="GF/ST Base">displayOn: aGraphicsContext"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	aGraphicsContext isGFScalingPen 		ifTrue: [ figure scale: aGraphicsContext scale.				shape scale: aGraphicsContext scale. ].	super displayOn: aGraphicsContext</body><body package="GF/ST Base">figure: pixmap"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	figure := pixmap</body><body package="GF/ST Base">pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^figure == nil		ifTrue: [ nil ]		ifFalse: [figure graphicsContext ]</body><body package="GF/ST Base">setMask: aBitmap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the mask for the receiver.  The mask determines which areas     of the receiver are transparent (ie, let the background show through,     and which of the areas of the receiver are opaque.  The mask is usually     a monochrome bitmap, but that isn't required.   The areas that are opaque     are represented by black (0's) and the transparent areas are represented     by white (1's) in the mask bitmap.  It is assumed that the mask and the     receiver are the same extent.    "    shape := aBitmap.    "self pen        fastCopy: mask pen        from: mask boundingBox        at: 0@0        rule: Srcinvert."</body><body package="GF/ST Base">setMaskNoInvert: aBitmap"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Set the mask for the receiver.  The mask determines which areas     of the receiver are transparent (ie, let the background show through,     and which of the areas of the receiver are opaque.  The mask is usually     a monochrome bitmap, but that isn't required.   The areas that are opaque     are represented by black (0's) and the transparent areas are represented     by white (1's) in the mask bitmap.  It is assumed that the mask and the     receiver are the same extent.    "    shape := aBitmap.</body></methods><methods><class-id>Polymorphic.GFOpaqueBitmap class</class-id> <category>GF/ST</category><body package="GF/ST Base">aboutToSaveImage"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        (self allInstancesWeakly: true) do: [ :b | b aboutToSaveImage ].</body><body package="GF/ST Base">screenExtent: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self new figure: (Pixmap extent: aPoint)</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">black"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setForeColorTo: Polymorphic.Color black</body><body package="GF/ST Base">blackFill"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setFillColorTo: Polymorphic.Color black</body><body package="GF/ST Base">checkClientData"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	clientData == nil ifTrue: [ clientData := self clientData ]</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>clipping</category><body package="GF/ST Base">clipRectanglesIntersect: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^aRect</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">copyBitmap: anImage from: srcRect at: point"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self displayImage: anImage at: point</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">displayStringCentered: string offsetBy: point"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self displayString: string at: ((point x + ((self clippingBounds width - (self font stringWidth: string)) // 2))@point y)</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">drawBorderRect: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setForeColorTo: Polymorphic.Color buttonBorder.	self gfPolyline: (Array with: aRect topLeft + (1@0) with: aRect topRight - (2@0)).	self gfPolyline: (Array with: aRect bottomLeft + (1@ -1) with: aRect bottomRight - (2@1)).	self gfPolyline: (Array with: aRect topLeft + (0@1) with: aRect bottomLeft - (0@2)).	self gfPolyline: (Array with: aRect topRight - (1@ -1) with: aRect bottomRight - (1@2)).</body><body package="GF/ST Base">drawEllipse: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setFore ifTrue: [ self displayArcBBoxOrigin: aRect origin extent: aRect extent startAngle: 0.0 sweepAngle: 360.0].</body><body package="GF/ST Base">drawInRect3D: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| tRect poly1 poly2 poly3 poly4 |	tRect := aRect insetBy: (1@1).	poly1 := (Array with: tRect bottomLeft - (0@1) with: tRect origin with: tRect topRight).			tRect := aRect insetBy: (2@2).	poly3 := (Array with: tRect bottomLeft with: tRect origin with: tRect topRight).	poly2 := (Array with: tRect bottomLeft - (1@0) with: tRect corner with: tRect topRight - (0@2)).	tRect := aRect insetBy: (3@3).	poly4 := (Array with: tRect bottomLeft- (1@0) with: tRect corner with: tRect topRight- (0@2)).	self lineWidth: 1.	self setForeColorTo: Polymorphic.Color buttonShadow;		gfPolyline: poly1;		gfPolyline: poly3;		setForeColorTo: Polymorphic.Color buttonHilite;		gfPolyline: poly2;		gfPolyline: poly4.	self drawBorderRect: aRect.</body><body package="GF/ST Base">drawOutRect3D: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| tRect poly1 poly2 poly3 poly4 |	tRect := aRect insetBy: (1@1).	poly1 := (Array with: tRect bottomLeft - (0@1) with: tRect origin with: tRect topRight).			tRect := aRect insetBy: (2@2).	poly3 := (Array with: tRect bottomLeft with: tRect origin with: tRect topRight).	poly2 := (Array with: tRect bottomLeft - (1@0) with: tRect corner with: tRect topRight - (0@2)).	tRect := aRect insetBy: (3@3).	poly4 := (Array with: tRect bottomLeft- (1@0) with: tRect corner with: tRect topRight- (0@2)).	self lineWidth: 1.	self setForeColorTo: Polymorphic.Color buttonHilite;		gfPolyline: poly1;		gfPolyline: poly3;		setForeColorTo: Polymorphic.Color buttonShadow;		gfPolyline: poly2;		gfPolyline: poly4.	self drawBorderRect: aRect.</body><body package="GF/ST Base">drawPushedRect3D: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| start1 stop1 stop2 |	self drawBorderRect: aRect.	start1 := aRect origin + (1@1).	stop1 := (aRect origin x + 1) @ (aRect corner y - 1).	stop2 := (aRect corner x - 1) @ (aRect origin y + 1).	self setForeColorTo: Polymorphic.Color buttonShadow.	self gfPolyline: (Array with: stop1 with: start1 with: stop2).</body><body package="GF/ST Base">drawRectangle: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This just draws the border.  This does differ from PPS method naming	conventions and in all rights should be called #drawRectangularBorder:	but given that this code is attempting to co-exist in some fashion with	the Digitalk implementation this difference in naming comventions will	just have to be lived with for now"	self setFore ifTrue: [self		primDisplayRectangularBorderOrigin: aRect topLeft		extent: aRect extent - (1@1)].</body><body package="GF/ST Base">drawRectangle: aRect joinStyle: style"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| oldStyle |	oldStyle := self joinStyle.	self joinStyle: style.	self drawRectangle: aRect.	self joinStyle: oldStyle.</body><body package="GF/ST Base">drawRectangleOrigin: origin extent: extent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setFore ifTrue: [self		primDisplayRectangularBorderOrigin: origin		extent: extent].</body><body package="GF/ST Base">drawRoundRectangle: aRect corner: cornerPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self primRoundRect: aRect corner: cornerPoint withFill: false</body><body package="GF/ST Base">ellipse: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| origin extent |	origin := aRect origin.	extent := aRect extent.	self setFill ifTrue: [		self 			primDisplayWedgeBBoxOrigin: origin			extent: (Point x: extent x + 1 y: extent y + 1)			startAngle: 0.0			sweepAngle: 360.0].	self setFore ifTrue: [		self			primDisplayArcBBoxOrigin: origin			extent: extent			startAngle: 0.0			sweepAngle: 360.0].</body><body package="GF/ST Base">fastCopy: aGraphicsContext from: aShape"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	(aGraphicsContext medium palette = medium palette)		ifFalse: [^self error: 'Palettes must match for a copyArea operation.'].	^self		copyRectangularArea: aShape		from: aGraphicsContext		sourceOffsetX: 0 y: 0		destinationOffsetX: 0 y: 0</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">fastCopyRectangularAreaOrigin: topLeft extent: extent from: aGraphicsContext"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Copy a rectangular area of aGraphicsContext's display medium to 	my display medium. The source area is described by 	aShape, translated by srcOffsetX@srcOffsetY in the coordinate system of 	aGraphicsContext. The destination area is described by aShape 	translated by destOffsetX@destOffsetY in my coordinate system. 		The source graphics context (aGraphicsContext) is used only to	specify the medium and coordinate system (translation).  No other	parameters of the source graphics context affect the copy operation.		Answer an array of damage rectangles indicating what areas of my 	display medium are damaged because they correspond to portions of 	the source display medium that could not be copied."	^self copyArea: (topLeft extent: extent) from: aGraphicsContext sourceOffsetX: 0 y: 0 destinationOffsetX: 0 y: 0</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">fastPolygonFilled: points"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setFill ifTrue: [ self displayPolygon: points ].	self setFore ifTrue: [ self displayPolyline: points ]</body><body package="GF/ST Base">fastPolyline: points"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setFore ifTrue: [ self displayPolyline: points ]</body><body package="GF/ST Base">fastPolyline: points joinStyle: style"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| oldStyle |	oldStyle := joinStyle.	self joinStyle: style.	self fastPolyline: points.	self joinStyle: oldStyle.</body><body package="GF/ST Base">fastRectangleFilled: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Note that unlike #fastRectangleFilledOrigin:extent: this method trims the 	extent of the rectangle to be displayed in by 1@1"	| origin extent |	origin := aRect origin.	extent := aRect extent - (1@1).	self setFill ifTrue: [self						primDisplayRectangleOrigin: origin						extent: extent].	self setFore ifTrue: [ self							primDisplayRectangularBorderOrigin: origin							extent: extent]</body><body package="GF/ST Base">fastRectangleFilledOrigin: origin extent: extent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setFill ifTrue: [self						primDisplayRectangleOrigin: origin						extent: extent].	self setFore ifTrue: [ self							primDisplayRectangularBorderOrigin: origin							extent: extent]</body><body package="GF/ST Base">fill: aColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Fill the entire clipping bounds to be aColor"	| oldPaint |	oldPaint := self paint.	aColor installOn: self.	self displayRectangle: self clippingBounds.	paint := oldPaint</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">gfExecute: aBlock clipRect: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	|  cX cY cW cH | 	[cX := clipOriginX.	cY := clipOriginY. 	cW := clipWidth. 	cH := clipHeight.	self intersectClip: rect.	aBlock value.]		ensure:			[clipOriginX := cX.			clipOriginY := cY. 			clipWidth := cW. 			clipHeight := cH].</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">gfFill: aRect color: aColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| oldPaint |	oldPaint := self paint.	aColor installOn: self.	self displayRectangle: aRect.	paint := oldPaint</body><body package="GF/ST Base">gfFillOrigin: origin extent: extent color: aColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| oldPaint |	oldPaint := self paint.	aColor installOn: self.	self		primDisplayRectangleOrigin: origin		extent: extent.	paint := oldPaint</body><body package="GF/ST Base">gfPolyline: points"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| pt1 |	pt1 := points at: 1.	2 to: points size do: [ :i | | pt2 |		self displayRectangle: (Rectangle vertex: pt1 vertex: ((pt2 := points at: i) + (1@1))).		pt1 := pt2.]</body><body package="GF/ST Base">isGFScalingPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^false</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">newScale: newScale"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self scale: newScale</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>private</category><body package="GF/ST Base">offsetX"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^offsetX</body><body package="GF/ST Base">offsetX: value"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	offsetX := value</body><body package="GF/ST Base">offsetY"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^offsetY</body><body package="GF/ST Base">offsetY: value"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	offsetY := value</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">primRect: aRect withFill: fillFlag"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	" draw a rectangle "	| origin extent |	origin := aRect origin.	extent := aRect extent.	fillFlag ifTrue:		[		self setFill ifTrue: 			[ self primDisplayRectangleOrigin: origin extent: extent ]		].	self setFore ifTrue: 		[ self primDisplayRectangularBorderOrigin: origin extent: extent ]</body><body package="GF/ST Base">primRoundRect: aRect corner: origCornerPoint withFill: fillFlag"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| arcPoint tl tr bl br rx ty lx by lStart lStop hackX hackY cornerPoint |	cornerPoint := origCornerPoint min: aRect extent // 2.	hackX := cornerPoint x = origCornerPoint x ifTrue: [1] ifFalse: [cornerPoint x &gt; 3 ifTrue: [1] ifFalse: [0]].	hackY := cornerPoint y = origCornerPoint y ifTrue: [1] ifFalse: [cornerPoint y &gt; 3 ifTrue: [1] ifFalse: [0]].	(cornerPoint x = 0 or: [ cornerPoint y = 0]) ifTrue:		[ self setFill ifTrue: [ self primDisplayRectangleOrigin: aRect origin extent: aRect extent].		self setFore ifTrue: [ self primDisplayRectangularBorderOrigin: aRect origin extent: aRect extent].		^self ].	arcPoint := Point x: (cornerPoint x bitShift: 1) y: (cornerPoint y bitShift: 1).	arcPoint := arcPoint min: aRect extent.	tl := aRect origin.	tr := aRect topRight - (arcPoint x @ 0).	bl := aRect bottomLeft - (0 @ arcPoint y).	br := tr x @ bl y.	rx := aRect origin x.	ty := aRect origin y.	lx := aRect corner x.	by := aRect corner y.	lStart := Point x: (rx + cornerPoint x - hackX) y: (ty + cornerPoint y - hackY).	lStop := Point x: (lx - cornerPoint x + hackX) y: (by - cornerPoint y + hackY).	"Am I filled?"	self setFill ifTrue:		[ | wedgePoint |		wedgePoint := arcPoint.		self primDisplayRectangleOrigin: lStart x @ty extent: (lStop x - lStart x) @ aRect extent y.		self primDisplayRectangleOrigin: rx@ lStart y extent: aRect extent x @ (lStop y - lStart y).		self displayWedgeBBoxOrigin: tl extent: wedgePoint startAngle: 180 sweepAngle: 90.		self displayWedgeBBoxOrigin: bl extent: wedgePoint startAngle: 90 sweepAngle: 90.		self displayWedgeBBoxOrigin: tr extent: wedgePoint startAngle: 270 sweepAngle: 90.		self displayWedgeBBoxOrigin: br extent: wedgePoint startAngle: 0 sweepAngle: 90 ].	"Ok to draw perimeter?"	self setFore ifFalse: [ ^self ].	self displayLineFrom: lStart x @ ty to: lStop x @ ty.	self displayLineFrom: lStart x @ by to: lStop x @ by.	self displayLineFrom: rx @ lStart y to: rx @ lStop y.	self displayLineFrom: lx @ lStart y to: lx @ lStop y.	self displayArcBBoxOrigin: tl extent: arcPoint startAngle: 180 sweepAngle: 90.	self displayArcBBoxOrigin: bl extent: arcPoint startAngle: 90 sweepAngle: 90.	self displayArcBBoxOrigin: tr extent: arcPoint startAngle: 270 sweepAngle: 90.	self displayArcBBoxOrigin: br extent: arcPoint startAngle: 0 sweepAngle: 90.</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">quickDisplayText: text at: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self		displayString: text		from: 1		to: text size		at: pt</body><body package="GF/ST Base">quickDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self gfExecute: [ self quickDisplayText: text at: (aRect origin leftAndDown: font basePoint) ] clipRect: aRect</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">rectangleFilled: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self displayRectangle: aRect</body><body package="GF/ST Base">roundRect: aRect corner: cornerPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self primRoundRect: aRect corner: cornerPoint withFill: true</body><body package="GF/ST Base">scalePoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(scaleX * pt x) rounded @ ((scaleY * pt y) rounded)</body><body package="GF/ST Base">setBackColorTo: aColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self checkClientData.	clientData at: #fill put: aColor.	aColor == nil ifFalse: [ aColor installOn: self ]</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">setBackgroundTransparent"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"no-op"</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">setFill"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"if there is a fill color, set it and return true.  return false otherwise."	| fillColor |	self checkClientData.	fillColor := clientData at: #fill ifAbsent: [ nil ].	^fillColor == nil 		ifTrue: [ false ]		ifFalse: [ fillColor installOn: self.				true].</body><body package="GF/ST Base">setFillColorTo: aColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self checkClientData.	clientData at: #fill put: aColor</body><body package="GF/ST Base">setFore"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"if there is a fill color, set it and return true.  return false otherwise."	| foreColor |	self checkClientData.	foreColor := clientData at: #foreground ifAbsent: [ nil ].	^foreColor == nil 		ifTrue: [ false ]		ifFalse: [foreColor installOn: self.				true].</body><body package="GF/ST Base">setForeColorTo: aColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self checkClientData.	clientData at: #foreground put: aColor.	aColor == nil ifFalse: [ aColor installOn: self ]</body><body package="GF/ST Base">setLineWidthTo: width"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self lineWidth: width</body><body package="GF/ST Base">setStyle: style color: aColor width: width"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setForeColorTo: aColor.	self lineWidth: width.</body><body package="GF/ST Base">unscalePoint: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^((pt x) / scaleX) rounded @ (((pt y) / scaleY) rounded)</body><body package="GF/ST Base">white"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self setForeColorTo: Polymorphic.Color white</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>GF/ST</category><body package="GF/ST Base">translation"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^0@0</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>testing</category><body package="GF/ST Base">fontDescription"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self</body><body package="GF/ST Base">isFontDescription"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^true</body></methods><methods><class-id>UI.Dialog class</class-id> <category>notifier</category><body package="GF/ST Base">message: aString"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Display a message"	^self warn: aString</body></methods><methods><class-id>UI.Dialog class</class-id> <category>fill In the blank dialogs</category><body package="GF/ST Base">prompt: promptString default: initialString"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self request: promptString initialAnswer: initialString onCancel: [ nil ]</body><body package="GF/ST Base">prompt: promptString defaultExpression: exp"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| finalExp |	finalExp := self request: promptString initialAnswer: exp.	finalExp size &gt; 0 ifFalse: [ ^nil ].	^Compiler evaluate: finalExp</body></methods><methods><class-id>Graphics.Image</class-id> <category>bounds accessing</category><body package="GF/ST Base">boundingBox"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self bounds</body></methods><methods><class-id>Graphics.Image</class-id> <category>displaying</category><body package="GF/ST Base">displayIn: rect with: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| tRect |	tRect := aPen clippingBounds.	aPen intersectClip: rect.	self displayOn: aPen at: rect origin.	aPen clippingRectangle: tRect.</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="GF/ST Base">gfMagnifiedBy: scale "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Answer a new Image created as a multiple of the receiver; the new Image	is larger, each bit in the receiver being blown up to extent=scale.	Note that scale X and Y must be integers."	^self gfMagnifyBy: scale to: (self copyEmpty: (self extent * scale) ceiling)</body><body package="GF/ST Base">gfMagnifyBy: scale to: newImage"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	" Fill newImage with a scaled-down copy of the receiver.	Answer newImage. "	"Each bit in the new image is a sample taken from the upper-left bit of 	a rectangle of extent = scale in the receiver.  A better algorithm 	would sample more bits and combine them in some way."	| wideImage row |	(newImage isLike: self withExtent: (self extent * scale) ceiling) ifFalse:		[self error: 'Destination is incompatible with source'].	wideImage := self copyEmpty: width @ (height * scale y) ceiling.	row := self pixelArraySpecies new: self packedRowSize.	0 to: wideImage height - 1 do: 		[:y |		self packedRowAt: (y / scale y) truncated ceiling into: row.		wideImage packedRowAt: y putAll: row].	0 to: newImage width - 1 do: 		[:x | 		newImage			copy: (x @ 0 extent: 1 @ wideImage height)			from: (x / scale x) truncated @ 0			in: wideImage			rule: RasterOp over].	^newImage</body></methods><methods><class-id>Core.Array</class-id> <category>accessing</category><body package="GF/ST Base">at: index ifAbsent: aBlock"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	(index between: 1 and: self size) ifTrue: [ ^self at: index ].	^aBlock value</body></methods><methods><class-id>Core.Array</class-id> <category>copying</category><body package="GF/ST Base">deepCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"It is assumed that all elements of the receiver know how to do deepCopy as well"	| new | 	new := self species new: self size.	1 to: self size do: [ :i | new at: i put: (self at: i) deepCopy ].	^new</body></methods><methods><class-id>Graphics.DeviceFont</class-id> <category>accessing</category><body package="GF/ST Base">basePoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^0@ self ascent</body><body package="GF/ST Base">characterBlockAtPoint: point onString: string"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| width |	self widthTable == nil ifTrue: [ ^nil].	width := 0.	point y &lt; 0 ifTrue: [ ^1 ].	point y &gt; (self height) ifTrue: [ ^string size + 1 ].	1 to: string size do: [ :i | | addition |						addition := (self widthOf: (string at: i)).						(width + (addition bitShift: -1)) &gt;= (point x)  ifTrue: [ ^i ].						width := width + addition.].	^string size + 1</body><body package="GF/ST Base">characterBlockForIndex: index onString: string"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| width |	self widthTable == nil ifTrue: [ ^((index * 7 @ 0) extent: (7@self height))].	width := 0.	1 to: index -1 do: [ :i | width := width + (self widthOf: (string at: i)) ].	^(width@0) extent: ((self widthOf: index) @ self height)</body><body package="GF/ST Base">stringWidth: string"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| width |	self widthTable == nil ifTrue: [ ^string size * 7 ].	width := 0.	string do: [ :char | width := width + (self widthOf: char) ].	^width</body></methods><methods><class-id>Core.Object</class-id> <category>GF/ST</category><body package="GF/ST Base">asString"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self printString</body><body package="GF/ST Base">bell"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	Screen default ringBell</body><body package="GF/ST Base">copyUsing: replacementDictionary	"The idea here is that if I am in the replacementDictionary, then I want to 	return the value at that location, otherwise, I should just return myself.	Subclasses such as Message will want to do a more indepth iterative 	search and replace procedure (not to mention actually return a copy of 	themselves).  However, care must be taken that this doesn't become	recursive so collections (with the exception of ActionSequence) should	not reimplement this, rather it should be implemented for collections by	those objects holding on to the collection."	^(replacementDictionary includesKey: self)		ifTrue: [ replacementDictionary at: self ]		ifFalse: [ self ]</body></methods><methods><class-id>Core.Object</class-id> <category>psi event handling</category><body package="GF/ST Base">evaluateIfNoTarget: newTarget	^self evaluate</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget with: anObject	^self evaluateIfNoTarget: newTarget withArguments: (Array with: anObject)</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget with: objectA with: objectB	^self evaluateIfNoTarget: newTarget withArguments: (Array with: objectA with: objectB)</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget withArguments: anArray	^self evaluateWithArguments: anArray</body><body package="GF/ST Base">evaluateWith: anObject	^self evaluateWithArguments: (Array with: anObject)</body><body package="GF/ST Base">evaluateWith: firstArgument with: secondArgument	^self evaluateWithArguments: (Array with: firstArgument with: secondArgument)</body></methods><methods><class-id>Core.Object</class-id> <category>system specifics</category><body package="GF/ST Base">gfCursorClass"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Cursor</body><body package="GF/ST Base">gfDisplay"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Screen default</body><body package="GF/ST Base">gfMenuClass"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Menu</body><body package="GF/ST Base">gfMessageBoxClass"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Dialog</body><body package="GF/ST Base">gfMessageClass"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^MessageSend</body><body package="GF/ST Base">gfPrompterClass"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Dialog</body><body package="GF/ST Base">gfTerminalClass"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Screen default</body></methods><methods><class-id>Core.Object</class-id> <category>psi event handling</category><body package="GF/ST Base">isAppropriateActionFor: anObject	^true</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GF/ST Base">isFontDescription"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>GF/ST</category><body package="GF/ST Base">isPsiDrawing"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	#PolymorphicAdded.	^false</body><body package="GF/ST Base">isPsiGraphicObject"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	#PolymorphicAdded.    ^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GF/ST Base">isScrollingContainer"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>psi event handling</category><body package="GF/ST Base">removeAction: anAction	self eventTable keys do: [:each |		self 			removeActionsSatisfying: [:a | a = anAction]			forEvent: each	].</body></methods><methods><class-id>Core.Object</class-id> <category>GF/ST</category><body package="GF/ST Base">restoreFrom: aMemento"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Restore the receiver's state from aMemento."	#PolymorphicAdded.	^aMemento restore: self.</body></methods><methods><class-id>Core.Object</class-id> <category>psi event handling</category><body package="GF/ST Base">triggerEvent: eventName with: argument ifNotHandled: exceptionBlock        "Trigger the event named &lt;eventName&gt; using the given        &lt;argument&gt; as the argument.		If the event is not handled, answer the value of 		&lt;exceptionBlock&gt;, otherwise answer the value		returned by the most recently defined event handler action."	^self 		triggerEvent: eventName		withArguments: (Array with: argument)		ifNotHandled: exceptionBlock</body><body package="GF/ST Base">triggerEvent: eventName with: firstArgument with: secondArgument ifNotHandled: exceptionBlock        "Trigger the event named &lt;eventName&gt; using the &lt;firstArgument&gt;        and &lt;secondArgument&gt; as the arguments.		If the event is not handled, answer the value of 		&lt;exceptionBlock&gt;, otherwise answer the value		returned by the most recently defined event handler action."	^self 		triggerEvent: eventName		withArguments: (Array with: firstArgument with: secondArgument)		ifNotHandled: exceptionBlock</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>constants</category><body package="GF/ST Base">darkBlue"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self navy</body><body package="GF/ST Base">darkPink"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self darkMagenta</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="GF/ST Base">asRGBColor"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self</body></methods><methods><class-id>Kernel.Context</class-id> <category>GF/ST</category><body package="GF/ST Base">asPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the value of the receiver, which is assumed to be a point"	#PolymorphicAdded.    ^self value</body><body package="GF/ST Base">isAppropriateActionFor: anObject	^true</body></methods><methods><class-id>UI.View</class-id> <category>private</category><body package="GF/ST Base">initGraphics"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"</body></methods><methods><class-id>Core.ActionSequence</class-id> <category>GF/ST</category><body package="GF/ST Base">asPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the value of the receiver, which is assumed to be a point"	#PolymorphicAdded.    ^self evaluate</body><body package="GF/ST Base">copyUsing: replacementDictionary	| newSeq |		newSeq := self class new: self size.	1 to: self size do: [ :i | newSeq at: i put: ((self at: i) copyUsing: replacementDictionary)].	^(newSeq select: [ :each | each notNil ]) asMinimalRepresentation.</body><body package="GF/ST Base">evaluateWithSelector: aSymbol withArguments: anArray        "Answer the result of evaluating the elements of the receiver        with &lt;aSymbol&gt; as the selector and &lt;anArray&gt; as the arguments.        The elements must be Messages.  Use only when processing        updates due to a #changed event."    | answer |    self do: [ :each |        answer := each receiver            perform: aSymbol            withArguments: anArray ].    ^answer</body></methods><methods><class-id>UI.Menu</class-id> <category>scheduling-popupmenu</category><body package="GF/ST Base">startUpForView: view	"Attempt to open the receiver as a menu.	NOTE:  		This message is for compatibility with old PopUpMenu.  		It is recommended that you use a Menu instead and use a subclass of MenuView to the open the Menu.	Allow the user to select from the menu.  	Answer the MenuItem value that is selected (or 0 if none was selected)."	| menuItem |	menuItem := (view widgetPolicy menuViewForMenu: self) openFromView: view.	^menuItem isNil 		ifTrue: [0] 		ifFalse: [menuItem value]</body></methods><methods><class-id>Core.Number</class-id> <category>graphics directions</category><body package="GF/ST Base">down: num"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self + num</body><body package="GF/ST Base">isAboveEqual: num"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self &lt;= num</body><body package="GF/ST Base">isBelowEqual: num"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self &gt;= num</body><body package="GF/ST Base">left: num"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self - num</body><body package="GF/ST Base">right: num"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self + num</body></methods><methods><class-id>Core.Number</class-id> <category>truncation and round off</category><body package="GF/ST Base">roundUpTo: aNumber "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the integer that is a multiple of the argument, aNumber,	that is nearest the receiver."	^(self / aNumber) ceiling * aNumber</body></methods><methods><class-id>Core.Number</class-id> <category>graphics directions</category><body package="GF/ST Base">up: num"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self - num</body></methods><methods><class-id>Graphics.HostPrintJob</class-id> <category>accessing</category><body package="GF/ST Base">resolution"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(self xResolution) @ (self yResolution)</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>testing</category><body package="GF/ST Base">isScrollingContainer"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^true</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>GF/ST</category><body package="GF/ST Base">max"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This is meant to return the current maximum internal value 	of the receiver.  For ArithmeticValues, this is just self, but for other	more complex entities such as Point, it is not this simple."	^self</body></methods><methods><class-id>Core.MessageSend</class-id> <category>accessing</category><body package="GF/ST Base">argument: anObject"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	args := (Array with: anObject)</body></methods><methods><class-id>Core.MessageSend</class-id> <category>converting</category><body package="GF/ST Base">copyUsing: replacementDictionary"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| newMessage newArgs newReceiver |	newArgs := (args == nil 			ifTrue: [ nil ]			ifFalse: [ args copy ]).	newReceiver := ((replacementDictionary includesKey: self receiver) 		ifTrue: [ replacementDictionary at: receiver]		ifFalse: [ receiver ]).	newMessage := self class new receiver: newReceiver selector: selector arguments: newArgs.	1 to: args size do: [ :i | 		 newMessage arguments at: i put: ((self arguments at: i) copyUsing: replacementDictionary) ].	^newMessage</body></methods><methods><class-id>Core.MessageSend</class-id> <category>evaluating</category><body package="GF/ST Base">evaluateIfNoTarget: newTarget"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| rslt |	receiver == nil ifTrue: [		receiver := newTarget.		rslt := self evaluate.		receiver := nil.		^rslt	].	^self evaluate</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget withArguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| rslt |	receiver == nil ifTrue: [		receiver := newTarget.		rslt := self evaluateWithArguments: anArray.		receiver := nil.		^rslt	].	^self evaluateWithArguments: anArray</body></methods><methods><class-id>Core.MessageSend</class-id> <category>accessing</category><body package="GF/ST Base">evaluateWith: anArg"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| oldArgs retVal |	oldArgs := args.	args := Array with: anArg.	[retVal := self value ] ensure: [ args := oldArgs ].	^retVal.</body></methods><methods><class-id>Core.MessageSend</class-id> <category>evaluating</category><body package="GF/ST Base">performDeferred"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	[ self evaluate ] fork</body></methods><methods><class-id>Core.MessageSend</class-id> <category>accessing</category><body package="GF/ST Base">receiver: anObject selector: aSymbol arguments: anArray"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	receiver := anObject.	selector := aSymbol.	args := anArray</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>GF/ST</category><body package="GF/ST Base">bringToFront: aFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    #PolymorphicAdded.    aFigure damaged.    ^self        remove: aFigure ifAbsent: [^self];        addFirst: aFigure</body><body package="GF/ST Base">conflict: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    #PolymorphicAdded.	^self select: [:each | each containedBy: aRectangle]</body><body package="GF/ST Base">deepCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"It is assumed that all of my elements know how to make deep copies of themselves"	| new |	new := self species new: self size.	self do: [ :each | new add: each deepCopy ].	^new</body><body package="GF/ST Base">pointContainer: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    | hit |    #PolymorphicAdded.    self reverseDo: [:each | (each ~~ nil and: [ hit := each graphicObjectAt: aPoint ]) == nil ifFalse: [^hit]].    ^hit</body><body package="GF/ST Base">reversed"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a new object containing the         elements of the receiver in reverse order."	| reverseCollection |	reverseCollection := self species new: self size.	self reverseDo: [ :each | reverseCollection add: each ].	^reverseCollection</body><body package="GF/ST Base">sendToBack: aFigure"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    #PolymorphicAdded.    aFigure damaged.    ^self        remove: aFigure ifAbsent: [^self];        addLast: aFigure</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>testing</category><body package="GF/ST Base">isValid"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^true</body></methods><methods><class-id>Core.EvaluableAction</class-id> <category>GF/ST</category><body package="GF/ST Base">asGFEndPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Polymorphic.GFEvaluableActionEndPlug fromAction: self</body><body package="GF/ST Base">asPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the value of the receiver, which is assumed to be a point"	#PolymorphicAdded.    ^self evaluate</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>copying</category><body package="GF/ST Base">deepCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self</body></methods><methods><class-id>Core.Message</class-id> <category>converting</category><body package="GF/ST Base">asGFEndPlug"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Polymorphic.GFEvaluableActionEndPlug fromAction: self</body></methods><methods><class-id>Graphics.ScreenGraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">fastCopyRectangularAreaOrigin: topLeft extent: extent from: aGraphicsContext"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Copy a rectangular area of aGraphicsContext's display medium to 	my display medium. The source area is described by 	aShape, translated by srcOffsetX@srcOffsetY in the coordinate system of 	aGraphicsContext. The destination area is described by aShape 	translated by destOffsetX@destOffsetY in my coordinate system. 		The source graphics context (aGraphicsContext) is used only to	specify the medium and coordinate system (translation).  No other	parameters of the source graphics context affect the copy operation.		Answer an array of damage rectangles indicating what areas of my 	display medium are damaged because they correspond to portions of 	the source display medium that could not be copied."	| damageArray |	damageArray := self				primCopyRectangularAreaExtent: extent				from: aGraphicsContext				sourceOffset: topLeft				destinationOffset: topLeft.	damageArray size = 0		ifTrue: [^damageArray]		ifFalse: 			[| rectArray |			rectArray := Array new: damageArray size.			1 to: rectArray size do: 				[:i | 				| damageRect |				damageRect := damageArray at: i.				rectArray at: i put:							(Rectangle								origin: (damageRect at: 1) @ (damageRect at: 2)								extent: (damageRect at: 3) @ (damageRect at: 4))].			^rectArray]</body></methods><methods><class-id>Graphics.ScreenGraphicsContext</class-id> <category>private-scaling</category><body package="GF/ST Base">installFont: aFont"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| fontToInstall fontScale oldSize desc |	fontScale := scaleX min: scaleY.	oldSize := (desc := aFont fontDescription) pixelSize.	fontScale = 1.0 		ifTrue: [ fontToInstall := aFont ]		ifFalse: [ fontToInstall := desc pixelSize: (oldSize * fontScale) rounded ].	fontToInstall installOn: self.	desc pixelSize: oldSize.</body></methods><methods><class-id>Graphics.ImplementationFont class</class-id> <category>private-size adjustment</category><body package="GF/ST Base">sizeAdjustment"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^1.51</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>private-text</category><body package="GF/ST Base">cheesyDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| temp pen |	temp := Polymorphic.GFPixmap extent: aRect extent.	pen := temp pen.	pen setForeColorTo: paint.	self font installOn: pen.		pen			displayString: text			from: 1			to: text size			at: (font basePoint).		self gfExecute: [ temp asImage displayOn: self at: aRect origin ] clipRect: aRect.		temp release</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">gfExecute: aBlock clipRect: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		| cX cY cW cH |	[cX := clipOriginX.	cY := clipOriginY. 	cW := clipWidth. 	cH := clipHeight.	self intersectClip: rect.	aBlock value.]		ensure:			[self medium flush.			clipOriginX := cX.			clipOriginY := cY. 			clipWidth := cW. 			clipHeight := cH]</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>primitives-text</category><body package="GF/ST Base">installFont: aFont"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		aFont installOn: self.</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>private-text</category><body package="GF/ST Base">properDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self		displayString: text		from: 1		to: text size		at: (aRect origin leftAndDown: font basePoint)</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">quickDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Host printing of text seems to have some inconsistencies.  If these	inconsistencies (incorrect z-order or clipping bounds) need to be side	stepped, then use the alternative display method.  (The alternative 	display method will create a pixmap, display the text on it and then	display the pixmap onto the host printer pen.)"	self useFonts 		ifTrue: [self properDisplayText: text in: aRect]		ifFalse: [self cheesyDisplayText: text in: aRect]</body><body package="GF/ST Base">superDisplayRectangle: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self displayRectangle: (Rectangle origin: (aRect origin unscaledFrom: self scale) extent: (aRect extent unscaledFrom: self scale))</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">useFonts"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	clientData == nil ifTrue: [ ^true ].	^clientData at: #useFonts ifAbsent: [ true ]</body><body package="GF/ST Base">useFonts: useFonts"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self checkClientData.	clientData at: #useFonts put: useFonts</body></methods><methods><class-id>Core.Symbol</class-id> <category>GF/ST</category><body package="GF/ST Base">copyUsing: figures	^self</body></methods><methods><class-id>Core.Symbol</class-id> <category>psi event handling</category><body package="GF/ST Base">evaluateIfNoTarget: newTarget	^newTarget perform: self</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget with: anObject	^newTarget perform: self with: anObject</body><body package="GF/ST Base">evaluateIfNoTarget: newTarget withArguments: anArray	^newTarget perform: self withArguments: anArray</body><body package="GF/ST Base">isAppropriateActionFor: anObject	^anObject respondsTo: self</body></methods><methods><class-id>Core.String</class-id> <category>GF/ST</category><body package="GF/ST Base">asInteger"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self asNumber</body><body package="GF/ST Base">replaceEscapeCharacters"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Replace any C-style escape sequences        with their literal character equivalents."    | inStream outStream char |    inStream := self readStream.    outStream := ( self species new ) writeStream.    [ inStream atEnd ] whileFalse: [        ( char := inStream next ) == $\            ifTrue: [                char := inStream next.                char == $n                    ifTrue: [ outStream nextPut: Character lf ].                char == $t                    ifTrue: [ outStream tab ].                char == $u                    ifTrue: [ outStream nextPut: $&amp; ].            ]            ifFalse: [ outStream nextPut: char ] ].    ^outStream contents</body></methods><methods><class-id>Graphics.Pixmap</class-id> <category>displaying</category><body package="GF/ST Base">displayAt: point with: pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^pen isGFScalingPen		ifTrue: [ self displayOn: pen at: point ]		ifFalse: [ "It is assumed that if execution is here, it is a printing pen"				self asImage displayOn: pen at: point ]</body></methods><methods><class-id>Graphics.Pixmap</class-id> <category>accessing</category><body package="GF/ST Base">pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self graphicsContext</body></methods><methods><class-id>Graphics.Pixmap</class-id> <category>private</category><body package="GF/ST Base">showNow"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"for debugging purposes only!!!"	| gc |	gc := ScheduledControllers activeController view graphicsContext.	self displayOn: gc.</body></methods><methods><class-id>Graphics.Mask</class-id> <category>accessing</category><body package="GF/ST Base">pen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self graphicsContext</body></methods><methods><class-id>Graphics.Mask</class-id> <category>private</category><body package="GF/ST Base">showNow"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"for debugging purposes only!!!"	| gc |	gc := ScheduledControllers activeController view graphicsContext.	self displayOn: gc.</body></methods><methods><class-id>UI.Cursor</class-id> <category>displaying</category><body package="GF/ST Base">change"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self show</body><body package="GF/ST Base">changeFor: aBlock"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self showWhile: aBlock</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>GF/ST</category><body package="GF/ST Base">sortOnNewCollection: col"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Set the contents of the receiver to the col, resort"	#PolymorphicAdded.	self removeAllSuchThat: [:each | true].	self addAll: col.</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>uilayout</category><body package="GF/ST Base">subtreeNeedsLayout	container ifNotNil: #subtreeNeedsLayout</body></methods><methods><class-id>Graphics.HostPrinterGraphicsContext</class-id> <category>private-text</category><body package="GF/ST Base">cheesyDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| temp pen |	temp := Polymorphic.GFPixmap extent: aRect extent.	pen := temp pen.	pen setForeColorTo: paint.	self font installOn: pen.		pen			displayString: text			from: 1			to: text size			at: (font basePoint).		self gfExecute: [ temp asImage displayOn: self at: aRect origin ] clipRect: aRect.		temp release</body></methods><methods><class-id>Graphics.HostPrinterGraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">gfExecute: aBlock clipRect: rect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		| cX cY cW cH |	[cX := clipOriginX.	cY := clipOriginY. 	cW := clipWidth. 	cH := clipHeight.	self intersectClip: rect.	aBlock value.]		ensure:			[self medium flush.			clipOriginX := cX.			clipOriginY := cY. 			clipWidth := cW. 			clipHeight := cH]</body></methods><methods><class-id>Graphics.HostPrinterGraphicsContext</class-id> <category>primitives-text</category><body package="GF/ST Base">installFont: aFont"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		aFont installOn: self.</body></methods><methods><class-id>Graphics.HostPrinterGraphicsContext</class-id> <category>private-text</category><body package="GF/ST Base">properDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self		displayString: text		from: 1		to: text size		at: (aRect origin leftAndDown: font basePoint)</body></methods><methods><class-id>Graphics.HostPrinterGraphicsContext</class-id> <category>displaying</category><body package="GF/ST Base">quickDisplayText: text in: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Host printing of text seems to have some inconsistencies.  If these	inconsistencies (incorrect z-order or clipping bounds) need to be side	stepped, then use the alternative display method.  (The alternative 	display method will create a pixmap, display the text on it and then	display the pixmap onto the host printer pen.)"	self useFonts 		ifTrue: [self properDisplayText: text in: aRect]		ifFalse: [self cheesyDisplayText: text in: aRect]</body><body package="GF/ST Base">superDisplayRectangle: aRect"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self displayRectangle: (Rectangle origin: (aRect origin unscaledFrom: self scale) extent: (aRect extent unscaledFrom: self scale))</body></methods><methods><class-id>Graphics.HostPrinterGraphicsContext</class-id> <category>GF/ST</category><body package="GF/ST Base">useFonts"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	clientData == nil ifTrue: [ ^true ].	^clientData at: #useFonts ifAbsent: [ true ]</body><body package="GF/ST Base">useFonts: useFonts"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	self checkClientData.	clientData at: #useFonts put: useFonts</body></methods><methods><class-id>Core.Point</class-id> <category>GF/ST point functions</category><body package="GF/ST Base">alignToGrid: grid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	"Snap aPoint to the grid.  This is a destructive operation.	 IE, the point is modified to be constrained to the grid.	"	| mod p |	#PolymorphicAdded.	mod := self \\ grid.	p := self - mod + ((mod / grid) rounded * grid).	x := p x.	y := p y.</body><body package="GF/ST Base">becomeLeftMostAndHighest: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Change the receiver's x and y to have the left-most x-coordinates         and the top-most y-coordinates of the receiver         and aPoint."	#PolymorphicAdded.    x := x min: aPoint x.    y := y min: aPoint y.</body><body package="GF/ST Base">becomeLeftMostAndLowest: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Change the receiver's x and y to have the left-most x-coordinates         and the bottom-most y-coordinates of the receiver         and aPoint."	#PolymorphicAdded.    x := x leftMost: aPoint x.    y := y lowerOf: aPoint y.</body><body package="GF/ST Base">becomeMostOriginal: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	x := x min: aPoint x.	y := y min: aPoint y.</body><body package="GF/ST Base">becomeRightMostAndLowest: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    "Change the receiver's x and y to have the right-most x-coordinates         and the bottom-most y-coordinates of the receiver         and aPoint."	#PolymorphicAdded.    x := x max: aPoint x.    y := y max: aPoint y.</body><body package="GF/ST Base">deepCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self species x: x y: y</body><body package="GF/ST Base">deviceToLogical: scalingPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"		^scalingPen scaling 		ifTrue: [ (self / scalingPen scale) rounded ] 		ifFalse: [ self ]</body><body package="GF/ST Base">extendedByScalar: delta"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	x := x + delta.	y := y + delta.</body><body package="GF/ST Base">extentWith: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self extent: aPoint</body><body package="GF/ST Base">initializeFrom: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	#PolymorphicAdded.    x := aPoint x.    y := aPoint y.</body><body package="GF/ST Base">inside: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"		#PolymorphicAdded.    ^(self isLeftAndAbove: aPoint) or: [self isRightAndAbove: aPoint]</body><body package="GF/ST Base">insureAboveAndLeftOf: aPoint in: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Adjust the receiver and aPoint such that        "	#PolymorphicAdded.    (self isLeftAndAbove: aPoint)        ifTrue: [            aRectangle                leftTop: self;                rightBottom: aPoint.        ]        ifFalse: [            aRectangle                leftTop: aPoint;                rightBottom: self.        ]</body><body package="GF/ST Base">leftAndDown: delta"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| pt |	pt := delta asPoint.	^pt x: x - pt x y: y + pt y</body><body package="GF/ST Base">leftAndUp: delta"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self - delta</body><body package="GF/ST Base">leftMostAndHighest: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a Point with the left-most x-coordinates         and the top-most y-coordinates of the receiver         and aPoint."    ^(x min: aPoint x) @ (y min: aPoint y)</body><body package="GF/ST Base">max"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"This is meant to return the current maximum internal value 	of the receiver."	^(x max: y)</body><body package="GF/ST Base">moveLeftAndUp: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	x := x - pt x.	y := y - pt y.</body><body package="GF/ST Base">moveLeftAndUpScalar: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Move the receiver leftAndUp a delta"	#PolymorphicAdded.	x := x left: delta.	y := y up: delta.</body><body package="GF/ST Base">moveRightAndDown: pt"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	x := x + pt x.	y := y + pt y.</body><body package="GF/ST Base">moveRightAndDownScalar: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Move the receiver rightAndDown a delta"	#PolymorphicAdded.	x := x right: delta.	y := y down: delta.</body><body package="GF/ST Base">moveRightAndUpScalar: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Move the receiver rightAndUp a delta"	#PolymorphicAdded.	x := x right: delta.	y := y up: delta.</body><body package="GF/ST Base">rectangleWith: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	#PolymorphicAdded.    ^Rectangle        origin: (self leftMostAndHighest: aPoint)        corner: (aPoint rightMostAndLowest: self)</body><body package="GF/ST Base">rightAndDown: delta"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self + delta</body><body package="GF/ST Base">rightBottom: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^Rectangle origin: self corner: aPoint</body><body package="GF/ST Base">rightMostAndLowest: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a Point with the right-most x-coordinates         and the bottom-most y-coordinates of the receiver         and aPoint."    ^(x max: aPoint x) @ (y max: aPoint y)</body><body package="GF/ST Base">roundUpTo: aNumber "Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"Answer the value that is an integer multiple of the argument,	aNumber, that is nearest the receiver."	^(self / aNumber) ceiling * aNumber</body></methods><methods><class-id>Core.Point</class-id> <category>scaling</category><body package="GF/ST Base">scaleBy: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self * aPoint</body><body package="GF/ST Base">scaledCeilingTo: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scale |	scale := aPoint asPoint.	^(scale x * x) ceiling @ ((scale y * y) ceiling)</body><body package="GF/ST Base">scaledFloorTo: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scale |	scale := aPoint asPoint.	^(scale x * x) floor @ ((scale y * y) floor)</body><body package="GF/ST Base">scaledTo: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scale |	scale := aPoint asPoint.	^(scale x * x) rounded @ ((scale y * y) rounded)</body></methods><methods><class-id>Core.Point</class-id> <category>GF/ST point functions</category><body package="GF/ST Base">snapToGrid: grid"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	| mod |	#PolymorphicAdded.	mod := self \\ grid.	^self - mod + ((mod / grid) rounded * grid)</body><body package="GF/ST Base">translateBy: aDelta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Answer the receiver incremented by aDelta"	#PolymorphicAdded.	^self rightAndDown: aDelta</body><body package="GF/ST Base">translatedByPoint: aPoint"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Answer the receiver with its x-coordinate         incremented by aPoint x and y-coordinate         incremented by aPoint y."	#PolymorphicAdded.	x := x + aPoint x.	y := y + aPoint y.</body></methods><methods><class-id>Core.Point</class-id> <category>scaling</category><body package="GF/ST Base">unscaledFrom: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	| scalePoint | 	scalePoint := aPoint asPoint.	^(x / scalePoint x) rounded @ ((y / scalePoint y) rounded)</body></methods><methods><class-id>Core.Point</class-id> <category>GF/ST point functions</category><body package="GF/ST Base">value"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	#PolymorphicAdded.</body><body package="GF/ST Base">x: xVal y: yVal"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"	#PolymorphicAdded.    x := xVal.    y := yVal.</body></methods><methods><class-id>Core.InternalStream</class-id> <category>accessing</category><body package="GF/ST Base">nextLine	^self upTo: Character cr</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>growUnits</category><body package="GF/ST Base">leftBottomGrowUnit"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    #PolymorphicAdded.	^-1@1</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>instance creation</category><body package="GF/ST Base">leftTop: origin rightBottom: corner"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self origin: origin corner: corner</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>growUnits</category><body package="GF/ST Base">leftTopGrowUnit"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	^-1@ -1</body><body package="GF/ST Base">rightBottomGrowUnit"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"    #PolymorphicAdded.	^1@1</body><body package="GF/ST Base">rightTopGrowUnit"Copyright (C) 1995 Polymorphic Software, Inc.  All Rights Reserved"	^1@ -1</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>copying</category><body package="GF/ST Base">deepCopy"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^origin copy corner: corner copy</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>GF/ST rectangle functions</category><body package="GF/ST Base">expandBy: delta"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self expandedBy: delta</body><body package="GF/ST Base">expandByPoint: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a Rectangle which is the receiver expanded         by delta, where delta is a Point"    ^(origin - delta)        corner: (corner + delta).</body><body package="GF/ST Base">expandByRectangle: delta"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	origin moveLeftAndUp: delta origin.	corner moveRightAndDown: delta corner.</body><body package="GF/ST Base">expandByScalar: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a Rectangle which is the receiver expanded         by delta, where delta is a scalar value"    ^((origin x - delta) @ (origin y - delta))        corner: ((corner x + delta) @ (corner y + delta)).</body><body package="GF/ST Base">expandedByPoint: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a Rectangle which is the receiver expanded         by delta, where delta is a Point"    origin moveLeftAndUp: delta.    corner moveRightAndDown: delta.</body><body package="GF/ST Base">expandedByScalar: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Expand the receiver by delta, where delta is a Number."    #PolymorphicAdded.    origin moveLeftAndUpScalar: delta.    corner moveRightAndDownScalar: delta.</body><body package="GF/ST Base">initializeFrom: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"    #PolymorphicAdded.    origin initializeFrom: aRectangle leftTop.    corner initializeFrom: aRectangle rightBottom.</body><body package="GF/ST Base">leftBottom"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(origin x) @ (corner y)</body><body package="GF/ST Base">leftTop"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^origin</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>converting</category><body package="GF/ST Base">logicalToDevice: aPen"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"no-op for now"</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>GF/ST rectangle functions</category><body package="GF/ST Base">mergeWith: aRectangle"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Merge the receiver and a rectangle"    #PolymorphicAdded.    origin becomeLeftMostAndHighest: aRectangle leftTop.    corner becomeRightMostAndLowest: aRectangle rightBottom.</body><body package="GF/ST Base">rightBottom"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^corner</body><body package="GF/ST Base">rightBottom: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	corner := aPoint</body><body package="GF/ST Base">rightTop"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^(corner x) @ (origin y)</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>transforming</category><body package="GF/ST Base">scaleBy: aPoint"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	^self class new origin: (origin scaleBy: aPoint) corner: (corner scaleBy: aPoint)</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>GF/ST rectangle functions</category><body package="GF/ST Base">translatedByPoint: delta"Copyright (C) 1993-1995 Polymorphic Software, Inc.  All Rights Reserved"        "Answer a Rectangle which is the receiver with         position incremented by delta, where delta is a Point."    #PolymorphicAdded.    origin translatedByPoint: delta.    corner translatedByPoint: delta.</body></methods><methods><class-id>Polymorphic.GFFloatingPalette class</class-id> <category>resources</category><body package="GF/ST Base">selectIconImage	"UIMaskEditor new openOnClass: self andSelector: #selectIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 4978 scaledGreen: 6584 scaledBlue: 8191); yourself)) usingBits: #[85 21 85 85 85 0 0 0 85 5 85 85 85 0 0 0 85 33 85 85 85 0 0 0 85 40 85 85 85 0 0 0 85 42 21 85 85 0 0 0 85 42 133 85 85 0 0 0 85 42 161 85 85 0 0 0 85 42 168 85 85 0 0 0 85 42 170 21 85 0 0 0 85 42 170 5 85 0 0 0 85 42 160 85 85 0 0 0 85 42 1 85 85 0 0 0 85 32 168 85 85 0 0 0 85 5 40 85 85 0 0 0 85 85 42 21 85 0 0 0 85 85 74 21 85 0 0 0 85 85 74 133 85 0 0 0 85 85 82 133 85 0 0 0 85 85 82 21 85 0 0 0 85 85 84 85 85 0 0 0])</body><body package="GF/ST Base">stickyIconImage	"UIMaskEditor new openOnClass: self andSelector: #stickyIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: (Graphics.ColorValue scaledRed: 7227 scaledGreen: 7227 scaledBlue: 7227); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@CL3L3L0@@@"H"H"HCL3L3L0@@@"H"H"HCL3L3L0@@@"H"H"HCL3L3L0@@@"H@@@@@@@L3L0@@@"HADQDQDPL3L0@@@"HADQDQDPL3L0@@@"HADQDQDPL3L0@@@"HADQDQDPL3L0@@@"HADQ@@@@@@@@@@@@@ADQADQDQDP@@@L3LADQADQDQDP@@@L3LADQADQDQDP@@@L3LADQADQDQDP@@@L3L@@@ADQDQDP@@@L3L3L3ADQDQDP@@@L3L3L3ADQDQDP@@@L3L3L3ADQDQDP@@@L3L3L3ADQDQDP@@@L3L3L3@@@@@@@@@@'))</body></methods><methods><class-id>Polymorphic.GFFloatingPalette class</class-id> <category>interface specs</category><body package="GF/ST Base">windowSpec"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Palette' 			#min: #(#Point 94 77 ) 			#bounds: #(#Rectangle 617 171 711 248 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Rectangle 3 3 31 31 ) 					#name: #selectTool 					#flags: 0 					#colors: 					#(#LookPreferences 						#setSelectionBackgroundColor: #(#ColorValue #black ) ) 					#model: #select 					#tabable: false 					#label: #selectIconImage 					#hasCharacterOrientedLabel: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -31 1 3 0 -3 1 31 0 ) 					#flags: 0 					#colors: 					#(#LookPreferences 						#setSelectionBackgroundColor: #(#ColorValue #black ) ) 					#model: #Sticky 					#tabable: false 					#label: #stickyIconImage 					#hasCharacterOrientedLabel: false ) 				#(#ArbitraryComponentSpec 					#layout: #(#LayoutFrame 0 0 43 0 0 1 0 1 ) 					#name: #iconView 					#flags: 0 					#colors: 					#(#LookPreferences 						#setSelectionBackgroundColor: #(#ColorValue #black ) ) 					#component: #iconView ) 				#(#DividerSpec 					#layout: #(#Rectangle 0 38 127 42 ) ) ) ) )</body></methods><methods><class-id>Polymorphic.GFFontChooser class</class-id> <category>interface specs</category><body package="GF/ST Base">windowSpec"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Choose a Font' 			#min: #(#Point 278 239 ) 			#max: #(#Point 278 239 ) 			#bounds: #(#Rectangle 467 237 745 476 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#Rectangle 10 24 119 107 ) 					#name: #familyList 					#model: #familyList ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 130 24 209 107 ) 					#name: #styleList 					#model: #styleList ) 				#(#SequenceViewSpec 					#layout: #(#Rectangle 219 24 269 107 ) 					#name: #sizeList 					#model: #sizeList ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 24 0 0 1 ) 					#label: 'family:' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 130 0 24 0 0 1 ) 					#label: 'style:' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 219 0 24 0 0 1 ) 					#label: 'size:' ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 5 0 -130 1 -5 1 -42 1 ) 					#label: 'preview' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #accept 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#LayoutFrame 8 0 -112 1 -8 1 -46 1 ) 					#name: #sample 					#label: 'Aa Bb Cc' ) ) ) )</body></methods><methods><class-id>Polymorphic.ColorChooser class</class-id> <category>interface specs</category><body package="GF/ST Base">windowSpec"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Color Tool' 			#min: #(#Point 243 234 ) 			#max: #(#Point 243 257 ) 			#bounds: #(#Rectangle 504 307 747 541 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#MenuButtonSpec 					#layout: #(#LayoutFrame -71 1 139 0 -7 1 164 0 ) 					#flags: 0 					#model: #colorName 					#label: ' ' 					#menu: #colorMenu ) 				#(#CompositeSpecCollection 					#collection: #() 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#LayoutFrame -71 1 130 0 -7 1 160 0 ) 						#name: #theActualColor 						#colors: #(#LookPreferences ) ) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame -72 1 130 0 -6 1 160 0 ) 					#flags: 0 					#model: #colorName 					#label: ' ' 					#menu: #colorMenu ) 				#(#SliderSpec 					#layout: #(#Rectangle 6 6 27 125 ) 					#model: #sliderModel 					#orientation: #vertical ) 				#(#LabelSpec 					#layout: #(#Point 5 129 ) 					#label: 'V' ) 				#(#LabelSpec 					#layout: #(#Point 4 173 ) 					#name: #hueLabel 					#label: 'H' ) 				#(#CompositeSpecCollection 					#collection: #() 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#LayoutFrame 32 0 6 0 -6 1 125 0 ) 						#name: #colorSpace 						#flags: 8 						#isOpaque: true ) ) 				#(#SliderSpec 					#layout: #(#LayoutFrame 20 0 175 0 -80 1 192 0 ) 					#name: #hue 					#model: #hue 					#orientation: #horizontal 					#start: 0.0 					#stop: 0.999 					#step: 0.001 ) 				#(#SliderSpec 					#layout: #(#LayoutFrame 20 0 131 0 -80 1 148 0 ) 					#model: #brightness 					#orientation: #horizontal 					#start: 0.0 					#stop: 1.0 					#step: 0.001 ) 				#(#SliderSpec 					#layout: #(#LayoutFrame 20 0 153 0 -80 1 170 0 ) 					#name: #saturation 					#model: #saturation 					#orientation: #horizontal 					#start: 0.0 					#stop: 1.0 					#step: 0.001 ) 				#(#LabelSpec 					#layout: #(#Point 4 151 ) 					#name: #saturationLabel 					#label: 'S' ) 				#(#RegionSpec 					#layout: #(#LayoutFrame -72 1 131 0 -6 1 163 0 ) 					#lineWidth: 1 ) 				#(#CompositeSpecCollection 					#collection: #() 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#LayoutFrame -71 1 132 0 -7 1 162 0 ) 						#name: #theActualColor 						#colors: #(#LookPreferences ) ) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #accept 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Polymorphic.ColorChooser class</class-id> <category>resources</category><body package="GF/ST Base">colorMenu"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"UIMenuEditor new openOnClass: self andSelector: #colorMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'Named Colors' 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'black' ) 						#(#MenuItem 							#label: 'blue' ) 						#(#MenuItem 							#label: 'brown' ) 						#(#MenuItem 							#label: 'chartreuse' ) 						#(#MenuItem 							#label: 'cyan' ) 						#(#MenuItem 							#label: 'darkCyan' ) 						#(#MenuItem 							#label: 'darkGray' ) 						#(#MenuItem 							#label: 'darkGreen' ) 						#(#MenuItem 							#label: 'darkMagenta' ) 						#(#MenuItem 							#label: 'darkRed' ) 						#(#MenuItem 							#label: 'olive' ) 						#(#MenuItem 							#label: 'gray' ) 						#(#MenuItem 							#label: 'green' ) 						#(#MenuItem 							#label: 'lightYellow' ) 						#(#MenuItem 							#label: 'lightGray' ) 						#(#MenuItem 							#label: 'magenta' ) 						#(#MenuItem 							#label: 'navy' ) 						#(#MenuItem 							#label: 'orange' ) 						#(#MenuItem 							#label: 'orchid' ) 						#(#MenuItem 							#label: 'paleGreen' ) 						#(#MenuItem 							#label: 'pink' ) 						#(#MenuItem 							#label: 'purple' ) 						#(#MenuItem 							#label: 'red' ) 						#(#MenuItem 							#label: 'royalBlue' ) 						#(#MenuItem 							#label: 'salmon' ) 						#(#MenuItem 							#label: 'lightCyan' ) 						#(#MenuItem 							#label: 'springGreen' ) 						#(#MenuItem 							#label: 'veryDarkGray' ) 						#(#MenuItem 							#label: 'veryLightGray' ) 						#(#MenuItem 							#label: 'white' ) 						#(#MenuItem 							#label: 'yellow' ) ) #(31 ) #(#black #blue #brown #chartreuse #cyan #darkCyan #darkGray #darkGreen #darkMagenta #darkRed #olive #gray #green #lightYellow #lightGray #magenta #navy #orange #orchid #paleGreen #pink #purple #red #royalBlue #salmon #lightCyan #springGreen #veryDarkGray #veryLightGray #white #yellow ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Polymorphic.GFDrawingEditor class</class-id> <category>resources</category><body package="GF/ST Base">fileMenu"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"UIMenuEditor new openOnClass: self andSelector: #fileMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'Exit' 				#accessCharacterPosition: 2 ) ) #(1 ) #(#closeRequest ) ) decodeAsLiteralArray</body></methods><methods><class-id>Polymorphic.GFDrawingEditor class</class-id> <category>interface specs</category><body package="GF/ST Base">windowSpec"Copyright (C) 1993-1996 Polymorphic Software, Inc.  All Rights Reserved"	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Drawing' 			#bounds: #(#Rectangle 300 322 666 615 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#RegionSpec 					#layout: #(#LayoutFrame -1 0 -29 1 1 1 1 1 ) 					#name: #region 					#colors: 					#(#LookPreferences 						#setForegroundColor: #(#ColorValue #white ) ) 					#lineWidth: 1 ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 7 0 -27 1 152 0 -2 1 ) 					#name: #category 					#model: #currentCategory 					#style: #systemDefault 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 166 0 -27 1 311 0 -2 1 ) 					#name: #tool 					#model: #currentTool 					#style: #systemDefault 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 327 0 -27 1 472 0 -2 1 ) 					#name: #handleInfo 					#model: #handle 					#style: #systemDefault 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 487 0 -27 1 632 0 -2 1 ) 					#name: #point 					#model: #currentPoint 					#style: #systemDefault 					#isReadOnly: true ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0 -30 1 0 1 -26 1 ) 					#name: #divider1 ) 				#(#ArbitraryComponentSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 -30 1 ) 					#name: #view 					#flags: 11 					#component: #gfView ) ) ) )</body></methods><initialize><class-id>Polymorphic.GFHandle</class-id></initialize><initialize><class-id>Polymorphic.GFTool</class-id></initialize><initialize><class-id>Polymorphic.GFGraphicObject</class-id></initialize><initialize><class-id>Polymorphic.GFSplineGO</class-id></initialize><initialize><class-id>Polymorphic.GFQuadTreeElement</class-id></initialize><initialize><class-id>Polymorphic.GFOrthogonalPathGO</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GraphicsContext</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>medium clipOriginX clipOriginY clipWidth clipHeight lineWidth capStyle joinStyle deviceFont devicePaint offsetX offsetY phaseX phaseY scaleX scaleY font paint paintPolicy fontPolicy clientData paintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>HostPrinterGraphicsContext</name><environment>Graphics</environment><super>Graphics.GraphicsContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Printing-Host</category><attributes><package>Graphics-Printing-Host</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>OpaqueImage</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure shape </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ScreenGraphicsContext</name><environment>Graphics</environment><super>Graphics.GraphicsContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>ArithmeticValue</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Message</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>HostPrintJob</name><environment>Graphics</environment><super>Graphics.GraphicsMedium</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle height landscape printer width xResolution yResolution xPixelsPerPoint yPixelsPerPoint pageAtEnd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Printing-Host</category><attributes><package>Graphics-Printing-Host</package></attributes></class><class><name>Mask</name><environment>Graphics</environment><super>Graphics.UnmappableSurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>FontDescription</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name family manufacturer pixelSize flags masks color encoding encodings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Image</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bits width height depth bitsPerPixel palette maxPixelValue rowByteSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Cursor</name><environment>UI</environment><super>OS.OSHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image mask hotSpot name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>InternalStream</name><environment>Core</environment><super>Core.PositionableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>WidgetController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cursor activeAccessor evenIfKeyPressed controlBlock enableYellowButton </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>Menu</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items groupSizes adornment selectionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>EvaluableAction</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>DeviceFont</name><environment>Graphics</environment><super>Graphics.ImplementationFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>MessageSend</name><environment>Core</environment><super>Core.Message</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>PostScriptGraphicsContext</name><environment>Graphics</environment><super>Graphics.GraphicsContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Printing-PostScript</category><attributes><package>Graphics-Printing-PostScript</package></attributes></class><class><name>ActionSequence</name><environment>Core</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class><class><name>UIPalette</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activeSpecs toolName currentLookPolicy stickyStatus </inst-vars><class-inst-vars>selectIcon stickyIcon </class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Pixmap</name><environment>Graphics</environment><super>Graphics.UnmappableSurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>ScrollWrapper</name><environment>UI</environment><super>Graphics.TranslatingWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents preferredBoundsBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class></st-source>