<?xml version="1.0"?><st-source><!-- Name: BraceConstructorComment: This package adds brace Array constructor (a.k.a. ''dynamic array constructor'', a.k.a. Squeak-like {}) support to VisualWorks. Brace constructor creates an Array at execution time from the period-separated expressions inside the braces. A quick example:	{3 + 4. Date today}is equivalent to	Array with: 3 + 4 with: Date todayImplementation limits: Arrays created using this constructor may have a maximum of 256 elements. The implementation relies on a bytecode properly supported in VisualWorks VMs versions 7.2 and above, and will not work in earlier VW versions.Vassili Bykov <vbykov@cincom.com>Thanks to David Pennell for his encouragement, testing, and comments.=====================================This package is made available underThe MIT LicenseCopyright (c) 2005 Vassili BykovPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ''Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: bear73DbTrace: 499185DbUsername: niallrDbVersion: 1.4PackageName: BraceConstructorParcel: #('BraceConstructor')ParcelName: BraceConstructorPrintStringCache: (1.4,niallr)Version: 1.4Post-Load Block: 	[:package | InstructionStream initialize]Post-Unload Block: 	[ InstructionStream initialize]Date: 1:13:49 PM March 10, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (mar17.2) of March 10, 2017 on March 10, 2017 at 1:13:49 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BraceConstructorNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>body </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>BraceConstructor</package></attributes></class><comment><class-id>Kernel.BraceConstructorNode</class-id><body>BraceConstructorNode represents an Array brace constructor expression in the source code.Instance Variables:	body	&lt;SequenceNode&gt;	The sequence of expressions that will provide the elements of the array created by the constructor.</body></comment><shared-variable><name>OpConsArray</name><environment>Kernel.OpcodePool</environment><private>false</private><constant>true</constant><category>Two Byte Misc Codes</category><initializer> 16rD5 </initializer><attributes><package>BraceConstructor</package></attributes></shared-variable><methods><class-id>Kernel.BraceConstructorNode</class-id> <category>testing</category><body package="BraceConstructor">isComplex	^body size &gt; 1</body></methods><methods><class-id>Kernel.BraceConstructorNode</class-id> <category>enumerating</category><body package="BraceConstructor">nodeDo: anEnumerator	^anEnumerator doBlock: self arguments: #() body: body</body></methods><methods><class-id>Kernel.BraceConstructorNode</class-id> <category>initialize-release</category><body package="BraceConstructor">body: aSequence	body := aSequence</body></methods><methods><class-id>Kernel.BraceConstructorNode</class-id> <category>accessing</category><body package="BraceConstructor">body	^body</body></methods><methods><class-id>Kernel.BraceConstructorNode</class-id> <category>printing</category><body package="BraceConstructor">printOn: aStream indent: level	body isComplex ifTrue: [aStream crtab: level].	aStream nextPut: ${.	body printOn: aStream indent: level.	aStream nextPut: $}</body></methods><methods><class-id>Kernel.BraceConstructorNode</class-id> <category>code generation</category><body package="BraceConstructor">emitValue: codeStream	body statements do: [:stmt | stmt emitValue: codeStream].	codeStream		noteSourceStart: self;		putConsArray: body size;		noteSourceEnd: self</body></methods><methods><class-id>Kernel.InstructionStream class</class-id> <category>class initialization</category><body package="BraceConstructor">initializeXMisc: codes numberOfExtensions: numExt combinationRule: combo	codes at: OpCopyValues+1 put: [:client :method :x1 | client pushCopiedValues: x1].	codes at: OpXNoCheckSend+1 put: [:client :method :x1 | client sendNoCheck: (method literalAt: (x1 bitAnd: 31) + 1) numArgs: (x1 bitShift: -5)].	codes at: OpXNonImmediateSend+1 put: [:client :method :x1 | client sendNonImmediate: (method literalAt: (x1 bitAnd: 31) + 1) numArgs: (x1 bitShift: -5)].	codes at: OpXNonImmediateSpecialSend+1 put: [:client :method :x1 | | index |					index := x1 * 2 + 1.					client sendNonImmediate: (SpecialSelectors at: index) numArgs: (SpecialSelectors at: index + 1)].	numExt at: OpFullBlock+1 put: 1.	combo at: OpFullBlock+1 put: ExtensionNormalXCodes.	codes at: OpFullBlock+1 put: [:client :method :x1 | client makeFullBlock: (method literalAt: x1 + 1)].	numExt at: OpXLoadInst+1 put: 1.	combo at: OpXLoadInst+1 put: ExtensionNormalXCodes.	codes at: OpXLoadInst+1 put: [:client :method :x1 | client pushInst: x1].	codes at: OpXLoadTemp+1 put: [:client :method :x1 | client pushLocal: x1].	numExt at: OpXLoadLiteral+1 put: 1.	combo at: OpXLoadLiteral+1 put: ExtensionNormalXCodes.	codes at: OpXLoadLiteral+1 put: [:client :method :x1 | client pushConstant: (method literalAt: x1 + 1)].	numExt at: OpXLoadStatic+1 put: 1.	combo at: OpXLoadStatic+1 put: ExtensionNormalXCodes.	codes at: OpXLoadStatic+1 put: [:client :method :x1 | client pushStatic: (method literalAt: x1 + 1)].	numExt at: OpCreateArray+1 put: 1.	combo at: OpCreateArray+1 put: ExtensionNormalXCodes.	codes at: OpCreateArray+1 put: [:client :method :x1 | client pushNewArray: x1 + 1].	numExt at: OpConsArray+1 put: 1.	combo at: OpConsArray+1 put: ExtensionNormalXCodes.	codes at: OpConsArray+1 put: [:client :method :x1 | client pushConsedArray: x1 + 1].	numExt at: OpLoadCharacter+1 put: 1.	combo at: OpLoadCharacter+1 put: ExtensionNormalXCodes.	codes at: OpLoadCharacter+1 put: [:client :method :x1 | client pushConstant: (Character value: x1)].	codes at: OpLoadByte+1 put: [:client :method :x1 | client pushConstant: x1].	codes at: OpLoadLocalIndirect+1 put: [:client :method :x1 | client pushLocalIndirect: (x1 bitShift: -4) index: (x1 bitAnd: 15)].	numExt at: OpXStorePopInst+1 put: 1.	combo at: OpXStorePopInst+1 put: ExtensionNormalXCodes.	codes at: OpXStorePopInst+1 put: [:client :method :x1 | client storePopInst: x1].	codes at: OpXStorePopTemp+1 put: [:client :method :x1 | client storePopLocal: x1].	codes at: OpStorePopLocalIndirect+1 put: [:client :method :x1 | client storePopLocalIndirect: (x1 bitShift: -4) index: (x1 bitAnd: 15)].</body></methods><methods><class-id>Kernel.InstructionStream</class-id> <category>private-decoding</category><body package="BraceConstructor">interpretXMisc: byte with: x1 for: client	| index |	byte = OpCopyValues ifTrue: [^client pushCopiedValues: x1].	byte = OpXNoCheckSend ifTrue: [^client sendNoCheck: (method literalAt: (x1 bitAnd: 31) + 1) numArgs: (x1 bitShift: -5)].	byte = OpXNonImmediateSend ifTrue: [^client sendNonImmediate: (method literalAt: (x1 bitAnd: 31) + 1) numArgs: (x1 bitShift: -5)].	byte = OpXNonImmediateSpecialSend ifTrue: [index := x1 * 2 + 1.  ^client sendNonImmediate: (SpecialSelectors at: index) numArgs: (SpecialSelectors at: index + 1)].	byte = OpFullBlock ifTrue: [^client makeFullBlock: (method literalAt: x1 + 1)].	byte = OpXLoadInst ifTrue: [^client pushInst: x1].	byte = OpXLoadTemp ifTrue: [^client pushLocal: x1].	byte = OpXLoadLiteral ifTrue: [^client pushConstant: (method literalAt: x1 + 1)].	byte = OpXLoadStatic ifTrue: [^client pushStatic: (method literalAt: x1 + 1)].	byte = OpCreateArray ifTrue: [^client pushNewArray: x1 + 1].	byte = OpConsArray ifTrue: [^client pushConsedArray: x1 + 1].	byte = OpLoadCharacter ifTrue: [^client pushConstant: (Character value: x1)].	byte = OpLoadByte ifTrue: [^client pushConstant: x1].	byte = OpLoadLocalIndirect ifTrue: [^client pushLocalIndirect: (x1 bitShift: -4) index: (x1 bitAnd: 15)].	byte = OpXStorePopInst ifTrue: [^client storePopInst: x1].	byte = OpXStorePopTemp ifTrue: [^client storePopLocal: x1].	byte = OpStorePopLocalIndirect ifTrue: [^client storePopLocalIndirect: (x1 bitShift: -4) index: (x1 bitAnd: 15)].	^client undefined: byte with: x1</body></methods><methods><class-id>Kernel.AssemblerCodeStream</class-id> <category>code generation-loads and stores</category><body package="BraceConstructor">putConsArray: size	self pop: size -1.	code nextPut: OpConsArray with: size - 1.</body></methods><methods><class-id>Kernel.InstructionPrinter</class-id> <category>opcodes-data movement</category><body package="BraceConstructor">pushConsedArray: size	stream		nextPutAll: 'pop ';		print: size;		nextPutAll: ' into new array; '</body></methods><methods><class-id>Kernel.CodeRegenerator</class-id> <category>code generation-loads and stores</category><body package="BraceConstructor">pushConsedArray: size	self pushAll.	self pushPC.	self code putConsArray: size</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-success/error</category><body package="BraceConstructor">bracedStatements	| stmts start blockComment returnStart |	stmts := OrderedCollection new.	blockComment := currentComment.	currentComment := nil.	start := endTemps.	[tokenType == #upArrow		ifTrue: 			[returnStart := mark.			self scanToken.			self expression				ifFalse: [^self expected: 'Expression to return'].			parseNode := builder newReturnValue: parseNode.			self addComment.			parseNode sourcePosition: (returnStart to: self endOfLastToken).			stmts addLast: parseNode.			self match: #period.  "allow optional trailing . after ^"			false]		ifFalse: 			[self expression				ifTrue: 					[self addComment.					stmts addLast: parseNode.					self match: #period]				ifFalse: 					[false]]]		whileTrue.	self addComment.	stmts size &gt; 256		ifTrue: "Hopefully only generated code can be this patient."			[self notify: 'Maximum 256 elements are allowed' at: start].	stmts size = 0 ifTrue: "Empty array, not handled by OpConsArray"		[parseNode := builder			newMessageReceiver: (builder newVariableName: #{Core.Array})			selector: #new			arguments: #().		parseNode addComment: blockComment.		parseNode sourcePosition:			(start to: self endOfLastToken+ (tokenType = #rightBrace ifTrue: [0] ifFalse: [1])).		^self].	(stmts size = 1 and: [blockComment == nil and: [parseNode := stmts first.  parseNode sourcePosition == nil]])		ifTrue:			["No point in building a sequence"]		ifFalse:			[parseNode := builder newSequenceTemporaries: #() statements: stmts].	parseNode := builder newBraceConstructorBody: parseNode.	parseNode		addComment: blockComment;		sourcePosition:			(start to: 				self endOfLastToken + (tokenType = #rightBrace ifTrue: [0] ifFalse: [1]))</body><body package="BraceConstructor">braceExpression	"${ statements $} =&gt; BraceConstructorNode"	| start |	start := mark.	self scanToken.  "skip {"	self bracedStatements.	tokenType == #rightBrace		ifFalse: [^self expected: 'Period or right brace'].	self scanToken.	parseNode sourcePosition: (start to: self endOfLastToken)</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-true/false</category><body package="BraceConstructor">primaryExpression	| start |	tokenType == #word		ifTrue: 			[start := mark.			self constant  "check for nil / true / false"				ifTrue:					[parseNode := builder newLiteralValue: parseNode.					parseNode sourcePosition: (start to: self endOfLastToken)]				ifFalse:					[parseNode := builder newVariableName: token.					parseNode sourcePosition: mark.					self scanToken].			^true].	tokenType == #compoundWord		ifTrue:			[parseNode := self bindingRefAt: token.			parseNode := builder newVariableName: parseNode.			parseNode sourcePosition: mark.			self scanToken.			^true].	tokenType == #leftBracket		ifTrue: 			[self blockExpression.			^true].	tokenType == #leftBrace		ifTrue:			[self braceExpression.			^true].	tokenType == #leftParenthesis		ifTrue: 			[self scanToken.			self expression ifFalse: [^self expected: (#Expression &lt;&lt; #dialogs &gt;&gt; 'expression')].			tokenType == #rightParenthesis				ifFalse: [^self expected: (#RightParenthesis &lt;&lt; #dialogs &gt;&gt; 'right parenthesis')].			self scanToken.			^true].	start := mark.	self constant		ifTrue:			[parseNode := builder newLiteralValue: parseNode.			parseNode sourcePosition: (start to: self endOfLastToken).			^true].	^false</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>opcodes-data movement</category><body package="BraceConstructor">dupFirst	"If the previous op was createArray, this is the beginning of brace constructor."	(stack last class == Association and: [stack last key == #createNewArray])		ifTrue: 			[stack addLast: #braceConstructor -&gt; OrderedCollection new.			stack addLast: #braceConstructorFlag]		ifFalse:			[stack addLast: OrderedCollection new.  "accumulate cascade elements"			stack addLast: CascadeFlag]</body><body package="BraceConstructor">dupLast	| msg braceList node |	msg := stack removeLast.	stack last class == Association		ifTrue: "the brace constructor's marker and expr list"			[braceList := stack removeLast value.			braceList addLast: msg.			stack removeLast. "array creation record, discarded"			node := builder newSequenceTemporaries: #() statements: braceList.			node := builder newBraceConstructorBody: node.			stack addLast: node]		ifFalse:			[stack last addLast: msg.			stack addLast: CascadeLastFlag]</body><body package="BraceConstructor">dupNext	| msg |	msg := stack removeLast.	stack last class == Association		ifTrue: "brace constructor marker and expr list"			[stack last value addLast: msg.			stack addLast: #braceConstructorFlag]		ifFalse:			[stack last addLast: msg.			stack addLast: CascadeFlag]</body><body package="BraceConstructor">pushConsedArray: size	| elements node |	elements := Array new: size.	size to: 1 by: -1 do: [:i | elements at: i put: stack removeLast].	node := builder newSequenceTemporaries: #() statements: elements.	node := builder newBraceConstructorBody: node.	stack addLast: node</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>opcodes-control</category><body package="BraceConstructor">send: selector numArgs: na	| args rcvr r node list |	args := stack removeLast: na.	rcvr := r := stack removeLast.	(selector == #value: and: [na == 1 and: [(rcvr isMemberOf: LiteralNode) and: [rcvr value isVariableBinding]]])		ifTrue:			[stack addAllLast: args.			self pushVarNamed: rcvr value key asString.			self doStore: stack.			^self].	r == #braceConstructorFlag		ifTrue: "#at:put: - ignored but 2nd arg is the element expr we want"			[selector == #at:put:				ifFalse: [self error: 'Unexpected brace constructor pattern'].			stack addLast: (args at: 2).			^self].	(r == CascadeFlag or: [r == CascadeLastFlag])		ifTrue:			["Get the true receiver of the cascade"			rcvr := stack at: stack size - 1].	node := builder newMessageReceiver: rcvr selector: selector arguments: args.	r == CascadeLastFlag		ifTrue:			["This is the last message of a cascade"			list := stack removeLast.  "cascade list"			list addLast: node.			stack removeLast.  "pop the saved receiver"			node := builder newCascadeReceiver: rcvr messages: list asArray].	stack addLast: node</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-data movement</category><body package="BraceConstructor">pushConsedArray: size	| elements |	elements := Array new: size.	size to: 1 by: -1 do: [:i | elements at: i put: stack removeLast].	stack add: elements</body></methods><methods><class-id>Kernel.InstructionClient</class-id> <category>opcodes-data movement</category><body package="BraceConstructor">pushConsedArray: size</body></methods><methods><class-id>Kernel.ProgramNodeBuilder</class-id> <category>node creation-basic</category><body package="BraceConstructor">newBraceConstructorBody: seq	^BraceConstructorNode new body: seq</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-data movement</category><body package="BraceConstructor">pushConsedArray: size	| consedArray |	consedArray := Array new: size.	size to: 1 by: -1 do: [:i | consedArray at: i put: self topPop].	self push: consedArray</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>opcodes-data movement</category><body package="BraceConstructor">pushConsedArray: size	size timesRepeat: [self pop].	self push</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>opcodes-data movement</category><body package="BraceConstructor">pushConsedArray: size	size timesRepeat: [stack removeLast].	stack add: #array.	^false</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>InstructionClient</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Decompiler</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder instVars allParameters localVars copiedVars tempCount stack statements limit primitive primErrorCode lastPc exit lastJumpPc hasValue loopDepth lastAssignment lastAssignVar lastAssignPc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>CodeRegenerator</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent codeGenerator labels lastPC locals stack copiedValues canCopy oldInstVarNames pcStack pcLabels repressNextPop </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProgramNodeBuilder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>LeafNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>DecompilerAnalyzer</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack saved copiedValues stopForBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>AssemblerCodeStream</name><environment>Kernel</environment><super>Kernel.ByteCodeStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodClass needsFrame hybrid forContext method innerBlocks allowNewLiterals copiedVars segments owner outerStream </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Assembler</package></attributes></class><class><name>InstanceVariableSearch</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method input slotIndex searchType stack initialStack saveStacks copied </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>AuxCodeInfoExtractor</name><environment>CraftedSmalltalk</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth jumpStack maxDepth visited </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>InstructionPrinter</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method stream inStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>