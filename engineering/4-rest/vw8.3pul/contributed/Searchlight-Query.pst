<?xml version="1.0"?><st-source><!-- Name: Searchlight-QueryNotice: MIT LicenseCopyright (c) 2008-2014 Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: Searchlight is a search engine for the Smalltalk Image, inspired by Apple Spotlight. It is designed to integrate with the environment. It quickly scans the image across multiple domains from a single search criteria to return the closest search matches in the Refactoring Browser, from the VisualLauncher and in its own incremental search window too.This package contains the search query model for Searchlight and then tools reside in the package Searchlight-Tools.Requires: VisualWorks 7.7+DbIdentifier: bear73DbTrace: 425661DbUsername: smichaelDbVersion: 339DevelopmentPrerequisites: #(#(#any 'Searchlight-Core' ''))DialectVersion: VisualWorks 7.9PackageName: Searchlight-QueryParcel: #('Searchlight-Query')ParcelName: Searchlight-QueryPrerequisiteDescriptions: #(#(#name 'Searchlight-Core' #componentType #package))PrerequisiteParcels: #(#('Searchlight-Core' ''))PrintStringCache: (339,smichael)Version: 339Post-Load Block: 	[:package | ]Pre-Unload Block: 	[:package | Searchlight.SearchDatabase deregister]Date: 11:06:46 AM March 21, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (mar14.3) of March 21, 2014 on March 21, 2014 at 11:06:46 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Implementor</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.Implementor</class-id><body>Implementor represents a method that is actually implemented on a class.Instance Variables:	method	&lt;CompiledMethod&gt;	the method that is an implementor</body></comment><class><name>Primitive</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.Primitive</class-id><body>Primitive represents a method that is actually implemented on a class that calls a primitive.Instance Variables	method	&lt;CompiledMethod&gt;	the method that is an implementor</body></comment><class><name>SearchEngine</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>criteria results searches uppercaseCriteria isAllUppercaseCriteria numericCriteria isMatchCriteria isNumericCriteria matchCriteria lowercaseCriteria criteriaSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.SearchEngine</class-id><body>SearchEngine is the abstract representation of a /kind/ of SearchEngine that will scan memory, the image, disk, a website - whatever. There is no constraint on how it finds results for a certain criteria except that ideally we wish all searches to be fast. Subclasses of SearchEngine specialize it to a particular domain of searching and a particular technique of searching. Result testing for each search engine is specified as a method on the class that contains the pragma &lt;search&gt;.Some of the search engines use indexes that update themselves when something changes in the image, other search engines scan through object hierarchies. The best technique to use for a search engine is always a trade off between memory and speed.Each result test usually calls #match:result: which does a set of standard comparisons with the search criteria:	* Is it an exact match - high scoring result	* Do the capital letters match - high scoring result	* Is it a prefix match with same capitalization - medium scoring result	* Is it a near match, same word, different capitalization - medium scoring result	* Is it a near prefix match, same word, different capitalization - medium scoring result	* Is it a case insensitive substring match - low scoring resultSome searches, such as reference searches, do not do this kind of regular testing - instead they just do an exact match test and the score is meaningless. The result parameter of #match:result: is a block that is only executed if the test passes, otherwise we'd be generating a lot of needless garbage. The method #add:score: is then sent and this generates a Result object that contains both the @object and the @score. The lower the score the more relevant the match is.There are several objects that represent different kinds of results that don't have natural objects in Smalltalk - such as InstanceVariable, MethodLiteral, SharedVariable, Reference, etc. These objects allow us to differentiate the meaning of the result from objects that would otherwise all appear the same.If you want to drive the search engine(s) you have a lot of control over what they will do. When you instantiate a search engine, it sets up its @searches variable that contains the selectors of all the result tests. You can modify this collection to include only the tests you want. Likewise, the common API to do a search is " SearchEngine searchImage: 'Smalltalk' " - but this is an aggregate API that fires off the common top most search engines and puts all the results in to one collection for you. You can pick and choose what search classes you want to use, create more and pick and choose which result tests you want to have execute.To conduct a search with a particular SearchEngine subclass, you can do something like the following:Searchlight.SearchBehaviors search: 'ByteString'This API creates a results collection for you, but you can send #search:into: to give it your own collection that the results should go in to. The results are not sorted by score in any way or grouped by type, if you wish to present them a particular way in a user interface, that is a separate concern to the search engines.Each SearchEngine subclass must implement the method #search to do its actual iterative search behaviour. What it does from there is up to it but the general pattern is to then call #search: on the superclass which will send each searchable object to the &lt;search&gt; pragma methods. These methods in turn will create (or not) Result objects and place them in @results.Instance Variables:	criteria	&lt;String&gt;	the crteria given to us to search for	integerCriteria	&lt;Integer&gt;	the criteria is an integer	isAllUppercaseCriteria	&lt;Boolean&gt;	are we dealing with a purely uppercase search looking for acronyms?	isPhraseCriteria	&lt;Boolean&gt;	are we looking for something that is phrase like, eg: it includes a space?	matchCriteria	&lt;String&gt;	 the criteria as a match statement	results	&lt;(Collection of: (Result))&gt;	the collection of results that we put our new results in to	searches	&lt;(Collection of: (SearchEngine))&gt;	the collection of result tests we're going to run when we do our search	uppercaseCriteria	&lt;String&gt;	the search criteria as uppercase letters only</body></comment><class><name>SearchReferences</name><environment>Searchlight</environment><super>Searchlight.SearchEngine</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.SearchReferences</class-id><body>SearchReferences for direct references of an object, such as being an implementor, a sender, a reference, a class reference, etc.</body></comment><class><name>MethodLiteral</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method literal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.MethodLiteral</class-id><body>MethodLiteral represents a literal inside a methodInstance Variables:	literal	&lt;String&gt;	the string or symbol that is the literal we found	method	&lt;CompiledMethod&gt;	the implemented method that contains the literal</body></comment><class><name>Reference</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.Reference</class-id><body>Reference represents a method that references a particular literal - a class or selector.Instance Variables:	method	&lt;CompiledMethod&gt;	the method that refers to the object that was searched for</body></comment><class><name>SearchImage</name><environment>Searchlight</environment><super>Searchlight.SearchEngine</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.SearchImage</class-id><body>SearchImage searches through the MethodsCache for information already installed in the image.</body></comment><class><name>Result</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object score </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Query</package></attributes></class><comment><class-id>Searchlight.Result</class-id><body>Result is a single result of any kind with a common API to be used by ResultsView.Instance Variables:	object	&lt;Object&gt;	the object we found that matches the search criteria	score	&lt;Integer&gt;	the relevance of the result we found, lower score is more relevant</body></comment><methods><class-id>Searchlight.Implementor</class-id> <category>accessing</category><body package="Searchlight-Query">method	^method</body><body package="Searchlight-Query">method: anObject	method := anObject</body></methods><methods><class-id>Searchlight.Implementor</class-id> <category>printing</category><body package="Searchlight-Query">printOn: stream	stream nextPutAll: 'Implementor: '.	method printOn: stream</body></methods><methods><class-id>Searchlight.Primitive</class-id> <category>printing</category><body package="Searchlight-Query">printOn: stream	stream nextPutAll: 'Primitive: '.	method printOn: stream</body></methods><methods><class-id>Searchlight.Primitive</class-id> <category>accessing</category><body package="Searchlight-Query">method	^method</body><body package="Searchlight-Query">method: anObject	method := anObject</body></methods><methods><class-id>Searchlight.SearchEngine</class-id> <category>accessing</category><body package="Searchlight-Query">criteria	^criteria</body><body package="Searchlight-Query">criteria: anObject	criteria := anObject.	criteriaSize := (anObject copyWithout: $*) size.	isAllUppercaseCriteria := criteria allSatisfy: [:each | each isUppercase].	uppercaseCriteria := criteria asUppercase.	lowercaseCriteria := criteria asLowercase.	(isMatchCriteria := criteria includes: $*) ifTrue: [matchCriteria := criteria last = $* ifTrue: [criteria] ifFalse: [criteria, '*']].	isNumericCriteria := criteria notEmpty and: [criteria first isDigit].	numericCriteria := Number readFrom: criteria readStream</body><body package="Searchlight-Query">results	^results</body><body package="Searchlight-Query">results: anObject	results := anObject</body><body package="Searchlight-Query">searches	^searches</body><body package="Searchlight-Query">searches: anObject	searches := anObject</body></methods><methods><class-id>Searchlight.SearchEngine</class-id> <category>initialize-release</category><body package="Searchlight-Query">initialize	searches := (Pragma allNamed: #search in: self class) collect: [:each | each selector]</body></methods><methods><class-id>Searchlight.SearchEngine</class-id> <category>private</category><body package="Searchlight-Query">add: resultBlock score: score	results add: (Result object: resultBlock value score: score)</body><body package="Searchlight-Query">match: object do: matchedBlock	object ifNil: [^false].	object isEmpty ifTrue: [^false].	object size &lt; criteriaSize ifTrue: [^false].	self matchCapitals: object ifHit: [:score | matchedBlock value: score. ^true].	isMatchCriteria		ifFalse:			[self matchPrefixCaseSensitive: object ifHit: [:score | matchedBlock value: score. ^true].			self matchPrefixCaseInsensitive: object ifHit: [:score | matchedBlock value: score. ^true].			criteriaSize &lt;= 2 ifTrue: [^false].			self matchSubstring: object ifHit: [:score | matchedBlock value: score. ^true]]		ifTrue:	[self matchMatch: object ifHit: [:score | matchedBlock value: score. ^true]].	^false</body><body package="Searchlight-Query">match: object result: resultBlock	^self match: object do: [:score | self add: resultBlock score: score]</body><body package="Searchlight-Query">matchCapitals: object ifHit: trueBlock	| i capital |	isAllUppercaseCriteria ifFalse: [^self].	i := 1.	capital := uppercaseCriteria at: i.	object first isUppercase ifFalse: [^self].	object keysAndValuesDo: [:index :a |		a isUppercase ifTrue:			[a = capital ifFalse: [^self].			i := i + 1.			i &gt; criteria size ifTrue:				[index + 1 to: object size do: [:i2 | (object at: i2) isUppercase ifTrue: [^self]].				trueBlock value: 0].			capital := uppercaseCriteria at: i]]</body><body package="Searchlight-Query">matchMatch: object ifHit: trueBlock	(matchCriteria match: object) ifFalse: [^self].	trueBlock value: 5</body><body package="Searchlight-Query">matchPrefixCaseInsensitive: object ifHit: trueBlock	1 to: criteria size do: [:i |		| a b |		a := object at: i.		b := criteria at: i.		(a = b or: [a = (uppercaseCriteria at: i) or: [a = (lowercaseCriteria at: i)]]) ifFalse: [^self]].	object size = criteria size		ifTrue:	[trueBlock value: 3]		ifFalse:	[trueBlock value: 4]</body><body package="Searchlight-Query">matchPrefixCaseSensitive: object ifHit: trueBlock	1 to: criteria size do: [:i |		| a b |		a := object at: i.		b := criteria at: i.		a = b ifFalse: [^self]].	object size = criteria size		ifTrue:	[trueBlock value: 1]		ifFalse:	[trueBlock value: 2]</body><body package="Searchlight-Query">matchSubstring: object ifHit: trueBlock	(object findSameAs: criteria startingAt: 2 wildcard: false) isZero ifTrue: [^self].	trueBlock value: 5</body></methods><methods><class-id>Searchlight.SearchEngine</class-id> <category>API</category><body package="Searchlight-Query">search	searches do: [:each | self perform: each]</body></methods><methods><class-id>Searchlight.SearchEngine class</class-id> <category>instance creation</category><body package="Searchlight-Query">new	^super new initialize</body><body package="Searchlight-Query">newSearch: criteria into: results	^self new		criteria: criteria;		results: results;		yourself</body></methods><methods><class-id>Searchlight.SearchEngine class</class-id> <category>API</category><body package="Searchlight-Query">search: criteria	| results |	results := OrderedCollection new: 50.	self search: criteria into: results.	^results</body><body package="Searchlight-Query">search: criteria into: results	criteria isEmpty ifTrue: [^results].	^(self newSearch: criteria into: results)		search</body></methods><methods><class-id>Searchlight.SearchReferences</class-id> <category>accessing</category><body package="Searchlight-Query">criteria: anObject	criteria := anObject</body></methods><methods><class-id>Searchlight.SearchReferences</class-id> <category>private</category><body package="Searchlight-Query">match: object result: resultBlock	object ifNil: [^false].	object = criteria ifTrue:		[self add: resultBlock score: 0.		^true].	^false</body></methods><methods><class-id>Searchlight.SearchReferences class</class-id> <category>API</category><body package="Searchlight-Query">search: criteria into: results	^(self newSearch: criteria into: results)		search</body></methods><methods><class-id>Searchlight.MethodLiteral</class-id> <category>accessing</category><body package="Searchlight-Query">literal	^literal</body><body package="Searchlight-Query">literal: anObject	literal := anObject</body><body package="Searchlight-Query">method	^method</body><body package="Searchlight-Query">method: anObject	method := anObject</body></methods><methods><class-id>Searchlight.Reference</class-id> <category>accessing</category><body package="Searchlight-Query">method	^method</body><body package="Searchlight-Query">method: anObject	method := anObject</body></methods><methods><class-id>Searchlight.Reference</class-id> <category>printing</category><body package="Searchlight-Query">printOn: stream	stream nextPutAll: 'Reference: '.	method printOn: stream</body></methods><methods><class-id>Searchlight.Result</class-id> <category>accessing</category><body package="Searchlight-Query">object	^object</body><body package="Searchlight-Query">object: anObject	object := anObject</body><body package="Searchlight-Query">score	^score</body><body package="Searchlight-Query">score: anObject	score := anObject</body><body package="Searchlight-Query">type	object isBehavior ifTrue: [^Class].	^object class</body></methods><methods><class-id>Searchlight.Result</class-id> <category>printing</category><body package="Searchlight-Query">printOn: stream	score printOn: stream.	stream space.	object printOn: stream</body></methods><methods><class-id>Searchlight.Result class</class-id> <category>instance creation</category><body package="Searchlight-Query">object: object score: score	^self new		object: object;		score: score;		yourself</body></methods><methods><class-id>Searchlight.SearchEngine class</class-id> <category>pragmas</category><body package="Searchlight-Query">pragmas	&lt;pragmas: #instance&gt;	^#(search)</body></methods><methods><class-id>Searchlight.SearchReferences</class-id> <category>searches</category><body package="Searchlight-Query">searchClassReferences	&lt;search&gt;	(SearchDatabase default classReferencesIndex at: criteria ifAbsent: [^self])		do: [:method | self add: [Reference new method: method; yourself] score: 0]</body><body package="Searchlight-Query">searchImplementors	&lt;search&gt;	(SearchDatabase default implementorsIndex at: criteria ifAbsent: [^self])		do: [:behavior | self add: [Implementor new method: (behavior compiledMethodAt: criteria); yourself] score: 0]</body><body package="Searchlight-Query">searchSenders	&lt;search&gt;	(SearchDatabase default sendersIndex at: criteria ifAbsent: [^self])		do: [:method | self add: [Reference new method: method; yourself] score: 0]</body></methods><methods><class-id>Searchlight.SearchImage</class-id> <category>searches</category><body package="Searchlight-Query">searchBehaviorNames	&lt;search&gt;	SearchDatabase default behaviorsCache keysAndValuesDo: [:fullName :behavior |		behavior isMeta ifFalse:			[(self match: behavior name result: [behavior]) ifFalse:				[self match: fullName result: [behavior]]]]</body><body package="Searchlight-Query">searchBundleNames	&lt;search&gt;	Store.Registry bundlesDo: [:bundle | self match: bundle name result: [bundle]]</body><body package="Searchlight-Query">searchInstanceVariables	&lt;search&gt;	criteria first isUppercase ifTrue: [^self].	SearchDatabase default instanceVariablesIndex keysAndValuesDo: [:name :behaviors |		self match: name do: [:score |			behaviors do: [:behavior | self add: [InstanceVariable behavior: behavior name: name] score: score]]]</body><body package="Searchlight-Query">searchLiterals	&lt;search&gt;	SearchDatabase default literalsIndex keysAndValuesDo: [:literal :methods |		| matched matchScore |		matchScore := 0.		matched := (literal isString and: [literal size &lt; 1024])					ifTrue: [ self match: literal do: [: score | matchScore := score ]]					ifFalse: [ isNumericCriteria ifTrue: [ numericCriteria = literal ] ifFalse: [criteria = literal ] ].		matched ifTrue:			[methods do: [:method |				self add: [MethodLiteral new method: method; literal: literal; yourself] score: matchScore]]]</body><body package="Searchlight-Query">searchNamespaceNames	&lt;search&gt;	SearchDatabase default namespacesCache keysAndValuesDo: [:fullName :namespace |		(self match: namespace name result: [namespace]) ifFalse:			[self match: fullName result: [namespace]]]</body><body package="Searchlight-Query">searchPackageNames	&lt;search&gt;	Store.Registry packagesDo: [:package | self match: package name result: [package]]</body><body package="Searchlight-Query">searchParcelNames	&lt;search&gt;	ParcelsCache cachedParcelInformation do: [:parcelInformation |		self match: parcelInformation key result: [(Parcel parcelNamed: parcelInformation key) ifNil: [Parcel name: parcelInformation key]]]</body><body package="Searchlight-Query">searchPrimitives	&lt;search&gt;	isNumericCriteria ifFalse: [^self].	(SearchDatabase default primitivesIndex at: numericCriteria ifAbsent: [^self]) do: [:result |		self add: [Primitive new method: (result mclass compiledMethodAt: result selector); yourself] score: 0]</body><body package="Searchlight-Query">searchSelectors	&lt;search&gt;	| symbol found |	(symbol := Symbol findInterned: criteria) == nil ifFalse:		[(SearchDatabase default implementorsIndex at: symbol ifAbsent: [#()])			do: [:behavior | self add: [Implementor new method: (behavior compiledMethodAt: symbol); yourself] score: 0]].	found := Set new.	SearchDatabase default implementorsIndex keysAndValuesDo: [:selector :classes |		self match: selector result: [found add: selector. selector]].	SearchDatabase default sendersIndex keysAndValuesDo: [:selector :methods |		(found includes: selector) ifFalse: [self match: selector result: [selector]]]</body><body package="Searchlight-Query">searchSharedVariables	&lt;search&gt;	SearchDatabase default sharedVariablesIndex keysAndValuesDo: [:name :behaviors |		self match: name do: [:score |			behaviors do: [:behavior | self add: [SharedVariable namespace: behavior name: name] score: score]]]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>