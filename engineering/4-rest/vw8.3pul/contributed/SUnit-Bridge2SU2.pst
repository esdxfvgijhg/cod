<?xml version="1.0"?><st-source><!-- Name: SUnit-Bridge2SU2Notice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: This package implements a tool to install a bridge between the SUnit and SUnitToo test environments such that XProgramming.SUnit tests may be run with the SUnitTools, respecting the original XProgramming.SUnit inheritance rules, without any changes to the tests.  To run your test suite without any "phantom" changes to the test classes, make sure you load this package to deploy the Bridge before loading your test suite.The Bridge is accomplished by replacing the two primary SUnit classes (TestCase and TestResource) with stripped versions whose purpose is simply to inherit from their counterparts in the SUnitToo class hierarchy.  The Bridge classes are substituted for the original XProgramming.SUnit classes and then renamed back to their original names.  This enables the SUnitTools to operate correctly while using the inheritance rules of the original SUnit environment, and without any changes to the existing tests.Note that while this package is loaded, the bridge is deployed, and the original TestCase and TestResource classes in the SUnit package will be renamed BRIDGE2SUTestCase and BRIDGE2SUTestResource respectively.If you load your tests before you load this package, phantom "No Conflict" changes will appear in all test classes that inherit directly from the original TestCase and TestResource classes.  These artifacts are unavoidable due to the renaming mechanisms required to substitute the bridge's stripped classes for their original counterparts.  However, publishing new versions of your test packages created while the bridge is deployed will not change the basic inheritance structure of the tests, since the fully qualified path of the superclass binding reference is exactly the same as when the bridge is not deployed.  Deploying the Bridge only alters classes in the SUnit package, and that package should consequently not be published while the bridge is deployed.  You can retract or deploy the bridge manually if necessary using the class methods #retractBridge and #deployBridge in SU2Bridge.Publishing this package will first retract the bridge so it will publish cleanly.  You will need to deploy it again manually after the publish is complete.  (If RB windows were open during retraction, the VM method cash can sometimes require flushing to update all references and avoid DNUs when selecting packages with tests;  closing windows and collecting garbage usually solves the problem.)DbIdentifier: bear73DbTrace: 454768DbUsername: smichaelDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'SUnitToo' '') #(#any 'SUnitPreload' '') #(#any 'SUnit' '') #(#any 'Browser-ChangeObjects' ''))PackageName: SUnit-Bridge2SU2Parcel: #('SUnit-Bridge2SU2')ParcelName: SUnit-Bridge2SU2PrerequisiteDescriptions: #(#(#name 'SUnitToo' #componentType #package) #(#name 'SUnitPreload' #componentType #package) #(#name 'SUnit' #componentType #package) #(#name 'Browser-ChangeObjects' #componentType #package))PrerequisiteParcels: #(#('SUnitToo' '') #('SUnitPreload' '') #('SUnit' '') #('Browser-ChangeObjects' ''))PrintStringCache: (8.1 - 1,smichael)Version: 8.1 - 1Post-Load Block: 	[:package | Bridge2SU2.SU2Bridge deployBridge]Pre-Unload Block: 	[:package | Bridge2SU2.SU2Bridge retractBridge]Pre-Save Block: 	[:package | Bridge2SU2.SU2Bridge retractBridgeForSave]Date: 9:56:54 AM January 16, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (jan15.2) of January 16, 2015 on January 16, 2015 at 9:56:54 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Bridge2SU2</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>SUnit-Bridge2SU2</package></attributes></name-space><class><name>TestAsserter</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit-Bridge2SU2</package></attributes></class><comment><class-id>SUnit.TestAsserter</class-id><body>This class exists only to provide an SUnitToo TestAsserter superclass of the XProgramming.SUnit.TestAsserter class which will be generated from the TEMPLATETestAsserter class when the bridge is deployed.  The generated class will reparent any subclasses that have not already been reparented because they are subclasses of XProgramming.SUnit.TestCase or XProgramming.SUnit.TestResource (which are subclasses of TestAsserter in unbridged XProgramming.SUnit but of SUnit.TestCase and SUnit.TestResource when the bridge is deployed).  As SUnitToo does not yet have any TestAsserter class, this class has no behaviour at the moment and is defined in the bridge package.</body></comment><class><name>TEMPLATETestAsserter</name><environment>Bridge2SU2</environment><super>SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit-Bridge2SU2</category><attributes><package>SUnit-Bridge2SU2</package></attributes></class><comment><class-id>Bridge2SU2.TEMPLATETestAsserter</class-id><body>The template TestAsserter class from which to create the Bridge TestAsserter class.This is a stripped version of the TestCase class with only the behavior required to bridge the two environments.</body></comment><class><name>SU2Bridge</name><environment>Bridge2SU2</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit-Bridge2SU2</category><attributes><package>SUnit-Bridge2SU2</package></attributes></class><comment><class-id>Bridge2SU2.SU2Bridge</class-id><body>SU2Bridge implements a singleton instance which can be used to convert existing images to use the SU2 Bridge classes for XProgramming.SUnit based tests and run the test suites as SUnitToo based tests through the SUnitTools.Instance Variables:	className	&lt;String&gt;		the simple name of the original class for which the bridge is created</body></comment><class><name>TEMPLATETestCase</name><environment>Bridge2SU2</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit-Bridge2SU2</category><attributes><package>SUnit-Bridge2SU2</package></attributes></class><comment><class-id>Bridge2SU2.TEMPLATETestCase</class-id><body>The template TestCase class from which to create the Bridge TestCase class.This is a stripped version of the TestCase class with only the behavior required to bridge the two environments.</body></comment><class><name>TEMPLATETestResource</name><environment>Bridge2SU2</environment><super>SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit-Bridge2SU2</category><attributes><package>SUnit-Bridge2SU2</package></attributes></class><comment><class-id>Bridge2SU2.TEMPLATETestResource</class-id><body>The template TestResource class from which to create the Bridge TestCase class.This is a stripped version of the TestResource class with only the behavior required to bridge the two environments.</body></comment><methods><class-id>SUnit.TestAsserter</class-id> <category>logging</category><body package="SUnit-Bridge2SU2">signalFailure: aString 	FailedAssertion raiseSignal: aString</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestAsserter</class-id> <category>asserting</category><body package="SUnit-Bridge2SU2">assert: aBoolean 	aBoolean ifFalse: [self signalFailure: 'Assertion failed']</body><body package="SUnit-Bridge2SU2">assert: aBoolean description: aString	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnit-Bridge2SU2">assert: aBoolean description: aString resumable: resumableBoolean	"SUnitToo does not support resuming a failed assertion, so we must ignore resumableBoolean."	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnit-Bridge2SU2">deny: aBoolean	self assert: aBoolean not</body><body package="SUnit-Bridge2SU2">deny: aBoolean description: aString	self assert: aBoolean not description: aString</body><body package="SUnit-Bridge2SU2">deny: aBoolean description: aString resumable: resumableBoolean	self assert: aBoolean not description: aString resumable: resumableBoolean</body><body package="SUnit-Bridge2SU2">should: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent)</body><body package="SUnit-Bridge2SU2">should: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent)		description: aString.</body><body package="SUnit-Bridge2SU2">shouldnt: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent) not</body><body package="SUnit-Bridge2SU2">shouldnt: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent) not		description: aString.</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestAsserter</class-id> <category>private</category><body package="SUnit-Bridge2SU2">assertBlock: aBlock raises: anExceptionalEvent 	^	[aBlock value.	false] on: anExceptionalEvent do: [:ex | ex return: true]</body></methods><methods><class-id>Bridge2SU2.SU2Bridge</class-id> <category>accessing</category><body package="SUnit-Bridge2SU2">bridgeClass	^self xpsuEnvironment at: (self bridgePrefix, className) asSymbol ifAbsent: [nil]</body><body package="SUnit-Bridge2SU2">className: aClassName	className := aClassName</body><body package="SUnit-Bridge2SU2">placeholderClass	^self xpsuEnvironment at: (self placeholderPrefix, className) asSymbol ifAbsent: [nil]</body><body package="SUnit-Bridge2SU2">templateClass	^ Bridge2SU2 at: (self templatePrefix, className) asSymbol ifAbsent: [nil]</body><body package="SUnit-Bridge2SU2">xpsuClass	^self xpsuEnvironment at: className asSymbol ifAbsent: [nil]</body></methods><methods><class-id>Bridge2SU2.SU2Bridge</class-id> <category>private</category><body package="SUnit-Bridge2SU2">bridgeClassDefn	^ self xpsuEnvironment fullName, 		' defineClass: #', self bridgePrefix, '&lt;1s&gt;	superclass: #{', self su2Environment fullName ,'.&lt;1s&gt;}	indexedType: #none	private: false	instanceVariableNames: ''''	classInstanceVariableNames: ''''	imports: ''''	category: ''SUnit-Bridge2SU2'''</body><body package="SUnit-Bridge2SU2">bridgePrefix	^ 'XPSU'</body><body package="SUnit-Bridge2SU2">placeholderPrefix	^ 'BRIDGE2SU2'</body><body package="SUnit-Bridge2SU2">su2Environment	^ SUnit</body><body package="SUnit-Bridge2SU2">templatePrefix	^ 'TEMPLATE'</body><body package="SUnit-Bridge2SU2">xpsuEnvironment	^ XProgramming.SUnit</body></methods><methods><class-id>Bridge2SU2.SU2Bridge</class-id> <category>private-actions</category><body package="SUnit-Bridge2SU2">bridgeFrom: currentSubclass to: newSubclass	| change |	(currentSubclass isNil or: [newSubclass isNil]) ifTrue: [^self].	change := Refactory.Browser.CompositeRefactoryChange new.	(currentSubclass subclasses reject: [:each | (each name beginsWith: self placeholderPrefix)])		 do: [:each || rs ws |			rs := each instanceBehavior definition readStream.			ws := String new writeStream.			ws				nextPutAll: (rs upTo: Character cr);				cr.	"copy first line"			rs upTo: Character cr.	"throw out old superclass line"			ws nextPutAll: ('superclass: #{&lt;1s&gt;}' expandMacrosWith: newSubclass fullName).			ws nextPutAll: rs upToEnd.			change defineClass: ws contents].	Refactory.Browser.RefactoryChangeManager instance performChange: change.</body><body package="SUnit-Bridge2SU2">createBridgeClass	| bridgeClass |	(bridgeClass := self createClass)		ifNotNil: [ 			self createComment: bridgeClass.			self createMethods: bridgeClass].	^bridgeClass</body><body package="SUnit-Bridge2SU2">createClass	| classDef change |	classDef := self bridgeClassDefn		expandMacrosWith: className.	change := Refactory.Browser.AddClassChange definition: classDef.	change 		package: (Store.Registry containingPackageForClass: self xpsuClass).	Refactory.Browser.RefactoryChangeManager instance performChange: change.	^self bridgeClass</body><body package="SUnit-Bridge2SU2">createComment: newClass		| change |	newClass ifNil: [^self].	change := Refactory.Browser.CommentChange		object: newClass		comment:			newClass name , ' was cloned from the bridge template by '				, self class fullName.	Refactory.Browser.RefactoryChangeManager instance performChange: change</body><body package="SUnit-Bridge2SU2">createMethods: newClass	"Implement all the TEMPLATE&lt;TestClassName&gt; methods in the new class, converting any references to TEMPLATETest... classes to XPSUTest... classes which will then be renamed to the actual equivalents, done this way because the TEMPLATETest... classes cannot see their equivalents so cannot reference them directly.  (This could be done more subtly with class rename refactorings but for now direct rewriting of TEMPLATETest... to XPSUTest... in method source is good enough.  If a circular pattern of inter-reference of classes were to occur in SUnit in methods the bridge needed to preserve, such that there was no order of creating each class and its methods such that all the XPSU classes existed before they were referenced, we might have to reorder processing;  that can wait till the need arises.)"	| change templateClass |	(templateClass := self templateClass) ifNil: [^self].	newClass ifNil: [^self].	change := Refactory.Browser.CompositeRefactoryChange new.	templateClass		selectorsAndMethodsDo:			[:sel :meth | | chg |			chg := change				compile: (meth getSource copyReplaceAll: self templatePrefix, 'Test' with: self bridgePrefix, 'Test')				in: newClass				classified: (templateClass whichCategoryIncludesSelector: sel).			chg 				package: (Store.Registry containingPackageForSelector: sel class: self xpsuClass)].	templateClass class		selectorsAndMethodsDo:			[:sel :meth |  | chg |			chg := change				compile: (meth getSource copyReplaceAll: self templatePrefix, 'Test' with: self bridgePrefix, 'Test')				in: newClass class				classified: (templateClass class whichCategoryIncludesSelector: sel).			chg 				package: (Store.Registry containingPackageForSelector: sel class: self xpsuClass)].	Refactory.Browser.RefactoryChangeManager instance performChange: change</body><body package="SUnit-Bridge2SU2">harvestExtensionMethods	"If any methods have been added to the class since the bridge was deployed, we need to pull those methods into the placeholder class or they will be lost when the bridge is retracted."	| targetClass filterBlock extensions metaExtensions placeholderClass change |	targetClass := self xpsuClass.	filterBlock :=			[:meth |			(Store.Registry containingPackageForClass: targetClass)				~= meth definition package].	extensions := targetClass methodDictionary values select: filterBlock.	metaExtensions := targetClass class methodDictionary values				select: filterBlock.	placeholderClass := self placeholderClass.	change := Refactory.Browser.CompositeRefactoryChange new.	extensions do: 			[:meth |			| sel chg |			sel := meth selector.			chg := change						compile: meth getSource						in: placeholderClass						classified: (targetClass whichCategoryIncludesSelector: sel).			chg package: meth definition package].	metaExtensions do: 			[:meth |			| sel chg |			sel := meth selector.			chg := change						compile: meth getSource						in: placeholderClass class						classified: (targetClass class whichCategoryIncludesSelector: sel).			chg package: meth definition package].	Refactory.Browser.RefactoryChangeManager instance performChange: change</body><body package="SUnit-Bridge2SU2">removeBridgeClass		| change |	self bridgeClass		ifNotNil:			[:brClass | 			change := Refactory.Browser.RemoveClassChange objectName: brClass fullName.			Refactory.Browser.RefactoryChangeManager instance performChange: change]</body></methods><methods><class-id>Bridge2SU2.SU2Bridge</class-id> <category>actions</category><body package="SUnit-Bridge2SU2">deployBridgeClass	| envPath change bridgeClass |	self placeholderClass ifNotNil: [ :cls |		^Dialog warn: ('Bridge for class &lt;1s&gt; is already deployed' expandMacrosWith: className) ].	"Install the temporary Bridge class."	bridgeClass := self createBridgeClass.		"Re-target all currently loaded test subclasses."	self bridgeFrom: self xpsuClass to: bridgeClass.	"Rename the existing XProgramming.SUnit class out of the way, 		and put the bridge class in its place in the test superclass hierarchy."	envPath := self xpsuEnvironment fullName, '.'.	change := Refactory.Browser.RenameObjectChange new.	change rename: (envPath, className) to: (self placeholderPrefix, className).	Refactory.Browser.RefactoryChangeManager instance performChange: change.	change rename: (envPath, self bridgePrefix, className) to: className.	Refactory.Browser.RefactoryChangeManager instance performChange: change.</body><body package="SUnit-Bridge2SU2">retractBridgeClass	| envPath change |	"Silently ignore un-deployed bridge." 	self placeholderClass ifNil: [ ^self ].		"Gather up any previously unknown extension methods."	self harvestExtensionMethods.	"Replace the bridge class with the original XProgramming.SUnit class."	envPath := self xpsuEnvironment fullName, '.'.	change := Refactory.Browser.RenameObjectChange new.	change rename: (envPath, className) to: (self bridgePrefix, className).	Refactory.Browser.RefactoryChangeManager instance performChange: change.	change rename: (envPath, self placeholderPrefix, className) to: className.	Refactory.Browser.RefactoryChangeManager instance performChange: change.	"Re-target Bridge class to original XProgramming.SUnit test class."	self bridgeFrom: self bridgeClass to: self xpsuClass.	"Remove the temporary bridge class."	self removeBridgeClass</body></methods><methods><class-id>Bridge2SU2.SU2Bridge class</class-id> <category>accessing</category><body package="SUnit-Bridge2SU2">current	current ifNil: [ current := self new ].	^ current</body><body package="SUnit-Bridge2SU2">targetNames	"The order is important;  we only re-parent TestAsserter subclasses after we have reparented the TestCase and TestResource sub-branches."	^ Array with: 'TestCase' with: 'TestResource' with: 'TestAsserter'</body></methods><methods><class-id>Bridge2SU2.SU2Bridge class</class-id> <category>bridging</category><body package="SUnit-Bridge2SU2">deployBridge	"self deployBridge"		self targetNames		do: [:ea | self deployBridgeFor: ea].	self refresh</body><body package="SUnit-Bridge2SU2">deployBridgeFor: className		(self current className: className) deployBridgeClass</body><body package="SUnit-Bridge2SU2">refresh	current := nil.	#{Refactory.Browser.BrowserNavigator} ifDefinedDo: [:nav| nav allInstances do: [:ea | ea refreshLists]]</body><body package="SUnit-Bridge2SU2">retractBridge	"self retractBridge"		self targetNames reverseDo: [:ea | self retractBridgeFor: ea].	self refresh.</body><body package="SUnit-Bridge2SU2">retractBridgeFor: className		^(self current className: className) retractBridgeClass</body><body package="SUnit-Bridge2SU2">retractBridgeForSave	"self retractBridgeForSave"		self retractBridge.	Transcript cr; show: (#RetractBridge &lt;&lt; #labels &gt;&gt; 'The SU2Bridge was retracted prior to publishing the package/parcel.&lt;n&gt;Execute "Bridge2SU2.SU2Bridge deployBridge" to deploy it again.') expandMacros</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestCase class</class-id> <category>accessing</category><body package="SUnit-Bridge2SU2">allTestSelectors	| answer pivotClass lookupRoot |	answer := Set withAll: self testSelectors.	self shouldInheritSelectors ifTrue:		[pivotClass := self.		lookupRoot := self lookupHierarchyRoot.		[pivotClass == lookupRoot] whileFalse:			[pivotClass := pivotClass superclass.			answer addAll: pivotClass testSelectors]].	^answer asSortedCollection asOrderedCollection</body><body package="SUnit-Bridge2SU2">lookupHierarchyRoot	"The template test case class cannot see the real test case class (in either XProgramming.SUnit or SUnit) so we return the template class which is converted to the XPSU class in source before compilation in #createMethods:, after which XPSUTestCase is changed to TestCase in bytecode though the source will still read XPSUTestCase."	^TEMPLATETestCase"After deployment to XProgramming.SUnit.TestCase, the bytecode is	^TestCasealthough the source above will read	^XPSUTestCaseso if you chance to be looking at this on XProgramming.SUnit.TestCase after deployment, do not recompile without deleting XPSU (not that there should be any reason to recompile since XProgramming.SUnit.TestCase&gt;&gt;lookupHierarchyRoot is generated and deleted by deploying and retracting the bridge."</body><body package="SUnit-Bridge2SU2">testSelectors	^self selectors select: [:each | 'test*' sunitMatch: each]</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestCase class</class-id> <category>test case support</category><body package="SUnit-Bridge2SU2">testSelectorsDo: aBlock skipping: aCollection	self isAbstract ifTrue: [^self].	self allTestSelectors do:		[:each |		(aCollection includes: each) ifFalse:			[aBlock				cull: each				cull: (MethodDefinition class: self selector: each) resolve method.			aCollection add: each]].</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestCase class</class-id> <category>testing</category><body package="SUnit-Bridge2SU2">canHaveTests: aClass	"I cannot have SUnit tests if I have been temporarily reparented to run under a different test framework's superclass, e.g. during deployment of SUnit-Bridge2SU2.  Therefore we call #xpsuInheritsFrom:, which such bridges can make false during the period of their deployment, allowing this method to be (like most in this class) identical between template class and real class, so the order of loading and unloading of implementing packages matters not."	^(self xpsuInheritsFrom: aClass) and: [aClass isAbstract not]</body><body package="SUnit-Bridge2SU2">isAbstract	"Override to true if a TestCase subclass is Abstract and should not have TestCase instances built from it"	^self sunitName == #TestCase</body><body package="SUnit-Bridge2SU2">shouldInheritSelectors	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."	^self ~~ self lookupHierarchyRoot		and: [self superclass isAbstract			or: [self testSelectors isEmpty]]</body><body package="SUnit-Bridge2SU2">xpsuInheritsFrom: aClass	"This method is used by tools that require SUnit tests, e.g. RBSUnitExtensions.1) When the bridge is deployed, this method appears on XProgramming.SUnit.TestCase, subclass of SUnit.TestCase (the parking spot for the SUnitToo TestCase class).  While the bridge is deployed, that class and all its subclasses are SUnitToo tests;  tools that ask 'Are you a subclass of XProgramming.SUnit.TestCase?' as a proxy for asking 'Are you a test case in the SUnit test framework?' cannot run them.  We want to end such tools' search for SUnit test cases as soon as possible, so false is the right thing to return.2) When the bridge is not deployed, this method appears on TEMPLATETestCase, a leaf subclass of SUnit.TestCase, which has no tests and no role to play in SUnit-using tools.  So false remains the right answer.So in all cases, we just return false."	^false</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestResource</class-id> <category>asserting</category><body package="SUnit-Bridge2SU2">assert: aBoolean	aBoolean ifFalse: [self signalInitializationError].</body><body package="SUnit-Bridge2SU2">assert: aBoolean description: aString	self assert: aBoolean.</body><body package="SUnit-Bridge2SU2">assert: aBoolean description: aString resumable: anotherBoolean	self assert: aBoolean.</body><body package="SUnit-Bridge2SU2">deny: aBoolean	self assert: aBoolean not.</body><body package="SUnit-Bridge2SU2">deny: aBoolean description: aString	self deny: aBoolean.</body><body package="SUnit-Bridge2SU2">deny: aBoolean description: aString resumable: anotherBoolean	self deny: aBoolean.</body><body package="SUnit-Bridge2SU2">should: aBlock raise: anExceptionalEvent	self assert: (self assertBlock: aBlock raises: anExceptionalEvent).</body><body package="SUnit-Bridge2SU2">should: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent)		description: aString.</body><body package="SUnit-Bridge2SU2">shouldnt: aBlock raise: anExceptionalEvent	self assert: (self assertBlock: aBlock raises: anExceptionalEvent) not.</body><body package="SUnit-Bridge2SU2">shouldnt: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent) not		description: aString.</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestResource</class-id> <category>private</category><body package="SUnit-Bridge2SU2">assertBlock: aBlock raises: anExceptionalEvent	"Cloned from TestCase.  Needed to bridge from SUnit 3.2 and after, in which resources and tests share assert:... protocol."	^	[aBlock value.	false] on: anExceptionalEvent do: [:ex | ex return: true]</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestResource class</class-id> <category>testing</category><body package="SUnit-Bridge2SU2">isAlreadyAvailable	^current class == self</body><body package="SUnit-Bridge2SU2">isAvailable	"In SUnit, raising a TestFailure means the resource is unavailable.  Current SUnitToo(ls) treats any exception raised in a resource as a not-for-trapping error, i.e. it halts the run and opens a debugger.  Map to false, so unavailable SUnit resources behave as expected in SunitToo."	^[super isAvailable]		on: SUnit.TestResourceUnavailable		do: [:ex | false]</body></methods><methods><class-id>Bridge2SU2.TEMPLATETestResource class</class-id> <category>asserting</category><body package="SUnit-Bridge2SU2">assert: aBoolean	aBoolean ifFalse: [self signalInitializationError].</body><body package="SUnit-Bridge2SU2">assert: aBoolean description: aString	self assert: aBoolean.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>TestResource</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>