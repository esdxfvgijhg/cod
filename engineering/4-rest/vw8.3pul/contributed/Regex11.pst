<?xml version="1.0"?><st-source><!-- Name: Regex11Notice: Copyright 1996, 1999 Vassili Bykov.Copyright 2013 Michel Bany.This utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This provides standard regex searching, matching and editing facilities.  The RBRegexExtensions package prereqs this and offers a UI for its use in searching code.  It is provided to the Smalltalk community in hope it will be useful.  See the `documentation' protocol of RxParser class for user's guide.Tests are included.  To run all tests, logging the results to the Transcript, do	RxParser.LoggingEnabled := true.	RxParser runTestsForMatcher: RxMatcherTo rerun failures only, do	RxParser.LoggingEnabled := true.	RxParser runRegexTestsForMatcher: RxMatcher suite: RxParser failureSuite.To run tests without logging (much faster), do	RxParser.LoggingEnabled := false.	Transcript cr;		print: (Time microsecondsToRun: [RxParser runTestsForMatcher: RxMatcher]);		space; show: 'microseconds'; cr.DbIdentifier: bear73DbTrace: 454394DbUsername: stevekDbVersion: 1.4.6PackageName: Regex11Parcel: #('Regex11')ParcelName: Regex11PrintStringCache: (1.4.6,stevek)Version: 1.4.6Date: 7:20:36 AM January 9, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (jan15.1) of January 9, 2015 on January 9, 2015 at 7:20:36 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>RxmLink</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxmLink</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A matcher is built of a number of links interconnected into some intricate structure. Regardless of fancy stuff, any link (except for the terminator) has the next one. Any link can match against a stream of characters, recursively propagating the match to the next link. Any link supports a number of matcher-building messages. This superclass does all of the above. The class is not necessarily abstract. It may double as an empty string matcher: it recursively propagates the match to the next link, thus always matching nothing successfully.Principal method:	matchAgainst: aMatcher		Any subclass will reimplement this to test the state of the matcher, most		probably reading one or more characters from the matcher's stream, and		either decide it has matched and answer true, leaving matcher stream		positioned at the end of match, or answer false and restore the matcher		stream position to whatever it was before the matching attempt.Instance variables:	next		&lt;RxmLink | RxmTerminator&gt; The next link in the structure.</body></comment><class><name>RxsNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsNode</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A generic syntax tree node, provides some common responses to the standard tests, as well as tree structure printing -- handy for debugging.</body></comment><class><name>RxsCharSet</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>negated elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsCharSet</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A character set corresponds to a [...] construct in the regular expression.Instance variables:	elements	&lt;OrderedCollection&gt; An element can be one of: RxsCharacter, RxsRange, or RxsPredicate.	negated		&lt;Boolean&gt;</body></comment><class><name>RxsPredicate</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predicate negation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsPredicate</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--This represents a character that satisfies a certain predicate.Instance Variables:	predicate	&lt;BlockClosure&gt;	A one-argument block. If it evaluates to the value defined by &lt;negated&gt; when it is passed a character, the predicate is considered to match.	negation	&lt;BlockClosure&gt;	A one-argument block that is a negation of &lt;predicate&gt;.</body></comment><class><name>RmCurrentMatchContext</name><environment>Smalltalk</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>RxsContextCondition</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>kind </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsContextCondition</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--One of a few special nodes more often representing special state of the match rather than a predicate on a character.  The ugly exception is the #any condition which *is* a predicate on a character.Instance variables:	kind		&lt;Selector&gt;</body></comment><class><name>RxsBranch</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>piece branch captureEnabled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsBranch</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A Branch is a Piece followed by a Branch or an empty string.Instance variables:	piece		&lt;RxsPiece&gt;	branch		&lt;RxsBranch|RxsEpsilon&gt;</body></comment><class><name>RxmPredicate</name><environment>Smalltalk</environment><super>RxmLink</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predicate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxmPredicate</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--Instance holds onto a one-argument block and matches exactly one character if the block evaluates to true when passed the character as the argument.Instance variables:	predicate		&lt;BlockClosure&gt;</body></comment><class><name>RxMatcher</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matcher ignoreCase startOptimizer stream markerPositions markerCount lastResult lastChar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxMatcher</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--This is a recursive regex matcher. Not strikingly efficient, but simple. Also, keeps track of matched subexpressions.  The life cycle goes as follows:1. Initialization. Accepts a syntax tree (presumably produced by RxParser) and compiles it into a matcher built of other classes in this category.2. Matching. Accepts a stream or a string and returns a boolean indicating whether the whole stream or its prefix -- depending on the message sent -- matches the regex.3. Subexpression query. After a successful match, and before any other match, the matcher may be queried about the range of specific stream (string) positions that matched to certain parenthesized subexpressions of the original expression.Any number of queries may follow a successful match, and any number or matches may follow a successful initialization.Note that `matcher' is actually a sort of a misnomer. The actual matcher is a web of Rxm* instances built by RxMatcher during initialization. RxMatcher is just the interface facade of this network.  It is also a builder of it, and also provides a stream-like protocol to easily access the stream being matched.Instance variables:	matcher				&lt;RxmLink&gt; The entry point into the actual matcher.	stream				&lt;Stream&gt; The stream currently being matched against.	markerPositions		&lt;Array of: Integer&gt; Positions of markers' matches.	markerCount		&lt;Integer&gt; Number of markers.	lastResult 			&lt;Boolean&gt; Whether the latest match attempt succeeded or not.	lastChar			&lt;Character | nil&gt; character last seen in the matcher stream</body></comment><class><name>RxCharSetParser</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source lookahead elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxCharSetParser</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--I am a parser created to parse the insides of a character set ([...]) construct. I create and answer a collection of "elements", each being an instance of one of: RxsCharacter, RxsRange, or RxsPredicate.Instance Variables:	source	&lt;Stream&gt;	open on whatever is inside the square brackets we have to parse.	lookahead	&lt;Character&gt;	The current lookahead character	elements	&lt;Collection of: &lt;RxsCharacter|RxsRange|RxsPredicate&gt;&gt; Parsing result</body></comment><class><name>RxmMarker</name><environment>Smalltalk</environment><super>RxmLink</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxmMarker</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A marker is used to remember positions of match of certain points of a regular expression. The marker receives an identifying key from the Matcher and uses that key to report positions of successful matches to the Matcher.Instance variables:	index	&lt;Object&gt; Something that makes sense for the Matcher. Received from the latter during initalization and later passed to it to identify the receiver.</body></comment><class><name>RxsEpsilon</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsEpsilon</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--This is an empty string.  It terminates some of the recursive constructs.</body></comment><class><name>RxmSubstring</name><environment>Smalltalk</environment><super>RxmLink</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sample compare </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxmSubstring</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--Instance holds onto a string and matches exactly this string, and exactly once.Instance variables:	string 	&lt;String&gt;</body></comment><class><name>RxsRegex</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>branch regex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsRegex</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--The body of a parenthesized thing, or a top-level expression, also an atom.  Instance variables:	branch		&lt;RxsBranch&gt;	regex		&lt;RxsRegex | RxsEpsilon&gt;</body></comment><class><name>RxMatchOptimizer</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ignoreCase prefixes nonPrefixes conditions testBlock methodPredicates nonMethodPredicates predicates nonPredicates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxMatchOptimizer</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A match start optimizer, handy for searching a string. Takes a regex syntax tree and sets itself up so that prefix characters or matcher states that cannot start a match are later recognized with #canStartMatch:in: method.Used by RxMatcher, but can be used by other matchers (if implemented) as well.</body></comment><class><name>RxsRange</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>first last </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsRange</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--I represent a range of characters as appear in character classes such as	[a-ZA-Z0-9].I appear in a syntax tree only as an element of RxsCharSet.Instance Variables:	first	&lt;Character&gt;	last	&lt;Character&gt;</body></comment><class><name>RxsPiece</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>atom min max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsPiece</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A piece is an atom, possibly optional or repeated a number of times.Instance variables:	atom	&lt;RxsCharacter|RxsCharSet|RxsPredicate|RxsRegex|RxsSpecial&gt;	min		&lt;Integer&gt;	max	&lt;Integer|nil&gt; nil means infinity</body></comment><class><name>RxParser</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input lookahead </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxParser</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--The regular expression parser. Translates a regular expression read from a stream into a parse tree. ('accessing' protocol). The tree can later be passed to a matcher initialization method.  All other classes in this category implement the tree. Refer to their comments for any details.Instance variables:	input		&lt;Stream&gt; A stream with the regular expression being parsed.	lookahead	&lt;Character&gt;</body></comment><class><name>RxmBranch</name><environment>Smalltalk</environment><super>RxmLink</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loopback alternative </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxmBranch</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--This is a branch of a matching process. Either `next' chain should match, or `alternative', if not nil, should match. Since this is also used to build loopbacks to match repetitions, `loopback' variable indicates whether the instance is a loopback: it affects the matcher-building operations (which of the paths through the branch is to consider as the primary when we have to find the "tail" of a matcher construct).Instance variables	alternative		&lt;RxmLink&gt; to match if `next' fails to match.	loopback		&lt;Boolean&gt;</body></comment><class><name>RxmRepeatOptional</name><environment>Smalltalk</environment><super>RxmBranch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>RxsRepetitions</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>RmMatchContext</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matcher context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>RxsCharacter</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>character </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsCharacter</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A character is a literal character that appears either in the expression itself or in a character set within an expression.Instance variables:	character		&lt;Character&gt;</body></comment><class><name>RxmRepeat</name><environment>Smalltalk</environment><super>RxmRepeatOptional</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>RxRepetitionsParser</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>RmRepeatContext</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalState depth x </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>RxmTerminator</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxmTerminator</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--Instances of this class are used to terminate matcher's chains. When a match reaches this (an instance receives #matchAgainst: message), the match is considered to succeed. Instances also support building protocol of RxmLinks, with some restrictions.</body></comment><class><name>RxsMessagePredicate</name><environment>Smalltalk</environment><super>RxsNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector negated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxsMessagePredicate</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A message predicate represents a condition on a character that is tested (at the match time) by sending a unary message to the character expecting a Boolean answer.Instance variables:	selector		&lt;Symbol&gt;</body></comment><class><name>RxmSpecial</name><environment>Smalltalk</environment><super>RxmLink</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matchSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><comment><class-id>RxmSpecial</class-id><body>-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov-- See `documentation' protocol of RxParser class for user's guide.--A special node that matches a specific matcher state rather than any input character.The state is either at-beginning-of-line or at-end-of-line.</body></comment><shared-variable><name>BackslashConstants</name><environment>RxParser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Regex11</package></attributes></shared-variable><shared-variable><name>BackslashSpecials</name><environment>RxParser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Regex11</package></attributes></shared-variable><shared-variable><name>LoggingEnabled</name><environment>RxParser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>true</initializer><attributes><package>Regex11</package></attributes></shared-variable><shared-variable><name>ExceptionObjects</name><environment>RxParser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Regex11</package></attributes></shared-variable><shared-variable><name>EscapedLetterSelectors</name><environment>RxsPredicate</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Regex11</package></attributes></shared-variable><shared-variable><name>NamedClassSelectors</name><environment>RxsPredicate</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Regex11</package></attributes></shared-variable><shared-variable><name>Cr</name><environment>RxMatcher</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Regex11</package></attributes></shared-variable><shared-variable><name>Lf</name><environment>RxMatcher</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Regex11</package></attributes></shared-variable><methods><class-id>RxmLink</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"If a link does not match the contents of the matcher's stream,	answer false. Otherwise, let the next matcher in the chain match."	^next matchAgainst: aMatcher</body><body package="Regex11">next		^next</body></methods><methods><class-id>RxmLink</class-id> <category>building</category><body package="Regex11">pointTailTo: anRxmLink	"Propagate this message along the chain of links.	Point `next' reference of the last link to &lt;anRxmLink&gt;.	If the chain is already terminated, blow up."	next == nil		ifTrue: [next := anRxmLink]		ifFalse: [next pointTailTo: anRxmLink]</body><body package="Regex11">terminateWith: aTerminator	"Propagate this message along the chain of links, and	make aTerminator the `next' link of the last link in the chain.	If the chain is already reminated with the same terminator, 	do not blow up."	next == nil		ifTrue: [next := aTerminator]		ifFalse: [next terminateWith: aTerminator]</body></methods><methods><class-id>RxmLink</class-id> <category>initialize-release</category><body package="Regex11">initialize	"Subclasses may want to initialize."</body><body package="Regex11">next: aLink	"Set the next link, either an RxmLink or an RxmTerminator."	next := aLink</body></methods><methods><class-id>RxmLink</class-id> <category>printing</category><body package="Regex11">printOn: aStream	super printOn: aStream.	aStream		space;		nextPut: $[.	self hash printOn: aStream.	aStream nextPut: $]</body></methods><methods><class-id>RxmLink class</class-id> <category>instance creation</category><body package="Regex11">new	^super new initialize</body></methods><methods><class-id>RxsNode</class-id> <category>testing</category><body package="Regex11">isAtomic	"Answer whether the node is atomic, i.e. matches exactly one 	constant predefined normal character.  A matcher may decide to 	optimize matching of a sequence of atomic nodes by glueing them 	together in a string."	^false "tentatively"</body><body package="Regex11">isNullable	"True if the node can match an empty sequence of characters."	^false "for most nodes"</body></methods><methods><class-id>RxsNode</class-id> <category>constants</category><body package="Regex11">indentCharacter	"Normally, #printOn:withIndent: method in subclasses	print several characters returned by this method to indicate	the tree structure."	^$+</body></methods><methods><class-id>RxsCharSet</class-id> <category>accessing</category><body package="Regex11">dispatchTo: aMatcher	"Inform the matcher of the kind of the node, and it	will do whatever it has to."	^aMatcher syntaxCharSet: self</body><body package="Regex11">hasPredicates	^elements anySatisfy: [:some | some isEnumerable not]</body><body package="Regex11">predicateIgnoringCase: aBoolean	| predicate enumerable |	enumerable := self enumerablePartPredicateIgnoringCase: aBoolean.	^self hasPredicates		ifFalse: [enumerable]		ifTrue:			[predicate := self predicatePartPredicate.			negated				ifTrue: [[:char | (enumerable value: char) and: [predicate value: char]]]				ifFalse: [[:char | (enumerable value: char) or: [predicate value: char]]]]</body><body package="Regex11">predicates	^(elements reject: [:some | some isEnumerable])		collect: [:each | each predicate]</body></methods><methods><class-id>RxsCharSet</class-id> <category>initialize-release</category><body package="Regex11">initializeElements: aCollection negated: aBoolean	"See class comment for instance variables description."	elements := aCollection.	negated := aBoolean</body></methods><methods><class-id>RxsCharSet</class-id> <category>testing</category><body package="Regex11">isEnumerable	elements detect: [:some | some isEnumerable not] ifNone: [^true].	^false</body><body package="Regex11">isNegated	^negated</body></methods><methods><class-id>RxsCharSet</class-id> <category>privileged</category><body package="Regex11">enumerablePartPredicateIgnoringCase: aBoolean	| enumeration |	enumeration := self optimalSetIgnoringCase: aBoolean.	^negated		ifTrue: [[:char | (enumeration includes: char) not]]		ifFalse: [[:char | enumeration includes: char]]</body><body package="Regex11">enumerableSetIgnoringCase: aBoolean	"Answer a collection of characters that make up the portion of me	that can be enumerated."	| set |	set := Set new.	elements do:		[:each |		each isEnumerable ifTrue:			[each enumerateTo: set ignoringCase: aBoolean]].	^set</body><body package="Regex11">optimalSetIgnoringCase: aBoolean	"Assuming the client with search the `set' using #includes:,	answer a collection with the contents of `set', of the class	that will provide the fastest lookup. Strings are faster than	Sets for short strings."	| set |	set := self enumerableSetIgnoringCase: aBoolean.	^set size &lt; 10		ifTrue: [String withAll: set]		ifFalse: [set]</body><body package="Regex11">predicatePartPredicate	"Answer a predicate that tests all of my elements that cannot be	enumerated."	| predicates |	predicates := elements reject: [:some | some isEnumerable].	predicates isEmpty		ifTrue: [^[:char | negated]].	predicates size = 1		ifTrue: [^negated			ifTrue: [predicates first predicateNegation]			ifFalse: [predicates first predicate]].	predicates := predicates collect: [:each | each predicate].	^negated		ifFalse:			[[:char | predicates anySatisfy: [:some | some value: char]]]		ifTrue:			[[:char | (predicates anySatisfy: [:some | some value: char]) not]]</body></methods><methods><class-id>RxsPredicate</class-id> <category>initialize-release</category><body package="Regex11">beAlphaNumeric	predicate := [:char | char isAlphaNumeric].	negation := [:char | char isAlphaNumeric not]</body><body package="Regex11">beAlphabetic	predicate := [:char | char isAlphabetic].	negation := [:char | char isAlphabetic not]</body><body package="Regex11">beBackslash	predicate := [:char | char == $\].	negation := [:char | char ~~ $\]</body><body package="Regex11">beControl	predicate := [:char | char asInteger &lt; 32].	negation := [:char | char asInteger &gt;= 32]</body><body package="Regex11">beDigit	predicate := [:char | char isDigit].	negation := [:char | char isDigit not]</body><body package="Regex11">beGraphics	self		beControl;		negate</body><body package="Regex11">beHexDigit	| hexLetters |	hexLetters := 'abcdefABCDEF'.	predicate := [:char | char isDigit or: [hexLetters includes: char]].	negation := [:char | char isDigit not and: [(hexLetters includes: char) not]]</body><body package="Regex11">beLowercase	predicate := [:char | char isLowercase].	negation := [:char | char isLowercase not]</body><body package="Regex11">beNotDigit	self		beDigit;		negate</body><body package="Regex11">beNotSpace	self		beSpace;		negate</body><body package="Regex11">beNotWordConstituent	self		beWordConstituent;		negate</body><body package="Regex11">bePrintable	self		beControl;		negate</body><body package="Regex11">bePunctuation	| punctuationChars |	punctuationChars := #($. $, $! $? $; $: $" $' $- $( $) $`).	predicate := [:char | punctuationChars includes: char].	negation := [:char | (punctuationChars includes: char) not]</body><body package="Regex11">beSpace	predicate := [:char | char isSeparator].	negation := [:char | char isSeparator not]</body><body package="Regex11">beUppercase	predicate := [:char | char isUppercase].	negation := [:char | char isUppercase not]</body><body package="Regex11">beWordConstituent	predicate := [:char | char isAlphaNumeric or: [char == $_]].	negation := [:char | char isAlphaNumeric not and: [char ~~ $_]]</body></methods><methods><class-id>RxsPredicate</class-id> <category>accessing</category><body package="Regex11">dispatchTo: anObject	^anObject syntaxPredicate: self</body><body package="Regex11">negated	^self copy negate</body><body package="Regex11">predicate	^predicate</body><body package="Regex11">predicateNegation	^negation</body><body package="Regex11">value: aCharacter	^predicate value: aCharacter</body></methods><methods><class-id>RxsPredicate</class-id> <category>testing</category><body package="Regex11">isAtomic	"A predicate is a single character but the character is not known in advance."	^false</body><body package="Regex11">isEnumerable	^false</body></methods><methods><class-id>RxsPredicate</class-id> <category>private</category><body package="Regex11">negate	| tmp |	tmp := predicate.	predicate := negation.	negation := tmp</body></methods><methods><class-id>RxsPredicate class</class-id> <category>instance creation</category><body package="Regex11">forEscapedLetter: aCharacter	^self new perform:		(EscapedLetterSelectors			at: aCharacter			ifAbsent: [RxParser signalSyntaxException: 'bad backslash escape'])</body><body package="Regex11">forNamedClass: aString	^self new perform:		(NamedClassSelectors			at: aString			ifAbsent: [RxParser signalSyntaxException: 'bad character class name'])</body></methods><methods><class-id>RxsPredicate class</class-id> <category>class initialization</category><body package="Regex11">initialize	"self initialize"	self		initializeNamedClassSelectors;		initializeEscapedLetterSelectors</body><body package="Regex11">initializeEscapedLetterSelectors	"self initializeEscapedLetterSelectors"	(EscapedLetterSelectors := Dictionary new)		at: $w put: #beWordConstituent;		at: $W put: #beNotWordConstituent;		at: $d put: #beDigit;		at: $D put: #beNotDigit;		at: $s put: #beSpace;		at: $S put: #beNotSpace;		at: $\ put: #beBackslash</body><body package="Regex11">initializeNamedClassSelectors	"self initializeNamedClassSelectors"	(NamedClassSelectors := Dictionary new)		at: 'alnum' put: #beAlphaNumeric;		at: 'alpha' put: #beAlphabetic;		at: 'cntrl' put: #beControl;		at: 'digit' put: #beDigit;		at: 'graph' put: #beGraphics;		at: 'lower' put: #beLowercase;		at: 'print' put: #bePrintable;		at: 'punct' put: #bePunctuation;		at: 'space' put: #beSpace;		at: 'upper' put: #beUppercase;		at: 'xdigit' put: #beHexDigit</body></methods><methods><class-id>RmCurrentMatchContext</class-id> <category>private - actions</category><body package="Regex11">defaultAction	^self class defaultValue</body></methods><methods><class-id>RmCurrentMatchContext</class-id> <category>private</category><body package="Regex11">performHandler: aContext	"The following method is a copy from GenericException&gt;&gt;performHandler:	 Why? Because the debugger specifically looks for GE's implementation of this method to detect if it needs to break	 during code simulation for an unexpected exception handler. For the case of dynamic variables, we do not want the	 debugger to suddenly stop running just because we've hit the request for a dynamic variable."	| result oldHandler |	(handlerContext := aContext) == nil		ifTrue:			[result := self defaultAction.			self isResumable				ifTrue:					[handlerContext := initialContext.					firstUnwindContext := nil.					self unwind.					thisContext terminateTo: handlerContext.					handlerContext := nil]]		ifFalse:			[oldHandler := handlerContext.			result := handlerContext handlerBlock cull: self.			handlerContext := oldHandler. "Executing the handler may have set a new handler."			self unwind.			thisContext terminateTo: handlerContext].	^result</body></methods><methods><class-id>RmCurrentMatchContext class</class-id> <category>defaults</category><body package="Regex11">defaultValue	^nil</body><body package="Regex11">value	"Answer the dynamic value of the receiver."		^ self signal</body></methods><methods><class-id>RmCurrentMatchContext class</class-id> <category>evaluating</category><body package="Regex11">use: aMatchContext during: aBlock	"Set the dynamic value of the receiver to anObject during the evaluation of aBlock."		^ aBlock on: self do: [ :notification | notification resume: aMatchContext ]</body></methods><methods><class-id>RxsContextCondition</class-id> <category>initialize-release</category><body package="Regex11">beAny	"Matches anything but a newline."	kind := #syntaxAny</body><body package="Regex11">beBeginningOfLine	"Matches empty string at the beginning of a line."	kind := #syntaxBeginningOfLine</body><body package="Regex11">beBeginningOfWord	"Matches empty string at the beginning of a word."	kind := #syntaxBeginningOfWord</body><body package="Regex11">beEndOfLine	"Matches empty string at the end of a line."	kind := #syntaxEndOfLine</body><body package="Regex11">beEndOfWord	"Matches empty string at the end of a word."	kind := #syntaxEndOfWord</body><body package="Regex11">beNonWordBoundary	"Analog of \B."	kind := #syntaxNonWordBoundary</body><body package="Regex11">beWordBoundary	"Analog of \w (alphanumeric plus _)."	kind := #syntaxWordBoundary</body></methods><methods><class-id>RxsContextCondition</class-id> <category>testing</category><body package="Regex11">isNullable	^#syntaxAny ~~ kind</body></methods><methods><class-id>RxsContextCondition</class-id> <category>accessing</category><body package="Regex11">dispatchTo: aBuilder	^aBuilder perform: kind</body></methods><methods><class-id>RxsBranch</class-id> <category>accessing</category><body package="Regex11">branch	^branch</body><body package="Regex11">captureEnabled	^captureEnabled</body><body package="Regex11">captureEnabled: anObject	captureEnabled := anObject</body><body package="Regex11">dispatchTo: aMatcher	"Inform the matcher of the kind of the node, and it	will do whatever it has to."	^aMatcher syntaxBranch: self</body><body package="Regex11">piece	^piece</body></methods><methods><class-id>RxsBranch</class-id> <category>optimization</category><body package="Regex11">tryMergingInto: aStream	"Concatenation of a few simple characters can be optimized	to be a plain substring match. Answer the node to resume	syntax tree traversal at. Epsilon node used to terminate the branch	will implement this to answer nil, thus indicating that the branch	has ended."	piece isAtomic ifFalse: [^self].	aStream nextPut: piece character.	^branch isNil		ifTrue: [branch]		ifFalse: [branch tryMergingInto: aStream]</body></methods><methods><class-id>RxsBranch</class-id> <category>testing</category><body package="Regex11">isNullable	^piece isNullable and: [branch isNil or: [branch isNullable]]</body></methods><methods><class-id>RxsBranch</class-id> <category>initialize-release</category><body package="Regex11">initializePiece: aPiece branch: aBranch	"See class comment for instance variables description."	piece := aPiece.	branch := aBranch</body></methods><methods><class-id>RxmPredicate</class-id> <category>initialize-release</category><body package="Regex11">bePerform: aSelector	"Match any single character that answers true  to this message."	self predicate: 		[:char | 		RxParser doHandlingMessageNotUnderstood: [char perform: aSelector]]</body><body package="Regex11">bePerformNot: aSelector	"Match any single character that answers false to this message."	self predicate: 		[:char | 		RxParser doHandlingMessageNotUnderstood: [(char perform: aSelector) not]]</body><body package="Regex11">predicate: aBlock	"This link will match any single character for which &lt;aBlock&gt;	evaluates to true."	aBlock numArgs ~= 1 ifTrue: [self error: 'bad predicate block'].	predicate := aBlock.	^self</body></methods><methods><class-id>RxmPredicate</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"Match if the predicate block evaluates to true when given the	current stream character as the argument."	| original |	original := aMatcher currentState.	(aMatcher atEnd not 		and: [(predicate value: aMatcher next)			and: [next matchAgainst: aMatcher]])		ifTrue: [^true]		ifFalse:			[aMatcher restoreState: original.			^false]</body></methods><methods><class-id>RxmPredicate</class-id> <category>printing</category><body package="Regex11">printOn: aStream	super printOn: aStream.	aStream		space;		nextPutAll: predicate copiedValues printString.</body></methods><methods><class-id>RxmPredicate class</class-id> <category>instance creation</category><body package="Regex11">with: unaryBlock	^self new predicate: unaryBlock</body></methods><methods><class-id>RxMatcher</class-id> <category>private</category><body package="Regex11">allocateMarker	"Answer an integer to use as an index of the next marker."	markerCount := markerCount + 1.	^markerCount</body><body package="Regex11">hookBranchOf: regexNode onto: endMarker	"Private - Recurse down the chain of regexes starting at	regexNode, compiling their branches and hooking their tails 	to the endMarker node."	| rest |	rest := regexNode regex isNil		ifTrue: [nil]		ifFalse: [self hookBranchOf: regexNode regex onto: endMarker].	^RxmBranch new		next: ((regexNode branch dispatchTo: self)					pointTailTo: endMarker; 					yourself);		alternative: rest;		yourself</body><body package="Regex11">isWordChar: aCharacterOrNil	"Answer whether the argument is a word constituent character:	alphanumeric or _."	^aCharacterOrNil ~~ nil		and: [aCharacterOrNil isAlphaNumeric]</body><body package="Regex11">makeOptional: aMatcher	"Private - Wrap this matcher so that the result would match 0 or 1	occurrences of the matcher."	| dummy branch |	dummy := RxmLink new.	branch := (RxmBranch new beLoopback)		next: aMatcher;		alternative: dummy.	aMatcher pointTailTo: dummy.	^branch</body><body package="Regex11">makeOptionalRepetitions: aMatcher max: max	"Private - Wrap this matcher so that the result would match 0 or more	occurrences of the matcher, with an upper limit of occurences"	| repeat |	repeat := (RxmRepeatOptional new)				max: max;				yourself.	repeat		beLoopback;		next: aMatcher.	aMatcher pointTailTo: repeat.	^repeat</body><body package="Regex11">makePlus: aMatcher	"Private - Wrap this matcher so that the result would match 1 and more	occurrences of the matcher."	| loopback |	loopback := (RxmBranch new beLoopback)		next: aMatcher.	aMatcher pointTailTo: loopback.	^aMatcher</body><body package="Regex11">makePlusRepetitions: aMatcher min: min max: max	"Private - Wrap this matcher so that the result would match 1 and more	occurrences of the matcher, with a lower limit and an upper limit of occurences"	| detour repeat dummy |	dummy := RxmLink new.	repeat := (RxmRepeat new)				min: min;				max: max;				yourself.	detour := (RxmBranch new)				next: aMatcher.	repeat		beLoopback;		next: aMatcher;		alternative: dummy.	aMatcher pointTailTo: repeat.	^detour</body><body package="Regex11">makeRepetitions: aMatcher min: min max: max	"Private - Wrap this matcher."	"Use existing logic for simple cases"	(min = 0 and: [max = 1]) ifTrue: [^self makeOptional: aMatcher	"{0,1}"].	(min = 0 and: [max isNil]) ifTrue: [^self makeStar: aMatcher	"{0,}"].	(min = 1 and: [max isNil]) ifTrue: [^self makePlus: aMatcher	"{1,}"].	"New logic for explicitely numbered occurences"	^min &gt; 0		ifFalse: [self makeOptionalRepetitions: aMatcher max: max	"{0,n}"]		ifTrue: [self makePlusRepetitions: aMatcher min: min max: max	"{m,n}"]</body><body package="Regex11">makeStar: aMatcher	"Private - Wrap this matcher so that the result would match 0 and more	occurrences of the matcher."	| dummy detour loopback |	dummy := RxmLink new.	detour := RxmBranch new		next: aMatcher;		alternative: dummy.	loopback := (RxmBranch new beLoopback)		next: aMatcher;		alternative: dummy.	aMatcher pointTailTo: loopback.	^detour</body><body package="Regex11">proceedSearchingStream: aStream	| position |	position := aStream position.	[aStream atEnd] whileFalse:		[self tryMatch ifTrue: [^true].		aStream position: position.		lastChar := aStream next.		position := aStream position].	"Try match at the very stream end too!"	self tryMatch ifTrue: [^true]. 	^false</body><body package="Regex11">tryMatch	"Match thyself against the current stream.	A context object is established so that explicit repeats can be processed"	self withContextDo: 			[markerPositions := Array new: markerCount.			1 to: markerCount do: [:i | markerPositions at: i put: OrderedCollection new].			startOptimizer == nil				ifTrue: [lastResult := matcher matchAgainst: self]				ifFalse: 					[lastResult := (startOptimizer canStartMatch: stream peek in: self)								and: [matcher matchAgainst: self]]].	^lastResult</body><body package="Regex11">withContextDo: aBlock	^RmCurrentMatchContext use: RmMatchContext new during: aBlock</body></methods><methods><class-id>RxMatcher</class-id> <category>testing</category><body package="Regex11">atBeginningOfLine	^self position = 0 or: [lastChar = Cr]</body><body package="Regex11">atBeginningOfWord	^(self isWordChar: lastChar) not		and: [self isWordChar: stream peek]</body><body package="Regex11">atEndOfLine	^self atEnd or: [stream peek = Cr]</body><body package="Regex11">atEndOfWord	^(self isWordChar: lastChar)		and: [(self isWordChar: stream peek) not]</body><body package="Regex11">atWordBoundary	^(self isWordChar: lastChar)		xor: (self isWordChar: stream peek)</body><body package="Regex11">notAtWordBoundary	^self atWordBoundary not</body><body package="Regex11">supportsSubexpressions	^true</body></methods><methods><class-id>RxMatcher</class-id> <category>streaming</category><body package="Regex11">atEnd	^stream atEnd</body><body package="Regex11">next	lastChar := stream next.	^lastChar</body><body package="Regex11">position	^stream position</body></methods><methods><class-id>RxMatcher</class-id> <category>double dispatch</category><body package="Regex11">syntaxAny	"Double dispatch from the syntax tree. 	Create a matcher for any non-null character."	^RxmPredicate new		predicate: [:char | char asInteger ~= 0]</body><body package="Regex11">syntaxBeginningOfLine	"Double dispatch from the syntax tree. 	Create a matcher for beginning-of-line condition."	^RxmSpecial new beBeginningOfLine</body><body package="Regex11">syntaxBeginningOfWord	"Double dispatch from the syntax tree. 	Create a matcher for beginning-of-word condition."	^RxmSpecial new beBeginningOfWord</body><body package="Regex11">syntaxBranch: branchNode	"Double dispatch from the syntax tree. 	Branch node is a link in a chain of concatenated pieces.	First build the matcher for the rest of the chain, then make 	it for the current piece and hook the rest to it."	| result next rest |	branchNode branch isNil		ifTrue: [^branchNode piece dispatchTo: self].	"Optimization: glue a sequence of individual characters into a single string to match."	branchNode piece isAtomic ifTrue:		[result := WriteStream on: (String new: 40).		next := branchNode tryMergingInto: result.		result := result contents.		result size &gt; 1 ifTrue: "worth merging"			[rest := next notNil 				ifTrue: [next dispatchTo: self]				ifFalse: [nil].			^(RxmSubstring new substring: result ignoreCase: ignoreCase)				pointTailTo: rest;				yourself]].	"No optimization possible or worth it, just concatenate all. "	^(branchNode piece dispatchTo: self)		pointTailTo: (branchNode branch dispatchTo: self);		yourself</body><body package="Regex11">syntaxCharSet: charSetNode	"Double dispatch from the syntax tree. 	A character set is a few characters, and we either match any of them,	or match any that is not one of them."	^RxmPredicate with: (charSetNode predicateIgnoringCase: ignoreCase)</body><body package="Regex11">syntaxCharacter: charNode	"Double dispatch from the syntax tree. 	We get here when no merging characters into strings was possible."	| wanted |	wanted := charNode character.	^RxmPredicate new predicate: 		(ignoreCase			ifTrue: [[:char | char sameAs: wanted]]			ifFalse: [[:char | char = wanted]])</body><body package="Regex11">syntaxEndOfLine	"Double dispatch from the syntax tree. 	Create a matcher for end-of-line condition."	^RxmSpecial new beEndOfLine</body><body package="Regex11">syntaxEndOfWord	"Double dispatch from the syntax tree. 	Create a matcher for end-of-word condition."	^RxmSpecial new beEndOfWord</body><body package="Regex11">syntaxEpsilon	"Double dispatch from the syntax tree. Match empty string. This is unlikely	to happen in sane expressions, so we'll live without special epsilon-nodes."	^RxmSubstring new		substring: String new		ignoreCase: ignoreCase</body><body package="Regex11">syntaxMessagePredicate: messagePredicateNode	"Double dispatch from the syntax tree. 	Special link can handle predicates."	| sel |	sel := messagePredicateNode selector.	(#(true false) includes: ([$a perform: sel] on: Error do: [:ex | ex return: nil])) ifFalse:		[RxParser signalSyntaxException: 'Invalid predicate selector, :', sel, ':'].	^messagePredicateNode negated		ifTrue: [RxmPredicate new bePerformNot: sel]		ifFalse: [RxmPredicate new bePerform: sel]</body><body package="Regex11">syntaxNonWordBoundary	"Double dispatch from the syntax tree. 	Create a matcher for the word boundary condition."	^RxmSpecial new beNotWordBoundary</body><body package="Regex11">syntaxPiece: pieceNode	"Double dispatch from the syntax tree. 	Piece is an atom repeated a few times. Take care of a special	case when the atom is repeated just once."	| atom |	atom := pieceNode atom dispatchTo: self.	^pieceNode isSingular		ifTrue: [atom]		ifFalse: 			[pieceNode isStar				ifTrue: [self makeStar: atom]				ifFalse: 					[pieceNode isPlus						ifTrue: [self makePlus: atom]						ifFalse: 							[pieceNode isOptional								ifTrue: [self makeOptional: atom]								ifFalse: 									[self										makeRepetitions: atom										min: pieceNode min										max: pieceNode max]]]]</body><body package="Regex11">syntaxPredicate: predicateNode	"Double dispatch from the syntax tree. 	A character set is a few characters, and we either match any of them,	or match any that is not one of them."	^RxmPredicate with: predicateNode predicate</body><body package="Regex11">syntaxRegex: regexNode	"Double dispatch from the syntax tree. 	Regex node is a chain of branches to be tried. Should compile this 	into a bundle of parallel branches, between two marker nodes."	| startIndex endIndex endNode alternatives |	regexNode branch captureEnabled		ifTrue: 			[startIndex := self allocateMarker.			endIndex := self allocateMarker]		ifFalse: 			["Non-capturing markers"			startIndex := endIndex := 0].	endNode := RxmMarker new index: endIndex.	alternatives := self hookBranchOf: regexNode onto: endNode.	^(RxmMarker new index: startIndex)		pointTailTo: alternatives;		yourself</body><body package="Regex11">syntaxWordBoundary	"Double dispatch from the syntax tree. 	Create a matcher for the word boundary condition."	^RxmSpecial new beWordBoundary</body></methods><methods><class-id>RxMatcher</class-id> <category>accessing</category><body package="Regex11">buildFrom: aSyntaxTreeRoot	"Private - Entry point of matcher build process."	markerCount := 0.  "must go before #dispatchTo: !"	matcher := aSyntaxTreeRoot dispatchTo: self.	matcher terminateWith: RxmTerminator new</body><body package="Regex11">lastResult	^lastResult</body><body package="Regex11">matches: aString	"Match against a string."	^self matchesStream: aString readStream</body><body package="Regex11">matchesPrefix: aString	"Match against a string."	^self matchesStreamPrefix: aString readStream</body><body package="Regex11">matchesStream: theStream	"Match thyself against a positionable stream."	^(self matchesStreamPrefix: theStream)		and: [stream atEnd]</body><body package="Regex11">matchesStreamPrefix: theStream	"Match thyself against a positionable stream."	stream := theStream.	lastChar := nil.	^self tryMatch</body><body package="Regex11">search: aString	"Search the string for occurrence of something matching myself.	Answer a Boolean indicating success."	^self searchStream: aString readStream</body><body package="Regex11">searchStream: aStream	"Search the stream for occurrence of something matching myself.	After the search has occurred, stop positioned after the end of the	matched substring. Answer a Boolean indicating success."	| position |	stream := aStream.	lastChar := nil.	position := aStream position.	[aStream atEnd] whileFalse:		[self tryMatch ifTrue: [^true].		aStream position: position.		lastChar := aStream next.		position := aStream position].	"Try match at the very stream end too!"	self tryMatch ifTrue: [^true]. 	^false</body><body package="Regex11">subBeginning: subIndex	^markerPositions at: subIndex * 2 - 1</body><body package="Regex11">subEnd: subIndex	^markerPositions at: subIndex * 2</body><body package="Regex11">subexpression: subIndex	"Answer a string that matched the subexpression at the given index.	If there are multiple matches, answer the last one.	If there are no matches, answer nil. 	(NB: it used to answer an empty string but I think nil makes more sense)."	| matches |	matches := self subexpressions: subIndex.	^matches isEmpty ifTrue: [nil] ifFalse: [matches last]</body><body package="Regex11">subexpressionCount	^markerCount // 2</body><body package="Regex11">subexpressions: subIndex	"Answer an array of all matches of the subexpression at the given index.	The answer is always an array; it is empty if there are no matches."	| originalPosition startPositions stopPositions reply |	originalPosition := stream position.	startPositions := self subBeginning: subIndex.	stopPositions := self subEnd: subIndex.	(startPositions isEmpty or: [stopPositions isEmpty]) ifTrue: [^Array new].	reply := OrderedCollection new.	startPositions with: stopPositions do:		[:start :stop |		stream position: start.		reply add: (stream next: stop - start)].	stream position: originalPosition.	^reply asArray</body></methods><methods><class-id>RxMatcher</class-id> <category>match enumeration</category><body package="Regex11">copy: aString replacingMatchesWith: replacementString	"Copy &lt;aString&gt;, except for the matches. Replace each match with &lt;aString&gt;."	| answer |	answer := (String new: 40) writeStream.	self		copyStream: aString readStream		to: answer		replacingMatchesWith: replacementString.	^answer contents</body><body package="Regex11">copy: aString translatingMatchesUsing: aBlock	"Copy &lt;aString&gt;, except for the matches. For each match, evaluate &lt;aBlock&gt; passing the matched substring as the argument.  Expect the block to answer a String, and replace the match with the answer."	| answer |	answer := (String new: 40) writeStream.	self copyStream: aString readStream to: answer translatingMatchesUsing: aBlock.	^answer contents</body><body package="Regex11">copyStream: aStream to: writeStream replacingMatchesWith: aString	"Copy the contents of &lt;aStream&gt; on the &lt;writeStream&gt;, except for the matches. Replace each match with &lt;aString&gt;."	| searchStart matchStart matchEnd |	stream := aStream.	lastChar := nil.	[searchStart := aStream position.	self proceedSearchingStream: aStream] whileTrue:		[matchStart := (self subBeginning: 1) first.		matchEnd := (self subEnd: 1) first.		aStream position: searchStart.		searchStart to: matchStart - 1 do:			[:ignoredPos | writeStream nextPut: aStream next].		writeStream nextPutAll: aString.		aStream position: matchEnd.		"Be extra careful about successful matches which consume no input.		After those, make sure to advance or finish if already at end."		matchEnd = searchStart ifTrue: 			[aStream atEnd				ifTrue:	[^self "rest after end of whileTrue: block is a no-op if atEnd"]				ifFalse:	[writeStream nextPut: aStream next]]].	aStream position: searchStart.	[aStream atEnd] whileFalse: [writeStream nextPut: aStream next]</body><body package="Regex11">copyStream: aStream to: writeStream translatingMatchesUsing: aBlock	"Copy the contents of &lt;aStream&gt; on the &lt;writeStream&gt;, except for the matches. For each match, evaluate &lt;aBlock&gt; passing the matched substring as the argument.  Expect the block to answer a String, and write the answer to &lt;writeStream&gt; in place of the match."	| searchStart matchStart matchEnd match |	stream := aStream.	lastChar := nil.	[searchStart := aStream position.	self proceedSearchingStream: aStream] whileTrue:		[matchStart := (self subBeginning: 1) first.		matchEnd := (self subEnd: 1) first.		aStream position: searchStart.		searchStart to: matchStart - 1 do:			[:ignoredPos | writeStream nextPut: aStream next].		match := (String new: matchEnd - matchStart + 1) writeStream.		matchStart to: matchEnd - 1 do:			[:ignoredPos | match nextPut: aStream next].		writeStream nextPutAll: (aBlock value: match contents).		"Be extra careful about successful matches which consume no input.		After those, make sure to advance or finish if already at end."		matchEnd = searchStart ifTrue: 			[aStream atEnd				ifTrue:	[^self "rest after end of whileTrue: block is a no-op if atEnd"]				ifFalse:	[writeStream nextPut: aStream next]]].	aStream position: searchStart.	[aStream atEnd] whileFalse: [writeStream nextPut: aStream next]</body><body package="Regex11">matchesIn: aString	"Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of all matches (substrings)."	| result |	result := OrderedCollection new.	self		matchesOnStream: aString readStream		do: [:match | result add: match].	^result</body><body package="Regex11">matchesIn: aString collect: aBlock	"Search aString repeatedly for the matches of the receiver.  Evaluate aBlock for each match passing the matched substring as the argument, collect evaluation results in an OrderedCollection, and return in. The following example shows how to use this message to split a string into words."	"'\w+' asRegex matchesIn: 'Now is the Time' collect: [:each | each asLowercase]"	| result |	result := OrderedCollection new.	self		matchesOnStream: aString readStream		do: [:match | result add: (aBlock value: match)].	^result</body><body package="Regex11">matchesIn: aString do: aBlock	"Search aString repeatedly for the matches of the receiver.	Evaluate aBlock for each match passing the matched substring	as the argument."	self		matchesOnStream: aString readStream		do: aBlock</body><body package="Regex11">matchesOnStream: aStream	| result |	result := OrderedCollection new.	self		matchesOnStream: aStream		do: [:match | result add: match].	^result</body><body package="Regex11">matchesOnStream: aStream collect: aBlock	| result |	result := OrderedCollection new.	self		matchesOnStream: aStream		do: [:match | result add: (aBlock value: match)].	^result</body><body package="Regex11">matchesOnStream: aStream do: aBlock	"Be extra careful about successful matches which consume no input.	After those, make sure to advance or finish if already at end."	| position |	[position := aStream position.	self searchStream: aStream] whileTrue:		[aBlock value: (self subexpression: 1).		position = aStream position ifTrue: 			[aStream atEnd				ifTrue: [^self]				ifFalse: [aStream next]]]</body><body package="Regex11">matchingRangesIn: aString	"Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."	| result |	result := OrderedCollection new.	self		matchesIn: aString 		do: [:match | result add: (self position - match size + 1 to: self position)].	^result</body></methods><methods><class-id>RxMatcher</class-id> <category>initialize-release</category><body package="Regex11">initialize: syntaxTreeRoot ignoreCase: aBoolean	"Compile thyself for the regex with the specified syntax tree.	See comment and `building' protocol in this class and 	#dispatchTo: methods in syntax tree components for details 	on double-dispatch building. 	The argument is supposedly a RxsRegex."	ignoreCase := aBoolean.	self buildFrom: syntaxTreeRoot.	startOptimizer := RxMatchOptimizer new initialize: syntaxTreeRoot ignoreCase: aBoolean</body></methods><methods><class-id>RxMatcher</class-id> <category>privileged</category><body package="Regex11">currentState	"Answer an opaque object that can later be used to restore the	matcher's state (for backtracking)."	| origPosition origLastChar origMarkerPositions |	origPosition := stream position.	origLastChar := lastChar.	origMarkerPositions := markerPositions				collect: [:collection | collection copy].	^	[stream position: origPosition.	lastChar := origLastChar.	markerPositions := origMarkerPositions]</body><body package="Regex11">markerPositionAt: anIndex add: position	"Remember position of another instance of the given marker."	anIndex = 0		ifTrue: 			["Non capturing marker"			^self].	(markerPositions at: anIndex) addFirst: position</body><body package="Regex11">restoreState: aBlock	aBlock value</body></methods><methods><class-id>RxMatcher</class-id> <category>printing</category><body package="Regex11">graph	"Not quite finished"	| visited node alternative graph graphBlock |	graph := OrderedCollection new.	visited := OrderedCollection new.	graphBlock :=			[:aNode |			visited add: aNode.			((aNode respondsTo: #alternative)				and: [aNode alternative notNil])					ifTrue: [alternative := aNode alternative].			graph add: aNode].	node := matcher.	graphBlock value: node.	[node class == RxmTerminator] whileFalse: 			[node := node next.			(visited includes: node) ifTrue: [node := alternative].			graphBlock value: node].	^graph</body><body package="Regex11">graphOn: aStream	self graph do: 			[:eachNode |			eachNode printOn: aStream.			aStream cr]</body><body package="Regex11">graphString	| aStream |	aStream := String new writeStream.	self graphOn: aStream.	^aStream contents</body></methods><methods><class-id>RxMatcher</class-id> <category>converting</category><body package="Regex11">asRegex	^self.</body></methods><methods><class-id>RxMatcher class</class-id> <category>instance creation</category><body package="Regex11">for: aRegex	"Create and answer a matcher that will match a regular expression	specified by the syntax tree of which `aRegex' is a root."	^self for: aRegex ignoreCase: false</body><body package="Regex11">for: aRegex ignoreCase: aBoolean	"Create and answer a matcher that will match a regular expression	specified by the syntax tree of which `aRegex' is a root."	^self new		initialize: aRegex		ignoreCase: aBoolean</body><body package="Regex11">forString: aString	"Create and answer a matcher that will match the regular expression	`aString'."	^self for: (RxParser new parse: aString)</body><body package="Regex11">forString: aString ignoreCase: aBoolean	"Create and answer a matcher that will match the regular expression	`aString'."	^self for: (RxParser new parse: aString) ignoreCase: aBoolean</body></methods><methods><class-id>RxMatcher class</class-id> <category>class initialization</category><body package="Regex11">initialize	"RxMatcher initialize"	Cr := TextConstants at: #CR.	Lf := TextConstants at: #LF</body></methods><methods><class-id>RxCharSetParser</class-id> <category>accessing</category><body package="Regex11">parse	lookahead = $- ifTrue:		[self addChar: $-.		self match: $-].	[lookahead isNil] whileFalse: [self parseStep].	^elements</body></methods><methods><class-id>RxCharSetParser</class-id> <category>parsing</category><body package="Regex11">addChar: aChar	elements add: (RxsCharacter with: aChar)</body><body package="Regex11">addRangeFrom: firstChar to: lastChar	firstChar asInteger &gt; lastChar asInteger ifTrue:		[RxParser signalSyntaxException: ' bad character range'].	elements add: (RxsRange from: firstChar to: lastChar)</body><body package="Regex11">match: aCharacter	aCharacter = lookahead ifFalse: [ | chBlock |		chBlock := [:ch | ch ifNil: ['no character'] ifNotNil: [String with: ch]].		RxParser signalSyntaxException: 			'was expecting ', (chBlock value: aCharacter), 			' but found ', (chBlock value: lookahead)].	^source atEnd		ifTrue: [lookahead := nil]		ifFalse: [lookahead := source next]</body><body package="Regex11">parseCharOrRange	| firstChar |	firstChar := lookahead.	self match: firstChar.	lookahead = $- ifTrue:		[self match: $-.		lookahead isNil			ifTrue: [^self addChar: firstChar; addChar: $-]			ifFalse: 				[self addRangeFrom: firstChar to: lookahead.				^self match: lookahead]].	self addChar: firstChar</body><body package="Regex11">parseEscapeChar	self match: $\.	$- = lookahead		ifTrue: [elements add: (RxsCharacter with: $-)]		ifFalse: [elements add: (RxsPredicate forEscapedLetter: lookahead)].	self match: lookahead</body><body package="Regex11">parseNamedSet	| name |	self match: $[; match: $:.	name := (String with: lookahead), (source upTo: $:).	lookahead := source next.	self match: $].	elements add: (RxsPredicate forNamedClass: name)</body><body package="Regex11">parseStep	lookahead = $[ ifTrue:		[source peek = $:			ifTrue: [^self parseNamedSet]			ifFalse: [^self parseCharOrRange]].	lookahead = $\ ifTrue:		[^self parseEscapeChar].	lookahead = $- ifTrue:		[RxParser signalSyntaxException: 'invalid range'].	self parseCharOrRange</body></methods><methods><class-id>RxCharSetParser</class-id> <category>initialize-release</category><body package="Regex11">initialize: aStream	source := aStream.	lookahead := aStream next.	elements := OrderedCollection new</body></methods><methods><class-id>RxCharSetParser class</class-id> <category>instance creation</category><body package="Regex11">on: aStream	^self new initialize: aStream</body></methods><methods><class-id>RxmMarker</class-id> <category>initialize-release</category><body package="Regex11">index: anIndex	"An index is a key that makes sense for the matcher.	This key can be passed to marker position getters and	setters to access position for this marker in the current	matching session."	index := anIndex</body></methods><methods><class-id>RxmMarker</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"If the rest of the link chain matches successfully, report the	position of the stream *before* the match started to the matcher."	| startPosition |	startPosition := aMatcher position.	(next matchAgainst: aMatcher)		ifTrue:			[aMatcher markerPositionAt: index add: startPosition.			^true].	^false</body></methods><methods><class-id>RxmMarker</class-id> <category>printing</category><body package="Regex11">printOn: aStream	super printOn: aStream.	aStream space.	index printOn: aStream</body></methods><methods><class-id>RxsEpsilon</class-id> <category>building</category><body package="Regex11">dispatchTo: aBuilder	"Inform the matcher of the kind of the node, and it	will do whatever it has to."	^aBuilder syntaxEpsilon</body></methods><methods><class-id>RxsEpsilon</class-id> <category>testing</category><body package="Regex11">isNullable	"See comment in the superclass."	^true</body></methods><methods><class-id>RxmSubstring</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"Match if my sample stream is exactly the current prefix	of the matcher stream's contents."	| originalState sampleStream mismatch |	originalState := aMatcher currentState.	sampleStream := self sampleStream.	mismatch := false.	[sampleStream atEnd		or: [aMatcher atEnd		or: [mismatch := (compare value: sampleStream next value: aMatcher next) not]]] whileFalse.	(mismatch not and: [sampleStream atEnd and: [next matchAgainst: aMatcher]])		ifTrue: [^true]		ifFalse: 			[aMatcher restoreState: originalState.			^false]</body></methods><methods><class-id>RxmSubstring</class-id> <category>private</category><body package="Regex11">sampleStream	^sample readStream</body></methods><methods><class-id>RxmSubstring</class-id> <category>initialize-release</category><body package="Regex11">beCaseInsensitive	compare := [:char1 :char2 | char1 sameAs: char2]</body><body package="Regex11">beCaseSensitive	compare := [:char1 :char2 | char1 = char2]</body><body package="Regex11">character: aCharacter ignoreCase: aBoolean	"Match exactly this character."	sample := String with: aCharacter.	aBoolean ifTrue: [self beCaseInsensitive]</body><body package="Regex11">initialize	super initialize.	self beCaseSensitive</body><body package="Regex11">substring: aString ignoreCase: aBoolean	"Match exactly this string."	sample := aString.	aBoolean ifTrue: [self beCaseInsensitive]</body></methods><methods><class-id>RxsRegex</class-id> <category>accessing</category><body package="Regex11">branch	^branch</body><body package="Regex11">dispatchTo: aMatcher	"Inform the matcher of the kind of the node, and it	will do whatever it has to."	^aMatcher syntaxRegex: self</body><body package="Regex11">regex	^regex</body></methods><methods><class-id>RxsRegex</class-id> <category>testing</category><body package="Regex11">isNullable	^branch isNullable or: [regex notNil and: [regex isNullable]]</body></methods><methods><class-id>RxsRegex</class-id> <category>initialize-release</category><body package="Regex11">initializeBranch: aBranch regex: aRegex	"See class comment for instance variable description."	branch := aBranch.	regex := aRegex</body></methods><methods><class-id>RxMatchOptimizer</class-id> <category>double dispatch</category><body package="Regex11">syntaxAny	"Any special char is among the prefixes."	conditions add: #any</body><body package="Regex11">syntaxBeginningOfLine	"Beginning of line is among the prefixes."	conditions add: #atBeginningOfLine</body><body package="Regex11">syntaxBeginningOfWord	"Beginning of line is among the prefixes."	conditions add: #atBeginningOfWord</body><body package="Regex11">syntaxBranch: branchNode	"If the head piece of the branch is transparent (allows 0 matches),	we must recurse down the branch. Otherwise, just the head atom	is important."	(branchNode piece isNullable and: [branchNode branch notNil])		ifTrue: [branchNode branch dispatchTo: self].	branchNode piece dispatchTo: self</body><body package="Regex11">syntaxCharSet: charSetNode 	"All these (or none of these) characters is the prefix."	charSetNode isNegated		ifTrue: [nonPrefixes addAll: (charSetNode enumerableSetIgnoringCase: ignoreCase)]		ifFalse: [prefixes addAll: (charSetNode enumerableSetIgnoringCase: ignoreCase)].	charSetNode hasPredicates ifTrue: 			[charSetNode isNegated				ifTrue: [nonPredicates addAll: charSetNode predicates]				ifFalse: [predicates addAll: charSetNode predicates]]</body><body package="Regex11">syntaxCharacter: charNode	"This character is the prefix, of one of them."	prefixes add: charNode character</body><body package="Regex11">syntaxEndOfLine	"Beginning of line is among the prefixes."	conditions add: #atEndOfLine</body><body package="Regex11">syntaxEndOfWord	conditions add: #atEndOfWord</body><body package="Regex11">syntaxEpsilon	"Empty string, terminate the recursion (do nothing)."</body><body package="Regex11">syntaxMessagePredicate: messagePredicateNode 	messagePredicateNode negated		ifTrue: [nonMethodPredicates add: messagePredicateNode selector]		ifFalse: [methodPredicates add: messagePredicateNode selector]</body><body package="Regex11">syntaxNonWordBoundary	conditions add: #notAtWordBoundary</body><body package="Regex11">syntaxPiece: pieceNode	"Pass on to the atom."	pieceNode atom dispatchTo: self</body><body package="Regex11">syntaxPredicate: predicateNode 	predicates add: predicateNode predicate</body><body package="Regex11">syntaxRegex: regexNode	"All prefixes of the regex's branches should be combined.	Therefore, just recurse."	regexNode branch dispatchTo: self.	regexNode regex notNil		ifTrue: [regexNode regex dispatchTo: self]</body><body package="Regex11">syntaxWordBoundary	conditions add: #atWordBoundary</body></methods><methods><class-id>RxMatchOptimizer</class-id> <category>accessing</category><body package="Regex11">canStartMatch: aCharacter in: aMatcher 	"Answer whether a match could commence at the given lookahead	character, or in the current state of &lt;aMatcher&gt;. True answered	by this method does not mean a match will definitly occur, while false	answered by this method *does* guarantee a match will never occur."	aCharacter isNil ifTrue: [^true].	^testBlock == nil or: [testBlock value: aCharacter value: aMatcher]</body><body package="Regex11">conditionTester	"#any condition is filtered at the higher level;	it cannot appear among the conditions here."	| matchCondition |	conditions isEmpty ifTrue: [^nil].	conditions size = 1 ifTrue:		[matchCondition := conditions detect: [:ignored | true].		"Special case all of the possible conditions."		#atBeginningOfLine = matchCondition ifTrue: [^[:c :matcher | matcher atBeginningOfLine]].		#atEndOfLine = matchCondition ifTrue: [^[:c :matcher | matcher atEndOfLine]].		#atBeginningOfWord = matchCondition ifTrue: [^[:c :matcher | matcher atBeginningOfWord]].		#atEndOfWord = matchCondition ifTrue: [^[:c :matcher | matcher atEndOfWord]].		#atWordBoundary = matchCondition ifTrue: [^[:c :matcher | matcher atWordBoundary]].		#notAtWordBoundary = matchCondition ifTrue: [^[:c :matcher | matcher notAtWordBoundary]].		RxParser signalCompilationException: 'invalid match condition'].	"More than one condition. Capture them as an array in scope."	matchCondition := conditions asArray.	^[:c :matcher |		matchCondition anySatisfy:			[:conditionSelector |			matcher perform: conditionSelector]]</body><body package="Regex11">methodPredicateTester	| p selector |	methodPredicates isEmpty ifTrue: [^nil].	p := self optimizeSet: methodPredicates.	"also allows copying closures"	^p size = 1		ifTrue: 			["might be a pretty common case"			selector := p first.			[:char :matcher | 			RxParser doHandlingMessageNotUnderstood:				[char perform: selector]]]		ifFalse: 			[[:char :m | 			RxParser doHandlingMessageNotUnderstood:				[p anySatisfy: [:sel | char perform: sel]]]]</body><body package="Regex11">nonMethodPredicateTester	| p selector |	nonMethodPredicates isEmpty ifTrue: [^nil].	p := self optimizeSet: nonMethodPredicates.	"also allows copying closures"	^p size = 1		ifTrue: 			[selector := p first.			[:char :matcher | 			RxParser doHandlingMessageNotUnderstood:				[(char perform: selector) not]]]		ifFalse: 			[[:char :m | 			RxParser doHandlingMessageNotUnderstood:				[p anySatisfy: [:sel | (char perform: sel) not]]]]</body></methods><methods><class-id>RxMatchOptimizer</class-id> <category>private</category><body package="Regex11">determineTestMethod	"Answer a block closure that will work as a can-match predicate.	Answer nil if no viable optimization is possible (too many chars would	be able to start a match)."	| testers |	(conditions includes: #any) ifTrue: [^nil].	testers := OrderedCollection new: 5.	#(#prefixTester #nonPrefixTester #conditionTester #methodPredicateTester #nonMethodPredicateTester #predicateTester #nonPredicateTester)		do: 			[:selector | 			| tester |			tester := self perform: selector.			tester notNil ifTrue: [testers add: tester]].	testers isEmpty ifTrue: [^nil].	testers size = 1 ifTrue: [^testers first].	testers := testers asArray.	^[:char :matcher | testers anySatisfy: [:t | t value: char value: matcher]]</body><body package="Regex11">nonPredicateTester	| p pred |	nonPredicates isEmpty ifTrue: [^nil].	p := self optimizeSet: nonPredicates.	"also allows copying closures"	^p size = 1		ifTrue: 			[pred := p first.			[:char :matcher | (pred value: char) not]]		ifFalse: 			[[:char :m | p anySatisfy: [:some | (some value: char) not]]]</body><body package="Regex11">nonPrefixTester	| np nonPrefixChar |	nonPrefixes isEmpty ifTrue: [^nil].	np := self optimizeSet: nonPrefixes. "also allows copying closures"	^np size = 1 "might be be pretty common case"		ifTrue: 			[nonPrefixChar := np first.			[:char :matcher | char ~= nonPrefixChar]]		ifFalse: [[:char : matcher | (np includes: char) not]]</body><body package="Regex11">optimizeSet: aSet	"If a set is small, convert it to array to speed up lookup	(Array has no hashing overhead, beats Set on small number	of elements)."	^aSet size &lt; 10 ifTrue: [aSet asArray] ifFalse: [aSet]</body><body package="Regex11">predicateTester	| p pred |	predicates isEmpty ifTrue: [^nil].	p := self optimizeSet: predicates.	"also allows copying closures"	^p size = 1		ifTrue: 			[pred := p first.			[:char :matcher | pred value: char]]		ifFalse: 			[[:char :m | p anySatisfy: [:some | some value: char]]]</body><body package="Regex11">prefixTester	| p prefixChar |	prefixes isEmpty ifTrue: [^nil].	p := self optimizeSet: prefixes. "also allows copying closures"	ignoreCase ifTrue: [p := p collect: [:each | each asUppercase]].	^p size = 1 "might be a pretty common case"		ifTrue: 			[prefixChar := p first.			ignoreCase				ifTrue: [[:char :matcher | char sameAs: prefixChar]]				ifFalse: [[:char :matcher | char = prefixChar]]]		ifFalse:			[ignoreCase				ifTrue: [[:char :matcher | p includes: char asUppercase]]				ifFalse: [[:char :matcher | p includes: char]]]</body></methods><methods><class-id>RxMatchOptimizer</class-id> <category>initialize-release</category><body package="Regex11">initialize: aRegex ignoreCase: aBoolean 	"Set `testMethod' variable to a can-match predicate block:	two-argument block which accepts a lookahead character	and a matcher (presumably built from aRegex) and answers 	a boolean indicating whether a match could start at the given	lookahead. "	ignoreCase := aBoolean.	prefixes := Set new: 10.	nonPrefixes := Set new: 10.	conditions := Set new: 3.	methodPredicates := Set new: 3.	nonMethodPredicates := Set new: 3.	predicates := Set new: 3.	nonPredicates := Set new: 3.	aRegex dispatchTo: self.	"If the whole expression is nullable, 		end-of-line is an implicit can-match condition!"	aRegex isNullable ifTrue: [conditions add: #atEndOfLine].	testBlock := self determineTestMethod</body></methods><methods><class-id>RxsRange</class-id> <category>testing</category><body package="Regex11">isEnumerable	^true</body></methods><methods><class-id>RxsRange</class-id> <category>initialize-release</category><body package="Regex11">initializeFirst: aCharacter last: anotherCharacter	first := aCharacter.	last := anotherCharacter</body></methods><methods><class-id>RxsRange</class-id> <category>accessing</category><body package="Regex11">enumerateTo: aSet ignoringCase: aBoolean	"Add all of the elements I represent to the collection."	first asInteger to: last asInteger do:		[:charCode | | character |		character := charCode asCharacter.		aBoolean		ifTrue: 			[aSet 				add: character asUppercase;				add: character asLowercase]		ifFalse: [aSet add: character]]</body></methods><methods><class-id>RxsRange class</class-id> <category>instance creation</category><body package="Regex11">from: aCharacter to: anotherCharacter	^self new initializeFirst: aCharacter last: anotherCharacter</body></methods><methods><class-id>RxsPiece</class-id> <category>testing</category><body package="Regex11">isAtomic	"A piece is atomic if only it contains exactly one atom	which is atomic (sic)."	^self isSingular and: [atom isAtomic]</body><body package="Regex11">isNullable	"A piece is nullable if it allows 0 matches. 	This is often handy to know for optimization."	^min = 0 or: [atom isNullable]</body><body package="Regex11">isOptional	^min = 0 and: [max = 1]</body><body package="Regex11">isPlus	^min = 1 and: [max == nil]</body><body package="Regex11">isSingular	"A piece with a range is 1 to 1 needs can be compiled	as a simple match."	^min = 1 and: [max = 1]</body><body package="Regex11">isStar	^min = 0 and: [max == nil]</body></methods><methods><class-id>RxsPiece</class-id> <category>accessing</category><body package="Regex11">atom	^atom</body><body package="Regex11">character	"If this node is atomic, answer the character it	represents. It is the caller's responsibility to make sure this	node is indeed atomic before using this."	^atom character</body><body package="Regex11">dispatchTo: aMatcher	"Inform the matcher of the kind of the node, and it	will do whatever it has to."	^aMatcher syntaxPiece: self</body><body package="Regex11">max	"The value answered may be nil, indicating infinity."	^max</body><body package="Regex11">min	^min</body></methods><methods><class-id>RxsPiece</class-id> <category>initialize-release</category><body package="Regex11">initializeAtom: anAtom	"This piece is exactly one occurrence of the specified RxsAtom."	self initializeAtom: anAtom min: 1 max: 1</body><body package="Regex11">initializeAtom: anAtom min: minOccurrences max: maxOccurrences	"This piece is from &lt;minOccurrences&gt; to &lt;maxOccurrences&gt; 	occurrences of the specified RxsAtom."	atom := anAtom.	min := minOccurrences.	max := maxOccurrences</body><body package="Regex11">initializeOptionalAtom: anAtom	"This piece is 0 or 1 occurrences of the specified RxsAtom."	self initializeAtom: anAtom min: 0 max: 1</body><body package="Regex11">initializePlusAtom: anAtom	"This piece is one or more occurrences of the specified RxsAtom."	self initializeAtom: anAtom min: 1 max: nil</body><body package="Regex11">initializeStarAtom: anAtom	"This piece is any number of occurrences of the atom."	self initializeAtom: anAtom min: 0 max: nil</body></methods><methods><class-id>RxParser</class-id> <category>private</category><body package="Regex11">characterSetFrom: setSpec	"&lt;setSpec&gt; is what goes between the brackets in a charset regex	(a String). Make a string containing all characters the spec specifies.	Spec is never empty."	| negated spec |	spec := ReadStream on: setSpec.	spec peek == $^		ifTrue: 	[negated := true.				spec next]		ifFalse:	[negated := false].	^RxsCharSet new		initializeElements: (RxCharSetParser on: spec) parse		negated: negated</body><body package="Regex11">ifSpecial: aCharacter then: aBlock	"If the character is such that it defines a special node when follows a $\,	then create that node and evaluate aBlock with the node as the parameter.	Otherwise just return."	| classAndSelector |	classAndSelector := BackslashSpecials at: aCharacter ifAbsent: [^self].	^aBlock value: (classAndSelector key new perform: classAndSelector value)</body><body package="Regex11">inputUpTo: aCharacter errorMessage: aString	"Accumulate input stream until &lt;aCharacter&gt; is encountered	and answer the accumulated chars as String, not including	&lt;aCharacter&gt;. Signal error if end of stream is encountered,	passing &lt;aString&gt; as the error description."	| accumulator |	accumulator := WriteStream on: (String new: 20).	[lookahead ~= aCharacter and: [lookahead ~= #epsilon]]		whileTrue:			[accumulator nextPut: lookahead.			self next].	lookahead = #epsilon ifTrue: [self signalParseError: aString].	^accumulator contents</body><body package="Regex11">inputUpTo: aCharacter nestedOn: anotherCharacter errorMessage: aString 	"Accumulate input stream until &lt;aCharacter&gt; is encountered	and answer the accumulated chars as String, not including	&lt;aCharacter&gt;. Signal error if end of stream is encountered,	passing &lt;aString&gt; as the error description."	| accumulator nestLevel |	accumulator := WriteStream on: (String new: 20).	nestLevel := 0.	[lookahead ~= aCharacter or: [nestLevel &gt; 0]] whileTrue: 			[#epsilon = lookahead ifTrue: [self signalParseError: aString].			accumulator nextPut: lookahead.			lookahead = anotherCharacter ifTrue: [nestLevel := nestLevel + 1].			lookahead = aCharacter ifTrue: [nestLevel := nestLevel - 1].			self next].	^accumulator contents</body><body package="Regex11">match: aCharacter	"&lt;aCharacter&gt; MUST match the current lookeahead.	If this is the case, advance the input. Otherwise, blow up."	aCharacter ~= lookahead 		ifTrue: [^self signalParseError].	"does not return"	self next</body><body package="Regex11">next	"Advance the input storing the just read character	as the lookahead."	input atEnd		ifTrue: [lookahead := #epsilon]		ifFalse: [lookahead := input next]</body><body package="Regex11">repetitionsFrom: aString	| aStream  |	aStream := ReadStream on: aString.	^RxsRepetitions new		initializeRepetitions: (RxRepetitionsParser on: aStream) parse</body><body package="Regex11">signalParseError	self class signalSyntaxException: 'Regex syntax error'</body><body package="Regex11">signalParseError: aString	self class signalSyntaxException: aString</body></methods><methods><class-id>RxParser</class-id> <category>accessing</category><body package="Regex11">parse: aString	"Parse input from a string &lt;aString&gt;.	On success, answers an RxsRegex -- parse tree root.	On error, raises `RxParser syntaxErrorSignal' with the current	input stream position as the parameter."	^self parseStream: (ReadStream on: aString)</body><body package="Regex11">parseStream: aStream	"Parse an input from a character stream &lt;aStream&gt;.	On success, answers an RxsRegex -- parse tree root.	On error, raises `RxParser syntaxErrorSignal' with the current	input stream position as the parameter."	| tree |	input := aStream.	lookahead := nil.	self match: nil.	tree := self regex.	self match: #epsilon.	^tree</body></methods><methods><class-id>RxParser</class-id> <category>recursive descent</category><body package="Regex11">atom	"An atom is one of a lot of possibilities, see below."	| atom |	(lookahead == #epsilon or: 			[lookahead == $| or: 					[lookahead == $)						or: [lookahead == $* or: [lookahead == $+ or: [lookahead == $?]]]]])		ifTrue: [^RxsEpsilon new].	lookahead == $( ifTrue: 			["&lt;atom&gt; ::= '(' &lt;regex&gt; ')' "			self match: $(.			atom := self regex.			self match: $).			^atom].	lookahead == $[ ifTrue: 			["&lt;atom&gt; ::= '[' &lt;characterSet&gt; ']' "			self match: $[.			atom := self characterSet.			self match: $].			^atom].	lookahead == $: ifTrue: 			["&lt;atom&gt; ::= ':' &lt;messagePredicate&gt; ':' "			self match: $:.			atom := self messagePredicate.			self match: $:.			^atom].	lookahead == $. ifTrue: 			["any non-whitespace character"			self next.			^RxsContextCondition new beAny].	lookahead == $^ ifTrue: 			["beginning of line condition"			self next.			^RxsContextCondition new beBeginningOfLine].	lookahead = $$ ifTrue: 			["end of line condition"			self next.			^RxsContextCondition new beEndOfLine].	lookahead == $\ ifTrue: 			["&lt;atom&gt; ::= '\' &lt;character&gt;"			self next.			lookahead == #epsilon ifTrue: 				[self signalParseError: 'bad quotation'].			(BackslashConstants includesKey: lookahead) ifTrue:				[atom := RxsCharacter with: (BackslashConstants at: lookahead).				self next.				^atom].			self ifSpecial: lookahead				then: [:node | self next. ^node]].	"If passed through the above, the following is a regular character."	atom := RxsCharacter with: lookahead.	self next.	^atom</body><body package="Regex11">branch	"&lt;branch&gt; ::= e | ?:' &lt;piece&gt; &lt;branch&gt; | &lt;piece&gt; &lt;branch&gt;"	| piece branch captureEnabled |	captureEnabled := true.	(lookahead == $? and: [input peek == $:])		ifTrue: 			[captureEnabled := false.			self				match: $?;				match: $:].	piece := self piece.	(lookahead == #epsilon or: [lookahead == $| or: [lookahead == $)]])		ifTrue: [branch := nil]		ifFalse: [branch := self branch].	^(RxsBranch new initializePiece: piece branch: branch)		captureEnabled: captureEnabled;		yourself</body><body package="Regex11">characterSet	"Match a range of characters: something between `[' and `]'.	Opening bracked has already been seen, and closing should	not be consumed as well. Set spec is as usual for	sets in regexes."	| spec errorMessage |	errorMessage := ' no terminating "]"'.	spec := self inputUpTo: $] nestedOn: $[ errorMessage: errorMessage.	(spec isEmpty or: [spec = '^']) ifTrue: "This ']' was literal."		[self next.		spec := spec, ']', (self inputUpTo: $] nestedOn: $[ errorMessage: errorMessage)].	^self characterSetFrom: spec</body><body package="Regex11">messagePredicate	"Match a message predicate specification: a selector (presumably	understood by a Character) enclosed in :'s ."	| spec negated |	spec := (self inputUpTo: $: errorMessage: ' no terminating ":"').	negated := false.	spec first == $^ ifTrue:		[negated := true.		spec := spec copyFrom: 2 to: spec size].	^RxsMessagePredicate new 		initializeSelector: spec asSymbol		negated: negated</body><body package="Regex11">piece	"&lt;piece&gt; ::= &lt;atom&gt; | &lt;atom&gt;* | &lt;atom&gt;+ | &lt;atom&gt;? | &lt;atom&gt;{&lt;repeats&gt;}"	| atom errorMessage repetitions |	errorMessage := ' nullable closure'.	atom := self atom.	lookahead == $* ifTrue: 		[self next.		atom isNullable ifTrue: [self signalParseError: errorMessage].		^RxsPiece new initializeStarAtom: atom].	lookahead == $+ ifTrue: 		[self next.		atom isNullable ifTrue: [self signalParseError: errorMessage].		^RxsPiece new initializePlusAtom: atom].	lookahead == $? ifTrue: 		[self next.		atom isNullable ifTrue: [self signalParseError: errorMessage].		^RxsPiece new initializeOptionalAtom: atom].	lookahead == ${		ifTrue: 			[self match: ${.			repetitions := self repetitions.			self match: $}.			^RxsPiece new				initializeAtom: atom				min: repetitions min				max: repetitions max].	^RxsPiece new initializeAtom: atom</body><body package="Regex11">regex	"&lt;regex&gt; ::= e | &lt;branch&gt; `|' &lt;regex&gt;"	| branch regex |	branch := self branch.	(lookahead = #epsilon or: [lookahead = $)])		ifTrue: [regex := nil]		ifFalse: 			[self match: $|.			regex := self regex].	^RxsRegex new initializeBranch: branch regex: regex</body><body package="Regex11">repetitions	"&lt;repeats&gt; ::= &lt;integer&gt; | &lt;integer&gt;,&lt;integer&gt;	Match a range of characters: something between `{' and `}'.	Opening bracked has already been seen, and closing should	not be consumed as well. Repeat spec is as usual for	repeats in regexes.	"	| spec errorMessage |	errorMessage := ' no terminating "}"'.	spec := self inputUpTo: $} nestedOn: ${ errorMessage: errorMessage.	^self repetitionsFrom: spec</body></methods><methods><class-id>RxParser class</class-id> <category>utilities</category><body package="Regex11">metacharacters	"Returns the characters that require or may require escaping with a backslash to be used as a literal.	See RxParser&gt;&gt;atom and piece. For other uses of backslash, see BackslashConstants and BackslashSpecials"	^'^$\()*+.?[{|:'</body><body package="Regex11">parse: aString	"Parse the argument and return the result (the parse tree).	In case of a syntax error, the corresponding exception is signaled."	^self new parse: aString</body><body package="Regex11">safelyParse: aString	"Parse the argument and return the result (the parse tree).	In case of a syntax error, return nil.	Exception handling here is dialect-dependent."	^self syntaxErrorSignal		handle: [:ex | ex returnWith: nil]		do: [self new parse: aString]</body></methods><methods><class-id>RxParser class</class-id> <category>Signal constants</category><body package="Regex11">compilationErrorSignal	"Raised by the specific matcher's builder if an error is	encountered while building.."	^ExceptionObjects at: #compilationErrorSignal</body><body package="Regex11">initializeExceptions	"self initializeExceptions"	| parentSignal |	ExceptionObjects := (Dictionary new: 4).	ExceptionObjects		at: #regexErrorSignal		put: (parentSignal := Object errorSignal newSignal			notifierString: 'Regex error - ';			nameClass: self message: #regexErrorSignal);		at: #syntaxErrorSignal		put: (parentSignal newSignal			notifierString: 'Regex syntax error - ';			nameClass: self message: #syntaxErrorSignal);		at: #compilationErrorSignal		put: (parentSignal newSignal			notifierString: 'Regex compilation error - ';			nameClass: self message: #compilationErrorSignal);		at: #matchErrorSignal		put: (parentSignal newSignal			notifierString: 'Regex matching error - ';			nameClass: self message: #matchErrorSignal)</body><body package="Regex11">matchErrorSignal	"To signal errors encountered while matching."	^ExceptionObjects at: #matchErrorSignal</body><body package="Regex11">regexErrorSignal	"Parent of the other three signals, to catch them all if needed."	^ExceptionObjects at: #regexErrorSignal</body><body package="Regex11">syntaxErrorSignal	"Raised within the recursive descent when a syntax error	is encountered."	^ExceptionObjects at: #syntaxErrorSignal</body></methods><methods><class-id>RxParser class</class-id> <category>test suite</category><body package="Regex11">assert: aBoolean	aBoolean ifFalse: [self error: 'assertion failed'].</body><body package="Regex11">compileRegex: regexSource into: matcherClass	"Compile the regex and answer the matcher, or answer nil if compilation fails."	| syntaxTree |	syntaxTree := self safelyParse: regexSource.	syntaxTree == nil ifTrue: [^nil].	^matcherClass for: syntaxTree</body><body package="Regex11">deny: aBoolean	aBoolean ifTrue: [self error: 'assertion failed'].</body><body package="Regex11">log: aBlock	LoggingEnabled ifTrue: [aBlock value]</body><body package="Regex11">runProtocolTestsForCharacterArray	"Run basic tests to make sure that CharacterArray implements the desired protocol of regex-related messages"	| result |	self log: [Transcript show: 'Testing CharacterArray protocol...'].	('ba*c' asRegex matches: 'baaac')		ifFalse: [self error: 'CharacterArray asRegex test failed'].	('ba*c' asRegexIgnoringCase matches: 'BaAaAc')		ifFalse: [self error: 'CharacterArray asRegexIgnoringCase test failed'].	('baaac678bc' allRangesOfRegexMatches: 'ba*c') asArray = (Array with: (1 to: 5) with: (9 to: 10))		ifFalse: [self error: 'CharacterArray allRangesOfRegexMatches: test failed'].	('baaac678bc' allRegexMatches: 'ba*c') asArray = #('baaac' 'bc')		ifFalse: [self error: 'CharacterArray allRegexMatches: test failed'].	('baaac678bc' copyWithRegex: 'ba*c' matchesReplacedWith: 'MATCH') = 'MATCH678MATCH'		ifFalse: [self error: 'CharacterArray copyWithRegex:matchesReplacedWith: test failed'].	('baaac678bc' copyWithRegex: 'ba*c' matchesTranslatedUsing: [:m | m asUppercase]) = 'BAAAC678BC'		ifFalse: [self error: 'CharacterArray copyWithRegex:matchesTranslatedUsing: test failed'].	('baaac' matchesRegex: 'ba*c')		ifFalse: [self error: 'CharacterArray matchesRegex: test failed'].	('BaAaAc' matchesRegexIgnoringCase: 'ba*c')		ifFalse: [self error: 'CharacterArray matchesRegexIgnoringCase: test failed'].	('baaac678bc' prefixMatchesRegex: 'ba*c')		ifFalse: [self error: 'CharacterArray prefixMatchesRegex: test failed'].	('BaAaAc678bc' prefixMatchesRegexIgnoringCase: 'ba*c')		ifFalse: [self error: 'CharacterArray prefixMatchesRegexIgnoringCase: test failed'].	('baaac678bc' regex: 'ba*c' matchesCollect: [:m | m asUppercase]) asArray =  #('BAAAC' 'BC')		ifFalse: [self error: 'CharacterArray regex:matchesCollect: test failed'].	result := OrderedCollection new.	'baaac678bc' regex: 'ba*c' matchesDo: [:m | result addFirst: m asUppercase].	result asArray =  #('BC' 'BAAAC')		ifFalse: [self error: 'CharacterArray regex:matchesDo: test failed'].	('James Bond' replaceRegex: '(\w+) (\w+)' withString: '\2, \1 \2') = 'Bond, James Bond'		ifFalse: [self error: 'CharacterArray replaceRegex:withString: test failed'].	self log: [Transcript show: 'OK'; cr]</body><body package="Regex11">runProtocolTestsForMatcher: matcherClass	| matcher |	self log: [Transcript show: 'Testing matcher protocol...'].	matcher := matcherClass forString: '\w+'.	(matcher matchesIn: 'now is the time') asArray = #('now' 'is' 'the' 'time')		ifFalse: [self error: 'matchesIn: test failed'].	(matcher copy: 'now is  the   time    ' translatingMatchesUsing: [:s | s reverse])		= 'won si  eht   emit    '		ifFalse: [self error: 'copy:translatingMatchesWith: test failed'].	"See that the match context is preserved while copying stuff between matches:"	((matcherClass forString: '\&lt;\d\D+') 		copy: '9aaa1bbb 8ccc'		replacingMatchesWith: 'foo') = 'foo1bbb foo'			ifFalse: [self error: 'test failed'].	self log: [Transcript show: 'OK'; cr]</body><body package="Regex11">runRegexTestsForMatcher: matcherClass	"Run the whole suite of tests for the given matcher class. May blow up	if anything goes wrong with the matcher or parser. Since this is a 	developer's tool, who cares?"	"self runRegexTestsForMatcher: RxMatcher"	self runRegexTestsForMatcher: matcherClass suite: self testSuiteLong</body><body package="Regex11">runRegexTestsForMatcher: matcherClass suite: aCollection	"Run the whole suite of tests for the given matcher class. May blow up	if anything goes wrong with the matcher or parser. Since this is a 	developer's tool, who cares?"	"self runRegexTestsForMatcher: RxMatcher"	| failures |	failures := OrderedCollection new.	self log: [Transcript cr].	aCollection do: 			[:clause |			| rxSource matcher isOK |			rxSource := clause first.			self log: 					[Transcript						show: 'Testing regex: ';						show: rxSource printString;						cr].			matcher := self compileRegex: rxSource into: matcherClass.			matcher == nil				ifTrue: 					[(clause at: 2) isNil						ifTrue: 							[self log: 									[Transcript										tab;										show: 'Compilation error as expected (ok)';										cr]]						ifFalse: 							[self log: 									[Transcript										tab;										show: 'Compilation error, UNEXPECTED -- FAILED';										cr].							failures add: clause]]				ifFalse: 					[(clause at: 2) == nil						ifTrue: 							[self log: 									[Transcript										tab;										show: 'Compilation succeeded, should have failed -- FAILED!';										cr].							failures add: clause]						ifFalse: 							[2 to: clause size								by: 3								do: 									[:i |									isOK := self												test: matcher												with: (clause at: i)												expect: (clause at: i + 1)												withSubexpressions: (clause at: i + 2).									isOK ifFalse: [failures add: clause].									self log: 											[Transcript												show: (isOK ifTrue: [' (ok).'] ifFalse: [' -- FAILED!']);												cr]]]]].	failures isEmpty		ifTrue: 			[self log: 					[Transcript						show: 'PASSED ALL TESTS.';						cr].			self clearFailures]		ifFalse: 			[| errorString |			errorString := failures size printString , ' TESTS FAILED!'.			self log: 					[Transcript						show: errorString;						cr].			self saveFailures: failures for: matcherClass.			self error: errorString].	self handleFailures: failures for: matcherClass</body><body package="Regex11">runRepeatTestsForMatcher: matcherClass	"Tests that are not possible using the test suite mechanics"	self log: [Transcript show: 'Testing matcher protocol with repeats...'].	self deny: ((matcherClass forString: 'a{0,1}') matches: 'aa').	self deny: ((matcherClass forString: 'a{2}') matches: 'aaa').	self deny: ((matcherClass forString: 'a{2}bc{3}') matches: 'aaabccc').	self deny: ((matcherClass forString: 'a{2}bc{3}') matches: 'aabcccc').	self deny: ((matcherClass forString: '[a-z]{2}') matches: 'kpw').	self deny: ((matcherClass forString: 'a{2,5}') matches: 'aaaaaa').	self deny: ((matcherClass forString: 'a{2,5}b{2,5}z') matches: 'aaaaaabbz').	self assert: ((matcherClass forString: 'a{0,2}') matches: 'a').	self assert: ((matcherClass forString: 'a{,2}') matches: 'a').	self deny: ((matcherClass forString: 'a{0,2}') matches: 'aaa').	self deny: ((matcherClass forString: 'a{,2}') matches: 'aaa').	self deny: ((matcherClass forString: 'xa{,2}') matches: 'xaaa').	self assert: ((matcherClass forString: 'xa{,2}') matches: 'xa').	self assert: ((matcherClass forString: 'xa{,2}z') matches: 'xaz').	self deny: ((matcherClass forString: 'a{,2}z') matches: 'aaaz').	self log: [Transcript show: 'OK'; cr]</body><body package="Regex11">runTestsForMatcher: matcherClass	"Run the whole suite of tests for the given matcher class. May blow up	if something goes wrong with the matcher or the parser. Since this is a 	developer's tool, who cares? With LoggingEnabled true (the default),	each test's result is logged to the Transcript, which takes about 10	seconds. With LoggingEnabled false, the tests run 1000 times faster"	"LoggingEnabled := false.	Time microsecondsToRun: [self runTestsForMatcher: RxMatcher]"	self		runRegexTestsForMatcher: matcherClass;		runProtocolTestsForMatcher: matcherClass;		runRepeatTestsForMatcher: matcherClass;		runProtocolTestsForCharacterArray</body><body package="Regex11">test: aMatcher with: testString expect: expected withSubexpressions: subexpr	| copy got |	self log: 			[Transcript				tab;				show: 'Matching: ';				show: testString printString].	copy := aMatcher copy: testString translatingMatchesUsing: [:s | s].	copy ~= testString		ifTrue: 			[self log: [Transcript show: ' (copy failed: "' , copy , '")'].			^false].	self log: 			[Transcript				show: ' expected: ';				show: expected printString;				show: ' got: '].	got := aMatcher search: testString.	self log: [Transcript show: got printString].	got ~= expected ifTrue: [^false].	(subexpr notNil and: [aMatcher supportsSubexpressions])		ifFalse: [^true]		ifTrue: 			[| isOK |			isOK := true.			1 to: subexpr size				by: 2				do: 					[:i |					| sub subExpect subGot |					sub := subexpr at: i.					subExpect := subexpr at: i + 1.					subGot := sub &gt; aMatcher subexpressionCount								ifTrue: [#void]								ifFalse: 									[(subExpect isNil or: [subExpect isString])										ifTrue: [aMatcher subexpression: sub]										ifFalse: [aMatcher subexpressions: sub]].					self log: 							[Transcript								cr;								tab;								tab;								show: 'Subexpression: ' , sub printString;								show: ' expected: ';								show: subExpect printString;								show: ' got: ';								show: subGot printString].					subExpect ~= subGot						ifTrue: 							[self log: [Transcript show: ' -- MISMATCH'].							isOK := false]].			^isOK]</body><body package="Regex11">testSuite	"Answer an array of test clauses. Each clause is an array with a regex source	string followed by sequence of 3-tuples. Each three-element	group is one test to try against the regex, and includes: 1) test string;	2) expected result; 3) expected subexpression as an array of (index, substring), 	or nil.	The test suite is based on the one in Henry Spencer's regexp.c package."	^#(		('abc'			'abc' true (1 'abc')			'xbc' false nil			'axc' false nil			'abx' false nil			'xabcy' true (1 'abc')			'ababc' true (1 'abc'))		('ab*c'			'abc' true (1 'abc'))		('ab*bc'			'abc' true (1 'abc')			'abbc' true (1 'abbc')			'abbbbc' true (1 'abbbbc'))		('ab+bc'				'abbc' true (1 'abbc')			'abc' false nil			'abq' false nil			'abbbbc' true (1 'abbbbc'))		('ab?bc'			'abbc' true (1 'abbc')			'abc' true (1 'abc')			'abbbbc' false nil			'abc' true (1 'abc'))		('^abc$'			'abc' true (1 'abc')			'abcc' false nil			'aabc' false nil)		('^abc'			'abcc' true (1 'abc'))		('abc$'			'aabc' true (1 'abc'))		('^'			'abc' true nil)		('$'			'abc' true nil)		('a.c'			'abc' true (1 'abc')			'axc' true (1 'axc'))	"Need to get creative to include the null character..."	), (Array with: 		#('a.*c'				'axyzc' true (1 'axyzc')			'axy zc' true (1 'axy zc') "testing that a dot matches a space"			), (Array with: 'axy', (String with: 0 asCharacter), 'zc'), #(false nil "testing that a dot does not match a null"			'axyzd' false nil)	), #(		('.a.*'			'1234abc' true (1 '4abc')			'abcd' false nil)		('a\w+c'			' abbbbc ' true (1 'abbbbc')			'abb bc' false nil)		('\w+'			'  	foobar	quux' true (1 'foobar')			' 	~!@#$%^&amp;*()-+=\|/?.&gt;,&lt;' false nil)		('a\W+c'			'a   c' true (1 'a   c')			'a bc' false nil)		('\W+'			'foo!@#$bar' true (1 '!@#$')			'foobar' false nil)		('a\s*c'			'a   c' true (1 'a   c')			'a bc' false nil)		('\s+'			'abc3457 sd' true (1 ' ')			'1234$^*^&amp;asdfb' false nil)		('a\S*c'			'aqwertyc' true (1 'aqwertyc')			'ab c' false nil)		('\S+'			'     	asdf		' true (1 'asdf')			' 					' false nil)		('a\d+c'			'a0123456789c' true (1 'a0123456789c')			'a12b34c' false nil)		('\d+'			'foo@#$%123ASD #$$%^&amp;' true (1 '123')			'foo!@#$asdfl;' false nil)		('a\D+c'			'aqwertyc' true (1 'aqwertyc')			'aqw6ertc' false nil)		('\D+'			'1234 abc 456' true (1 ' abc ')			'1234567890' false nil)		('(f|o)+\b'			'foo' true (1 'foo')			' foo ' true (1 'foo'))		('\ba\w+' "a word beginning with an A"			'land ancient' true (1 'ancient')			'antique vase' true (1 'antique')			'goofy foobar' false nil)		('(f|o)+\B'			'quuxfoobar' true (1 'foo')			'quuxfoo ' true (1 'fo'))		('\Ba\w+' "a word with an A in the middle, match at A and further"			'land ancient' true (1 'and')			'antique vase' true (1 'ase')			'smalltalk shall overcome' true (1 'alltalk')			'foonix is better' false nil)		('fooa\&gt;.*'			'fooa ' true nil			'fooa123' false nil			'fooa bar' true nil			'fooa' true nil			'fooargh' false nil)		('\&gt;.+abc'			' abcde fg' false nil			'foo abcde' true (1 ' abc')			'abcde' false nil)		('\&lt;foo.*'			'foo' true nil			'foobar' true nil			'qfoobarq foonix' true (1 'foonix')			' foo' true nil			' 12foo' false nil			'barfoo' false nil)		('.+\&lt;foo'			'foo' false nil			'ab foo' true (1 'ab foo')			'abfoo' false nil)		('a[bc]d'			'abc' false nil			'abd' true (1 'abd'))		('a[b-d]e'			'abd' false nil			'ace' true (1 'ace'))		('a[b-d]'			'aac' true (1 'ac'))		('a[-b]'			'a-' true (1 'a-'))		('a[b-]'			'a-' true (1 'a-'))		('a[a-b-c]' nil)		('[k]'			'ab' false nil)		('a[b-a]' nil)		('a[]b' nil)		('a[' nil)		('a]' 			'a]' true (1 'a]'))		('a[]]b'			'a]b' true (1 'a]b'))		('a[^bc]d'			'aed' true (1 'aed')			'abd' false nil)		('a[^-b]c'			'adc' true (1 'adc')			'a-c' false nil)		('a[^]b]c'			'a]c' false nil			'adc' true (1 'adc'))		('[\de]+'			'01234' true (1 '01234')			'0123e456' true (1 '0123e456')			'0123e45g78' true (1 '0123e45'))		('[e\d]+' "reversal of the above, should be the same"			'01234' true (1 '01234')			'0123e456' true (1 '0123e456')			'0123e45g78' true (1 '0123e45'))		('[\D]+'			'123abc45def78' true (1 'abc'))		('[[:digit:]e]+'			'01234' true (1 '01234')			'0123e456' true (1 '0123e456')			'0123e45g78' true (1 '0123e45'))		('[\s]+'			'2  spaces' true (1 '  '))		('[\S]+'			'  word12!@#$  ' true (1 'word12!@#$'))		('[\w]+'			' 	foo123bar	45' true (1 'foo123bar'))		('[\W]+'			'fii234!@#$34f' true (1 '!@#$'))		('[^[:alnum:]]+'			'fii234!@#$34f' true (1 '!@#$'))		('[%&amp;[:alnum:]]+'			'foo%3' true (1 'foo%3')			'foo34&amp;rt4$57a' true (1 'foo34&amp;rt4')			'!@#$' false nil)		('[[:alpha:]]+'			' 123foo3 ' true (1 'foo')			'123foo' true (1 'foo')			'foo1b' true (1 'foo'))		('[[:cntrl:]]+'			' a 1234asdf' false nil)		('[[:lower:]]+'			'UPPERlower1234' true (1 'lower')			'lowerUPPER' true (1 'lower'))		('[[:upper:]]+'			'UPPERlower1234' true (1 'UPPER')			'lowerUPPER ' true (1 'UPPER'))		('[[:space:]]+'			'2  spaces' true (1 '  '))		('[^[:space:]]+'			'  word12!@#$  ' true (1 'word12!@#$'))		('[[:graph:]]+'			'abc' true (1 'abc'))		('[[:print:]]+'			'abc' true (1 'abc'))		('[^[:punct:]]+'			'!hello,world!' true (1 'hello'))		('[[:xdigit:]]+'			'  x10FCD  ' true (1 '10FCD')			' hgfedcba0123456789ABCDEFGH '				true (1 'fedcba0123456789ABCDEF'))		('ab|cd'			'abc' true (1 'ab')			'abcd' true (1 'ab'))		('()ef'			'def' true (1 'ef' 2 ''))		('()*' nil)		('*a' nil)		('^*' nil)		('$*' nil)		('(*)b' nil)		('$b'	'b' false nil)		('a\' nil)		('a\(b'			'a(b' true (1 'a(b'))		('a\(*b'			'ab' true (1 'ab')			'a((b' true (1 'a((b'))		('a\\b'			'a\b' true (1 'a\b'))		('abc)' nil)		('(abc' nil)		('((a))'			'abc' true (1 'a' 2 'a' 3 'a'))		('(a)b(c)'			'abc' true (1 'abc' 2 'a' 3 'c'))		('a+b+c'			'aabbabc' true (1 'abc'))		('a**' nil)		('a*?' nil)		('(a*)*' nil)		('(a*)+' nil)		('(a|)*' nil)		('(a*|b)*' nil)		('(a+|b)*'			'ab' true (1 'ab' 2 'b'))		('(a+|b)+'			'ab' true (1 'ab' 2 'b'))		('(a+|b)?'			'ab' true (1 'a' 2 'a'))		('[^ab]*'			'cde' true (1 'cde'))		('(^)*' nil)		('(ab|)*' nil)		(')(' nil)		('' 'abc' true (1 ''))		('abc' '' false nil)		('a*'			'' true '')		('abcd'			'abcd' true (1 'abcd'))		('a(bc)d'			'abcd' true (1 'abcd' 2 'bc'))		('([abc])*d'			'abbbcd' true (1 'abbbcd' 2 'c'))		('([abc])*bcd'			'abcd' true (1 'abcd' 2 'a'))		('a|b|c|d|e' 'e' true (1 'e'))		('(a|b|c|d|e)f' 'ef' true (1 'ef' 2 'e'))			"	((a*|b))*	-	c	-	-"		('abcd*efg' 'abcdefg' true (1 'abcdefg'))		('ab*' 			'xabyabbbz' true (1 'ab')			'xayabbbz' true (1 'a'))		('(ab|cd)e' 'abcde' true (1 'cde' 2 'cd'))		('[abhgefdc]ij' 'hij' true (1 'hij'))		('^(ab|cd)e' 'abcde' false nil)		('(abc|)def' 'abcdef' true nil)		('(a|b)c*d' 'abcd' true (1 'bcd' 2 'b'))		('(ab|ab*)bc' 'abc' true (1 'abc' 2 'a'))		('a([bc]*)c*' 'abc' true (1 'abc' 2 'bc'))		('a([bc]*)(c*d)' 'abcd' true (1 'abcd' 2 'bc' 3 'd'))		('a([bc]+)(c*d)' 'abcd' true (1 'abcd' 2 'bc' 3 'd'))		('a([bc]*)(c+d)' 'abcd' true (1 'abcd' 2 'b' 3 'cd'))		('a[bcd]*dcdcde' 'adcdcde' true (1 'adcdcde'))		('a[bcd]+dcdcde' 'adcdcde' false nil)		('(ab|a)b*c' 'abc' true (1 'abc'))		('((a)(b)c)(d)' 'abcd' true (1 'abcd' 3 'a' 4 'b' 5 'd'))		('[ -~]*' 'abc' true (1 'abc'))		('[ -~ -~]*' 'abc' true (1 'abc'))		('[ -~ -~ -~]*' 'abc' true (1 'abc'))		('[ -~ -~ -~ -~]*' 'abc' true (1 'abc'))		('[ -~ -~ -~ -~ -~]*' 'abc' true (1 'abc'))		('[ -~ -~ -~ -~ -~ -~]*' 'abc' true (1 'abc'))		('[ -~ -~ -~ -~ -~ -~ -~]*' 'abc' true (1 'abc'))		('[a-zA-Z_][a-zA-Z0-9_]*' 'alpha' true (1 'alpha'))		('^a(bc+|b[eh])g|.h$' 'abh' true (1 'bh' 2 nil))		('(bc+d$|ef*g.|h?i(j|k))' 			'effgz' true (1 'effgz' 2 'effgz' 3 nil)			'ij' true (1 'ij' 2 'ij' 3 'j')			'effg' false nil			'bcdd' false nil			'reffgz' true (1 'effgz' 2 'effgz' 3 nil))		('(((((((((a)))))))))' 'a' true (1 'a'))		('multiple words of text' 			'uh-uh' false nil			'multiple words of text, yeah' true (1 'multiple words of text'))		('(.*)c(.*)' 'abcde' true (1 'abcde' 2 'ab' 3 'de'))		('\((.*), (.*)\)' '(a, b)' true (2 'a' 3 'b')))	"Add your own tests here."	, #(		('^.*$' 			'' true (1 '')			'a' true (1 'a')			'abc' true (1 'abc'))		('a\w+c'			' abb_bbc ' true (1 'abb_bbc')			'abb-bc' false nil)		('a\W+c'			' abb_bbc ' false nil			'abb-bc' false nil			'a.,:;-&amp;!"#%/()={[]}+?\~*''c' true (1 'a.,:;-&amp;!"#%/()={[]}+?\~*''c'))	),	#(		('.*(ABC|B)'			'fooB' true (1 'fooB' 2 'B')			'fooABC' true (1 'fooABC' 2 'ABC' ))		('.*(ABCD|BC)'			'fooBC' true (1 'fooBC' 2 'BC')			'fooABCD' true (1 'fooABCD' 2 'ABCD'))	),	#( "mantis 0005391"		('[1-9]|1[0-9]'			'15' true (1 '15' )		)		('1[0-9]|[1-9]'			'15' true (1 '15' )		)	)"RxParser runTestsForMatcher: RxMatcher"</body><body package="Regex11">testSuiteCapturingGroups	"See explanations in #testSuite	When #void is used, the number of subexpressions is smaller than the number"	^#(		('a(b*)bc'			'abc' true (1 'abc' 99999 void)			'abc' true (1 'abc' 2 '')			'abbc' true (1 'abbc' 2 'b')			'abbbbc' true (1 'abbbbc' 2 'bbb'))  		('a((b)*)bc'			'abc' true (1 'abc' 2 '')			'abbc' true (1 'abbc' 2 'b')			'abbbbc' true (1 'abbbbc' 2 'bbb' 3 ('b' 'b' 'b')))		('a(?:b*)bc'			'abc' true (1 'abc' 2 void )			'abbc' true (1 'abbc' 2 void)			'abbbbc' true (1 'abbbbc' 2 void))  		('a(?:(b)*)bc'			'abc' true (1 'abc' 2 ())			'abbc' true (1 'abbc' 2 ('b') 3 void)			'abbbbc' true (1 'abbbbc' 2 ('b' 'b' 'b') 3 void))		('.*&lt;(?:DTP|TPX)=(.*)&gt;.*' 			'foo&lt;DTP=12345&gt;bar' true (2 '12345'))		('.*&lt;(DTP|TPX)=(?:.*)&gt;.*' 			'foo&lt;DTP=12345&gt;bar' true (2 'DTP'))	)</body><body package="Regex11">testSuiteLong	"If there are some failed tests, run them	otherwise run the full test suite	Full test suite can be forced though"	| fullTestSuiteForced |	fullTestSuiteForced := false.	(self testSuiteThatFails isEmpty or: [fullTestSuiteForced])		ifTrue: 			[^self testSuite , self testSuiteRepeatsEquivalence , self testSuiteRepeats				, self testSuiteCapturingGroups].	"	The list of failed tests should be enpty when publishing	"	Transcript		cr;		show: 'Running the failed tests, not the full test suite !!!'.	^self testSuiteThatFails</body><body package="Regex11">testSuiteRepeats	"See explanations in #testSuite"	^#(		('a{2}'			'aa' true (1 'aa' )			'a' false (1  nil)			'' false (1  nil)			'b' false (1  nil))		('a{2}bc{3}'			'aabccc' true (1 'aabccc')			'abccc' false (1 nil)			'aabcc' false (1 nil))		('a{2}bc{3}z'			'aabcccz' true (1 'aabcccz'))		('xa{2}bc{3}'			'xaabccc' true (1 'xaabccc'))		('xa{2}bc{3}z'			'xaabcccz' true (1 'xaabcccz'))		('[a-z]{2}'			'kp' true (1 'kp')			'k' false (1 nil)			'KP' false (1 nil))		('[1-9]{2}'			'63' true (1 '63'))		('(a|b){2}'			'ba' true (1 'ba' 2 ('b' 'a')))			('(ab){2}'			'abab' true (1 'abab' 2 ('ab' 'ab')))		('(ab|zx){2}'			'zxab' true (1 'zxab' 2 ( 'zx' 'ab')))		('k((ab|zx){2})k'			'kzxabk' true (1 'kzxabk' 2 'zxab' 3 ('zx'  'ab')))		('a{2,}b'			'aaaaab' true (1 'aaaaab')			'ab' false (1 nil))		('a{2,5}'			'aa' true (1 'aa')			'aaaaa' true (1 'aaaaa')			'ab' false (1 nil)			'a' false (1 nil))		('a{2,5}b'			'aab' true (1 'aab')			'aaaaab' true (1 'aaaaab')			'ab' false (1 nil)			'a' false (1 nil))		('xa{2,5}'			'xaa' true (1 'xaa')			'xaaaaa' true (1 'xaaaaa')			'xa' false (1 nil)			'a' false (1 nil))		('xa{2,5}b'			'xaab' true (1 'xaab')			'xaaaaab' true (1 'xaaaaab')			'xab' false (1 nil)			'a' false (1 nil))		('a{2,5}b{2,5}z'			'aabbz' true (1 'aabbz')			'aaaaabbbbbz' true (1 'aaaaabbbbbz')			'aabbbbbbz' false (1 nil))		('a{0,2}'			'' true (1 '')			'a' true (1 'a')				'aa' true (1 'aa'))		('a{,2}'			'' true (1 '')			'a' true (1 'a')				'aa' true (1 'aa'))		('xa{,2}z'			'xz' true (1 'xz')			'xaz' true (1 'xaz')					'xaaz' true (1 'xaaz')			'xaaaz' false (1 nil))		('xa{,2}z'			'xz' true (1 'xz')			'xaz' true (1 'xaz')				'xaaz' true (1 'xaaz')			'xaaaz' false (1 nil))		('xa{,2}'			'x' true (1 'x')		'xa' true (1 'xa')			'xaa' true (1 'xaa'))		('a{,2}z'			'z' true (1 'z')			'az' true (1 'az')			'aaz' true (1 'aaz'))		)</body><body package="Regex11">testSuiteRepeatsEquivalence	"See explanations in #testSuite"	^#(		('a{0,1}'			'a' true (1 'a' )			'' true (1  ''))		('a{0,1}a'			'aa' true (1 'aa' )			'a' true (1  'a'))		('a{0,1}b'			'ab' true (1 'ab' )			'b' true (1  'b'))		('xa{0,1}'			'xa' true (1 'xa' )			'x' true (1  'x'))		('xa{0,1}b'			'xab' true (1 'xab' )			'xb' true (1  'xb')			'xaab' false (1  nil))		('a{0,}'			'aa' true (1 'aa' )			'' true (1  ''))		('xa{0,}'			'xaa' true (1 'xaa' )			'x' true (1  'x'))		('a{0,}b'			'aab' true (1 'aab' )			'b' true (1  'b'))		('xa{0,}b'			'xaab' true (1 'xaab' )			'xb' true (1  'xb'))		('xa{0,1}b'			'xab' true (1 'xab' )			'xb' true (1  'xb')			'xaab' false (1  nil))		('a{1,}'			'aa' true (1 'aa' )			'' false (1  nil))		('xa{1,}'			'xaa' true (1 'xaa' )			'x' false (1  nil))		('a{1,}b'			'aab' true (1 'aab' )			'b' false (1  nil))		('xa{1,}b'			'xaab' true (1 'xaab' )			'xb' false (1  nil))		)</body><body package="Regex11">testSuiteThatFails	"See explanations in #testSuite"	"The tests below failed,  they must added back to the regular test suites when they are fixed"	^#()</body></methods><methods><class-id>RxParser class</class-id> <category>class initialization</category><body package="Regex11">initialize	"self initialize"	self		initializeExceptions;		initializeBackslashConstants;		initializeBackslashSpecials</body><body package="Regex11">initializeBackslashConstants	"self initializeBackslashConstants"	(BackslashConstants := Dictionary new)		at: $e put: Character esc;		at: $n put: Character lf;		at: $r put: Character cr;		at: $f put: Character newPage;		at: $t put: Character tab</body><body package="Regex11">initializeBackslashSpecials	"Keys are characters that normally follow a \, the values are	associations of classes and initialization selectors on the instance side	of the classes."	"self initializeBackslashSpecials"	(BackslashSpecials := Dictionary new)		at: $w put: (Association key: RxsPredicate value: #beWordConstituent);		at: $W put: (Association key: RxsPredicate value: #beNotWordConstituent);		at: $s put: (Association key: RxsPredicate value: #beSpace);		at: $S put: (Association key: RxsPredicate value: #beNotSpace);		at: $d put: (Association key: RxsPredicate value: #beDigit);		at: $D put: (Association key: RxsPredicate value: #beNotDigit);		at: $b put: (Association key: RxsContextCondition value: #beWordBoundary);		at: $B put: (Association key: RxsContextCondition value: #beNonWordBoundary);		at: $&lt; put: (Association key: RxsContextCondition value: #beBeginningOfWord);		at: $&gt; put: (Association key: RxsContextCondition value: #beEndOfWord)</body></methods><methods><class-id>RxParser class</class-id> <category>profiling</category><body package="Regex11">bigHonkingStream	^'/home/vassili/VisualWorks/image/visualnc.sou' asFilename readStream "7 Megs"</body><body package="Regex11">frequentMatchProfile	"	TimeProfiler profile: [self frequentMatchProfile]	Time millisecondsToRun: [self frequentMatchProfile]	"	| stream matcher count |	stream := self bigHonkingStream.	count := 0.	matcher := '\&lt;\w+' asRegex.	[		[matcher searchStream: stream] whileTrue: [count := count + 1].	]	ensure: [stream close].	^count</body><body package="Regex11">rareMatchProfile	"	TimeProfiler profile: [self rareMatchProfile]	Time millisecondsToRun: [self rareMatchProfile]	"	| stream matcher count |	stream := self bigHonkingStream.	count := 0.	matcher := 'foo' asRegex.	[		[matcher searchStream: stream] whileTrue: [count := count + 1].	]	ensure: [stream close].	^count</body><body package="Regex11">singleCharPrefixMatchProfile	"	TimeProfiler profile: [self singleCharPrefixMatchProfile]	Time millisecondsToRun: [self singleCharPrefixMatchProfile]	"	| stream matcher count |	stream := self bigHonkingStream.	count := 0.	matcher := 'm(e|a)th' asRegex.	[		[matcher searchStream: stream] whileTrue: [count := count + 1].	]	ensure: [stream close].	^count</body></methods><methods><class-id>RxParser class</class-id> <category>preferences</category><body package="Regex11">preferredMatcherClass	"The matcher to use. For now just one is available, but in	principle this determines the matchers built implicitly,	such as by String&gt;&gt;asRegex, or String&gt;&gt;matchesRegex:.	This might seem a bit strange place for this preference, but	Parser is still more or less `central' thing in the whole package."	^RxMatcher</body></methods><methods><class-id>RxParser class</class-id> <category>exception signaling</category><body package="Regex11">doHandlingMessageNotUnderstood: aBlock	"MNU should be trapped and resignaled as a match error in a few places in the matcher.	This method factors out this dialect-dependent code to make porting easier."	^Object messageNotUnderstoodSignal		handle:			[:ex | ex restartDo:					[RxParser signalMatchException: 'invalid predicate selector']]		do: aBlock</body><body package="Regex11">signalCompilationException: errorString	^self compilationErrorSignal raiseErrorString: errorString</body><body package="Regex11">signalMatchException: errorString	^self matchErrorSignal raiseErrorString: errorString</body><body package="Regex11">signalSyntaxException: errorString	^self syntaxErrorSignal raiseErrorString: errorString</body></methods><methods><class-id>RxParser class</class-id> <category>DOCUMENTATION</category><body package="Regex11">a:_ introduction:__ " A regular expression is a template specifying a class of strings. Aregular expression matcher is an tool that determines whether a stringbelongs to a class specified by a regular expression.  This is acommon task of a user input validation code, and the use of regularexpressions can GREATLY simplify and speed up development of suchcode.  As an example, here is how to verify that a string is a validhexadecimal number in Smalltalk notation, using this matcher package:	aString matchesRegex: '16r[[:xdigit:]]+'(Coding the same ``the hard way'' is an exercise to a curious reader).This matcher is offered to the Smalltalk community in hope it will beuseful. It is free in terms of money, and to a large extent--in termsof rights of use. Refer to `Boring Stuff' section for legalese.The 'What's new in this release' section describes the functionalityintroduced in 1.1 release.The `Syntax' section explains the recognized syntax of regularexpressions.The `Usage' section explains matcher capabilities that go beyond whatString&gt;&gt;matchesRegex: method offers.The `Implementation notes' sections says a few words about what isunder the hood.Happy hacking,--Vassili Bykov &lt;vassili@objectpeople.com&gt; &lt;vassili@magma.ca&gt;August 6, 1996April 4, 1999_Michel Bany&lt;michel@bany.fr&gt;April 26, 2013May 03, 2013"	self error: 'comment only'</body><body package="Regex11">b:_ whatsNewInThisRelease: __"VERSION 1.4.6 (December 2014)1 Fix: Compiling a regular expression with an invalid or unrecognized message predicate :xxx: gave no error, but trying to match with it gave an error. VERSION 1.4.5 (October 2014)1. New: RxParser class&gt;&gt;metacharacters lists characters that need escaping with backslash2. Documentation: minor improvements to syntax documentationVERSION 1.4.4 (May 2014)1. Tests: Added tests for messages in regex protocol in CharacterArray2. Documentation: #replaceRegex:withString: docs and exampleVERSION 1.4.3.1 (April 2014)1. Refactoring: sends of #contains: replaced with ANSI-compatible #anySatisfy:VERSION 1.4.3 (February 2014)1. New: CharacterArray&gt;&gt;replaceRegex:withString:, where replacement string can contain \0 for whole match or \1..\9 for subexpression matchesVERSION 1.4.2 (May 2013)1. Documentation: MIT licence applied2. Change: Tests removed from VW Launcher menus, see package comment for how to run.VERSION 1.4.1 (May 2013)1. New: Support for non-capturing groups, (?:a*b)VERSION 1.4 (May 2013)1. New: Support for explicitely numbered repetitions.2. Internal: Tests can be fired from the Launcher tools menuVERSION 1.3.4 (May 2011)1. New: can turn off test result logging with RxParser's LoggingEnabled shared var. With LoggingEnabled true (the default), each test's result is logged to the Transcript, so the suite takes over 10 seconds. With LoggingEnabled false, the tests run about 1000 times faster, and failures are shown by raising an error.2. Note: the correction in 1.3.3 makes regular expressions about twice as slow as before, but still only 15ms for the whole suite of 359 tests (144 regexs and 215 regex matches).VERSION 1.3.3 (May 2011)1. Fixed RxmBranch to do greedy matching instead of first match passes.This entailed adding a collection copy to #currentState, so I expect this to slow down Regex11 a bit (not measured yet).2. This fixes a bug found a Soops:    '.*(ABCD|BC)' asRegex matches: 'fooABCD'and Mantis bug 5391:    '15' matchesRegex: '[1-9]|1[0-9]'VERSION 1.3.2 (August 2010)1. Fix: 'Strings only store characters' error on [[:alnum]] and other similar named character classes missing a final colon2. Internal: updated package comment to point to documentationVERSION 1.3.1 (September 2008)1. Updated documentation of character classes, making clear the problems of locale - an area for future improvementVERSION 1.3 (September 2008)1. \w now matches underscore as well as alphanumerics, in line with most other regex libraries (and our documentation!).  2. \W rejects underscore as well as alphanumerics3. added tests for this at end of testSuite4. updated documentation and added note to old incorrect comments in version 1.1 belowVERSION 1.2.3 (November 2007)1. Regexs with ^ or $ applied to copy empty strings caused infinite loops, e.g. ('' copyWithRegex: '^.*$' matchesReplacedWith: 'foo'). Applied a similar correction to that from version 1.1c, to #copyStream:to:(replacingMatchesWith:|translatingMatchesUsing:).2. Extended RxParser testing to run each test for #copy:translatingMatchesUsing: as well as #search:.3. Corrected #testSuite test that a dot does not match a null, which was passing by luck with Smalltalk code in a literal array.4. Added test to end of test suite for fix 1 above.VERSION 1.2.2 (November 2006)There was no way to specify a backslash in a character set. Now [\\] is accepted.VERSION 1.2.1	(August 2006)1. Support for returning all ranges (startIndex to: stopIndex) matching a regex - #allRangesOfRegexMatches:, #matchingRangesIn:2. Added hint to usage documentation on how to get more information about matches when enumerating3. Syntax description of dot corrected: matches anything but NUL since 1.1aVERSION 1.2	(May 2006)Fixed case-insensitive search for character sets.VERSION 1.1c	(December 2004)Fixed the issue with #matchesOnStream:do: which caused infinite loops for matches that matched empty strings.VERSION 1.1b	(November 2001)Changes valueNowOrOnUnwindDo: to ensure:, plus incorporates some earlier fixes.VERSION 1.1a	(May 2001)1. Support for keeping track of multiple subexpressions.2. Dot (.) matches anything but NUL character, as it should per POSIX spec.3. Some bug fixes.VERSION 1.1	(October 1999)Regular expression syntax corrections and enhancements:1. Backslash escapes similar to those in Perl are allowed in patterns:	\w	any word constituent character (equivalent to [a-zA-Z0-9_]) *** underscore only since 1.3 ***	\W	any character but a word constituent (equivalent to [^a-xA-Z0-9_] *** underscore only since 1.3 ***	\d	a digit (same as [0-9])	\D	anything but a digit	\s 	a whitespace character	\S	anything but a whitespace character	\b	an empty string at a word boundary	\B	an empty string not at a word boundary	\&lt;	an empty string at the beginning of a word	\&gt;	an empty string at the end of a wordFor example, '\w+' is now a valid expression matching any word.2. The following backslash escapes are also allowed in character sets(between square brackets):	\w, \W, \d, \D, \s, and \S.3. The following grep(1)-compatible named character classes arerecognized in character sets as well:	[:alnum:]	[:alpha:]	[:cntrl:]	[:digit:]	[:graph:]	[:lower:]	[:print:]	[:punct:]	[:space:]	[:upper:]	[:xdigit:]For example, the following patterns are equivalent:	'[[:alnum:]_]+' '\w+'  '[\w]+' '[a-zA-Z0-9_]+' *** underscore only since 1.3 ***4. Some non-printable characters can be represented in regularexpressions using a common backslash notation:	\t	tab (Character tab)	\n	newline (Character lf)	\r	carriage return (Character cr)	\f	form feed (Character newPage)	\e	escape (Character esc)5. A dot is corectly interpreted as 'any character but a newline'instead of 'anything but whitespace'.6. Case-insensitive matching.  The easiest access to it are newmessages CharacterArray understands: #asRegexIgnoringCase,#matchesRegexIgnoringCase:, #prefixMatchesRegexIgnoringCase:.7. The matcher (an instance of RxMatcher, the result ofString&gt;&gt;asRegex) now provides a collection-like interface to matchesin a particular string or on a particular stream, as well assubstitution protocol. The interface includes the following messages:	matchesIn: aString	matchesIn: aString collect: aBlock	matchesIn: aString do: aBlock	matchesOnStream: aStream	matchesOnStream: aStream collect: aBlock	matchesOnStream: aStream do: aBlock	copy: aString translatingMatchesUsing: aBlock	copy: aString replacingMatchesWith: replacementString	copyStream: aStream to: writeStream translatingMatchesUsing: aBlock	copyStream: aStream to: writeStream replacingMatchesWith: aStringExamples:	'\w+' asRegex matchesIn: 'now is the time'returns an OrderedCollection containing four strings: 'now', 'is','the', and 'time'.	'\&lt;t\w+' asRegexIgnoringCase		copy: 'now is the Time'		translatingMatchesUsing: [:match | match asUppercase]returns 'now is THE TIME' (the regular expression matches wordsbeginning with either an uppercase or a lowercase T).ACKNOWLEDGEMENTSSince the first release of the matcher, thanks to the input fromseveral fellow Smalltalkers, I became convinced a native Smalltalkregular expression matcher was worth the effort to keep it alive. Forthe contributions, suggestions, and bug reports that made this release possible, I want to thank:	Felix Hack	Peter Hatch	Alan Knight	Eliot Miranda	Thomas Muhr	Robb Shecter	David N. Smith	Francis Wolinskiand anyone whom I haven't yet met or heard from, but who agrees thishas not been a complete waste of time.--Vassili BykovOctober 3, 1999"	self error: 'comment only'</body><body package="Regex11">c:_ syntax:__ " [You can select and `print it' examples in this method. Just don'tforget to cancel the changes.]The simplest regular expression is a single character.  It matchesexactly that character. A sequence of characters matches a string withexactly the same sequence of characters:	'a' matchesRegex: 'a'				-- true	'foobar' matchesRegex: 'foobar'		-- true	'blorple' matchesRegex: 'foobar'		-- falseThe above paragraph introduced a primitive regular expression (acharacter), and an operator (sequencing). Operators are applied toregular expressions to produce more complex regular expressions.Sequencing (placing expressions one after another) as an operator is,in a certain sense, `invisible'--yet it is arguably the most common.A more `visible' operator is Kleene closure, more often simplyreferred to as `a star'.  A regular expression followed by an asteriskmatches any number (including 0) of matches of the originalexpression. For example:	'ab' matchesRegex: 'a*b'		 		-- true	'aaaaab' matchesRegex: 'a*b'	 	-- true	'b' matchesRegex: 'a*b'		 		-- true	'aac' matchesRegex: 'a*b'	 		-- false: b does not matchA star's precedence is higher than that of sequencing. A star appliesto the shortest possible subexpression that precedes it. For example,'ab*' means `a followed by zero or more occurrences of b', not `zeroor more occurrences of ab':	'abbb' matchesRegex: 'ab*'	 		-- true	'abab' matchesRegex: 'ab*'		 	-- falseTo actually make a regex matching `zero or more occurrences of ab',`ab' is enclosed in parentheses:	'abab' matchesRegex: '(ab)*'		 	-- true	'abcab' matchesRegex: '(ab)*'	 	-- false: c spoils the funA regex that is enclosed in parentheses is called a group, but in Regex11we call this a subexpression. By default, subexpressions are 'capturing',however a subexpression can be marked as hidden'  to become non-capturing.This is done by adding '?:' immediately after the opening parentheses. Markingsubexpressions as non-capturing has no effect on the matching:	'abab' matchesRegex: '(?:ab)*'		 	-- true	'abcab' matchesRegex: '(?:ab)*'	 	-- false: c spoils the funSee more information about capturing vs. non-capturing subexpressionsin the usage section.Two other operators similar to `*' are `+' and `?'. `+' (positiveclosure, or simply `plus') matches one or more occurrences of theoriginal expression. `?' (`optional') matches zero or one, but nevermore, occurrences.	'ac' matchesRegex: 'ab*c'	 		-- true	'ac' matchesRegex: 'ab+c'	 		-- false: need at least one b	'abbc' matchesRegex: 'ab+c'		 	-- true	'abbc' matchesRegex: 'ab?c'		 	-- false: too many b'sRepetitions can also be represented explicitely using numbers- Exactly three occurences: {3}- Two to five occurences: {2,5}- Three or more occurences: {3,}- Zero, one or two occurences: {,2}	'abbbc' matchesRegex: 'ab{3}c'	 	-- true	'abc' matchesRegex: 'ab{2,5}c'	 	-- false: need at least two b	'abbbbbbc' matchesRegex: 'ab{2,5}c'	-- false: may not have more than five b	'abbbc' matchesRegex: 'ab{2,5}c'		-- true	'abbbbbbc' matchesRegex: 'ab{3,}c'	-- true	'ac' matchesRegex: 'ab{,2}c'		 	-- trueAs we have seen, characters like `*', `+', `?', `(', and `)' have specialmeaning in regular expressions. If one of them is to be usedliterally, it should be escaped: preceded with a backslash. (Thus,backslash is also special character, and needs to be escaped for aliteral match.) The full set of characters that require or may require backslash is listed in RxParser class&gt;&gt;metacharacters.	'ab*' matchesRegex: 'ab*'		 	-- false: star in the right string is special	'ab*' matchesRegex: 'ab\*'	 		-- true	'a\c' matchesRegex: 'a\\c'		 	-- trueThe last operator is `|' meaning `or'. It is placed between tworegular expressions, and the resulting expression matches if one ofthe expressions matches. It has the lowest possible precedence (lowerthan sequencing). For example, `ab*|ba*' means `a followed by anynumber of b's, or b followed by any number of a's':	'abb' matchesRegex: 'ab*|ba*'	 	-- true	'baa' matchesRegex: 'ab*|ba*'	 	-- true	'baab' matchesRegex: 'ab*|ba*'	 	-- falseA bit more complex example is the following expression, matching thename of any of the Lisp-style `car', `cdr', `caar', `cadr',... functions:	c(a|d)+rIt is possible to write an expression matching an empty string, forexample: `a|'.  However, it is an error to apply `*', `+', or `?' tosuch an expression: `(a|)*' is an invalid expression.So far, we have used only characters as the 'smallest' components ofregular expressions. There are other, more `interesting', components.A character set is a string of characters enclosed in squarebrackets. It matches any single character if it appears between thebrackets. For example, `[01]' matches either `0' or `1':	'0' matchesRegex: '[01]'		 		-- true	'3' matchesRegex: '[01]'		 		-- false	'11' matchesRegex: '[01]'		 		-- false: a set matches only one characterUsing the plus operator, we can build the following binary numberrecognizer:	'10010100' matchesRegex: '[01]+'	 	-- true	'10001210' matchesRegex: '[01]+'	 	-- falseIf the first character after the opening bracket is `^', the set isinverted: it matches any single character *not* appearing between thebrackets:	'0' matchesRegex: '[^01]'		  		-- false	'3' matchesRegex: '[^01]'		 		-- trueFor convenience, a set may include ranges: pairs of charactersseparated with `-'. This is equivalent to listing all charactersbetween them: `[0-9]' is the same as `[0123456789]'.Special characters within a set are `^', `-', and `]' that closes theset. Below are the examples of how to literally use them in a set:	[01^]		-- put the caret anywhere except the beginning	[01-]		-- put the dash as the last character	[]01]		-- put the closing bracket as the first character 	[^]01]			(thus, empty and universal sets cannot be specified)Regular expressions can also include the following backslash special setsto refer to popular classes of characters:	\w	any word constituent character (same as [a-zA-Z0-9_])	\W	any character but a word constituent	\d	a digit (same as [0-9])	\D	anything but a digit	\s 	a whitespace character (same as [:space:] below)	\S	anything but a whitespace characterThese backslash special sets are also allowed in character classes: '[\w+-]' means 'any character that is either a word constituent, or a plus, or a minus'.Character classes can also include the following grep(1)-compatibleelements to refer to:	[:alnum:]		any alphanumeric character (same as [a-zA-Z0-9])	[:alpha:]		any alphabetic character (same as [a-zA-Z])	[:cntrl:]		any control character. (any character with code &lt; 32)	[:digit:]		any decimal digit (same as [0-9])	[:graph:]		any graphical character. (any character with code &gt;= 32).	[:lower:]		any lowercase character (including non-ASCII lowercase characters)	[:print:]		any printable character. In this version, this is the same as [:graph:]	[:punct:]		any punctuation character:  . , ! ? ; : ' - ( ) ` and double quotes	[:space:]		any whitespace character (space, tab, CR, LF, null, form feed, Ctrl-Z, 16r2000-16r200B, 16r3000)	[:upper:]		any uppercase character (including non-ASCII uppercase characters)	[:xdigit:]		any hexadecimal character (same as [a-fA-F0-9]).Note that many of these are only as consistent or inconsistent on issuesof locale as the underlying Smalltalk implementation. Values shown hereare for VisualWorks 7.6.Note that these elements are components of the character classes,i.e. they have to be enclosed in an extra set of square brackets toform a valid regular expression.  For example, a non-empty string ofdigits would be represented as '[[:digit:]]+'.The above primitive expressions and operators are common to manyimplementations of regular expressions. The next primitive expressionis unique to this Smalltalk implementation.A sequence of characters between colons is treated as a unary selectorwhich is supposed to be understood by Characters. A character matchessuch an expression if it answers true to a message with thatselector. This allows a more readable and efficient way of specifyingcharacter classes. For example, `[0-9]' is equivalent to `:isDigit:',but the latter is more efficient. Analogously to character sets,character classes can be negated: `:^isDigit:' matches a Characterthat answers false to #isDigit, and is therefore equivalent to`[^0-9]'.As an example, so far we have seen the following equivalent ways towrite a regular expression that matches a non-empty string of digits:	'[0-9]+'	'\d+'	'[\d]+'	'[[:digit:]]+'	:isDigit:+'The last group of special primitive expressions includes: 	.	matching any character except a NULL; 	^	matching an empty string at the beginning of a line; 	$	matching an empty string at the end of a line.	\b	an empty string at a word boundary	\B	an empty string not at a word boundary	\&lt;	an empty string at the beginning of a word	\&gt;	an empty string at the end of a word	'axyzb' matchesRegex: 'a.+b'		-- true	'ax zb' matchesRegex: 'a.+b'			-- true (space is matched by `.')	'axzb' matchesRegex: 'a.+b'				-- true (carriage return is matched by `.')Again, the dot ., caret ^ and dollar $ characters are special and should be escapedto be matched literally.	EXAMPLESAs the introductions said, a great use for regular expressions is userinput validation. Following are a few examples of regular expressionsthat might be handy in checking input entered by the user in an inputfield. Try them out by entering something between the quotes andprint-iting. (Also, try to imagine Smalltalk code that each validationwould require if coded by hand).  Most example expressions could havebeen written in alternative ways.Checking if aString may represent a nonnegative integer number:	'' matchesRegex: ':isDigit:+'or	'' matchesRegex: '[0-9]+'or	'' matchesRegex: '\d+'Checking if aString may represent an integer number with an optionalsign in front:	'' matchesRegex: '(\+|-)?\d+'Checking if aString is a fixed-point number, with at least one digitis required after a dot:	'' matchesRegex: '(\+|-)?\d+(\.\d+)?'The same, but allow notation like `123.':	'' matchesRegex: '(\+|-)?\d+(\.\d*)?'Recognizer for a string that might be a name: one word with firstcapital letter, no blanks, no digits.  More traditional:	'' matchesRegex: '[A-Z][A-Za-z]*'more Smalltalkish:	'' matchesRegex: ':isUppercase::isAlphabetic:*'A date in format MMM DD, YYYY with any number of spaces in between, inXX century:	'' matchesRegex: '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(\d\d?)[ ]*,[ ]*19(\d\d)'Note parentheses around some components of the expression above. As`Usage' section shows, they will allow us to obtain the actual stringsthat have matched them (i.e. month name, day number, and year number).For dessert, coming back to numbers: here is a recognizer for ageneral number format: anything like 999, or 999.999, or -999.999e+21.	'' matchesRegex: '(\+|-)?\d+(\.\d*)?((e|E)(\+|-)?\d+)?'"	self error: 'comment only'</body><body package="Regex11">d:_ usage:__" The preceding section covered the syntax of regular expressions. Itused the simplest possible interface to the matcher: sending#matchesRegex: message to the sample string, with regular expressionstring as the argument.  This section explains hairier ways of usingthe matcher.	PREFIX MATCHING AND CASE-INSENSITIVE MATCHINGA CharacterArray (an EsString in VA) also understands these messages:	#prefixMatchesRegex: regexString	#matchesRegexIgnoringCase: regexString	#prefixMatchesRegexIgnoringCase: regexString#prefixMatchesRegex: is just like #matchesRegex, except that the wholereceiver is not expected to match the regular expression passed as theargument; matching just a prefix of it is enough.  For example:	'abcde' matchesRegex: '(a|b)+'		-- false	'abcde' prefixMatchesRegex: '(a|b)+'	-- trueThe last two messages are case-insensitive versions of matching.	ENUMERATION INTERFACEAn application can be interested in all matches of a certain regularexpression within a String.  The matches are accessible using aprotocol modelled after the familiar Collection-like enumerationprotocol:	#regex: regexString matchesDo: aBlockEvaluates a one-argument &lt;aBlock&gt; for every match of the regularexpression within the receiver string.	#regex: regexString matchesCollect: aBlockEvaluates a one-argument &lt;aBlock&gt; for every match of the regularexpression within the receiver string. Collects results of evaluationsand anwers them as a SequenceableCollection.	#allRegexMatches: regexStringReturns a collection of all matches (substrings of the receiverstring) of the regular expression.  It is an equivalent of &lt;aStringregex: regexString matchesCollect: [:each | each]&gt;.	#allRangesOfRegexMatches: regexStringReturns a collection of all character ranges (startIndex to: stopIndex)that match the regular expression.	REPLACEMENT AND TRANSLATIONIt is possible to replace all matches of a regular expression with acertain string using the message:	#copyWithRegex: regexString matchesReplacedWith: aStringFor example:	'ab cd ab' copyWithRegex: '(a|b)+' matchesReplacedWith: 'foo'If the replacement string should be based on the match in the input string,or subexpression matches within it (see below), you can use:		#replaceRegex: regularExpressionString withString: replacementStringreplacementString can contain \0 for the whole regex match or \1 .. \9for the corresponding subexpression. For example, to turn 'James Bond'into 'Bond, James Bond':	'James Bond' replaceRegex: '(\w+) (\w+)' withString: '\2, \1 \2'A more general substitution is match translation:	#copyWithRegex: regexString matchesTranslatedUsing: aBlockThis message evaluates a block passing it each match of the regularexpression in the receiver string and answers a copy of the receiverwith the block results spliced into it in place of the respectivematches.  For example:	'ab cd ab' copyWithRegex: '(a|b)+' matchesTranslatedUsing: [:each | each asUppercase]All messages of enumeration and replacement protocols perform acase-sensitive match.  Case-insensitive versions are not provided aspart of a CharacterArray protocol.  Instead, they are accessible usingthe lower-level matching interface.	LOWER-LEVEL INTERFACEInternally, #matchesRegex: works as follows:1. A fresh instance of RxParser is created, and the regular expressionstring is passed to it, yielding the expression's syntax tree.2. The syntax tree is passed as an initialization parameter to aninstance of RxMatcher. The instance sets up some data structure thatwill work as a recognizer for the regular expression described by thetree.3. The original string is passed to the matcher, and the matcherchecks for a match.	THE MATCHERIf you repeatedly match a number of strings against the same regularexpression using one of the messages defined in CharacterArray, theregular expression string is parsed and a matcher is created anew forevery match.  You can avoid this overhead by building a matcher forthe regular expression, and then reusing the matcher over and overagain. You can, for example, create a matcher at a class or instanceinitialization stage, and store it in a variable for future use.You can create a matcher using one of the following methods:	- Sending #forString:ignoreCase: message to RxMatcher class, withthe regular expression string and a Boolean indicating whether case isignored as arguments.	- Sending #forString: message.  It is equivalent to &lt;... forString:regexString ignoreCase: false&gt;.A more convenient way is using one of the two matcher-created messagesunderstood by CharacterArray.	- &lt;regexString asRegex&gt; is equivalent to &lt;RxMatcher forString:regexString&gt;.	- &lt;regexString asRegexIgnoringCase&gt; is equivalent to &lt;RxMatcherforString: regexString ignoreCase: true&gt;.Here are four examples of creating a matcher:	hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+'	hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+' ignoreCase: false	hexRecognizer := '16r[0-9A-Fa-f]+' asRegex	hexRecognizer := '16r[0-9A-F]+' asRegexIgnoringCase	MATCHINGThe matcher understands these messages (all of them return true toindicate successful match or search, and false otherwise):matches: aString	True if the whole target string (aString) matches.matchesPrefix: aString	True if some prefix of the string (not necessarily the whole	string) matches.search: aString	Search the string for the first occurrence of a matching	substring. (Note that the first two methods only try matching from	the very beginning of the string). Using the above example with a	matcher for `a+', this method would answer success given a string	`baaa', while the previous two would fail.matchesStream: aStreammatchesStreamPrefix: aStreamsearchStream: aStream	Respective analogs of the first three methods, taking input from a	stream instead of a string. The stream must be positionable and	peekable.All these methods answer a boolean indicating success. The matcheralso stores the outcome of the last match attempt and can report it:lastResult	Answers a Boolean -- the outcome of the most recent match	attempt. If no matches were attempted, the answer is unspecified.	SUBEXPRESSION MATCHESAfter a successful match attempt, you can query the specifics of whichpart of the original string has matched which part of the wholeexpression.A subexpression is a parenthesized part of a regular expression, orthe whole expression. When a regular expression is compiled, itssubexpressions are assigned indices starting from 1, depth-first,left-to-right. For example, `((ab)+(c|d))?ef' includes the followingsubexpressions with these indices:	1:	((ab)+(c|d))?ef	2:	(ab)+(c|d)	3:	ab	4:	c|dAfter a successful match, the matcher can report what part of theoriginal string matched what subexpression. It understandards thesemessages:subexpressionCount	Answers the total number of subexpressions: the highest value that	can be used as a subexpression index with this matcher. This value	is available immediately after initialization and never changes.subexpression: anIndex	An index must be a valid subexpression index, and this message	must be sent only after a successful match attempt. The method	answers a substring of the original string the corresponding	subexpression has matched to.subBeginning: anIndexsubEnd: anIndex	Answer positions within the original string or stream where the	match of a subexpression with the given index has started and	ended, respectively.This facility provides a convenient way of extracting parts of inputstrings of complex format. For example, the following piece of codeuses the 'MMM DD, YYYY' date format recognizer example from the`Syntax' section to convert a date to a three-element array with year,month, and day strings (you can select and evaluate it right here):	| matcher |	matcher := RxMatcher forString: '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(:isDigit::isDigit:?)[ ]*,[ ]*(19|20)(:isDigit::isDigit:)'.	(matcher matches: 'Aug 6, 1996')		ifTrue: 			[Array 				with: (matcher subexpression: 5)				with: (matcher subexpression: 2)				with: (matcher subexpression: 3)]		ifFalse: ['no match'](should answer ` #('96' 'Aug' '6')').It is possible to disable extraction for a given subexpression. A subexpressionfor which extraction is disabled is also called a 'non-capturing group'. To disableextraction for a subexpression, one must add '?:' immediately after the openingparenthesis.  For example, `(?:(ab)+(?:c|d))?ef' includes the followingsubexpressions with these indices:	1:	((ab)+(c|d))?ef	2:	abThis facility provides a convenient way to only extract those parts that are interesting.Exemple: 	| matcher |	matcher := RxMatcher forString: '.*&lt;(?:DTP|TPX)=(.*)&gt;.*' .	(matcher matches: 'foo&lt;DTP=12345&gt;bar')		ifTrue: 			[Array 				with: (matcher subexpression: matcher subexpressionCount)]		ifFalse: ['no match'](should answer ` #('12345')).	| matcher |	matcher := RxMatcher forString: '.*&lt;(DTP|TPX)=(?:.*)&gt;.*' .	(matcher matches: 'foo&lt;DTP=12345&gt;bar')		ifTrue: 			[Array 				with: (matcher subexpression: matcher subexpressionCount)]		ifFalse: ['no match'](should answer ` #('DTP')).	ENUMERATION AND REPLACEMENTThe enumeration and replacement protocols exposed in CharacterArrayare actually implemented by the matcher.  The following messages areunderstood:	#matchesIn: aString	#matchesIn: aString do: aBlock	#matchesIn: aString collect: aBlock	#copy: aString replacingMatchesWith: replacementString	#copy: aString translatingMatchesUsing: aBlock	#matchingRangesIn: aString	#matchesOnStream: aStream	#matchesOnStream: aStream do: aBlock	#matchesOnStream: aStream collect: aBlock	#copy: sourceStream to: targetStream replacingMatchesWith: replacementString	#copy: sourceStream to: targetStream translatingMatchesWith: aBlockNote that in those methods that take a block, the block may refer to the rxMatcher itself, e.g. to collect information about the position the match occurred at, or thesubexpressions of the match. An example can be seen in #matchingRangesIn:	ERROR HANDLINGException signaling objects (Signals in VisualWorks, Exceptions in VisualAge) areaccessible through RxParser class protocol. To handle possible errors, usethe protocol described below to obtain the exception objects and use theprotocol of the native Smalltalk implementation to handle them.If a syntax error is detected while parsing expression,RxParser&gt;&gt;syntaxErrorSignal is raised/signaled.If an error is detected while building a matcher,RxParser&gt;&gt;compilationErrorSignal is raised/signaled.If an error is detected while matching (for example, if a bad selectorwas specified using `:&lt;selector&gt;:' syntax, or because of the matcher'sinternal error), RxParser&gt;&gt;matchErrorSignal is raisedRxParser&gt;&gt;regexErrorSignal is the parent of all three.  Since any ofthe three signals can be raised within a call to #matchesRegex:, it ishandy if you want to catch them all.  For example:VisualWorks:	RxParser regexErrorSignal		handle: [:ex | ex returnWith: nil]		do: ['abc' matchesRegex: '))garbage[']VisualAge:	['abc' matchesRegex: '))garbage[']		when: RxParser regexErrorSignal		do: [:signal | signal exitWith: nil]"	self error: 'comment only'</body><body package="Regex11">e:_ implementationNotes:__"		Version:		1.1	Released:		October 1999	Mail to:		Vassili Bykov &lt;vassili@parcplace.com&gt;, &lt;v_bykov@yahoo.com&gt;	Flames to:		/dev/null	WHAT IS ADDEDThe matcher includes classes in two categories:	VB-Regex-Syntax	VB-Regex-Matcherand a few CharacterArray methods in `VB-regex' protocol.  No systemclasses or methods are modified.	WHAT TO LOOK AT FIRSTString&gt;&gt;matchesRegex: -- in 90% cases this method is all you need toaccess the package.RxParser -- accepts a string or a stream of characters with a regularexpression, and produces a syntax tree corresponding to theexpression. The tree is made of instances of Rxs&lt;whatever&gt; classes.RxMatcher -- accepts a syntax tree of a regular expression built bythe parser and compiles it into a matcher: a structure made ofinstances of Rxm&lt;whatever&gt; classes. The RxMatcher instance can testwhether a string or a positionable stream of characters matches theoriginal regular expression, or search a string or a stream forsubstrings matching the expression. After a match is found, thematcher can report a specific string that matched the wholeexpression, or any parenthesized subexpression of it.All other classes support the above functionality and are used byRxParser, RxMatcher, or both.	CAVEATSThe matcher is similar in spirit, but NOT in the design--let alone thecode--to the original Henry Spencer's regular expressionimplementation in C.  The focus is on simplicity, not on efficiency.I didn't optimize or profile anything.  I may in future--or I may not:I do this in my spare time and I don't promise anything.The matcher passes H. Spencer's test suite (see 'test suite'protocol), with quite a few extra tests added, so chances are goodthere are not too many bugs.  But watch out anyway.	EXTENSIONS, FUTURE, ETC.With the existing separation between the parser, the syntax tree, andthe matcher, it is easy to extend the system with other matchers basedon other algorithms. In fact, I have a DFA-based matcher right now,but I don't feel it is good enough to include it here.  I might addautomata-based matchers later, but again I don't promise anything.	HOW TO REACH MEAs of today (December 20, 2000), you can contact me at&lt;vassili@parcplace.com&gt;. If this doesn't work, look aroundcomp.lang.smalltalk or comp.lang.lisp.  "	self error: 'comment only'</body><body package="Regex11">f:_ boringStuff: __"The Regular Expression Matcher (``The Software'') is Copyright (C) 1996, 1999 Vassili Bykov. Copyright (C) 2013 Michel Bany It is provided to the Smalltalk community in hope it will be useful.1. This license applies to the package as a whole, as well as to any   component of it. By performing any of the activities described   below, you accept the terms of this agreement.2. The software is provided free of charge, and ``as is'', in hope   that it will be useful, with ABSOLUTELY NO WARRANTY. The entire   risk and all responsibility for the use of the software is with   you.  Under no circumstances the author may be held responsible for   loss of data, loss of profit, or any other damage resulting   directly or indirectly from the use of the software, even if the   damage is caused by defects in the software.3. You may use this software in any applications you build.4. You may distribute this software provided that the software   documentation and copyright notices are included and intact.5. You may create and distribute modified versions of the software,   such as ports to other Smalltalk dialects or derived work, provided   that:    a. any modified version is expressly marked as such and is not   misrepresented as the original software;    b. credit is given to the original software in the source code and   documentation of the derived work;    c. the copyright notice at the top of this document accompanies   copyright notices of any modified version.  "	self error: 'comment only'</body></methods><methods><class-id>RxParser class</class-id> <category>test failures</category><body package="Regex11">clearFailures	[self class removeSelector: self failureSelector] on: Error do: [:ex | ]</body><body package="Regex11">failureSelector	^#testFailures</body><body package="Regex11">failureSuite	^self hasFailures		ifTrue: [self perform: self failureSelector]		ifFalse: [#()]</body><body package="Regex11">handleFailures: failures for: matcherClass	failures isEmpty		ifTrue: [self clearFailures]		ifFalse: [self saveFailures: failures for: matcherClass]</body><body package="Regex11">hasFailures	^self respondsTo: self failureSelector</body><body package="Regex11">saveFailures: failures for: matcherClass	| aStream |	aStream := (String new: failures size * 20) writeStream.	aStream		nextPutAll: self failureSelector;		nextPutAll: '	"(( self 			runRegexTestsForMatcher: ' , matcherClass name					, '			suite: self ' , self failureSelector					, ' ))"	^#('.	failures asSet do: 			[:each |			aStream				cr;				tab;				tab;				nextPutAll: each printString].	aStream		cr;		tab;		nextPut: $).	self class compile: aStream contents classified: 'test failures'</body></methods><methods><class-id>RxmBranch</class-id> <category>initialize-release</category><body package="Regex11">alternative	^alternative</body><body package="Regex11">alternative: aBranch	"See class comment for instance variable description."	alternative := aBranch</body><body package="Regex11">beLoopback	"See class comment for instance variable description."	loopback := true</body><body package="Regex11">initialize	"See class comment for instance variable description."	loopback := false</body></methods><methods><class-id>RxmBranch</class-id> <category>building</category><body package="Regex11">pointTailTo: aNode	"See superclass for explanations."	loopback		ifTrue: [alternative == nil			ifTrue: [alternative := aNode]			ifFalse: [alternative pointTailTo: aNode]]		ifFalse: [super pointTailTo: aNode]</body><body package="Regex11">terminateWith: aNode	"See superclass for explanations."	loopback		ifTrue: [alternative == nil			ifTrue: [alternative := aNode]			ifFalse: [alternative terminateWith: aNode]]		ifFalse: [super terminateWith: aNode]</body></methods><methods><class-id>RxmBranch</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"Match the longest match of `next' or `alternative'. Fail the alternative if the alternative is nil."	| original firstMatch firstMatchPos |	original := aMatcher currentState.	(next matchAgainst: aMatcher)		ifFalse: [^alternative notNil and: [alternative matchAgainst: aMatcher]].	alternative ifNil: [^true].	firstMatch := aMatcher currentState.	firstMatchPos := aMatcher position.	aMatcher restoreState: original.	(alternative matchAgainst: aMatcher)		ifFalse: 			[aMatcher restoreState: firstMatch.			^true].	firstMatchPos &gt;= aMatcher position		ifTrue: 			[aMatcher restoreState: firstMatch.			^true].	^true</body></methods><methods><class-id>RxmBranch</class-id> <category>printing</category><body package="Regex11">printOn: aStream	super printOn: aStream.	aStream		space;		nextPutAll: 'Loop=';		nextPut: (loopback ifTrue: [$Y] ifFalse: [$N]).	alternative		ifNotNil: 			[aStream				space;				nextPutAll: 'Alt='.			alternative printOn: aStream].</body></methods><methods><class-id>RxmRepeatOptional</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"Hacky, funky, naughty and recursive"	self forMatcher: aMatcher		withContextDo: 			[:context |			context depth = 0				ifFalse: 					["A match has just been consumed, 					counting number of matches so far					Note - a match is not consumed at first entry"					context match].			context increment.			context x = max				ifTrue: 					[context decrement.					^true].			(next matchAgainst: aMatcher)				ifFalse: 					[context x = 0						ifTrue: 							[aMatcher restoreState: context originalState.							context decrement.							context depth &gt; 0 ifTrue: [^true].							^alternative matchAgainst: aMatcher]					"				ifTrue: 					[context decrement.					^true]"].			"Unwind"			context decrement.			context depth &gt; 0 ifTrue: [^true].			^alternative matchAgainst: aMatcher]</body></methods><methods><class-id>RxmRepeatOptional</class-id> <category>printing</category><body package="Regex11">printOccurencesOn: aStream	aStream		nextPutAll: (max ifNil: [''] ifNotNil: [max printString])</body><body package="Regex11">printOn: aStream	super printOn: aStream.	aStream		space;		nextPut: ${.	self printOccurencesOn: aStream.	aStream nextPut: $}</body></methods><methods><class-id>RxmRepeatOptional</class-id> <category>accessing</category><body package="Regex11">max	^max</body><body package="Regex11">max: anObject	max := anObject</body></methods><methods><class-id>RxmRepeatOptional</class-id> <category>private</category><body package="Regex11">forMatcher: aMatcher withContextDo: aBlock	aBlock value: (RmCurrentMatchContext value at: self ifAbsentPut: [RmRepeatContext new originalState: aMatcher currentState])</body></methods><methods><class-id>RxsRepetitions</class-id> <category>validating</category><body package="Regex11">ensureValidRepetitions	min &gt; (max ifNil: [min])		ifTrue: 			[RxParser				signalCompilationException: 'invalid repetitions {' , min asString , ','						, max asString , '}']</body></methods><methods><class-id>RxsRepetitions</class-id> <category>initialize-release</category><body package="Regex11">initializeRepetitions: anArray	min := max := anArray first asNumber.	anArray size &gt; 1		ifTrue: 			[max := anArray last isEmpty ifTrue: [nil] ifFalse: [anArray last asNumber]].	self ensureValidRepetitions</body></methods><methods><class-id>RxsRepetitions</class-id> <category>accessing</category><body package="Regex11">max	^max</body><body package="Regex11">max: anObject	max := anObject</body><body package="Regex11">min	^min</body><body package="Regex11">min: anObject	min := anObject</body></methods><methods><class-id>RmMatchContext</class-id> <category>accessing</category><body package="Regex11">at: anObject ifAbsentPut: aBlock	^(context ifNil: [context := Dictionary new]) at: anObject		ifAbsentPut: aBlock</body><body package="Regex11">matcher	^matcher</body><body package="Regex11">matcher: anObject	matcher := anObject</body></methods><methods><class-id>RxsCharacter</class-id> <category>initialize-release</category><body package="Regex11">initializeCharacter: aCharacter	"See class comment for instance variable description."	character := aCharacter</body></methods><methods><class-id>RxsCharacter</class-id> <category>testing</category><body package="Regex11">isAtomic	"A character is always atomic."	^true</body><body package="Regex11">isEnumerable	^true</body><body package="Regex11">isNullable	^false</body></methods><methods><class-id>RxsCharacter</class-id> <category>accessing</category><body package="Regex11">character	^character</body><body package="Regex11">dispatchTo: aMatcher	"Inform the matcher of the kind of the node, and it	will do whatever it has to."	^aMatcher syntaxCharacter: self</body><body package="Regex11">enumerateTo: aSet ignoringCase: aBoolean	aBoolean		ifTrue: 			[aSet 				add: character asUppercase;				add: character asLowercase]		ifFalse: [aSet add: character]</body></methods><methods><class-id>RxsCharacter class</class-id> <category>instance creation</category><body package="Regex11">with: aCharacter	^self new initializeCharacter: aCharacter</body></methods><methods><class-id>RxmRepeat</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"Hacky, funky, naughty and recursive"	self forMatcher: aMatcher		withContextDo: 			[:context |			"A match has just been consumed, 			counting number of matches so far"			context match.			context increment.			context x = max				ifTrue: 					[context decrement.					^true].			(next matchAgainst: aMatcher)				ifFalse: 					[context x &gt;= min						ifFalse: 							[aMatcher restoreState: context originalState.							context decrement.							^false]					"				ifTrue: 					[context decrement.					^true]"].			"Unwind"			context decrement.			context depth &gt; 0 ifTrue: [^true].			^alternative matchAgainst: aMatcher]</body></methods><methods><class-id>RxmRepeat</class-id> <category>printing</category><body package="Regex11">printOccurencesOn: aStream	aStream		nextPutAll: (min ifNil: [''] ifNotNil: [min printString]);		nextPut: $,;		nextPutAll: (max ifNil: [''] ifNotNil: [max printString])</body></methods><methods><class-id>RxmRepeat</class-id> <category>accessing</category><body package="Regex11">min	^min</body><body package="Regex11">min: anObject	min := anObject</body></methods><methods><class-id>RxRepetitionsParser</class-id> <category>initialize-release</category><body package="Regex11">initialize: aStream 	source := aStream.	elements := OrderedCollection new.</body></methods><methods><class-id>RxRepetitionsParser</class-id> <category>parsing</category><body package="Regex11">parse	elements add: (source upToAll: ',').	source atEnd		ifFalse: 			[source skip: 1.			elements add: source upToEnd].	^elements</body></methods><methods><class-id>RxRepetitionsParser class</class-id> <category>instance </category><body package="Regex11">on: aStream	^self new initialize: aStream</body></methods><methods><class-id>RmRepeatContext</class-id> <category>accessing</category><body package="Regex11">decrement	depth := depth - 1.</body><body package="Regex11">depth	^depth</body><body package="Regex11">increment	depth := depth + 1.</body><body package="Regex11">match	x := x + 1.</body><body package="Regex11">originalState	^originalState</body><body package="Regex11">originalState: anObject	originalState := anObject</body><body package="Regex11">x	^x</body></methods><methods><class-id>RmRepeatContext</class-id> <category>initialize-release</category><body package="Regex11">initialize	x := 0.	depth := 0</body></methods><methods><class-id>RmRepeatContext class</class-id> <category>instance creation</category><body package="Regex11">new	^super new initialize</body></methods><methods><class-id>RxmTerminator</class-id> <category>building</category><body package="Regex11">pointTailTo: anRxmLink	"Branch tails are never redirected by the build algorithm.	Healthy terminators should never receive this."	RxParser signalCompilationException:		'internal matcher build error - redirecting terminator tail'</body><body package="Regex11">terminateWith: aTerminator	"Branch terminators are never supposed to change.	Make sure this is the case."	aTerminator ~~ self		ifTrue: [RxParser signalCompilationException:				'internal matcher build error - wrong terminator']</body></methods><methods><class-id>RxmTerminator</class-id> <category>matching</category><body package="Regex11">matchAgainst: aStream	"If got here, the match is successful."	^true</body></methods><methods><class-id>RxsMessagePredicate</class-id> <category>accessing</category><body package="Regex11">dispatchTo: aBuilder	"Inform the matcher of the kind of the node, and it	will do whatever it has to."	^aBuilder syntaxMessagePredicate: self</body><body package="Regex11">negated	^negated</body><body package="Regex11">selector	^selector</body></methods><methods><class-id>RxsMessagePredicate</class-id> <category>initialize-release</category><body package="Regex11">initializeSelector: aSelector	"The selector must be a one-argument message understood by Character."	selector := aSelector</body><body package="Regex11">initializeSelector: aSelector negated: aBoolean	"The selector must be a one-argument message understood by Character."	selector := aSelector.	negated := aBoolean</body></methods><methods><class-id>RxmSpecial</class-id> <category>matching</category><body package="Regex11">matchAgainst: aMatcher	"Match without consuming any input, if the matcher is	in appropriate state."	^(aMatcher perform: matchSelector)		and: [next matchAgainst: aMatcher]</body></methods><methods><class-id>RxmSpecial</class-id> <category>initialize-release</category><body package="Regex11">beBeginningOfLine	matchSelector := #atBeginningOfLine</body><body package="Regex11">beBeginningOfWord	matchSelector := #atBeginningOfWord</body><body package="Regex11">beEndOfLine	matchSelector := #atEndOfLine</body><body package="Regex11">beEndOfWord	matchSelector := #atEndOfWord</body><body package="Regex11">beNotWordBoundary	matchSelector := #notAtWordBoundary</body><body package="Regex11">beWordBoundary	matchSelector := #atWordBoundary</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>VB-regex</category><body package="Regex11">allRangesOfRegexMatches: rxString	^rxString asRegex matchingRangesIn: self</body><body package="Regex11">allRegexMatches: rxString	^rxString asRegex matchesIn: self</body><body package="Regex11">asRegex	"Compile the receiver as a regex matcher. May raise RxParser&gt;&gt;syntaxErrorSignal	or RxParser&gt;&gt;compilationErrorSignal.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^RxParser preferredMatcherClass for: (RxParser new parse: self)</body><body package="Regex11">asRegexIgnoringCase	"Compile the receiver as a regex matcher. May raise RxParser&gt;&gt;syntaxErrorSignal	or RxParser&gt;&gt;compilationErrorSignal.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^RxParser preferredMatcherClass		for: (RxParser new parse: self)		ignoreCase: true</body><body package="Regex11">copyWithRegex: rxString matchesReplacedWith: aString	^rxString asRegex		copy: self replacingMatchesWith: aString</body><body package="Regex11">copyWithRegex: rxString matchesTranslatedUsing: aBlock	^rxString asRegex		copy: self translatingMatchesUsing: aBlock</body><body package="Regex11">matchesRegex: regexString	"Test if the receiver matches a regex.  May raise RxParser&gt;&gt;regexErrorSignal or	child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegex matches: self</body><body package="Regex11">matchesRegexIgnoringCase: regexString	"Test if the receiver matches a regex.  May raise RxParser&gt;&gt;regexErrorSignal or	child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegexIgnoringCase matches: self</body><body package="Regex11">prefixMatchesRegex: regexString	"Test if the receiver's prefix matches a regex.		May raise RxParser class&gt;&gt;regexErrorSignal or child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegex matchesPrefix: self</body><body package="Regex11">prefixMatchesRegexIgnoringCase: regexString	"Test if the receiver's prefix matches a regex.		May raise RxParser class&gt;&gt;regexErrorSignal or child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegexIgnoringCase matchesPrefix: self</body><body package="Regex11">regex: rxString matchesCollect: aBlock	^rxString asRegex matchesIn: self collect: aBlock</body><body package="Regex11">regex: rxString matchesDo: aBlock	^rxString asRegex matchesIn: self do: aBlock</body><body package="Regex11">replaceRegex: regularExpressionString usingBlock: replacementBlock ifMatchedDo: matchedBlock	"This vaguely emulates the Ruby gsub method, which takes a regular expression as input and returns a substituted version. It also allows \0, \1 .. \9 in the substituting string as references to the whole match, or the match for the 1st .. 9th parenthesized subexpression in the original matcher. The replacementBlock can take no arguments, one argument (the match) or two (the match + the matcher). The matchedBlock lets us evaluate a final block if a match is found."	| matcher matched result |	matcher := regularExpressionString asRegex.	matched := false.	result := matcher copy: self translatingMatchesUsing: [:match | 		matched := true.		replacementBlock cull: match cull: matcher].	^matched ifTrue: [matchedBlock cull: result] ifFalse: [result]</body><body package="Regex11">replaceRegex: regularExpressionString withString: replacementString	"This vaguely emulates the Ruby gsub method, which takes a regular expression as input and returns a substituted version. It also allows \0, \1 .. \9 in the substituting string as references to the whole match, or the match for the 1st .. 9th parenthesized subexpression in the original matcher."	^self replaceRegex: regularExpressionString withString: replacementString ifMatchedDo: [:result | result].</body><body package="Regex11">replaceRegex: regularExpressionString withString: replacementString ifMatchedDo: matchedBlock	"This vaguely emulates the Ruby gsub method, which takes a regular expression as input and returns a substituted version. It also allows \0, \1 .. \9 in the substituting string as references to the whole match, or the match for the 1st .. 9th parenthesized subexpression in the original matcher. The matchedBlock lets us evaluate a final block if a match was found."	| subRegex block |	subRegex := '\\\d' asRegex.	block := [:match :matcher | 			subRegex				copy: replacementString				translatingMatchesUsing: [:indexMatch | matcher subexpression: indexMatch last digitValue + 1]].	^self replaceRegex: regularExpressionString usingBlock: block ifMatchedDo: matchedBlock</body></methods><initialize><class-id>RxsPredicate</class-id></initialize><initialize><class-id>RxMatcher</class-id></initialize><initialize><class-id>RxParser</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>