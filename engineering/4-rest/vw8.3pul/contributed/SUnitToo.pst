<?xml version="1.0"?><st-source><!-- Name: SUnitTooNotice: Copyright 2004 - 2013 Travis GriggsThis utility is free to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: SUnitToo is an alternate implementation to the SUnit project. It is a VisualWorks specific implementation. It tries to be as API compatible as possible with the original SUnit APIs. It's architecture is "simplified" and done in such a way that writing tools like that of SUnitToo(ls) that integrate tightly with the browser is possible.There are a variety of small differences (like that TestCase is declared in SUnit, not XProgramming). One interesting addition of note is that tests need not begin with the 'test' prefix, but can instead be tagged using a method tag (pragma) using <test>.Please publish changes on dot branches. I tend to try and stay on top of this pretty closely.Besides the near essential SUnitToo(ls) package, there is also some interesting experiment packages that go along with SUnitToo:SUnitTooCancellations - adds support for cancellable testsSUnitToo(verage) - adds support for gathering coverage information on testsDakarTesting - Supports running SUnitToo TestCases.A lengthy article was written about the original devleopment here:http://www.cincomsmalltalk.com/userblogs/travis/blogView?showComments=true&entry=3278236086Doing a search on the same blog site for SUnitToo will turn up more recent news.DbIdentifier: bear73DbTrace: 458728DbUsername: smichaelDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' ''))PackageName: SUnitTooParcel: #('SUnitToo')ParcelName: SUnitTooPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle))PrerequisiteParcels: #(#('Base VisualWorks' ''))PrintStringCache: (8.1 - 1,smichael)Version: 8.1 - 1Post-Load Block: 	[:package | Transcript show: package name , ' suggests SUnitToo(ls)'; cr]Date: 11:05:42 AM February 27, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (feb15.4) of February 27, 2015 on February 27, 2015 at 11:05:42 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SUnit</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>SUnitToo</package></attributes></name-space><class><name>FailedAssertion</name><environment>SUnit</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitPreload</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.FailedAssertion</class-id><body>I am raised when an assert: fails to pass.</body></comment><class><name>TestSuite</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourceAndDefinitions </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestSuite</class-id><body>This is a Composite of Tests. After building one, use #run to run the tests, or runUsing: [:eachTestCase | ] to have more control over how each test is run.ImplementationOn the outside, a suite is a big bag of tests. Under the hood, it actually aggregates tests by their resources. And when it then runs them, it manages the logic of bring the resources alive and shutting them down. To avoid thrashing resource startup/shutdown overhead, and to avoid contention between competing resources, it stores and executes them by resources.Unlike SUnit, it is the suite that assumes the responsibility of enumerating the individual tests (not the Results). So if one wants to change the way tests are enumerated, or how they are run, one should consider making a subclass of TestSuite, not Results.In SUnitToo, Suites do NOT gather the results. Rather you register with TestCase class to receive announcements as the results are reported. Results is an example/reference implementation of how one does that.Instance Variables	resources	&lt;Collection of &gt;	collection of test resources	tests	&lt;Dictionary of: ((IdentitySet of: TestResource) -&gt; (IdentitySet of: MethodDefinition))&gt;	method definitions for all the tests to run; we take advantage of the fact that we can create definitions for inherited test implementations. Using MethodDefinitions, rather than the tests themselves, avoids memory leak problems. The definitions are grouped in collections, keyed by collections of the TestResources that go with them</body></comment><class><name>TestCaseAnnouncement</name><environment>SUnit</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestCaseAnnouncement</class-id><body>The following comment was copied from the original comments of SUnit.Result==========================================================Each test run results in one of my subclasses being announced as the result of the test run. I have protocol for halping to qualify myself, and get at the test case for which I was run.Subclasses must implement the following messages:	accessing		addTo:Instance Variables:	definition	&lt;MethodDefinition&gt;	a definiton used to describe (indirectly) the test that was run to get this result</body></comment><class><name>Result</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Result</class-id><body>Each test run results in one of my subclasses being announced as the result of the test run. I have protocol for halping to qualify myself, and get at the test case for which I was run.Subclasses must implement the following messages:	accessing		addTo:Instance Variables:	definition	&lt;MethodDefinition&gt;	a definiton used to describe (indirectly) the test that was run to get this result</body></comment><class><name>ExceptionalResult</name><environment>SUnit</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.ExceptionalResult</class-id><body>A generic announcement for any kind of test result that is unexpected, and for which we'd like to be able to retain exception information.Instance Variables:	exception	&lt;Exception&gt;	the exception that was associatied with generating this result</body></comment><class><name>TestResource</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestResource</class-id><body>I am a singleton pattern, used to provide common long lived resources across a series of test runs.OverviewTestResources can be used to alleviate expensive resource setup for series of tests. For example, your tests may require a database connection. Reconnecting for each test, may be overly expensive, and better done just once for all of the tests.UsageCreate a subclass of me, if you want to make your own test resource. A resource is managed as a singleton. When it is activated, if necessary, it instantiates and stores in the 'current' class instance variable. The message #setUp is sent to the instance. When a suite is done, it will release the resource by sending #reset to the class, which in turn sends #tearDown to the singleton.Code in a TestCase test method then usually access the resource via a YourTestResourceClass current sendSomeMethodToItTo register your TestResource with a TestCase, you have three choices:1) Implement the message #resources on the class side of your TestCase. It should return a collection of TestResource classes.2) Add an arbitrarily named class side message to your TestCase, use the method tag &lt;resource&gt; to indicate it participates in the TestResource search. It should return a nil, a TestResourceClass, or a collection of TestResource classes.In both of the cases above, while it is common to just return a hard coded value, if your needs are more dynamic, you can certainly make computations before returning the result.3) You can have a resource for a specific test case, by using the method tag &lt;uses: #YourTestResourceClassName&gt; in your test method. You may use either a symbol, or  binding reference. We have deprecated the use of symbols in favor of binding references in 7.10.Finally, a TestResource may drag other TestResources into the picture by specifying via its class side #resources method additional resource required by the receiver.</body></comment><class><name>UnresolvedPseudoResource</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unresolved </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.UnresolvedPseudoResource</class-id><body>UnresolvedPseudoResource impersonates a resource class in a resource collection on behalf of resource class specified in a &lt;uses: &gt; pragma that could not be resolved.Instance Variables	unresolved	&lt;Symbol | BindingReference&gt;	description of unresolved</body></comment><class><name>Results</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errors passes failures </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Results</class-id><body>Results is an example/reference implementation of a result gathering mechanism. It simply records each Result in the appropriate bucket.UsageBecause the Result observes a universal object, Results can run in parallel. And different Result observers can take different kind of actions. Examples have included, interactive feedback, storing information for browser annotation, a variety of custom loggers logging different kinds of details, and coverage tracking gatherers.ImplementationAt its core, a Results is an Announcement observer. Every time a TestCase is run, the TestCase *class* posts an announcement with the result of the test. A results gatherer then, just has to observer the Result anouncement being broadcast from the TestCase class. This is done with the collectWhile: method.Instance Variables	errors	&lt;Set&gt;		failures	&lt;Set&gt;		passes	&lt;Set&gt;	</body></comment><class><name>Pass</name><environment>SUnit</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Pass</class-id><body>I'm the result that is announced when a test method is run successfully with no exceptions occuring.</body></comment><class><name>SomeError</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.SomeError</class-id><body>Announcement to indicate  an Error occured while running the test.</body></comment><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestCase</class-id><body>A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.UsageWhen you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override #tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.Implementation	See also TestResource comment. When a test is prepared to run, they are usually grouped by their response to resources. The result of the #resources query is a deterministic vector of TestResources to run that specific test. In all cases, when a TestResource is called out by a Test, that Resource's own Resources will precede it. The order of query for a TestCase is first the class side #resources method. After that, any class side &lt;resource&gt; tagged methods are visited. They are visited alphabetically, class by class, up the inheritance change. Finally, any method local resources are added.Instance Variables	testSelector	&lt;Symbol&gt;	which method represents the current test</body></comment><class><name>TestResourceUnavailable</name><environment>SUnit</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestResourceUnavailable</class-id><body>Raised when we can't get a TestResource initialized.</body></comment><class><name>Failure</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.Failure</class-id><body>I'm used to announce that a FailedAssertion occured.</body></comment><class><name>TestResourceError</name><environment>SUnit</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failingResource resourceSet originalException </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo</package></attributes></class><comment><class-id>SUnit.TestResourceError</class-id><body>Raised when any Error occurs during TestResource handling. This is distinct from a ResourceUnavailableError.</body></comment><class><name>Started</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitToo</package></attributes></class><shared-variable><name>MySubscriptions</name><environment>SUnit.TestCase</environment><private>false</private><constant>false</constant><category>subscriptions</category><initializer></initializer><attributes><package>SUnitToo</package></attributes></shared-variable><methods><class-id>SUnit.FailedAssertion</class-id> <category>sunit</category><body package="SUnitToo">occurredForTest: aTestCase 	"double dispatch back to the test"	aTestCase announceFailure: self.	self return</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>accessing</category><body package="SUnitToo">addTest: aTest		(resourceAndDefinitions		at: aTest resources		ifAbsentPut: [Set new]) add: aTest asDefinition</body><body package="SUnitToo">addTests: aCollection 	aCollection do: [:eachTest | self addTest: eachTest]</body><body package="SUnitToo">definitionsForResources: aResourceSet		^resourceAndDefinitions at: aResourceSet</body><body package="SUnitToo">initialize	resourceAndDefinitions := Dictionary new</body><body package="SUnitToo">resources	^resourceAndDefinitions keys		fold: [:a :b | TestResource appendResources: a to: b]</body><body package="SUnitToo">testCases: aSetOfDefintions randomDo: aBlock	"Backwards compatibility. To be removed soon."		^self testCasesFrom: aSetOfDefintions randomDo: aBlock</body><body package="SUnitToo">testCasesFrom: aSetOfDefinitiions do: aBlock	"This is the core enumeration point of a subset of my tests. For myself, I take the approach that random is best. Subclasses may override to change the order, or to change what is done at each point."		self testCasesFrom: aSetOfDefinitiions randomDo: aBlock</body><body package="SUnitToo">testCasesFrom: aSetOfDefinitions randomDo: aBlock	"Enumerate the TestCases in aCollection in a random order. We keep a class variable to use the same random, that creating a new random each time, which is less random. This is the encouraged enumeration strategy. It makes sure that coupling errors don't accrue from running the tests in the same order each time."		| methods a b random |	random := self class random.	methods := aSetOfDefinitions asArray.	methods size * 3		timesRepeat:			[a := (random next * methods size) ceiling max: 1.			b := (random next * methods size) ceiling max: 1.			methods swap: a with: b].	methods do: [:each | aBlock value: each asTestCase]</body><body package="SUnitToo">testCount		self isEmpty ifTrue: [^0].	^(resourceAndDefinitions collect: [:each | each size])		fold: [:a :b | a + b]</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>testing</category><body package="SUnitToo">isEmpty	^resourceAndDefinitions isEmpty</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>running</category><body package="SUnitToo">run	^self runTests</body><body package="SUnitToo">runTests	^self runUsing: [:each | each run]</body><body package="SUnitToo">runUsing: aBlock	"Run the suite through the tests, group them by resources which are are setup and reset for each grouping, but randomize their enumeration otherwise. aBlock is where the the test should actually be run."	^Results collectWhile: 			[resourceAndDefinitions keysAndValuesDo: 					[:resourceSet :definitions |					| allAvailable capturedEach |										[allAvailable := resourceSet allSatisfy: 									[:each |									capturedEach := each.									each isAvailable]]							on: Error							do: 								[:ex |								resourceSet reverseDo: [:each | each reset].								(TestResourceError newException)									failingResource: capturedEach;									resourceSet: resourceSet;									originalException: ex;									raiseSignal].					allAvailable						ifNotNil: 							[							[allAvailable								ifFalse: [TestResourceUnavailable raiseRequestWith: resourceSet]								ifTrue: [self testCasesFrom: definitions do: aBlock]]									ensure: [resourceSet reverseDo: [:each | each reset]]]]]</body></methods><methods><class-id>SUnit.TestSuite</class-id> <category>obsolete</category><body package="SUnitToo">checkForResources	self resources 		do: [:res | res isAvailable ifFalse: [res signalInitializationError]]</body></methods><methods><class-id>SUnit.TestSuite class</class-id> <category>instance creation</category><body package="SUnitToo">new	^super new initialize</body></methods><methods><class-id>SUnit.TestSuite class</class-id> <category>private</category><body package="SUnitToo">random	^random ifNil: [random := Random standard]</body></methods><methods><class-id>SUnit.TestCaseAnnouncement</class-id> <category>initialize-release</category><body package="SUnitToo">testCase: aTestCase 	definition := aTestCase asDefinition</body></methods><methods><class-id>SUnit.TestCaseAnnouncement</class-id> <category>comparing</category><body package="SUnitToo">= aResult 	^self class == aResult class and: [definition = aResult definition]</body><body package="SUnitToo">hash	^definition hash</body></methods><methods><class-id>SUnit.TestCaseAnnouncement</class-id> <category>accessing</category><body package="SUnitToo">addTo: aResults 	self subclassResponsibility</body><body package="SUnitToo">asTestCase	^definition asTestCase</body><body package="SUnitToo">definition	^definition</body><body package="SUnitToo">definition: anObject	definition := anObject</body><body package="SUnitToo">method	^definition method</body></methods><methods><class-id>SUnit.TestCaseAnnouncement class</class-id> <category>instance creation</category><body package="SUnitToo">testCase: aTestCase 	^self new testCase: aTestCase</body></methods><methods><class-id>SUnit.Result</class-id> <category>accessing</category><body package="SUnitToo">addTo: aResults 	self subclassResponsibility</body><body package="SUnitToo">asTestCase	^definition asTestCase</body><body package="SUnitToo">definition	^definition</body><body package="SUnitToo">definition: anObject	definition := anObject</body><body package="SUnitToo">method	^definition method</body></methods><methods><class-id>SUnit.Result</class-id> <category>initialize-release</category><body package="SUnitToo">testCase: aTestCase 	definition := aTestCase asDefinition</body></methods><methods><class-id>SUnit.Result</class-id> <category>comparing</category><body package="SUnitToo">= aResult 	^self class == aResult class and: [definition = aResult definition]</body><body package="SUnitToo">hash	^definition hash</body></methods><methods><class-id>SUnit.Result class</class-id> <category>instance creation</category><body package="SUnitToo">testCase: aTestCase 	^self new testCase: aTestCase</body></methods><methods><class-id>SUnit.ExceptionalResult</class-id> <category>accessing</category><body package="SUnitToo">exception	^exception</body><body package="SUnitToo">exception: anObject	exception := anObject</body></methods><methods><class-id>SUnit.ExceptionalResult</class-id> <category>copying</category><body package="SUnitToo">postCopy	super postCopy.	exception := nil</body></methods><methods><class-id>SUnit.TestResource</class-id> <category>Running</category><body package="SUnitToo">setUp	"Does nothing. Subclasses should override this	to initialize their resource"</body><body package="SUnitToo">signalInitializationError	^self class signalInitializationError</body><body package="SUnitToo">tearDown	"Does nothing. Subclasses should override this	to tear down their resource"</body></methods><methods><class-id>SUnit.TestResource</class-id> <category>Testing</category><body package="SUnitToo">isAvailable	"override to provide information on the	readiness of the resource"		^true</body><body package="SUnitToo">isUnavailable	"override to provide information on the	readiness of the resource"		^self isAvailable not</body></methods><methods><class-id>SUnit.TestResource</class-id> <category>Init / Release</category><body package="SUnitToo">initialize	self setUp</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>testing</category><body package="SUnitToo">isAbstract	"Override to true if a TestResource subclass is Abstract and should not have	TestCase instances built from it"	^self == TestResource</body><body package="SUnitToo">isAvailable	^self current notNil and: [self current isAvailable]</body><body package="SUnitToo">isUnavailable	^self isAvailable not</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>accessing</category><body package="SUnitToo">current	current isNil		ifTrue: [current := self new].	^current</body><body package="SUnitToo">current: aTestResource	current := aTestResource</body><body package="SUnitToo">reset		current notNil ifTrue: [[current tearDown] ensure: [current := nil]]</body><body package="SUnitToo">resources	"A Resource can bring in other resource (prerequisite resources basically) by return a collection of resources here that should be used in addition to the receiver."		^#()</body><body package="SUnitToo">signalInitializationError	TestResourceUnavailable raiseSignal</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>instance creation</category><body package="SUnitToo">new	^super new initialize</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>private</category><body package="SUnitToo">appendResources: aResourceCollection to: aSequence	"Given aSequence, return a copy that has aResourceCollection AND all of its recursive resources added to aSequence. Avoid cycles and don't add duplicates. This is done as a utility method, because we can reuse the algorithm, and feed SUnit classic resources thru it as well."	| toAdd stack |	toAdd := OrderedCollection new.	stack := OrderedCollection withAll: aResourceCollection.	[stack isEmpty] whileFalse: 			[| next |			next := stack removeLast.			(toAdd includes: next)				ifFalse: 					[toAdd addFirst: next.					stack addAll: next resources]].	^aSequence , toAdd</body></methods><methods><class-id>SUnit.UnresolvedPseudoResource</class-id> <category>actions</category><body package="SUnitToo">reset	^true</body></methods><methods><class-id>SUnit.UnresolvedPseudoResource</class-id> <category>accessing</category><body package="SUnitToo">name	^'(unresolved resource ', unresolved printString, ')'</body><body package="SUnitToo">resources	^#()</body><body package="SUnitToo">unresolved	^unresolved</body><body package="SUnitToo">unresolved: aSymbolOrBindingRef	unresolved := aSymbolOrBindingRef</body></methods><methods><class-id>SUnit.UnresolvedPseudoResource</class-id> <category>printing</category><body package="SUnitToo">printOn: aStream	super printOn: aStream.	aStream nextPut: $(;		print: unresolved;		nextPut: $)</body></methods><methods><class-id>SUnit.UnresolvedPseudoResource</class-id> <category>testing</category><body package="SUnitToo">isAvailable	^false</body></methods><methods><class-id>SUnit.UnresolvedPseudoResource class</class-id> <category>instance creation</category><body package="SUnitToo">new	^super new</body><body package="SUnitToo">newForUnresolved: aSymbolOrBindingRef	^self new		unresolved: aSymbolOrBindingRef</body></methods><methods><class-id>SUnit.Results</class-id> <category>accessing</category><body package="SUnitToo">addError: aResult 	errors add: aResult</body><body package="SUnitToo">addFailure: aResult 	failures add: aResult</body><body package="SUnitToo">addPass: aResult 	passes add: aResult</body><body package="SUnitToo">addResult: aResult 	aResult copy addTo: self</body><body package="SUnitToo">cease	TestCase unsubscribe: self</body><body package="SUnitToo">collect	TestCase 		when: Result		send: #addResult:		to: self</body><body package="SUnitToo">collectWhile: aBlock 	self collect.	aBlock ensure: [self cease]</body><body package="SUnitToo">defects	^(OrderedCollection new)		addAll: self errors;		addAll: self failures;		yourself</body><body package="SUnitToo">errors	^errors</body><body package="SUnitToo">errorsCount	^errors size</body><body package="SUnitToo">failedCount	^failures size</body><body package="SUnitToo">failures	^failures</body><body package="SUnitToo">passCount	^passes size</body><body package="SUnitToo">passes	^passes</body><body package="SUnitToo">ranCount	^self passCount + self failedCount + self errorsCount</body></methods><methods><class-id>SUnit.Results</class-id> <category>testing</category><body package="SUnitToo">allPassed	^self hasErrors not and: [self hasFailures not]</body><body package="SUnitToo">hasErrors	^errors notEmpty</body><body package="SUnitToo">hasFailures	^failures notEmpty</body><body package="SUnitToo">isEmpty	^self ranCount isZero</body></methods><methods><class-id>SUnit.Results</class-id> <category>bw compat SUnit APIs</category><body package="SUnitToo">errorCount	^self errorsCount</body><body package="SUnitToo">failureCount	^self failedCount</body><body package="SUnitToo">runCount	^self ranCount</body></methods><methods><class-id>SUnit.Results</class-id> <category>initialize-release</category><body package="SUnitToo">initialize	errors := Set new.	passes := Set new.	failures := Set new</body></methods><methods><class-id>SUnit.Results</class-id> <category>printing</category><body package="SUnitToo">countSelectors	^#(#ranCount #failedCount #errorsCount)</body><body package="SUnitToo">printOn: aStream	aStream		nextPutAll:			(self allPassed				ifTrue: ['Passed: ']				ifFalse: ['Failed: ']).	(self countSelectors reject: [:each | (self perform: each) isZero])		do:			[:each | 			aStream				print: (self perform: each);				space;				nextPutAll: (each allButLast: 'Count' size)]		separatedBy: [aStream nextPutAll: ', ']</body></methods><methods><class-id>SUnit.Results class</class-id> <category>instance creation</category><body package="SUnitToo">collectWhile: aBlock 	^self new collectWhile: aBlock</body><body package="SUnitToo">new	^super new initialize</body></methods><methods><class-id>SUnit.Pass</class-id> <category>accessing</category><body package="SUnitToo">addTo: aResults 	aResults addPass: self</body></methods><methods><class-id>SUnit.SomeError</class-id> <category>accessing</category><body package="SUnitToo">addTo: aResults 	aResults addError: self</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>accessing</category><body package="SUnitToo">assert: aBoolean 	aBoolean ifFalse: [self signalFailure: 'Assertion failed']</body><body package="SUnitToo">deny: aBoolean	self assert: aBoolean not</body><body package="SUnitToo">method	^(self class findSelector: testSelector) ifNotNil: [:pair | pair last]</body><body package="SUnitToo">resources	"Compute all of the resources necessary for this specific test, avoid duplicates, but otherwise keep the order (depth first) (i.e. don't use a Set). Do not override this message. See the class comment for TestResource for instructions on how to add resources."	| resources |	resources := Array new.	resources := TestResource appendResources: self methodLocalResources to: resources.	resources := TestResource appendResources: self class allResources to: resources.	^resources</body><body package="SUnitToo">selector	^testSelector</body><body package="SUnitToo">should: aBlock	self assert: aBlock value</body><body package="SUnitToo">should: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent)</body><body package="SUnitToo">shouldnt: aBlock	self deny: aBlock value</body><body package="SUnitToo">shouldnt: aBlock raise: anExceptionalEvent 	^self assert: (self assertBlock: aBlock raises: anExceptionalEvent) not</body><body package="SUnitToo">signalFailure: aString 	FailedAssertion raiseSignal: aString</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>initialize-release</category><body package="SUnitToo">setUp</body><body package="SUnitToo">tearDown</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>private</category><body package="SUnitToo">assertBlock: aBlock raises: anExceptionalEvent 	^	[aBlock value.	false] on: anExceptionalEvent do: [:ex | ex return: true]</body><body package="SUnitToo">methodLocalResources	| specificResources method classRef |	specificResources := #().	method := self asDefinition method.	method attributeMessages		ifNotNil: 			[:methodTags |			methodTags do: 					[:eachTag |					eachTag selector = #uses:						ifTrue: 							[classRef := eachTag arguments first.							classRef isSymbol								ifTrue: 									[classRef := self resolveResourceFromSymbol: classRef inMethod: method].							classRef								ifDefinedDo: [:resource | specificResources := specificResources copyWith: resource] 								elseDo: [specificResources := specificResources copyWith: (UnresolvedPseudoResource newForUnresolved: classRef path last)]]]].	^specificResources</body><body package="SUnitToo">performTest	self perform: testSelector</body><body package="SUnitToo">resolveResourceFromSymbol: aSymbol inMethod: method	| binding |	self deprecated: #(#version '7.10' #sunset '8.0' #use 'binding ref instead of symbol in uses: pragma').	binding := (method mclass instanceBehavior bindingFor: aSymbol) ifNil: [method environment bindingFor: aSymbol].	^binding notNil		ifTrue: [binding value fullyQualifiedReference]		ifFalse: [BindingReference path: (Array with: #UndefinedUndefinedUndefined with: aSymbol)]</body><body package="SUnitToo">setTestSelector: aSymbol 	testSelector := aSymbol asSymbol</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>comparing</category><body package="SUnitToo">= aTestCase 	^self class == aTestCase class and: [testSelector == aTestCase selector]</body><body package="SUnitToo">hash	^testSelector hash bitXor: self class hash</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>running</category><body package="SUnitToo">debug	"this is for legacy support really, the debug mode in the tool is just happy to just use run, but some may have used this as a hook, so we forward that here"	^self run</body><body package="SUnitToo">doTestCycle		[self setUp.	self performTest] ensure: [self tearDown]</body><body package="SUnitToo">handledExceptions	^Error , FailedAssertion</body><body package="SUnitToo">run	"If we use a double dispatch pattern here, we can (A) reduce the number of nested blocks (B) make it easier for people's custom exceptions to do 'interesting' things for test case occurence -- Much thanks to Andres Valloud for suggesting this."		[self announceStarted.	self doTestCycle.	self announcePass]			on: self handledExceptions			do: [:ex | ex occurredForTest: self]</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>announcements</category><body package="SUnitToo">announceError: anException 	TestCase announce: ((SomeError testCase: self) exception: anException)</body><body package="SUnitToo">announceFailure: anException 	TestCase announce: ((Failure testCase: self) exception: anException)</body><body package="SUnitToo">announcePass	TestCase announce: (Pass testCase: self)</body><body package="SUnitToo">announceStarted	TestCase announce: (Started testCase: self)</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>converting</category><body package="SUnitToo">asDefinition	^(MethodDefinition class: self class selector: testSelector) resolve</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>backwards compatibility</category><body package="SUnitToo">assert: aBoolean description: aString	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnitToo">assert: aBoolean description: aString resumable: resumableBoolean	aBoolean ifFalse: [self signalFailure: aString]</body><body package="SUnitToo">assert: anObject equals: anotherObject	self assert: anObject = anotherObject		description: anObject printString, ' is not equal to ', anotherObject printString.</body><body package="SUnitToo">deny: aBoolean description: aString	self assert: aBoolean not description: aString</body><body package="SUnitToo">deny: aBoolean description: aString resumable: resumableBoolean	self assert: aBoolean not description: aString resumable: resumableBoolean</body><body package="SUnitToo">should: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent)		description: aString.</body><body package="SUnitToo">shouldnt: aBlock raise: anExceptionalEvent description: aString	self		assert: (self assertBlock: aBlock raises: anExceptionalEvent) not		description: aString.</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>instance creation</category><body package="SUnitToo">selector: aSymbol 	^self new setTestSelector: aSymbol</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>announcements</category><body package="SUnitToo">noResultsWhile: aBlock 	self subscriptionRegistry allSubscriptions suspendWhile: aBlock</body><body package="SUnitToo">subscriptionRegistry: newRegistry 	MySubscriptions := newRegistry</body><body package="SUnitToo">subscriptionRegistryOrNil	^MySubscriptions</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>testing</category><body package="SUnitToo">isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^subclasses size ~= 0</body><body package="SUnitToo">isTestCase	^true</body><body package="SUnitToo">needsComment	"TestCases aren't usually commented"	^false</body><body package="SUnitToo">shouldInheritSelectors	"This deviates from classic SUnit (for now). I don't care for the 'guesses' it makes. With the SUnit one, you can have an empty class one minute which is inheriting, decide you need to add a specific test, and suddenly you quit inheriting, unless you flip this switch. That kind of coupled logic is just wrong."	^self inheritsFrom: TestCase</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>test case support</category><body package="SUnitToo">looksLikeTestMethod: aCompiledMethod selector: aMethodSelector	^(aMethodSelector copyFrom: 1 to: (4 min: aMethodSelector size)) = 'test'		or: [aCompiledMethod hasAttributeSelector: #test]</body><body package="SUnitToo">looksLikeTestSelector: aMethodSelector 	^(aMethodSelector copyFrom: 1 to: (4 min: aMethodSelector size)) = 'test'</body><body package="SUnitToo">testSelectorsDo: aBlock 	self testSelectorsDo: aBlock skipping: IdentitySet new</body><body package="SUnitToo">testSelectorsDo: aBlock skipping: aCollection	self == TestCase ifTrue: [^self].	self selectorsAndMethodsDo: 			[:eachSelector :eachMethod |			(self looksLikeTestMethod: eachMethod selector: eachSelector)				ifTrue: 					[(aCollection includes: eachSelector)						ifFalse: 							[aBlock cull: eachSelector cull: eachMethod.							aCollection add: eachSelector]]].	self shouldInheritSelectors		ifTrue: [superclass testSelectorsDo: aBlock skipping: aCollection]</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>accessing</category><body package="SUnitToo">resources	"Subclasses may choose to return resources here."	^#()</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>private</category><body package="SUnitToo">allResources	"Compute the union of all resources gathered either from the resources method, or from &lt;resource&gt; tagged methods. Keep them in a definitive order."	| result byMethod classToSearch visitedMethods |	result := #().	self resources do: 			[:eachResource |			result := TestResource appendResources: (Array with: eachResource)						to: result].	classToSearch := self class.	visitedMethods := Set with: #resources.	[classToSearch = TestCase class superclass] whileFalse: 			[byMethod := Pragma						allNamed: #resource						in: classToSearch						sortedUsing: [:a :b | a selector &lt; b selector].			byMethod do: 					[:eachMethodTag |					(visitedMethods includes: eachMethodTag selector)						ifFalse: 							[visitedMethods add: eachMethodTag selector.							(self perform: eachMethodTag selector) ifNotNil:								[:resources |								result := TestResource									appendResources: (resources isSequenceable										ifFalse: [Array with: resources]										ifTrue: [resources])									to: result]]].			classToSearch := classToSearch superclass].	^result</body></methods><methods><class-id>SUnit.TestResourceUnavailable</class-id> <category>accessing</category><body package="SUnitToo">resourceSet	^self parameter</body><body package="SUnitToo">resourceSet: aResourceSet	self parameter: aResourceSet</body></methods><methods><class-id>SUnit.TestResourceUnavailable class</class-id> <category>testing</category><body package="SUnitToo">mayResume	^true</body></methods><methods><class-id>SUnit.Failure</class-id> <category>accessing</category><body package="SUnitToo">addTo: aResults 	aResults addFailure: self</body></methods><methods><class-id>SUnit.TestResourceError</class-id> <category>accessing</category><body package="SUnitToo">failingResource	^failingResource</body><body package="SUnitToo">failingResource: anObject	failingResource := anObject</body><body package="SUnitToo">originalException	^originalException</body><body package="SUnitToo">originalException: anObject	originalException := anObject</body><body package="SUnitToo">parameter	"backwards compatibility"	^self resourceSet</body><body package="SUnitToo">resourceSet	^resourceSet</body><body package="SUnitToo">resourceSet: anObject	resourceSet := anObject</body></methods><methods><class-id>SUnit.TestResourceError</class-id> <category>initialize-release</category><body package="SUnitToo">parameter: aResourceSet	"backwards compatibility"	^self resourceSet: aResourceSet</body></methods><methods><class-id>SUnit.TestResourceError class</class-id> <category>testing</category><body package="SUnitToo">mayResume	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>testing</category><body package="SUnitToo">hasAttributeSelector: aSymbol 	^self attributeMessages anySatisfy: [:each | each selector = aSymbol]</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>converting</category><body package="SUnitToo">asTestCase	^inheritingClass selector: selector</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SUnitToo">hasAttributeSelector: nope 	^false</body></methods><methods><class-id>Core.Error</class-id> <category>sunit</category><body package="SUnitToo">occurredForTest: aTestCase 	"double dispatch back to the test"	aTestCase announceError: self.	self return</body></methods><methods><class-id>Core.Object class</class-id> <category>testing</category><body package="SUnitToo">isTestCase	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SUnitToo">isTestCase	^self class isTestCase</body></methods><methods><class-id>Kernel.AnnotatedMethod</class-id> <category>accessing</category><body package="SUnitToo">hasAttributeSelector: aSymbol 	^self attributeMessages anySatisfy: [:each | each selector = aSymbol]</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>private</category><body package="SUnitToo">testMethodTags	"Any method tagged with a &lt;test&gt; pragma is considered a test selector candidate"	"&lt;uses:&gt; tags are used to compute instance specific resources for the tagged test. The argument is a symbol for the class name, or a binding reference to the same."	&lt;pragmas: #instance&gt;	^#(#test #uses:)</body><body package="SUnitToo">testResourceTags	"Any method tagged with a &lt;test&gt; pragma is considered a test selector candidate"	"&lt;resource:&gt; tags are used to compute instance specific resources for the tagged test. The argument is a symbol for the class name, or a binding reference to the same."	&lt;pragmas: #class&gt;	^#(#resource)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProbedAnnotatedMethod</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbedCompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>AnnotatedMethod</name><environment>Kernel</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class></st-source>