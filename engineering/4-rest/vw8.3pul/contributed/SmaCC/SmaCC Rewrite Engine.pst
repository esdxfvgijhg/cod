<?xml version="1.0"?><st-source><!-- Name: SmaCC Rewrite EngineNotice: Comment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains code that can be used to rewrite items parsed by SmaCC.If you want more information about SmaCC, visit http://www.refactoryworkers.com/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2010 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: bear73DbTrace: 317933DevelopmentPrerequisites: #(#(#any 'SmaCC Runtime' '') #(#any 'SmaCC Source Editing' '') #(#any 'Browser-Parser' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: SmaCC Rewrite EngineParcel: #('SmaCC Rewrite Engine')PrerequisiteParcels: #(#('SmaCC Runtime' '') #('SmaCC Source Editing' '') #('Browser-Parser' ''))PrintStringCache: (2.0.3,brant)Version: 2.0.3Date: 9:56:25 AM January 28, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:56:25 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SmaCCRewriteTransformation</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rewrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteMatchContext</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rewriteEngine match nodes strings continuation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteMatch</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rewrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteTypeMatch</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRewriteMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeClass code method enableDebug </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteCodeTransformation</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRewriteTransformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteResult</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename errorString type startLine startColumn interval transformation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteLink</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rewrite next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteStringTransformation</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRewriteTransformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string expression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCReplaceExpression</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCNodeReplaceExpression</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReplaceExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beforeWhitespace beforePrefix prefix name postfix afterPostfix afterWhitespace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCAbstractRewrite</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewrite</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAbstractRewrite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment match transformation engine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteTreeMatch</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRewriteMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startingState source trees </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCCompositeReplaceExpression</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReplaceExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expressions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteAnnotation</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeClass nodeInterval rewrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCReplaceExpressionVisitor</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParseNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteFile</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAbstractRewrite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename rewrites parserClass isModified timestamp cachedLists </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteCompleteResult</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRewriteResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputSource outputSource transformedString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCReplaceExpressionParser</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteEngine</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rewriteRule source newStarts newStops properties processedNodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteRuleFileScanner</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCStringReplaceExpression</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReplaceExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCAnnotatedStringInterval</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCStringInterval</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annotations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteProcessor</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rules parserClass inputDirectory outputDirectory files validationParserClass rewriteEngine baseDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCAnnotatedString</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCString</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node rule </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCCodeReplaceExpression</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReplaceExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCTransformationToolkitModel</name><environment>Refactory.SmaCC</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified files inputParserClass validationParserClass rewrites outputDirectory server runOnServer createSubdirectories </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCRewriteRuleFileParser</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><class><name>SmaCCReplaceExpressionScanner</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Rewrite Engine</category><attributes><package>SmaCC Rewrite Engine</package></attributes></class><shared-variable><name>Continue</name><environment>Refactory.SmaCC.SmaCCRewriteMatchContext</environment><private>false</private><constant>false</constant><category>variables</category><attributes><package>SmaCC Rewrite Engine</package></attributes></shared-variable><shared-variable><name>HaltBlock</name><environment>Refactory.SmaCC.SmaCCRewriteProcessor</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Rewrite Engine</package></attributes></shared-variable><shared-variable><name>Debug</name><environment>Refactory.SmaCC.SmaCCRewriteProcessor</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Rewrite Engine</package></attributes></shared-variable><methods><class-id>Refactory.SmaCC.SmaCCRewriteTransformation</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="modified">modified	rewrite notNil ifTrue: [rewrite modified]</body><body package="SmaCC Rewrite Engine" selector="rewrite">rewrite	^rewrite</body><body package="SmaCC Rewrite Engine" selector="rewrite:">rewrite: aSmaCCRewrite	rewrite := aSmaCCRewrite</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTransformation</class-id> <category>transforming</category><body package="SmaCC Rewrite Engine" selector="transformUsingContext:">transformUsingContext: aSmaCCRewriteMatchContext	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTransformation</class-id> <category>copying</category><body package="SmaCC Rewrite Engine" selector="postCopy">postCopy	super postCopy.	rewrite := nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTransformation</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext</class-id> <category>source editing</category><body package="SmaCC Rewrite Engine" selector="addNewlineWhitespace:to:">addNewlineWhitespace: aString to: source	| outputStream inputStream |	(aString notNil and: [aString notEmpty]) ifFalse: [^source].	outputStream := WriteStream on: String new.	inputStream := ReadStream on: source asString.	[inputStream atEnd]		whileFalse:			[| char endOfLine |			endOfLine := false.			char := inputStream next.			char = Character lf ifTrue: [endOfLine := true].			char = Character cr				ifTrue:					[endOfLine := true.					inputStream peek = Character lf						ifTrue:							[outputStream nextPut: char.							char := inputStream next]].			outputStream nextPut: char.			endOfLine ifTrue: [outputStream nextPutAll: aString]].	^outputStream contents</body><body package="SmaCC Rewrite Engine" selector="delete:">delete: anObject	| start stop |	start := self startIndexFor: anObject.	stop := self stopIndexFor: anObject.	self deleteFrom: start to: stop</body><body package="SmaCC Rewrite Engine" selector="deleteAll:">deleteAll: aCollection	aCollection isNil ifTrue: [^self].	aCollection do: [:each | self delete: each]</body><body package="SmaCC Rewrite Engine" selector="deleteAllWithWhitespaceAfter:">deleteAllWithWhitespaceAfter: aCollection	aCollection isNil ifTrue: [^self].	aCollection do: [:each | self deleteWithWhitespaceAfter: each]</body><body package="SmaCC Rewrite Engine" selector="deleteAllWithWhitespaceBefore:">deleteAllWithWhitespaceBefore: aCollection	aCollection isNil ifTrue: [^self].	aCollection do: [:each | self deleteWithWhitespaceBefore: each]</body><body package="SmaCC Rewrite Engine" selector="deleteFrom:to:">deleteFrom: start to: stop	| startIndex stopIndex |	startIndex := self startIndexFor: start.	stopIndex := self stopIndexFor: stop.	(startIndex isNil or: [stopIndex isNil]) ifTrue: [^self].	self source deleteFrom: startIndex to: stopIndex</body><body package="SmaCC Rewrite Engine" selector="deleteWhitespaceAfter:">deleteWhitespaceAfter: anObject	| anIndex |	anIndex := self stopIndexFor: anObject.	self source deleteWhitespaceAfterIndex: anIndex</body><body package="SmaCC Rewrite Engine" selector="deleteWhitespaceBefore:">deleteWhitespaceBefore: anObject	| anIndex |	anIndex := self startIndexFor: anObject.	self source deleteWhitespaceBeforeIndex: anIndex</body><body package="SmaCC Rewrite Engine" selector="deleteWithWhitespaceAfter:">deleteWithWhitespaceAfter: anObject	self deleteWhitespaceAfter: anObject.	self delete: anObject</body><body package="SmaCC Rewrite Engine" selector="deleteWithWhitespaceBefore:">deleteWithWhitespaceBefore: anObject	self deleteWhitespaceBefore: anObject.	self delete: anObject</body><body package="SmaCC Rewrite Engine" selector="insert:after:">insert: aString after: anObject	| position endPosition anIndex |	anIndex := self stopIndexFor: anObject.	anIndex isNil ifTrue: [^nil].	position := self source insert: aString asString at: (self source nextIndex: anIndex).	position isNil ifTrue: [^nil].	endPosition := position + (aString size - 1).	self		updateStopPositionFor: ((anObject isKindOf: SmaCCParseNode) ifTrue: [anObject] ifFalse: [match])		to: endPosition		whenEqualTo: anIndex.	^position</body><body package="SmaCC Rewrite Engine" selector="insert:afterAll:">insert: aString afterAll: aCollection	aCollection isNil ifTrue: [^self].	aCollection do: [:each | self insert: aString after: each]</body><body package="SmaCC Rewrite Engine" selector="insert:around:">insert: aSequenceableCollection around: aNode	self insert: aSequenceableCollection first before: aNode.	self insert: aSequenceableCollection last after: aNode</body><body package="SmaCC Rewrite Engine" selector="insert:before:">insert: aString before: anObject	| position anIndex |	anIndex := self startIndexFor: anObject.	anIndex isNil ifTrue: [^nil].	position := self source insert: aString at: anIndex.	rewriteEngine		updateStartPositionFor: ((anObject isKindOf: SmaCCParseNode) ifTrue: [anObject] ifFalse: [match])		to: position		whenEqualTo: anIndex.	^position</body><body package="SmaCC Rewrite Engine" selector="insert:beforeAll:">insert: aString beforeAll: aCollection	aCollection isNil ifTrue: [^self].	aCollection do: [:each | self insert: aString before: each]</body><body package="SmaCC Rewrite Engine" selector="move:after:">move: anObject after: anotherObject	^self		move: anObject		after: anotherObject		withWhitespace: ''</body><body package="SmaCC Rewrite Engine" selector="move:after:withWhitespace:">move: anObject after: anotherObject withWhitespace: aString	| start stop oldStop |	start := self startIndexFor: anObject.	stop := self stopIndexFor: anObject.	oldStop := self stopIndexFor: anotherObject.	self source		moveFrom: start		to: stop		after: oldStop.	aString notEmpty		ifTrue:			[self source				addNewLineWhitespace: aString				from: start				to: stop].	rewriteEngine		updateStopPositionFor: ((anotherObject isKindOf: SmaCCParseNode) ifTrue: [anotherObject] ifFalse: [match])		to: stop		whenEqualTo: oldStop.	^self startIndexFor: anotherObject</body><body package="SmaCC Rewrite Engine" selector="move:before:">move: anObject before: anotherObject	^self		move: anObject		before: anotherObject		withWhitespace: ''</body><body package="SmaCC Rewrite Engine" selector="move:before:withWhitespace:">move: anObject before: anotherObject withWhitespace: aString	| start stop oldStart |	start := self startIndexFor: anObject.	stop := self stopIndexFor: anObject.	oldStart := self startIndexFor: anotherObject.	self source		moveFrom: start		to: stop		before: oldStart.	aString notEmpty		ifTrue:			[self source				addNewLineWhitespace: aString				from: start				to: stop].	rewriteEngine		updateStartPositionFor: ((anotherObject isKindOf: SmaCCParseNode) ifTrue: [anotherObject] ifFalse: [match])		to: start		whenEqualTo: oldStart.	^self startIndexFor: anObject</body><body package="SmaCC Rewrite Engine" selector="move:replacing:withWhitespace:">move: anObject replacing: anotherObject withWhitespace: aString	| oldStop |	oldStop := self stopIndexFor: anotherObject.	self		move: anObject		after: anotherObject		withWhitespace: aString.	self deleteFrom: (self startIndexFor: anotherObject) to: oldStop.	^self startIndexFor: anObject</body><body package="SmaCC Rewrite Engine" selector="moveFrom:to:after:">moveFrom: startIndex to: stopIndex after: anObject	^self source		moveFrom: (self startIndexFor: startIndex)		to: (self stopIndexFor: stopIndex)		after: (self startIndexFor: anObject)</body><body package="SmaCC Rewrite Engine" selector="moveFrom:to:before:">moveFrom: startIndex to: stopIndex before: anObject	^self source		moveFrom: (self startIndexFor: startIndex)		to: (self stopIndexFor: stopIndex)		before: (self startIndexFor: anObject)</body><body package="SmaCC Rewrite Engine" selector="replace:with:">replace: anObject with: aString	anObject isNil ifTrue: [^self].	self delete: anObject.	self insert: aString before: anObject</body><body package="SmaCC Rewrite Engine" selector="replaceAll:with:">replaceAll: aCollection with: aString	aCollection do: [:each | self replace: each with: aString]</body><body package="SmaCC Rewrite Engine" selector="replaceFrom:to:with:">replaceFrom: startIndex to: stopIndex with: aString	self insert: aString before: startIndex.	self deleteFrom: startIndex to: stopIndex</body><body package="SmaCC Rewrite Engine" selector="sourceFor:">sourceFor: anObject	anObject isNil ifTrue: [^''].	^(self sourceFrom: (self startIndexFor: anObject) to: (self stopIndexFor: anObject)) asString</body><body package="SmaCC Rewrite Engine" selector="startIndexFor:">startIndexFor: anObject	^((anObject isKindOf: SmaCCParseNode) or: [anObject isKindOf: SmaCCToken])		ifTrue: [rewriteEngine startPositionForNode: anObject]		ifFalse: [anObject]</body><body package="SmaCC Rewrite Engine" selector="startOfLineWhitespaceBefore:">startOfLineWhitespaceBefore: anObject	^self originalSource startOfLineWhitespaceBeforeIndex: (self originalStartIndexFor: anObject)</body><body package="SmaCC Rewrite Engine" selector="stopIndexFor:">stopIndexFor: anObject	^((anObject isKindOf: SmaCCParseNode) or: [anObject isKindOf: SmaCCToken])		ifTrue: [rewriteEngine stopPositionForNode: anObject]		ifFalse: [anObject]</body><body package="SmaCC Rewrite Engine" selector="updateStopPositionFor:to:whenEqualTo:">updateStopPositionFor: node to: endPosition whenEqualTo: anIndex	rewriteEngine		updateStopPositionFor: node		to: endPosition		whenEqualTo: anIndex</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="characterAt:">characterAt: anIndex	^self source at: anIndex</body><body package="SmaCC Rewrite Engine" selector="characterAtEndOf:">characterAtEndOf: aSmaCCNode	| index |	index := self stopIndexFor: aSmaCCNode.	^self characterAt: ((self source isRemoved: index) ifTrue: [self source previousIndex: index] ifFalse: [index])</body><body package="SmaCC Rewrite Engine" selector="computeStringFor:">computeStringFor: value	(value isKindOf: Collection)		ifTrue:			[| first last |			first := last := nil.			value				do:					[:each | 					(each isKindOf: SmaCCParseNode)						ifTrue:							[self processChild: each.							first isNil ifTrue: [first := self startIndexFor: each].							(self stopIndexFor: each) ifNotNil: [:i | i ~= 0 ifTrue: [last := i]]]						ifFalse:							[(each isKindOf: SmaCCToken)								ifTrue:									[first isNil ifTrue: [first := value startPosition].									last := value stopPosition]]].			(first notNil and: [last notNil]) ifTrue: [^self sourceFrom: first to: last]].	(value isKindOf: SmaCCParseNode) ifTrue: [^self rewrite: value].	^(value isKindOf: SmaCCToken) ifTrue: [value value] ifFalse: [value]</body><body package="SmaCC Rewrite Engine" selector="context:">context: aDictionary	aDictionary		keysAndValuesDo:			[:key :value | 			| cachedString |			nodes at: key name put: value.			strings at: key name put: [cachedString ifNil: [cachedString := self computeStringFor: value]]]</body><body package="SmaCC Rewrite Engine" selector="match">match	^match</body><body package="SmaCC Rewrite Engine" selector="match:">match: anObject	match := anObject</body><body package="SmaCC Rewrite Engine" selector="nextIndex:">nextIndex: position	^self originalSource nextIndex: position</body><body package="SmaCC Rewrite Engine" selector="nodeFor:">nodeFor: aString	^nodes at: aString ifAbsent: [nil]</body><body package="SmaCC Rewrite Engine" selector="originalSource">originalSource	^match completeSource</body><body package="SmaCC Rewrite Engine" selector="originalStartIndexFor:">originalStartIndexFor: anObject	^((anObject isKindOf: SmaCCParseNode) or: [anObject isKindOf: SmaCCToken])		ifTrue: [anObject startPosition]		ifFalse: [anObject]</body><body package="SmaCC Rewrite Engine" selector="originalStartPosition:">originalStartPosition: anObject	(anObject isKindOf: Collection) ifTrue: [anObject do: [:each | ^self originalStartPosition: each]].	((anObject isKindOf: SmaCCParseNode) or: [anObject isKindOf: SmaCCToken]) ifTrue: [^anObject startPosition].	^nil</body><body package="SmaCC Rewrite Engine" selector="originalStopPosition:">originalStopPosition: anObject	(anObject isKindOf: Collection) ifTrue: [anObject reverseDo: [:each | ^self originalStopPosition: each]].	((anObject isKindOf: SmaCCParseNode) or: [anObject isKindOf: SmaCCToken]) ifTrue: [^anObject stopPosition].	^nil</body><body package="SmaCC Rewrite Engine" selector="previousIndex:">previousIndex: position	^self originalSource previousIndex: position</body><body package="SmaCC Rewrite Engine" selector="rewrite:">rewrite: aSmaCCParseNode	^rewriteEngine rewrite: aSmaCCParseNode</body><body package="SmaCC Rewrite Engine" selector="rewriteEngine">rewriteEngine	^rewriteEngine</body><body package="SmaCC Rewrite Engine" selector="rewriteEngine:">rewriteEngine: anObject	rewriteEngine := anObject</body><body package="SmaCC Rewrite Engine" selector="safe:">safe: aBlock	^aBlock on: Error do: [:ex | ex return]</body><body package="SmaCC Rewrite Engine" selector="smaccStringClass">smaccStringClass	^self source class</body><body package="SmaCC Rewrite Engine" selector="source">source	^rewriteEngine source</body><body package="SmaCC Rewrite Engine" selector="sourceFrom:to:">sourceFrom: first to: last	^(self source copyFrom: (self startIndexFor: first) to: (self stopIndexFor: last)) asString</body><body package="SmaCC Rewrite Engine" selector="stringFor:">stringFor: aString	^(strings at: aString ifAbsent: [['']]) value</body><body package="SmaCC Rewrite Engine" selector="whitespaceAfter:">whitespaceAfter: anObject	^self originalSource whitespaceAfterIndex: (self stopIndexFor: anObject)</body><body package="SmaCC Rewrite Engine" selector="whitespaceBefore:">whitespaceBefore: anObject	^self originalSource whitespaceBeforeIndex: (self originalStartIndexFor: anObject)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="charactersAtAndAfter:matchesToken:">charactersAtAndAfter: startPosition matchesToken: aSmaCCToken	| string position |	position := startPosition.	position isNil ifTrue: [^false].	string := aSmaCCToken value.	1		to: string size		do:			[:i | 			(string at: i) = (self originalSource at: position) ifFalse: [^false].			position := self nextIndex: position].	^true</body><body package="SmaCC Rewrite Engine" selector="charactersAtAndBefore:matchesToken:">charactersAtAndBefore: stopPosition matchesToken: aSmaCCToken	| string position |	position := stopPosition.	position isNil ifTrue: [^false].	string := aSmaCCToken value.	string size		to: 1		do:			[:i | 			(string at: i) = (self originalSource at: position) ifFalse: [^false].			position := self previousIndex: position].	^true</body><body package="SmaCC Rewrite Engine" selector="hasChild:position:">hasChild: anObject position: positionSelector	| position node |	node := nil.	(anObject isKindOf: SequenceableCollection)		ifTrue: [node := positionSelector = #startPosition ifTrue: [anObject first] ifFalse: [anObject last]].	(anObject isKindOf: SmaCCParseNode) ifTrue: [node := anObject].	anObject isNil ifTrue: [^false].	position := node perform: positionSelector.	node nodesDo: [:child | (child perform: positionSelector) = position ifTrue: [^true]].	^false</body><body package="SmaCC Rewrite Engine" selector="hasChildAtEndOf:">hasChildAtEndOf: anObject	^self hasChild: anObject position: #stopPosition</body><body package="SmaCC Rewrite Engine" selector="hasChildAtStartOf:">hasChildAtStartOf: anObject	^self hasChild: anObject position: #startPosition</body><body package="SmaCC Rewrite Engine" selector="isAtEndOfParent:">isAtEndOfParent: anObject	(anObject isKindOf: Collection) ifTrue: [anObject reverseDo: [:each | ^self isAtEndOfParent: each]].	^(anObject isKindOf: SmaCCParseNode)		and: [anObject parent notNil and: [anObject parent stopPosition = anObject stopPosition]]</body><body package="SmaCC Rewrite Engine" selector="isAtStartOfParent:">isAtStartOfParent: anObject	(anObject isKindOf: Collection) ifTrue: [anObject do: [:each | ^self isAtStartOfParent: each]].	^(anObject isKindOf: SmaCCParseNode)		and: [anObject parent notNil and: [anObject parent startPosition = anObject startPosition]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext</class-id> <category>accessing-properites</category><body package="SmaCC Rewrite Engine" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	aMessage arguments size = 0 ifTrue: [^self propertyAt: aMessage selector].	aMessage arguments size = 1		ifTrue:			[| selector |			selector := (aMessage selector first: aMessage selector size - 1) asSymbol.			^self propertyAt: selector put: aMessage arguments first].	^super doesNotUnderstand: aMessage</body><body package="SmaCC Rewrite Engine" selector="propertyAt:">propertyAt: aString	^rewriteEngine propertyAt: aString</body><body package="SmaCC Rewrite Engine" selector="propertyAt:ifAbsent:">propertyAt: aString ifAbsent: aBlock	^rewriteEngine propertyAt: aString ifAbsent: aBlock</body><body package="SmaCC Rewrite Engine" selector="propertyAt:ifAbsentPut:">propertyAt: aString ifAbsentPut: aBlock	^rewriteEngine propertyAt: aString ifAbsentPut: aBlock</body><body package="SmaCC Rewrite Engine" selector="propertyAt:put:">propertyAt: aString put: anObject	^rewriteEngine propertyAt: aString put: anObject</body><body package="SmaCC Rewrite Engine" selector="removeProperty:">removeProperty: aString	^rewriteEngine removeProperty: aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext</class-id> <category>processing</category><body package="SmaCC Rewrite Engine" selector="continue">continue	continuation value</body><body package="SmaCC Rewrite Engine" selector="markAsProcessed:">markAsProcessed: aSmaCCParseNode	rewriteEngine markAsProcessed: aSmaCCParseNode</body><body package="SmaCC Rewrite Engine" selector="processChild:">processChild: aSmaCCParseNode	rewriteEngine rewriteNode: aSmaCCParseNode</body><body package="SmaCC Rewrite Engine" selector="processChildren">processChildren	match nodesDo: [:each | self processChild: each]</body><body package="SmaCC Rewrite Engine" selector="processChildren:">processChildren: aCollection	aCollection do: [:each | self processChild: each]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext</class-id> <category>initialize-release</category><body package="SmaCC Rewrite Engine" selector="forNode:rewriter:continuation:">forNode: aSmaCCParseNode rewriter: aSmaCCRewriteEngine continuation: aBlock	rewriteEngine := aSmaCCRewriteEngine.	match := aSmaCCParseNode.	continuation := aBlock.	nodes := Dictionary new.	strings := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="forNode:rewriter:continuation:">forNode: aSmaCCParseNode rewriter: aSmaCCRewriteEngine continuation: aBlock	^(self new)		forNode: aSmaCCParseNode			rewriter: aSmaCCRewriteEngine			continuation: aBlock;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext class</class-id> <category>class initialization</category><body package="SmaCC Rewrite Engine" selector="initialize">initialize	Continue := Object new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext class</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="continue">continue	^Continue</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatch</class-id> <category>copying</category><body package="SmaCC Rewrite Engine" selector="postCopy">postCopy	super postCopy.	rewrite := nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatch</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="displayOn:">displayOn: aStream	self printOn: aStream</body><body package="SmaCC Rewrite Engine" selector="displayString">displayString	| stream |	stream := WriteStream on: String new.	self displayOn: stream.	^stream contents</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatch</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="parserClass">parserClass	^rewrite parserClass</body><body package="SmaCC Rewrite Engine" selector="rewrite">rewrite	^rewrite</body><body package="SmaCC Rewrite Engine" selector="rewrite:">rewrite: anObject	rewrite := anObject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatch</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="modified">modified	rewrite notNil ifTrue: [rewrite modified]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatch</class-id> <category>matching</category><body package="SmaCC Rewrite Engine" selector="match:">match: aSmaCCRewriteMatchContext	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatch</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteMatch</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="canMatch:">canMatch: aClass	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTypeMatch</class-id> <category>matching</category><body package="SmaCC Rewrite Engine" selector="codeMatches:">codeMatches: aSmaCCParseNode	(code isNil or: [code isEmpty]) ifTrue: [^true].	^(enableDebug and: [SmaCCRewriteProcessor debug])		ifTrue: [self methodMatches: aSmaCCParseNode]		ifFalse: [[self methodMatches: aSmaCCParseNode] on: Error do: [:ex | ex return: false]]</body><body package="SmaCC Rewrite Engine" selector="match:">match: aSmaCCRewriteMatchContext	| dictionary |	(aSmaCCRewriteMatchContext match isKindOf: nodeClass) ifFalse: [^nil].	(self codeMatches: aSmaCCRewriteMatchContext) ifFalse: [^nil].	dictionary := Dictionary new.	aSmaCCRewriteMatchContext match		allGettersDo:			[:each | dictionary at: (SmaCCPatternToken value: each asString) put: (aSmaCCRewriteMatchContext match perform: each)].	^dictionary</body><body package="SmaCC Rewrite Engine" selector="methodMatches:">methodMatches: aSmaCCParseNode	^(self method valueWithReceiver: aSmaCCParseNode arguments: #()) = true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTypeMatch</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="code">code	^code</body><body package="SmaCC Rewrite Engine" selector="code:">code: aString	code := aString.	method := nil.	self modified</body><body package="SmaCC Rewrite Engine" selector="enableDebug">enableDebug	^enableDebug</body><body package="SmaCC Rewrite Engine" selector="enableDebug:">enableDebug: aBoolean	enableDebug := aBoolean</body><body package="SmaCC Rewrite Engine" selector="nodeClass">nodeClass	^nodeClass</body><body package="SmaCC Rewrite Engine" selector="nodeClass:">nodeClass: aClass	nodeClass := aClass.	self modified</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTypeMatch</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="canMatch:">canMatch: aClass	^aClass includesBehavior: nodeClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTypeMatch</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="method">method	method isNil		ifTrue:			[| source tree |			source := 'code ' , code.			tree := RBParser parseMethod: source.			tree body statements isEmpty ifTrue: [^method := Object compiledMethodAt: #notNil].			tree body addReturn.			source := tree formattedCode.			method := (Object compilerClass new				compile: source				in: SmaCCRewriteMatchContext				notifying: nil				ifFail: [^nil]) generate].	^method</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTypeMatch</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	aStream nextPutAll: nodeClass name.	(code isNil or: [code isEmpty]) ifTrue: [^self].	aStream		cr;		nextPut: $[;		nextPutAll: code;		nextPut: $]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTypeMatch</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="displayOn:">displayOn: aStream	aStream nextPutAll: nodeClass name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTypeMatch class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="on:">on: aClass	^(self new)		enableDebug: false;		nodeClass: aClass;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteCodeTransformation</class-id> <category>transforming</category><body package="SmaCC Rewrite Engine" selector="transformUsingContext:">transformUsingContext: aSmaCCRewriteMatchContext	(SmaCCRewriteProcessor haltBlock value: rewrite value: aSmaCCRewriteMatchContext match) ifTrue: [self halt].	^self method valueWithReceiver: aSmaCCRewriteMatchContext arguments: #()</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteCodeTransformation</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="code">code	^code</body><body package="SmaCC Rewrite Engine" selector="code:">code: aString	code := aString.	method := nil.	self modified</body><body package="SmaCC Rewrite Engine" selector="method">method	method isNil		ifTrue:			[| source tree rewriter |			source := 'code ' , code.			tree := RBParser parseMethod: source.			tree body addReturn.			rewriter := ParseTreeRewriter new.			rewriter replace: '^self continue' with: '^Continue'.			rewriter executeTree: tree.			method := (Object compilerClass new				compile: rewriter tree formattedCode				in: SmaCCRewriteMatchContext				notifying: nil				ifFail: [^nil]) generate].	^method</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteCodeTransformation</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	aStream		nextPut: $[;		nextPutAll: code;		nextPut: $]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteCodeTransformation class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="on:">on: aString	^(self new)		code: aString;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteResult</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="errorString">errorString	^errorString</body><body package="SmaCC Rewrite Engine" selector="errorString:">errorString: anObject	errorString := anObject</body><body package="SmaCC Rewrite Engine" selector="filename">filename	^filename</body><body package="SmaCC Rewrite Engine" selector="filename:">filename: anObject	filename := anObject</body><body package="SmaCC Rewrite Engine" selector="inputSource">inputSource	^''</body><body package="SmaCC Rewrite Engine" selector="inputSource:">inputSource: aString</body><body package="SmaCC Rewrite Engine" selector="interval">interval	^interval</body><body package="SmaCC Rewrite Engine" selector="interval:">interval: anObject	interval := anObject</body><body package="SmaCC Rewrite Engine" selector="outputSource">outputSource	^''</body><body package="SmaCC Rewrite Engine" selector="outputSource:">outputSource: aString</body><body package="SmaCC Rewrite Engine" selector="smaccStringClass">smaccStringClass	^SmaCCString</body><body package="SmaCC Rewrite Engine" selector="startColumn">startColumn	^startColumn</body><body package="SmaCC Rewrite Engine" selector="startColumn:">startColumn: anInteger	startColumn := anInteger</body><body package="SmaCC Rewrite Engine" selector="startLine">startLine	^startLine</body><body package="SmaCC Rewrite Engine" selector="startLine:">startLine: anInteger	startLine := anInteger</body><body package="SmaCC Rewrite Engine" selector="transformation">transformation	^transformation</body><body package="SmaCC Rewrite Engine" selector="transformation:">transformation: anObject	transformation := anObject</body><body package="SmaCC Rewrite Engine" selector="transformedString">transformedString	^SmaCCAnnotatedString on: ''</body><body package="SmaCC Rewrite Engine" selector="transformedString:">transformedString: aSmaCCAnnotatedString</body><body package="SmaCC Rewrite Engine" selector="type">type	^type</body><body package="SmaCC Rewrite Engine" selector="type:">type: aSymbol	type := aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteResult</class-id> <category>converting</category><body package="SmaCC Rewrite Engine" selector="asSocketString">asSocketString	| stream null |	stream := WriteStream on: String new.	null := Character value: 0.	stream		nextPutAll: 'FILENAME=';		nextPutAll: filename;		nextPut: null.	errorString notNil		ifTrue:			[stream				nextPutAll: 'ERRORSTRING=';				nextPutAll: errorString;				nextPut: null].	type notNil		ifTrue:			[stream				nextPutAll: 'TYPE=';				nextPutAll: type;				nextPut: null].	startLine notNil		ifTrue:			[stream				nextPutAll: 'STARTLINE=';				print: startLine;				nextPut: null].	startColumn notNil		ifTrue:			[stream				nextPutAll: 'STARTCOLUMN=';				print: startColumn;				nextPut: null].	interval notNil		ifTrue:			[stream				nextPutAll: 'INTERVAL=';				print: interval first;				nextPut: $-;				print: interval last;				nextPut: null].	transformation notNil		ifTrue:			[stream				nextPutAll: 'TRANSFORMATION=';				nextPutAll: transformation displayString;				nextPut: null].	^stream contents</body><body package="SmaCC Rewrite Engine" selector="asTabDelimitedString">asTabDelimitedString	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: filename;		tab;		nextPutAll: (errorString ifNil: ['']);		tab;		nextPutAll: (type ifNil: ['']);		tab;		nextPutAll: (startLine ifNil: [''] ifNotNil: [:value | value printString]);		tab;		nextPutAll: (startColumn ifNil: [''] ifNotNil: [:value | value printString]);		tab;		nextPutAll: (transformation ifNil: [''] ifNotNil: [:value | value displayString]).	^stream contents</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteResult</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="isError">isError	^type = #error</body><body package="SmaCC Rewrite Engine" selector="isWarning">isWarning	^type = #warning</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteResult class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="fromSocketString:">fromSocketString: aString	| result |	result := self new.	aString		splitFirstOn: (Character value: 0)		andThen: $=		do:			[:key :value | 			key = 'FILENAME' ifTrue: [result filename: value].			key = 'ERRORSTRING' ifTrue: [result errorString: value].			key = 'TYPE' ifTrue: [result type: value asSymbol].			key = 'STARTLINE' ifTrue: [result startLine: (Number readFromString: value)].			key = 'STARTCOLUMN' ifTrue: [result startColumn: (Number readFromString: value)].			key = 'INTERVAL'				ifTrue:					[| items |					items := value tokensBasedOn: $-.					result interval: ((Number readFromString: items first) to: (Number readFromString: items last))].			key = 'TRANSFORMATION' ifTrue: [result transformation: value]].	^result</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteLink</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="next">next	^next</body><body package="SmaCC Rewrite Engine" selector="next:">next: anObject	next := anObject</body><body package="SmaCC Rewrite Engine" selector="rewrite">rewrite	^rewrite</body><body package="SmaCC Rewrite Engine" selector="rewrite:">rewrite: anObject	rewrite := anObject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteLink</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: rewrite displayString;		nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteStringTransformation</class-id> <category>initialize-release</category><body package="SmaCC Rewrite Engine" selector="string">string	^string ifNil: ['']</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteStringTransformation</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="expression">expression	^expression ifNil: [expression := SmaCCReplaceExpressionParser parse: self string]</body><body package="SmaCC Rewrite Engine" selector="string:">string: aString	string := aString.	expression := nil.	self modified</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteStringTransformation</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	aStream		nextPutAll: '&gt;&gt;&gt;';		nextPutAll: self string;		nextPutAll: '&lt;&lt;&lt;'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteStringTransformation</class-id> <category>transforming</category><body package="SmaCC Rewrite Engine" selector="transformUsingContext:">transformUsingContext: aSmaCCRewriteMatchContext	| newSource |	newSource := self expression evaluateInContext: aSmaCCRewriteMatchContext.	aSmaCCRewriteMatchContext replace: aSmaCCRewriteMatchContext match with: newSource</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteStringTransformation class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="on:">on: aString	^(self new)		string: aString;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpression</class-id> <category>evaluating</category><body package="SmaCC Rewrite Engine" selector="evaluateInContext:">evaluateInContext: aSmaCCRewriteMatchContext	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpression</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="acceptVisitor:">acceptVisitor: aReplaceVisitor	^aReplaceVisitor visitReplace: self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeReplaceExpression</class-id> <category>evaluating</category><body package="SmaCC Rewrite Engine" selector="addPostfixTo:inContext:">addPostfixTo: aSmaCCString inContext: aSmaCCRewriteMatchContext	| node position string |	node := aSmaCCRewriteMatchContext nodeFor: name value.	(aSmaCCRewriteMatchContext isAtEndOfParent: node)		ifFalse:			[position := aSmaCCRewriteMatchContext originalStopPosition: node.			string := nil.			afterPostfix notNil				ifTrue:					[(aSmaCCRewriteMatchContext						charactersAtAndAfter: (aSmaCCRewriteMatchContext nextIndex: position)						matchesToken: afterPostfix)						ifTrue: [afterPostfix value size timesRepeat: [position := aSmaCCRewriteMatchContext nextIndex: position]].					string := afterPostfix value].			afterWhitespace notNil ifTrue: [aSmaCCString addPrefix: (aSmaCCRewriteMatchContext whitespaceAfter: position)].			string notNil ifTrue: [aSmaCCString addPrefix: string]].	postfix notNil ifTrue: [aSmaCCString addPrefix: postfix value]</body><body package="SmaCC Rewrite Engine" selector="addPrefixTo:inContext:">addPrefixTo: aSmaCCString inContext: aSmaCCRewriteMatchContext	| node startPosition |	node := aSmaCCRewriteMatchContext nodeFor: name value.	startPosition := aSmaCCRewriteMatchContext originalStartPosition: node.	prefix notNil ifTrue: [aSmaCCString addPrefix: prefix value].	(aSmaCCRewriteMatchContext isAtStartOfParent: node) ifTrue: [^self].	beforePrefix notNil		ifTrue:			[(aSmaCCRewriteMatchContext				charactersAtAndBefore: (aSmaCCRewriteMatchContext previousIndex: startPosition)				matchesToken: beforePrefix)				ifTrue:					[beforePrefix value size timesRepeat: [startPosition := aSmaCCRewriteMatchContext previousIndex: startPosition]].			aSmaCCString addPrefix: beforePrefix value].	beforeWhitespace notNil ifTrue: [aSmaCCString addPrefix: (aSmaCCRewriteMatchContext whitespaceBefore: startPosition)]</body><body package="SmaCC Rewrite Engine" selector="evaluateInContext:">evaluateInContext: aSmaCCRewriteMatchContext	| result |	result := aSmaCCRewriteMatchContext smaccStringClass new.	self addPostfixTo: result inContext: aSmaCCRewriteMatchContext.	result addPrefix: (aSmaCCRewriteMatchContext stringFor: name value).	self addPrefixTo: result inContext: aSmaCCRewriteMatchContext.	^result</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeReplaceExpression</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="acceptVisitor:">acceptVisitor: aReplaceVisitor	^aReplaceVisitor visitNodeReplace: self</body><body package="SmaCC Rewrite Engine" selector="afterPostfix">afterPostfix	^afterPostfix</body><body package="SmaCC Rewrite Engine" selector="afterPostfix:">afterPostfix: aSmaCCToken	afterPostfix := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="afterWhitespace">afterWhitespace	^afterWhitespace</body><body package="SmaCC Rewrite Engine" selector="afterWhitespace:">afterWhitespace: aSmaCCToken	afterWhitespace := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="beforePrefix">beforePrefix	^beforePrefix</body><body package="SmaCC Rewrite Engine" selector="beforePrefix:">beforePrefix: aSmaCCToken	beforePrefix := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="beforeWhitespace">beforeWhitespace	^beforeWhitespace</body><body package="SmaCC Rewrite Engine" selector="beforeWhitespace:">beforeWhitespace: aSmaCCToken	beforeWhitespace := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="name">name	^name</body><body package="SmaCC Rewrite Engine" selector="name:">name: aSmaCCToken	name := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="postfix">postfix	^postfix</body><body package="SmaCC Rewrite Engine" selector="postfix:">postfix: aSmaCCToken	postfix := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="prefix">prefix	^prefix</body><body package="SmaCC Rewrite Engine" selector="prefix:">prefix: aSmaCCToken	prefix := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="tokenVariables">tokenVariables	^#(#beforeWhitespace #beforePrefix #prefix #name #postfix #afterPostfix #afterWhitespace)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAbstractRewrite</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="finishedLoading">finishedLoading</body><body package="SmaCC Rewrite Engine" selector="listForClass:into:">listForClass: aClass into: aSmaCCRewriteLink	self subclassResponsibility</body><body package="SmaCC Rewrite Engine" selector="modified">modified	parent notNil ifTrue: [parent modified]</body><body package="SmaCC Rewrite Engine" selector="parent">parent	^parent</body><body package="SmaCC Rewrite Engine" selector="parent:">parent: aSmaCCAbstractRewrite	parent := aSmaCCAbstractRewrite</body><body package="SmaCC Rewrite Engine" selector="parserClass">parserClass	^parent notNil ifTrue: [parent parserClass] ifFalse: [nil]</body><body package="SmaCC Rewrite Engine" selector="rewrites">rewrites	^#()</body><body package="SmaCC Rewrite Engine" selector="topParent">topParent	^parent ifNil: [self] ifNotNil: [:value | value topParent]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAbstractRewrite</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="isComposite">isComposite	^false</body><body package="SmaCC Rewrite Engine" selector="isRoot">isRoot	^parent isNil</body><body package="SmaCC Rewrite Engine" selector="isUnder:">isUnder: aSmaCCAbstractRewrite	| current |	current := self.	[current notNil and: [current ~= aSmaCCAbstractRewrite]] whileTrue: [current := current parent].	^current notNil</body><body package="SmaCC Rewrite Engine" selector="isUpToDate">isUpToDate	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAbstractRewrite</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="localSaveOn:">localSaveOn: aStream	self subclassResponsibility</body><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	self localSaveOn: aStream</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAbstractRewrite</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="displayOn:">displayOn: aStream	self subclassResponsibility</body><body package="SmaCC Rewrite Engine" selector="displayString">displayString	| stream |	stream := WriteStream on: String new.	self displayOn: stream.	^stream contents</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAbstractRewrite</class-id> <category>initialize-release</category><body package="SmaCC Rewrite Engine" selector="engine:">engine: aSmaCCRewriteEngine	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAbstractRewrite</class-id> <category>copying</category><body package="SmaCC Rewrite Engine" selector="postCopy">postCopy	super postCopy.	parent := nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAbstractRewrite</class-id> <category>rewriting</category><body package="SmaCC Rewrite Engine" selector="performOn:continuation:">performOn: aSmaCCNode continuation: aBlock	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewrite</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="comment">comment	^comment ifNil: ['']</body><body package="SmaCC Rewrite Engine" selector="comment:">comment: aString	comment := aString</body><body package="SmaCC Rewrite Engine" selector="listForClass:into:">listForClass: aClass into: aSmaCCRewriteLink	| next |	(match canMatch: aClass) ifFalse: [^aSmaCCRewriteLink].	next := SmaCCRewriteLink new.	next rewrite: self.	aSmaCCRewriteLink next: next.	^next</body><body package="SmaCC Rewrite Engine" selector="match">match	^match</body><body package="SmaCC Rewrite Engine" selector="match:">match: aSmaCCRewriteMatch	match := aSmaCCRewriteMatch.	match rewrite: self.	self modified</body><body package="SmaCC Rewrite Engine" selector="transformation">transformation	^transformation</body><body package="SmaCC Rewrite Engine" selector="transformation:">transformation: aSmaCCRewriteTransformation	transformation := aSmaCCRewriteTransformation.	transformation rewrite: self.	self modified</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewrite</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="localSaveOn:">localSaveOn: aStream	self comment notEmpty		ifTrue:			[aStream				nextPut: $";				nextPutAll: (self comment copyReplaceAll: '"' with: '""');				nextPut: $";				cr].	match saveOn: aStream.	aStream		cr;		nextPutAll: '-&gt;';		cr.	transformation saveOn: aStream</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewrite</class-id> <category>rewriting</category><body package="SmaCC Rewrite Engine" selector="performOn:continuation:">performOn: aSmaCCNode continuation: aBlock	| matchedContext dictionary result previousNode previousRule |	previousNode := engine source node.	previousRule := engine source rule.	(engine source)		node: aSmaCCNode;		rule: self.	matchedContext := SmaCCRewriteMatchContext		forNode: aSmaCCNode		rewriter: engine		continuation: aBlock.	dictionary := match match: matchedContext.	result := dictionary notNil.	result		ifTrue:			[matchedContext context: dictionary.			result := (transformation transformUsingContext: matchedContext) ~~ SmaCCRewriteMatchContext continue].	(engine source)		node: previousNode;		rule: previousRule.	^result</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewrite</class-id> <category>copying</category><body package="SmaCC Rewrite Engine" selector="postCopy">postCopy	super postCopy.	self match: self match copy.	self transformation: self transformation copy.	engine := nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewrite</class-id> <category>initialize-release</category><body package="SmaCC Rewrite Engine" selector="engine:">engine: aSmaCCRewriteEngine	engine := aSmaCCRewriteEngine</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewrite</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="displayOn:">displayOn: aStream	self comment notEmpty ifTrue: [aStream nextPutAll: self comment] ifFalse: [match displayOn: aStream]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewrite class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="comment:match:transformation:">comment: aString match: aSmaCCRewriteMatch transformation: aSmaCCRewriteTransformation	^(self new)		comment: aString;		match: aSmaCCRewriteMatch;		transformation: aSmaCCRewriteTransformation;		yourself</body><body package="SmaCC Rewrite Engine" selector="newInstance">newInstance	^self		comment: ''		match: (SmaCCRewriteTypeMatch on: SmaCCParseNode)		transformation: (SmaCCRewriteCodeTransformation on: 'self continue')</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTreeMatch</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="source">source	^source</body><body package="SmaCC Rewrite Engine" selector="source:">source: aString	source := aString.	trees := nil.	self modified</body><body package="SmaCC Rewrite Engine" selector="startingState">startingState	^startingState</body><body package="SmaCC Rewrite Engine" selector="startingState:">startingState: aString	startingState := aString.	self modified</body><body package="SmaCC Rewrite Engine" selector="startingStateIndex">startingStateIndex	startingState isNil ifTrue: [^1].	^self parserClass perform: ('startingStateFor' , startingState) asSymbol</body><body package="SmaCC Rewrite Engine" selector="trees">trees	^trees		ifNil:			[trees := [self parserClass parseAndCacheAll: source startingAt: self startingStateIndex]				on: SmaCCParserError				do: [:ex | ex return: #()]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTreeMatch</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="displayOn:">displayOn: aStream	aStream nextPutAll: (source isNil ifTrue: ['"Empty"'] ifFalse: [source])</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTreeMatch</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="canMatch:">canMatch: aClass	^self trees anySatisfy: [:each | each class == aClass or: [each isKindOf: SmaCCPatternNode]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTreeMatch</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	startingState notNil		ifTrue:			[aStream				nextPutAll: startingState;				cr].	aStream		nextPutAll: '&gt;&gt;&gt;';		nextPutAll: source;		nextPutAll: '&lt;&lt;&lt;'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteTreeMatch</class-id> <category>matching</category><body package="SmaCC Rewrite Engine" selector="match:">match: aSmaCCRewriteMatchContext	| context |	1		to: self trees size		do:			[:i | 			context := Dictionary new.			((trees at: i) match: aSmaCCRewriteMatchContext match inContext: context) ifTrue: [^context]].	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeReplaceExpression</class-id> <category>generated-initialize-release</category><body package="SmaCC Rewrite Engine" selector="initialize">initialize	super initialize.	expressions := OrderedCollection new: 2.</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeReplaceExpression</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="acceptVisitor:">acceptVisitor: aReplaceVisitor	^aReplaceVisitor visitCompositeReplace: self</body><body package="SmaCC Rewrite Engine" selector="compositeNodeVariables">compositeNodeVariables	^#(#expressions)</body><body package="SmaCC Rewrite Engine" selector="expressions">expressions	^expressions</body><body package="SmaCC Rewrite Engine" selector="expressions:">expressions: anOrderedCollection	self setParents: self expressions to: nil.	expressions := anOrderedCollection.	self setParents: self expressions to: self</body><body package="SmaCC Rewrite Engine" selector="pluralVariablesMap">pluralVariablesMap	^[(Dictionary new)		at: 'expression' put: 'expressions';		yourself] once</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeReplaceExpression</class-id> <category>evaluating</category><body package="SmaCC Rewrite Engine" selector="evaluateInContext:">evaluateInContext: aSmaCCRewriteMatchContext	| result |	result := aSmaCCRewriteMatchContext smaccStringClass new.	self expressions reverseDo: [:each | result addPrefix: (each evaluateInContext: aSmaCCRewriteMatchContext)].	^result</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteAnnotation</class-id> <category>comparing</category><body package="SmaCC Rewrite Engine" selector="=">= anObject	^self class = anObject class		and:			[self nodeClass = anObject nodeClass				and: [self nodeInterval = anObject nodeInterval and: [self rewrite = anObject rewrite]]]</body><body package="SmaCC Rewrite Engine" selector="hash">hash	^(nodeClass hash bitXor: nodeInterval hash) bitXor: rewrite hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteAnnotation</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="nodeClass">nodeClass	^nodeClass</body><body package="SmaCC Rewrite Engine" selector="nodeClass:">nodeClass: aBehavior	nodeClass := aBehavior</body><body package="SmaCC Rewrite Engine" selector="nodeInterval">nodeInterval	^nodeInterval</body><body package="SmaCC Rewrite Engine" selector="nodeInterval:">nodeInterval: anInterval	nodeInterval := anInterval</body><body package="SmaCC Rewrite Engine" selector="rewrite">rewrite	^rewrite</body><body package="SmaCC Rewrite Engine" selector="rewrite:">rewrite: aSmaCCRewrite	rewrite := aSmaCCRewrite</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteAnnotation</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: nodeClass;		print: nodeInterval;		nextPutAll: ', ';		nextPutAll: rewrite displayString;		nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteAnnotation class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="onNode:rewrite:">onNode: aSmaCCParseNode rewrite: aSmaCCRewrite	^(self new)		nodeClass: aSmaCCParseNode class;		nodeInterval: (aSmaCCParseNode startPosition to: aSmaCCParseNode stopPosition);		rewrite: aSmaCCRewrite;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionVisitor</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="visitCodeReplace:">visitCodeReplace: aCodeReplace	^self visitReplace: aCodeReplace</body><body package="SmaCC Rewrite Engine" selector="visitCompositeReplace:">visitCompositeReplace: aCompositeReplace	^self visitReplace: aCompositeReplace</body><body package="SmaCC Rewrite Engine" selector="visitNodeReplace:">visitNodeReplace: aNodeReplace	^self visitReplace: aNodeReplace</body><body package="SmaCC Rewrite Engine" selector="visitReplace:">visitReplace: aReplace	^self visitSmaCCParseNode: aReplace</body><body package="SmaCC Rewrite Engine" selector="visitStringReplace:">visitStringReplace: aStringReplace	^self visitReplace: aStringReplace</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>rewriting</category><body package="SmaCC Rewrite Engine" selector="performLink:on:continuation:">performLink: aSmaCCRewriteLink on: aSmaCCNode continuation: aBlock	| link continuation |	link := aSmaCCRewriteLink.	continuation := [self		performLink: link next		on: aSmaCCNode		continuation: aBlock].	[link notNil]		whileTrue:			[(link rewrite performOn: aSmaCCNode continuation: continuation) ifTrue: [^true].			link := link next].	^aBlock value</body><body package="SmaCC Rewrite Engine" selector="performOn:continuation:">performOn: aSmaCCNode continuation: aBlock	| link |	link := cachedLists		at: aSmaCCNode class		ifAbsentPut:			[| first |			first := SmaCCRewriteLink new.			self listForClass: aSmaCCNode class into: first.			first next].	^self performLink: link on: aSmaCCNode continuation: aBlock</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>printing</category><body package="SmaCC Rewrite Engine" selector="displayOn:">displayOn: aStream	aStream nextPutAll: filename asFilename tail</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>saving</category><body package="SmaCC Rewrite Engine" selector="localSaveOn:">localSaveOn: aStream	aStream		nextPutAll: 'Import: ''';		nextPutAll: self relativeFilename;		nextPut: $'</body><body package="SmaCC Rewrite Engine" selector="save">save	| stream |	stream := filename asFilename writeStream.	[parserClass notNil		ifTrue:			[stream				nextPutAll: 'Parser: ';				nextPutAll: parserClass name;				cr;				cr].	rewrites		do: [:each | each saveOn: stream]		separatedBy:			[stream				cr;				cr].	isModified := false] ensure: [stream close].	timestamp := self currentFileTimestamp</body><body package="SmaCC Rewrite Engine" selector="saveOn:">saveOn: aStream	super saveOn: aStream.	self save</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="addTransformation:">addTransformation: aSmaCCAbstractRewrite	rewrites add: aSmaCCAbstractRewrite.	aSmaCCAbstractRewrite parent: self.	self modified</body><body package="SmaCC Rewrite Engine" selector="addTransformation:before:">addTransformation: aSmaCCAbstractRewrite before: anotherSmaCCAbstractRewrite	rewrites add: aSmaCCAbstractRewrite before: anotherSmaCCAbstractRewrite.	aSmaCCAbstractRewrite parent: self.	self modified</body><body package="SmaCC Rewrite Engine" selector="currentFileTimestamp">currentFileTimestamp	^filename ifNotNil: [:name | name asFilename modificationTimestamp]</body><body package="SmaCC Rewrite Engine" selector="directory">directory	^filename asFilename head copyWith: Filename separator</body><body package="SmaCC Rewrite Engine" selector="filename">filename	^filename</body><body package="SmaCC Rewrite Engine" selector="filename:">filename: aString	filename := aString.	timestamp := self currentFileTimestamp.	self modified</body><body package="SmaCC Rewrite Engine" selector="finishedLoading">finishedLoading	isModified := false.	rewrites do: [:each | each finishedLoading]</body><body package="SmaCC Rewrite Engine" selector="import:">import: aString	| name rewriteFile |	name := self directory , aString.	name asFilename exists ifFalse: [name := aString].	rewriteFile := SmaCCRewriteRuleFileParser parseFile: name.	self addTransformation: rewriteFile</body><body package="SmaCC Rewrite Engine" selector="listForClass:into:">listForClass: aClass into: aSmaCCRewriteLink	^rewrites inject: aSmaCCRewriteLink into: [:sum :each | each listForClass: aClass into: sum]</body><body package="SmaCC Rewrite Engine" selector="modified">modified	isModified := true.	cachedLists := IdentityDictionary new.	super modified</body><body package="SmaCC Rewrite Engine" selector="parserClass">parserClass	^parserClass ifNil: [super parserClass]</body><body package="SmaCC Rewrite Engine" selector="parserClass:">parserClass: aSmaCCParserClass	parserClass := aSmaCCParserClass.	self modified</body><body package="SmaCC Rewrite Engine" selector="relativeFilename">relativeFilename	| parentDirectory |	parent isNil ifTrue: [^filename].	parentDirectory := parent directory.	^(filename beginsWith: parentDirectory)		ifTrue: [filename copyFrom: parentDirectory size + 1 to: filename size]		ifFalse: [filename]</body><body package="SmaCC Rewrite Engine" selector="removeTransformation:">removeTransformation: aSmaCCAbstractRewrite	rewrites remove: aSmaCCAbstractRewrite ifAbsent: [].	aSmaCCAbstractRewrite parent: nil.	self modified</body><body package="SmaCC Rewrite Engine" selector="rewrites">rewrites	^rewrites</body><body package="SmaCC Rewrite Engine" selector="rewrites:">rewrites: aCollection	rewrites := aCollection.	self modified</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="isComposite">isComposite	^true</body><body package="SmaCC Rewrite Engine" selector="isModified">isModified	^isModified</body><body package="SmaCC Rewrite Engine" selector="isUpToDate">isUpToDate	^timestamp = self currentFileTimestamp and: [rewrites allSatisfy: [:each | each isUpToDate]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>initialize-release</category><body package="SmaCC Rewrite Engine" selector="engine:">engine: aSmaCCRewriteEngine	rewrites do: [:each | each engine: aSmaCCRewriteEngine]</body><body package="SmaCC Rewrite Engine" selector="initialize">initialize	super initialize.	rewrites := OrderedCollection new.	isModified := false.	cachedLists := IdentityDictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>comparing</category><body package="SmaCC Rewrite Engine" selector="=">= anObject	self class = anObject class ifFalse: [^false].	^self filename = anObject filename</body><body package="SmaCC Rewrite Engine" selector="hash">hash	^self class hash bitXor: self filename hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile</class-id> <category>copying</category><body package="SmaCC Rewrite Engine" selector="postCopy">postCopy	| oldRewrites |	super postCopy.	oldRewrites := self rewrites.	rewrites := OrderedCollection new: oldRewrites size.	oldRewrites do: [:each | self addTransformation: each copy].	cachedLists := IdentityDictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteFile class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteCompleteResult</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="inputSource">inputSource	^inputSource</body><body package="SmaCC Rewrite Engine" selector="inputSource:">inputSource: aString	inputSource := aString</body><body package="SmaCC Rewrite Engine" selector="outputSource">outputSource	^outputSource</body><body package="SmaCC Rewrite Engine" selector="outputSource:">outputSource: aString	outputSource := aString</body><body package="SmaCC Rewrite Engine" selector="smaccStringClass">smaccStringClass	^SmaCCAnnotatedString</body><body package="SmaCC Rewrite Engine" selector="transformedString">transformedString	^transformedString</body><body package="SmaCC Rewrite Engine" selector="transformedString:">transformedString: aSmaCCAnnotatedString	transformedString := aSmaCCAnnotatedString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionParser</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="reduceTable">reduceTable^#(	#(22 0 #reduceActionForRewriteExpressions1:) 	#(17 0 #reduceActionForSwitchStateToExpression1:) 	#(16 0 #reduceActionForSwitchStateToCode1:) 	#(12 1 #reduceActionForExpression1:) 	#(10 1 #reduceActionForStringReplace1:) 	#(11 1 #reduceActionForRewriteExpression3:) 	#(22 2 #reduceActionForRewriteExpressions2:) 	#(18 0 #nil) 	#(15 0 #reduceActionForSwitchStateToDefault1:) 	#(18 1 #reduceActionForRewriteExpression3:) 	#(21 0 #nil) 	#(19 1 #reduceActionForRewriteExpression3:) 	#(21 1 #reduceActionForRewriteExpression3:) 	#(23 2 #reduceActionForPrefixModifiers2:) 	#(8 5 #reduceActionForCodeReplace1:) 	#(23 4 #reduceActionForPrefixModifiers1:) 	#(14 2 #reduceActionForPrefixModifiers2:) 	#(9 7 #reduceActionForNodeReplace1:) 	#(14 4 #reduceActionForPostfixModifiers1:)	).</body><body package="SmaCC Rewrite Engine" selector="symbolTypes">symbolTypes	^#(#SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCCodeReplaceExpression #SmaCCNodeReplaceExpression #SmaCCStringReplaceExpression #SmaCCReplaceExpression #SmaCCCompositeReplaceExpression #SmaCCToken #OrderedCollection #Object #Object #Object #SmaCCToken #SmaCCToken #SmaCCCompositeReplaceExpression #SmaCCToken #OrderedCollection #OrderedCollection #SmaCCToken #SmaCCToken)</body><body package="SmaCC Rewrite Engine" selector="transitionTable">transitionTable^#(#[1 0 6 0 5 0 6 0 6 0 6 0 7 0 9 0 12 0 13 0 22 0 6 0 24] #[0 0 0 0 24] #[1 0 17 0 5 0 10 0 6 0 14 0 7 0 21 0 8 0 25 0 9 0 29 0 10 0 33 0 11 0 37 0 16 0 41 0 17 0 18 0 24] #[0 0 22 0 5 0 6 0 7 0 24] #[0 0 26 0 5 0 6 0 7 0 24] #[0 0 26 0 5 0 6 0 7 0 24] #[0 0 26 0 5 0 6 0 7 0 24] #[0 0 30 0 5 0 6 0 7 0 24] #[0 0 45 0 7] #[0 0 49 0 6] #[0 0 53 0 13] #[1 0 34 0 1 0 57 0 2 0 34 0 3 0 61 0 18 0 65 0 23] #[1 0 38 0 7 0 69 0 15] #[0 0 42 0 1 0 3 0 6] #[1 0 46 0 1 0 73 0 3 0 77 0 19 0 81 0 21] #[0 0 85 0 1] #[0 0 89 0 7] #[0 0 50 0 1 0 2 0 4 0 6] #[1 0 54 0 1 0 93 0 4] #[0 0 58 0 1] #[1 0 46 0 2 0 73 0 3 0 46 0 4 0 46 0 6 0 97 0 14 0 101 0 19 0 105 0 21] #[0 0 62 0 5 0 6 0 7 0 24] #[1 0 46 0 1 0 73 0 3 0 101 0 19 0 109 0 21] #[1 0 38 0 6 0 113 0 15] #[0 0 54 0 1 0 2 0 4 0 6] #[1 0 57 0 2 0 117 0 4 0 34 0 6 0 121 0 18] #[0 0 66 0 1] #[0 0 125 0 6] #[1 0 73 0 3 0 129 0 19] #[0 0 70 0 6] #[0 0 74 0 5 0 6 0 7 0 24] #[1 0 57 0 2 0 34 0 6 0 133 0 18] #[0 0 78 0 6]	).</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionParser</class-id> <category>generated-reduction actions</category><body package="SmaCC Rewrite Engine" selector="reduceActionForCodeReplace1:">reduceActionForCodeReplace1: nodes	| result |	result := SmaCCCodeReplaceExpression new.	result addVariablesFrom: (nodes at: 1).	result code: (nodes at: 3).	result addVariablesFrom: (nodes at: 4).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForExpression1:">reduceActionForExpression1: nodes	| result |	result := SmaCCCompositeReplaceExpression new.	result addNodes: ((nodes at: 1) at: 1) to: result expressions.	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForNodeReplace1:">reduceActionForNodeReplace1: nodes	| result |	result := SmaCCNodeReplaceExpression new.	result addVariablesFrom: (nodes at: 1).	result beforeWhitespace: ((nodes at: 3) at: 1).	result beforePrefix: ((nodes at: 3) at: 2).	result prefix: ((nodes at: 3) at: 3).	result name: (nodes at: 4).	result postfix: ((nodes at: 5) at: 1).	result afterPostfix: ((nodes at: 5) at: 2).	result afterWhitespace: ((nodes at: 5) at: 3).	result addVariablesFrom: (nodes at: 6).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForPostfixModifiers1:">reduceActionForPostfixModifiers1: nodes	| result |	result := Array new: 3.	result at: 1 put: (nodes at: 1).	result at: 2 put: (nodes at: 3).	result at: 3 put: (nodes at: 4).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForPrefixModifiers1:">reduceActionForPrefixModifiers1: nodes	| result |	result := Array new: 3.	result at: 1 put: (nodes at: 1).	result at: 2 put: (nodes at: 2).	result at: 3 put: (nodes at: 4).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForPrefixModifiers2:">reduceActionForPrefixModifiers2: nodes	| result |	result := Array new: 3.	result at: 1 put: (nodes at: 1).	result at: 3 put: (nodes at: 2).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRewriteExpression3:">reduceActionForRewriteExpression3: nodes	^nodes at: 1</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRewriteExpressions1:">reduceActionForRewriteExpressions1: nodes	| result |	result := Array new: 1.	result at: 1 put: (OrderedCollection new: 2).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRewriteExpressions2:">reduceActionForRewriteExpressions2: nodes	| result |	result := Array new: 1.	result at: 1 put: (OrderedCollection new: 2).	self addAll: ((nodes at: 1) at: 1) to: (result at: 1).	self add: (nodes at: 2) to: (result at: 1).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForStringReplace1:">reduceActionForStringReplace1: nodes	| result |	result := SmaCCStringReplaceExpression new.	result string: (nodes at: 1).	^result</body><body package="SmaCC Rewrite Engine" selector="reduceActionForSwitchStateToCode1:">reduceActionForSwitchStateToCode1: nodes	self state: #code.	^nil</body><body package="SmaCC Rewrite Engine" selector="reduceActionForSwitchStateToDefault1:">reduceActionForSwitchStateToDefault1: nodes	self state: #default.	^nil</body><body package="SmaCC Rewrite Engine" selector="reduceActionForSwitchStateToExpression1:">reduceActionForSwitchStateToExpression1: nodes	self state: #expression.	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionParser class</class-id> <category>generated-accessing</category><body package="SmaCC Rewrite Engine" selector="scannerClass">scannerClass	^SmaCCReplaceExpressionScanner</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionParser class</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="definitionComment">definitionComment"%excludes expression code ;%id &lt;codeExpression&gt;;expression &lt;name&gt;	: (&lt;isLetter&gt;) (&lt;isLetter&gt; | &lt;isDigit&gt;) *	;expression &lt;newline&gt;	: \\	;expression &lt;special_characters&gt;	: [\~\!\@\#\$\%\^\&amp;\*\(\)\-\+\=\|\{\[\]\}\&lt;\,\&gt;\.\?\/\;\:\'\""]+	;expression &lt;end_of_expression_character&gt;	: _	;&lt;string&gt;	: [^`]+	;default expression &lt;backquote&gt;	: `	;default code &lt;double_backquote&gt;	: ``	;%prefix SmaCC;%suffix Expression;%root Replace;Expression	: RewriteExpressions {{CompositeReplace}}	;RewriteExpressions	: 	| RewriteExpressions RewriteExpression 'expression'	;RewriteExpression	: StringReplace	| NodeReplace	| CodeReplace	;StringReplace	: &lt;string&gt; 'string' {{StringReplace}}	;NodeReplace	: SwitchStateToExpression &lt;backquote&gt; PrefixModifiers &lt;name&gt; 'name' PostfixModifiers SwitchStateToDefault &lt;backquote&gt; {{NodeReplace}}	;SwitchStateToDefault	: {self state: #default. nil}	;SwitchStateToExpression	: {self state: #expression. nil}	;CodeReplace	: SwitchStateToCode &lt;double_backquote&gt; &lt;codeExpression&gt; 'code' SwitchStateToDefault &lt;double_backquote&gt; {{CodeReplace}}	;SwitchStateToCode	: {self state: #code. nil}	;PrefixModifiers	: OptionalWhitespace 'beforeWhitespace' Characters 'beforePrefix' &lt;end_of_expression_character&gt; OptionalCharacters 'prefix'	| OptionalWhitespace 'beforeWhitespace' OptionalCharacters 'prefix'	;PostfixModifiers	: OptionalCharacters 'postfix' &lt;end_of_expression_character&gt; Characters 'afterPostfix' OptionalWhitespace 'afterWhitespace'	| OptionalCharacters 'postfix' OptionalWhitespace 'afterWhitespace'	;OptionalWhitespace	: 	| &lt;newline&gt;	;OptionalCharacters	: 	| Characters	;Characters	: &lt;special_characters&gt; 'characters'	;"</body><body package="SmaCC Rewrite Engine" selector="startingStateForExpression">startingStateForExpression	^1</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteEngine</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="markAsProcessed:">markAsProcessed: aSmaCCNode	processedNodes add: aSmaCCNode</body><body package="SmaCC Rewrite Engine" selector="processChildrenOf:">processChildrenOf: aSmaCCNode	^aSmaCCNode nodesDo: [:each | self rewriteNode: each]</body><body package="SmaCC Rewrite Engine" selector="rewrite:">rewrite: aSmaCCParseNode	self rewriteNode: aSmaCCParseNode.	^source copyFrom: (self startPositionForNode: aSmaCCParseNode) to: (self stopPositionForNode: aSmaCCParseNode)</body><body package="SmaCC Rewrite Engine" selector="rewriteNode:">rewriteNode: aSmaCCNode	(aSmaCCNode isNil or: [processedNodes includes: aSmaCCNode]) ifTrue: [^self].	self markAsProcessed: aSmaCCNode.	rewriteRule performOn: aSmaCCNode continuation: [self processChildrenOf: aSmaCCNode]</body><body package="SmaCC Rewrite Engine" selector="setPosition:in:">setPosition: anIndex in: aSequenceableCollection	| i lastPosition |	lastPosition := aSequenceableCollection last.	i := aSequenceableCollection size.	[i &gt; 0 and: [lastPosition = (aSequenceableCollection at: i)]]		whileTrue:			[aSequenceableCollection at: i put: anIndex.			i := i - 1]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteEngine</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="addRewrites:">addRewrites: aCollection	aCollection do: [:each | self rewriteRule: each]</body><body package="SmaCC Rewrite Engine" selector="additionalFiles">additionalFiles	^self propertyAt: #additionalFiles ifAbsent: [Dictionary new]</body><body package="SmaCC Rewrite Engine" selector="rewriteRule">rewriteRule	^rewriteRule</body><body package="SmaCC Rewrite Engine" selector="rewriteRule:">rewriteRule: aSmaCCAbstractRewrite	rewriteRule := aSmaCCAbstractRewrite.	aSmaCCAbstractRewrite engine: self</body><body package="SmaCC Rewrite Engine" selector="setStartPositionForNode:to:">setStartPositionForNode: aSmaCCParseNode to: anIndex	| position current |	current := aSmaCCParseNode.	position := self startPositionForNode: aSmaCCParseNode.	[newStarts at: current put: anIndex.	current := current parent.	current notNil and: [position = (self startPositionForNode: current)]] whileTrue</body><body package="SmaCC Rewrite Engine" selector="setStopPositionForNode:to:">setStopPositionForNode: aSmaCCParseNode to: anIndex	| position current |	current := aSmaCCParseNode.	position := self stopPositionForNode: aSmaCCParseNode.	[newStops at: current put: anIndex.	current := current parent.	current notNil and: [position = (self stopPositionForNode: current)]] whileTrue</body><body package="SmaCC Rewrite Engine" selector="source">source	^source</body><body package="SmaCC Rewrite Engine" selector="source:">source: aSmaCCString	source := aSmaCCString</body><body package="SmaCC Rewrite Engine" selector="startPositionForNode:">startPositionForNode: aSmaCCParseNode	((aSmaCCParseNode isKindOf: SmaCCParseNode) and: [aSmaCCParseNode parent isNil]) ifTrue: [^source startIndex].	^newStarts at: aSmaCCParseNode ifAbsent: [aSmaCCParseNode startPosition]</body><body package="SmaCC Rewrite Engine" selector="stopPositionForNode:">stopPositionForNode: aSmaCCParseNode	((aSmaCCParseNode isKindOf: SmaCCParseNode) and: [aSmaCCParseNode parent isNil]) ifTrue: [^source stopIndex].	^newStops at: aSmaCCParseNode ifAbsent: [aSmaCCParseNode stopPosition]</body><body package="SmaCC Rewrite Engine" selector="updateStartPositionFor:to:whenEqualTo:">updateStartPositionFor: aSmaCCParseNode to: startPosition whenEqualTo: anIndex	anIndex = (self startPositionForNode: aSmaCCParseNode) ifTrue: [self setStartPositionForNode: aSmaCCParseNode to: startPosition]</body><body package="SmaCC Rewrite Engine" selector="updateStopPositionFor:to:whenEqualTo:">updateStopPositionFor: aSmaCCParseNode to: stopPosition whenEqualTo: anIndex	anIndex = (self stopPositionForNode: aSmaCCParseNode) ifTrue: [self setStopPositionForNode: aSmaCCParseNode to: stopPosition]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteEngine</class-id> <category>accessing-properites</category><body package="SmaCC Rewrite Engine" selector="properties">properties	^properties</body><body package="SmaCC Rewrite Engine" selector="properties:">properties: aDictionary	properties := aDictionary</body><body package="SmaCC Rewrite Engine" selector="propertyAt:">propertyAt: aString	^properties at: aString ifAbsent: [nil]</body><body package="SmaCC Rewrite Engine" selector="propertyAt:ifAbsent:">propertyAt: aString ifAbsent: aBlock	^properties at: aString ifAbsent: aBlock</body><body package="SmaCC Rewrite Engine" selector="propertyAt:ifAbsentPut:">propertyAt: aString ifAbsentPut: aBlock	^properties at: aString ifAbsentPut: aBlock</body><body package="SmaCC Rewrite Engine" selector="propertyAt:put:">propertyAt: aString put: anObject	^properties at: aString put: anObject</body><body package="SmaCC Rewrite Engine" selector="removeProperty:">removeProperty: aString	^properties removeKey: aString ifAbsent: [nil]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteEngine</class-id> <category>initialize-release</category><body package="SmaCC Rewrite Engine" selector="initialize">initialize	super initialize.	newStarts := IdentityDictionary new.	newStops := IdentityDictionary new.	properties := Dictionary new.	processedNodes := IdentitySet new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteEngine</class-id> <category>rewriting</category><body package="SmaCC Rewrite Engine" selector="rewriteTree:">rewriteTree: aSmaCCParseNode	source isNil ifTrue: [source := aSmaCCParseNode completeSource copy].	^(self rewrite: aSmaCCParseNode) asString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteEngine class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileScanner</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="emptySymbolTokenId">emptySymbolTokenId	^25</body><body package="SmaCC Rewrite Engine" selector="errorTokenId">errorTokenId	^26</body><body package="SmaCC Rewrite Engine" selector="scan1">scan1	[self step.	currentCharacter == $"		ifTrue:			[self recordMatch: #(11).			self step.			currentCharacter == $" ifTrue: [^self scan1].			^self reportLastMatch]] repeat</body><body package="SmaCC Rewrite Engine" selector="scan2">scan2	[self step.	currentCharacter == $'		ifTrue:			[self recordMatch: #(10).			self step.			currentCharacter == $' ifTrue: [^self scan2].			^self reportLastMatch]] repeat</body><body package="SmaCC Rewrite Engine" selector="scan3">scan3	[self recordMatch: #(9).	self step.	currentCharacter == $.		ifTrue:			[self step.			(currentCharacter isLetter or: [currentCharacter == $_]) ifTrue: [^self scan3].			^self reportLastMatch].	currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue.	^self reportLastMatch</body><body package="SmaCC Rewrite Engine" selector="scanForToken">scanForToken	self step.	currentCharacter == $" ifTrue: [^self scan1].	currentCharacter == $' ifTrue: [^self scan2].	currentCharacter == $-		ifTrue:			[self step.			currentCharacter == $&gt; ifTrue: [^self recordAndReportMatch: #(5)].			^self reportLastMatch].	currentCharacter == $: ifTrue: [^self recordAndReportMatch: #(2)].	currentCharacter == $&lt;		ifTrue:			[self step.			currentCharacter == $&lt;				ifTrue:					[self step.					currentCharacter == $&lt; ifTrue: [^self recordAndReportMatch: #(7)]].			^self reportLastMatch].	currentCharacter == $&gt;		ifTrue:			[self step.			currentCharacter == $&gt;				ifTrue:					[self step.					currentCharacter == $&gt; ifTrue: [^self recordAndReportMatch: #(8)]].			^self reportLastMatch].	currentCharacter == $[ ifTrue: [^self recordAndReportMatch: #(6)].	currentCharacter == $] ifTrue: [^self recordAndReportMatch: #(1)].	currentCharacter isSeparator		ifTrue:			[[self recordMatch: #(12).			self step.			currentCharacter isSeparator] whileTrue.			^self reportLastMatch].	(currentCharacter isLetter or: [currentCharacter == $_]) ifTrue: [^self scan3].	^self reportLastMatch</body><body package="SmaCC Rewrite Engine" selector="tokenActions">tokenActions	^#(nil nil nil nil nil nil nil nil nil nil nil #whitespace)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileScanner</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="fixExpression:">fixExpression: expression	^expression</body><body package="SmaCC Rewrite Engine" selector="isValidSmalltalk:">isValidSmalltalk: aString	RBParser parseExpression: aString onError: [:e :p | ^false].	^true</body><body package="SmaCC Rewrite Engine" selector="scanSmalltalkExpression">scanSmalltalkExpression	| expression |	expression := ''.	[stream atEnd ifTrue: [self error: 'Invalid Smalltalk expression'].	expression := expression , (stream upTo: $]).	self isValidSmalltalk: expression] whileFalse: [expression := expression copyWith: $]].	stream skip: -1.	^self fixExpression: expression</body><body package="SmaCC Rewrite Engine" selector="scanStringExpression">scanStringExpression	| string position |	currentCharacter := nil.	position := stream position.	string := stream throughAll: '&lt;&lt;&lt;'.	(string last: 3) = '&lt;&lt;&lt;'		ifTrue:			[stream skip: -3.			^string copyFrom: 1 to: string size - 3]		ifFalse:			[stream position: position.			^nil]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileScanner class</class-id> <category>generated-initialization</category><body package="SmaCC Rewrite Engine" selector="initializeKeywordMap">initializeKeywordMap	keywordMap := Dictionary new.	#(#(9 'Import' 4) #(9 'Parser' 3)) do: [:each | (keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2) put: each last].	^keywordMap</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringReplaceExpression</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="acceptVisitor:">acceptVisitor: aReplaceVisitor	^aReplaceVisitor visitStringReplace: self</body><body package="SmaCC Rewrite Engine" selector="string">string	^string</body><body package="SmaCC Rewrite Engine" selector="string:">string: aSmaCCToken	string := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="tokenVariables">tokenVariables	^#(#string)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringReplaceExpression</class-id> <category>evaluating</category><body package="SmaCC Rewrite Engine" selector="evaluateInContext:">evaluateInContext: aSmaCCRewriteMatchContext	^string value</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAnnotatedStringInterval</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="canBeMergedWith:">canBeMergedWith: nextSmaCCStringInterval	"We want to keep the annotations, so we don't allow merging"	^false</body><body package="SmaCC Rewrite Engine" selector="postCopy">postCopy	super postCopy.	annotations := annotations copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAnnotatedStringInterval</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="addAllAnnotations:">addAllAnnotations: aCollection	self annotations addAll: aCollection</body><body package="SmaCC Rewrite Engine" selector="addAnnotation:">addAnnotation: aSmaCCRewriteAnnotation	| collection |	collection := self annotations.	(collection notEmpty and: [collection last = aSmaCCRewriteAnnotation]) ifTrue: [^self].	collection add: aSmaCCRewriteAnnotation</body><body package="SmaCC Rewrite Engine" selector="annotations">annotations	^annotations ifNil: [annotations := OrderedCollection new: 2]</body><body package="SmaCC Rewrite Engine" selector="annotations:">annotations: aSequenceableCollection	annotations := aSequenceableCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteProcessor</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="baseDirectory">baseDirectory	^baseDirectory ifNil: ['']</body><body package="SmaCC Rewrite Engine" selector="baseDirectory:">baseDirectory: aString	baseDirectory := aString</body><body package="SmaCC Rewrite Engine" selector="createDirectory:">createDirectory: aString	| filename parent |	filename := aString asFilename.	filename exists ifTrue: [^self].	parent := filename head.	parent asFilename = filename ifTrue: [^self].	parent asFilename exists ifFalse: [self createDirectory: parent].	filename makeDirectory</body><body package="SmaCC Rewrite Engine" selector="debug">debug	^self class debug</body><body package="SmaCC Rewrite Engine" selector="debug:">debug: aBoolean	self class debug: aBoolean</body><body package="SmaCC Rewrite Engine" selector="engine">engine	rewriteEngine isNil		ifTrue:			[rewriteEngine := SmaCCRewriteEngine new.			rewriteEngine rewriteRule: self rules].	^rewriteEngine</body><body package="SmaCC Rewrite Engine" selector="extension">extension	^self parserClass fileExtension</body><body package="SmaCC Rewrite Engine" selector="files">files	^files ifNil: [files := self inputFilenames]</body><body package="SmaCC Rewrite Engine" selector="files:">files: aCollection	files := aCollection</body><body package="SmaCC Rewrite Engine" selector="inputDirectory">inputDirectory	^inputDirectory</body><body package="SmaCC Rewrite Engine" selector="inputDirectory:">inputDirectory: aString	inputDirectory := aString</body><body package="SmaCC Rewrite Engine" selector="inputFilenames">inputFilenames	| names todo searchString cur |	todo := OrderedCollection with: self inputDirectory asFilename.	searchString := '*' , self extension.	names := OrderedCollection new.	[todo notEmpty]		whileTrue:			[cur := todo removeFirst.			([cur directoryContents] on: Error do: [:ex | ex return: #()])				do:					[:each | 					| sub |					(searchString match: each) ifTrue: [names add: each].					sub := cur construct: each.					(sub exists and: [sub isDirectory]) ifTrue: [todo add: sub]]].	^names</body><body package="SmaCC Rewrite Engine" selector="outputDirectory">outputDirectory	^outputDirectory</body><body package="SmaCC Rewrite Engine" selector="outputDirectory:">outputDirectory: aString	outputDirectory := aString</body><body package="SmaCC Rewrite Engine" selector="parseFile:">parseFile: aString	| source |	source := self sourceFor: aString.	^self parserClass parse: source</body><body package="SmaCC Rewrite Engine" selector="parseRewriteRuleFile:">parseRewriteRuleFile: aString	rules := SmaCCRewriteRuleFileParser parseFile: aString</body><body package="SmaCC Rewrite Engine" selector="parserClass">parserClass	^parserClass</body><body package="SmaCC Rewrite Engine" selector="parserClass:">parserClass: aSmaCCParserClass	parserClass := aSmaCCParserClass</body><body package="SmaCC Rewrite Engine" selector="processAllNotifying:">processAllNotifying: postBlock	self files do: [:each | postBlock value: (self processFile: each)]</body><body package="SmaCC Rewrite Engine" selector="processFile:">processFile: aString	^self processFile: aString usingResult: SmaCCRewriteResult new</body><body package="SmaCC Rewrite Engine" selector="processFile:usingResult:">processFile: aString usingResult: aSmaCCRewriteResult	| input output tree stream subdirectory dir |	aSmaCCRewriteResult filename: aString.	[input := self sourceFor: aString.	aSmaCCRewriteResult inputSource: input.	stream := SmaCCLineNumberStream on: (ReadStream on: input).	tree := [self parserClass parseStream: stream]		on: SmaCCParserError		do:			[:ex | 			| parser token |			parser := ex parameter.			token := parser errorToken.			token notNil				ifTrue:					[aSmaCCRewriteResult						startLine: (stream lineNumberFor: token startPosition);						startColumn: (stream columnNumberFor: token startPosition);						interval: (token startPosition to: token stopPosition)].			ex pass].	tree		completeSource: input;		filename: aString.	self engine source: (aSmaCCRewriteResult smaccStringClass on: input).	output := [[self engine rewriteTree: tree] on: HaltInterrupt do: [:ex | ex resume]]		on: Error		do:			[:ex | 			| frame node |			frame := thisContext.			[frame isNil or: [(frame receiver isKindOf: SmaCCRewrite) and: [frame method selector = #performOn:continuation:]]]				whileFalse: [frame := frame sender].			frame notNil				ifTrue:					[node := frame tempAt: 1.					aSmaCCRewriteResult						startLine: (stream lineNumberFor: node startPosition);						startColumn: (stream columnNumberFor: node startPosition);						interval: (node startPosition to: node stopPosition);						transformation: frame receiver].			ex pass].	aSmaCCRewriteResult		outputSource: output;		transformedString: self engine source.	dir := aString asFilename head copyWith: Filename getSeparator.	subdirectory := self baseDirectory isEmpty ifTrue: [''] ifFalse: [dir copyFrom: self baseDirectory size + 1 to: dir size].	self		saveOutput: output		in:			subdirectory , (Filename splitExtension: (Filename splitPath: aString) last) first				, (self validationParserClass isNil ifTrue: [''] ifFalse: [self validationParserClass fileExtension]).	self engine additionalFiles keysAndValuesDo: [:file :text | self saveOutput: text in: subdirectory , file].	"self validate: output forResult: aSmaCCRewriteResult"]		on: Error		do:			[:ex | 			aSmaCCRewriteResult type: (output isNil ifTrue: [#error] ifFalse: [#warning]).			aSmaCCRewriteResult errorString: ex description.			(self debug and: [Processor activeProcess respondsTo: #debug]) ifTrue: [Processor activeProcess debug].			ex return].	^aSmaCCRewriteResult</body><body package="SmaCC Rewrite Engine" selector="ruleFile:">ruleFile: aString	self parseRewriteRuleFile: aString</body><body package="SmaCC Rewrite Engine" selector="rules">rules	^rules</body><body package="SmaCC Rewrite Engine" selector="rules:">rules: aCollection	rules := aCollection</body><body package="SmaCC Rewrite Engine" selector="saveOutput:in:">saveOutput: aString in: aFilename	| stream directory fullFilename |	(self outputDirectory isNil or: [self outputDirectory isEmpty]) ifTrue: [^self].	fullFilename := self outputDirectory asFilename constructString: aFilename.	directory := fullFilename asFilename head.	self createDirectory: directory.	stream := fullFilename asFilename writeStream.	stream lineEndCRLF.	[stream nextPutAll: aString] ensure: [stream close]</body><body package="SmaCC Rewrite Engine" selector="sourceFor:">sourceFor: aString	| stream |	stream := aString asFilename readStream.	stream lineEndCRLF.	^[([#[239 187 191] allSatisfy: [:each | stream peekFor: (Character value: each)]] on: Error do: [:ex | ex return: false])		ifFalse: [stream position: 0].	"HACK to handle UTF-8 streams"	stream upToEnd] ensure: [stream close]</body><body package="SmaCC Rewrite Engine" selector="validate:forResult:">validate: aString forResult: aSmaCCRewriteResult	| stream |	self validationParserClass isNil ifTrue: [^self].	stream := SmaCCLineNumberStream on: (ReadStream on: aString).	[self validationParserClass parseStream: stream]		on: SmaCCParserError		do:			[:ex | 			| parser token |			parser := ex parameter.			token := parser errorToken.			token notNil				ifTrue:					[aSmaCCRewriteResult						startLine: (stream lineNumberFor: token startPosition);						startColumn: (stream columnNumberFor: token startPosition);						interval: (token startPosition to: token stopPosition)].			aSmaCCRewriteResult				errorString: 'Validation error';				type: #warning]</body><body package="SmaCC Rewrite Engine" selector="validationParserClass">validationParserClass	^validationParserClass</body><body package="SmaCC Rewrite Engine" selector="validationParserClass:">validationParserClass: aSmaCCParserClass	validationParserClass := aSmaCCParserClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteProcessor class</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="debug">debug	^Debug ifNil: [false]</body><body package="SmaCC Rewrite Engine" selector="debug:">debug: aBoolean	Debug := aBoolean</body><body package="SmaCC Rewrite Engine" selector="haltBlock">haltBlock	^HaltBlock ifNil: [[:rewrite :node | false]]</body><body package="SmaCC Rewrite Engine" selector="haltBlock:">haltBlock: aBlock	HaltBlock := aBlock</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAnnotatedString</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="addAnnotationTo:">addAnnotationTo: aSmaCCAnnotatedStringInterval	(node isNil or: [rule isNil]) ifTrue: [^self].	aSmaCCAnnotatedStringInterval addAnnotation: (SmaCCRewriteAnnotation onNode: node rewrite: rule)</body><body package="SmaCC Rewrite Engine" selector="node">node	^node</body><body package="SmaCC Rewrite Engine" selector="node:">node: aSmaCCParseNode	node := aSmaCCParseNode</body><body package="SmaCC Rewrite Engine" selector="rule">rule	^rule</body><body package="SmaCC Rewrite Engine" selector="rule:">rule: aSmaCCRewrite	rule := aSmaCCRewrite</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAnnotatedString</class-id> <category>editing</category><body package="SmaCC Rewrite Engine" selector="removeInterval:">removeInterval: startInterval	| result |	result := super removeInterval: startInterval.	self addAnnotationTo: result.	^result</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAnnotatedString</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="intervalClass">intervalClass	^SmaCCAnnotatedStringInterval</body><body package="SmaCC Rewrite Engine" selector="newIntervalFor:">newIntervalFor: aString	| interval |	interval := super newIntervalFor: aString.	self addAnnotationTo: interval.	^interval</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeReplaceExpression</class-id> <category>evaluating</category><body package="SmaCC Rewrite Engine" selector="evaluateInContext:">evaluateInContext: aSmaCCRewriteMatchContext	| value |	value := self method valueWithReceiver: aSmaCCRewriteMatchContext arguments: #().	^(value isString or: [value isKindOf: SmaCCString])		ifTrue: [value]		ifFalse: [aSmaCCRewriteMatchContext sourceFrom: aSmaCCRewriteMatchContext match startPosition to: aSmaCCRewriteMatchContext match stopPosition]</body><body package="SmaCC Rewrite Engine" selector="method">method	^self		attributeNamed: #method		ifAbsentPut:			[| source method tree |			source := 'code ' , code value.			tree := RBParser parseMethod: source.			tree body statements isEmpty ifTrue: [tree := RBParser parseMethod: 'code ^'''''].			tree body addReturn.			source := tree formattedCode.			method := (Object compilerClass new				compile: source				in: SmaCCRewriteMatchContext				notifying: nil				ifFail: [^nil]) generate.			method]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeReplaceExpression</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="acceptVisitor:">acceptVisitor: aReplaceVisitor	^aReplaceVisitor visitCodeReplace: self</body><body package="SmaCC Rewrite Engine" selector="code">code	^code</body><body package="SmaCC Rewrite Engine" selector="code:">code: aSmaCCToken	code := aSmaCCToken</body><body package="SmaCC Rewrite Engine" selector="tokenVariables">tokenVariables	^#(#code)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="areRewritesModified">areRewritesModified	^self rewrites notNil and: [self rewrites isModified]</body><body package="SmaCC Rewrite Engine" selector="isModified">isModified	^modified or: [self areRewritesModified]</body><body package="SmaCC Rewrite Engine" selector="isModified:">isModified: aBoolean	modified := aBoolean</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="createSubdirectories">createSubdirectories	^createSubdirectories ifNil: [false]</body><body package="SmaCC Rewrite Engine" selector="createSubdirectories:">createSubdirectories: aBoolean	createSubdirectories := aBoolean.	modified := true.	self triggerEvent: #createSubdirectories with: aBoolean</body><body package="SmaCC Rewrite Engine" selector="files">files	^files ifNil: [#() asList]</body><body package="SmaCC Rewrite Engine" selector="files:">files: aCollection	files := aCollection asList.	modified := true.	self triggerEvent: #files with: aCollection</body><body package="SmaCC Rewrite Engine" selector="inputParserClass">inputParserClass	^inputParserClass</body><body package="SmaCC Rewrite Engine" selector="inputParserClass:">inputParserClass: aSmaCCParserClass	inputParserClass := aSmaCCParserClass.	modified := true.	self triggerEvent: #inputParserClass with: aSmaCCParserClass</body><body package="SmaCC Rewrite Engine" selector="outputDirectory">outputDirectory	^outputDirectory ifNil: ['']</body><body package="SmaCC Rewrite Engine" selector="outputDirectory:">outputDirectory: aString	outputDirectory := aString.	modified := true.	self triggerEvent: #outputDirectory with: aString</body><body package="SmaCC Rewrite Engine" selector="rewrites">rewrites	^rewrites</body><body package="SmaCC Rewrite Engine" selector="rewrites:">rewrites: aSmaCCRewrite	rewrites := aSmaCCRewrite.	modified := true.	self triggerEvent: #rewrites with: aSmaCCRewrite</body><body package="SmaCC Rewrite Engine" selector="runOnServer">runOnServer	^runOnServer ifNil: [false]</body><body package="SmaCC Rewrite Engine" selector="runOnServer:">runOnServer: aBoolean	runOnServer := aBoolean.	modified := true.	self triggerEvent: #runOnServer with: aBoolean</body><body package="SmaCC Rewrite Engine" selector="server">server	^(server isNil or: [server isEmpty]) ifTrue: ['localhost'] ifFalse: [server]</body><body package="SmaCC Rewrite Engine" selector="server:">server: aString	server := aString.	modified := true.	self triggerEvent: #server with: aString</body><body package="SmaCC Rewrite Engine" selector="serverName">serverName	^(self serverAndPort: 36rSM from: self server) first</body><body package="SmaCC Rewrite Engine" selector="serverPort">serverPort	^(self serverAndPort: 36rSM from: self server) last</body><body package="SmaCC Rewrite Engine" selector="validationParserClass">validationParserClass	^validationParserClass</body><body package="SmaCC Rewrite Engine" selector="validationParserClass:">validationParserClass: aSmaCCParserClass	validationParserClass := aSmaCCParserClass.	modified := true.	self triggerEvent: #validationParserClass with: aSmaCCParserClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>actions</category><body package="SmaCC Rewrite Engine" selector="loadFile:">loadFile: aString	| stream |	stream := aString asFilename readStream.	[Compiler		evaluate: stream contents		for: self		logged: false.	self isModified: false] ensure: [stream close]</body><body package="SmaCC Rewrite Engine" selector="loadRewriteFile:">loadRewriteFile: aString	aString isNil ifTrue: [^self].	self rewrites: (self openRewriteFile: aString)</body><body package="SmaCC Rewrite Engine" selector="saveRewrites">saveRewrites	self rewrites save</body><body package="SmaCC Rewrite Engine" selector="saveTo:">saveTo: filename	| stream |	stream := filename asFilename writeStream.	[stream		nextPutAll: 'self';		crtab;		nextPutAll: 'inputParserClass: ';		nextPutAll: self inputParserClass storeString;		nextPut: $;;		crtab;		nextPutAll: 'validationParserClass: ';		nextPutAll: self validationParserClass storeString;		nextPut: $;;		crtab;		nextPutAll: 'loadRewriteFile: ';		nextPutAll: self rewrites filename storeString;		nextPut: $;;		crtab;		nextPutAll: 'files: ';		nextPutAll: self files asArray storeString;		nextPut: $;;		crtab;		nextPutAll: 'outputDirectory: ';		nextPutAll: self outputDirectory storeString;		nextPut: $;;		crtab;		nextPutAll: 'createSubdirectories: ';		nextPutAll: self createSubdirectories storeString;		nextPut: $;;		crtab;		nextPutAll: 'server: ';		nextPutAll: self server storeString;		nextPut: $;;		crtab;		nextPutAll: 'runOnServer: ';		nextPutAll: self runOnServer storeString] ensure: [stream close].	modified := false.	self areRewritesModified ifTrue: [self saveRewrites]</body><body package="SmaCC Rewrite Engine" selector="toggleUseServer">toggleUseServer	self runOnServer: self runOnServer not</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="serverAndPort:from:">serverAndPort: defaultPort from: aString	| serverName port parts |	parts := aString tokensBasedOn: $:.	(parts size = 2 and: [parts last notEmpty and: [parts last allSatisfy: [:each | each isDigit]]])		ifTrue:			[serverName := parts first.			port := Number fromString: parts last]		ifFalse:			[serverName := aString.			port := defaultPort].	^Array with: serverName with: port</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>event triggering</category><body package="SmaCC Rewrite Engine" selector="triggerEvent:with:">triggerEvent: aSymbol with: aValue		self changed: aSymbol with: aValue.	^super triggerEvent: aSymbol with: aValue</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>running</category><body package="SmaCC Rewrite Engine" selector="commonParentDirectory">commonParentDirectory	| common |	(self files isEmpty or: [self createSubdirectories not]) ifTrue: [^''].	common := self files first asFilename head.	self files		do:			[:each | 			[each beginsWith: common]				whileFalse:					[common := (common isEmpty or: [common size = 3 and: [(common at: 2) = $:]])						ifTrue: ['']						ifFalse: [(common copyFrom: 1 to: common size - 1) asFilename head]]].	^common</body><body package="SmaCC Rewrite Engine" selector="localRunOn:">localRunOn: aCollection	(SmaCCRewriteProcessor new)		rules: self rewrites;		parserClass: self inputParserClass;		validationParserClass: self validationParserClass;		files: aCollection;		outputDirectory: self outputDirectory;		baseDirectory: self commonParentDirectory;		processAllNotifying: [:each | self triggerEvent: #resultAdded with: each]</body><body package="SmaCC Rewrite Engine" selector="serverRunOn:">serverRunOn: aCollection	| baseString stream socket request connection serverStream |	baseString := 'INPUTPARSER=' , self inputParserClass name , ';REWRITEFILE=' , self rewrites filename.	self outputDirectory notEmpty ifTrue: [baseString := baseString , ';OUTPUTDIRECTORY=' , self outputDirectory].	baseString := baseString , ';BASEDIRECTORY=' , self commonParentDirectory.	self validationParserClass notNil ifTrue: [baseString := baseString , ';OUTPUTPARSER=' , self validationParserClass name].	stream := WriteStream on: String new.	aCollection		do:			[:each | 			stream				nextPutAll: baseString;				nextPutAll: ';FILE=';				nextPutAll: each;				nextPut: (Character value: 0)].	request := stream contents.	socket := SocketAccessor		newTCPclientToHost: self serverName		port: self serverPort.	connection := ExternalConnection new.	connection		input: socket;		output: socket.	serverStream := (connection withEncoding: #binary) readAppendStream.	[serverStream		nextPut: $1 asInteger;		nextPut: (request size bitAnd: 16rFF);		nextPut: ((request size bitShift: -8) bitAnd: 16rFF);		nextPut: ((request size bitShift: -16) bitAnd: 16rFF);		nextPut: ((request size bitShift: -24) bitAnd: 16rFF);		nextPutAll: request asByteArray;		flush.	aCollection size		timesRepeat:			[self				triggerEvent: #resultAdded				with:					(SmaCCRewriteResult						fromSocketString:							(serverStream next: serverStream next + (serverStream next bitShift: 8) + (serverStream next bitShift: 16) + (serverStream next bitShift: 24))								asString)]] ensure: [socket close]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>initialize-release</category><body package="SmaCC Rewrite Engine" selector="initialize">initialize	super initialize.	modified := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>actions-rewrites</category><body package="SmaCC Rewrite Engine" selector="openRewriteFile:">openRewriteFile: filename	^filename asFilename exists		ifTrue: [SmaCCRewriteRuleFileParser parseFile: filename]		ifFalse:			[(SmaCCRewriteFile new)				filename: filename;				yourself]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel</class-id> <category>actions-running</category><body package="SmaCC Rewrite Engine" selector="runOn:">runOn: tranformationFiles	self runOnServer ifTrue: [self serverRunOn: tranformationFiles] ifFalse: [self localRunOn: tranformationFiles]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTransformationToolkitModel class</class-id> <category>instance creation</category><body package="SmaCC Rewrite Engine" selector="new">new		^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileParser</class-id> <category>generated-reduction actions</category><body package="SmaCC Rewrite Engine" selector="reduceActionForComment2:">reduceActionForComment2: nodes	^((nodes at: 1) value copyFrom: 2 to: (nodes at: 1) value size - 1) copyReplaceAll: '""' with: '"'</body><body package="SmaCC Rewrite Engine" selector="reduceActionForFile1:">reduceActionForFile1: nodes	^nodes at: 1</body><body package="SmaCC Rewrite Engine" selector="reduceActionForImport1:">reduceActionForImport1: nodes	^((nodes at: 3) value copyFrom: 2 to: (nodes at: 3) value size - 1) copyReplaceAll: '''''' with: ''''</body><body package="SmaCC Rewrite Engine" selector="reduceActionForMatch1:">reduceActionForMatch1: nodes	^(SmaCCRewriteTreeMatch new)		source: (nodes at: 1);		yourself</body><body package="SmaCC Rewrite Engine" selector="reduceActionForMatch2:">reduceActionForMatch2: nodes	^(SmaCCRewriteTreeMatch new)		source: (nodes at: 2);		startingState: (nodes at: 1) value;		yourself</body><body package="SmaCC Rewrite Engine" selector="reduceActionForMatch3:">reduceActionForMatch3: nodes	^SmaCCRewriteTypeMatch on: (self lookupClass: (nodes at: 1))</body><body package="SmaCC Rewrite Engine" selector="reduceActionForMatch4:">reduceActionForMatch4: nodes	^(SmaCCRewriteTypeMatch on: (self lookupClass: (nodes at: 1)))		code: (nodes at: 2);		yourself</body><body package="SmaCC Rewrite Engine" selector="reduceActionForParserClass1:">reduceActionForParserClass1: nodes	^self lookupClass: (nodes at: 3)</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRule1:">reduceActionForRule1: nodes	^SmaCCRewrite		comment: (nodes at: 1)		match: (nodes at: 2)		transformation: (nodes at: 4)</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRules1:">reduceActionForRules1: nodes	^(SmaCCRewriteFile new)		filename: filename;		yourself</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRules2:">reduceActionForRules2: nodes	^(nodes at: 1)		addTransformation: (nodes at: 2);		yourself</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRules3:">reduceActionForRules3: nodes	^(nodes at: 1)		parserClass: (nodes at: 2);		yourself</body><body package="SmaCC Rewrite Engine" selector="reduceActionForRules4:">reduceActionForRules4: nodes	^(nodes at: 1)		import: (nodes at: 2);		yourself</body><body package="SmaCC Rewrite Engine" selector="reduceActionForStartSmalltalkExpression1:">reduceActionForStartSmalltalkExpression1: nodes	^self scanSmalltalkExpression</body><body package="SmaCC Rewrite Engine" selector="reduceActionForStartStringExpression1:">reduceActionForStartStringExpression1: nodes	^self scanStringExpression</body><body package="SmaCC Rewrite Engine" selector="reduceActionForTransformation1:">reduceActionForTransformation1: nodes	^SmaCCRewriteStringTransformation on: (nodes at: 1)</body><body package="SmaCC Rewrite Engine" selector="reduceActionForTransformation2:">reduceActionForTransformation2: nodes	^SmaCCRewriteCodeTransformation on: (nodes at: 1)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileParser</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="reduceTable">reduceTable^#(	#(20 0 #reduceActionForRules1:) 	#(17 0 #nil) 	#(16 1 #reduceActionForFile1:) 	#(17 1 #reduceActionForComment2:) 	#(20 2 #reduceActionForRules3:) 	#(20 2 #reduceActionForRules2:) 	#(23 0 #reduceActionForStartStringExpression1:) 	#(20 2 #reduceActionForRules4:) 	#(18 1 #reduceActionForMatch3:) 	#(24 0 #reduceActionForStartSmalltalkExpression1:) 	#(18 1 #reduceActionForMatch1:) 	#(13 3 #reduceActionForParserClass1:) 	#(27 3 #reduceActionForImport1:) 	#(18 2 #reduceActionForMatch2:) 	#(18 2 #reduceActionForMatch4:) 	#(14 4 #reduceActionForRule1:) 	#(19 1 #reduceActionForTransformation1:) 	#(19 1 #reduceActionForTransformation2:) 	#(21 3 #reduceActionForFile1:) 	#(22 3 #reduceActionForFile1:)	).</body><body package="SmaCC Rewrite Engine" selector="transitionTable">transitionTable^#(#[1 0 6 0 3 0 6 0 4 0 6 0 8 0 6 0 9 0 6 0 11 0 9 0 16 0 13 0 20 0 6 0 25] #[0 0 0 0 25] #[1 0 17 0 3 0 21 0 4 0 10 0 8 0 10 0 9 0 25 0 11 0 29 0 13 0 33 0 14 0 37 0 17 0 14 0 25 0 41 0 27] #[0 0 45 0 2] #[0 0 49 0 2] #[0 0 18 0 8 0 9] #[0 0 22 0 3 0 4 0 8 0 9 0 11 0 25] #[0 0 26 0 3 0 4 0 8 0 9 0 11 0 25] #[1 0 30 0 8 0 53 0 9 0 57 0 18 0 61 0 21 0 65 0 23] #[0 0 34 0 3 0 4 0 8 0 9 0 11 0 25] #[0 0 69 0 9] #[0 0 73 0 10] #[1 0 38 0 5 0 42 0 6 0 30 0 8 0 77 0 21 0 81 0 22 0 65 0 23 0 85 0 24] #[0 0 89 0 5] #[0 0 46 0 5] #[0 0 93 0 8] #[0 0 50 0 3 0 4 0 8 0 9 0 11 0 25] #[0 0 54 0 3 0 4 0 8 0 9 0 11 0 25] #[0 0 58 0 5] #[0 0 62 0 5] #[0 0 97 0 6] #[1 0 42 0 6 0 30 0 8 0 101 0 19 0 105 0 21 0 109 0 22 0 65 0 23 0 85 0 24] #[0 0 113 0 7] #[0 0 117 0 1] #[0 0 66 0 3 0 4 0 8 0 9 0 11 0 25] #[0 0 70 0 3 0 4 0 8 0 9 0 11 0 25] #[0 0 74 0 3 0 4 0 8 0 9 0 11 0 25] #[0 0 78 0 3 0 4 0 5 0 8 0 9 0 11 0 25] #[0 0 82 0 3 0 4 0 5 0 8 0 9 0 11 0 25]	).</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileParser</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="filename:">filename: aString	filename := aString</body><body package="SmaCC Rewrite Engine" selector="lookupClass:">lookupClass: aSmaCCToken	| string block |	string := aSmaCCToken value.	block := [:each | each name asString = string ifTrue: [^each]].	SmaCCParseNode withAllSubclasses do: block.	SmaCCParser allSubclassesDo: block.	^nil</body><body package="SmaCC Rewrite Engine" selector="scanSmalltalkExpression">scanSmalltalkExpression	^scanner scanSmalltalkExpression</body><body package="SmaCC Rewrite Engine" selector="scanStringExpression">scanStringExpression	^scanner scanStringExpression</body><body package="SmaCC Rewrite Engine" selector="tryAllTokens">tryAllTokens	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileParser class</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="parseFile:">parseFile: aString	| stream |	stream := aString asFilename readStream.	^[| parser |	parser := self on: stream.	parser filename: aString.	(parser parse)		filename: aString;		finishedLoading;		yourself] ensure: [stream close]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileParser class</class-id> <category>file types</category><body package="SmaCC Rewrite Engine" selector="fileExtension">fileExtension	^'.rw'</body><body package="SmaCC Rewrite Engine" selector="fileExtensionType">fileExtensionType	^'SmaCC Rewrite files'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileParser class</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="definitionComment">definitionComment"&lt;singleName&gt;	: (&lt;isLetter&gt; | _) (&lt;isLetter&gt; | &lt;isDigit&gt; | _)*	;&lt;name&gt;	: &lt;singleName&gt; (\. &lt;singleName&gt;)*	;&lt;string&gt;	: (\' [^\']* \') +	;&lt;cmt&gt;	: (\""[^\""]*\"")+	;&lt;whitespace&gt;	: &lt;isSeparator&gt;+	;File	: Rules {'1'}	;Rules	: {SmaCCRewriteFile new filename: filename; yourself}	| Rules Rule {'1' addTransformation: '2'; yourself}	| Rules ParserClass {'1' parserClass: '2'; yourself}	| Rules Import {'1' import: '2'; yourself}	;ParserClass	: ""Parser"" "":"" &lt;name&gt; 'name' {self lookupClass: name}	;Import	: ""Import"" "":"" &lt;string&gt; 'name' {(name value copyFrom: 2 to: name value size - 1) copyReplaceAll: '''''' with: ''''}	;Rule	: Comment 'comment' Match 'match' ""-&gt;"" Transformation 'transformation' {SmaCCRewrite comment: comment match: match transformation: transformation}	;Comment	: {nil}	| &lt;cmt&gt; {('1' value copyFrom: 2 to: '1' value size - 1) copyReplaceAll: '""""' with: '""'}	;Match	: StringExpression {SmaCCRewriteTreeMatch new source: '1'; yourself}	| &lt;name&gt; 'state' StringExpression 'exp' {SmaCCRewriteTreeMatch new source: exp; startingState: state value; yourself}	| &lt;name&gt; {SmaCCRewriteTypeMatch on: (self lookupClass: '1')}	| &lt;name&gt; Block {(SmaCCRewriteTypeMatch on: (self lookupClass: '1')) code: '2'; yourself}	;StringExpression	: StartStringExpression 'string' ""&gt;&gt;&gt;"" ""&lt;&lt;&lt;"" {string}	;Transformation	: StringExpression {SmaCCRewriteStringTransformation on: '1'}	| Block {SmaCCRewriteCodeTransformation on: '1'}	;Block	: StartSmalltalkExpression 'string' ""[""  ""]"" {string}	;StartStringExpression	: {self scanStringExpression}	;StartSmalltalkExpression	: {self scanSmalltalkExpression}	;"</body><body package="SmaCC Rewrite Engine" selector="startingStateForFile">startingStateForFile	^1</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRewriteRuleFileParser class</class-id> <category>generated-accessing</category><body package="SmaCC Rewrite Engine" selector="scannerClass">scannerClass	^SmaCCRewriteRuleFileScanner</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionScanner</class-id> <category>generated</category><body package="SmaCC Rewrite Engine" selector="codeExpressionId">codeExpressionId	^13</body><body package="SmaCC Rewrite Engine" selector="emptySymbolTokenId">emptySymbolTokenId	^24</body><body package="SmaCC Rewrite Engine" selector="errorTokenId">errorTokenId	^25</body><body package="SmaCC Rewrite Engine" selector="scanForToken">scanForToken	state == #expression		ifTrue:			[self step.			currentCharacter == $\ ifTrue: [^self recordAndReportMatch: #(2)].			currentCharacter == $_ ifTrue: [^self recordAndReportMatch: #(4)].			currentCharacter == $` ifTrue: [^self recordAndReportMatch: #(6)].			((currentCharacter between: $! and: $/)				or:					[(currentCharacter between: $: and: $@)						or: [currentCharacter == $[ or: [(currentCharacter between: $] and: $^) or: [currentCharacter between: ${ and: $~]]]])				ifTrue:					[[self recordMatch: #(3).					self step.					(currentCharacter between: $! and: $/)						or:							[(currentCharacter between: $: and: $@)								or: [currentCharacter == $[ or: [(currentCharacter between: $] and: $^) or: [currentCharacter between: ${ and: $~]]]]] whileTrue.					^self reportLastMatch].			currentCharacter isLetter				ifTrue:					[[self recordMatch: #(1).					self step.					currentCharacter isLetter or: [currentCharacter isAlphaNumeric]] whileTrue].			^self reportLastMatch].	state == #default		ifTrue:			[self step.			currentCharacter == $`				ifTrue:					[self recordMatch: #(6).					self step.					currentCharacter == $` ifTrue: [^self recordAndReportMatch: #(7)].					^self reportLastMatch].			true				ifTrue:					[[self recordMatch: #(5).					self step.					currentCharacter ~~ $`] whileTrue].			^self reportLastMatch].	state == #code		ifTrue:			[2				timesRepeat:					[self step.					currentCharacter == $` ifFalse: [^self reportLastMatch]].			^self recordAndReportMatch: #(7)].	^self reportLastMatch</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionScanner</class-id> <category>accessing</category><body package="SmaCC Rewrite Engine" selector="next">next	state = #code		ifTrue:			[self resetScanner.			returnMatchBlock := [:match | ^match].			^self scanCode].	^super next</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionScanner</class-id> <category>private</category><body package="SmaCC Rewrite Engine" selector="scanCode">scanCode	outputStream reset.	[outputStream nextPutAll: (stream upTo: $`).	stream peek == $`		ifTrue:			[self isValidCode				ifTrue:					[stream skip: -1.					state := #default.					^self recordAndReportMatch: (Array with: self codeExpressionId)]].	stream atEnd ifTrue: [^self reportLastMatch].	outputStream nextPut: $`] repeat</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReplaceExpressionScanner</class-id> <category>testing</category><body package="SmaCC Rewrite Engine" selector="isValidCode">isValidCode	RBParser parseExpression: outputStream contents onError: [:s :p | ^false].	^true</body></methods><methods><class-id>Core.String</class-id> <category>SmaCC</category><body package="SmaCC Rewrite Engine" selector="splitFirstOn:andThen:do:">splitFirstOn: firstCharacter andThen: secondCharacter do: aBlock	(self tokensBasedOn: firstCharacter)		do:			[:each | 			| index |			index := each indexOf: secondCharacter.			index ~= 0 ifTrue: [aBlock value: (each copyFrom: 1 to: index - 1) value: (each copyFrom: index + 1 to: each size)]]</body></methods><initialize><class-id>Refactory.SmaCC.SmaCCRewriteMatchContext</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SmaCCParseNodeVisitor</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>SmaCCParser</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken errorToken stateStack nodeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>SmaCCString</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstSentinel lastSentinel currentId cachedInterval </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Source Editing</category><attributes><package>SmaCC Source Editing</package></attributes></class><class><name>SmaCCScanner</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock state comments </inst-vars><class-inst-vars>keywordMap </class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>SmaCCStringInterval</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id start stop next previous string isRemoved </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Source Editing</category><attributes><package>SmaCC Source Editing</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SmaCCParseNode</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>