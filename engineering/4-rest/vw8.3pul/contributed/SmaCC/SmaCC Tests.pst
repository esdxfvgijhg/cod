<?xml version="1.0"?><st-source><!-- Name: SmaCC TestsNotice: Comment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains some simple tests for SmaCC. If you wish to port SmaCC or if you want to verify you installation of SmaCC, then these may be useful to you. Under VisualWorks, these tests require loading the MethodWrappers package.If you want more information about SmaCC, visit http://www.refactoryworkers.com/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2010 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: bear73DbTrace: 317932DevelopmentPrerequisites: #(#(#any 'SmaCC Source Editing' '') #(#any 'SmaCC Development' '') #(#any 'SUnitToo' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: SmaCC TestsParcel: #('SmaCC Tests')PrerequisiteDescriptions: #(#(#name 'SmaCC Source Editing') #(#name 'SmaCC Development') #(#name 'SUnitToo'))PrerequisiteParcels: #(#('SmaCC Source Editing' '') #('SmaCC Development' '') #('SUnitToo' ''))PrintStringCache: (2.0.3,brant)Version: 2.0.3Date: 9:56:24 AM January 28, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:56:24 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SmaCCEndToEndTest</name><environment>Refactory.SmaCC</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentClasses currentPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><class><name>DuplicationNodeEliminationTest</name><environment>Refactory.SmaCC</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><class><name>LineNumberStreamTest</name><environment>Refactory.SmaCC</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><class><name>SmaCCStringTest</name><environment>Refactory.SmaCC</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><methods><class-id>Refactory.SmaCC.SmaCCEndToEndTest</class-id> <category>tests-parse tree creation</category><body package="SmaCC Tests" selector="testAutoAnnotateTokens">testAutoAnnotateTokens	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;name&gt; : \w+; &lt;whitespace&gt; : \s+; 			%annotate_tokens;			%root FooNode;			A : "(" &lt;name&gt; "&lt;&lt;" "test" ")" {{FooANode}} ; '.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '( foo &lt;&lt; test )'.	self assert: node nameToken value = 'foo'.	self assert: node leftParenToken value = '('.	self assert: node lessThanLessThanToken value = '&lt;&lt;'.	self assert: node testToken value = 'test'.	self assert: node rightParenToken value = ')'</body><body package="SmaCC Tests" selector="testBadNode">testBadNode	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;whitespace&gt; : \s+; 			%root FooNode;			A : B "a" ''a'' {{FooNode}} ;			B : A | C ;			C : "c" ''c''; '.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'c a  a a'.	self assert: node c startPosition = 1.	self assert: node as size = 3.	self checkTokensAreInOrder: node as</body><body package="SmaCC Tests" selector="testChildrenVariables">testChildrenVariables	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			%hierarchy If (IfElse);			%left "+" "-" ;			If : "if" number ''a'' "then" number ''b'' {{If}}				| "if" number ''a'' "then" number ''b'' "else" number ''c'' {{IfElse}};			number : &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'if 1 then 2 else 3'.	self assert: node class name asString = 'FooIfElseNode'.	self assert: node children size = 3</body><body package="SmaCC Tests" selector="testChildrenWhenNodeTypeNotSpecified">testChildrenWhenNodeTypeNotSpecified	| compiler node values |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '%root Program;			%prefix Test;			%suffix Node;			&lt;id&gt; : [a-zA-Z]+;			&lt;num&gt; : [0-9]+;			&lt;whitespace&gt; : [\s]+;			Start : Expr ";" ;			Expr : Term ''left'' "+" ''op''  Expr ''right''   {{Binary}}			     | Term ''left'' "-" ''op'' Expr ''right''        {{Binary}}			     | Term ;			Term : Factor ''left'' "*" ''op'' Term ''right'' {{Binary}}			     | Factor ''left'' "/" ''op'' Term ''right''       {{Binary}}			     | Factor ;			Factor : &lt;num&gt; ''value''                  {{Constant}}			        | &lt;id&gt; ''name'' "(" Expr ''argument'' ")"        {{Function}}			        | "(" Expr ")" ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 + 2;'.	self assert: node children size = 2.	values := #('1' '2') asSet.	node children do: [:each | values remove: each value value]</body><body package="SmaCC Tests" selector="testChildrenWhenNodeTypeNotSpecifiedAndCouldBeToken">testChildrenWhenNodeTypeNotSpecifiedAndCouldBeToken	| compiler node values |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '%root Program;			%prefix Test;			%suffix Node;			&lt;id&gt; : [a-zA-Z]+;			&lt;num&gt; : [0-9]+;			&lt;whitespace&gt; : [\s]+;			Start : Expr ";" ;			Expr : Term ''left'' "+" ''op''  Expr ''right''   {{Binary}}			     | Term ''left'' "-" ''op'' Expr ''right''        {{Binary}}			     | Term ;			Term : Factor ''left'' "*" ''op'' Term ''right'' {{Binary}}			     | Factor ''left'' "/" ''op'' Term ''right''       {{Binary}}			     | Factor ;			Factor : &lt;num&gt; ''value''                  {{Constant}}			        | &lt;id&gt; ''name'' "(" Expr ''argument'' ")"        {{Function}}				  | "(" Q ")" ;			Q : Expr | &lt;id&gt; ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 + 2;'.	self assert: node children size = 2.	values := #('1' '2') asSet.	node children do: [:each | values remove: each value value]</body><body package="SmaCC Tests" selector="testCollectionSuperclass">testCollectionSuperclass	| parserCompiler node copy |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; %hierarchy Expression (Number Binary); 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| &lt;number&gt; ''number'' {{Number}}				| "(" ''leftParen'' Expression ")" ''rightParen'' {{Expression}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '(2 + 3 - (4))'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node leftParens size = 1.	self assert: node class superclass name asString = 'FooExpressionNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right leftParens size = 1.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testCollectionSuperclassWithCodeNode">testCollectionSuperclassWithCodeNode	| parserCompiler node copy |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; %hierarchy Expression (Number Binary); 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| Number {''1''}				| "(" ''leftParen'' Expression ")" ''rightParen'' {{Expression}} ;			Number : &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '(2 + 3 - (4))'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node leftParens size = 1.	self assert: node class superclass name asString = 'FooExpressionNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right leftParens size = 1.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testCollectionSuperclassWithImplicitPullUp">testCollectionSuperclassWithImplicitPullUp	| parserCompiler node copy |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; %hierarchy Expression (Number Binary); 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| Number				| "(" ''leftParen'' Expression ")" ''rightParen'' {{Expression}} ;			Number : &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '(2 + 3 - (4))'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node leftParens size = 1.	self assert: node class superclass name asString = 'FooExpressionNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right leftParens size = 1.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testCopyCollection">testCopyCollection	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node;			%left "+" "-" ;			ExpressionList : ExpressionList Expression ''expression'' {{ExpressionList}}  | Expression ''expression'' {{ExpressionList}};			Expression : Number ;			Number : &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 2 3 4'.	self assert: (node copyInContext: Dictionary new) = node</body><body package="SmaCC Tests" selector="testDefaultClassNameWithUnderscore">testDefaultClassNameWithUnderscore	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%root Test ; %prefix Foo; %suffix Node; 			test_class : "a" ''letter'' {{}};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooTestClassNode'.	self assert: node class superclass name asString = 'FooTestNode'.	(self lookupType: #FooTestNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testEmptyAlternative">testEmptyAlternative	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '%root FooNode;			A : B ''component'' {{FooANode}} ;			B :  | C ; 			C : "c" ''c'' {{FooCNode}} ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'c'.	self assert: node class name asString = 'FooANode'.	self assert: node component c value = 'c'.	self assert: node component parent == node.	node := self parserClass parse: ''.	self assert: node component isNil</body><body package="SmaCC Tests" selector="testLeftAndRightRecursive">testLeftAndRightRecursive	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Foo : Number ''number'' {{Collection}}				| "(" ''leftParen'' Foo ")" ''rightParen'' {{Collection}} ;			Number : &lt;number&gt; ''token'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '(((4)))'.	self assert: node leftParens size = 3.	self assert: node rightParens size = 3.	self assert: node number token value = '4'.	self checkTokensAreInOrder: node leftParens.	self checkTokensAreInOrder: node rightParens.	self assert: node children size = 1.	self assert: node children first == node number.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testLeftRecursive">testLeftRecursive	| parserCompiler node copy |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Foo : Number ''number'' {{Collection}}				| Foo "," ''comma'' Number ''number'' {{Collection}} ;			Number : &lt;number&gt; ''token'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 , 2 , 3 , 4'.	self assert: node numbers size = 4.	node numbers keysAndValuesDo: 			[:key :each |			self assert: key printString = each token value.			self assert: each parent == node.			self assert: (node children includes: each)].	self assert: node commas size = 3.	node commas do: [:each | self assert: each value = ','].	copy := node copy.	self assert: copy ~~ node.	self assert: copy numbers ~~ node numbers.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testMatchCollection">testMatchCollection	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node;			%left "+" "-" ;			ExpressionList : ExpressionList Expression ''expression'' {{ExpressionList}}  | Expression ''expression'' {{ExpressionList}};			Expression : Number ;			Number : &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 2 3 4'.	self assert: (node match: node inContext: Dictionary new)</body><body package="SmaCC Tests" selector="testMultipleComponents">testMultipleComponents	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '%root FooNode;			A : B C {{FooANode}} ;			B : "b" ''b'' ;			C : "c" ''c'';'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'bc'.	self assert: node class name asString = 'FooANode'.	self assert: node b startPosition = 1.	self assert: node c startPosition = 2</body><body package="SmaCC Tests" selector="testMultipleTypes">testMultipleTypes	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : B | C ;			B : "b" ''b'' D {{FooBNode}} ;			C : "c" ''c'' D {{FooCNode}};			D : Number ''number'' | D "," ''comma'' Number ''number'' ;			Number : &lt;number&gt; ''number'' {{FooNumberNode}};'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'b 1, 2, 3, 4'.	self assert: node class name asString = 'FooBNode'.	node numbers keysAndValuesDo: 			[:key :each |			self assert: key printString = each number value.			self assert: each parent == node].	self assert: node numbers size = 4.	self assert: node commas size = 3</body><body package="SmaCC Tests" selector="testName">testName	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;name&gt; : \w+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : name ''nameNode'' {{FooANode}} ;			name : simple | composite ;			simple : &lt;name&gt; ''name'' {{FooNameNode}};			composite : name ''base'' "." ''period'' &lt;name&gt; ''name'' {{FooFullNameNode}}; '.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'a.b.c'.	self assert: node nameNode name value = 'c'.	self assert: node nameNode parent == node.	self assert: node nameNode base name value = 'b'.	self assert: node nameNode base parent == node nameNode.	self assert: node nameNode base base name value = 'a'.	self assert: node nameNode base base parent == node nameNode base</body><body package="SmaCC Tests" selector="testNamedSubComponent">testNamedSubComponent	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : {{FooANode}} | "a" ''a'' A ''sub'' {{FooANode}} ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'aaa'.	self assert: node class name asString = 'FooANode'.	self assert: node a startPosition = 1.	self assert: node sub a startPosition = 2.	self assert: node sub parent == node.	self assert: node sub sub a startPosition = 3.	self assert: node sub sub parent == node sub.	self assert: node sub sub sub a isNil.	self assert: node sub sub sub parent == node sub sub.	self assert: node sub sub sub sub isNil</body><body package="SmaCC Tests" selector="testNodeAndExpression">testNodeAndExpression	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '%root FooNode;			A : B "a" ''a'' {{FooNode}} ;			B : {Object new} ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'a'.	self assert: node a value = 'a'</body><body package="SmaCC Tests" selector="testNodeClassName">testNodeClassName	| compiler pattern |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;name&gt; : [a-z]+; &lt;whitespace&gt; : \s+; &lt;patternToken&gt; : (\`  [^\`]* \`)+ ; %glr;			%root FooNode;			A : Name | Number ;			Name : &lt;name&gt;''name'' {{FooNameNode}};			Number : &lt;number&gt; ''number'' {{FooNumberNode}};'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	pattern := self parserClass parse: '`a{nodeClassName: #FooNumberNode}`'.	self assert: (pattern match: (self parserClass parse: '123')				inContext: Dictionary new).	self		deny: (pattern match: (self parserClass parse: 'abc') inContext: Dictionary new)</body><body package="SmaCC Tests" selector="testNodeWithoutRoot">testNodeWithoutRoot	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildDefinition: 'test : "a" ''letter'' {{FooNode}};'.	self should: 			[parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser']		raise: SmaCCCompilationNotification</body><body package="SmaCC Tests" selector="testNonRecursiveVariableInsideRecursiveProduction">testNonRecursiveVariableInsideRecursiveProduction	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;whitespace&gt; : \s+; 			%root FooNode;			A : B "a" ''letter'' {{FooNode}} ;			B : A | C ;			C : "c" ''c'' {{FooNode}};'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'c a a a'.	self assert: node c value = 'c'.	self assert: node letters size = 3</body><body package="SmaCC Tests" selector="testOptionalCollection">testOptionalCollection	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : B_opt {{FooANode}} ;			B_opt : B | ;			B : Number ''numberNode'' | B Number ''numberNode'' ;			Number : &lt;number&gt; ''number'' {{FooNumberNode}};'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 2 3 4'.	node numberNodes keysAndValuesDo: 			[:key :each |			self assert: key printString = each number value.			self assert: each parent == node].	self assert: node numberNodes size = 4</body><body package="SmaCC Tests" selector="testOptionalComponent">testOptionalComponent	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : B {{FooANode}} ;			B : "b" ''b'' | ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: ''.	self assert: node b isNil.	node := self parserClass parse: 'b'.	self assert: node b startPosition = 1</body><body package="SmaCC Tests" selector="testPassThrough">testPassThrough	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : B ''b'' {{FooANode}} ;			B : C ;			C : Number;			Number : &lt;number&gt; ''number'' {{FooNumberNode}}; '.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '12'.	self assert: node class name asString = 'FooANode'.	self assert: node b parent == node.	self assert: node b number startPosition = 1.	self assert: node b number value = '12'</body><body package="SmaCC Tests" selector="testPerformanceMatchCollection">testPerformanceMatchCollection	| parserCompiler node match fastTime slowTime |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d; &lt;whitespace&gt; : \s+; 			&lt;patternToken&gt;: (\`  [^\`]* \`)+ ;			%glr;			%root Parse ; %prefix Foo; %suffix Node;			%left "+" "-" ;			ExpressionList : ExpressionList Expression ''expression'' {{ExpressionList}}  | Expression ''expression'' {{ExpressionList}};			Expression : Number ;			Number : &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: (String new: 1000 withAll: $1) , '22'						, (String new: 1000 withAll: $1).	fastTime := Time				millisecondsToRun: [self assert: (node match: node inContext: Dictionary new)].	match := self parserClass parse: '`a{beList}` 22 `b{beList}`'.	slowTime := Time millisecondsToRun: 					[self assert: (match match: node inContext: Dictionary new)].	self assert: (fastTime min: 1) * 10 &gt; slowTime</body><body package="SmaCC Tests" selector="testPrefixSuffix">testPrefixSuffix	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%root Test ; %prefix Foo; %suffix Node; 			test : "a" ''letter'' {{Test}};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooTestNode'.	self assert: node class superclass = SmaCCParseNode.	(self lookupType: #FooTestNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testPrefixSuffixWithDefaultClassName">testPrefixSuffixWithDefaultClassName	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%root Test ; %prefix Foo; %suffix Node; 			test : "a" ''letter'' {{}};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooTestNode'.	self assert: node class superclass = SmaCCParseNode.	(self lookupType: #FooTestNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testPullUpCollectionVariables">testPullUpCollectionVariables	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : AList {{FooNode}} ;			AList : B | AList B;			B : &lt;number&gt; ''number'' ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 2 3 4'.	node numbers		keysAndValuesDo: [:key :each | self assert: key printString = each value].	self assert: node numbers size = 4</body><body package="SmaCC Tests" selector="testPullUpMultipleTypes">testPullUpMultipleTypes	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : D B {{FooBNode}} | D C {{FooCNode}};			B : "b" ''b'' D ;			C : "c" ''c'' D ;			D : Number ''number'' | D Number ''number'' ;			Number : &lt;number&gt; ''number'' {{FooNumberNode}};'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '0 b 1 2 3 4'.	self assert: node class name asString = 'FooBNode'.	node numbers keysAndValuesDo: 			[:key :each |			self assert: (key - 1) printString = each number value.			self assert: each parent == node].	self assert: node numbers size = 5</body><body package="SmaCC Tests" selector="testPullUpNullNodeAsVariables">testPullUpNullNodeAsVariables	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '%glr;			&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : B D {{FooANode}};			B : &lt;number&gt; ''a'' &lt;number&gt; ''b'' {{FooBNode}} | ;			D : &lt;number&gt; ''c''; '.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 2 3'.	self assert: node class name asString = 'FooANode'.	self assert: node a value = '1'.	self assert: node b value = '2'.	self assert: node c value = '3'.	node := self parserClass parse: '1'.	self assert: node a isNil.	self assert: node b isNil.	self assert: node c value = '1'</body><body package="SmaCC Tests" selector="testPullUpVariablesForLaterSymbols">testPullUpVariablesForLaterSymbols	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : "a" ''a'' B_opt {{FooNode}} ;			B_opt : B | ;			B : &lt;number&gt; ''number'' | B &lt;number&gt; ''number'' ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'a 1 2 3 4'.	node numbers		keysAndValuesDo: [:key :each | self assert: key printString = each value].	self assert: node numbers size = 4.	node := self parserClass parse: 'a'.	self assert: node numbers isEmpty</body><body package="SmaCC Tests" selector="testRightRecursive">testRightRecursive	| parserCompiler node copy |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Foo : Number ''number'' {{Collection}}				| Number ''number''  "," ''comma'' Foo {{Collection}} ;			Number : &lt;number&gt; ''token'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 , 2 , 3 , 4'.	self assert: node numbers size = 4.	node numbers keysAndValuesDo: 			[:key :each |			self assert: key printString = each token value.			self assert: each parent == node.			self assert: (node children includes: each)].	self assert: node commas size = 3.	node commas inject: 0		into: 			[:sum :each |			self assert: sum &lt; each startPosition.			each startPosition].	node commas do: [:each | self assert: each value = ','].	copy := node copy.	self assert: copy ~~ node.	self assert: copy numbers ~~ node numbers.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testSimpleHierarchy">testSimpleHierarchy	| parserCompiler node copy |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			%hierarchy Binary (Plus Minus);			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Plus}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Minus}}				| &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '2 + 3 - 4'.	self assert: node class name asString = 'FooMinusNode'.	self assert: node operator value = '-'.	self assert: node class superclass name asString = 'FooBinaryNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node left class name asString = 'FooPlusNode'.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testSimpleNode">testSimpleNode	| parserCompiler node |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%root FooNode ;			test : "a" ''letter'' {{FooNode}};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooNode'.	self assert: node letter value = 'a'.	self assert: node letter startPosition = 1.	self assert: node letter stopPosition = 1.	self assert: node class superclass = SmaCCParseNode.	self assert: node copy ~~ node.	self assert: node copy letter ~~ node letter.	self assert: node = node copy.	self assert: node hash = node copy hash.	(self lookupType: #FooNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testSimpleTree">testSimpleTree	| parserCompiler node copy |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| &lt;number&gt; ''number'' {{Number}} ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '2 + 3 - 4'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node class superclass name asString = 'FooParseNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node</body><body package="SmaCC Tests" selector="testUnnamedCollectionSymbol">testUnnamedCollectionSymbol	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : B {{FooANode}} ;			B : "b" ''b'' {{FooBNode}} | B "b" ''b'' {{FooBNode}} ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'b'.	self assert: node class name asString = 'FooANode'.	self assert: node bs first value = 'b'</body><body package="SmaCC Tests" selector="testUnnamedSymbol">testUnnamedSymbol	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : B {{FooANode}} ;			B : "b" ''b'' {{FooBNode}} ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: 'b'.	self assert: node class name asString = 'FooANode'.	self assert: node b value = 'b'</body><body package="SmaCC Tests" selector="testUseWithoutClassDefinition">testUseWithoutClassDefinition	| compiler node |	compiler := SmaCCGrammarCompiler new.	compiler		buildDefinition: '&lt;number&gt; : \d+; &lt;whitespace&gt; : \s+; 			%root FooNode;			A : &lt;number&gt; ''left'' B ''operator'' &lt;number&gt; ''right'' {{FooNode}} ;			B : C ;			C : "+" | "-" | "*" | "/" ;'.	compiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	node := self parserClass parse: '1 + 3'.	self assert: node operator value = '+'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEndToEndTest</class-id> <category>tests</category><body package="SmaCC Tests" selector="expressionParserString">expressionParserString	^'%left "+" "-" ;%left "*" "/" ;%right "^" ;Expression: Expression ''first'' "+" Expression ''last'' {first + last}	| Expression "-" Expression {''1'' - ''3''}	| Expression "*" Expression {''1'' * ''3''}	| Expression "/" Expression {''1'' / ''3''}	| Expression "^" Expression {''1'' raisedTo: ''3''} 	| "(" Expression ")" {''2''}	| &lt;number&gt; {''1'' value asNumber};'</body><body package="SmaCC Tests" selector="expressionScannerString">expressionScannerString	^'&lt;number&gt;	:	[0-9]+ (\. [0-9]+) ? ;&lt;whitespace&gt;	:	\s+;'</body><body package="SmaCC Tests" selector="testAmbiguousReduceReduceConflict">testAmbiguousReduceReduceConflict	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;int&gt; : \d+; &lt;whitespace&gt;: \s+;			%glr;			Expression : Left "!" "&lt;" {''1''} | Right "!" "&gt;" {''1''} ;			Left : &lt;int&gt; "+" &lt;int&gt; "*" &lt;int&gt; {''1'' value asNumber + ''3'' value asNumber * ''5'' value asNumber};			Right : &lt;int&gt; "+" &lt;int&gt; "*" &lt;int&gt; {''1'' value asNumber + (''3'' value asNumber * ''5'' value asNumber)};			'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: '2 + 3 * 4!&lt;') = 20.	self assert: (self parserClass parse: '2 + 3 * 4!&gt;') = 14.	self should: [self parserClass parse: '2 + 3 * 4!!'] raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testAmbiguousResultWithDifferentScannerTokens">testAmbiguousResultWithDifferentScannerTokens	| parserCompiler results result |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%id &lt;a&gt; &lt;aa&gt;;			&lt;a&gt; : a ; &lt;aa&gt; : aa;			%glr;			List : Item {''1''} | List Item {''1'' + ''2''} ;			Item : &lt;a&gt; {1} | &lt;aa&gt; {1.5};			'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self parserClass compile: 'alwaysPerformReduceAction ^true'.	self parserClass		compile: 'actionsForCurrentToken 		| oldToken oldPosition |		(currentToken ids includes: scanner aaId) ifTrue: [			oldToken := currentToken.			oldPosition := scanner position.			self position: currentToken stopPosition - 1.			currentToken := currentToken class value: ''a'' start: currentToken startPosition ids: (Array with: scanner aId).			super actionsForCurrentToken do: [:each | self splitWithAction: each].			currentToken := oldToken.			self position: oldPosition.		].		^super actionsForCurrentToken'.	self assert: (self parserClass parse: 'a') = 1.	[result := self parserClass parse: 'aa'] on: SmaCCAmbiguousResultNotification		do: 			[:ex |			results := ex parameter						collect: [:each | each performOnSmaCCParser: ex parser].			ex resume: 0].	self assert: result = 0.	self assert: results size = 2.	self assert: (results includes: 2).	self assert: (results includes: 1.5)</body><body package="SmaCC Tests" selector="testAmbiguousResults">testAmbiguousResults	| parserCompiler results result |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;int&gt; : \d+; &lt;whitespace&gt;: \s+;			%glr;			Expression : Expression "+" Expression {''1'' + ''3''}				| Expression "*" Expression {''1'' * ''3''}				| &lt;int&gt; {''1'' value asNumber};			'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self parserClass compile: 'alwaysPerformReduceAction ^true'.	self assert: (self parserClass parse: '3 + 4') = 7.	self assert: (self parserClass parse: '3 * 4') = 12.	[result := self parserClass parse: '2 + 3 * 4']		on: SmaCCAmbiguousResultNotification		do: 			[:ex |			results := ex parameter						collect: [:each | each performOnSmaCCParser: ex parser].			ex resume: 0].	self assert: result = 0.	self assert: results size = 2.	self assert: (results includes: 20).	self assert: (results includes: 14).	"There are a bunch of ways to parse the following expression. If we don't merge the possibilities, then this will never complete."	self		assert: (self parserClass				parse: '1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1')					= 60</body><body package="SmaCC Tests" selector="testBadCharacterBlock">testBadCharacterBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	self should: 			[parserCompiler buildDefinition: '&lt;foo&gt; : [a-] ;					Start : &lt;foo&gt;;'.			parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser']		raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testBadSmalltalkBlock">testBadSmalltalkBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	self should: 			[parserCompiler				buildDefinition: '&lt;foo&gt; : foo ;					Start : &lt;foo&gt; {self printOn: };'.			parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser']		raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testComments">testComments	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;a&gt; : /* q */ /***/ /****/ a # b 				;			/* */ /***/ /****/			#this is a comment			begin : &lt;a&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'a')</body><body package="SmaCC Tests" selector="testCrLf">testCrLf	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildDefinition: '&lt;a&gt; : \r? \n | \r ;			A : &lt;a&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self		assert: (self parserClass parse: (String with: Character cr with: Character lf)).	self		should: [self parserClass parse: (String with: Character cr with: Character cr)]		raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testErrorToken">testErrorToken	| parserCompiler countingBlock |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;name&gt; : [a-zA-Z]+; &lt;whitespace&gt;: \s+;			%left "+"; Expression : &lt;name&gt; | Expression "+" Expression {[Notification signal] on: Error do: [:ex | ex return: (Notification raise)]} | error "+" Expression ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	countingBlock :=			[:string |			| count |			count := 0.						[[self parserClass parse: string] on: Notification				do: 					[:ex |					count := count + 1.					[ex resume] on: Error						do: 							[:ex1 |							ex isResumable: true.							ex1 retry]]]					on: SmaCCParserError					do: [:ex | ex return].			count].	#(#('a + b + c' 2) #('+ a + b + c' 2) #('a + b +' 1) #('a + 1 / 2 + b + c + 3' 2) #('1 + 1 / 2 + b + c + 3' 1))		do: [:each | self assert: (countingBlock value: each first) = each last]</body><body package="SmaCC Tests" selector="testErrors">testErrors	| parserCompiler position |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: self expressionScannerString , self expressionParserString.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self parserClass parse: '+3*4' onError: [:str :pos | position := pos].	self assert: position = 1.	self parserClass parseStream: (ReadStream on: '1+a+4')		onError: [:str :pos | position := pos].	self assert: position = 3</body><body package="SmaCC Tests" selector="testExcludeScannerState">testExcludeScannerState	| parserCompiler parser |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%excludes a;			&lt;foo&gt; : b;			a &lt;bar&gt; : a;			Start : &lt;foo&gt; {true} | &lt;bar&gt; {false};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'b').	self should: [self parserClass parse: 'a'] raise: SmaCCParserError.	parser := self parserClass on: (ReadStream on: 'a').	parser state: #a.	self deny: parser parse.	parser := self parserClass on: (ReadStream on: 'b').	parser state: #a.	self should: [parser parse] raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testExistingVariables">testExistingVariables	| parserCompiler |	Refactory.SmaCC		defineClass: #TestScanner		superclass: #{Refactory.SmaCC.SmaCCScanner}		indexedType: #none		private: false		instanceVariableNames: 'scanner1 scanner2'		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	Refactory.SmaCC		defineClass: #TestParser		superclass: #{Refactory.SmaCC.SmaCCParser}		indexedType: #none		private: false		instanceVariableNames: 'parser1 parser2'		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;a&gt; : \{ | \&lt; \% ;			&lt;all&gt; : .;			%id &lt;_all&gt; &lt;a&gt; &lt;all&gt;;  			begin : A {true}					| All {false};			A : &lt;a&gt; ;			All: &lt;_all&gt;;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner' andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self scannerClass instVarNames includes: 'scanner1').	self assert: (self scannerClass instVarNames includes: 'scanner2').	self assert: (self parserClass instVarNames includes: 'parser1').	self assert: (self parserClass instVarNames includes: 'parser2')</body><body package="SmaCC Tests" selector="testExpressions">testExpressions	#(#LR1 #LALR1) do: 			[:each |			| parserCompiler |			parserCompiler := SmaCCGrammarCompiler new.			parserCompiler grammar type: each.			parserCompiler				buildDefinition: self expressionScannerString , self expressionParserString.			parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser'.			self assert: (self parserClass parse: '2 + 3 * 4 / 5 ^ 3 ^ 2')						= (2 + (3 * 4 / (5 raisedTo: (3 raisedTo: 2)))).			self assert: (self parserClass parse: '1.0*2/3+4.0^2^3+3')						= (1.0 * 2 / 3 + (4.0 raisedTo: (2 raisedTo: 3)) + 3).			self assert: (self parserClass parse: '(((1 + 2) * 3) ^ 2) ^ 3')						= (((1 + 2) * 3 raisedTo: 2) raisedTo: 3)]</body><body package="SmaCC Tests" selector="testGLRHierarchy">testGLRHierarchy	| parserCompiler |	Refactory.SmaCC		defineClass: #FooParser		superclass: #{Refactory.SmaCC.SmaCCGLRParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	Refactory.SmaCC		defineClass: #TestParser		superclass: #{Refactory.SmaCC.FooParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase; %glr;			&lt;a&gt; : \{ | \&lt; \% ;			&lt;all&gt; : .;			%id &lt;_all&gt; &lt;a&gt; &lt;all&gt;;  			begin : A {true}					| All {false};			A : &lt;a&gt; ;			All: &lt;_all&gt;;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner' andParser: 'Refactory.SmaCC.TestParser'.	self assert: self parserClass superclass name asString = 'FooParser'</body><body package="SmaCC Tests" selector="testHierarchy">testHierarchy	| parserCompiler |	Refactory.SmaCC		defineClass: #FooScanner		superclass: #{Refactory.SmaCC.SmaCCScanner}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	Refactory.SmaCC		defineClass: #TestScanner		superclass: #{Refactory.SmaCC.FooScanner}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	Refactory.SmaCC		defineClass: #FooParser		superclass: #{Refactory.SmaCC.SmaCCParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	Refactory.SmaCC		defineClass: #TestParser		superclass: #{Refactory.SmaCC.FooParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;a&gt; : \{ | \&lt; \% ;			&lt;all&gt; : .;			%id &lt;_all&gt; &lt;a&gt; &lt;all&gt;;  			begin : A {true}					| All {false};			A : &lt;a&gt; ;			All: &lt;_all&gt;;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner' andParser: 'Refactory.SmaCC.TestParser'.	self assert: self scannerClass superclass name asString = 'FooScanner'.	self assert: self parserClass superclass name asString = 'FooParser'</body><body package="SmaCC Tests" selector="testIgnoreCaseKeywords">testIgnoreCaseKeywords	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;identifier&gt; : [a-z_]+ ; &lt;whitespace&gt; : \s+ ;			Start ::= "Foo" {true} | &lt;identifier&gt; &lt;identifier&gt; {false};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'FOo').	self deny: (self parserClass parse: 'FoObAr ASDS')</body><body package="SmaCC Tests" selector="testIgnoreCaseTokens">testIgnoreCaseTokens	| parserCompiler result |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;whitespace&gt; : \s+ ;			Start ::= "a" "a" {Array with: ''1'' with: ''2''};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	result := self parserClass parse: 'a A'.	self assert: result first = result last.	self assert: result first hash = result last hash</body><body package="SmaCC Tests" selector="testIgnoreCaseWithMultipleKeywordCases">testIgnoreCaseWithMultipleKeywordCases	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;whitespace&gt; : \s+ ;			Start ::= "if" "If" "iF" "IF" {true}; '.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'IF IF IF IF').	self assert: (self parserClass parse: 'iF If IF If')</body><body package="SmaCC Tests" selector="testImplicitParserTokens">testImplicitParserTokens	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildDefinition: 'A : &lt;isLetter&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'a').	self should: [self parserClass parse: ' '] raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testImplicitScannerTokens">testImplicitScannerTokens	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildDefinition: '&lt;a&gt; : &lt;isLetter&gt; + ;			A : &lt;a&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'asdfssdafADSFS').	self should: [self parserClass parse: ' asdf asdf'] raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testImplicitTokenPrecedence">testImplicitTokenPrecedence	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;a&gt; : . ;			A : &lt;a&gt; {true} | &lt;isLetter&gt; {false};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	0 to: 255		do: [:each | self assert: (self parserClass parse: (String with: (Character value: each)))]</body><body package="SmaCC Tests" selector="testInvertedCharactersBlock">testInvertedCharactersBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;A&gt; : a{1,3} ;			&lt;ID&gt; : [^a]+ ;			&lt;comment&gt; : \s+ ;			begin : {0} | begin &lt;A&gt; {''1'' + 1} | begin &lt;ID&gt; {''1'' - 1};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'aa') = 1.	self assert: (self parserClass parse: 'aaaa') = 2.	self assert: (self parserClass parse: 'a bab') = 0</body><body package="SmaCC Tests" selector="testKeywords">testKeywords	| parserCompiler size |	size := SmaCCGrammar maximumCharacterValue.	self supportsUnicodeStrings		ifTrue: [SmaCCGrammar maximumCharacterValue: (2 raisedTo: 16) - 1].		[parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildDefinition: '%ignorecase;			Start ::= "Foo" "bar";'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self parserClass parse: 'FoObAr']			ensure: [SmaCCGrammar maximumCharacterValue: size]</body><body package="SmaCC Tests" selector="testLALRErrorHandler">testLALRErrorHandler	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;whitespace&gt; : \s+ ;			Start : Foo "]" Foo ")";			Foo : "a" Bar ;			Bar : "b" | error ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self should: [self parserClass parse: 'a ] a b )'] raise: SmaCCParserError.	self should: [self parserClass parse: 'a ) a b )'] raise: SmaCCParserError.	self should: [self parserClass parse: 'a b ] a  ]'] raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testMoveFromGLRHierarchy">testMoveFromGLRHierarchy	| parserCompiler |	Refactory.SmaCC		defineClass: #FooParser		superclass: #{Refactory.SmaCC.SmaCCGLRParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	Refactory.SmaCC		defineClass: #TestParser		superclass: #{Refactory.SmaCC.FooParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;a&gt; : \{ | \&lt; \% ;			&lt;all&gt; : .;			%id &lt;_all&gt; &lt;a&gt; &lt;all&gt;;  			begin : A {true}					| All {false};			A : &lt;a&gt; ;			All: &lt;_all&gt;;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner' andParser: 'Refactory.SmaCC.TestParser'.	self assert: self parserClass superclass name asString = 'SmaCCParser'</body><body package="SmaCC Tests" selector="testMoveToGLRHierarchy">testMoveToGLRHierarchy	| parserCompiler |	Refactory.SmaCC		defineClass: #FooParser		superclass: #{Refactory.SmaCC.SmaCCParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	Refactory.SmaCC		defineClass: #TestParser		superclass: #{Refactory.SmaCC.FooParser}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase; %glr;			&lt;a&gt; : \{ | \&lt; \% ;			&lt;all&gt; : .;			%id &lt;_all&gt; &lt;a&gt; &lt;all&gt;;  			begin : A {true}					| All {false};			A : &lt;a&gt; ;			All: &lt;_all&gt;;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner' andParser: 'Refactory.SmaCC.TestParser'.	self assert: self parserClass superclass name asString = 'SmaCCGLRParser'</body><body package="SmaCC Tests" selector="testMultipleStartingPositions">testMultipleStartingPositions	| parserCompiler position |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;name&gt; : \w+;			%start plus ;			multiply: plus "*" plus {true};			plus: &lt;name&gt; {false} | &lt;name&gt; "+" &lt;name&gt; {false};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'a*a').	self assert: (self parserClass parse: 'a+a*a').	self should: [self parserClass parse: 'a+a'] raise: SmaCCParserError.	self		deny: (self parserClass parse: 'a+a' startingAt: self parserClass startingStateForplus).	self parserClass		parse: 'a*a'		startingAt: self parserClass startingStateForplus		onError: [:str :pos | position := pos].	self assert: position = 2</body><body package="SmaCC Tests" selector="testNonAssociativeTokens">testNonAssociativeTokens	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;IDENTIFIER&gt; : \w+ ; &lt;whitespace&gt; : \s+ ;			%left "and" ;			%nonassoc "=" "&lt;=";			%left "+" ;			expr : expr "=" expr {true} | expr "&lt;=" expr {true} | expr "and" expr {true} | expr "+" expr {true} | &lt;IDENTIFIER&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self should: [self parserClass parse: 'a=b=c'] raise: SmaCCParserError.	self should: [self parserClass parse: 'a=b&lt;=c'] raise: SmaCCParserError.	self should: [self parserClass parse: 'a=b+c=d'] raise: SmaCCParserError.	self assert: (self parserClass parse: 'a=b and c=d')</body><body package="SmaCC Tests" selector="testOverlappingTokens">testOverlappingTokens	| parserCompiler result |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;id1&gt; : \w+; &lt;id2&gt; : \w+;			%glr;			Test : "keyword" {''1''} | &lt;id1&gt; {''1''} | &lt;id2&gt; {''1''} ;			'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	result := self parserClass parse: 'keyword'.	self assert: result ids size = 3</body><body package="SmaCC Tests" selector="testPriority">testPriority	| parserCompiler |	Refactory.SmaCC		defineClass: #TestScanner		superclass: #{Refactory.SmaCC.SmaCCScanner}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: 'SmaCC Tests'.	(self lookupType: #TestScanner) compile: 'all ^self recordAndReportMatch: (Array with: self _allId)'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;a&gt; : \{ | \&lt; \% ;			&lt;all&gt; : .;			%id &lt;_all&gt; &lt;a&gt; &lt;all&gt;;  			begin : A {true}					| All {false};			A : &lt;a&gt; ;			All: &lt;_all&gt;;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner' andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: '{').	self assert: (self parserClass parse: '&lt;%').	self deny: (self parserClass parse: '}')</body><body package="SmaCC Tests" selector="testRecursiveRule">testRecursiveRule	#(#LR1 #LALR1) do: 			[:each |			| parserCompiler |			parserCompiler := SmaCCGrammarCompiler new.			parserCompiler grammar type: each.			parserCompiler buildDefinition: self expressionScannerString						, 'Test: Test1 Recursive;							Test1: &lt;number&gt; {''1'' value};							Recursive: | Recursive "|" &lt;number&gt; {''1'' add: ''3'' value; yourself};'.			parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser'.			self				assert: ((parserCompiler grammar nonTerminalSymbolNamed: 'Recursive')						firstTerminals							includes: (parserCompiler grammar keywordTerminalNamed: '"|"')).			self assert: (self parserClass parse: '2|3|4') asOrderedCollection						= (OrderedCollection with: '2' with: '3' with: '4')]</body><body package="SmaCC Tests" selector="testReduceReduceConflict">testReduceReduceConflict	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;letter&gt; : \w ;			&lt;whitespace&gt;: \s+	;			begin : Foo &lt;letter&gt; {true} | Bar &lt;letter&gt; {false};			Foo :  ;			Bar : ;'.	self		assert: (			[parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser'.			false]					on: SmaCCCompilationNotification					do: 						[:ex |						('*Reduce/Reduce*' match: ex messageText)							ifTrue: [ex return: true]							ifFalse: [ex resume: nil]])</body><body package="SmaCC Tests" selector="testReduceRules">testReduceRules	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;char&gt; : [a-zA-Z] ; 			&lt;ws&gt; : \s ;			Start ::= Chars {#liftFirstValue:};			Chars : WS A WS {#liftSecondValue:};			A : WS WS C {#liftLastValue:} | C WS {#liftLastValue:};			WS : &lt;ws&gt; {#nil};			C : &lt;char&gt; {#stringValue:};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: ' a  ') isNil.	self assert: (self parserClass parse: '   a ') = 'a'</body><body package="SmaCC Tests" selector="testRepeat">testRepeat	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;letters&gt; : [a-zA-Z];			&lt;test&gt; : (\`[^\`]*\`)+;			All : | All Test ;			Test : &lt;letters&gt; | &lt;test&gt; ;'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: '`a`b`c`') size = 3</body><body package="SmaCC Tests" selector="testRepeatingCharactersBlock">testRepeatingCharactersBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;A&gt; : a{1,3} ;			&lt;ID&gt; : \w+ ;			&lt;whitespace&gt; : \s+ ;			begin : {true} | begin &lt;A&gt; {''1''} | begin &lt;ID&gt; {false};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'aa').	self deny: (self parserClass parse: 'aaaa')</body><body package="SmaCC Tests" selector="testReuseCompositeToken">testReuseCompositeToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;LETTERDIGIT&gt; : [a-zA-Z_] \d ;			&lt;AAorBB&gt; :  aa | bb;			&lt;IDENTIFIER&gt;: &lt;LETTERDIGIT&gt; | &lt;AAorBB&gt;	;			&lt;whitespace&gt;: \s+	;			begin : &lt;IDENTIFIER&gt; begin {false} | &lt;IDENTIFIER&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self should: [self parserClass parse: '2'] raise: SmaCCParserError.	self assert: (self parserClass parse: 'aa').	self assert: (self parserClass parse: 'bb').	self assert: (self parserClass parse: 'a4').	self should: [self parserClass parse: 'ab'] raise: SmaCCParserError.	self should: [self parserClass parse: '4b'] raise: SmaCCParserError</body><body package="SmaCC Tests" selector="testReuseSimpleToken">testReuseSimpleToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;LETTER&gt; : [a-zA-Z_\\] ;			&lt;DIGIT&gt; : [0-9] ;			&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;)*	;			&lt;whitespace&gt;: \s+	;			begin : &lt;IDENTIFIER&gt; begin {false} | &lt;IDENTIFIER&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self should: [self parserClass parse: '2'] raise: SmaCCParserError.	self assert: (self parserClass parse: '\')</body><body package="SmaCC Tests" selector="testScannerState">testScannerState	| parserCompiler parser |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%states a ;			&lt;foo&gt; : b;			a &lt;bar&gt; : a;			Start : &lt;foo&gt; {true} | &lt;bar&gt; {false};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass parse: 'b').	self should: [self parserClass parse: 'a'] raise: SmaCCParserError.	parser := self parserClass on: (ReadStream on: 'a').	parser state: #a.	self deny: parser parse.	parser := self parserClass on: (ReadStream on: 'b').	parser state: #a.	self assert: parser parse</body><body package="SmaCC Tests" selector="testSimple">testSimple	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildDefinition: '&lt;a&gt; : a ;			begin : &lt;a&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self should: [self parserClass parse: '2'] raise: SmaCCParserError.	self assert: (self parserClass parse: 'a')</body><body package="SmaCC Tests" selector="testSpecialCharacters">testSpecialCharacters	| parserCompiler maxValue |	[String with: (Character value: 16rFF00)] on: Error do: [:ex | ^self].	"Unicode characters not supported"	maxValue := SmaCCGrammar maximumCharacterValue.	SmaCCGrammar maximumCharacterValue: 65535.		[parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '%ignorecase;			&lt;name&gt; : \x3g \x20 \xFF \xFF1 \xFF00 \cC;			begin ::= &lt;name&gt; {true};'.	parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'		andParser: 'Refactory.SmaCC.TestParser'.	self assert: (self parserClass				parse: (String withAll: (#(3 103 16r20 16rFF 16rFF1 16rFF00 2)								collect: [:each | Character value: each])))]			ensure: [SmaCCGrammar maximumCharacterValue: maxValue]</body><body package="SmaCC Tests" selector="testUnusedSymbols">testUnusedSymbols	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;letters&gt; : \w+ ;			&lt;whitespace&gt;: \s+	;			%start Bar;			begin : Foo;			Foo :  &lt;letters&gt;;			Bar : Baz ;			Baz : "test" ;'.	self		assert: (			[parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser'.			true]					on: SmaCCCompilationNotification					do: [:ex | ex return: false]).	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler		buildDefinition: '&lt;letters&gt; : \w+ ;			&lt;whitespace&gt;: \s+	;			begin : Foo;			Foo :  &lt;letters&gt;;			Bar : Baz ;			Baz : "test" ;'.	self		assert: (			[parserCompiler compileInto: 'Refactory.SmaCC.TestScanner'				andParser: 'Refactory.SmaCC.TestParser'.			false]					on: SmaCCCompilationNotification					do: [:ex | ex return: true])</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEndToEndTest</class-id> <category>private</category><body package="SmaCC Tests" selector="checkTokensAreInOrder:">checkTokensAreInOrder: tokenCollection 	tokenCollection inject: 0		into: 			[:sum :each | 			self assert: sum &lt; each startPosition.			each startPosition]</body><body package="SmaCC Tests" selector="classesInPackage">classesInPackage	^self package allDefinedClasses</body><body package="SmaCC Tests" selector="lookupType:">lookupType: className 	^self class environment at: className</body><body package="SmaCC Tests" selector="package">package	^#{Store.Registry} value containingPackageForClass: self class</body><body package="SmaCC Tests" selector="parserClass">parserClass	^self lookupType: #TestParser</body><body package="SmaCC Tests" selector="removeClass:">removeClass: aBehavior 	aBehavior removeFromSystem</body><body package="SmaCC Tests" selector="removeNewClasses">removeNewClasses	| classesToRemove |	classesToRemove := self classesInPackage reject: [:each | currentClasses includes: each].	(classesToRemove asSortedCollection: [:a :b | a allSuperclasses size &gt; b allSuperclasses size]) do: [:each | self removeClass: each].	#{Store.Registry} value currentPackage: currentPackage</body><body package="SmaCC Tests" selector="scannerClass">scannerClass	^self lookupType: #TestScanner</body><body package="SmaCC Tests" selector="setUp">setUp	super setUp.	SmaCCCodeGenerator reset.	self setUpClasses</body><body package="SmaCC Tests" selector="setUpClasses">setUpClasses	currentClasses := self classesInPackage.	currentPackage := #{Store.Registry} value currentPackage.	#{Store.Registry} value currentPackage: self package</body><body package="SmaCC Tests" selector="supportsUnicodeStrings">supportsUnicodeStrings	^	[String with: (Character value: 16rFF00).	true] on: Error			do: [:ex | ex return: false]</body><body package="SmaCC Tests" selector="tearDown">tearDown	self removeNewClasses.	super tearDown</body></methods><methods><class-id>Refactory.SmaCC.DuplicationNodeEliminationTest</class-id> <category>tests</category><body package="SmaCC Tests" selector="testDuplicateLoop">testDuplicateLoop	| node1 node2 node3 |	node1 := SmaCCNode new.	node1 action: 1.	node2 := SmaCCNode new.	node2 action: 1.	node3 := SmaCCNode new.	node3 action: 1.	node1 addEdgeTo: node2 onCharacters: 'a'.	node2 addEdgeTo: node3 onCharacters: 'a'.	node3 addEdgeTo: node1 onCharacters: 'a'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 1.	self assert: node1 transitions size = 1.	self assert: (node1 action includes: 1).	self assert: node1 transitions first transitionObjects = 'a'.	self assert: node1 transitions first to = node1</body><body package="SmaCC Tests" selector="testNoDuplicates">testNoDuplicates	| node1 node2 node3 |	node1 := SmaCCNode new.	node1 action: 1.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 3.	node1 addEdgeTo: node2 onCharacters: 'a'.	node2 addEdgeTo: node3 onCharacters: 'a'.	node3 addEdgeTo: node1 onCharacters: 'a'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 3.	self assert: node1 transitions size = 1.	self assert: (node1 action includes: 1).	self assert: node1 transitions first transitionObjects = 'a'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions size = 1.	self assert: (node2 action includes: 2).	self assert: node2 transitions first transitionObjects = 'a'.	node3 := node2 transitions first to.	self deny: node1 = node3.	self deny: node2 = node3.	self assert: node3 transitions size = 1.	self assert: (node3 action includes: 3).	self assert: node3 transitions first transitionObjects = 'a'.	self assert: node3 transitions first to = node1</body><body package="SmaCC Tests" selector="testSimpleDuplicateWithEdges">testSimpleDuplicateWithEdges	| node1 node2 node3 |	node1 := SmaCCNode new.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 2.	node1 addEdgeTo: node2 onCharacters: 'a'.	node1 addEdgeTo: node3 onCharacters: 'b'.	node2 addEdgeTo: node1 onCharacters: 'c'.	node3 addEdgeTo: node1 onCharacters: 'c'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 2.	self assert: node1 transitions size = 1.	self assert: node1 transitions first transitionObjects = 'ab'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions size = 1.	self assert: (node2 action includes: 2).	self assert: node2 transitions first transitionObjects = 'c'.	self assert: node2 transitions first to = node1</body><body package="SmaCC Tests" selector="testSimpleTerminalDuplicate">testSimpleTerminalDuplicate	| node1 node2 node3 |	node1 := SmaCCNode new.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 2.	node1 addEdgeTo: node2 onCharacters: 'a'.	node1 addEdgeTo: node3 onCharacters: 'b'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 2.	self assert: node1 transitions size = 1.	self assert: node1 transitions first transitionObjects = 'ab'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions isEmpty.	self assert: (node2 action includes: 2)</body></methods><methods><class-id>Refactory.SmaCC.LineNumberStreamTest</class-id> <category>tests</category><body package="SmaCC Tests" selector="testCRLFLines">testCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1234\1234\1234\1234')).	1 to: 4		do:			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character lf]</body><body package="SmaCC Tests" selector="testCRLines">testCRLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '1234\1234\1234\1234')).	1 to: 4		do:			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character cr]</body><body package="SmaCC Tests" selector="testEmptyLines">testEmptyLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '\\\')).	1 to: 4		do: 			[:each | 			self assert: stream lineNumber = each.			stream upTo: Character cr]</body><body package="SmaCC Tests" selector="testForwardPositionCRLFLines">testForwardPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1</body><body package="SmaCC Tests" selector="testLFLines">testLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addLFsTo: '1234\1234\1234\1234')).	1 to: 4		do: 			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character lf]</body><body package="SmaCC Tests" selector="testNoLines">testNoLines	| stream index |	stream := SmaCCLineNumberStream on: (ReadStream on: 'this is a test').	self assert: stream lineNumber = 1.	index := 1.	stream do: 			[:each | 			self assert: stream lineNumber = 1.			index := index + 1.			self assert: stream columnNumber = index]</body><body package="SmaCC Tests" selector="testPositionCRLFLines">testPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1</body><body package="SmaCC Tests" selector="testPositionCRLines">testPositionCRLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream skip: -1.	self assert: stream lineNumber = 4.	self assert: stream columnNumber = 1.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 2.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1</body></methods><methods><class-id>Refactory.SmaCC.LineNumberStreamTest</class-id> <category>private</category><body package="SmaCC Tests" selector="addCRLFsTo:">addCRLFsTo: aString 	^aString copyReplaceAll: '\'		with: (String with: Character cr with: Character lf)</body><body package="SmaCC Tests" selector="addCRsTo:">addCRsTo: aString 	^aString copyReplaceAll: '\' with: (String with: Character cr)</body><body package="SmaCC Tests" selector="addLFsTo:">addLFsTo: aString 	^aString copyReplaceAll: '\' with: (String with: Character lf)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringTest</class-id> <category>tests</category><body package="SmaCC Tests" selector="testCombiningDeletedIntervals">testCombiningDeletedIntervals	| string intervalCount current |	string := SmaCCString on: '12345'.	#(3 2 4) do: [:each | string deleteCharacter: each].	self assert: string asString = '15'.	intervalCount := 0.	current := (string instVarAt: (string class instVarNames indexOf: 'firstSentinel')) next.	[current isSentinel]		whileFalse:			[intervalCount := intervalCount + 1.			current := current next].	self assert: intervalCount = 3</body><body package="SmaCC Tests" selector="testCopyFromTo">testCopyFromTo	| string |	string := SmaCCString on: '1245'.	string insert: '3' at: 3.	self assert: (string copyFrom: 2 to: 3) asString = '234'</body><body package="SmaCC Tests" selector="testDeleteAcrossInsert">testDeleteAcrossInsert	| string |	string := SmaCCString on: '1233345'.	string insert: '234' at: 5.	string deleteFrom: 4 to: 5.	self assert: string asString = '12345'</body><body package="SmaCC Tests" selector="testDeleteAcrossInserts">testDeleteAcrossInserts	| string startIndex stopIndex |	string := SmaCCString on: '16'.	startIndex := string insert: '233' at: 2.	stopIndex := string insert: '445' at: 2.	string insert: 'asdf' at: stopIndex.	string deleteFrom: startIndex + 2 to: stopIndex.	self assert: string asString = '123456'</body><body package="SmaCC Tests" selector="testDeleteAll">testDeleteAll	| string |	string := SmaCCString on: 'asdf'.	string deleteFrom: 1 to: 4.	self assert: string asString = ''</body><body package="SmaCC Tests" selector="testDeleteFirst">testDeleteFirst	| string |	string := SmaCCString on: 'asdf'.	string deleteFrom: 1 to: 1.	self assert: string asString = 'sdf'</body><body package="SmaCC Tests" selector="testDeleteLast">testDeleteLast	| string |	string := SmaCCString on: 'asdf'.	string deleteFrom: 4 to: 4.	self assert: string asString = 'asd'</body><body package="SmaCC Tests" selector="testDeleteUpTo">testDeleteUpTo	| string |	string := SmaCCString on: '123456'.	#(1 3) do: [:each | string deleteCharacter: each].	string deleteUpTo: 5.	self assert: string asString = '56'</body><body package="SmaCC Tests" selector="testDeleteUpToEnd">testDeleteUpToEnd	| string |	string := SmaCCString on: '123456'.	#(1 5) do: [:each | string deleteCharacter: each].	string deleteUpToEnd: 3.	self assert: string asString = '2'</body><body package="SmaCC Tests" selector="testDeleteWhitespaceBeforeAfter">testDeleteWhitespaceBeforeAfter	| string |	string := SmaCCString on: '0 asdf 9'.	string deleteWhitespaceBeforeIndex: 4.	self assert: string asString = '0 asdf 9'.	string deleteWhitespaceAfterIndex: 4.	self assert: string asString = '0 asdf 9'.	string deleteWhitespaceBeforeIndex: 3.	self assert: string asString = '0asdf 9'.	string deleteWhitespaceAfterIndex: 6.	self assert: string asString = '0asdf9'</body><body package="SmaCC Tests" selector="testDoubleInsertInMiddle">testDoubleInsertInMiddle	| string index |	string := SmaCCString on: '15'.	index := string insert: '24' at: 2.	string insert: '3' at: index + 1.	self assert: string asString = '12345'</body><body package="SmaCC Tests" selector="testInsertAtBeginning">testInsertAtBeginning	| string |	string := SmaCCString on: '12345'.	string insert: '0' at: 1.	self assert: string asString = '012345'</body><body package="SmaCC Tests" selector="testInsertAtEnd">testInsertAtEnd	| string |	string := SmaCCString on: '12345'.	string insert: '6' at: 6.	self assert: string asString = '123456'</body><body package="SmaCC Tests" selector="testInsertInMiddle">testInsertInMiddle	| string |	string := SmaCCString on: '1245'.	string insert: '3' at: 3.	self assert: string asString = '12345'</body><body package="SmaCC Tests" selector="testInsertOnEmptyString">testInsertOnEmptyString	| string |	string := SmaCCString on: ''.	string insert: '123456' at: 1.	self assert: string asString = '123456'</body><body package="SmaCC Tests" selector="testInsertWhitespace">testInsertWhitespace	| string |	string := SmaCCString		on:			'1' , (String with: Character cr with: Character lf) , '2' , (String with: Character cr) , '3'				, (String with: Character lf) , '4' , (String with: Character lf) , (String with: Character cr) , '5'				, (String with: Character lf).	string		addNewLineWhitespace: ' '		from: 1		to: string size.	self		assert:			string asString				=					('1' , (String with: Character cr with: Character lf) , ' 2' , (String with: Character cr) , ' 3'						, (String with: Character lf) , ' 4' , (String with: Character lf) , ' ' , (String with: Character cr) , ' 5'						, (String with: Character lf) , ' ')</body><body package="SmaCC Tests" selector="testMoveAfter">testMoveAfter	| string |	string := SmaCCString on: '123456'.	string		moveFrom: 1		to: 2		after: 3.	self assert: string asString = '312456'.	string deleteFrom: 1 to: 4.	self assert: string asString = '356'.	string := SmaCCString on: '123456'.	string		moveFrom: 1		to: 3		after: 6.	self assert: string asString = '456123'</body><body package="SmaCC Tests" selector="testMoveBefore">testMoveBefore	| string |	string := SmaCCString on: '123456'.	string		moveFrom: 4		to: 6		before: 3.	self assert: string asString = '124563'.	string deleteFrom: 5 to: 5.	self assert: string asString = '12463'.	string := SmaCCString on: '123456'.	string		moveFrom: 4		to: 6		before: 1.	self assert: string asString = '456123'</body><body package="SmaCC Tests" selector="testMultipleDeleteAll">testMultipleDeleteAll	| string |	string := SmaCCString on: 'asdf'.	#(1 3 4 2) do: [:each | string deleteCharacter: each].	self assert: string asString = ''</body><body package="SmaCC Tests" selector="testMultipleInserts">testMultipleInserts	| string |	string := SmaCCString on: '125'.	string insert: '3' at: 3.	string insert: '4' at: 3.	self assert: string asString = '12345'</body><body package="SmaCC Tests" selector="testMultipleInsertsAndDeletes">testMultipleInsertsAndDeletes	| string indices last |	string := SmaCCString on: ''.	last := 0.	indices := (1 to: 5) collect: [:each | last := string insert: each printString , 'X' at: last + 1].	string deleteFrom: last + 1 to: indices first + 1.	self assert: string asString = '12345'</body><body package="SmaCC Tests" selector="testNoEdits">testNoEdits	| string |	string := SmaCCString on: 'asdf'.	self assert: string asString = 'asdf'</body><body package="SmaCC Tests" selector="testReplaceInserted">testReplaceInserted	| string index |	string := SmaCCString on: '1245'.	index := string insert: 'x' at: 3.	string		replaceFrom: index		to: index		with: '3'.	self assert: string asString = '12345'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>