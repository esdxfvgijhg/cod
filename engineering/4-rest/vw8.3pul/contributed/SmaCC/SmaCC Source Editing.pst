<?xml version="1.0"?><st-source><!-- Name: SmaCC Source EditingNotice: Comment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It has a special string implementation that is used when transforming code. If you want more information about SmaCC, visit http://www.refactoryworkers.com/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2010 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: bear73DbTrace: 317927DevelopmentPrerequisites: #(#(#any 'SmaCC Namespace' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: SmaCC Source EditingParcel: #('SmaCC Source Editing')PrerequisiteParcels: #(#('SmaCC Namespace' ''))PrintStringCache: (2.0.3,brant)Version: 2.0.3Date: 9:56:23 AM January 28, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:56:23 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SmaCCStringInterval</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id start stop next previous string isRemoved </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Source Editing</category><attributes><package>SmaCC Source Editing</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCStringInterval</class-id><body>SmaCCStringInterval is a SmaCCInterval that represents a string that is insert into the SmaCCString.Instance Variables:	id	&lt;Integer&gt;	a unique id for the operation	isRemoved	&lt;Boolean&gt;	is this interval removed?	next	&lt;SmaCCStringInterval&gt;	the next interval in the string	previous	&lt;SmaCCStringInterval&gt;	the previous interval in the string	start	&lt;Integer&gt;	the starting location in the string	stop	&lt;Integer&gt;	the ending location in the string	string	&lt;String&gt;	the text that we are inserting -- we are only inserting from the start index to the stop index</body></comment><class><name>SmaCCStringIndex</name><environment>Refactory.SmaCC</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index intervalId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Source Editing</category><attributes><package>SmaCC Source Editing</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCStringIndex</class-id><body>SmaCCStringIndex is used to index into a SmaCCString. When you perform an insert operation into a SmaCCString, you get a SmaCCStringIndex back so you can index into the newly inserted string.Instance Variables:	index	&lt;Integer&gt;	the index in the SmaCCInterval	intervalId	&lt;Integer&gt;	the SmaCCInterval's id</body></comment><class><name>SmaCCString</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstSentinel lastSentinel currentId cachedInterval </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Source Editing</category><attributes><package>SmaCC Source Editing</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCString</class-id><body>SmaCCString is a special string like object that makes rewriting source code faster. It supports operations to insert and delete text from the middle of strings more efficiently than constructing new strings.Instance Variables:	currentId	&lt;Integer&gt;	the id that is used when constructing new SmaCCIntervals	firstSentinel	&lt;SmaCCStringInterval&gt;	the head of the SmaCCInterval list	lastSentinel	&lt;SmaCCStringInterval&gt;	the tail of the SmaCCInterval list	cachedInterval	&lt;SmaCCStringInterval&gt;	the interval where the last action took place -- most likely it or something nearby will the next thing needed</body></comment><methods><class-id>Refactory.SmaCC.SmaCCStringInterval</class-id> <category>testing</category><body package="SmaCC Source Editing" selector="canBeMergedWith:">canBeMergedWith: nextSmaCCStringInterval	^self id = nextSmaCCStringInterval id		and: [self isRemoved = nextSmaCCStringInterval isRemoved and: [self stop + 1 = nextSmaCCStringInterval start]]</body><body package="SmaCC Source Editing" selector="containsIndex:">containsIndex: anIndex	| indexPosition indexId |	self isSentinel ifTrue: [^true].	anIndex isInteger		ifTrue:			[indexPosition := anIndex.			indexId := 1]		ifFalse:			[indexPosition := anIndex index.			indexId := anIndex intervalId].	^id = indexId and: [(indexPosition between: start and: stop) or: [indexPosition = 0]]</body><body package="SmaCC Source Editing" selector="isEmpty">isEmpty	^start &gt; stop</body><body package="SmaCC Source Editing" selector="isRemoved">isRemoved	^isRemoved</body><body package="SmaCC Source Editing" selector="isSentinel">isSentinel	^id = -1</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringInterval</class-id> <category>accessing</category><body package="SmaCC Source Editing" selector="annotations">annotations	^#()</body><body package="SmaCC Source Editing" selector="annotationsTo:">annotationsTo: lastInterval	| annotations current |	annotations := Set new.	current := self.	[annotations addAll: current annotations.	current ~~ lastInterval]		whileTrue:			[current isSentinel ifTrue: [^nil].			current := current next].	^annotations asOrderedCollection</body><body package="SmaCC Source Editing" selector="asString">asString	(self isRemoved or: [self isEmpty]) ifTrue: [^''].	^string copyFrom: start to: stop</body><body package="SmaCC Source Editing" selector="id">id	^id</body><body package="SmaCC Source Editing" selector="id:">id: anInteger	id := anInteger</body><body package="SmaCC Source Editing" selector="isRemoved:">isRemoved: aBoolean	isRemoved := aBoolean</body><body package="SmaCC Source Editing" selector="next">next	^next</body><body package="SmaCC Source Editing" selector="next:">next: aSmaCCInterval	next := aSmaCCInterval.	aSmaCCInterval previous: self</body><body package="SmaCC Source Editing" selector="previous">previous	^previous</body><body package="SmaCC Source Editing" selector="previous:">previous: aSmaCCInterval	previous := aSmaCCInterval</body><body package="SmaCC Source Editing" selector="removedString">removedString	^string copyFrom: start to: stop</body><body package="SmaCC Source Editing" selector="size">size	self isRemoved ifTrue: [^0].	^stop - start + 1 max: 0</body><body package="SmaCC Source Editing" selector="start">start	^start</body><body package="SmaCC Source Editing" selector="start:">start: anInteger	start := anInteger</body><body package="SmaCC Source Editing" selector="startIndex">startIndex	self isSentinel ifTrue: [^nil].	^self isEmpty ifTrue: [next startIndex] ifFalse: [SmaCCStringIndex index: start intervalId: id]</body><body package="SmaCC Source Editing" selector="stop">stop	^stop</body><body package="SmaCC Source Editing" selector="stop:">stop: anInteger	stop := anInteger</body><body package="SmaCC Source Editing" selector="stopIndex">stopIndex	^SmaCCStringIndex index: stop intervalId: id</body><body package="SmaCC Source Editing" selector="string">string	^string</body><body package="SmaCC Source Editing" selector="string:">string: aString	isRemoved := false.	string := aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringInterval</class-id> <category>printing</category><body package="SmaCC Source Editing" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: id;		nextPut: $,;		print: start;		nextPut: $-;		print: stop;		nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringInterval</class-id> <category>private</category><body package="SmaCC Source Editing" selector="addAllAnnotations:">addAllAnnotations: aCollection</body><body package="SmaCC Source Editing" selector="beSentinel">beSentinel	id := -1.	next := self.	previous := self</body><body package="SmaCC Source Editing" selector="convertToRemoved">convertToRemoved	| interval |	(self isRemoved or: [self isSentinel]) ifTrue: [^self].	isRemoved := true.	(previous canBeMergedWith: self)		ifTrue:			[interval := previous.			interval stop: self stop.			interval next: next.			self removed.			^interval].	(self canBeMergedWith: next)		ifTrue:			[interval := next.			next start: self start.			previous next: next.			self removed.			^interval].	^self</body><body package="SmaCC Source Editing" selector="nextPutOn:">nextPutOn: aWriteStream	self isRemoved ifTrue: [^self].	aWriteStream		next: self size		putAll: string		startingAt: start</body><body package="SmaCC Source Editing" selector="removed">removed	next := nil.	previous := nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringInterval</class-id> <category>editing</category><body package="SmaCC Source Editing" selector="insertAfter:">insertAfter: aSmaCCInterval	self next: aSmaCCInterval next.	aSmaCCInterval next: self</body><body package="SmaCC Source Editing" selector="splitAt:">splitAt: anIndex	| new |	(self isSentinel or: [anIndex = start]) ifTrue: [^self].	new := self copy.	self stop: anIndex - 1.	new start: anIndex.	new insertAfter: self.	^new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringInterval</class-id> <category>iterating</category><body package="SmaCC Source Editing" selector="do:">do: aBlock	| current |	current := self.	[current isSentinel]		whileFalse:			[aBlock value: current.			current := current next]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringInterval class</class-id> <category>instance creation</category><body package="SmaCC Source Editing" selector="from:to:string:">from: aSmaCCIndex to: aSmaCCIndex2 string: aString	^(self new)		start: aSmaCCIndex;		stop: aSmaCCIndex2;		string: aString;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringIndex</class-id> <category>comparing</category><body package="SmaCC Source Editing" selector="&lt;">&lt; aSmaCCStringIndex	^self index &lt; aSmaCCStringIndex index</body><body package="SmaCC Source Editing" selector="=">= anObject	^self class = anObject class and: [self index = anObject index and: [self intervalId = anObject intervalId]]</body><body package="SmaCC Source Editing" selector="hash">hash	^index bitXor: intervalId</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringIndex</class-id> <category>accessing</category><body package="SmaCC Source Editing" selector="index">index	^index</body><body package="SmaCC Source Editing" selector="index:">index: anInteger	index := anInteger</body><body package="SmaCC Source Editing" selector="intervalId">intervalId	^intervalId</body><body package="SmaCC Source Editing" selector="intervalId:">intervalId: anInteger	intervalId := anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringIndex</class-id> <category>arithmetic</category><body package="SmaCC Source Editing" selector="+">+ anInteger	^self class index: index + anInteger intervalId: intervalId</body><body package="SmaCC Source Editing" selector="-">- anInteger	^self + anInteger negated</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringIndex</class-id> <category>printing</category><body package="SmaCC Source Editing" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: intervalId;		nextPut: $,;		print: index;		nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStringIndex class</class-id> <category>instance creation</category><body package="SmaCC Source Editing" selector="index:intervalId:">index: anInteger intervalId: intervalId	^(self new)		index: anInteger;		intervalId: intervalId;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString</class-id> <category>editing</category><body package="SmaCC Source Editing" selector="addNewLineWhitespace:from:to:">addNewLineWhitespace: aString from: startIndex to: stopIndex	| currentInterval next |	currentInterval := self intervalContaining: startIndex.	[currentInterval isSentinel ifTrue: [^self].	next := currentInterval next.	currentInterval isRemoved		ifFalse:			[self				addNewLineWhitespace: aString				toInterval: currentInterval				from: startIndex				to: stopIndex].	currentInterval containsIndex: stopIndex] whileFalse: [currentInterval := next]</body><body package="SmaCC Source Editing" selector="addNewLineWhitespace:toInterval:from:to:">addNewLineWhitespace: aString toInterval: currentInterval from: startIndex to: stopIndex	| start stop stream next location interval whitespaceInterval |	interval := currentInterval.	next := currentInterval next.	start := (currentInterval containsIndex: startIndex)		ifTrue: [self indexFor: startIndex]		ifFalse: [currentInterval start].	stop := (currentInterval containsIndex: stopIndex) ifTrue: [self indexFor: stopIndex] ifFalse: [currentInterval stop].	stream := ReadStream on: (currentInterval string copyFrom: start to: stop).	[stream atEnd]		whileFalse:			[| char |			char := stream next.			char = Character cr ifTrue: [stream peek = Character lf ifTrue: [stream next]].			(char = Character lf or: [char = Character cr])				ifTrue:					[location := stream position + start.					interval := location &gt; stop ifTrue: [next] ifFalse: [interval splitAt: location].					whitespaceInterval := self newIntervalFor: aString.					interval previous next: whitespaceInterval.					whitespaceInterval next: interval]]</body><body package="SmaCC Source Editing" selector="addPrefix:">addPrefix: aString	^self insert: aString at: self startIndex</body><body package="SmaCC Source Editing" selector="append:">append: aString	^self insert: aString at: self stopIndex + 1</body><body package="SmaCC Source Editing" selector="deleteCharacter:">deleteCharacter: anInteger 	^self deleteFrom: anInteger to: anInteger</body><body package="SmaCC Source Editing" selector="deleteFrom:to:">deleteFrom: startIndex to: stopIndex	| startInterval atEnd |	startInterval := self intervalContaining: startIndex.	startInterval := startInterval splitAt: (self indexFor: startIndex).	[atEnd := startInterval containsIndex: stopIndex.	(atEnd and: [startInterval stop ~= (self indexFor: stopIndex)])		ifTrue: [startInterval splitAt: (self indexFor: stopIndex) + 1].	cachedInterval := startInterval := self removeInterval: startInterval.	atEnd or: [startInterval containsIndex: stopIndex]] whileFalse: [startInterval := startInterval next]</body><body package="SmaCC Source Editing" selector="deleteUpTo:">deleteUpTo: anIndex	self deleteFrom: self startIndex to: anIndex - 1</body><body package="SmaCC Source Editing" selector="deleteUpToEnd:">deleteUpToEnd: anIndex	self deleteFrom: anIndex to: self stopIndex</body><body package="SmaCC Source Editing" selector="insert:at:">insert: aString at: anInteger	| newFirstInterval |	aString isEmpty ifTrue: [^anInteger].	(aString isKindOf: SmaCCString)		ifTrue:			[^aString				copyFrom: aString startIndex				to: aString stopIndex				into: self				at: anInteger]		ifFalse:			[newFirstInterval := self newIntervalFor: aString.			^self				insertFirst: newFirstInterval				last: newFirstInterval				at: anInteger]</body><body package="SmaCC Source Editing" selector="moveFrom:to:after:">moveFrom: fromIndex to: toIndex after: newIndex	self		moveFrom: fromIndex		to: toIndex		location: newIndex		before: false</body><body package="SmaCC Source Editing" selector="moveFrom:to:before:">moveFrom: fromIndex to: toIndex before: newIndex	self		moveFrom: fromIndex		to: toIndex		location: newIndex		before: true</body><body package="SmaCC Source Editing" selector="moveFrom:to:location:before:">moveFrom: fromIndex to: toIndex location: newIndex before: aBoolean	| startInterval stopInterval newInterval currentInterval afterInterval |	startInterval := self intervalContaining: fromIndex.	startInterval := startInterval splitAt: (self indexFor: fromIndex).	currentInterval := startInterval.	[currentInterval containsIndex: toIndex]		whileFalse:			[currentInterval isSentinel ifTrue: [^self].			(currentInterval containsIndex: newIndex) ifTrue: [^self].			currentInterval := currentInterval next].	stopInterval := currentInterval.	(stopInterval containsIndex: newIndex) ifTrue: [newIndex &lt; toIndex ifTrue: [^self]].	stopInterval := (stopInterval splitAt: (self indexFor: toIndex) + 1) previous.	newInterval := self intervalContaining: newIndex.	afterInterval := aBoolean		ifTrue: [newInterval splitAt: (self indexFor: newIndex)]		ifFalse:			[(newInterval containsIndex: newIndex)				ifTrue: [newInterval splitAt: (self indexFor: newIndex) + 1]				ifFalse: [newInterval next]].	startInterval previous next: stopInterval next.	afterInterval previous next: startInterval.	stopInterval next: afterInterval</body><body package="SmaCC Source Editing" selector="removeInterval:">removeInterval: startInterval	^startInterval convertToRemoved</body><body package="SmaCC Source Editing" selector="replaceFrom:to:with:">replaceFrom: startIndex to: stopIndex with: aString	| newIndex |	newIndex := self insert: aString at: startIndex.	self deleteFrom: startIndex to: stopIndex.	^newIndex</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString</class-id> <category>accessing</category><body package="SmaCC Source Editing" selector="addAnnotationTo:">addAnnotationTo: aSmaCCStringInterval</body><body package="SmaCC Source Editing" selector="asString">asString	| stream |	stream := WriteStream on: (String new: self size).	firstSentinel next do: [:each | each nextPutOn: stream].	^stream contents</body><body package="SmaCC Source Editing" selector="at:">at: anIndex	^(self intervalContaining: anIndex) string at: (self indexFor: anIndex)</body><body package="SmaCC Source Editing" selector="deleteWhitespaceAfterIndex:">deleteWhitespaceAfterIndex: stopPosition	| stopIndex |	stopIndex := self whitespaceEndIndexAfterIndex: stopPosition.	(stopIndex isNil or: [self isIndex: stopIndex equalTo: stopPosition]) ifTrue: [^''].	^self deleteFrom: (self nextIndex: stopPosition) to: stopIndex</body><body package="SmaCC Source Editing" selector="deleteWhitespaceBeforeIndex:">deleteWhitespaceBeforeIndex: startPosition	| startIndex |	startIndex := self whitespaceStartIndexBeforeIndex: startPosition.	(startIndex isNil or: [self isIndex: startIndex equalTo: startPosition]) ifTrue: [^''].	^self deleteFrom: startIndex to: (self basicPreviousIndex: startPosition)</body><body package="SmaCC Source Editing" selector="indexFor:">indexFor: anIndex	^anIndex isInteger ifTrue: [anIndex] ifFalse: [anIndex index]</body><body package="SmaCC Source Editing" selector="nextIndex:">nextIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex + 1.	[(interval isRemoved not and: [interval containsIndex: newIndex])		ifTrue: [^newIndex]		ifFalse:			[interval next isSentinel				ifTrue: [^self stopIndex + 1]				ifFalse:					[interval := interval next.					newIndex := interval startIndex]]] repeat</body><body package="SmaCC Source Editing" selector="node">node	^nil</body><body package="SmaCC Source Editing" selector="node:">node: aSmaCCParseNode</body><body package="SmaCC Source Editing" selector="previousIndex:">previousIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex - 1.	[(interval isRemoved not and: [(interval containsIndex: newIndex) and: [(self indexFor: newIndex) ~= 0]])		ifTrue: [^newIndex]		ifFalse:			[interval previous isSentinel				ifTrue: [^nil]				ifFalse:					[interval := interval previous.					newIndex := interval stopIndex]]] repeat</body><body package="SmaCC Source Editing" selector="rule">rule	^nil</body><body package="SmaCC Source Editing" selector="rule:">rule: aSmaCCRewrite</body><body package="SmaCC Source Editing" selector="size">size	| current length |	length := 0.	current := firstSentinel next.	[current isSentinel]		whileFalse:			[length := length + current size.			current := current next].	^length</body><body package="SmaCC Source Editing" selector="startIndex">startIndex	^firstSentinel next isSentinel ifTrue: [0] ifFalse: [firstSentinel next startIndex]</body><body package="SmaCC Source Editing" selector="startOfLineWhitespaceBeforeIndex:">startOfLineWhitespaceBeforeIndex: startPosition	| startIndex |	startIndex := self startOfLineWhitespaceStartIndexBeforeIndex: startPosition.	startIndex isNil ifTrue: [^''].	^(self copyFrom: startIndex to: (self basicPreviousIndex: startPosition)) asString</body><body package="SmaCC Source Editing" selector="startOfLineWhitespaceStartIndexBeforeIndex:">startOfLineWhitespaceStartIndexBeforeIndex: startPosition	| stopIndex currentIndex position |	position := startPosition.	position isNil ifTrue: [^nil].	stopIndex := self previousIndex: position.	stopIndex isNil ifTrue: [^nil].	currentIndex := stopIndex.	[currentIndex notNil		and:			[| char |			char := self at: currentIndex.			char isSeparator and: [char ~= Character cr and: [char ~= Character lf]]]]		whileTrue: [currentIndex := self previousIndex: currentIndex].	^currentIndex isNil ifTrue: [self startIndex] ifFalse: [self basicNextIndex: currentIndex]</body><body package="SmaCC Source Editing" selector="stopIndex">stopIndex	^lastSentinel previous isSentinel ifTrue: [0] ifFalse: [lastSentinel previous stopIndex]</body><body package="SmaCC Source Editing" selector="whitespaceAfterIndex:">whitespaceAfterIndex: stopPosition	| stopIndex |	stopIndex := self whitespaceEndIndexAfterIndex: stopPosition.	stopIndex isNil ifTrue: [^''].	^(self copyFrom: (self basicNextIndex: stopPosition) to: stopIndex) asString</body><body package="SmaCC Source Editing" selector="whitespaceBeforeIndex:">whitespaceBeforeIndex: startPosition	| startIndex |	startIndex := self whitespaceStartIndexBeforeIndex: startPosition.	startIndex isNil ifTrue: [^''].	^(self copyFrom: startIndex to: (self basicPreviousIndex: startPosition)) asString</body><body package="SmaCC Source Editing" selector="whitespaceEndIndexAfterIndex:">whitespaceEndIndexAfterIndex: stopPosition	| currentIndex position startIndex |	position := stopPosition.	position isNil ifTrue: [^nil].	startIndex := self nextIndex: position.	startIndex isNil ifTrue: [^nil].	currentIndex := startIndex.	[currentIndex notNil and: [(self at: currentIndex) isSeparator]]		whileTrue: [currentIndex := self nextIndex: currentIndex].	^currentIndex isNil ifTrue: [self stopIndex] ifFalse: [self basicPreviousIndex: currentIndex]</body><body package="SmaCC Source Editing" selector="whitespaceStartIndexBeforeIndex:">whitespaceStartIndexBeforeIndex: startPosition	| stopIndex currentIndex position |	position := startPosition.	position isNil ifTrue: [^nil].	stopIndex := self previousIndex: position.	stopIndex isNil ifTrue: [^nil].	currentIndex := stopIndex.	[currentIndex notNil and: [(self at: currentIndex) isSeparator]]		whileTrue: [currentIndex := self previousIndex: currentIndex].	^currentIndex isNil ifTrue: [self startIndex] ifFalse: [self basicNextIndex: currentIndex]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString</class-id> <category>actions</category><body package="SmaCC Source Editing" selector="annotationRangesFor:">annotationRangesFor: aSmaCCAnnotation	| ranges startIndex current |	ranges := OrderedCollection new.	startIndex := 1.	current := firstSentinel next.	[current isSentinel]		whileFalse:			[(current isRemoved not and: [current annotations includes: aSmaCCAnnotation])				ifTrue: [ranges add: (startIndex to: startIndex + current size - 1)].			startIndex := startIndex + current size.			current := current next].	^ranges</body><body package="SmaCC Source Editing" selector="annotationsInNewRange:">annotationsInNewRange: range	| startIndex first last annotations current |	annotations := Set new.	startIndex := 0.	first := range start.	last := range isEmpty ifTrue: [first] ifFalse: [range stop].	current := firstSentinel next.	[current isSentinel]		whileFalse:			[startIndex &gt; last ifTrue: [^annotations asOrderedCollection].			startIndex := startIndex + current size.			startIndex &gt;= first ifTrue: [annotations addAll: current annotations].			current := current next].	^annotations asOrderedCollection</body><body package="SmaCC Source Editing" selector="annotationsInOriginalRange:">annotationsInOriginalRange: range	| first last |	first := self intervalContaining: range start.	last := range isEmpty ifTrue: [first] ifFalse: [self intervalContaining: range stop].	^(first annotationsTo: last) ifNil: [(last annotationsTo: first) ifNil: [#()]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString</class-id> <category>private</category><body package="SmaCC Source Editing" selector="basicNextIndex:">basicNextIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex + 1.	^(interval containsIndex: newIndex)		ifTrue: [newIndex]		ifFalse: [interval next isSentinel ifTrue: [self stopIndex + 1] ifFalse: [interval next startIndex]]</body><body package="SmaCC Source Editing" selector="basicPreviousIndex:">basicPreviousIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex - 1.	^((interval containsIndex: newIndex) and: [(self indexFor: newIndex) ~= 0])		ifTrue: [newIndex]		ifFalse: [interval previous isSentinel ifTrue: [nil] ifFalse: [interval previous stopIndex]]</body><body package="SmaCC Source Editing" selector="copyFrom:to:into:at:">copyFrom: startIndex to: stopIndex into: aSmaCCString at: anInteger	| startInterval stopInterval current newInterval first last |	startInterval := self intervalContaining: startIndex.	stopInterval := self intervalContaining: stopIndex.	current := startInterval.	last := first := nil.	[(current isRemoved or: [current isSentinel])		ifFalse:			[newInterval := aSmaCCString newIntervalFor: current string.			newInterval addAllAnnotations: current annotations.			newInterval start: (current == startInterval ifTrue: [self indexFor: startIndex] ifFalse: [current start]).			newInterval stop: (current == stopInterval ifTrue: [self indexFor: stopIndex] ifFalse: [current stop]).			first isNil ifTrue: [first := newInterval].			last notNil ifTrue: [last next: newInterval].			last := newInterval].	current ~~ stopInterval]		whileTrue:			[current isSentinel ifTrue: [^''].			current := current next].	first isNil ifTrue: [^aSmaCCString startIndex].	^aSmaCCString		insertFirst: first		last: last		at: anInteger</body><body package="SmaCC Source Editing" selector="insertFirst:last:at:">insertFirst: first last: last at: anInteger	| interval |	interval := self intervalContaining: anInteger.	interval := interval splitAt: (self indexFor: anInteger).	interval previous next: first.	last next: interval.	^first startIndex</body><body package="SmaCC Source Editing" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array with: (#{Tools.Trippy.TextAttribute} value label: 'string' textBlock: [self asString])</body><body package="SmaCC Source Editing" selector="intervalClass">intervalClass	^SmaCCStringInterval</body><body package="SmaCC Source Editing" selector="intervalContaining:">intervalContaining: anIndex	| prev next |	(cachedInterval isNil or: [cachedInterval isSentinel])		ifTrue:			[prev := lastSentinel previous.			next := firstSentinel next]		ifFalse:			[(cachedInterval containsIndex: anIndex) ifTrue: [^cachedInterval].			prev := cachedInterval previous.			next := cachedInterval next].	[prev isSentinel not or: [next isSentinel not]]		whileTrue:			[(prev isSentinel not and: [prev containsIndex: anIndex]) ifTrue: [^cachedInterval := prev].			(next isSentinel not and: [next containsIndex: anIndex]) ifTrue: [^cachedInterval := next].			prev := prev previous.			next := next next].	^lastSentinel</body><body package="SmaCC Source Editing" selector="newIntervalFor:">newIntervalFor: aString	| newInterval |	newInterval := self intervalClass		from: 1		to: aString size		string: aString.	currentId := currentId + 1.	newInterval id: currentId.	^newInterval</body><body package="SmaCC Source Editing" selector="setIntervalId">setIntervalId	firstSentinel next do: [:each | currentId := currentId max: each id]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString</class-id> <category>testing</category><body package="SmaCC Source Editing" selector="isEmpty">isEmpty	firstSentinel next do: [:each | each isEmpty ifFalse: [^false]].	^true</body><body package="SmaCC Source Editing" selector="isIndex:equalTo:">isIndex: aIndex equalTo: bIndex	aIndex = bIndex ifTrue: [^true].	aIndex class = bIndex class ifTrue: [^false].	^aIndex isInteger		ifTrue: [bIndex intervalId = 1 and: [aIndex = bIndex index]]		ifFalse: [bIndex isInteger and: [aIndex intervalId = 1 and: [aIndex index = bIndex]]]</body><body package="SmaCC Source Editing" selector="isModified">isModified	^firstSentinel next ~~ lastSentinel previous</body><body package="SmaCC Source Editing" selector="isRemoved:">isRemoved: anIndex	| interval |	interval := self intervalContaining: anIndex.	^interval isSentinel or: [interval isRemoved]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString</class-id> <category>initialize-release</category><body package="SmaCC Source Editing" selector="initialize">initialize	super initialize.	firstSentinel := self intervalClass		from: 1		to: 0		string: ''.	firstSentinel beSentinel.	lastSentinel := self intervalClass		from: 1		to: 0		string: ''.	lastSentinel beSentinel.	firstSentinel next: lastSentinel.	currentId := 0</body><body package="SmaCC Source Editing" selector="on:">on: aString	| firstInterval |	firstInterval := self intervalClass		from: 1		to: aString size		string: aString.	firstInterval id: 1.	currentId := 1.	firstSentinel next: firstInterval.	firstInterval next: lastSentinel</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString</class-id> <category>copying</category><body package="SmaCC Source Editing" selector=",">, aString	^(self copy)		append: aString;		yourself</body><body package="SmaCC Source Editing" selector="copy">copy	| new first last current newCurrent |	first := last := nil.	new := self class new.	current := firstSentinel next.	[current isSentinel]		whileFalse:			[newCurrent := current copy.			first isNil ifTrue: [first := newCurrent].			last notNil ifTrue: [last next: newCurrent].			last := newCurrent.			current := current next].	first notNil ifTrue: [new insertFirst: first last: last at: 1].	new setIntervalId.	^new</body><body package="SmaCC Source Editing" selector="copyFrom:to:">copyFrom: startIndex to: stopIndex	| result |	result := self class new.	self		copyFrom: startIndex		to: stopIndex		into: result		at: 1.	^result</body></methods><methods><class-id>Refactory.SmaCC.SmaCCString class</class-id> <category>instance creation</category><body package="SmaCC Source Editing" selector="new">new	^(super new)		initialize;		yourself</body><body package="SmaCC Source Editing" selector="on:">on: aString	^(self new)		insert: aString at: 0;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>