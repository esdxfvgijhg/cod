<?xml version="1.0"?><st-source><!-- Name: SmaCC GLR RuntimeNotice: Comment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains the runtime part of the GLR parser for SmaCC. All GLR parsers created using SmaCC will need this code. If you want more information about SmaCC, visit http://www.refactoryworkers.com/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2010 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: bear73DbTrace: 317928DevelopmentPrerequisites: #(#(#any 'SmaCC Runtime' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: SmaCC GLR RuntimeParcel: #('SmaCC GLR Runtime')PrerequisiteParcels: #(#('SmaCC Runtime' ''))PrintStringCache: (2.0.3,brant)Version: 2.0.3Date: 9:56:23 AM January 28, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:56:23 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SmaCCDeferredReduceAction</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC GLR Runtime</category><attributes><package>SmaCC GLR Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCDeferredReduceAction</class-id><body>SmaCCDeferredReduceAction represents a deferred message that will be sent once we figure out what we are parsing.Instance Variables	arguments	&lt;Array of: Object&gt;	the arguments of the message	selector	&lt;Symbol&gt;	the selector to send</body></comment><class><name>SmaCCAmbiguousResultNotification</name><environment>Refactory.SmaCC</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC GLR Runtime</category><attributes><package>SmaCC GLR Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCAmbiguousResultNotification</class-id><body>SmaCCAmbiguousResultNotification is a notification that is signaled when the GLR parser accepts multiple parses. The user can catch this signal and resume it with the correct parse. The parameters of the notification are the potential parses.Instance Variables:	parser	&lt;SmaCCGLRParser&gt;	the parser that parsed the ambiguous results</body></comment><class><name>SmaCCParserState</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateStack nodeStack isAccepted position scannerState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC GLR Runtime</category><attributes><package>SmaCC GLR Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCParserState</class-id><body>SmaCCParserState represents a particular parse in a GLR parser.Instance Variables:	isAccepted	&lt;Boolean&gt;	has this parse been accepted	nodeStack	&lt;SequenceableCollection of: Object&gt;	the stack of objects for this parse	position	&lt;Integer&gt;	the current position of the scanner	scannerState	&lt;Symbol&gt; the current state of the scanner	stateStack	&lt;SequenceableCollection of: Integer&gt;	the stack of states for this parse</body></comment><class><name>SmaCCDeferredChoice</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>possibleItems choiceBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC GLR Runtime</category><attributes><package>SmaCC GLR Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCDeferredChoice</class-id><body>SmaCCDeferredChoice represents a choice between multiple parses.Instance Variables	choiceBlock	&lt;BlockClosure&gt;	a two argument block that decides what choice should be chosen	possibleItems	&lt;SequenceableCollection of: Object&gt;	the choices</body></comment><class><name>SmaCCGLRParser</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>states parseAll currentState tryAllStates lastToken lastPosition lastState nextScannerState nextScannerPosition </inst-vars><class-inst-vars>cachedTrees </class-inst-vars><imports></imports><category>SmaCC GLR Runtime</category><attributes><package>SmaCC GLR Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCGLRParser</class-id><body>SmaCCGLRParser is an abstract superclass for all GLR generated parsers in SmaCC.Instance Variables:	currentState	&lt;SmaCCParserState&gt;	the current parse that we are trying	lastPosition	&lt;Integer&gt;	the starting location of the scanner before calling getNextToken	lastState	&lt;Symbol&gt;	the state of the scanner before calling getNextToken	lastToken	&lt;SmaCCToken&gt;	the token returned from getNextToken (if the lastState and lastToken are the same as the current token, then this value is returned without scanning anything)	nextScannerPosition	&lt;Integer&gt;	the ending location of the scanner after calling getNextToken	nextScannerState	&lt;Symbol&gt;	the ending state of the scanner after calling getNextToken	parseAll	&lt;Boolean&gt;	should we return a collection of all potential parses or just one	states	&lt;SequenceableCollection of: SmaCCParserState&gt;	the current list of valid parses	tryAllStates	&lt;Boolean&gt;	should we try to parse starting from any state instead of the starting state</body></comment><methods><class-id>Refactory.SmaCC.SmaCCDeferredReduceAction</class-id> <category>accessing</category><body package="SmaCC GLR Runtime" selector="arguments">arguments	^arguments</body><body package="SmaCC GLR Runtime" selector="performOnSmaCCParser:">performOnSmaCCParser: aSmaCCParser	^selector numArgs = 0		ifTrue: [aSmaCCParser perform: selector]		ifFalse: [aSmaCCParser perform: selector with: (self argumentsFor: aSmaCCParser)]</body><body package="SmaCC GLR Runtime" selector="selector">selector	^selector</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDeferredReduceAction</class-id> <category>comparing</category><body package="SmaCC GLR Runtime" selector="=">= anObject	^self class = anObject class and: [self selector = anObject selector and: [self arguments = anObject arguments]]</body><body package="SmaCC GLR Runtime" selector="hash">hash	^self class hash bitXor: (selector hash bitXor: arguments hash)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDeferredReduceAction</class-id> <category>initialize-release</category><body package="SmaCC GLR Runtime" selector="argumentsFor:">argumentsFor: aSmaCCParser	1 to: arguments size do: [:i | arguments at: i put: ((arguments at: i) performOnSmaCCParser: aSmaCCParser)].	^arguments</body><body package="SmaCC GLR Runtime" selector="selector:arguments:">selector: aSymbol arguments: aCollection	selector := aSymbol.	arguments := aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDeferredReduceAction class</class-id> <category>instance creation</category><body package="SmaCC GLR Runtime" selector="selector:arguments:">selector: aSymbol arguments: aCollection	^(self new)		selector: aSymbol arguments: aCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousResultNotification</class-id> <category>accessing</category><body package="SmaCC GLR Runtime" selector="parser">parser	^parser</body><body package="SmaCC GLR Runtime" selector="parser:">parser: anObject	parser := anObject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousResultNotification</class-id> <category>private-actions</category><body package="SmaCC GLR Runtime" selector="defaultAction">defaultAction	^self parameter first</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousResultNotification class</class-id> <category>instance creation</category><body package="SmaCC GLR Runtime" selector="forParser:">forParser: aSmaCCParser	^(self new)		parser: aSmaCCParser;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParserState</class-id> <category>comparing</category><body package="SmaCC GLR Runtime" selector="=">= anObject	^self == anObject or: [self class = anObject class and: [self stateStack = anObject stateStack and: [self nodeStack = anObject nodeStack]]]</body><body package="SmaCC GLR Runtime" selector="hash">hash	^self stateStack hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParserState</class-id> <category>testing</category><body package="SmaCC GLR Runtime" selector="canBeMergedWith:">canBeMergedWith: aSmaCCParserState	^self stateStack = aSmaCCParserState stateStack		and: [self position = aSmaCCParserState position and: [self scannerState = aSmaCCParserState scannerState]]</body><body package="SmaCC GLR Runtime" selector="isAccepted">isAccepted	^isAccepted</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParserState</class-id> <category>accessing</category><body package="SmaCC GLR Runtime" selector="markAccepted">markAccepted	isAccepted := true</body><body package="SmaCC GLR Runtime" selector="mergeWith:">mergeWith: aSmaCCParserStateCollection	| stacks |	stacks := OrderedCollection new: aSmaCCParserStateCollection size + 1.	stacks add: nodeStack.	aSmaCCParserStateCollection do: [:each | (stacks includes: each nodeStack) ifFalse: [stacks add: each nodeStack]].	nodeStack := SmaCCDeferredChoice mergeStacks: stacks</body><body package="SmaCC GLR Runtime" selector="nodeStack">nodeStack	^nodeStack</body><body package="SmaCC GLR Runtime" selector="position">position	^position</body><body package="SmaCC GLR Runtime" selector="position:">position: anObject	position := anObject</body><body package="SmaCC GLR Runtime" selector="runDeferredActionsFor:">runDeferredActionsFor: aSmaCCParser	1		to: nodeStack size		do:			[:i | 			| each |			each := nodeStack at: i.			nodeStack at: i put: (each performOnSmaCCParser: aSmaCCParser)]</body><body package="SmaCC GLR Runtime" selector="scannerState">scannerState	^scannerState</body><body package="SmaCC GLR Runtime" selector="scannerState:">scannerState: anObject	scannerState := anObject</body><body package="SmaCC GLR Runtime" selector="stateStack">stateStack	^stateStack</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParserState</class-id> <category>initialize-release</category><body package="SmaCC GLR Runtime" selector="stateStack:nodeStack:">stateStack: stateCollection nodeStack: nodeCollection	stateStack := stateCollection.	nodeStack := nodeCollection.	isAccepted := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParserState class</class-id> <category>instance creation</category><body package="SmaCC GLR Runtime" selector="stateStack:nodeStack:">stateStack: stateStack nodeStack: nodeStack	^(self new)		stateStack: stateStack nodeStack: nodeStack;		yourself</body><body package="SmaCC GLR Runtime" selector="stateStack:nodeStack:scannerState:position:">stateStack: stateStack nodeStack: nodeStack scannerState: aSymbol position: anInteger	^(self new)		stateStack: stateStack nodeStack: nodeStack;		scannerState: aSymbol;		position: anInteger;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDeferredChoice</class-id> <category>accessing</category><body package="SmaCC GLR Runtime" selector="choiceBlock:">choiceBlock: aBlock	choiceBlock := aBlock</body><body package="SmaCC GLR Runtime" selector="performOnSmaCCParser:">performOnSmaCCParser: aSmaCCParser	^(choiceBlock value: possibleItems value: aSmaCCParser) performOnSmaCCParser: aSmaCCParser</body><body package="SmaCC GLR Runtime" selector="possibleItems:">possibleItems: aSequenceableCollection	possibleItems := aSequenceableCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDeferredChoice class</class-id> <category>accessing</category><body package="SmaCC GLR Runtime" selector="mergeStacks:">mergeStacks: stacksOrderedCollection 	| result choiceBlock choices |	choices := 1 to: stacksOrderedCollection size.	choiceBlock := 			[:possibleChoices :parser | 			| returnValue newChoices |			choices size == 1 				ifTrue: [possibleChoices at: choices first]				ifFalse: 					[returnValue := (SmaCCAmbiguousResultNotification forParser: parser)								parameter: (choices collect: [:each | possibleChoices at: each]);								errorString: 'Ambiguous results';								raiseSignal.					newChoices := choices 								select: [:each | (possibleChoices at: each) == returnValue].					newChoices notEmpty ifTrue: [choices := newChoices].					returnValue]].	result := OrderedCollection new.	1 to: stacksOrderedCollection first size		do: 			[:i | 			| object |			object := stacksOrderedCollection first at: i.			(stacksOrderedCollection allSatisfy: [:each | object == (each at: i)]) 				ifTrue: [result add: object]				ifFalse: 					[result add: ((self new)								possibleItems: (stacksOrderedCollection collect: [:each | each at: i]);								choiceBlock: choiceBlock;								yourself)]].	^result</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGLRParser</class-id> <category>private</category><body package="SmaCC GLR Runtime" selector="actionsForCurrentToken">actionsForCurrentToken	| actions |	actions := OrderedCollection new: 1.	self tryAllTokens		ifTrue: [currentToken ids do: [:each | self addActionsFor: each to: actions]]		ifFalse: [self addActionsFor: currentToken ids first to: actions].	^actions</body><body package="SmaCC GLR Runtime" selector="addAction:to:">addAction: action to: anOrderedCollection	(anOrderedCollection includes: action) ifTrue: [^self].	anOrderedCollection add: action</body><body package="SmaCC GLR Runtime" selector="addActionsFor:to:">addActionsFor: anInteger to: anOrderedCollection	| state |	state := self currentState.	self		addActionsForState: state		symbol: anInteger		to: anOrderedCollection</body><body package="SmaCC GLR Runtime" selector="addActionsForState:symbol:to:">addActionsForState: state symbol: anInteger to: anOrderedCollection	| action |	action := self actionForState: state and: anInteger.	action = self errorAction ifTrue: [^self].	(action bitAnd: self actionMask) = 2r11		ifTrue: [self ambiguousTransitionsAt: (action bitShift: -2) into: anOrderedCollection]		ifFalse: [self addAction: action to: anOrderedCollection]</body><body package="SmaCC GLR Runtime" selector="alwaysPerformReduceAction">alwaysPerformReduceAction	^false</body><body package="SmaCC GLR Runtime" selector="ambiguousTransitions">ambiguousTransitions	^#()</body><body package="SmaCC GLR Runtime" selector="ambiguousTransitionsAt:into:">ambiguousTransitionsAt: anIndex into: anOrderedCollection	| ambiguousTransitions |	ambiguousTransitions := self ambiguousTransitions at: anIndex.	1		to: ambiguousTransitions size		by: 2		do:			[:i | self addAction: ((ambiguousTransitions at: i) bitShift: 8) + (ambiguousTransitions at: i + 1) to: anOrderedCollection]</body><body package="SmaCC GLR Runtime" selector="copyStackObject:">copyStackObject: anObject	(anObject isKindOf: String) ifTrue: [^anObject].	(anObject isKindOf: Collection) ifTrue: [^anObject collect: [:each | self copyStackObject: each]].	^anObject</body><body package="SmaCC GLR Runtime" selector="duplicateState">duplicateState	| state |	nodeStack := nodeStack copy.	stateStack := stateStack copy.	state := currentState copy.	state stateStack: stateStack nodeStack: nodeStack.	state position: scanner position.	state scannerState: scanner state.	states add: state.	^state</body><body package="SmaCC GLR Runtime" selector="fixObject:">fixObject: anObject	| result |	result := anObject performOnSmaCCParser: self.	(result isKindOf: SmaCCParseNode) ifTrue: [result fixParentPointers].	^result</body><body package="SmaCC GLR Runtime" selector="getNextToken">getNextToken	currentToken isNil ifFalse: [^self].	(lastState = currentState scannerState and: [lastPosition = currentState position])		ifTrue:			[currentToken := lastToken.			scanner				setPosition: nextScannerPosition;				state: nextScannerState.			currentState				scannerState: nextScannerState;				position: nextScannerPosition]		ifFalse:			[lastPosition := currentState position.			lastState := currentState scannerState.			scanner				state: currentState scannerState;				setPosition: currentState position.			lastToken := currentToken := scanner next.			nextScannerPosition := scanner position.			nextScannerState := scanner state].	currentState		scannerState: nextScannerState;		position: nextScannerPosition</body><body package="SmaCC GLR Runtime" selector="killState">killState	states remove: currentState.	states isEmpty ifTrue: [self handleError: 0].	(states size = 1 and: [parseAll not]) ifTrue: [states first runDeferredActionsFor: self]</body><body package="SmaCC GLR Runtime" selector="mergeStates">mergeStates	| i j state otherStates otherState |	i := 1.	[i &lt; states size]		whileTrue:			[state := states at: i.			otherStates := OrderedCollection new.			j := i := i + 1.			[j &lt;= states size]				whileTrue:					[otherState := states at: j.					(parseAll ifTrue: [state = otherState] ifFalse: [state canBeMergedWith: otherState])						ifTrue:							[otherStates add: otherState.							states removeAtIndex: j]						ifFalse: [j := j + 1]].			(parseAll not and: [otherStates notEmpty]) ifTrue: [state mergeWith: otherStates]]</body><body package="SmaCC GLR Runtime" selector="performParsingLoop">performParsingLoop	| result |	self setStartingStatesIfNone.	[states size		to: 1		by: -1		do:			[:i | 			self restoreState: (states at: i).			self getNextToken.			errorToken := nil.			self performParsingStep].	self mergeStates.	states anySatisfy: [:each | each isAccepted not]] whileTrue.	self checkForErrors.	result := parseAll		ifTrue: [states collect: [:each | self fixObject: each nodeStack first]]		ifFalse: [self fixObject: states first nodeStack first].	nodeStack := OrderedCollection with: result</body><body package="SmaCC GLR Runtime" selector="performParsingStep">performParsingStep	| actions action |	currentState isAccepted ifTrue: [^self].	self restoreState: currentState.	(tryAllStates and: [self isEOFToken]) ifTrue: [^self processEOFToken].	currentToken isPattern ifTrue: [^self splitForPatternToken].	[actions := self actionsForCurrentToken.	actions isEmpty		ifTrue:			[self killState.			currentToken := nil.			^self].	2 to: actions size do: [:i | self splitWithAction: (actions at: i)].	action := actions first.	action = self acceptAction		or:			[self performAction: action.			currentToken isNil]] whileFalse.	action = self acceptAction ifTrue: [currentState markAccepted]</body><body package="SmaCC GLR Runtime" selector="performReduceMethod:with:">performReduceMethod: aSymbol with: items	^(states size = 1 or: [parseAll])		ifTrue:			[1 to: items size do: [:i | items at: i put: ((items at: i) performOnSmaCCParser: self)].			super performReduceMethod: aSymbol with: items]		ifFalse: [SmaCCDeferredReduceAction selector: aSymbol arguments: items]</body><body package="SmaCC GLR Runtime" selector="popNodeStack">popNodeStack	| result |	result := nodeStack removeLast.	(self alwaysPerformReduceAction and: [states size &gt; 1]) ifTrue: [result := self copyStackObject: result].	^result</body><body package="SmaCC GLR Runtime" selector="position:">position: anInteger	super position: anInteger.	currentState position: anInteger</body><body package="SmaCC GLR Runtime" selector="processEOFToken">processEOFToken	| performedActions token |	performedActions := Set new.	token := currentToken.	self symbolTypes		keysAndValuesDo:			[:i :each | 			| actions |			(each = #SmaCCToken and: [i ~= scanner errorTokenId])				ifTrue:					[actions := OrderedCollection new.					self addActionsFor: i to: actions.					actions						do:							[:action | 							(performedActions includes: action)								ifFalse:									[performedActions add: action.									(action bitAnd: self actionMask) = self reduceAction										ifTrue:											[currentToken := token.											self splitWithAction: action]]]]].	(nodeStack size = 1 and: [nodeStack first isKindOf: SmaCCParseNode])		ifTrue: [currentState markAccepted]		ifFalse: [self killState]</body><body package="SmaCC GLR Runtime" selector="reduce:">reduce: anInteger	| reduceEntry items size |	reduceEntry := self reduceTable at: anInteger.	items := Array new: (size := reduceEntry at: 2).	nodeStack size &lt; size		ifTrue:			[self killState.			^currentToken := nil].	size		to: 1		by: -1		do:			[:i | 			items at: i put: self popNodeStack.			stateStack removeLast].	nodeStack addLast: (self performReduceMethod: (reduceEntry at: 3) with: items).	stateStack addLast: ((self actionFor: (reduceEntry at: 1)) bitShift: -2)</body><body package="SmaCC GLR Runtime" selector="restoreState:">restoreState: aSmaCCParserState	currentState := aSmaCCParserState.	nodeStack := aSmaCCParserState nodeStack.	stateStack := aSmaCCParserState stateStack</body><body package="SmaCC GLR Runtime" selector="splitForPatternToken">splitForPatternToken	| token patternNode performedActions nodeClass |	performedActions := Set new.	token := currentToken copy.	token ids: OrderedCollection new.	patternNode := SmaCCPatternNode onToken: token copy.	nodeClass := token nodeClassName		ifNil: [SmaCCParseNode]		ifNotNil: [:name | self class environment at: name ifAbsent: [SmaCCParseNode]].	self symbolTypes		keysAndValuesDo:			[:i :each | 			| actions |			(i ~= scanner emptySymbolTokenId and: [i ~= scanner errorTokenId])				ifTrue:					[actions := OrderedCollection new.					(each = #SmaCCToken or: [(self class environment at: each ifAbsent: [Object]) includesBehavior: nodeClass])						ifTrue:							[self addActionsFor: i to: actions.							actions								do:									[:action | 									(performedActions includes: action)										ifFalse:											[performedActions add: action.											each = #SmaCCToken												ifTrue:													[token ids add: i.													((action bitAnd: self actionMask) = self reduceAction or: [token isToken])														ifTrue:															[currentToken := token.															self splitWithAction: action]]												ifFalse:													[token isNode														ifTrue:															[currentToken := nil.															self duplicateState.															stateStack addLast: (action bitShift: -2).															nodeStack addLast: patternNode.															self restoreState: currentState]]]]]]].	self killState.	currentToken := nil</body><body package="SmaCC GLR Runtime" selector="splitWithAction:">splitWithAction: anInteger	| previousToken previousState |	previousState := currentState.	previousToken := currentToken.	[currentState := self duplicateState.	self performAction: anInteger.	currentToken notNil ifTrue: [self performParsingStep]]		ensure:			[self restoreState: previousState.			currentToken := previousToken]</body><body package="SmaCC GLR Runtime" selector="state:">state: aSymbol	super state: aSymbol.	currentState scannerState: aSymbol</body><body package="SmaCC GLR Runtime" selector="statesThatShift">statesThatShift	^(1 to: self transitionTable size)		select:			[:each | 			(1 to: self symbolTypes size)				anySatisfy:					[:i | 					| actions |					actions := OrderedCollection new.					self						addActionsForState: each						symbol: i						to: actions.					actions anySatisfy: [:action | (action bitAnd: self actionMask) = self shiftAction]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGLRParser</class-id> <category>accessing</category><body package="SmaCC GLR Runtime" selector="parseAll:">parseAll: aBoolean	parseAll := aBoolean</body><body package="SmaCC GLR Runtime" selector="setAllStartingStates">setAllStartingStates	tryAllStates := true.	self statesThatShift		do:			[:each | 			states				add:					(SmaCCParserState						stateStack: (OrderedCollection with: each)						nodeStack: OrderedCollection new						scannerState: scanner state						position: scanner position)]</body><body package="SmaCC GLR Runtime" selector="setStartingStatesIfNone">setStartingStatesIfNone	states isEmpty		ifTrue:			[states				add:					(SmaCCParserState						stateStack: stateStack						nodeStack: nodeStack						scannerState: scanner state						position: scanner position)]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGLRParser</class-id> <category>initialize-release</category><body package="SmaCC GLR Runtime" selector="initialize">initialize	super initialize.	states := OrderedCollection new.	parseAll := false.	tryAllStates := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGLRParser class</class-id> <category>parsing</category><body package="SmaCC GLR Runtime" selector="parseAll:startingAt:">parseAll: aString startingAt: anInteger	| parser |	parser := self on: (ReadStream on: aString).	parser setStartingState: anInteger.	parser parseAll: true.	^parser parse</body><body package="SmaCC GLR Runtime" selector="parseAllPossibleStates:">parseAllPossibleStates: aString	| parser |	parser := self on: (ReadStream on: aString).	parser		parseAll: true;		setAllStartingStates.	^parser parse</body><body package="SmaCC GLR Runtime" selector="parseAndCacheAll:startingAt:">parseAndCacheAll: aString startingAt: anInteger	cachedTrees isNil ifTrue: [cachedTrees := Dictionary new].	^cachedTrees at: aString ifAbsentPut: [self parseAll: aString startingAt: anInteger]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGLRParser class</class-id> <category>accessing</category><body package="SmaCC GLR Runtime" selector="resetCaches">resetCaches	super resetCaches.	cachedTrees := nil</body></methods><methods><class-id>Core.Object</class-id> <category>SmaCC</category><body package="SmaCC GLR Runtime" selector="performOnSmaCCParser:">performOnSmaCCParser: aSmaCCParser	^self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SmaCCParser</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken errorToken stateStack nodeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class></st-source>