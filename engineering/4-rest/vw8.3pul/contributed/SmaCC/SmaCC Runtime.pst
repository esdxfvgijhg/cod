<?xml version="1.0"?><st-source><!-- Name: SmaCC RuntimeNotice: Comment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains the runtime part of SmaCC. All parsers created using SmaCC will need this code. If you want more information about SmaCC, visit http://www.refactoryworkers.com/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2010 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: bear73DbTrace: 317926DevelopmentPrerequisites: #(#(#any 'SmaCC Namespace' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: SmaCC RuntimeParcel: #('SmaCC Runtime')PrerequisiteDescriptions: #(#(#name 'SmaCC Namespace'))PrerequisiteParcels: #(#('SmaCC Namespace' ''))PrintStringCache: (2.0.3,brant)Version: 2.0.3Date: 9:56:22 AM January 28, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:56:22 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SmaCCParseNode</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCParseNode</class-id><body>SmaCCParseNode is an abstract class that represents parse nodes generated by SmaCC.Subclasses must implement the following messages:	visitor-double dispatching		acceptVisitor:Instance Variables:	attributes	&lt;Dictionary&gt;	a dictionary that holds special properties for each node	parent	&lt;SmaCCParseNode&gt;	the parent node in the parse tree</body></comment><class><name>SmaCCParseNodeVisitor</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCParseNodeVisitor</class-id><body>SmaCCParseNodeVisitor is an abstract visitor for the SmaCC parse trees.</body></comment><class><name>SmaCCToken</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start ids value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCToken</class-id><body>SmaCCTokens are used as the interface objects between scanner and parser. They hold the string that was scanned and its position information. Also, included in the token is its id. The id specifies what type of token it is.Instance Variables:	id	&lt;Array of: Integer&gt;	the list of possible token types this represents. There can be overlapping tokens, so we list all of the id here. The default parser only looks at the first id, but we can redefine this behavior in a subclass to look at all possibilities until we find a valid token.	start	&lt;Integer&gt;	the starting position of the token in the original input	value	&lt;Object&gt;	the value of our token (normally a string, but could be anything)</body></comment><class><name>SmaCCCaseInsensitiveToken</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCaseInsensitiveToken</class-id><body>SmaCCCaseInsensitiveToken represents a case insensitive token (e.g., "IF" and "if" will compare equal).</body></comment><class><name>SmaCCLineNumberStream</name><environment>Refactory.SmaCC</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceStream previousWasCR eolPositions lastPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id><body>SmaCCLineNumberStream is a wrapper for streams that calculates line numbers.Instance Variables:	eolPositions	&lt;OrderedCollection of: Integer&gt;	the positions of each end of line	lastPosition	&lt;Integer&gt;	the position of the last character that we have calculated the end of line information for (we know the line number for all characters before this position and don't know anything about the characters after this position)	previousWasCR	&lt;Boolean&gt;	was the previous character a CR. This is used for CR LF streams. A CR LF combination should only increment the line counter by 1	sourceStream	&lt;Stream&gt;	the stream that we are wrapping</body></comment><class><name>SmaCCParserError</name><environment>Refactory.SmaCC</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCParserError</class-id><body>SmaCCParserError is the exception raised when a parsing error occurs. The description of the exception will be the error message and the parameter of the exception is the parser. With this information, you can insert a custom error message in your text view that you are parsing. For example, in VisualWorks, the following code will insert an error message into your text view:	textController insertAndSelect: ex description , ' -&gt;' at: ex parameter position</body></comment><class><name>SmaCCParser</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken errorToken stateStack nodeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCParser</class-id><body>SmaCCParser is an abstract class that defines most of the parsing actions. Subclasses will define methods that specify their transitions and reduction actions. These are normally defined automatically when compiling the parser.Subclasses must implement the following messages:	accessing		reduceTable		transitionTableInstance Variables:	currentToken	&lt;SmaCCToken&gt;	the token last returned by the scanner that has not been shifted (reduce actions leave the current token alone)	errorToken	&lt;SmaCCToken&gt;	the token where a parse error occurred	nodeStack	&lt;OrderedCollection of: Object&gt;	collection of items on stack. These items are specific to the parser and can be any object. 	scanner	&lt;SmaCCScanner&gt;	our scanner	stateStack	&lt;OrderedCollection of: Integer&gt;	the stack of states for our parser (standard LR state stack)</body></comment><class><name>SmaCCPatternNode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParseNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>patternToken </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id><body>SmaCCPatternNode is a parse node that matches other parse nodes when you are searching or rewriting parse trees.Instance Variables:	patternToken	&lt;SmaCCPatternToken&gt;	the token that holds our name and properties</body></comment><class><name>SmaCCScanner</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock state comments </inst-vars><class-inst-vars>keywordMap </class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCScanner</class-id><body>SmaCCScanner is an abstract class that represents a scanner for the parser. The scanner converts its string input into SmaCCToken objects that the parser then uses for its parsing.Subclasses must implement the following messages:	accessing		emptySymbolTokenId		errorTokenId		scanForTokenInstance Variables:	comments	&lt;OrderedCollection&gt;	a collection of comment intervals (array of start position &amp; stop position)	currentCharacter	&lt;Character&gt;	the current character we are scanning	lastMatchWasEmpty	&lt;Boolean&gt;	was our last scanning match an empty string -- don't allow two empty matches in a row	lastOutputStreamMatchPosition	&lt;Integer&gt;	the position in the outputStream of the last match	matchActions	&lt;Array | Symbol&gt;	the actions for the last match (a symbol means that the action should be performed on the scanner)	matchEnd	&lt;Integer&gt;	the position of the last match in the stream (our input stream)	outputStream	&lt;PositionableStream&gt;	the matched characters go in this stream. After a match is made, we take this stream's contents and create a token object.	returnMatchBlock	&lt;BlockClosure&gt;	when we match a token evaluate this block with the token (hack to return from multiple levels)	start	&lt;Integer&gt;	the starting position of a match in the stream	state	&lt;Symbol&gt;	the state of the scanner	stream	&lt;Stream&gt;	our input</body></comment><class><name>SmaCCPatternToken</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isList isToken isNode testBlock nodeClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCPatternToken</class-id><body>SmaCCPatternToken is a token for pattern nodes.Instance Variables:	isList	&lt;Boolean&gt;	do we match collections or single objects	isNode	&lt;Boolean&gt;	can we match other parse nodes	isToken	&lt;Boolean&gt;	can we match other tokens	nodeClassName	&lt;Symbol&gt;	when matching a parse node, limit it to these types of nodes	testBlock	&lt;BlockClosure&gt;	after a match, run some code that tests the match</body></comment><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>variables</category><body package="SmaCC Runtime" selector="addVariablesFrom:">addVariablesFrom: anObject	| myCompositeVariables mySingularVariables |	(anObject isKindOf: SmaCCParseNode) ifFalse: [^self].	myCompositeVariables := self compositeVariables.	mySingularVariables := self singularVariables.	anObject compositeVariables		do: [:each | (myCompositeVariables includes: each) ifTrue: [(self perform: each) addAll: (anObject perform: each)]].	anObject singularVariables		do:			[:each | 			| newName |			newName := self pluralVariablesMap at: each ifAbsent: [each].			(myCompositeVariables includes: newName)				ifTrue: [(self perform: newName asSymbol) add: (anObject perform: each)]				ifFalse:					[(mySingularVariables includes: each) ifTrue: [self perform: (each , ':') asSymbol with: (anObject perform: each)]]]</body><body package="SmaCC Runtime" selector="allVariableSelectors">allVariableSelectors	^#(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables #ignoredTokenVariables #ignoredCompositeTokenVariables #ignoredNodeVariables #ignoredCompositeNodeVariables #ignoredOtherVariables)</body><body package="SmaCC Runtime" selector="compositeNodeVariables">compositeNodeVariables	^#()</body><body package="SmaCC Runtime" selector="compositeTokenVariables">compositeTokenVariables	^#()</body><body package="SmaCC Runtime" selector="compositeVariableSelectors">compositeVariableSelectors	^#(#compositeTokenVariables #compositeNodeVariables #ignoredCompositeTokenVariables #ignoredCompositeNodeVariables)</body><body package="SmaCC Runtime" selector="compositeVariables">compositeVariables	^self compositeVariableSelectors		inject: Set new		into:			[:sum :each | 			sum				addAll: (self perform: each);				yourself]</body><body package="SmaCC Runtime" selector="ignoredCompositeNodeVariables">ignoredCompositeNodeVariables	^#()</body><body package="SmaCC Runtime" selector="ignoredCompositeTokenVariables">ignoredCompositeTokenVariables	^#()</body><body package="SmaCC Runtime" selector="ignoredNodeVariables">ignoredNodeVariables	^#()</body><body package="SmaCC Runtime" selector="ignoredOtherVariables">ignoredOtherVariables	^#()</body><body package="SmaCC Runtime" selector="ignoredTokenVariables">ignoredTokenVariables	^#()</body><body package="SmaCC Runtime" selector="nodeVariables">nodeVariables	^#()</body><body package="SmaCC Runtime" selector="otherVariables">otherVariables	^#()</body><body package="SmaCC Runtime" selector="pluralVariablesMap">pluralVariablesMap	^[Dictionary new] once</body><body package="SmaCC Runtime" selector="singularVariableSelectors">singularVariableSelectors	^#(#tokenVariables #nodeVariables #ignoredTokenVariables #ignoredNodeVariables #otherVariables #ignoredOtherVariables)</body><body package="SmaCC Runtime" selector="singularVariables">singularVariables	^self singularVariableSelectors		inject: Set new		into:			[:sum :each | 			sum				addAll: (self perform: each);				yourself]</body><body package="SmaCC Runtime" selector="tokenVariables">tokenVariables	^#()</body><body package="SmaCC Runtime" selector="variableSelectors">variableSelectors	^#(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>testing</category><body package="SmaCC Runtime" selector="hasDescendant:">hasDescendant: aSmaCCNode	^aSmaCCNode isDescendantFrom: self</body><body package="SmaCC Runtime" selector="isDescendantFrom:">isDescendantFrom: aSmaCCNode	| current |	current := self.	[current isNil or: [current == aSmaCCNode]] whileFalse: [current := current parent].	^current notNil</body><body package="SmaCC Runtime" selector="isListMatch">isListMatch	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>source</category><body package="SmaCC Runtime" selector="completeSource">completeSource	^parent isNil ifTrue: [self attributeNamed: #source] ifFalse: [parent completeSource]</body><body package="SmaCC Runtime" selector="completeSource:">completeSource: aString	^parent isNil		ifTrue: [#{SmaCCString} ifDefinedDo: [:stringClass | self attributeNamed: #source put: (stringClass on: aString)]]		ifFalse: [parent completeSource: aString]</body><body package="SmaCC Runtime" selector="deleteSource">deleteSource	self completeSource deleteFrom: self startPosition to: self stopPosition</body><body package="SmaCC Runtime" selector="deleteToken:">deleteToken: aSmaCCToken	self completeSource deleteFrom: aSmaCCToken startPosition to: aSmaCCToken stopPosition</body><body package="SmaCC Runtime" selector="insertSourceAfter:">insertSourceAfter: aString	self completeSource insert: aString at: self stopPosition + 1</body><body package="SmaCC Runtime" selector="insertSourceBefore:">insertSourceBefore: aString	self completeSource insert: aString at: self startPosition</body><body package="SmaCC Runtime" selector="insertSourceBefore:andAfter:">insertSourceBefore: beginString andAfter: endString	self		insertSourceBefore: beginString;		insertSourceAfter: endString</body><body package="SmaCC Runtime" selector="replaceToken:withSource:">replaceToken: aSmaCCToken withSource: aString	self completeSource		replaceFrom: aSmaCCToken startPosition		to: aSmaCCToken stopPosition		with: aString</body><body package="SmaCC Runtime" selector="replaceWithSource:">replaceWithSource: aString	^self completeSource		replaceFrom: self startPosition		to: self stopPosition		with: aString</body><body package="SmaCC Runtime" selector="source">source	^self completeSource ifNotNil: [:value | (value copyFrom: self startPosition to: self stopPosition) asString]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>iterating</category><body package="SmaCC Runtime" selector="allGettersDo:">allGettersDo: aBlock	self allVariableSelectors do: [:sel | (self perform: sel) do: aBlock]</body><body package="SmaCC Runtime" selector="allNodesDo:">allNodesDo: nodeBlock	self allNodesDo: nodeBlock andTokensDo: nil</body><body package="SmaCC Runtime" selector="allNodesDo:andTokensDo:">allNodesDo: nodeBlock andTokensDo: tokenBlock	self		nodesDo:			[:each | 			nodeBlock value: each.			each allNodesDo: nodeBlock andTokensDo: tokenBlock]		andTokensDo: tokenBlock</body><body package="SmaCC Runtime" selector="nodesDo:">nodesDo: nodeBlock	self nodesDo: nodeBlock andTokensDo: nil</body><body package="SmaCC Runtime" selector="nodesDo:andTokensDo:">nodesDo: nodeBlock andTokensDo: tokenBlock	| block |	nodeBlock notNil		ifTrue:			[block := [:each | (self perform: each) ifNotNil: nodeBlock].			self nodeVariables do: block.			self ignoredNodeVariables do: block.			block := [:each | (self perform: each) ifNotNil: [:nodes | nodes do: nodeBlock]].			self compositeNodeVariables do: block.			self ignoredCompositeNodeVariables do: block].	tokenBlock notNil		ifTrue:			[block := [:each | (self perform: each) ifNotNil: tokenBlock].			self tokenVariables do: block.			self ignoredTokenVariables do: block.			block := [:each | (self perform: each) ifNotNil: [:nodes | nodes do: tokenBlock]].			self compositeTokenVariables do: block.			self ignoredCompositeTokenVariables do: block].	block := [:each | 	nodeBlock notNil ifTrue: [(each isKindOf: SmaCCParseNode) ifTrue: [nodeBlock value: each]].	tokenBlock notNil ifTrue: [(each isKindOf: SmaCCToken) ifTrue: [tokenBlock value: each]].	(each isKindOf: Collection) ifTrue: [each do: block]].	self otherVariables do: [:sel | block value: (self perform: sel)].	self ignoredOtherVariables do: [:sel | block value: (self perform: sel)]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="allTokens">allTokens	| tokens |	tokens := OrderedCollection new.	self allTokensInto: tokens.	^tokens asSortedCollection: [:a :b | a startPosition &lt; b startPosition]</body><body package="SmaCC Runtime" selector="allTokensInto:">allTokensInto: aCollection	self tokenVariables do: [:each | (self perform: each) ifNotNil: [:token | aCollection add: token]].	self compositeTokenVariables		do: [:each | (self perform: each) ifNotNil: [:tokens | aCollection addAll: tokens]].	self nodesDo: [:each | each allTokensInto: aCollection]</body><body package="SmaCC Runtime" selector="children">children	| result |	result := OrderedCollection new.	self nodesDo: [:each | each notNil ifTrue: [result add: each]].	^result</body><body package="SmaCC Runtime" selector="comments">comments	^self attributeNamed: #comments</body><body package="SmaCC Runtime" selector="comments:">comments: anObject	self attributeNamed: #comments put: anObject</body><body package="SmaCC Runtime" selector="filename">filename	^self attributeNamed: #filename</body><body package="SmaCC Runtime" selector="filename:">filename: aString	self attributeNamed: #filename put: aString</body><body package="SmaCC Runtime" selector="lookupNode:">lookupNode: aBlock	| current |	current := self.	[current isNil or: [aBlock value: current]] whileFalse: [current := current parent].	^current</body><body package="SmaCC Runtime" selector="nodeOfType:">nodeOfType: aSmaCCParseNodeClassOrCollection	| isCollection |	isCollection := aSmaCCParseNodeClassOrCollection isKindOf: Collection.	^self		lookupNode:			[:each | 			isCollection				ifTrue: [aSmaCCParseNodeClassOrCollection anySatisfy: [:class | each isKindOf: class]]				ifFalse: [each isKindOf: aSmaCCParseNodeClassOrCollection]]</body><body package="SmaCC Runtime" selector="parent">parent	^parent</body><body package="SmaCC Runtime" selector="parent:">parent: aSmaCCParseNode	parent := aSmaCCParseNode</body><body package="SmaCC Runtime" selector="parentOfType:">parentOfType: aSmaCCParseNodeClassOrCollection	^parent notNil ifTrue: [parent nodeOfType: aSmaCCParseNodeClassOrCollection] ifFalse: [nil]</body><body package="SmaCC Runtime" selector="sortedChildren">sortedChildren	^self children		asSortedCollection:			[:a :b | 			| startA startB |			startA := a startPosition.			startB := b startPosition.			startA isNil				or:					[b notNil and: [startA class = startB class ifTrue: [startA &lt; startB] ifFalse: [startA class name &lt; startB class name]]]]</body><body package="SmaCC Runtime" selector="startPosition">startPosition	"Hackish way to get the minimum for all nodes. You might want to override to get a better implementation."	| min doBlock |	min := SmallInteger maxVal.	doBlock := [:each | each startPosition ifNotNil: [:pos | min := min min: pos]].	self nodesDo: doBlock andTokensDo: doBlock.	^min</body><body package="SmaCC Runtime" selector="stopPosition">stopPosition	"Hackish way to get the maximum for all nodes. You might want to override to get a better implementation."	| max doBlock |	max := 0.	doBlock := [:each | each stopPosition ifNotNil: [:pos | max := max max: pos]].	self nodesDo: doBlock andTokensDo: doBlock.	^max</body><body package="SmaCC Runtime" selector="topParent">topParent	| current |	current := self.	[current parent notNil] whileTrue: [current := current parent].	^current</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>copying</category><body package="SmaCC Runtime" selector="postCopy">postCopy	super postCopy.	self		allGettersDo:			[:each | 			self				perform: (self convertToSetter: each)				with:					((self compositeVariableSelectors includes: each)						ifTrue: [(self perform: each) collect: [:item | item copy]]						ifFalse: [(self perform: each) copy])]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>collection handling</category><body package="SmaCC Runtime" selector="addFirstNode:to:">addFirstNode: aSmaCCParseNode to: aCollection	aSmaCCParseNode isNil ifTrue: [^self].	aCollection addFirst: aSmaCCParseNode.	aSmaCCParseNode parent: self</body><body package="SmaCC Runtime" selector="addFirstNodes:to:">addFirstNodes: aSmaCCParseNodeCollection to: aCollection	aSmaCCParseNodeCollection isNil ifTrue: [^self].	aSmaCCParseNodeCollection reverseDo: [:each | self addFirstNode: each to: aCollection]</body><body package="SmaCC Runtime" selector="addFirstObject:to:">addFirstObject: anObject to: aCollection	anObject isNil ifTrue: [^self].	aCollection addFirst: anObject.	(anObject isKindOf: SmaCCParseNode) ifTrue: [anObject parent: self]</body><body package="SmaCC Runtime" selector="addFirstObjects:to:">addFirstObjects: addCollection to: aCollection	addCollection isNil ifTrue: [^self].	addCollection reverseDo: [:each | self addFirstObject: each to: aCollection]</body><body package="SmaCC Runtime" selector="addFirstToken:to:">addFirstToken: aSmaCCToken to: aCollection	aSmaCCToken isNil ifTrue: [^self].	aCollection addFirst: aSmaCCToken</body><body package="SmaCC Runtime" selector="addFirstTokens:to:">addFirstTokens: aSmaCCTokenCollection to: aCollection	aSmaCCTokenCollection isNil ifTrue: [^self].	aCollection addAll: aSmaCCTokenCollection beforeIndex: 1</body><body package="SmaCC Runtime" selector="addNode:to:">addNode: aSmaCCParseNode to: aCollection	aSmaCCParseNode isNil ifTrue: [^self].	aCollection add: aSmaCCParseNode.	aSmaCCParseNode parent: self</body><body package="SmaCC Runtime" selector="addNodes:to:">addNodes: aSmaCCParseNodeCollection to: aCollection	aSmaCCParseNodeCollection isNil ifTrue: [^self].	aSmaCCParseNodeCollection do: [:each | self addNode: each to: aCollection]</body><body package="SmaCC Runtime" selector="addObject:to:">addObject: anObject to: aCollection	anObject isNil ifTrue: [^self].	aCollection add: anObject.	(anObject isKindOf: SmaCCParseNode) ifTrue: [anObject parent: self]</body><body package="SmaCC Runtime" selector="addObjects:to:">addObjects: addCollection to: aCollection	addCollection isNil ifTrue: [^self].	addCollection do: [:each | self addObject: each to: aCollection]</body><body package="SmaCC Runtime" selector="addToken:to:">addToken: aSmaCCToken to: aCollection	aSmaCCToken isNil ifTrue: [^self].	aCollection add: aSmaCCToken</body><body package="SmaCC Runtime" selector="addTokens:to:">addTokens: aSmaCCTokenCollection to: aCollection	aSmaCCTokenCollection isNil ifTrue: [^self].	aCollection addAll: aSmaCCTokenCollection</body><body package="SmaCC Runtime" selector="setParents:to:">setParents: aCollection to: anObject	aCollection isNil ifTrue: [^self].	aCollection do: [:each | each parent: anObject]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>replacing</category><body package="SmaCC Runtime" selector="replace:with:">replace: originalSmaCCParseNode with: newSmaCCParseNode	SmaCCParseNode instSize + 1		to: self class instSize		do:			[:i | 			| each |			each := self instVarAt: i.			each == originalSmaCCParseNode				ifTrue: [self instVarAt: i put: newSmaCCParseNode]				ifFalse:					[(each isKindOf: SequenceableCollection)						ifTrue:							[each keysAndValuesDo: [:index :value | value == originalSmaCCParseNode ifTrue: [each at: index put: newSmaCCParseNode]]]]].	newSmaCCParseNode parent: self.	self completeSource		ifNotNil:			[:source | 			source				replaceFrom: originalSmaCCParseNode startPosition				to: originalSmaCCParseNode stopPosition				with: newSmaCCParseNode source]</body><body package="SmaCC Runtime" selector="replaceWith:">replaceWith: aSmaCCParseNode	parent replace: self with: aSmaCCParseNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>private</category><body package="SmaCC Runtime" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array with: (#{Tools.Trippy.TextAttribute} value label: 'source' textBlock: [self source asString])</body><body package="SmaCC Runtime" selector="safePerform:">safePerform: aSymbol	^(self respondsTo: aSymbol) ifTrue: [self perform: aSymbol] ifFalse: [nil]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="convertToSetter:">convertToSetter: selector	^(selector , ':') asSymbol</body><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	| copy |	copy := self copy.	self tokenVariables		do:			[:selector | copy perform: (self convertToSetter: selector) with: ((self perform: selector) copyInContext: aDictionary)].	self nodeVariables		do:			[:selector | copy perform: (self convertToSetter: selector) with: ((self perform: selector) copyInContext: aDictionary)].	self compositeTokenVariables		do:			[:selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) collect: [:each | each copyInContext: aDictionary])].	self compositeNodeVariables		do:			[:selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) collect: [:each | each copyInContext: aDictionary])].	^copy</body><body package="SmaCC Runtime" selector="match:inContext:">match: aSmaCCParseNode inContext: aDictionary	self class = aSmaCCParseNode class ifFalse: [^false].	(self tokenVariables		allSatisfy: [:each | (self perform: each) match: (aSmaCCParseNode perform: each) inContext: aDictionary])		ifFalse: [^false].	(self nodeVariables		allSatisfy: [:each | (self perform: each) match: (aSmaCCParseNode perform: each) inContext: aDictionary])		ifFalse: [^false].	(self compositeTokenVariables		allSatisfy:			[:each | 			self				matchCollection: (self perform: each)				to: (aSmaCCParseNode perform: each)				inContext: aDictionary]) ifFalse: [^false].	^self compositeNodeVariables		allSatisfy:			[:each | 			self				matchCollection: (self perform: each)				to: (aSmaCCParseNode perform: each)				inContext: aDictionary]</body><body package="SmaCC Runtime" selector="matchCollection:index:to:index:inContext:">matchCollection: matchNodes index: matchIndex to: programNodes index: programIndex inContext: aDictionary	| node currentIndex currentDictionary nodes |	matchNodes size &lt; matchIndex ifTrue: [^programNodes size &lt; programIndex].	node := matchNodes at: matchIndex.	node isListMatch		ifTrue:			[currentIndex := programIndex - 1.			[currentDictionary := aDictionary copy.			programNodes size &lt; currentIndex				or:					[(self						matchCollection: matchNodes						index: matchIndex + 1						to: programNodes						index: currentIndex + 1						inContext: currentDictionary)						and:							[nodes := programNodes copyFrom: programIndex to: currentIndex.							(currentDictionary at: node ifAbsentPut: [nodes]) = nodes								ifTrue:									[currentDictionary keysAndValuesDo: [:key :value | aDictionary at: key put: value].									^true].							false]]] whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size &lt; programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) ifFalse: [^false].	^self		matchCollection: matchNodes		index: matchIndex + 1		to: programNodes		index: programIndex + 1		inContext: aDictionary</body><body package="SmaCC Runtime" selector="matchCollection:to:inContext:">matchCollection: receiverCollection to: argumentCollection inContext: aDictionary 	^self 		matchCollection: receiverCollection		index: 1		to: argumentCollection		index: 1		inContext: aDictionary</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>accessing-attributes</category><body package="SmaCC Runtime" selector="attributeNamed:">attributeNamed: aSymbol	attributes isNil ifTrue: [^nil].	^attributes at: aSymbol ifAbsent: [nil]</body><body package="SmaCC Runtime" selector="attributeNamed:ifAbsent:">attributeNamed: aSymbol ifAbsent: aBlock	^self attributes at: aSymbol ifAbsent: aBlock</body><body package="SmaCC Runtime" selector="attributeNamed:ifAbsentPut:">attributeNamed: aSymbol ifAbsentPut: aBlock	^self attributes at: aSymbol ifAbsentPut: aBlock</body><body package="SmaCC Runtime" selector="attributeNamed:put:">attributeNamed: aSymbol put: aValue	^self attributes at: aSymbol put: aValue</body><body package="SmaCC Runtime" selector="attributes">attributes	^attributes ifNil: [attributes := IdentityDictionary new]</body><body package="SmaCC Runtime" selector="removeAttributeNamed:">removeAttributeNamed: aSymbol	attributes isNil ifTrue: [^self].	attributes removeKey: aSymbol ifAbsent: []</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>initialize-release</category><body package="SmaCC Runtime" selector="fixParentPointers">fixParentPointers	self		nodesDo:			[:each | 			each parent: self.			each fixParentPointers]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>comparing</category><body package="SmaCC Runtime" selector="=">= anObject	^self == anObject		or:			[self class = anObject class				and: [self variableSelectors allSatisfy: [:symbol | (self perform: symbol) allSatisfy: [:each | (self perform: each) = (anObject perform: each)]]]]</body><body package="SmaCC Runtime" selector="hash">hash	^self variableSelectors		inject: self class hash		into: [:sum :symbol | (self perform: symbol) inject: sum into: [:hash :each | hash bitXor: (self perform: each) hash]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>visitor-double dispatching</category><body package="SmaCC Runtime" selector="acceptVisitor:">acceptVisitor: aSmaCCParseNodeVisitor	^aSmaCCParseNodeVisitor visitSmaCCParseNode: self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode class</class-id> <category>instance creation</category><body package="SmaCC Runtime" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode class</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="collectionVariableIn:collectionGetter:variableGetter:">collectionVariableIn: aSmaCCParseNode collectionGetter: aSymbol variableGetter: varSymbol	(aSmaCCParseNode respondsTo: aSymbol) ifTrue: [^aSmaCCParseNode perform: aSymbol].	(aSmaCCParseNode respondsTo: varSymbol) ifTrue: [^Array with: (aSmaCCParseNode perform: varSymbol)].	^#()</body><body package="SmaCC Runtime" selector="variableIn:getter:">variableIn: aSmaCCParseNode getter: aSymbol	(aSmaCCParseNode respondsTo: aSymbol) ifTrue: [^aSmaCCParseNode perform: aSymbol].	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNodeVisitor</class-id> <category>visiting</category><body package="SmaCC Runtime" selector="accept:">accept: anObject	(anObject isKindOf: SmaCCParseNode) ifTrue: [^self acceptNode: anObject].	(anObject isKindOf: Collection) ifTrue: [^self acceptNodes: anObject].	^anObject</body><body package="SmaCC Runtime" selector="acceptNode:">acceptNode: aSmaCCParseNode	aSmaCCParseNode isNil ifTrue: [^nil].	^aSmaCCParseNode acceptVisitor: self</body><body package="SmaCC Runtime" selector="acceptNodes:">acceptNodes: aCollection	aCollection do: [:each | self acceptNode: each].	^aCollection</body><body package="SmaCC Runtime" selector="visitSmaCCParseNode:">visitSmaCCParseNode: aSmaCCParseNode	self acceptNodes: aSmaCCParseNode sortedChildren.	^aSmaCCParseNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="ids">ids	^ids</body><body package="SmaCC Runtime" selector="ids:">ids: anArray	ids := anArray</body><body package="SmaCC Runtime" selector="startPosition">startPosition	^start</body><body package="SmaCC Runtime" selector="stopPosition">stopPosition	start isNil ifTrue: [^nil].	^start + value size - 1</body><body package="SmaCC Runtime" selector="value">value	^value</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>testing</category><body package="SmaCC Runtime" selector="isListMatch">isListMatch	^false</body><body package="SmaCC Runtime" selector="isPattern">isPattern	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>comparing</category><body package="SmaCC Runtime" selector="=">= aSmaCCToken 	^self class = aSmaCCToken class and: [self value = aSmaCCToken value]</body><body package="SmaCC Runtime" selector="hash">hash	^self value hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>matching</category><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	^self</body><body package="SmaCC Runtime" selector="match:inContext:">match: anObject inContext: aDictionary	^self = anObject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>initialize-release</category><body package="SmaCC Runtime" selector="value:start:ids:">value: aString start: startPositionInteger ids: aCollection	value := aString.	start := startPositionInteger.	ids := aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>printing</category><body package="SmaCC Runtime" selector="printOn:">printOn: aStream	aStream		nextPut: ${;		nextPutAll: self value;		nextPut: $(;		nextPutAll: self startPosition printString;		nextPut: $,;		nextPutAll: self stopPosition printString;		nextPut: $,;		nextPutAll: self ids printString;		nextPutAll: ')}'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>deprecated</category><body package="SmaCC Runtime" selector="id">id	^ids</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken class</class-id> <category>instance creation</category><body package="SmaCC Runtime" selector="value:">value: aString	^self		value: aString		start: 0		ids: #()</body><body package="SmaCC Runtime" selector="value:start:ids:">value: aString start: anInteger ids: aCollection	^(self new)		value: aString			start: anInteger			ids: aCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken class</class-id> <category>deprecated</category><body package="SmaCC Runtime" selector="value:start:id:">value: aString start: anInteger id: anObject	^self value: aString start: anInteger ids: anObject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCaseInsensitiveToken</class-id> <category>comparing</category><body package="SmaCC Runtime" selector="=">= aSmaCCToken	^self class = aSmaCCToken class and: [self value sameAs: aSmaCCToken value]</body><body package="SmaCC Runtime" selector="hash">hash	^self value asUppercase hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="columnNumber">columnNumber	^self columnNumberFor: self position</body><body package="SmaCC Runtime" selector="columnNumberFor:">columnNumberFor: anInteger 	^anInteger - (eolPositions at: (self lineNumberFor: anInteger)) + 1</body><body package="SmaCC Runtime" selector="contents">contents	^sourceStream contents</body><body package="SmaCC Runtime" selector="flush">flush	^sourceStream flush</body><body package="SmaCC Runtime" selector="lineNumber">lineNumber	^self lineNumberFor: self position</body><body package="SmaCC Runtime" selector="lineNumberFor:">lineNumberFor: anInteger	| index start stop pos |	pos := anInteger.	pos &gt;= eolPositions last ifTrue: [^eolPositions size].	start := 1.	stop := eolPositions size.	[start + 1 &lt; stop] whileTrue: 			[index := (start + stop) // 2.			(eolPositions at: index) &lt;= pos 				ifTrue: [start := index]				ifFalse: [stop := index]].	^start</body><body package="SmaCC Runtime" selector="next">next	| character streamPosition |	character := sourceStream next.	streamPosition := sourceStream position.	streamPosition - 1 &gt;= lastPosition 		ifTrue: 			[lastPosition := streamPosition.			character == Character cr 				ifTrue: 					[eolPositions add: lastPosition.					previousWasCR := true]				ifFalse: 					[character == Character lf 						ifTrue: 							[previousWasCR 								ifTrue: [eolPositions at: eolPositions size put: lastPosition]								ifFalse: [eolPositions add: lastPosition]].					previousWasCR := false]].	^character</body><body package="SmaCC Runtime" selector="nextPut:">nextPut: anObject 	^sourceStream nextPut: anObject</body><body package="SmaCC Runtime" selector="peek">peek	^sourceStream peek</body><body package="SmaCC Runtime" selector="position">position	^sourceStream position</body><body package="SmaCC Runtime" selector="position:">position: anInteger 	anInteger &gt; lastPosition 		ifTrue: 			[sourceStream position: lastPosition.			[sourceStream position &lt; anInteger and: [sourceStream atEnd not]] 				whileTrue: [self next]]		ifFalse: [sourceStream position: anInteger]</body><body package="SmaCC Runtime" selector="skip:">skip: anInteger	^self position: self position + anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>error handling</category><body package="SmaCC Runtime" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	^sourceStream perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>initialize-release</category><body package="SmaCC Runtime" selector="on:">on: aReadStream 	sourceStream := aReadStream.	eolPositions := OrderedCollection with: aReadStream position.	lastPosition := aReadStream position.	previousWasCR := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>testing</category><body package="SmaCC Runtime" selector="atEnd">atEnd	^sourceStream atEnd</body><body package="SmaCC Runtime" selector="isReadable">isReadable	^sourceStream isReadable</body><body package="SmaCC Runtime" selector="isWritable">isWritable	^sourceStream isWritable</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>private</category><body package="SmaCC Runtime" selector="contentsSpecies">contentsSpecies	^sourceStream contentsSpecies</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream class</class-id> <category>instance creation</category><body package="SmaCC Runtime" selector="on:">on: aReadStream 	^(self basicNew)		on: aReadStream;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="emptySymbolTokenId">emptySymbolTokenId	^scanner emptySymbolTokenId</body><body package="SmaCC Runtime" selector="errorTable">errorTable	^#()</body><body package="SmaCC Runtime" selector="errorToken">errorToken	^errorToken</body><body package="SmaCC Runtime" selector="errorTokenId">errorTokenId	^scanner errorTokenId</body><body package="SmaCC Runtime" selector="parse">parse	| result |	self setDefaultStartingStateIfNone.	self performParsingLoop.	result := nodeStack last.	(result respondsTo: #comments:) ifTrue: [result comments: scanner comments].	^result</body><body package="SmaCC Runtime" selector="position">position	^currentToken isNil ifTrue: [scanner position] ifFalse: [currentToken startPosition]</body><body package="SmaCC Runtime" selector="position:">position: anInteger	scanner setPosition: anInteger</body><body package="SmaCC Runtime" selector="reduceTable">reduceTable	^self subclassResponsibility</body><body package="SmaCC Runtime" selector="scanner">scanner	^scanner</body><body package="SmaCC Runtime" selector="state">state	^scanner state</body><body package="SmaCC Runtime" selector="state:">state: aSymbol	scanner state: aSymbol</body><body package="SmaCC Runtime" selector="symbolTypes">symbolTypes	^#()</body><body package="SmaCC Runtime" selector="transitionTable">transitionTable	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>standard reduction rules</category><body package="SmaCC Runtime" selector="liftFirstValue:">liftFirstValue: aCollection 	^aCollection first</body><body package="SmaCC Runtime" selector="liftLastValue:">liftLastValue: aCollection 	^aCollection last</body><body package="SmaCC Runtime" selector="liftSecondValue:">liftSecondValue: aCollection 	^aCollection at: 2</body><body package="SmaCC Runtime" selector="nil">nil	^nil</body><body package="SmaCC Runtime" selector="stringValue:">stringValue: anOrderedCollection 	^anOrderedCollection first value</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>initialize-release</category><body package="SmaCC Runtime" selector="initialize">initialize	super initialize.	nodeStack := OrderedCollection new</body><body package="SmaCC Runtime" selector="scanner:">scanner: aScanner 	scanner := aScanner</body><body package="SmaCC Runtime" selector="setDefaultStartingStateIfNone">setDefaultStartingStateIfNone	stateStack isNil ifTrue: [self setStartingState: self class defaultStartingState]</body><body package="SmaCC Runtime" selector="setStartingState:">setStartingState: startingState 	stateStack := OrderedCollection with: startingState</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>private</category><body package="SmaCC Runtime" selector="acceptAction">acceptAction	^0</body><body package="SmaCC Runtime" selector="actionFor:">actionFor: aSymbolIndex 	^self actionForState: self currentState and: aSymbolIndex</body><body package="SmaCC Runtime" selector="actionForCurrentToken">actionForCurrentToken	self tryAllTokens		ifTrue:			[| ids action |			ids := currentToken ids.			1				to: ids size				do:					[:i | 					action := self actionFor: (ids at: i).					(action bitAnd: self actionMask) = self errorAction ifFalse: [^action]].			^self errorAction]		ifFalse: [^self actionFor: currentToken ids first]</body><body package="SmaCC Runtime" selector="actionForState:and:">actionForState: stateIndex and: aSymbolIndex	| index row |	row := self transitionTable at: stateIndex.	^(row at: 1) == 0		ifTrue:			[index := self				binarySearchIn: row				for: aSymbolIndex				size: 2.			index == 0 ifTrue: [^self errorAction] ifFalse: [^((row at: 2) bitShift: 8) + (row at: 3)]]		ifFalse:			[index := self				binarySearchIn: row				for: aSymbolIndex				size: 4.			index == 0 ifTrue: [^self errorAction] ifFalse: [^((row at: index - 2) bitShift: 8) + (row at: index - 1)]]</body><body package="SmaCC Runtime" selector="actionMask">actionMask	^2r11</body><body package="SmaCC Runtime" selector="add:to:">add: anObject to: aCollection	anObject isNil ifTrue: [^self].	aCollection add: anObject</body><body package="SmaCC Runtime" selector="addAll:to:">addAll: origCollection to: aCollection	origCollection isNil ifTrue: [^self].	origCollection do: [:each | each notNil ifTrue: [aCollection add: each]]</body><body package="SmaCC Runtime" selector="binarySearchIn:for:size:">binarySearchIn: aRow for: aSymbolIndex size: step	| start mid length high low midItem stop |	high := aSymbolIndex bitShift: -8.	low := aSymbolIndex bitAnd: 16rFF.	start := 4.	stop := aRow size - 1.	length := (stop - start) // step.	[length &gt; 4]		whileTrue:			[length := length bitShift: -1.			mid := length * step + start.			midItem := aRow at: mid.			((midItem == high and: [(aRow at: mid + 1) &lt;= low]) or: [midItem &lt; high])				ifTrue: [start := mid]				ifFalse: [stop := mid]].	[start &lt;= stop]		whileTrue:			[((aRow at: start) == high and: [(aRow at: start + 1) == low]) ifTrue: [^start].			start := start + step].	^0</body><body package="SmaCC Runtime" selector="currentState">currentState	^stateStack last</body><body package="SmaCC Runtime" selector="errorAction">errorAction	^3</body><body package="SmaCC Runtime" selector="getNextToken">getNextToken	currentToken isNil ifTrue: [currentToken := scanner next]</body><body package="SmaCC Runtime" selector="performAction:">performAction: action	| value actionType |	actionType := action bitAnd: self actionMask.	value := action bitShift: -2.	actionType == self shiftAction		ifTrue: [self shift: value]		ifFalse: [actionType == self reduceAction ifTrue: [self reduce: value] ifFalse: [self handleError: value]]</body><body package="SmaCC Runtime" selector="performParsingLoop">performParsingLoop	| action |	[self getNextToken.	action := self actionForCurrentToken.	action = self acceptAction] whileFalse: [self performAction: action].	self checkForErrors</body><body package="SmaCC Runtime" selector="performReduceMethod:with:">performReduceMethod: aSymbol with: items	^aSymbol last == $: ifTrue: [self perform: aSymbol with: items] ifFalse: [self perform: aSymbol]</body><body package="SmaCC Runtime" selector="popNodeStack">popNodeStack	^nodeStack removeLast</body><body package="SmaCC Runtime" selector="reduce:">reduce: anInteger	| reduceEntry items size |	reduceEntry := self reduceTable at: anInteger.	items := Array new: (size := reduceEntry at: 2).	size		to: 1		by: -1		do:			[:i | 			items at: i put: self popNodeStack.			stateStack removeLast].	nodeStack addLast: (self performReduceMethod: (reduceEntry at: 3) with: items).	stateStack addLast: ((self actionFor: (reduceEntry at: 1)) bitShift: -2)</body><body package="SmaCC Runtime" selector="reduceAction">reduceAction	^2r10</body><body package="SmaCC Runtime" selector="reduceFor:">reduceFor: aCollection	| newCollection item |	(aCollection allSatisfy: [:each | each class ~~ OrderedCollection]) ifTrue: [^aCollection asOrderedCollection].	aCollection first class == OrderedCollection		ifTrue:			[newCollection := aCollection first.			2				to: aCollection size				do:					[:i | 					item := aCollection at: i.					item class == OrderedCollection ifTrue: [newCollection addAll: item] ifFalse: [newCollection add: item]].			^newCollection].	newCollection := OrderedCollection new.	aCollection		do: [:each | each class == OrderedCollection ifTrue: [newCollection addAll: each] ifFalse: [newCollection add: each]].	^newCollection</body><body package="SmaCC Runtime" selector="shift:">shift: stateIndex	stateStack addLast: stateIndex.	nodeStack addLast: currentToken.	currentToken := nil</body><body package="SmaCC Runtime" selector="shiftAction">shiftAction	^2r01</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>error handling</category><body package="SmaCC Runtime" selector="checkForErrors">checkForErrors	"If we have an error correction installed, we might have handled the errors. If we did, we don't 	want to return the result, so we raise a final exception that can't be proceeded."	errorToken isNil ifTrue: [^self].	currentToken := errorToken.	self reportErrorMessage: 'Token not expected'</body><body package="SmaCC Runtime" selector="dismissErrorToken">dismissErrorToken	currentToken := nil.	self getNextToken</body><body package="SmaCC Runtime" selector="dismissStackTopForErrorRecovery">dismissStackTopForErrorRecovery	stateStack removeLast.	^nodeStack removeLast</body><body package="SmaCC Runtime" selector="errorHandlerStates">errorHandlerStates	^stateStack		collect:			[:each | 			| action |			action := self actionForState: each and: self errorTokenId.			(action bitAnd: self actionMask) = 1 ifTrue: [action bitShift: -2] ifFalse: [0]]</body><body package="SmaCC Runtime" selector="findErrorHandlerIfNoneUseErrorNumber:">findErrorHandlerIfNoneUseErrorNumber: anInteger	| handlerStates index startingErrorToken |	handlerStates := self errorHandlerStates reverse.	startingErrorToken := currentToken.	[index := (1 to: handlerStates size)		detect:			[:each | 			| state newStack |			state := handlerStates at: each.			state ~= 0				and:					[newStack := stateStack copyFrom: 1 to: handlerStates size - each + 1.					newStack addLast: state.					self willShift: newStack]]		ifNone: [nil].	index isNil]		whileTrue:			[self dismissErrorToken.			self isEOFToken				ifTrue:					[currentToken := startingErrorToken.					self reportError: anInteger]].	index - 1 timesRepeat: [self dismissStackTopForErrorRecovery].	stateStack addLast: (handlerStates at: index).	nodeStack addLast: startingErrorToken</body><body package="SmaCC Runtime" selector="handleError:">handleError: anInteger	errorToken isNil ifTrue: [errorToken := currentToken].	(self isEOFToken or: [self hasErrorHandler not]) ifTrue: [self reportError: anInteger].	self findErrorHandlerIfNoneUseErrorNumber: anInteger</body><body package="SmaCC Runtime" selector="hasErrorHandler">hasErrorHandler	^self errorHandlerStates anySatisfy: [:each | each ~~ 0]</body><body package="SmaCC Runtime" selector="reportError:">reportError: anInteger	self reportErrorMessage: (anInteger = 0 ifTrue: ['Token not expected'] ifFalse: [self errorTable at: anInteger])</body><body package="SmaCC Runtime" selector="reportErrorMessage:">reportErrorMessage: aString 	SmaCCParserError raiseWith: self errorString: aString</body><body package="SmaCC Runtime" selector="willShift:">willShift: potentialStateStack	| action compoundAction reduceEntry size |	compoundAction := self actionForState: potentialStateStack last and: currentToken ids first.	action := compoundAction bitAnd: self actionMask.	action == self shiftAction ifTrue: [^true].	action == self reduceAction		ifTrue:			[reduceEntry := self reduceTable at: (compoundAction bitShift: -2).			size := reduceEntry at: 2.			size timesRepeat: [potentialStateStack removeLast].			potentialStateStack add: ((self actionForState: potentialStateStack last and: (reduceEntry at: 1)) bitShift: -2).			^self willShift: potentialStateStack].	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>testing</category><body package="SmaCC Runtime" selector="isEOFToken">isEOFToken	^currentToken ids first = self emptySymbolTokenId</body><body package="SmaCC Runtime" selector="tryAllTokens">tryAllTokens	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser class</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="defaultStartingState">defaultStartingState	^1</body><body package="SmaCC Runtime" selector="errorBlock:">errorBlock: aBlock	^[:ex | 	| returnValue |	returnValue := aBlock numArgs = 3		ifTrue:			[aBlock				value: ex parameter				value: ex description				value: ex parameter]		ifFalse:			[aBlock numArgs = 1 ifTrue: [aBlock value: ex parameter] ifFalse: [aBlock value: ex description value: ex parameter position]].	ex return: returnValue]</body><body package="SmaCC Runtime" selector="parse:">parse: aString 	^self parse: aString startingAt: self defaultStartingState</body><body package="SmaCC Runtime" selector="parse:onError:">parse: aString onError: aBlock	^[self parse: aString] on: SmaCCParserError do: (self errorBlock: aBlock)</body><body package="SmaCC Runtime" selector="parse:startingAt:">parse: aString startingAt: anInteger	| value |	value := self parseStream: (ReadStream on: aString) startingAt: anInteger.	(value isKindOf: SmaCCParseNode) ifTrue: [value completeSource: aString].	^value</body><body package="SmaCC Runtime" selector="parse:startingAt:onError:">parse: aString startingAt: anInteger onError: aBlock	^[self parse: aString startingAt: anInteger] on: SmaCCParserError do: (self errorBlock: aBlock)</body><body package="SmaCC Runtime" selector="parseFile:">parseFile: aString	| stream |	stream := aString asFilename readStream.	^[self parseStream: stream startingAt: self defaultStartingState] ensure: [stream close]</body><body package="SmaCC Runtime" selector="parseStream:">parseStream: aStream 	^self parseStream: aStream startingAt: self defaultStartingState</body><body package="SmaCC Runtime" selector="parseStream:onError:">parseStream: aStream onError: aBlock	^[self parseStream: aStream] on: SmaCCParserError do: (self errorBlock: aBlock)</body><body package="SmaCC Runtime" selector="parseStream:startingAt:">parseStream: aStream startingAt: anInteger 	| parser |	parser := self on: aStream.	parser setStartingState: anInteger.	^parser parse</body><body package="SmaCC Runtime" selector="parseStream:startingAt:onError:">parseStream: aStream startingAt: anInteger onError: aBlock	^[self parseStream: aStream startingAt: anInteger] on: SmaCCParserError do: (self errorBlock: aBlock)</body><body package="SmaCC Runtime" selector="resetCaches">resetCaches	"self withAllSubclasses do: [:each | each resetCaches]"</body><body package="SmaCC Runtime" selector="scannerClass">scannerClass	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser class</class-id> <category>instance creation</category><body package="SmaCC Runtime" selector="new">new	^(super new)		initialize;		yourself</body><body package="SmaCC Runtime" selector="on:">on: aStream 	| parser scanner |	scanner := self scannerClass on: aStream.	parser := self new.	parser scanner: scanner.	^parser</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser class</class-id> <category>file types</category><body package="SmaCC Runtime" selector="fileExtension">fileExtension	^''</body><body package="SmaCC Runtime" selector="fileExtensionType">fileExtensionType	^'All files'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id> <category>comparing</category><body package="SmaCC Runtime" selector="=">= anObject	^super = anObject and: [self patternToken = anObject patternToken]</body><body package="SmaCC Runtime" selector="hash">hash	^self patternToken hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	^(aDictionary at: self ifAbsent: [nil]) copy</body><body package="SmaCC Runtime" selector="match:inContext:">match: aSmaCCParseNode inContext: aDictionary	^(aDictionary at: self ifAbsentPut: [aSmaCCParseNode]) = aSmaCCParseNode		and: [patternToken testBlock value: aSmaCCParseNode]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="name">name	^patternToken name</body><body package="SmaCC Runtime" selector="patternToken">patternToken	^patternToken</body><body package="SmaCC Runtime" selector="patternToken:">patternToken: anObject	patternToken := anObject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id> <category>variables</category><body package="SmaCC Runtime" selector="tokenVariables">tokenVariables	^#(#patternToken)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id> <category>testing</category><body package="SmaCC Runtime" selector="isListMatch">isListMatch	^patternToken isListMatch</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode class</class-id> <category>instance creation</category><body package="SmaCC Runtime" selector="onToken:">onToken: aSmaCCPatternToken	^(self new)		patternToken: aSmaCCPatternToken;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>testing</category><body package="SmaCC Runtime" selector="atEnd">atEnd	^stream atEnd</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="comments">comments	^comments</body><body package="SmaCC Runtime" selector="contents">contents	| writeStream token |	writeStream := WriteStream with: Array new.	[self atEnd] whileFalse: 			[token := self next.			token notNil ifTrue: [writeStream nextPut: token]].	^writeStream contents</body><body package="SmaCC Runtime" selector="emptySymbolTokenId">emptySymbolTokenId	^self subclassResponsibility</body><body package="SmaCC Runtime" selector="eofTokenId">eofTokenId	^Array with: self emptySymbolTokenId</body><body package="SmaCC Runtime" selector="errorTokenId">errorTokenId	^self subclassResponsibility</body><body package="SmaCC Runtime" selector="lineNumber">lineNumber	"This requires the stream to be a line number stream (see the #needsLineNumbers class method)."	^stream lineNumber</body><body package="SmaCC Runtime" selector="next">next	self resetScanner.	returnMatchBlock := [:match | ^match].	^self scanForToken</body><body package="SmaCC Runtime" selector="position">position	^stream position</body><body package="SmaCC Runtime" selector="scanForToken">scanForToken	^self subclassResponsibility</body><body package="SmaCC Runtime" selector="setPosition:">setPosition: anInteger	^stream position: anInteger</body><body package="SmaCC Runtime" selector="state">state	^state</body><body package="SmaCC Runtime" selector="state:">state: aSymbol	state := aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>private</category><body package="SmaCC Runtime" selector="checkForKeyword:">checkForKeyword: aString	| stateMap action oldActions |	action := matchActions isSymbol ifTrue: [matchActions] ifFalse: [matchActions first].	stateMap := self class keywordMap at: action ifAbsent: [nil].	stateMap isNil ifTrue: [^self].	oldActions := matchActions.	matchActions := stateMap at: (self keywordFor: aString) ifAbsent: [matchActions].	matchActions isInteger ifTrue: [matchActions := (Array with: matchActions) , oldActions]</body><body package="SmaCC Runtime" selector="checkForValidMatch">checkForValidMatch	matchActions isNil ifTrue: [self scannerError]</body><body package="SmaCC Runtime" selector="createTokenFor:">createTokenFor: string	| token |	token := self tokenClass		value: string		start: start + 1		ids: matchActions.	outputStream reset.	^token</body><body package="SmaCC Runtime" selector="patternToken">patternToken	| token |	token := SmaCCPatternToken		value: outputStream contents		start: start + 1		ids: matchActions.	outputStream reset.	^token</body><body package="SmaCC Runtime" selector="recordAndReportMatch:">recordAndReportMatch: aCollection	self recordMatch: aCollection.	^self reportLastMatch</body><body package="SmaCC Runtime" selector="recordMatch:">recordMatch: aCollection 	matchActions := aCollection.	matchEnd := stream position.	lastOutputStreamMatchPosition := outputStream position</body><body package="SmaCC Runtime" selector="reportLastMatch">reportLastMatch	"The scanner has found the end of a token and must report it"	| string action |	self checkForValidMatch.	self resetOutputToLastMatch.	stream position: matchEnd.	string := outputStream contents.	self checkForKeyword: string.	action := matchActions isSymbol				ifTrue: 					["This is only necessary to run version 1 parsers on version 2 SmaCC"					matchActions]				ifFalse: 					[(matchActions first between: 1 and: self tokenActions size)						ifTrue: [self tokenActions at: matchActions first]						ifFalse: [nil]].	^action notNil ifTrue: [self perform: action] ifFalse: [self createTokenFor: string]</body><body package="SmaCC Runtime" selector="resetOutputToLastMatch">resetOutputToLastMatch	outputStream position: lastOutputStreamMatchPosition.	lastOutputStreamMatchPosition == 0 		ifTrue: 			[lastMatchWasEmpty ifTrue: [self scannerError].			lastMatchWasEmpty := true]		ifFalse: [lastMatchWasEmpty := false]</body><body package="SmaCC Runtime" selector="resetScanner">resetScanner	matchActions := nil.	start := stream position.	outputStream reset.	lastOutputStreamMatchPosition := 0</body><body package="SmaCC Runtime" selector="scannerError">scannerError	| string |	(stream atEnd and: [start == stream position]) 		ifTrue: 			[string := ''.			matchActions := self eofTokenId]		ifFalse: 			[stream position: start.			string := String with: stream next.			matchActions := #(0)].	returnMatchBlock value: (self createTokenFor: string)</body><body package="SmaCC Runtime" selector="step">step	stream atEnd ifTrue: [^returnMatchBlock value: self reportLastMatch].	currentCharacter := stream next.	outputStream nextPut: currentCharacter</body><body package="SmaCC Runtime" selector="tokenClass">tokenClass	^SmaCCToken</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>default token handling</category><body package="SmaCC Runtime" selector="comment">comment	comments add: (Array with: start + 1 with: matchEnd).	^self whitespace</body><body package="SmaCC Runtime" selector="whitespace">whitespace	"By default, eat the whitespace"	self resetScanner.	^self scanForToken</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>initialize-release</category><body package="SmaCC Runtime" selector="initialize">initialize	super initialize.	outputStream := WriteStream with: String new.	lastMatchWasEmpty := true.	state := #default.	comments := OrderedCollection new</body><body package="SmaCC Runtime" selector="on:">on: aStream 	stream := aStream.	start := stream position</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>utility</category><body package="SmaCC Runtime" selector="keywordFor:">keywordFor: aString 	"Subclasses can override this to ignore case"	^aString</body><body package="SmaCC Runtime" selector="tokenActions">tokenActions	^#()</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>instance creation</category><body package="SmaCC Runtime" selector="new">new	^(super new)		initialize;		yourself</body><body package="SmaCC Runtime" selector="on:">on: aStream 	^(self new)		on: (self needsLineNumbers 					ifTrue: [SmaCCLineNumberStream on: aStream]					ifFalse: [aStream]);		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>class initialization</category><body package="SmaCC Runtime" selector="initialize">initialize	self initializeKeywordMap</body><body package="SmaCC Runtime" selector="initializeKeywordMap">initializeKeywordMap	keywordMap := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="keywordMap">keywordMap	keywordMap isNil ifTrue: [self initializeKeywordMap].	^keywordMap</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>testing</category><body package="SmaCC Runtime" selector="needsLineNumbers">needsLineNumbers	"Redefine to return true, if you need line number information"	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternToken</class-id> <category>accessing</category><body package="SmaCC Runtime" selector="beList">beList	isList := true</body><body package="SmaCC Runtime" selector="beNode">beNode	isNode := true.	isToken := false</body><body package="SmaCC Runtime" selector="beToken">beToken	isToken := true.	isNode := false</body><body package="SmaCC Runtime" selector="beTokenOrNode">beTokenOrNode	isToken := true.	isNode := true</body><body package="SmaCC Runtime" selector="name">name	| resultStream readStream char |	(value first isAlphaNumeric or: [value first == $_]) ifTrue: [^value].	resultStream := WriteStream on: String new.	readStream := ReadStream on: value.	readStream next.	[char := readStream next.	char isLetter or: [char == $_]] whileFalse.	[resultStream nextPut: char.	char := readStream next.	char isAlphaNumeric or: [char == $_]] whileTrue.	^resultStream contents</body><body package="SmaCC Runtime" selector="nodeClassName">nodeClassName	^nodeClassName</body><body package="SmaCC Runtime" selector="nodeClassName:">nodeClassName: aString	nodeClassName := aString</body><body package="SmaCC Runtime" selector="testBlock">testBlock	^[:node | 	(nodeClassName isNil or: [node isKindOf: (node class environment at: self nodeClassName ifAbsent: [SmaCCParseNode])])		and: [testBlock value: node]]</body><body package="SmaCC Runtime" selector="testBlock:">testBlock: aBlock	testBlock := aBlock</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternToken</class-id> <category>testing</category><body package="SmaCC Runtime" selector="isListMatch">isListMatch	^isList</body><body package="SmaCC Runtime" selector="isNode">isNode	^isNode</body><body package="SmaCC Runtime" selector="isPattern">isPattern	^true</body><body package="SmaCC Runtime" selector="isToken">isToken	^isToken</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternToken</class-id> <category>matching</category><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	^aDictionary at: self</body><body package="SmaCC Runtime" selector="match:inContext:">match: aSmaCCToken inContext: aDictionary	^(aSmaCCToken isKindOf: SmaCCToken)		and: [(aDictionary at: self ifAbsentPut: [aSmaCCToken]) = aSmaCCToken and: [self testBlock value: aSmaCCToken]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternToken</class-id> <category>initialize-release</category><body package="SmaCC Runtime" selector="value:start:ids:">value: aString start: startPositionInteger ids: aCollection	super value: aString start: startPositionInteger ids: aCollection.	self buildStructure</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternToken</class-id> <category>comparing</category><body package="SmaCC Runtime" selector="=">= aSmaCCToken	^self class = aSmaCCToken class and: [self name = aSmaCCToken name]</body><body package="SmaCC Runtime" selector="hash">hash	^self class hash bitXor: self name hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternToken</class-id> <category>private</category><body package="SmaCC Runtime" selector="buildStructure">buildStructure	| index code |	isList := isToken := false.	isNode := true.	testBlock := [:node | true].	index := value indexOf: ${.	index &gt; 0 ifFalse: [^self].	code := value copyFrom: index + 1 to: (value lastIndexOf: $}) - 1.	Compiler		evaluate: 'self ' , code		for: self		logged: false</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>SmaCC matching</category><body package="SmaCC Runtime" selector="match:inContext:">match: anObject inContext: aDictionary	^self = anObject</body></methods><initialize><class-id>Refactory.SmaCC.SmaCCScanner</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>