<?xml version="1.0"?><st-source><!-- Name: SmaCC DevelopmentNotice: Comment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains the classes used to create a new parser. It is only needed when developing parsers. While these classes can be used directly, it is suggested that you use the GUI in the SmaCC Development UI package to create your parsers. If you wish to use the code directly, you can browse the code in the SmaCC Tests for examples. If you want more information about SmaCC, visit http://www.refactoryworkers.com/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2010 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: bear73DbTrace: 317929DevelopmentPrerequisites: #(#(#any 'SmaCC GLR Runtime' '') #(#any 'Browser-Refactorings' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: SmaCC DevelopmentParcel: #('SmaCC Development')PrerequisiteParcels: #(#('SmaCC GLR Runtime' '') #('Browser-Refactorings' ''))PrintStringCache: (2.0.3,brant)Version: 2.0.3Date: 9:56:23 AM January 28, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.4) of January 28, 2011 on January 28, 2011 at 9:56:23 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SmaCCVariableDefinition</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variableName isCollection baseType isAlwaysAssigned getterMethodName setterMethodName index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCVariableDefinition</class-id><body>SmaCCVariableDefinition represents a variable for a node class.Instance Variables	baseType	&lt;RBAbstractClass&gt;	the type of the variable	getterMethodName	&lt;Symbol&gt;	the getter selector	index	&lt;Integer&gt;	the index of the variable (if we are pulling up a collection of variables from a symbol)	isAlwaysAssigned	&lt;Boolean&gt;	does the variable always have a value or can it be nil	isCollection	&lt;Boolean&gt;	does the variable represent a collection of values	setterMethodName	&lt;Symbol&gt;	the setter selector	variableName	&lt;String&gt;	the name of the variable</body></comment><class><name>SmaCCReduceCode</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rhs cachedTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id><body>SmaCCReduceCode represents the code to be run when we match the rhs.Subclasses must implement the following messages:	accessing		source - returns the code to be run after matching the rhs	private		basicModelTypes: - returns the types the source can return (e.g., OrderedCollection, SmaCCToken, etc.)Instance Variables	cachedTypes	&lt;Collection of: RBClass&gt;	the type of object that is returned when this reduce action is run	rhs	&lt;SmaCCRHS&gt;	the RHS that contains this reduce code</body></comment><class><name>SmaCCCreateNodeReduceCode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReduceCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDefinition index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCreateNodeReduceCode</class-id><body>SmaCCCreateNodeReduceCode represents a reduce action that creates a parse node.Instance Variables	classDefinition	&lt;SmaCCClassDefinition&gt;	the parse node class to create	index	&lt;Integer&gt;	index in the RHS of a symbol that returns parse node, if no symbol returns the parse node, then the index = 0</body></comment><class><name>SmaCCGrammarItem</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variableDefinitions grammar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCGrammarItem</class-id><body>SmaCCGrammarItem is an abstract class that represents something defined by the grammar.Subclasses must implement the following messages:	accessing		modelTypes:	private		annotateTokenVariables:		basicModelTypesForVariable:into:seen:		firstTerminalsInstance Variables	grammar	&lt;SmaCCGrammar&gt;	the grammar that we are defined in	variableDefinitions	&lt;OrderedCollection of: SmaCCVariableDefinition&gt;	the variables defined by this item</body></comment><class><name>SmaCCSymbol</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCGrammarItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name precedence firstTerminals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCSymbol</class-id><body>SmaCCSymbol is an abstract class that represents a symbol in our grammar. Symbols can be either terminal or non-terminal. Terminal symbols are mapped to tokens in the grammar and non-terminals are made up of other symbols.Subclasses must implement the following messages:	accessing		calculateFirstTerminals	testing		isTerminalInstance Variables	firstItems	&lt;Set of: SmaCCTerminalSymbol&gt;	the first terminal symbol that this can produce	name	&lt;String&gt;	the name of the symbol	precedence	&lt;Integer&gt;	the precedence for the symbol used for shift/reduce conflicts</body></comment><class><name>SmaCCNonTerminalSymbol</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCNode</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitions action id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCScannerDefinition</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokens states excludeStates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCAction</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCAction</class-id><body>SmaCCAction is an abstract class that represent actions (shift, reduce, accept, reject) in the LR parser to be performed for a specific state/symbol pair. Subclasses must implement the following messages:	accessing		id		lr1Item	private		mergeWith:prefer:</body></comment><class><name>SmaCCPrimitiveAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lr1Item </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCPrimitiveAction</class-id><body>SmaCCPrimitiveAction is an abstract class that represents a basic LR state/symbol action (shift, reduce, accept, or reject).Instance Variables:	lr1Item	&lt;SmaCCLR1Item&gt;	the item that the action is for</body></comment><class><name>SmaCCShiftAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCPrimitiveAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id><body>SmaCCShiftAction represents the LR shift action.</body></comment><class><name>SmaCCClassDefinition</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name subclasses grammar class superclass isRoot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id><body>SmaCCClassDefinition is an abstract class that represents a class to be created when compiling the parser's parse trees.Instance Variables:	class	&lt;RBClass&gt;	the model's class object that is created	grammar	&lt;SmaCCGrammar&gt;	the grammar that owns this class	isRoot	&lt;Boolean&gt;	is this the root class that we are generating	name	&lt;String&gt;	the name of the class	subclasses	&lt;Collection of: SmaCCNodeClassDefinition&gt;	our subclasses	superclass	&lt;SmaCCNodeClassDefinition&gt;	our superclass</body></comment><class><name>SmaCCVisitorClassDefinition</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCClassDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeClassDefinitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCVisitorClassDefinition</class-id><body>SmaCCVisitorClassDefinition represents the visitor class for the grammar.Instance Variables	nodeClassDefinitions	&lt;Collection of: SmaCCNodeClassDefinition&gt;	the node classes to create the visitor for</body></comment><class><name>SmaCCSet</name><environment>Refactory.SmaCC</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>characters objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCEdge</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>toNode transitionObjects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCEdge</class-id><body>SmaCCEdge is an edge in the DFA/NFA for the scanner. It contains the objects (characters or symbols) that we transition on and the node we transition to.Subclasses must implement the following messages:	private		dispatchTo:seen:Instance Variables:	toNode	&lt;SmaCCNode&gt;	the next node in the graph	transitionObjects	&lt;Collection of: (Character | Symbol))&gt;	the characters or states that we transition on</body></comment><class><name>SmaCCCharacterEdge</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCEdge</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCharacterEdge</class-id><body>SmaCCCharacterEdge is a SmaCCEdge for Characters.</body></comment><class><name>SmaCCRegularExpressionNode</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action position states </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id><body>SmaCCRegularExpressionNode is an abstract class that is used during the construction of the scanner. When the scanner definition is parsed, it creates the SmaCCRegularExpressionNode objects. These objects are then converted to an NFA graph that is converted to a DFA that is compiled.Subclasses must implement the following messages:	accessing		possibleMatchesSize	private		asNFAStartingWith:		possibleMatchesDo:on:Instance Variables:	action	&lt;Object&gt;	this is a symbol that is performed on the scanner, an integer for the token id, or nil if we can't accept a token at this position	position	&lt;Integer&gt;	the position in the scanner definition for this RE -- this is only used for overlapping tokens. Tokens that are defined earlier in the definition are preferred over later ones (except for those used in the parser's definition)	states	&lt;Collection of: Symbol&gt;	the states where this RE is valid</body></comment><class><name>SmaCCOrRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id><body>SmaCCOrRENode is a SmaCCRegularExpressionNode that represents several possible regular expression choices. For example, we may have an SmaCCOrRENode that contains a character RE that matches letters when the state is #foo, and another character RE that matches whitespace when the state is #bar.Instance Variables:	nodes	&lt;Collection of: SmaCCRegularExpressionNode&gt;	all RE nodes that are being ORed together</body></comment><class><name>SmaCCReduceActionGenerator</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rhs index generator variableName currentIndex currentSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCVariableReduceCode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReduceCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCVariableReduceCode</class-id><body>SmaCCVariableReduceCode represents a reduce action that returns a collection of objects that represent the variables defined by the rhs. When this is pulled up into a create node, it will use the variable collection to create the node.</body></comment><class><name>SmaCCStartingSymbol</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCNonTerminalSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCCompositeAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCompositeAction</class-id><body>SmaCCCompositeAction is an abstract class that represents multiple actions. Subclasses must implement the following messages:	accessing		errorType		preferredActionInstance Variables:	actions	&lt;Collection of: SmaCCAction&gt;	all valid non-reject actions</body></comment><class><name>SmaCCReduceAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCPrimitiveAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id><body>SmaCCReduceAction represents the LR reduce action.</body></comment><class><name>SmaCCGraphAlgorithm</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCSequenceRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id><body>SmaCCSequenceRENode is a SmaCCRegularExpressionNode that matches a sequence of other RE nodes.Instance Variables:	nodes	&lt;SequenceableCollection of: SmaCCRegularExpressionNode&gt;	an ordered list of nodes to match</body></comment><class><name>SmaCCRHS</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCGrammarItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection reduceAction variableNameMap nodeClassDefinition productionSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCSymbolSet</name><environment>Refactory.SmaCC</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbols components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCDefinitionParser</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scannerDefinition grammar defaultClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Generated Scanner/Parser</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCDefinitionParser</class-id><body>SmaCCDefinitionParser is a SmaCCParser that parses a parser's definition.Instance Variables:	grammar	&lt;SmaCCGrammar&gt;	we create the grammar object from the parser's definition	scannerDefinition	&lt;SmaCCScannerDefinition&gt;	we also create the scanner definition object from the parser's definition</body></comment><class><name>SmaCCNFAtoDFA</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCGraphAlgorithm</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergedStates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCNotRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCNotRENode</class-id><body>SmaCCNotRENode is a SmaCCRegularExpressionNode that inverts another SmaCCRegularExpressionNode matches.Instance Variables:	node	&lt;SmaCCRegularExpressionNode&gt;	the node whose match is being inverted</body></comment><class><name>SmaCCEpsilonRemoval</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCGraphAlgorithm</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCEpsilonRemoval</class-id><body>SmaCCEpsilonRemoval removes all epsilon edges from the scanner's NFA.Instance Variables:	nodeMap	&lt;Dictionary key: SmaCCNode value: SmaCCNode&gt;	map from nodes in old graph to nodes in new graph</body></comment><class><name>SmaCCNodeCalculation</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar classes variableSymbols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCPreferredCompositeAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCCompositeAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preferredAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCPreferredCompositeAction</class-id><body>SmaCCPreferredCompositeAction is a composite action that has a preferred action. The preferred action is used in the state/symbol table.Instance Variables:	preferredAction	&lt;SmaCCAction&gt;	the preferred action</body></comment><class><name>SmaCCDefaultNodeReduceCode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReduceCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCDefaultNodeReduceCode</class-id><body>SmaCCDefaultNodeReduceCode represents a reduce action that returns an item in the rhs. It returns the first symbol that is a non-terminal. If all symbols are terminals, then it returns the first terminal symbol. If there aren't any symbols, then it returns nil.Instance Variables	index	&lt;Integer&gt;	the index in the rhs to return; if 0 then return nil</body></comment><class><name>SmaCCSymbolTableIndex</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCNodeClassDefinition</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCClassDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productions variables extraAttributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition</class-id><body>SmaCCNodeClassDefinition represents a class to compile.Instance Variables	extraAttributes	&lt;Collection of: SmaCCVariableDefinition&gt;	extra variables that should be added to the class	productions	&lt;Collection of: SmaCCRHS&gt;	all of the rhs that return/create this class	variables	&lt;Collection of: SmaCCVariableDefinition&gt;	the variables defined by the grammar for this class</body></comment><class><name>SmaCCCodeGenerator</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parserClass scannerClass model codeStream reduceActionCache ambiguousActions grammar </inst-vars><class-inst-vars>codeTemplates </class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id><body>SmaCCCodeGenerator is an abstract class that is used to generate code. Subclasses are used to generate code for a particular language (e.g., Smalltalk, Java, etc.).Subclasses must implement the following messages:	code generation templates		comment:		method:type:		method:type:argumentName:argumentType:		method:type:argumentName:argumentType:argumentName:argumentType:		reduceAction:		send:to:with:		send:to:with:with:		send:to:with:with:with:		superMessage:		superMessage:argument:		superMessage:argument:argument:		variableReference:in:	compiling		compileChanges		compileMethodWithoutFormattingIn:		compileScannerClassIntoParser		outputStreamClass		removeOldMethods	compiling-nodes		compileInitializeMethod:	compiling-scanner		acceptStateEdge:		closestIsExpressionsFor:seen:		compileKeywordInitializerUsing:		defineClass:asSubclassOf:		outputInvertedMatchFor:on:		outputIsSelector:on:		outputMatchFor:on:without:		scannerActionFor:		scannerClass:		selectorMap:		writeMatchingCodeFor:	private		addVariable:forDefinition:		defaultNodeReductionSource:		removeOldMethodsFrom:		send:to:		writeTransitionTableEntry:on:firstIsType:	reduction table		basicCompileSourceFor:		defaultReductionSourceInstance Variables	ambiguousActions	&lt;SequenceableCollection of: SequenceableCollection&gt;	the ambiguous actions for the grammar	codeStream	&lt;Stream&gt;	a stream for writing the code	grammar	&lt;SmaCCGrammar&gt;	the grammar we are compiling	model	&lt;RBRootNamespace&gt;	the model for the system that we are compiling	parserClass	&lt;RBClass&gt;	the model's class for the parser	reduceActionCache	&lt;Dictionary key: SmaCCReduceAction value: String&gt;	mapping from reduce actions to their code	scannerClass	&lt;RBClass&gt;	the model's class for the scanner</body></comment><class><name>SmaCCDefinitionScanner</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parseSourceSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCDefinitionScanner</class-id><body>SmaCCDefinitionScanner is the SmaCCScanner for the parser definition.Instance Variables:	parseSourceSelector	&lt;Symbol&gt;	a symbol that can be performed to parse the code inside the {} reduce actions</body></comment><class><name>SmaCCScannerCompiler</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar codeGenerator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCGrammarCompiler</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shiftTable itemSets startingStateMap actions parserDefinitionString scannerCompiler grammar codeGenerator reduceTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCStateEdge</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCEdge</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCStateEdge</class-id><body>SmaCCStateEdge is a SmaCCEdge on states (that are represented by symbols) in the scanner.</body></comment><class><name>SmaCCVariableCalculation</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar todo dependentsMap newVariables ourType currentRHS previousVariables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCRepeatingRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node minimumMatches maximumMatches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id><body>SmaCCRepeatingRENode is a SmaCCRegularExpressionNode that matches a particular RE node multiple times.Instance Variables:	maximumMatches	&lt;Integer&gt;	the maximum amount of matches (or #finiteInfinity if we can repeat unlimited number of times)	minimumMatches	&lt;Integer&gt;	the minimum amount of matches we must accept	node	&lt;SmaCCRegularExpressionNode&gt;	the node we are matching</body></comment><class><name>SmaCCRejectAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCPrimitiveAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCRejectAction</class-id><body>SmaCCRejectAction represents the LR reject action.</body></comment><class><name>SmaCCDefaultReduceCode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReduceCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCDefaultReduceCode</class-id><body>SmaCCDefaultReduceCode represents a reduce action that returns a collection of all items in the rhs.</body></comment><class><name>SmaCCAcceptAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCPrimitiveAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCAcceptAction</class-id><body>SmaCCAcceptAction represents the LR accept action.</body></comment><class><name>SmaCCAmbiguousAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCCompositeAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCAmbiguousAction</class-id><body>SmaCCAmbiguousAction represents several conflicting actions for a state/symbol. If we are creating a GLR parser then all actions will be performed. Otherwise, we'll pick one of the actions to be performed preferring shift actions over reduce actions.</body></comment><class><name>SmaCCGrammar</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type shiftReduceTable symbols scannerDefinition otherStartingSymbols classDefinitions prefix suffix codeGenerator isGLR ignoreCase ignoredVariables annotateTokens errorSymbol emptySymbol sentinelSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCSourceReduceCode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCReduceCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCSourceReduceCode</class-id><body>SmaCCSourceReduceCode represents a reduce action that is specified in the grammar. In this case, it outputs the code directly into the parser.Instance Variables	source	&lt;String&gt;	the source to output</body></comment><class><name>SmaCCItemSet</name><environment>Refactory.SmaCC</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>type previousItemSets grammar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCCompilationNotification</name><environment>Refactory.SmaCC</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCompilationNotification</class-id><body>SmaCCCompilationNotification is a Notification that is signaled when a problem occurs when compiling the parser. It is mainly used to show the user problems with their grammar.</body></comment><class><name>SmaCCCharacterRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>characters ignoreCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id><body>SmaCCCharacterRENode is a SmaCCRegularExpressionNode that matches a character.Instance Variables:	characters	&lt;String&gt;	the characters we accept	ignoreCase	&lt;Boolean&gt;	should we ignore case when accepting the characters</body></comment><class><name>SmaCCLR1Item</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rhs location followers itemSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><class><name>SmaCCSmalltalkCodeGenerator</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCCodeGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isExpressions parseTreeCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id><body>SmaCCSmalltalkCodeGenerator represents a code generator for Smalltalk.Instance Variables	isExpressions	&lt;Dictionary key: String value: Symbol&gt;	a map of strings to is??? methods on String that answer true for those strings (e.g., '0123456789' -&gt; #isDigit)	parseTreeCache	&lt;Dictionary key: Symbol value: RBProgramNode&gt;	mapping from selector names to code compiled in the method</body></comment><class><name>SmaCCDuplicateNodeEliminator</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCGraphAlgorithm</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comparisonState root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCDuplicateNodeEliminator</class-id><body>SmaCCDuplicateNodeEliminator removes duplicate nodes from a scanner's DFA.Instance Variables:	comparisonState	&lt;Dictionary&gt;	a dictionary of "equal" objects when testing nodes for equality	root	&lt;SmaCCNode&gt;	the root node for the DFA</body></comment><class><name>SmaCCTerminalSymbol</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>regularExpression createIdMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Development</category><attributes><package>SmaCC Development</package></attributes></class><shared-variable><name>IsCaching</name><environment>Refactory.SmaCC.SmaCCDefaultNodeReduceCode</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>PluralNames</name><environment>Refactory.SmaCC.SmaCCVariableDefinition</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>PluralNameBlock</name><environment>Refactory.SmaCC.SmaCCVariableDefinition</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>NextId</name><environment>Refactory.SmaCC.SmaCCNode</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>TokenNameBlock</name><environment>Refactory.SmaCC.SmaCCGrammar</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>MaximumCharacterValue</name><environment>Refactory.SmaCC.SmaCCGrammar</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>TokenNameMap</name><environment>Refactory.SmaCC.SmaCCGrammar</environment><private>false</private><constant>false</constant><category>variable</category><attributes><package>SmaCC Development</package></attributes></shared-variable><methods><class-id>Refactory.SmaCC.SmaCCVariableDefinition</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= anObject	^self class = anObject class		and: [self variableName = anObject variableName and: [self isCollection = anObject isCollection]]</body><body package="SmaCC Development" selector="hash">hash	^self variableName hash bitXor: self isCollection hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableDefinition</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="baseType:">baseType: modelClass	baseType := modelClass</body><body package="SmaCC Development" selector="isCollection:">isCollection: aBoolean	isCollection := aBoolean</body><body package="SmaCC Development" selector="variableName:">variableName: aString	variableName := aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableDefinition</class-id> <category>accessing</category><body package="SmaCC Development" selector="baseType">baseType	^baseType</body><body package="SmaCC Development" selector="collectionType">collectionType	^self baseType rootNameSpace classFor: OrderedCollection</body><body package="SmaCC Development" selector="getterMethodName">getterMethodName	^getterMethodName</body><body package="SmaCC Development" selector="getterMethodName:">getterMethodName: aString	getterMethodName := aString</body><body package="SmaCC Development" selector="index">index	^index</body><body package="SmaCC Development" selector="index:">index: anInteger	index := anInteger</body><body package="SmaCC Development" selector="isAlwaysAssigned">isAlwaysAssigned	^isAlwaysAssigned or: [self isCollection]</body><body package="SmaCC Development" selector="isAlwaysAssigned:">isAlwaysAssigned: aBoolean	isAlwaysAssigned := aBoolean</body><body package="SmaCC Development" selector="isBaseNodeType">isBaseNodeType	^self baseType includesClass: (self baseType rootNameSpace classFor: SmaCCParseNode)</body><body package="SmaCC Development" selector="isBasePossibleNodeType">isBasePossibleNodeType	^self isBaseNodeType		or: [(self baseType rootNameSpace classFor: SmaCCParseNode) includesClass: self baseType]</body><body package="SmaCC Development" selector="isBaseTokenType">isBaseTokenType	^self baseType includesClass: (self baseType rootNameSpace classFor: SmaCCToken)</body><body package="SmaCC Development" selector="isCollection">isCollection	^isCollection</body><body package="SmaCC Development" selector="isNodeCollectionType">isNodeCollectionType	^self isCollection and: [self isBaseNodeType]</body><body package="SmaCC Development" selector="isNodeType">isNodeType	^self isCollection not and: [self isBaseNodeType]</body><body package="SmaCC Development" selector="isPossibleNodeCollectionType">isPossibleNodeCollectionType	^self isCollection and: [self isBasePossibleNodeType]</body><body package="SmaCC Development" selector="isPossibleNodeType">isPossibleNodeType	^self isCollection not and: [self isBasePossibleNodeType]</body><body package="SmaCC Development" selector="setterMethodName">setterMethodName	^setterMethodName</body><body package="SmaCC Development" selector="setterMethodName:">setterMethodName: aString	setterMethodName := aString</body><body package="SmaCC Development" selector="sourceVariableName">sourceVariableName	^self isCollection ifTrue: [self class pluralNameFor: variableName] ifFalse: [variableName]</body><body package="SmaCC Development" selector="type">type	^self isCollection ifTrue: [self collectionType] ifFalse: [self baseType]</body><body package="SmaCC Development" selector="variableName">variableName	^variableName</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableDefinition class</class-id> <category>accessing</category><body package="SmaCC Development" selector="assignIndices:">assignIndices: aCollection	aCollection keysAndValuesDo: [:index :each | each index: index]</body><body package="SmaCC Development" selector="pluralNameBlock">pluralNameBlock	^PluralNameBlock ifNil: [^[:value | nil]]</body><body package="SmaCC Development" selector="pluralNameBlock:">pluralNameBlock: aBlock	PluralNameBlock := aBlock</body><body package="SmaCC Development" selector="pluralNames">pluralNames	PluralNames isNil		ifTrue:			[PluralNames := Dictionary new.			PluralNames				at: 's' put: 'ses';				at: 'y' put: 'ies';				at: 'x' put: 'xes';				at: 'ch' put: 'ches'].	^PluralNames</body><body package="SmaCC Development" selector="pluralNames:">pluralNames: aDictionary	PluralNames := aDictionary</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableDefinition class</class-id> <category>private</category><body package="SmaCC Development" selector="pluralNameFor:">pluralNameFor: aString	| size |	(self pluralNameBlock value: aString) ifNotNil: [:result | ^result].	size := aString size.	1		to: size		do:			[:i | 			(self pluralNames at: (aString copyFrom: size - i + 1 to: size) ifAbsent: [nil])				ifNotNil: [:ending | ^(aString copyFrom: 1 to: size - i) , ending]].	^aString copyWith: $s</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableDefinition class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="variableName:">variableName: aString	^(self new)		variableName: aString;		isCollection: false;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id> <category>accessing-types</category><body package="SmaCC Development" selector="modelTypes:">modelTypes: anIdentitySet	cachedTypes isNil ifTrue: [cachedTypes := self basicModelTypes: anIdentitySet].	^cachedTypes</body><body package="SmaCC Development" selector="nodeType:">nodeType: anIdentitySet	| index |	index := self returnedNodeIndex.	^index notNil ifTrue: [(rhs at: index) nodeType: anIdentitySet] ifFalse: [self baseClassType]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id> <category>accessing</category><body package="SmaCC Development" selector="codeGenerator">codeGenerator	^rhs grammar codeGenerator</body><body package="SmaCC Development" selector="model">model	^rhs model</body><body package="SmaCC Development" selector="rhs">rhs	^rhs</body><body package="SmaCC Development" selector="source">source	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= anObject	^self class = anObject class and: [self rhs == anObject rhs]</body><body package="SmaCC Development" selector="hash">hash	^self class hash bitXor: self rhs hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id> <category>private</category><body package="SmaCC Development" selector="baseClassType">baseClassType	^rhs grammar rootDefinition</body><body package="SmaCC Development" selector="basicModelTypes:">basicModelTypes: aSet	self subclassResponsibility</body><body package="SmaCC Development" selector="basicModelTypes:forIndex:">basicModelTypes: aSet forIndex: index	^(rhs at: index) modelTypes: aSet</body><body package="SmaCC Development" selector="returnedNodeIndex">returnedNodeIndex	| parseTree index |	parseTree := self reduceExpressionParseTree.	parseTree isCascade ifTrue: [parseTree := parseTree messages last].	(parseTree isMessage and: [parseTree selector == #yourself])		ifTrue: [parseTree := parseTree receiver].	(parseTree isVariable or: [parseTree isLiteralNode]) ifFalse: [^nil].	parseTree isVariable ifTrue: [^rhs indexOfVariable: parseTree name].	parseTree value isString ifFalse: [^nil].	(parseTree value allSatisfy: [:each | each isDigit])		ifTrue:			[index := Integer readFrom: (ReadStream on: parseTree value).			(index between: 1 and: rhs size) ifTrue: [^index]].	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id> <category>testing</category><body package="SmaCC Development" selector="hasReduceAction">hasReduceAction	^true</body><body package="SmaCC Development" selector="returnsVariableCollection">returnsVariableCollection	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="rhs:">rhs: aSmaCCRHS	rhs := aSmaCCRHS</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode</class-id> <category>reduce actions</category><body package="SmaCC Development" selector="reduceExpressionParseTree">reduceExpressionParseTree	^RBParser parseExpression: self source</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceCode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="onRHS:">onRHS: aSmaCCRHS	^(self new)		rhs: aSmaCCRHS;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCreateNodeReduceCode</class-id> <category>accessing</category><body package="SmaCC Development" selector="classDefinition">classDefinition	classDefinition isNil ifTrue: [classDefinition := rhs nodeClassDefinition ifNil: [rhs nodeType]].	^classDefinition</body><body package="SmaCC Development" selector="index">index	^index ifNil: [index := rhs componentIndex]</body><body package="SmaCC Development" selector="source">source	^self isPullUpAction		ifTrue: [self codeGenerator createNodeReduceAction: rhs pullUpFrom: self index]		ifFalse: [self codeGenerator createNodeReduceAction: rhs]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCreateNodeReduceCode</class-id> <category>testing</category><body package="SmaCC Development" selector="isPullUpAction">isPullUpAction	^self index &gt; 0</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCreateNodeReduceCode</class-id> <category>accessing-types</category><body package="SmaCC Development" selector="nodeType:">nodeType: anIdentitySet	^self classDefinition</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCreateNodeReduceCode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="index:">index: anInteger	index := anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCreateNodeReduceCode</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= anObject	^super = anObject and: [self classDefinition = anObject classDefinition and: [self index = anObject index]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCreateNodeReduceCode</class-id> <category>private</category><body package="SmaCC Development" selector="basicModelTypes:">basicModelTypes: aSet	^Array with: self classDefinition modelClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarItem</class-id> <category>reduce actions</category><body package="SmaCC Development" selector="isNode">isNode	^self modelType includesClass: (self model classFor: SmaCCParseNode)</body><body package="SmaCC Development" selector="modelType">modelType	^self modelType: IdentitySet new</body><body package="SmaCC Development" selector="modelType:">modelType: anIdentitySet	| types |	types := self modelTypes: anIdentitySet.	^self grammar codeGenerator commonSupertypeOf: types</body><body package="SmaCC Development" selector="nodeType">nodeType	^self nodeType: IdentitySet new</body><body package="SmaCC Development" selector="nodeType:">nodeType: anIdentitySet	| node rootType |	rootType := self modelType: anIdentitySet.	node := nil.	(rootType includesClass: (self model referencedItem: #SmaCCParseNode))		ifTrue: [node := self grammar classDefinitions detect: [:e | e modelClass = rootType] ifNone: [nil]].	^node</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarItem</class-id> <category>accessing</category><body package="SmaCC Development" selector="grammar">grammar	^grammar</body><body package="SmaCC Development" selector="model">model	^self grammar codeGenerator model</body><body package="SmaCC Development" selector="modelTypes">modelTypes	^self modelTypes: IdentitySet new</body><body package="SmaCC Development" selector="modelTypes:">modelTypes: anIdentitySet	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarItem</class-id> <category>private</category><body package="SmaCC Development" selector="annotateTokenVariables:">annotateTokenVariables: aBlock	self subclassResponsibility</body><body package="SmaCC Development" selector="basicModelTypesForVariable:into:seen:">basicModelTypesForVariable: aString into: aCollection seen: anIdentitySet	self subclassResponsibility</body><body package="SmaCC Development" selector="firstTerminals">firstTerminals	^self subclassResponsibility</body><body package="SmaCC Development" selector="modelTypesForVariable:">modelTypesForVariable: aString	^self modelTypesForVariable: aString seen: IdentitySet new</body><body package="SmaCC Development" selector="modelTypesForVariable:seen:">modelTypesForVariable: aString seen: anIdentitySet	| productionTypes |	(anIdentitySet includes: self) ifTrue: [^#()].	anIdentitySet add: self.	productionTypes := Set new.	self		basicModelTypesForVariable: aString		into: productionTypes		seen: anIdentitySet.	^productionTypes</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarItem</class-id> <category>variables</category><body package="SmaCC Development" selector="collectionVariableDefinitions">collectionVariableDefinitions	^self variableDefinitions select: [:each | each isCollection]</body><body package="SmaCC Development" selector="computeVariableDefinitions">computeVariableDefinitions	^#()</body><body package="SmaCC Development" selector="hasVariableNamed:">hasVariableNamed: aString	^self variableDefinitions anySatisfy: [:each | each variableName = aString]</body><body package="SmaCC Development" selector="indexOfVariable:">indexOfVariable: aString	self variableDefinitions keysAndValuesDo: [:index :each | each variableName = aString ifTrue: [^index]].	self error: 'Variable not found'</body><body package="SmaCC Development" selector="isCollection:">isCollection: aString	^self collectionVariableDefinitions anySatisfy: [:each | each variableName = aString]</body><body package="SmaCC Development" selector="variableDefinitions">variableDefinitions	^variableDefinitions ifNil: [self computeVariableDefinitions]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarItem</class-id> <category>testing</category><body package="SmaCC Development" selector="isSubtypeOf:">isSubtypeOf: aSmaCCGrammarItem	^self modelType includesClass: aSmaCCGrammarItem modelType</body><body package="SmaCC Development" selector="returnsVariableCollection">returnsVariableCollection	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarItem</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="grammar:">grammar: aSmaCCGrammar	grammar := aSmaCCGrammar</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarItem class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>private</category><body package="SmaCC Development" selector="annotateTokenVariables:">annotateTokenVariables: aBlock	self productionsDo: [:each | each annotateTokenVariables: aBlock]</body><body package="SmaCC Development" selector="basicModelTypesForVariable:into:seen:">basicModelTypesForVariable: aString into: productionTypes seen: aSet	self productionsDo: [:each | productionTypes addAll: (each modelTypesForVariable: aString seen: aSet)]</body><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive</body><body package="SmaCC Development" selector="unsafeMethodName">unsafeMethodName	^self printString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>accessing</category><body package="SmaCC Development" selector="calculateFirstTerminals">calculateFirstTerminals	^self subclassResponsibility</body><body package="SmaCC Development" selector="createIdMethod">createIdMethod	^false</body><body package="SmaCC Development" selector="firstTerminals">firstTerminals	^firstTerminals</body><body package="SmaCC Development" selector="isEmptySymbol">isEmptySymbol	^self = grammar emptySymbol</body><body package="SmaCC Development" selector="name">name	^name</body><body package="SmaCC Development" selector="precedence">precedence	^precedence</body><body package="SmaCC Development" selector="precedence:">precedence: anInteger	precedence := anInteger</body><body package="SmaCC Development" selector="productionsDo:">productionsDo: aBlock</body><body package="SmaCC Development" selector="regularExpression">regularExpression	^nil</body><body package="SmaCC Development" selector="safeMethodName">safeMethodName	^self unsafeMethodName collect: [:each | each isAlphaNumeric ifTrue: [each] ifFalse: [$_]]</body><body package="SmaCC Development" selector="size">size	^0</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream 	aStream nextPutAll: name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>testing</category><body package="SmaCC Development" selector="isStartingSymbol">isStartingSymbol	^false</body><body package="SmaCC Development" selector="isTerminal">isTerminal	^self subclassResponsibility</body><body package="SmaCC Development" selector="requiresNodeType">requiresNodeType	self productionsDo: [:each | each hasNodeClassDefinition ifTrue: [^true]].	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	firstTerminals := Set new</body><body package="SmaCC Development" selector="name:">name: aString	name := aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>variables</category><body package="SmaCC Development" selector="computeVariableDefinitions">computeVariableDefinitions	| variableCollections |	variableCollections := OrderedCollection new.	self productionsDo: [:each | variableCollections add: each variableDefinitions].	variableDefinitions := self class mergeOrderedVariableDefinitions: variableCollections.	SmaCCVariableDefinition assignIndices: variableDefinitions.	^variableDefinitions</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="name:">name: aString 	^(self new)		name: aString;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol class</class-id> <category>variables</category><body package="SmaCC Development" selector="mergeOrderedVariableDefinitions:">mergeOrderedVariableDefinitions: newVariableDefinitions	| result |	result := OrderedCollection new.	newVariableDefinitions do: [:collection | self mergeVariableDefinitions: collection into: result].	^result</body><body package="SmaCC Development" selector="mergeVariableDefinitions:into:">mergeVariableDefinitions: collection into: result	collection		do:			[:each | 			| variable |			variable := result detect: [:def | def variableName = each variableName] ifNone: [result add: each copy].			each getterMethodName notNil ifTrue: [variable getterMethodName: each getterMethodName].			each setterMethodName notNil ifTrue: [variable setterMethodName: each setterMethodName].			each isCollection ifTrue: [variable isCollection: true]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNonTerminalSymbol</class-id> <category>testing</category><body package="SmaCC Development" selector="isEmpty">isEmpty	^productions isEmpty</body><body package="SmaCC Development" selector="isTerminal">isTerminal	^false</body><body package="SmaCC Development" selector="returnsVariableCollection">returnsVariableCollection	^productions anySatisfy: [:each | each returnsVariableCollection]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNonTerminalSymbol</class-id> <category>accessing</category><body package="SmaCC Development" selector="addProduction:">addProduction: aSmaCCRHS	productions add: aSmaCCRHS.	aSmaCCRHS symbol: self</body><body package="SmaCC Development" selector="calculateFirstTerminals">calculateFirstTerminals	| initialSize |	initialSize := firstTerminals size.	productions isEmpty ifTrue: [firstTerminals add: grammar emptySymbol] ifFalse: [productions do: [:each | firstTerminals addAll: each firstTerminals]].	^initialSize ~= firstTerminals size</body><body package="SmaCC Development" selector="modelTypes:">modelTypes: anIdentitySet	| types |	(anIdentitySet includes: self) ifTrue: [^#()].	anIdentitySet add: self.	types := Set new.	productions do: [:each | types addAll: (each modelTypes: anIdentitySet)].	anIdentitySet remove: self.	^types</body><body package="SmaCC Development" selector="positionOf:">positionOf: aSmaCCRHS	^productions indexOf: aSmaCCRHS</body><body package="SmaCC Development" selector="productionsDo:">productionsDo: aBlock	productions do: aBlock</body><body package="SmaCC Development" selector="size">size	^productions size</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNonTerminalSymbol</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	productions := OrderedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>converting</category><body package="SmaCC Development" selector="asDFA">asDFA	| new |	new := (SmaCCNFAtoDFA convertToDFA: self asNFAWithoutEpsilonTransitions)		startingNodeWithoutUnnecessaryDefaultTransition.	new removeDuplicateNodes.	new orderNodes.	^new</body><body package="SmaCC Development" selector="asNFAWithoutEpsilonTransitions">asNFAWithoutEpsilonTransitions	^SmaCCEpsilonRemoval removeEpsilonEdgesFrom: self</body><body package="SmaCC Development" selector="orderNodes">orderNodes	self orderNodesWithId: NextId map: Dictionary new</body><body package="SmaCC Development" selector="orderNodesWithId:map:">orderNodesWithId: anInteger map: aDictionary	anInteger &lt;= id ifTrue: [^self].	id := aDictionary at: id ifAbsentPut: [self getId].	self sortedTransitions do: [:each | each to orderNodesWithId: anInteger map: aDictionary]</body><body package="SmaCC Development" selector="sortedTransitions">sortedTransitions	^transitions asSortedCollection: [:a :b | a &lt;= b]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>comparing</category><body package="SmaCC Development" selector="&lt;=">&lt;= aSmaCCNode	^self id &lt;= aSmaCCNode id</body><body package="SmaCC Development" selector="=">= anObject	^self class = anObject class and: [self id = anObject id]</body><body package="SmaCC Development" selector="hash">hash	^id bitShift: 4</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>testing</category><body package="SmaCC Development" selector="hasSimpleLoop">hasSimpleLoop	^transitions anySatisfy: [:each | each to = self]</body><body package="SmaCC Development" selector="isTerminalNode">isTerminalNode	^transitions isEmpty or: [transitions size = 1 and: [self hasSimpleLoop]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>edges</category><body package="SmaCC Development" selector="addEdgeTo:">addEdgeTo: aSmaCCNode	transitions add: (SmaCCEdge to: aSmaCCNode on: nil)</body><body package="SmaCC Development" selector="addEdgeTo:onCharacters:">addEdgeTo: aSmaCCNode onCharacters: characterCollection	transitions add: (SmaCCCharacterEdge to: aSmaCCNode on: characterCollection)</body><body package="SmaCC Development" selector="addEdgeTo:onStates:">addEdgeTo: aSmaCCNode onStates: symbolCollection	transitions add: (SmaCCStateEdge to: aSmaCCNode on: symbolCollection)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="action:">action: anObject	anObject isNil ifTrue: [^self].	action := anObject isSymbol ifTrue: [anObject] ifFalse: [SortedCollection with: anObject]</body><body package="SmaCC Development" selector="getId">getId	^NextId := NextId + 1</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	id := self getId.	transitions := SortedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>accessing</category><body package="SmaCC Development" selector="action">action	^action</body><body package="SmaCC Development" selector="addActions:">addActions: aCollection	aCollection isNil ifTrue: [^self].	action isNil ifTrue: [^action := aCollection copy].	action isSymbol ifTrue: [^self].	aCollection isSymbol ifTrue: [^action := aCollection].	aCollection do: [:each | (action includes: each) ifFalse: [action add: each]]</body><body package="SmaCC Development" selector="allStates">allStates	| nodes |	nodes := Set new.	self allStatesInto: nodes.	^nodes</body><body package="SmaCC Development" selector="allStatesInto:">allStatesInto: aSet	(aSet includes: self) ifTrue: [^self].	aSet add: self.	transitions do: [:each | each to allStatesInto: aSet]</body><body package="SmaCC Development" selector="asDOTstring">asDOTstring	| nodeStream mapStream |	nodeStream := WriteStream on: String new.	nodeStream		nextPutAll: 'digraph finite_state_machine {	rankdir=LR;	size="100,100"';		cr.	mapStream := WriteStream on: String new.	self allStates do: 			[:each | 			nodeStream				nextPutAll: 'node [ style=filled, shape = circle, fillcolor = ';				nextPutAll: (each action notNil ifTrue: ['green'] ifFalse: ['white']);				nextPutAll: '];';				nextPutAll: each id printString;				nextPut: $;;				cr.			each transitions do: 					[:trans | 					| edge |					mapStream						nextPutAll: each id printString;						nextPutAll: ' -&gt; ';						nextPutAll: trans to id printString;						nextPutAll: '[ label = "'.					edge := trans edgeLabel displayString.					edge size &gt; 100 ifTrue: [edge := '...'].					mapStream						nextPutAll: edge;						nextPutAll: '"];';						cr]].	mapStream nextPut: $}.	^nodeStream contents , mapStream contents</body><body package="SmaCC Development" selector="groupedTransitions">groupedTransitions	^transitions		inject: OrderedCollection new		into:			[:sum :each | 			(sum				detect: [:edgeCollection | edgeCollection first canMergeWith: each]				ifNone: [sum add: OrderedCollection new]) add: each.			sum]</body><body package="SmaCC Development" selector="id">id	^id</body><body package="SmaCC Development" selector="mergeTransitions">mergeTransitions	self groupedTransitions		do:			[:edges | 			| toMap |			toMap := Dictionary new.			edges				do:					[:each | 					(toMap includesKey: each to)						ifTrue:							[(toMap at: each to) mergeWith: each.							transitions remove: each]						ifFalse: [toMap at: each to put: each]]]</body><body package="SmaCC Development" selector="mergeWith:">mergeWith: aSmaCCNode	id := aSmaCCNode id.	transitions := aSmaCCNode transitions.	action := aSmaCCNode action</body><body package="SmaCC Development" selector="removeDuplicateNodes">removeDuplicateNodes	^SmaCCDuplicateNodeEliminator removeDuplicateNodesIn: self</body><body package="SmaCC Development" selector="startingNodeWithoutUnnecessaryDefaultTransition">startingNodeWithoutUnnecessaryDefaultTransition	| edge |	self transitions size = 1 ifFalse: [^self].	edge := self transitions first.	(edge includes: #default) ifTrue: [^edge to].	^self</body><body package="SmaCC Development" selector="transitions">transitions	^transitions</body><body package="SmaCC Development" selector="transitions:">transitions: aCollection	transitions size		to: 1		by: -1		do: [:i | transitions removeAtIndex: i].	transitions addAll: aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>copying</category><body package="SmaCC Development" selector="shallowCopy">shallowCopy	| copy |	copy := self class new.	copy action: action.	^copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>simulating</category><body package="SmaCC Development" selector="simulate:">simulate: aStream	| char |	aStream atEnd ifTrue: [^action].	char := aStream next.	transitions do: [:each | (each includes: char) ifTrue: [^each to simulate: aStream]].	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: id printString;		nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>compiling-scanner</category><body package="SmaCC Development" selector="actionForSpecificRegularExpression:">actionForSpecificRegularExpression: aSmaCCRegularExpression	| matchedAction strings |	strings := aSmaCCRegularExpression possibleMatches.	matchedAction := self simulate: (ReadStream on: strings first).	strings do: [:each | matchedAction = (self simulate: (ReadStream on: each)) ifFalse: [^nil]].	^matchedAction</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode class</class-id> <category>class initialization</category><body package="SmaCC Development" selector="initialize">initialize	NextId := 0</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerDefinition</class-id> <category>testing</category><body package="SmaCC Development" selector="includesTokenNamed:">includesTokenNamed: aString	^tokens includesKey: aString</body><body package="SmaCC Development" selector="isExcludeState:">isExcludeState: aSymbol	^excludeStates includes: aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerDefinition</class-id> <category>accessing</category><body package="SmaCC Development" selector="addExcludeState:">addExcludeState: aSymbol	excludeStates add: aSymbol.	self addState: aSymbol</body><body package="SmaCC Development" selector="addState:">addState: aSymbol	states add: aSymbol</body><body package="SmaCC Development" selector="addToken:withName:">addToken: aSmaCCRENode withName: aString	tokens at: aString put: aSmaCCRENode</body><body package="SmaCC Development" selector="defaultState">defaultState	^#default</body><body package="SmaCC Development" selector="nonExcludeStates">nonExcludeStates	| nonExcludeStates |	nonExcludeStates := states reject: [:each | self isExcludeState: each].	nonExcludeStates add: self defaultState.	^nonExcludeStates</body><body package="SmaCC Development" selector="states">states	^states</body><body package="SmaCC Development" selector="tokenNamed:">tokenNamed: aString	^tokens at: aString</body><body package="SmaCC Development" selector="tokenNamed:ifAbsentPut:">tokenNamed: aString ifAbsentPut: aBlock 	^tokens at: aString ifAbsentPut: aBlock</body><body package="SmaCC Development" selector="tokens">tokens	^tokens</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerDefinition</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	tokens := Dictionary new.	states := Set with: self defaultState.	excludeStates := Set new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerDefinition class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction</class-id> <category>testing</category><body package="SmaCC Development" selector="isAmbiguous">isAmbiguous	^false</body><body package="SmaCC Development" selector="isReduce">isReduce	^false</body><body package="SmaCC Development" selector="isReject">isReject	^false</body><body package="SmaCC Development" selector="isShift">isShift	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="id">id	^self subclassResponsibility</body><body package="SmaCC Development" selector="lr1Item">lr1Item	^self subclassResponsibility</body><body package="SmaCC Development" selector="precedence">precedence	^self lr1Item precedence</body><body package="SmaCC Development" selector="preferredAction">preferredAction	^self</body><body package="SmaCC Development" selector="rhs">rhs	^self lr1Item rhs</body><body package="SmaCC Development" selector="size">size	^self rhs size</body><body package="SmaCC Development" selector="symbol">symbol	^self rhs productionSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= anObject	^self class = anObject class and: [self symbol = anObject symbol and: [self rhs = anObject rhs]]</body><body package="SmaCC Development" selector="hash">hash	^self symbol hash bitXor: self rhs hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:prefer:">mergeWith: aSmaCCAction prefer: aClass	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction</class-id> <category>error handling</category><body package="SmaCC Development" selector="signalAllWarnings">signalAllWarnings</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPrimitiveAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="lr1Item">lr1Item	^lr1Item</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPrimitiveAction</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="lr1Item:">lr1Item: aSmaCCLR1Item	lr1Item := aSmaCCLR1Item</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPrimitiveAction class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="item:">item: aSmaCCLR1Item	^(self new)		lr1Item: aSmaCCLR1Item;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id> <category>testing</category><body package="SmaCC Development" selector="isShift">isShift	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="id">id	^2r01</body></methods><methods><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:prefer:">mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isShift ifTrue: [^self].	aSmaCCAction isReduce ifTrue: [^self mergeWithReduceAction: aSmaCCAction prefer: aClass].	^aSmaCCAction mergeWith: self prefer: aClass</body><body package="SmaCC Development" selector="mergeWithReduceAction:prefer:">mergeWithReduceAction: aSmaCCAction prefer: aClass	| result |	(self precedence isNil or: [aSmaCCAction precedence isNil])		ifTrue:			[^(SmaCCAmbiguousAction new)				addAction: self;				addAction: aSmaCCAction;				yourself].	result := self.	self precedence &lt; aSmaCCAction precedence ifTrue: [result := aSmaCCAction].	self precedence = aSmaCCAction precedence		ifTrue:			[aSmaCCAction class = aClass ifTrue: [result := aSmaCCAction].			aClass = SmaCCRejectAction ifTrue: [result := SmaCCRejectAction item: self lr1Item]].	^(SmaCCPreferredCompositeAction new)		addAction: self;		addAction: aSmaCCAction;		preferredAction: result;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class name;		nextPutAll: '-class(';		nextPutAll: self name;		nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id> <category>accessing-hierarchy</category><body package="SmaCC Development" selector="addSubclass:">addSubclass: aSmaCCClassDefinition 	subclasses add: aSmaCCClassDefinition</body><body package="SmaCC Development" selector="commonSuperclass:">commonSuperclass: aSmaCCClassDefinition	(aSmaCCClassDefinition hierarchyIncludes: self) ifTrue: [^self].	superclass isNil ifTrue: [^nil].	^superclass commonSuperclass: aSmaCCClassDefinition</body><body package="SmaCC Development" selector="hierarchyCount">hierarchyCount	^superclass isNil ifTrue: [0] ifFalse: [superclass hierarchyCount + 1]</body><body package="SmaCC Development" selector="removeSubclass:">removeSubclass: aSmaCCClassDefinition	subclasses remove: aSmaCCClassDefinition ifAbsent: []</body><body package="SmaCC Development" selector="subclasses">subclasses	^subclasses</body><body package="SmaCC Development" selector="withAllSubclasses">withAllSubclasses	| classes index |	classes := OrderedCollection with: self.	index := 1.	[index &lt;= classes size]		whileTrue:			[classes addAll: (classes at: index) subclasses.			index := index + 1].	^classes</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id> <category>private</category><body package="SmaCC Development" selector="rootClassName">rootClassName	^Object fullName</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id> <category>accessing</category><body package="SmaCC Development" selector="beRoot">beRoot	isRoot := true</body><body package="SmaCC Development" selector="codeGenerator">codeGenerator	^grammar codeGenerator</body><body package="SmaCC Development" selector="fullName">fullName	^self codeGenerator namespaceName , self name</body><body package="SmaCC Development" selector="modelClass">modelClass	^class</body><body package="SmaCC Development" selector="name">name	^name</body><body package="SmaCC Development" selector="superclass">superclass	^superclass</body><body package="SmaCC Development" selector="superclassName">superclassName	^self isRoot ifTrue: [self rootClassName] ifFalse: [superclass fullName]</body><body package="SmaCC Development" selector="temporaryVariableName">temporaryVariableName	^self temporaryNameFor: self name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="grammar:">grammar: aSmaCCGrammar	grammar := aSmaCCGrammar</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	isRoot := false.	subclasses := OrderedCollection new</body><body package="SmaCC Development" selector="modelClass:">modelClass: aRBClass	class := aRBClass</body><body package="SmaCC Development" selector="name:">name: anObject	name := anObject</body><body package="SmaCC Development" selector="superclass:">superclass: anObject	superclass notNil ifTrue: [superclass removeSubclass: self].	superclass := anObject.	superclass notNil ifTrue: [superclass addSubclass: self]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id> <category>compiling</category><body package="SmaCC Development" selector="compileMethodsAndVariables">compileMethodsAndVariables</body><body package="SmaCC Development" selector="temporaryNameFor:">temporaryNameFor: fullName	^(fullName first isVowel ifTrue: ['an'] ifFalse: ['a']) , fullName</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition</class-id> <category>testing</category><body package="SmaCC Development" selector="hierarchyIncludes:">hierarchyIncludes: aSmaCCClassDefinition	^self = aSmaCCClassDefinition or: [superclass notNil and: [superclass hierarchyIncludes: aSmaCCClassDefinition]]</body><body package="SmaCC Development" selector="isRoot">isRoot	^isRoot</body><body package="SmaCC Development" selector="isSortedBefore:">isSortedBefore: aSmaCCClassDefinition	^self hierarchyCount &lt; aSmaCCClassDefinition hierarchyCount		or:			[self hierarchyCount = aSmaCCClassDefinition hierarchyCount				and: [self name &lt; aSmaCCClassDefinition name]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCClassDefinition class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVisitorClassDefinition</class-id> <category>compiling</category><body package="SmaCC Development" selector="compileMethodsAndVariables">compileMethodsAndVariables	nodeClassDefinitions do: [:each | self compileVisitMethodFor: each].	self codeGenerator compileAcceptNodeMethodFor: self rootNode: grammar rootDefinition</body><body package="SmaCC Development" selector="compileVisitMethodFor:">compileVisitMethodFor: aSmaCCNodeClassDefinition	self codeGenerator compileVisitMethodFor: aSmaCCNodeClassDefinition visitor: self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVisitorClassDefinition</class-id> <category>accessing</category><body package="SmaCC Development" selector="name">name	^self modelClass name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVisitorClassDefinition</class-id> <category>private</category><body package="SmaCC Development" selector="rootClassName">rootClassName	^SmaCCParseNodeVisitor fullName</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVisitorClassDefinition</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="nodeClassDefinitions:">nodeClassDefinitions: aCollection	nodeClassDefinitions := aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVisitorClassDefinition class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="forClassDefinitions:">forClassDefinitions: aCollection 	^(self new)		nodeClassDefinitions: aCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSet</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	characters := ByteArray new: 16r10000 / 8.	objects := Set new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSet</class-id> <category>enumerating</category><body package="SmaCC Development" selector="do:">do: aBlock	objects do: aBlock.	characters		keysAndValuesDo:			[:key :value | 			1				to: 8				do:					[:j | 					((value bitShift: 1 - j) bitAnd: 1) = 1						ifTrue: [aBlock value: (Character value: (key - 1) * 8 + j - 1)]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSet</class-id> <category>adding</category><body package="SmaCC Development" selector="add:">add: newObject	^(newObject isKindOf: Character)		ifTrue:			[| index mask |			index := newObject asInteger // 8 + 1.			mask := 1 bitShift: newObject asInteger \\ 8.			characters at: index put: ((characters at: index) bitOr: mask).			newObject]		ifFalse: [objects add: newObject]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSet</class-id> <category>removing</category><body package="SmaCC Development" selector="remove:ifAbsent:">remove: oldObject ifAbsent: aBlock	(oldObject isKindOf: Character)		ifTrue:			[| index mask |			index := oldObject asInteger // 8 + 1.			mask := 1 bitShift: oldObject asInteger \\ 8.			((characters at: index) bitAnd: mask) = mask				ifTrue:					[characters at: index put: ((characters at: index) bitXor: mask).					^oldObject]				ifFalse: [^aBlock value]]		ifFalse: [^objects remove: oldObject ifAbsent: aBlock]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSet</class-id> <category>testing</category><body package="SmaCC Development" selector="includes:">includes: anObject	^(anObject isKindOf: Character)		ifTrue:			[| index mask |			index := anObject asInteger // 8 + 1.			mask := 1 bitShift: anObject asInteger \\ 8.			^((characters at: index) bitAnd: mask) = mask]		ifFalse: [objects includes: anObject]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSet class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>testing</category><body package="SmaCC Development" selector="canMergeWith:">canMergeWith: aSmaCCEdge 	^self class = aSmaCCEdge class</body><body package="SmaCC Development" selector="does:include:">does: aSequenceableCollection include: anObject 	^aSequenceableCollection includes: anObject</body><body package="SmaCC Development" selector="includes:">includes: anObject	^self does: transitionObjects include: anObject</body><body package="SmaCC Development" selector="isCharacterTransition">isCharacterTransition	^false</body><body package="SmaCC Development" selector="isEmpty">isEmpty	^transitionObjects isEmpty</body><body package="SmaCC Development" selector="isEpsilonTransition">isEpsilonTransition	^transitionObjects isNil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>accessing</category><body package="SmaCC Development" selector="to">to	^toNode</body><body package="SmaCC Development" selector="transitionObjects">transitionObjects	^transitionObjects</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>comparing</category><body package="SmaCC Development" selector="&lt;=">&lt;= aSmaCCEdge 	^true</body><body package="SmaCC Development" selector="=">= aSmaCCEdge	^self class = aSmaCCEdge class		and: [self to = aSmaCCEdge to and: [self transitionObjects = aSmaCCEdge transitionObjects]]</body><body package="SmaCC Development" selector="hash">hash	^(self to hash bitShift: 14) bitXor: transitionObjects hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>printing</category><body package="SmaCC Development" selector="edgeLabel">edgeLabel	^transitionObjects isNil		ifTrue: ['epsilon']		ifFalse: [transitionObjects inject: '' into: [:sum :each | sum , each printString]]</body><body package="SmaCC Development" selector="printOn:">printOn: aStream	aStream		nextPutAll: '---';		nextPutAll: self edgeLabel;		nextPutAll: '---&gt;';		nextPutAll: toNode printString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:">mergeWith: aSmaCCEdge	transitionObjects := Array		withAll: (transitionObjects , aSmaCCEdge transitionObjects) asSet asSortedCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>private</category><body package="SmaCC Development" selector="remove:">remove: aCollection	transitionObjects := transitionObjects reject: [:each | self does: aCollection include: each]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="to:">to: aSmaCCNode	toNode := aSmaCCNode</body><body package="SmaCC Development" selector="to:on:">to: aSmaCCNode on: aStringOrNil	toNode := aSmaCCNode.	transitionObjects := aStringOrNil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>compiling</category><body package="SmaCC Development" selector="dispatchTo:seen:">dispatchTo: aSmaCCCodeGenerator seen: aCollection	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="to:on:">to: aSmaCCNode on: aCollectionOrNil 	| edge |	edge := self new.	edge to: aSmaCCNode on: aCollectionOrNil.	^edge</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterEdge</class-id> <category>printing</category><body package="SmaCC Development" selector="edgeLabel">edgeLabel	^transitionObjects</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterEdge</class-id> <category>testing</category><body package="SmaCC Development" selector="does:include:">does: aSequenceableCollection include: anObject	| start stop mid |	(anObject isKindOf: Character) ifFalse: [^false].	start := 1.	stop := aSequenceableCollection size.	stop = 0 ifTrue: [^false].	[mid := (start + stop) // 2.	mid = start]		whileFalse:			[(aSequenceableCollection at: mid) asInteger &lt; anObject asInteger				ifTrue: [start := mid]				ifFalse: [stop := mid]].	^(aSequenceableCollection at: start) = anObject or: [(aSequenceableCollection at: stop) = anObject]</body><body package="SmaCC Development" selector="isCharacterTransition">isCharacterTransition	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterEdge</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:">mergeWith: aSmaCCEdge	super mergeWith: aSmaCCEdge.	transitionObjects := String		withAll: (transitionObjects asSortedCollection: [:a :b | a asInteger &lt; b asInteger])</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterEdge</class-id> <category>comparing</category><body package="SmaCC Development" selector="&lt;=">&lt;= aSmaCCEdge	^self class = aSmaCCEdge class and: [self transitionObjects &lt;= aSmaCCEdge transitionObjects]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterEdge</class-id> <category>compiling</category><body package="SmaCC Development" selector="dispatchTo:seen:">dispatchTo: aSmaCCCodeGenerator seen: aCollection	^aSmaCCCodeGenerator acceptCharacterEdge: self seen: aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>copying</category><body package="SmaCC Development" selector="postCopy">postCopy	super postCopy.	states := Set new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="action:">action: aString	action := aString</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	states := Set new</body><body package="SmaCC Development" selector="position:">position: anInteger	position := anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>accessing</category><body package="SmaCC Development" selector="action">action	^action</body><body package="SmaCC Development" selector="position">position	^position</body><body package="SmaCC Development" selector="possibleMatches">possibleMatches	| matches |	matches := OrderedCollection new.	self possibleMatchesDo: [:each | matches add: each].	^matches</body><body package="SmaCC Development" selector="possibleMatchesDo:">possibleMatchesDo: aBlock	| stream |	stream := WriteStream with: String new.	self possibleMatchesDo: [aBlock value: stream contents] on: stream</body><body package="SmaCC Development" selector="possibleMatchesSize">possibleMatchesSize	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>testing</category><body package="SmaCC Development" selector="isKeywordLiteral">isKeywordLiteral	^self possibleMatchesSize &lt; 50		and:			[self possibleMatchesDo: [:each | each size &gt; 1 ifTrue: [^true]].			false]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>accessing-states</category><body package="SmaCC Development" selector="addState:">addState: aSymbol	states add: aSymbol</body><body package="SmaCC Development" selector="addStates:">addStates: aCollection	states addAll: aCollection</body><body package="SmaCC Development" selector="states">states	^states</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>constructing</category><body package="SmaCC Development" selector=",">, aSmaCCRegularExpressionNode	^SmaCCSequenceRENode nodes: (OrderedCollection with: self with: aSmaCCRegularExpressionNode)</body><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive</body><body package="SmaCC Development" selector="repeat">repeat	^SmaCCRepeatingRENode component: self</body><body package="SmaCC Development" selector="repeatFor:to:">repeatFor: minimum to: maximum	^SmaCCRepeatingRENode		component: self		minimum: minimum		maximum: maximum</body><body package="SmaCC Development" selector="repeatForAtLeast:">repeatForAtLeast: minimum	^SmaCCRepeatingRENode component: self minimum: minimum</body><body package="SmaCC Development" selector="|">| aSmaCCRegularExpressionNode	^SmaCCOrRENode nodes: (OrderedCollection with: self with: aSmaCCRegularExpressionNode)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>private</category><body package="SmaCC Development" selector="addStateTransitionsTo:">addStateTransitionsTo: aSmaCCNode	| endNode |	states isEmpty ifTrue: [^aSmaCCNode].	endNode := SmaCCNode new.	aSmaCCNode addEdgeTo: endNode onStates: states asSortedCollection asArray.	^endNode</body><body package="SmaCC Development" selector="asNFAStartingWith:">asNFAStartingWith: aSmaCCNode	^self subclassResponsibility</body><body package="SmaCC Development" selector="possibleMatchesDo:on:">possibleMatchesDo: aBlock on: aStream	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>converting</category><body package="SmaCC Development" selector="asDFA">asDFA	| startNode |	startNode := self asNFA.	^startNode asDFA</body><body package="SmaCC Development" selector="asNFA">asNFA	| startNode |	startNode := SmaCCNode new.	self asNFAStartingWith: startNode.	^startNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>accessing</category><body package="SmaCC Development" selector="possibleMatchesSize">possibleMatchesSize	^nodes inject: 0 into: [:sum :each | sum + each possibleMatchesSize]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>copying</category><body package="SmaCC Development" selector="postCopy">postCopy	super postCopy.	nodes := nodes copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>constructing</category><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive	nodes do: [:each | each makeCaseInsensitive]</body><body package="SmaCC Development" selector="|">| aSmaCCRegularExpressionNode	self action = aSmaCCRegularExpressionNode action ifFalse: [^super | aSmaCCRegularExpressionNode].	nodes add: aSmaCCRegularExpressionNode.	^self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>private</category><body package="SmaCC Development" selector="asNFAStartingWith:">asNFAStartingWith: aSmaCCNode	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	nodes		do:			[:each | 			| componentStart |			componentStart := SmaCCNode new.			startNode addEdgeTo: componentStart.			(each asNFAStartingWith: componentStart) addEdgeTo: endNode].	^endNode</body><body package="SmaCC Development" selector="possibleMatchesDo:on:">possibleMatchesDo: aBlock on: aStream	nodes		do:			[:each | 			| pos |			pos := aStream position.			each possibleMatchesDo: aBlock on: aStream.			aStream position: pos]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	aStream nextPut: $(.	nodes do: [:each | each printOn: aStream] separatedBy: [aStream nextPutAll: ' | '].	aStream nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="nodes:">nodes: aCollection	nodes := aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="nodes:">nodes: aCollection 	^(self new)		nodes: aCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceActionGenerator</class-id> <category>reduction table</category><body package="SmaCC Development" selector="compileAddToVariable:from:collection:">compileAddToVariable: aSmaCCVariableDefinition from: argument collection: isCollection	^aSmaCCVariableDefinition isCollection		ifTrue:			[| selector var |			var := rhs nodeType variableDefinitionNamed: aSmaCCVariableDefinition variableName.			selector := 'add'.			currentIndex &lt; index ifTrue: [selector := selector , 'First'].			selector := selector				, (var isBaseNodeType ifTrue: ['Node'] ifFalse: [var isBaseTokenType ifTrue: ['Token'] ifFalse: ['Object']]).			isCollection ifTrue: [selector := selector , 's'].			selector := (selector , ':to:') asSymbol.			generator				send: selector				to: 'result'				with: argument				with: (generator send: var getterMethodName to: 'result')]		ifFalse:			[generator				send: aSmaCCVariableDefinition setterMethodName				to: 'result'				with: argument]</body><body package="SmaCC Development" selector="connectChild">connectChild	| variableDefinition argument |	variableDefinition := rhs nodeType variableDefinitionNamed: variableName.	argument := generator cast: (generator argumentIndex: currentIndex) to: variableDefinition baseType name.	^self		compileAddToVariable: variableDefinition		from: argument		collection: false</body><body package="SmaCC Development" selector="generate:pullUp:on:">generate: aSmaCCRHS pullUp: anInteger on: aCodeGenerator	rhs := aSmaCCRHS.	index := anInteger.	generator := aCodeGenerator.	rhs collection		keysAndValuesDo:			[:i :each | 			currentIndex := i.			currentSymbol := each.			index ~= currentIndex				ifTrue:					[variableName := rhs variableNameForIndex: currentIndex.					variableName notNil ifTrue: [generator nextPutStatement: self connectChild] ifFalse: [self pullUpChildren]]]</body><body package="SmaCC Development" selector="getSubIndex:ofType:">getSubIndex: subIndex ofType: collectionType	^generator cast: (generator argumentIndex: currentIndex subIndex: subIndex) to: collectionType</body><body package="SmaCC Development" selector="pullUpChildren">pullUpChildren	currentSymbol returnsVariableCollection		ifTrue: [self pullUpVariableArray]		ifFalse:			[currentSymbol isNode				ifTrue: [self pullUpNodeVariables]				ifFalse: [currentSymbol modelType = (generator model classFor: Object) ifTrue: [self pullUpPotentialNodeVariables]]]</body><body package="SmaCC Development" selector="pullUpNodeVariables">pullUpNodeVariables	currentSymbol nodeType allVariableDefinitions		do:			[:var | 			| receiver declaration |			declaration := rhs nodeType variableDefinitionNamed: var variableName.			receiver := generator				cast: (generator argumentIndex: currentIndex)				to: (rhs collection at: currentIndex) modelType name.			generator				nextPutStatement:					(declaration isCollection						ifTrue:							[self								compileAddToVariable: var								from: (generator send: (rhs nodeType variableDefinitionNamed: var variableName) getterMethodName to: receiver)								collection: var isCollection]						ifFalse:							[generator								send: declaration setterMethodName								to: 'result'								with: (generator send: declaration getterMethodName to: receiver)])]</body><body package="SmaCC Development" selector="pullUpPotentialNodeVariables">pullUpPotentialNodeVariables	generator		nextPutStatement:			(generator				send: #addVariablesFrom:				to: 'result'				with: (generator argumentIndex: currentIndex))</body><body package="SmaCC Development" selector="pullUpVariableArray">pullUpVariableArray	currentSymbol variableDefinitions		keysAndValuesDo:			[:subIndex :var | 			generator				nextPutStatement:					(var isCollection						ifTrue:							[| collectionType |							collectionType := generator collectionType.							self								compileAddToVariable: var								from: (self getSubIndex: subIndex ofType: collectionType)								collection: true]						ifFalse:							[| nodesVariable |							nodesVariable := rhs nodeType variableDefinitionNamed: var variableName.							nodesVariable isCollection								ifTrue:									[self										compileAddToVariable: nodesVariable										from: (self getSubIndex: subIndex ofType: nodesVariable type name)										collection: false]								ifFalse:									[generator										send: nodesVariable setterMethodName										to: 'result'										with: (generator cast: (generator argumentIndex: currentIndex subIndex: subIndex) to: nodesVariable type name)]])]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceActionGenerator class</class-id> <category>accessing</category><body package="SmaCC Development" selector="generate:pullUp:on:">generate: aSmaCCRHS pullUp: anInteger on: aCodeGenerator 	^self new 		generate: aSmaCCRHS		pullUp: anInteger		on: aCodeGenerator</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableReduceCode</class-id> <category>private</category><body package="SmaCC Development" selector="basicModelTypes:">basicModelTypes: aSet	^Array with: (self model classFor: OrderedCollection)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableReduceCode</class-id> <category>accessing</category><body package="SmaCC Development" selector="source">source	^self codeGenerator variableArrayAction: rhs</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableReduceCode</class-id> <category>testing</category><body package="SmaCC Development" selector="returnsVariableCollection">returnsVariableCollection	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStartingSymbol</class-id> <category>accessing</category><body package="SmaCC Development" selector="asLRItemSet">asLRItemSet	| itemSet |	itemSet := self grammar newItemSet.	productions		do:			[:each | 			itemSet				add:					(SmaCCLR1Item						rhs: each						follow:							((SmaCCSymbolSet new)								add: grammar emptySymbol;								yourself))].	^itemSet</body><body package="SmaCC Development" selector="compileName">compileName	^(productions first at: 1) safeMethodName</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStartingSymbol</class-id> <category>testing</category><body package="SmaCC Development" selector="isStartingSymbol">isStartingSymbol	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeAction</class-id> <category>accessing-actions</category><body package="SmaCC Development" selector="actions">actions	^actions</body><body package="SmaCC Development" selector="addAction:">addAction: aSmaCCAction	actions add: aSmaCCAction</body><body package="SmaCC Development" selector="addActions:">addActions: aSmaCCActionCollection	actions addAll: aSmaCCActionCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeAction</class-id> <category>error handling</category><body package="SmaCC Development" selector="errorType">errorType	self subclassResponsibility</body><body package="SmaCC Development" selector="raiseXReduceNotification">raiseXReduceNotification	| stream |	stream := WriteStream with: String new.	actions do: 			[:each | 			stream nextPutAll: each lr1Item printString.			each == self preferredAction ifTrue: [stream nextPutAll: '	*****'].			stream cr].	stream cr.	self printPathOn: stream.	SmaCCCompilationNotification raiseRequestWith: stream contents		errorString: self errorType</body><body package="SmaCC Development" selector="signalAllWarnings">signalAllWarnings	self raiseXReduceNotification</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="id">id	^self preferredAction id</body><body package="SmaCC Development" selector="lr1Item">lr1Item	^self preferredAction lr1Item</body><body package="SmaCC Development" selector="preferredAction">preferredAction	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeAction</class-id> <category>printing</category><body package="SmaCC Development" selector="printPathOn:">printPathOn: aStream	self lr1Item path do: [:each | aStream nextPutAll: each name] separatedBy: [aStream space]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCompositeAction</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	actions := OrderedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id> <category>testing</category><body package="SmaCC Development" selector="isReduce">isReduce	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="id">id	^2r10</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:prefer:">mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isReduce ifTrue: [^self mergeWithReduceAction: aSmaCCAction].	^aSmaCCAction mergeWith: self prefer: aClass</body><body package="SmaCC Development" selector="mergeWithReduceAction:">mergeWithReduceAction: aSmaCCAction	self = aSmaCCAction ifTrue: [^self].	^(SmaCCAmbiguousAction new)		addAction: self;		addAction: aSmaCCAction;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="rhs:">rhs: aSmaCCRHS	^(self new)		rhs: aSmaCCRHS;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGraphAlgorithm</class-id> <category>nodes</category><body package="SmaCC Development" selector="createMergedNodeFrom:">createMergedNodeFrom: nodeCollection	| newNode |	newNode := SmaCCNode new.	self mergeTransitionsFrom: nodeCollection into: newNode.	self mergeActionsFrom: nodeCollection into: newNode.	^newNode</body><body package="SmaCC Development" selector="mergeActionsFrom:into:">mergeActionsFrom: nodeCollection into: aSmaCCNode	nodeCollection do: [:each | aSmaCCNode addActions: each action]</body><body package="SmaCC Development" selector="mergeTransitionsFrom:into:">mergeTransitionsFrom: nodeCollection into: aSmaCCNode	| transitions |	transitions := Set new.	nodeCollection do: [:each | each transitions do: [:edge | transitions add: edge copy]].	aSmaCCNode transitions: transitions.	aSmaCCNode mergeTransitions</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGraphAlgorithm class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>accessing</category><body package="SmaCC Development" selector="possibleMatchesSize">possibleMatchesSize	^nodes inject: 1 into: [:sum :each | sum * each possibleMatchesSize]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>copying</category><body package="SmaCC Development" selector="postCopy">postCopy	super postCopy.	nodes := nodes copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>private</category><body package="SmaCC Development" selector="asNFAStartingWith:">asNFAStartingWith: aSmaCCNode	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	(nodes inject: startNode into: [:sum :each | each asNFAStartingWith: sum]) addEdgeTo: endNode.	^endNode</body><body package="SmaCC Development" selector="possibleMatchesDo:on:">possibleMatchesDo: aBlock on: aStream	self		possibleMatchesDo: aBlock		on: aStream		startingAt: 1</body><body package="SmaCC Development" selector="possibleMatchesDo:on:startingAt:">possibleMatchesDo: aBlock on: aStream startingAt: anInteger	| node |	node := nodes at: anInteger.	nodes size = anInteger		ifTrue: [node possibleMatchesDo: aBlock on: aStream]		ifFalse:			[node				possibleMatchesDo:					[self						possibleMatchesDo: aBlock						on: aStream						startingAt: anInteger + 1]				on: aStream]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="nodes:">nodes: aCollection	nodes := aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	nodes do: [:each | each printOn: aStream] separatedBy: [aStream space]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>constructing</category><body package="SmaCC Development" selector=",">, aSmaCCRegularExpressionNode	self action = aSmaCCRegularExpressionNode action ifFalse: [^super , aSmaCCRegularExpressionNode].	nodes add: aSmaCCRegularExpressionNode.	^self</body><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive	nodes do: [:each | each makeCaseInsensitive]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="nodes:">nodes: aCollection 	^(self new)		nodes: aCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>private</category><body package="SmaCC Development" selector="annotateTokenVariables:">annotateTokenVariables: aBlock	collection		keysAndValuesDo:			[:i :each | 			(each isTerminal and: [(self variableNameForIndex: i) isNil])				ifTrue: [(aBlock value: each unsafeMethodName) ifNotNil: [:value | (variableNameMap at: value ifAbsentPut: [OrderedCollection new]) add: i]]]</body><body package="SmaCC Development" selector="basicModelTypesForVariable:into:seen:">basicModelTypesForVariable: aString into: productionTypes seen: aSet	(self symbolForVariableName: aString) ifNotNil: [:symbol | productionTypes addAll: symbol modelTypes].	self		unnamedSymbolsDo:			[:each | (each hasVariableNamed: aString) ifTrue: [productionTypes addAll: (each modelTypesForVariable: aString seen: aSet)]]</body><body package="SmaCC Development" selector="collection">collection	^collection</body><body package="SmaCC Development" selector="firstTerminals">firstTerminals	| items |	collection isEmpty ifTrue: [^Set with: self grammar emptySymbol].	items := Set new.	1		to: collection size		do:			[:index | 			items addAll: (collection at: index) firstTerminals.			(items includes: self grammar emptySymbol) ifTrue: [index &lt; collection size ifTrue: [items remove: self grammar emptySymbol]] ifFalse: [^items]].	^items</body><body package="SmaCC Development" selector="unnamedSymbolsDo:">unnamedSymbolsDo: aBlock	self variablesAndSymbolsDo: [:var :each | var isNil ifTrue: [aBlock value: each]]</body><body package="SmaCC Development" selector="variableNameForIndex:">variableNameForIndex: anInteger	variableNameMap keysAndValuesDo: [:key :value | (value includes: anInteger) ifTrue: [^key]].	^nil</body><body package="SmaCC Development" selector="variablesAndSymbolsDo:">variablesAndSymbolsDo: aBlock	collection		keysAndValuesDo: [:key :value | aBlock value: (self variableNameForIndex: key) value: value]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>accessing</category><body package="SmaCC Development" selector="add:">add: aSmaCCSymbol	collection add: aSmaCCSymbol</body><body package="SmaCC Development" selector="at:">at: anInteger	^collection at: anInteger</body><body package="SmaCC Development" selector="do:">do: aBlock	collection do: aBlock</body><body package="SmaCC Development" selector="modelTypes:">modelTypes: anIdentitySet	^reduceAction modelTypes: anIdentitySet</body><body package="SmaCC Development" selector="nameLastItem:">nameLastItem: aString	(variableNameMap at: aString ifAbsentPut: [OrderedCollection new]) add: collection size</body><body package="SmaCC Development" selector="nodeClassDefinition">nodeClassDefinition	^nodeClassDefinition</body><body package="SmaCC Development" selector="nodeClassDefinition:">nodeClassDefinition: aSmaCCNodeClassDefinition	nodeClassDefinition := aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="productionSymbol">productionSymbol	^productionSymbol</body><body package="SmaCC Development" selector="size">size	^collection size</body><body package="SmaCC Development" selector="symbolForVariableName:">symbolForVariableName: aString	| index |	index := self indexOfVariable: aString.	index isNil ifTrue: [^nil].	^self at: index</body><body package="SmaCC Development" selector="variableDefinitions:">variableDefinitions: aCollection	variableDefinitions := aCollection.	SmaCCVariableDefinition assignIndices: variableDefinitions</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= aSmaCCRHS	^self class = aSmaCCRHS class and: [collection = aSmaCCRHS collection]</body><body package="SmaCC Development" selector="hash">hash	^self class hash bitXor: (collection hash bitShift: 14)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>variables</category><body package="SmaCC Development" selector="indexOfVariable:">indexOfVariable: aString	^(variableNameMap at: aString ifAbsent: [^nil]) first</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>testing</category><body package="SmaCC Development" selector="hasNamedVariable">hasNamedVariable	^variableNameMap notEmpty</body><body package="SmaCC Development" selector="hasNodeClassDefinition">hasNodeClassDefinition	^self nodeClassDefinition notNil</body><body package="SmaCC Development" selector="hasReduceAction">hasReduceAction	^reduceAction hasReduceAction</body><body package="SmaCC Development" selector="locallyDefinesVariable:">locallyDefinesVariable: aString	^(self indexOfVariable: aString) notNil</body><body package="SmaCC Development" selector="returnsVariableCollection">returnsVariableCollection	^reduceAction returnsVariableCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	^collection do: [:each | each printOn: aStream] separatedBy: [aStream space]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>reduce actions</category><body package="SmaCC Development" selector="componentIndex">componentIndex	collection		keysAndValuesDo:			[:index :each | ((self variableNameForIndex: index) isNil and: [each isSubtypeOf: self]) ifTrue: [^index]].	^0</body><body package="SmaCC Development" selector="reduceAction">reduceAction	^reduceAction</body><body package="SmaCC Development" selector="reduceAction:">reduceAction: aSmaCCReduceCode	reduceAction := aSmaCCReduceCode</body><body package="SmaCC Development" selector="reduceActionSource:">reduceActionSource: aString	reduceAction := SmaCCSourceReduceCode onRHS: self source: aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	collection := OrderedCollection new.	reduceAction := SmaCCDefaultReduceCode onRHS: self.	variableNameMap := Dictionary new</body><body package="SmaCC Development" selector="symbol:">symbol: aSmaCCNonTerminalSymbol	productionSymbol := aSmaCCNonTerminalSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>accessing</category><body package="SmaCC Development" selector="add:">add: aSmaCCSymbol	(symbols includes: aSmaCCSymbol) ifTrue: [^self].	symbols add: aSmaCCSymbol.	self changed</body><body package="SmaCC Development" selector="addAll:">addAll: aCollection	| oldSize |	oldSize := symbols size.	symbols addAll: aCollection.	oldSize ~= symbols size ifTrue: [self changed]</body><body package="SmaCC Development" selector="addComponent:">addComponent: aSmaCCSymbolSet	(aSmaCCSymbolSet = self or: [components includes: aSmaCCSymbolSet]) ifTrue: [^self].	components add: aSmaCCSymbolSet.	aSmaCCSymbolSet addDependent: self.	self addAll: aSmaCCSymbolSet symbols</body><body package="SmaCC Development" selector="addComponentsFrom:">addComponentsFrom: aSmaCCSymbolSet	aSmaCCSymbolSet components do: [:each | self addComponent: each]</body><body package="SmaCC Development" selector="baseOn:">baseOn: aSmaCCSymbolSet	self addComponent: aSmaCCSymbolSet.	self addAll: aSmaCCSymbolSet symbols</body><body package="SmaCC Development" selector="components">components	^components</body><body package="SmaCC Development" selector="mergeWith:">mergeWith: aSmaCCSymbolSet	self addAll: aSmaCCSymbolSet symbols.	self addComponentsFrom: aSmaCCSymbolSet</body><body package="SmaCC Development" selector="size">size	^symbols size</body><body package="SmaCC Development" selector="symbols">symbols	^symbols</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	(symbols asSortedCollection: [:a :b | a name &lt; b name])		do: [:each | aStream nextPutAll: each printString]		separatedBy: [aStream space]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>updating</category><body package="SmaCC Development" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender	(components includes: aSender) ifTrue: [self addAll: aSender symbols]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>testing</category><body package="SmaCC Development" selector="allSatisfy:">allSatisfy: aBlock	^symbols allSatisfy: aBlock</body><body package="SmaCC Development" selector="includes:">includes: aSmaCCSymbol	^symbols includes: aSmaCCSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	symbols := Set new.	components := Set new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="basedOn:">basedOn: aSmaCCSymbolSet 	^(self new)		baseOn: aSmaCCSymbolSet;		yourself</body><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser</class-id> <category>generated-reduction actions</category><body package="SmaCC Development" selector="reduceActionForAnnotateTokens1:">reduceActionForAnnotateTokens1: nodes	^grammar annotateTokens: true</body><body package="SmaCC Development" selector="reduceActionForAttributesLine1:">reduceActionForAttributesLine1: nodes	^(grammar classNamed: (nodes at: 2) value asSymbol) extraAttributes: ((nodes at: 4) collect: [:each | SmaCCVariableDefinition variableName: each])</body><body package="SmaCC Development" selector="reduceActionForClassList1:">reduceActionForClassList1: nodes	^OrderedCollection new</body><body package="SmaCC Development" selector="reduceActionForClassList2:">reduceActionForClassList2: nodes	^(nodes at: 1)		add: (nodes at: 2) value asSymbol;		yourself</body><body package="SmaCC Development" selector="reduceActionForEndDirective1:">reduceActionForEndDirective1: nodes	^self state: #default</body><body package="SmaCC Development" selector="reduceActionForExcludeStates2:">reduceActionForExcludeStates2: nodes	^scannerDefinition addExcludeState: (nodes at: 2)</body><body package="SmaCC Development" selector="reduceActionForFile1:">reduceActionForFile1: nodes	^grammar		addExtraSymbols;		yourself</body><body package="SmaCC Development" selector="reduceActionForGLR1:">reduceActionForGLR1: nodes	^grammar isGLR: true</body><body package="SmaCC Development" selector="reduceActionForIdMethodLine1:">reduceActionForIdMethodLine1: nodes	(nodes at: 2) do: [:each | grammar makeTokenIdMethodFor: each].	^nil</body><body package="SmaCC Development" selector="reduceActionForIdTokens1:">reduceActionForIdTokens1: nodes	^OrderedCollection with: (nodes at: 1) value</body><body package="SmaCC Development" selector="reduceActionForIdTokens2:">reduceActionForIdTokens2: nodes	^(nodes at: 1)		add: (nodes at: 2) value;		yourself</body><body package="SmaCC Development" selector="reduceActionForIgnoreCase1:">reduceActionForIgnoreCase1: nodes	^grammar ignoreCase: true</body><body package="SmaCC Development" selector="reduceActionForIgnoredVariableList2:">reduceActionForIgnoredVariableList2: nodes	(nodes at: 1) add: (nodes at: 2) value.	^nodes at: 1</body><body package="SmaCC Development" selector="reduceActionForIgnoredVariables1:">reduceActionForIgnoredVariables1: nodes	^grammar ignoredVariables: (nodes at: 2)</body><body package="SmaCC Development" selector="reduceActionForLeftLine1:">reduceActionForLeftLine1: nodes	(nodes at: 2)		do:			[:each | 			grammar				leftPrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^nil</body><body package="SmaCC Development" selector="reduceActionForNonAssociativeLine1:">reduceActionForNonAssociativeLine1: nodes	(nodes at: 2)		do:			[:each | 			grammar				nonAssociativePrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^nil</body><body package="SmaCC Development" selector="reduceActionForParserRule1:">reduceActionForParserRule1: nodes	^nodes at: 1</body><body package="SmaCC Development" selector="reduceActionForParserRule2:">reduceActionForParserRule2: nodes	^self verifyCodeToken: (nodes at: 2) for: (nodes at: 1)</body><body package="SmaCC Development" selector="reduceActionForParserRule3:">reduceActionForParserRule3: nodes	^self createClass: (nodes at: 3) value asSymbol for: (nodes at: 1)</body><body package="SmaCC Development" selector="reduceActionForParserRule4:">reduceActionForParserRule4: nodes	^self createDefaultClassFor: (nodes at: 1)</body><body package="SmaCC Development" selector="reduceActionForParserRules1:">reduceActionForParserRules1: nodes	^(nodes at: 1)		add: (nodes at: 3);		yourself</body><body package="SmaCC Development" selector="reduceActionForPrefixLine1:">reduceActionForPrefixLine1: nodes	^grammar prefix: (nodes at: 2) value</body><body package="SmaCC Development" selector="reduceActionForProductionRule1:">reduceActionForProductionRule1: nodes	| symbol |	symbol := grammar nonTerminalSymbolNamed: (nodes at: 1) value.	(nodes at: 4) do: [:each | symbol addProduction: each].	self createDefaultClassesForSymbol: (nodes at: 1) value.	^symbol</body><body package="SmaCC Development" selector="reduceActionForRegex2:">reduceActionForRegex2: nodes	^(nodes at: 1) | (nodes at: 3)</body><body package="SmaCC Development" selector="reduceActionForRegex3:">reduceActionForRegex3: nodes	^(nodes at: 1) , (nodes at: 2)</body><body package="SmaCC Development" selector="reduceActionForRegexRule1:">reduceActionForRegexRule1: nodes	| symbol |	(nodes at: 4) position: (nodes at: 2) startPosition.	scannerDefinition addToken: (nodes at: 4) withName: (nodes at: 2) value.	symbol := grammar findSymbolNamed: (nodes at: 2) value ifAbsent: [nil].	symbol notNil ifTrue: [symbol regularExpression: (nodes at: 4)].	^nodes at: 4</body><body package="SmaCC Development" selector="reduceActionForRegexRule2:">reduceActionForRegexRule2: nodes	^(nodes at: 2)		addState: (nodes at: 1);		yourself</body><body package="SmaCC Development" selector="reduceActionForRegexTerm10:">reduceActionForRegexTerm10: nodes	^(nodes at: 1) repeatForAtLeast: 1</body><body package="SmaCC Development" selector="reduceActionForRegexTerm11:">reduceActionForRegexTerm11: nodes	^(nodes at: 1) repeatFor: 0 to: 1</body><body package="SmaCC Development" selector="reduceActionForRegexTerm12:">reduceActionForRegexTerm12: nodes	| readStream start stop |	readStream := ReadStream on: ((nodes at: 2) value copyFrom: 2 to: (nodes at: 2) value size - 1).	start := readStream upTo: $,.	stop := readStream upToEnd.	^(nodes at: 1) repeatFor: (start isEmpty ifTrue: [0] ifFalse: [start asNumber]) to: (stop isEmpty ifTrue: [1 bitShift: 31] ifFalse: [stop asNumber])</body><body package="SmaCC Development" selector="reduceActionForRegexTerm2:">reduceActionForRegexTerm2: nodes	^SmaCCCharacterRENode characters: (nodes at: 1) value</body><body package="SmaCC Development" selector="reduceActionForRegexTerm3:">reduceActionForRegexTerm3: nodes	^SmaCCCharacterRENode characters: self allCharacters</body><body package="SmaCC Development" selector="reduceActionForRegexTerm4:">reduceActionForRegexTerm4: nodes	^self nodeFor: (ReadStream on: ((nodes at: 1) value copyFrom: 2 to: (nodes at: 1) value size))</body><body package="SmaCC Development" selector="reduceActionForRegexTerm6:">reduceActionForRegexTerm6: nodes	^self parseCharacterBlock: (nodes at: 1)</body><body package="SmaCC Development" selector="reduceActionForRegexTerm7:">reduceActionForRegexTerm7: nodes	^(scannerDefinition tokenNamed: (nodes at: 1) value ifAbsentPut: [self generateImplicitToken: (nodes at: 1)]) copy</body><body package="SmaCC Development" selector="reduceActionForRegexTerm8:">reduceActionForRegexTerm8: nodes	^SmaCCSequenceRENode nodes: ((nodes at: 1) value asOrderedCollection collect: [:each | SmaCCCharacterRENode characters: (String with: each)])</body><body package="SmaCC Development" selector="reduceActionForRegexTerm9:">reduceActionForRegexTerm9: nodes	^(nodes at: 1) repeat</body><body package="SmaCC Development" selector="reduceActionForRightLine1:">reduceActionForRightLine1: nodes	(nodes at: 2)		do:			[:each | 			grammar				rightPrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^nil</body><body package="SmaCC Development" selector="reduceActionForRootClassLine1:">reduceActionForRootClassLine1: nodes	^(grammar classNamed: (nodes at: 2) value asSymbol) beRoot</body><body package="SmaCC Development" selector="reduceActionForRule1:">reduceActionForRule1: nodes	^grammar setStartSymbolIfNone: (nodes at: 1)</body><body package="SmaCC Development" selector="reduceActionForRule3:">reduceActionForRule3: nodes	^(nodes at: 1) states isEmpty ifTrue: [(nodes at: 1) addStates: scannerDefinition nonExcludeStates]</body><body package="SmaCC Development" selector="reduceActionForStartDirective1:">reduceActionForStartDirective1: nodes	^self state: #directives</body><body package="SmaCC Development" selector="reduceActionForStartProduction1:">reduceActionForStartProduction1: nodes	^self state: #parser</body><body package="SmaCC Development" selector="reduceActionForStartRegex1:">reduceActionForStartRegex1: nodes	^self state: #scanner</body><body package="SmaCC Development" selector="reduceActionForStartingTokens1:">reduceActionForStartingTokens1: nodes	^grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: (nodes at: 1) value)</body><body package="SmaCC Development" selector="reduceActionForStartingTokens2:">reduceActionForStartingTokens2: nodes	^grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: (nodes at: 2) value)</body><body package="SmaCC Development" selector="reduceActionForStates2:">reduceActionForStates2: nodes	^scannerDefinition addState: (nodes at: 2)</body><body package="SmaCC Development" selector="reduceActionForSuffixLine1:">reduceActionForSuffixLine1: nodes	^grammar suffix: (nodes at: 2) value</body><body package="SmaCC Development" selector="reduceActionForSuperclassLine1:">reduceActionForSuperclassLine1: nodes	^(nodes at: 4) do: [:each | (grammar classNamed: each) superclass: (grammar classNamed: (nodes at: 2) value asSymbol)]</body><body package="SmaCC Development" selector="reduceActionForSymbol1:">reduceActionForSymbol1: nodes	^(nodes at: 1) value asSymbol</body><body package="SmaCC Development" selector="reduceActionForTerm1:">reduceActionForTerm1: nodes	^grammar keywordTerminalNamed: (nodes at: 1) value</body><body package="SmaCC Development" selector="reduceActionForTerm2:">reduceActionForTerm2: nodes	^grammar		findSymbolNamed: (nodes at: 1) value		ifAbsentAdd:			[| node symbol |			symbol := grammar newTerminalSymbolNamed: (nodes at: 1) value.			(scannerDefinition includesTokenNamed: (nodes at: 1) value)				ifTrue: [symbol regularExpression: (scannerDefinition tokenNamed: (nodes at: 1) value)]				ifFalse:					[node := SmaCCGrammar implicitToken: (nodes at: 1) value.					node notNil						ifTrue:							[node addStates: scannerDefinition nonExcludeStates.							symbol regularExpression: node]].			symbol]</body><body package="SmaCC Development" selector="reduceActionForTerm3:">reduceActionForTerm3: nodes	^grammar nonTerminalSymbolNamed: (nodes at: 1) value</body><body package="SmaCC Development" selector="reduceActionForTerm4:">reduceActionForTerm4: nodes	^grammar errorSymbol</body><body package="SmaCC Development" selector="reduceActionForTerms1:">reduceActionForTerms1: nodes	^grammar newRHS</body><body package="SmaCC Development" selector="reduceActionForTerms2:">reduceActionForTerms2: nodes	^(nodes at: 1)		add: (nodes at: 2);		yourself</body><body package="SmaCC Development" selector="reduceActionForTerms3:">reduceActionForTerms3: nodes	^(nodes at: 1)		add: (nodes at: 2);		nameLastItem: ((nodes at: 3) value copyFrom: 2 to: (nodes at: 3) value size - 1);		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser</class-id> <category>private</category><body package="SmaCC Development" selector="capitalize:">capitalize: aString	| result |	result := aString copy.	result at: 1 put: result first asUppercase.	^result</body><body package="SmaCC Development" selector="charactersFor:in:">charactersFor: aStream in: aToken	| characters char endCharacters |	aStream atEnd ifTrue: [self reportCharacterBlockErrorForToken: aToken].	char := aStream next.	characters := char == $\		ifTrue: [(self nodeFor: aStream) characters]		ifFalse: [OrderedCollection with: char].	(characters size = 1 and: [aStream peekFor: $-]) ifFalse: [^characters].	endCharacters := self charactersFor: aStream in: aToken.	endCharacters size &gt; 1 ifTrue: [self reportCharacterBlockErrorForToken: aToken].	^(characters first asInteger to: endCharacters first asInteger)		collect: [:each | Character value: each]</body><body package="SmaCC Development" selector="createClass:for:">createClass: aSymbol for: aSmaCCRHS 	(grammar classNamed: aSymbol) addProduction: aSmaCCRHS.	^aSmaCCRHS</body><body package="SmaCC Development" selector="createDefaultClassFor:">createDefaultClassFor: aSmaCCRHS	defaultClasses add: aSmaCCRHS.	^aSmaCCRHS</body><body package="SmaCC Development" selector="createDefaultClassesForSymbol:">createDefaultClassesForSymbol: aString	| className index |	className := self capitalize: aString.	[index := className indexOf: $_.	index &gt; 0 and: [className size &gt; 1]]		whileTrue: [className := (className copyFrom: 1 to: index - 1) , (self capitalize: (className copyFrom: index + 1 to: className size))].	className := className asSymbol.	defaultClasses do: [:each | self createClass: className for: each].	defaultClasses := OrderedCollection new</body><body package="SmaCC Development" selector="generateImplicitToken:">generateImplicitToken: aSmaCCToken	| node |	node := SmaCCGrammar implicitToken: aSmaCCToken value.	node isNil		ifTrue:			[currentToken := aSmaCCToken.			self reportErrorMessage: 'Token not specified'].	^node</body><body package="SmaCC Development" selector="hexStringFrom:">hexStringFrom: aStream	^String with: (Character value: (self hexValueFrom: aStream))</body><body package="SmaCC Development" selector="hexValueFrom:">hexValueFrom: aStream	| char value count |	count := value := 0.	[aStream atEnd not		and:			[count &lt; 4				and:					[char := aStream peek.					(char between: $0 and: $9) or: [(char between: $A and: $F) or: [char between: $a and: $f]]]]]		whileTrue:			[count := count + 1.			value := value * 16 + aStream next digitValue].	^value</body><body package="SmaCC Development" selector="nodeFor:">nodeFor: aStream	| block char |	block := nil.	char := aStream next.	char == $f ifTrue: [^SmaCCCharacterRENode characters: self formFeedString].	char == $n ifTrue: [^SmaCCCharacterRENode characters: self newlineString].	char == $r ifTrue: [^SmaCCCharacterRENode characters: self carriageReturnString].	char == $t ifTrue: [^SmaCCCharacterRENode characters: self tabString].	char == $v ifTrue: [^SmaCCCharacterRENode characters: self verticalTabString].	char == $c		ifTrue: [^SmaCCCharacterRENode characters: (String with: (Character value: aStream next asInteger - $A asInteger))].	char == $x ifTrue: [^SmaCCCharacterRENode characters: (self hexStringFrom: aStream)].	char == $d ifTrue: [block := [:each | self isDigit: each]].	char == $D ifTrue: [block := [:each | (self isDigit: each) not]].	char == $s ifTrue: [block := [:each | self isWhitespace: each]].	char == $S ifTrue: [block := [:each | (self isWhitespace: each) not]].	char == $w ifTrue: [block := [:each | self isLetterOrDigit: each]].	char == $W ifTrue: [block := [:each | (self isLetterOrDigit: each) not]].	block isNil ifTrue: [^SmaCCCharacterRENode characters: (String with: char)].	^SmaCCCharacterRENode characters: (String withAll: (self allCharacters select: block))</body><body package="SmaCC Development" selector="parseCharacterBlock:">parseCharacterBlock: aToken	| characters aStream invert node |	aStream := ReadStream on: (aToken value copyFrom: 2 to: aToken value size - 1).	characters := OrderedCollection new.	invert := aStream peekFor: $^.	[aStream atEnd] whileFalse: [characters addAll: (self charactersFor: aStream in: aToken)].	node := SmaCCCharacterRENode characters: (String withAll: characters).	invert ifTrue: [node := SmaCCNotRENode on: node].	^node</body><body package="SmaCC Development" selector="reportCharacterBlockErrorForToken:">reportCharacterBlockErrorForToken: aToken	currentToken := aToken.	self reportErrorMessage: 'Invalid character block'</body><body package="SmaCC Development" selector="verifyCodeToken:for:">verifyCodeToken: codeToken for: aSmaCCRHS	| code |	code := codeToken value copyFrom: 2 to: codeToken value size - 1.	RBParser		parseExpression: code		onError:			[:string :position | 			currentToken := nil.			self position: codeToken startPosition + position.			self reportErrorMessage: string].	aSmaCCRHS reduceActionSource: code.	^aSmaCCRHS</body><body package="SmaCC Development" selector="whitespaceValues">whitespaceValues	^#[9 10 11 12 13 32]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="grammar:">grammar: aSmaCCGrammar	grammar := aSmaCCGrammar.	scannerDefinition := SmaCCScannerDefinition new.	grammar scannerDefinition: scannerDefinition</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	self grammar: SmaCCGrammar new.	defaultClasses := OrderedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser</class-id> <category>generated</category><body package="SmaCC Development" selector="reduceTable">reduceTable^#(	#(75 0 #reduceActionForStartRegex1:) 	#(71 0 #reduceActionForStartDirective1:) 	#(74 1 #reduceActionForSymbol1:) 	#(79 0 #reduceActionForStartProduction1:) 	#(52 1 #reduceFor:) 	#(52 1 #reduceActionForRule1:) 	#(57 1 #reduceFor:) 	#(55 1 #reduceActionForFile1:) 	#(52 1 #reduceActionForRule3:) 	#(57 2 #reduceFor:) 	#(86 2 #reduceActionForRegexRule2:) 	#(83 0 #reduceActionForTerms1:) 	#(66 0 #reduceFor:) 	#(53 0 #reduceFor:) 	#(45 1 #reduceActionForGLR1:) 	#(46 1 #reduceActionForIgnoreCase1:) 	#(48 1 #reduceActionForAnnotateTokens1:) 	#(73 1 #reduceFor:) 	#(70 0 #reduceActionForEndDirective1:) 	#(81 0 #reduceActionForEndDirective1:) 	#(80 1 #reduceFor:) 	#(82 1 #reduceActionForParserRule1:) 	#(68 2 #reduceFor:) 	#(51 2 #reduceFor:) 	#(64 2 #reduceActionForRootClassLine1:) 	#(60 2 #reduceActionForPrefixLine1:) 	#(59 2 #reduceActionForSuffixLine1:) 	#(65 1 #reduceActionForTerm4:) 	#(65 1 #reduceActionForTerm2:) 	#(65 1 #reduceActionForTerm3:) 	#(65 1 #reduceActionForTerm1:) 	#(50 2 #reduceActionForLeftLine1:) 	#(62 1 #reduceFor:) 	#(41 2 #reduceActionForRightLine1:) 	#(42 2 #reduceActionForNonAssociativeLine1:) 	#(67 1 #reduceActionForIdTokens1:) 	#(43 2 #reduceActionForIdMethodLine1:) 	#(69 1 #reduceActionForStartingTokens1:) 	#(87 2 #reduceFor:) 	#(72 1 #reduceActionForIdTokens1:) 	#(47 2 #reduceActionForIgnoredVariables1:) 	#(78 1 #reduceActionForRegexTerm7:) 	#(78 1 #reduceActionForRegexTerm8:) 	#(78 1 #reduceActionForRegexTerm2:) 	#(78 1 #reduceActionForRegexTerm4:) 	#(78 1 #reduceActionForRegexTerm6:) 	#(78 1 #reduceActionForRegexTerm3:) 	#(77 0 #reduceActionForEndDirective1:) 	#(76 1 #reduceActionForParserRule1:) 	#(82 2 #reduceActionForParserRule2:) 	#(83 2 #reduceActionForTerms2:) 	#(66 2 #reduceActionForStates2:) 	#(53 2 #reduceActionForExcludeStates2:) 	#(56 0 #reduceActionForClassList1:) 	#(58 0 #reduceActionForClassList1:) 	#(62 2 #reduceFor:) 	#(67 2 #reduceActionForIdTokens2:) 	#(69 2 #reduceActionForStartingTokens2:) 	#(72 2 #reduceActionForIgnoredVariableList2:) 	#(44 5 #reduceFor:) 	#(76 2 #reduceActionForRegex3:) 	#(78 2 #reduceActionForRegexTerm9:) 	#(78 2 #reduceActionForRegexTerm10:) 	#(78 2 #reduceActionForRegexTerm11:) 	#(78 2 #reduceActionForRegexTerm12:) 	#(80 3 #reduceActionForParserRules1:) 	#(49 6 #reduceActionForProductionRule1:) 	#(82 3 #reduceActionForParserRule4:) 	#(83 3 #reduceActionForTerms3:) 	#(78 3 #liftSecondValue:) 	#(76 3 #reduceActionForRegex2:) 	#(86 6 #reduceActionForRegexRule1:) 	#(82 4 #reduceActionForParserRule3:) 	#(63 5 #reduceActionForSuperclassLine1:) 	#(56 2 #reduceActionForClassList2:) 	#(61 5 #reduceActionForAttributesLine1:) 	#(58 2 #reduceActionForIdTokens2:)	).</body><body package="SmaCC Development" selector="transitionTable">transitionTable^#(#[1 0 6 0 25 0 9 0 26 0 10 0 32 0 13 0 44 0 17 0 49 0 21 0 52 0 25 0 55 0 29 0 57 0 33 0 71 0 37 0 74 0 41 0 75 0 45 0 86] #[1 0 14 0 25 0 14 0 26 0 18 0 31 0 49 0 79] #[0 0 22 0 25 0 26 0 32 0 84] #[0 0 26 0 25 0 26 0 32 0 84] #[0 0 30 0 25 0 26 0 32 0 84] #[0 0 0 0 84] #[1 0 6 0 25 0 9 0 26 0 10 0 32 0 13 0 44 0 17 0 49 0 53 0 52 0 33 0 71 0 37 0 74 0 41 0 75 0 34 0 84 0 45 0 86] #[0 0 57 0 32] #[1 0 6 0 25 0 61 0 26 0 37 0 74 0 41 0 75 0 65 0 86] #[0 0 69 0 25] #[0 0 38 0 25 0 26 0 32 0 84] #[0 0 73 0 31] #[0 0 42 0 25 0 26 0 32 0 84] #[1 0 77 0 8 0 81 0 9 0 85 0 10 0 89 0 11 0 93 0 12 0 97 0 13 0 101 0 14 0 105 0 15 0 109 0 16 0 113 0 17 0 117 0 18 0 121 0 19 0 125 0 20 0 129 0 21 0 133 0 22 0 137 0 23 0 141 0 41 0 145 0 42 0 149 0 43 0 153 0 45 0 157 0 46 0 161 0 47 0 165 0 48 0 169 0 50 0 173 0 51 0 177 0 59 0 181 0 60 0 185 0 61 0 189 0 63 0 193 0 64 0 197 0 68 0 201 0 73 0 205 0 87] #[0 0 14 0 25 0 26 0 33] #[0 0 46 0 25 0 26 0 32 0 84] #[0 0 209 0 31] #[1 0 50 0 1 0 50 0 7 0 50 0 25 0 50 0 26 0 50 0 27 0 50 0 29 0 50 0 33 0 50 0 39 0 213 0 80 0 217 0 82 0 221 0 83] #[1 0 54 0 26 0 54 0 33 0 225 0 66] #[1 0 58 0 26 0 58 0 33 0 229 0 53] #[0 0 233 0 26] #[0 0 237 0 26] #[0 0 241 0 26] #[0 0 245 0 26] #[0 0 249 0 26] #[1 0 253 0 7 1 1 0 25 1 5 0 26 1 9 0 27 1 13 0 62 1 17 0 65] #[1 0 253 0 7 1 1 0 25 1 5 0 26 1 9 0 27 1 21 0 62 1 17 0 65] #[1 0 253 0 7 1 1 0 25 1 5 0 26 1 9 0 27 1 25 0 62 1 17 0 65] #[1 1 29 0 25 1 33 0 67] #[1 1 37 0 26 1 41 0 69] #[0 0 62 0 33] #[0 0 66 0 33] #[1 1 45 0 26 1 49 0 72] #[0 0 70 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[0 0 74 0 33] #[1 0 78 0 33 1 53 0 70] #[0 0 74 0 33] #[1 1 57 0 2 1 61 0 25 1 65 0 26 1 69 0 32 1 73 0 34 1 77 0 35 1 81 0 37 1 85 0 38 1 89 0 76 1 93 0 78] #[1 1 97 0 1 0 82 0 33 1 101 0 81] #[0 0 86 0 1 0 33] #[1 0 90 0 1 0 253 0 7 1 1 0 25 1 5 0 26 1 9 0 27 1 105 0 29 0 90 0 33 1 109 0 39 1 113 0 65] #[1 0 61 0 26 0 94 0 33 1 117 0 74] #[1 0 61 0 26 0 98 0 33 1 121 0 74] #[0 0 102 0 33] #[0 1 125 0 2] #[0 1 129 0 2] #[0 0 106 0 33] #[0 0 110 0 33] #[0 0 114 0 1 0 7 0 25 0 26 0 27 0 29 0 30 0 33 0 39] #[0 0 118 0 1 0 7 0 25 0 26 0 27 0 29 0 30 0 33 0 39] #[0 0 122 0 1 0 7 0 25 0 26 0 27 0 29 0 30 0 33 0 39] #[0 0 126 0 1 0 7 0 25 0 26 0 27 0 29 0 30 0 33 0 39] #[1 0 253 0 7 1 1 0 25 1 5 0 26 1 9 0 27 0 130 0 33 1 133 0 65] #[0 0 134 0 7 0 25 0 26 0 27 0 33] #[1 0 253 0 7 1 1 0 25 1 5 0 26 1 9 0 27 0 138 0 33 1 133 0 65] #[1 0 253 0 7 1 1 0 25 1 5 0 26 1 9 0 27 0 142 0 33 1 133 0 65] #[0 0 146 0 25 0 33] #[1 1 137 0 25 0 150 0 33] #[0 0 154 0 26 0 33] #[1 1 141 0 26 0 158 0 33] #[0 0 162 0 26 0 33] #[1 1 145 0 26 0 166 0 33] #[0 1 149 0 33] #[1 1 57 0 2 1 61 0 25 1 65 0 26 1 69 0 32 1 73 0 34 1 77 0 35 1 81 0 37 1 85 0 38 1 153 0 76 1 93 0 78] #[0 0 170 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 0 174 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 0 178 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 0 182 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 0 186 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 0 178 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 0 190 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[1 1 157 0 1 1 57 0 2 1 61 0 25 1 65 0 26 1 69 0 32 0 194 0 33 1 73 0 34 1 77 0 35 1 81 0 37 1 85 0 38 1 161 0 77 1 165 0 78] #[1 0 198 0 1 0 198 0 2 1 169 0 3 1 173 0 4 1 177 0 5 0 198 0 6 0 198 0 25 0 198 0 26 0 198 0 32 0 198 0 33 0 198 0 34 0 198 0 35 1 181 0 36 0 198 0 37 0 198 0 38] #[1 0 50 0 1 0 50 0 7 0 50 0 25 0 50 0 26 0 50 0 27 0 50 0 29 0 50 0 33 0 50 0 39 1 185 0 82 0 221 0 83] #[0 1 189 0 33] #[0 0 202 0 1 0 33] #[1 1 193 0 26 1 197 0 40] #[1 0 206 0 1 0 206 0 7 0 206 0 25 0 206 0 26 0 206 0 27 0 206 0 29 1 201 0 30 0 206 0 33 0 206 0 39] #[0 0 210 0 26 0 33] #[0 0 214 0 26 0 33] #[1 0 218 0 6 0 218 0 26 1 205 0 56] #[1 0 222 0 6 0 222 0 26 1 209 0 58] #[0 0 226 0 7 0 25 0 26 0 27 0 33] #[0 0 230 0 25 0 33] #[0 0 234 0 26 0 33] #[0 0 238 0 26 0 33] #[0 0 242 0 25 0 26 0 32 0 84] #[1 1 157 0 1 1 57 0 2 1 213 0 6 1 61 0 25 1 65 0 26 1 69 0 32 1 73 0 34 1 77 0 35 1 81 0 37 1 85 0 38 1 165 0 78] #[1 1 57 0 2 1 61 0 25 1 65 0 26 1 69 0 32 1 73 0 34 1 77 0 35 1 81 0 37 1 85 0 38 1 217 0 76 1 93 0 78] #[0 1 221 0 33] #[1 0 246 0 1 0 246 0 2 1 169 0 3 1 173 0 4 1 177 0 5 0 246 0 6 0 246 0 25 0 246 0 26 0 246 0 32 0 246 0 33 0 246 0 34 0 246 0 35 1 181 0 36 0 246 0 37 0 246 0 38] #[0 0 250 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 0 254 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 1 2 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 1 6 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[0 1 10 0 1 0 33] #[0 1 14 0 25 0 26 0 32 0 84] #[0 1 225 0 40] #[0 1 18 0 1 0 33] #[0 1 22 0 1 0 7 0 25 0 26 0 27 0 29 0 33 0 39] #[1 1 229 0 6 1 233 0 26] #[1 1 237 0 6 1 241 0 26] #[0 1 26 0 1 0 2 0 3 0 4 0 5 0 6 0 25 0 26 0 32 0 33 0 34 0 35 0 36 0 37 0 38] #[1 1 30 0 1 1 57 0 2 1 30 0 6 1 61 0 25 1 65 0 26 1 69 0 32 1 30 0 33 1 73 0 34 1 77 0 35 1 81 0 37 1 85 0 38 1 165 0 78] #[0 1 34 0 25 0 26 0 32 0 84] #[0 1 38 0 1 0 33] #[0 1 42 0 33] #[0 1 46 0 6 0 26] #[0 1 50 0 33] #[0 1 54 0 6 0 26]	).</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser</class-id> <category>private-strings</category><body package="SmaCC Development" selector="allCharacters">allCharacters	^SmaCCGrammar allCharacters</body><body package="SmaCC Development" selector="carriageReturnString">carriageReturnString	^String with: (Character value: 13)</body><body package="SmaCC Development" selector="formFeedString">formFeedString	^String with: (Character value: 12)</body><body package="SmaCC Development" selector="newlineString">newlineString	^String with: (Character value: 10)</body><body package="SmaCC Development" selector="tabString">tabString	^'	'</body><body package="SmaCC Development" selector="verticalTabString">verticalTabString	^String with: (Character value: 11)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser</class-id> <category>testing</category><body package="SmaCC Development" selector="isDigit:">isDigit: each	^each between: $0 and: $9</body><body package="SmaCC Development" selector="isLetterOrDigit:">isLetterOrDigit: each	^(each between: $a and: $z) or: [(each between: $A and: $Z) or: [(each between: $0 and: $9) or: [each == $_]]]</body><body package="SmaCC Development" selector="isWhitespace:">isWhitespace: each	^self whitespaceValues includes: each asInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser class</class-id> <category>generated</category><body package="SmaCC Development" selector="definitionComment">definitionComment"%states default scanner directives parser;directives &lt;states&gt;	: states 	;directives &lt;excludes&gt; 	: excludes 	;directives &lt;root&gt; 	: root 	;directives &lt;hierarchy&gt; 	: hierarchy 	;directives &lt;attributes&gt;	: attributes	;directives &lt;prefix&gt; 	: prefix 	;directives &lt;suffix&gt; 	: suffix 	;directives &lt;left&gt; 	: left 	;directives &lt;right&gt; 	: right 	;directives &lt;nonassoc&gt; 	: nonassoc 	;directives &lt;id&gt; 	: id 	;directives &lt;start&gt; 	: start 	;directives &lt;glr&gt;	: glr	;directives &lt;ignorecase&gt;	: ignorecase	;directives &lt;ignorevariables&gt;	: ignore_variables	;directives &lt;annotate_tokens&gt;	: annotate_tokens	;&lt;name&gt; 	: (&lt;isLetter&gt; | _) (&lt;isLetter&gt; | _ | &lt;isDigit&gt;)*	;&lt;directive&gt; 	: \%	;&lt;whitespace&gt;	: \s+ 	;&lt;tokenname&gt;	: \&lt; &lt;name&gt; \&gt;	;&lt;symbolname&gt;	: &lt;name&gt;	 ;&lt;keyword&gt;	: (\"" [^\""]* \"") + 	;&lt;comment&gt;	: (\# [^\r\n]*) 	| (\/\* [^\*]* \*+ ([^\/\*] [^\*]* \*+)* \/)	;&lt;code&gt;	: \{ 	;&lt;variablename&gt;	: \' &lt;name&gt; \' 	;&lt;production&gt;	: \: (\: \=)? 	;&lt;directive&gt;	: % 	;&lt;semicolon&gt;	: \; 	;scanner &lt;backslashcharacter&gt;	: \\ [^cx] 	| \\ c [A-Z] 	| \\ x [0-9A-Fa-f]{1,4}	;scanner &lt;characterblock&gt;	: \[ ([^\]\\] | &lt;backslashcharacter&gt; )+ \] 	;scanner &lt;repeat&gt;	: \{ [0-9]* \, [0-9]* \}	;scanner &lt;character&gt;	: [^\ \t\v\\\r\n\{\(\[\.]	; scanner &lt;anycharacter&gt;	: \.	;parser &lt;optionalLeft&gt;	: \[	;parser &lt;optionalRight&gt;	: \] 	;parser &lt;repeatLeft&gt; 	: \&lt;\% 	;parser &lt;repeatRight&gt; 	: \%\&gt; 	;parser &lt;classLeft&gt; 	: \{\{ 	;parser &lt;classRight&gt; 	: \}\} 	;%id &lt;code&gt; &lt;keyword&gt; &lt;symbolname&gt; &lt;tokenname&gt; &lt;variablename&gt; &lt;semicolon&gt;	&lt;directive&gt; &lt;production&gt; &lt;classLeft&gt; &lt;classRight&gt;;%left	""|"";%left ""("" &lt;character&gt; &lt;backslashcharacter&gt; &lt;characterblock&gt; &lt;anycharacter&gt; &lt;tokenname&gt; &lt;symbolname&gt; &lt;directive&gt;;%left ""*"" ""+"" ""?"" &lt;repeat&gt; ;File	: Rules 			{grammar 				addExtraSymbols; 				yourself}	;Rules	: Rule	| Rules Rule	;Rule 	: ProductionRule 			{grammar setStartSymbolIfNone: '1'}	| DirectiveLine	| RegexRule 			{'1' states isEmpty ifTrue: ['1' addStates: scannerDefinition nonExcludeStates]}	;# DirectivesDirectiveLine 	: StartDirective &lt;directive&gt; Directive EndDirective &lt;semicolon&gt;	;Directive 	: ExcludeStatesLine 	| StatesLine	| RootClassLine	| SuperclassLine	| AttributesLine	| PrefixLine	| SuffixLine	| LeftLine 	| RightLine 	| NonAssociativeLine	| IdMethodLine	| StartLine 	| GLR	| IgnoreCase	| IgnoredVariables	| AnnotateTokens	;StartDirective 	: 		{self state: #directives}	;EndDirective 	: 		{self state: #default}	;StatesLine 	: &lt;states&gt; States	;States 	: 	| States Symbol 			{scannerDefinition addState: '2'}	;ExcludeStatesLine 	: &lt;excludes&gt; ExcludeStates	;ExcludeStates :	| ExcludeStates Symbol 			{scannerDefinition addExcludeState: '2'}	;RootClassLine 	: &lt;root&gt; &lt;symbolname&gt; 'root' 			{(grammar classNamed: root value asSymbol) beRoot}	;SuperclassLine	: &lt;hierarchy&gt; &lt;symbolname&gt; 'superclass' ""("" ClassList 'classes' "")""			{classes do: [:each | (grammar classNamed: each) superclass: (grammar classNamed: superclass value asSymbol)]}	;AttributesLine	: &lt;attributes&gt; &lt;symbolname&gt; 'aClass' ""("" IvarList 'ivars' "")""			{(grammar classNamed: aClass value asSymbol)  extraAttributes: (ivars collect: [:each | SmaCCVariableDefinition variableName: each ])} ;IvarList		:		{OrderedCollection new}	| IvarList 'list' &lt;symbolname&gt; 'name'				{list add: name value; yourself} 	;ClassList 	: 		{OrderedCollection new}	| ClassList 'list' &lt;symbolname&gt; 'name' 			{list 				add: name value asSymbol; 				yourself}	;PrefixLine	: &lt;prefix&gt; &lt;symbolname&gt; 'prefix' 			{grammar prefix: prefix value}	;SuffixLine	: &lt;suffix&gt; &lt;symbolname&gt; 'suffix' 			{grammar suffix: suffix value}	;LeftLine	: &lt;left&gt; TokenList 'tokens' 			{tokens 				do: 					[:each | 					grammar 						leftPrecedenceFor: each; 						setOperatorPrecedenceFor: each to: scanner lineNumber].			nil}	;RightLine	: &lt;right&gt; TokenList 'tokens' 			{tokens 				do: 					[:each | 					grammar 						rightPrecedenceFor: each; 						setOperatorPrecedenceFor: each to: scanner lineNumber].			nil}	;NonAssociativeLine	: &lt;nonassoc&gt; TokenList 'tokens'			{tokens 				do: 					[:each | 					grammar 						nonAssociativePrecedenceFor: each; 						setOperatorPrecedenceFor: each to: scanner lineNumber].			nil}	;TokenList	: Term	| TokenList Term	;IdMethodLine	: &lt;id&gt; IdTokens 'tokens' 			{tokens do: [:each | grammar makeTokenIdMethodFor: each]. nil}	;IdTokens	: &lt;tokenname&gt; 			{OrderedCollection with: '1' value}	| IdTokens &lt;tokenname&gt; 			{'1' 				add: '2' value; 				yourself}	;StartLine	: &lt;start&gt; StartingTokens	;StartingTokens	: &lt;symbolname&gt; 'symbol' 			{grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: symbol value)}	| StartingTokens &lt;symbolname&gt; 'symbol' 			{grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: symbol value)}	;GLR	: &lt;glr&gt;			{grammar isGLR: true}	;IgnoredVariables	: &lt;ignorevariables&gt; IgnoredVariableList 'variables'			{grammar ignoredVariables: variables}	;IgnoredVariableList	: &lt;symbolname&gt; 'name'			{OrderedCollection with: name value}	| IgnoredVariableList 'variables' &lt;symbolname&gt; 'name'			{variables add: name value.			variables}	;IgnoreCase	: &lt;ignorecase&gt;			{grammar ignoreCase: true}	;AnnotateTokens	: &lt;annotate_tokens&gt;			{grammar annotateTokens: true}	;# ScannerRegexRule 	: StartRegex &lt;tokenname&gt; 'token' &lt;production&gt; Regex 'regex' EndRegex &lt;semicolon&gt;			{| symbol |			regex position: token startPosition. 			scannerDefinition addToken: regex withName: token value. 			symbol := grammar findSymbolNamed: token value ifAbsent: [nil].			symbol notNil ifTrue: [symbol regularExpression: regex].			regex}	| Symbol 'state' RegexRule 'rule'			{rule				addState: state; 				yourself}	;StartRegex	: 		{self state: #scanner}	;EndRegex	: 		{self state: #default}	;Symbol 	: &lt;symbolname&gt; 			{'1' value asSymbol}	;Regex	: RegexTerm 			{'1'}	| Regex ""|"" Regex 			{'1' | '3'}	| Regex RegexTerm 			{'1' , '2'}	;RegexTerm	: &lt;character&gt; 			{SmaCCCharacterRENode characters: '1' value}	| &lt;directive&gt;			{SmaCCCharacterRENode characters: '1' value}	| &lt;anycharacter&gt; 			{SmaCCCharacterRENode characters: self allCharacters}	| &lt;backslashcharacter&gt; 			{self nodeFor: (ReadStream on: ('1' value copyFrom: 2 to: '1' value size))} 	| ""("" Regex "")"" 			{'2'}	| &lt;characterblock&gt; 			{self parseCharacterBlock: '1'}	| &lt;tokenname&gt; 			{(scannerDefinition tokenNamed: '1' value ifAbsentPut: [self generateImplicitToken: '1']) copy}	| &lt;symbolname&gt; 			{SmaCCSequenceRENode nodes: ('1' value asOrderedCollection collect: [:each | SmaCCCharacterRENode characters: (String with: each)])}	| RegexTerm ""*""				{'1' repeat}	| RegexTerm ""+"" 			{'1' repeatForAtLeast: 1}	| RegexTerm ""?"" 			{'1' repeatFor: 0 to: 1}	| RegexTerm &lt;repeat&gt; 			{| readStream start stop | 			readStream := ReadStream on: ('2' value copyFrom: 2 to: '2' value size - 1). 			start := readStream upTo: $,. 			stop := readStream upToEnd.			'1' repeatFor: (start isEmpty ifTrue: [0] ifFalse: [start asNumber]) to: (stop isEmpty ifTrue: [(1 bitShift: 31)] ifFalse: [stop asNumber])}	;# Parser ProductionRule	: &lt;symbolname&gt; 'symbolName' StartProduction &lt;production&gt; ParserRules 'rules' EndProduction &lt;semicolon&gt;			{| symbol | 			symbol := grammar nonTerminalSymbolNamed: symbolName value. 			rules do: [:each | symbol addProduction: each]. 			self createDefaultClassesForSymbol: symbolName value.			symbol}	;StartProduction	: 		{self state: #parser}	;EndProduction	: 		{self state: #default}	;ParserRules	: ParserRules ""|"" ParserRule 			{'1' 				add: '3'; 				yourself}	| ParserRule	;ParserRule 	: Terms 'rhs' 			{rhs}	| Terms 'rhs' &lt;code&gt; 'code' 			{self verifyCodeToken: code for: rhs} 	| Terms 'rhs' &lt;classLeft&gt; &lt;symbolname&gt; 'className' &lt;classRight&gt;			{self createClass: className value asSymbol for: rhs}	| Terms 'rhs' &lt;classLeft&gt; &lt;classRight&gt;			{self createDefaultClassFor: rhs}	;Terms 	: 		{grammar newRHS}	| Terms 'rhs' Term 'term'			{rhs 				add: term; 				yourself}		| Terms 'rhs' Term 'term' &lt;variablename&gt; 'variableNameToken'			{rhs 				add: term; 				nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); 				yourself}		;Term	: &lt;keyword&gt; 			{grammar keywordTerminalNamed: '1' value}	| &lt;tokenname&gt;			{grammar				findSymbolNamed: '1' value				ifAbsentAdd: 					[| node symbol |					symbol := grammar newTerminalSymbolNamed: '1' value.					(scannerDefinition includesTokenNamed: '1' value) 						ifTrue: [symbol regularExpression: (scannerDefinition tokenNamed: '1' value)]						ifFalse:							[node := SmaCCGrammar implicitToken: '1' value.							node notNil								ifTrue: 									[node addStates: scannerDefinition nonExcludeStates.									symbol regularExpression: node]].					symbol]}	| &lt;symbolname&gt; 			{grammar nonTerminalSymbolNamed: '1' value}	| ""error"" 			{grammar errorSymbol}	;"</body><body package="SmaCC Development" selector="startingStateForFile">startingStateForFile	^1</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionParser class</class-id> <category>generated-accessing</category><body package="SmaCC Development" selector="scannerClass">scannerClass	^SmaCCDefinitionScanner</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNFAtoDFA</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	mergedStates := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNFAtoDFA</class-id> <category>algorithm</category><body package="SmaCC Development" selector="convertToDFA:">convertToDFA: aSmaCCNode	^self mergedNodeFor: (Array with: aSmaCCNode)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNFAtoDFA</class-id> <category>edges</category><body package="SmaCC Development" selector="commonTransitionObjectsForEdges:">commonTransitionObjectsForEdges: edgeCollection	^edgeCollection		inject: edgeCollection first transitionObjects		into: [:sum :each | sum select: [:char | each includes: char]]</body><body package="SmaCC Development" selector="createEdgeMerging:">createEdgeMerging: conflictingEdgeCollection	| newNode common newEdge |	newNode := self mergedNodeFor: (conflictingEdgeCollection collect: [:each | each to]).	common := self commonTransitionObjectsForEdges: conflictingEdgeCollection.	newEdge := conflictingEdgeCollection first class to: newNode on: common.	conflictingEdgeCollection do: [:each | each remove: common].	^newEdge</body><body package="SmaCC Development" selector="setTransitionsOn:to:">setTransitionsOn: aSmaCCNode to: edgeCollection 	aSmaCCNode transitions: (edgeCollection reject: [:each | each isEmpty]).	aSmaCCNode transitions do: [:each | each to: (self convertToDFA: each to)]</body><body package="SmaCC Development" selector="someDuplicateIn:">someDuplicateIn: edgeCollection	| objects |	objects := SmaCCSet new.	edgeCollection		do:			[:edge | 			edge transitionObjects do: [:each | (objects includes: each) ifTrue: [^each]].			objects addAll: edge transitionObjects].	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNFAtoDFA</class-id> <category>merging nodes</category><body package="SmaCC Development" selector="eliminateDuplicateTransitionsIn:">eliminateDuplicateTransitionsIn: aSmaCCNode	| newTransitions conflictingObject |	newTransitions := aSmaCCNode transitions collect: [:each | each copy].	[conflictingObject := self someDuplicateIn: newTransitions.	conflictingObject notNil]		whileTrue:			[| conflictingEdges newEdge |			conflictingEdges := newTransitions select: [:each | each includes: conflictingObject].			newEdge := self createEdgeMerging: conflictingEdges.			newTransitions add: newEdge].	self setTransitionsOn: aSmaCCNode to: newTransitions</body><body package="SmaCC Development" selector="mergedNodeFor:">mergedNodeFor: nodeCollection 	| mergedNodes |	mergedNodes := nodeCollection asSortedCollection asArray.	^mergedStates at: mergedNodes		ifAbsent: 			[| newNode |			newNode := self createMergedNodeFrom: mergedNodes.			mergedStates				at: mergedNodes put: newNode;				at: (Array with: newNode) put: newNode.			self eliminateDuplicateTransitionsIn: newNode.			newNode]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNFAtoDFA class</class-id> <category>accessing</category><body package="SmaCC Development" selector="convertToDFA:">convertToDFA: aSmaCCNode 	"Returns an equivalent DFA from the NFA specified by aSmaCCNode -- the NFA must not contain epsilon edges."	^self new convertToDFA: aSmaCCNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNotRENode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="node:">node: aSmaCCCharacterRENode	node := aSmaCCCharacterRENode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNotRENode</class-id> <category>accessing</category><body package="SmaCC Development" selector="possibleMatchesSize">possibleMatchesSize	^self characterNode possibleMatchesSize</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNotRENode</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	self characterNode printOn: aStream</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNotRENode</class-id> <category>private</category><body package="SmaCC Development" selector="asNFAStartingWith:">asNFAStartingWith: aSmaCCNode	^self characterNode asNFAStartingWith: aSmaCCNode</body><body package="SmaCC Development" selector="characterNode">characterNode	^(SmaCCCharacterRENode characters: self characters)		addStates: states;		action: action;		yourself</body><body package="SmaCC Development" selector="characters">characters	^SmaCCGrammar allCharacters reject: [:each | node characters includes: each]</body><body package="SmaCC Development" selector="possibleMatchesDo:on:">possibleMatchesDo: aBlock on: aStream	self characterNode possibleMatchesDo: aBlock on: aStream</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNotRENode</class-id> <category>constructing</category><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive	node makeCaseInsensitive</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNotRENode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="on:">on: aSmaCCCharacterRENode	^(self new)		node: aSmaCCCharacterRENode;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEpsilonRemoval</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	nodeMap := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEpsilonRemoval</class-id> <category>algorithm</category><body package="SmaCC Development" selector="createNodeWithoutEpsilonEdges:">createNodeWithoutEpsilonEdges: aSmaCCNode	| newNode newTransitions |	newNode := self createMergedNodeFrom: (self epsilonReachableNodesFrom: aSmaCCNode).	nodeMap at: aSmaCCNode put: newNode.	newTransitions := OrderedCollection new.	newNode transitions		do:			[:each | 			each isEpsilonTransition				ifFalse:					[newTransitions						add: (each class to: (self removeEpsilonEdgesFrom: each to) on: each transitionObjects)]].	newNode transitions: newTransitions.	^newNode</body><body package="SmaCC Development" selector="epsilonReachableNodesFrom:">epsilonReachableNodesFrom: aSmaCCNode	| todo reachable node |	reachable := Set with: aSmaCCNode.	todo := OrderedCollection with: aSmaCCNode.	[todo notEmpty]		whileTrue:			[node := todo removeLast.			node transitions				do:					[:each | 					(each isEpsilonTransition and: [(reachable includes: each to) not])						ifTrue:							[reachable add: each to.							todo add: each to]]].	^reachable</body><body package="SmaCC Development" selector="removeEpsilonEdgesFrom:">removeEpsilonEdgesFrom: aSmaCCNode	^nodeMap at: aSmaCCNode ifAbsent: [self createNodeWithoutEpsilonEdges: aSmaCCNode]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEpsilonRemoval class</class-id> <category>algorithm</category><body package="SmaCC Development" selector="removeEpsilonEdgesFrom:">removeEpsilonEdgesFrom: aSmaCCNode 	"Returns an equivalent graph to aSmaCCNode that doesn't contain any epsilon transitions"	^self new removeEpsilonEdgesFrom: aSmaCCNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeCalculation</class-id> <category>private</category><body package="SmaCC Development" selector="calculateReduceActions">calculateReduceActions	variableSymbols do: [:each | each productionsDo: [:rhs | rhs reduceAction: (SmaCCVariableReduceCode onRHS: rhs)]].	grammar		rhsDo:			[:each | 			each hasNodeClassDefinition				ifTrue: [each reduceAction: (SmaCCCreateNodeReduceCode onRHS: each)]				ifFalse: [each hasReduceAction ifFalse: [each reduceAction: (SmaCCDefaultNodeReduceCode onRHS: each)]]]</body><body package="SmaCC Development" selector="calculateSymbolVariables">calculateSymbolVariables	variableSymbols := Set new.	grammar symbols		do:			[:each | 			each requiresNodeType				ifTrue: [each productionsDo: [:rhs | rhs unnamedSymbolsDo: [:sym | self calculateSymbolVariablesFor: sym]]]].	variableSymbols := variableSymbols select: [:each | self hasVariables: each seen: IdentitySet new]</body><body package="SmaCC Development" selector="calculateSymbolVariablesFor:">calculateSymbolVariablesFor: aSmaCCSymbol	aSmaCCSymbol isTerminal ifTrue: [^self].	aSmaCCSymbol requiresNodeType ifTrue: [^self].	(variableSymbols includes: aSmaCCSymbol) ifTrue: [^self].	variableSymbols add: aSmaCCSymbol.	aSmaCCSymbol productionsDo: [:rhs | rhs unnamedSymbolsDo: [:each | self calculateSymbolVariablesFor: each]]</body><body package="SmaCC Development" selector="calculateVariables">calculateVariables	SmaCCVariableCalculation calculateVariablesForGrammar: grammar</body><body package="SmaCC Development" selector="codeGenerator">codeGenerator	^grammar codeGenerator</body><body package="SmaCC Development" selector="compileMethodsAndVariables">compileMethodsAndVariables	classes do: [:each | each compileMethodsAndVariables]</body><body package="SmaCC Development" selector="compileNodeClasses">compileNodeClasses	classes := self sortedClasses.	classes isEmpty ifTrue: [^self].	self defineNodeClasses.	self calculateSymbolVariables.	self calculateReduceActions.	self calculateVariables.	self compileMethodsAndVariables.	self compileVisitor.	self compileTypes</body><body package="SmaCC Development" selector="compileTypes">compileTypes	self codeGenerator compileSymbolTypes</body><body package="SmaCC Development" selector="compileVisitor">compileVisitor	| class |	class := self codeGenerator		defineClass: grammar rootDefinition fullName , 'Visitor'		asSubclassOf: (self codeGenerator model classFor: SmaCCParseNodeVisitor).	self codeGenerator removeOldMethodsFrom: class.	self codeGenerator removeOldMethodsFrom: class metaclass.	(SmaCCVisitorClassDefinition forClassDefinitions: classes)		grammar: grammar;		modelClass: class;		compileMethodsAndVariables</body><body package="SmaCC Development" selector="defineNodeClasses">defineNodeClasses	classes do: [:each | self codeGenerator compileNodeClassDefinition: each]</body><body package="SmaCC Development" selector="grammar:">grammar: aSmaCCGrammar	grammar := aSmaCCGrammar</body><body package="SmaCC Development" selector="hasVariables:seen:">hasVariables: aSmaCCSymbol seen: aSet	aSmaCCSymbol requiresNodeType ifTrue: [^false].	(aSet includes: aSmaCCSymbol) ifTrue: [^false].	aSet add: aSmaCCSymbol.	aSmaCCSymbol		productionsDo:			[:each | 			each hasNamedVariable ifTrue: [^true].			each do: [:symbol | (self hasVariables: symbol seen: aSet) ifTrue: [^true]]].	^false</body><body package="SmaCC Development" selector="sortedClasses">sortedClasses	^grammar classDefinitions asSortedCollection: [:a :b | a isSortedBefore: b]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeCalculation class</class-id> <category>accessing</category><body package="SmaCC Development" selector="compileForGrammar:">compileForGrammar: aSmaCCGrammar	(self new)		grammar: aSmaCCGrammar;		compileNodeClasses</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPreferredCompositeAction</class-id> <category>private</category><body package="SmaCC Development" selector="reduceAction">reduceAction	^actions detect: [:each | each isReduce]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPreferredCompositeAction</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:prefer:">mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isReduce		ifTrue:			[self reduceAction = aSmaCCAction ifTrue: [^self].			^(SmaCCAmbiguousAction new)				addAction: aSmaCCAction;				addActions: actions;				yourself].	aSmaCCAction isShift		ifTrue:			[self addAction: aSmaCCAction.			^self].	^aSmaCCAction mergeWith: self prefer: aClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPreferredCompositeAction</class-id> <category>error handling</category><body package="SmaCC Development" selector="errorType">errorType	^'Shift/Reduce Conflict (handled by precedence rules)'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPreferredCompositeAction</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="preferredAction:">preferredAction: aSmaCCAction	preferredAction := aSmaCCAction</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPreferredCompositeAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="preferredAction">preferredAction	^preferredAction</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefaultNodeReduceCode</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= anObject	^super = anObject and: [self index = anObject index]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefaultNodeReduceCode</class-id> <category>private</category><body package="SmaCC Development" selector="basicModelTypes:">basicModelTypes: aSet	^self index = 0		ifTrue: [Array with: (self model classFor: nil class)]		ifFalse: [self basicModelTypes: aSet forIndex: self index]</body><body package="SmaCC Development" selector="modelTypes:">modelTypes: anIdentitySet	"Yes, I know it is a hack"	IsCaching ifTrue: [^self basicModelTypes: anIdentitySet].	IsCaching := true.	^[super modelTypes: anIdentitySet] ensure: [IsCaching := false]</body><body package="SmaCC Development" selector="returnedNodeIndex">returnedNodeIndex	self index = 0 ifTrue: [^nil].	^self index</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefaultNodeReduceCode</class-id> <category>accessing</category><body package="SmaCC Development" selector="index">index	index isNil		ifTrue:			[rhs size = 0				ifTrue: [index := 0]				ifFalse:					[rhs size						to: 1						by: -1						do: [:i | (rhs at: i) isTerminal ifFalse: [index := i]].					index isNil ifTrue: [index := 1]]].	^index</body><body package="SmaCC Development" selector="source">source	^self codeGenerator defaultNodeReductionSource: self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefaultNodeReduceCode class</class-id> <category>class initialization</category><body package="SmaCC Development" selector="initialize">initialize	IsCaching := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolTableIndex</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= anObject	^self class = anObject class and: [self index = anObject index and: [self symbol = anObject symbol]]</body><body package="SmaCC Development" selector="hash">hash	^(index bitShift: 14) + symbol hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolTableIndex</class-id> <category>accessing</category><body package="SmaCC Development" selector="index">index	^index</body><body package="SmaCC Development" selector="index:">index: anObject	index := anObject</body><body package="SmaCC Development" selector="symbol">symbol	^symbol</body><body package="SmaCC Development" selector="symbol:">symbol: anObject	symbol := anObject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolTableIndex class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="forIndex:symbol:">forIndex: anInteger symbol: aSmaCCSymbol	^(self new)		index: anInteger;		symbol: aSmaCCSymbol;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition</class-id> <category>private-variables</category><body package="SmaCC Development" selector="baseTypeOf:">baseTypeOf: aVariableName	| allTypes aRBRootNamespace |	aRBRootNamespace := class rootNameSpace.	allTypes := self modelTypesForVariable: aVariableName.	allTypes remove: (aRBRootNamespace classFor: nil class) ifAbsent: [nil].	allTypes isEmpty ifTrue: [^aRBRootNamespace classFor: Object].	allTypes := allTypes asOrderedCollection.	^allTypes		inject: allTypes first		into:			[:sum :each | 			| current |			current := sum.			[current notNil and: [(each includesClass: current) not]] whileTrue: [current := current superclass].			current]</body><body package="SmaCC Development" selector="calculateCommonSubclassVariables">calculateCommonSubclassVariables	| allSubclassVars includedVariables |	allSubclassVars := Bag new.	subclasses do: [:each | allSubclassVars addAll: each variableDefinitions].	includedVariables := allSubclassVars asSet select: [:each | (allSubclassVars occurrencesOf: each) = subclasses size].	^self subclassProductionVariables select: [:each | includedVariables includes: each]</body><body package="SmaCC Development" selector="collectionGetterForVariableName:">collectionGetterForVariableName: aString	self variableDefinitionInHierarchyNamed: aString do: [:var | var isCollection ifTrue: [^var getterMethodName asSymbol]].	^nil</body><body package="SmaCC Development" selector="collectionVariableDefinitions">collectionVariableDefinitions	^self variableDefinitions select: [:each | each isCollection]</body><body package="SmaCC Development" selector="hierarchyDefinesVariable:">hierarchyDefinesVariable: aString	^self withAllSubclasses anySatisfy: [:cls | cls instanceVariableNames includes: aString]</body><body package="SmaCC Development" selector="modelTypesForVariable:">modelTypesForVariable: aVariableName	| allTypes |	allTypes := Set new.	self withAllSubclasses do: [:each | each productions do: [:production | allTypes addAll: (production modelTypesForVariable: aVariableName)]].	^allTypes</body><body package="SmaCC Development" selector="objectGetterForVariableName:">objectGetterForVariableName: aString	self variableDefinitionInHierarchyNamed: aString do: [:var | var isCollection ifFalse: [^var getterMethodName asSymbol]].	^nil</body><body package="SmaCC Development" selector="productionVariables">productionVariables	| vars |	vars := productions collect: [:each | each variableDefinitions].	^SmaCCSymbol mergeOrderedVariableDefinitions: vars</body><body package="SmaCC Development" selector="removeDuplicateSubclassVariables">removeDuplicateSubclassVariables	variables do: [:each | self withAllSubclasses do: [:sub | sub == self ifFalse: [sub removeInstanceVariable: each variableName]]]</body><body package="SmaCC Development" selector="removeInstanceVariable:">removeInstanceVariable: aString	| variable |	variable := self variableDefinitions detect: [:each | each variableName = aString] ifNone: [nil].	variable isNil ifTrue: [^self].	variables remove: variable.	SmaCCVariableDefinition assignIndices: variables</body><body package="SmaCC Development" selector="subclassProductionVariables">subclassProductionVariables	| vars |	vars := self withAllSubclasses collect: [:sub | sub productionVariables].	^SmaCCSymbol mergeOrderedVariableDefinitions: vars</body><body package="SmaCC Development" selector="variableDefinitionInHierarchyNamed:do:">variableDefinitionInHierarchyNamed: aString do: aBlock	self withAllSubclasses do: [:cls | (cls variableDefinitionNamed: aString) ifNotNil: aBlock]</body><body package="SmaCC Development" selector="variableDefinitionNamed:">variableDefinitionNamed: aString	^self variableDefinitions		detect: [:each | each variableName = aString]		ifNone: [superclass isNil ifTrue: [nil] ifFalse: [superclass variableDefinitionNamed: aString]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition</class-id> <category>testing</category><body package="SmaCC Development" selector="hasVariable:">hasVariable: aString	^(variables anySatisfy: [:each | each variableName = aString])		or: [superclass notNil and: [superclass hasVariable: aString]]</body><body package="SmaCC Development" selector="isAlwaysAssigned:">isAlwaysAssigned: aString	^((self modelTypesForVariable: aString) includes: (class rootNameSpace classFor: nil class))		and:			[self withAllSubclasses allSatisfy: [:sub | sub productions allSatisfy: [:each | each locallyDefinesVariable: aString]]]</body><body package="SmaCC Development" selector="isCollectionVariable:">isCollectionVariable: aVariableName	| definition |	definition := self variableDefinitionNamed: aVariableName.	definition notNil ifTrue: [^definition isCollection].	^superclass notNil and: [superclass isCollectionVariable: aVariableName]</body><body package="SmaCC Development" selector="isLocalVariable:">isLocalVariable: aSmaCCVariableDefinition	^superclass isNil or: [(superclass variableDefinitionNamed: aSmaCCVariableDefinition variableName) isNil]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition</class-id> <category>private</category><body package="SmaCC Development" selector="copyName">copyName	^self findNameUsing: #('copy' 'new')</body><body package="SmaCC Development" selector="findNameUsing:">findNameUsing: aCollection	| string index indexString |	index := 0.	indexString := ''.	[string := aCollection		detect: [:each | (self hierarchyDefinesVariable: each , indexString) not]		ifNone: [nil].	string notNil ifTrue: [^string , indexString].	index := index + 1.	indexString := index printString] repeat</body><body package="SmaCC Development" selector="rootClassName">rootClassName	^SmaCCParseNode fullName</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition</class-id> <category>compiling</category><body package="SmaCC Development" selector="addVariable:">addVariable: aSmaCCVariableDefinition	self codeGenerator addVariable: aSmaCCVariableDefinition forDefinition: self</body><body package="SmaCC Development" selector="compileChildrenMethod">compileChildrenMethod	self codeGenerator compileChildrenMethod: self</body><body package="SmaCC Development" selector="compileCopyInContextMethod">compileCopyInContextMethod	self codeGenerator compileCopyInContextMethod: self</body><body package="SmaCC Development" selector="compileEqualMethod">compileEqualMethod	self codeGenerator compileEqualMethod: self</body><body package="SmaCC Development" selector="compileGetterAndSetter:">compileGetterAndSetter: aSmaCCVariableDefinition	self codeGenerator compileGetterAndSetter: aSmaCCVariableDefinition forDefinition: self</body><body package="SmaCC Development" selector="compileHashMethod">compileHashMethod	self codeGenerator compileHashMethod: self</body><body package="SmaCC Development" selector="compileInitializeMethod">compileInitializeMethod	self codeGenerator compileInitializeMethod: self</body><body package="SmaCC Development" selector="compileMatchInContextMethod">compileMatchInContextMethod	self codeGenerator compileMatchInContextMethod: self</body><body package="SmaCC Development" selector="compileMethodsAndVariables">compileMethodsAndVariables	self		compileVariablesAndAccessors;		compileInitializeMethod;		compileHashMethod;		compileEqualMethod;		compilePostCopyMethod;		compileChildrenMethod;		compileCopyInContextMethod;		compileMatchInContextMethod;		compileVariablesMethods</body><body package="SmaCC Development" selector="compilePostCopyMethod">compilePostCopyMethod	self codeGenerator compilePostCopyMethod: self</body><body package="SmaCC Development" selector="compileVariableAndAccessor:">compileVariableAndAccessor: aSmaCCVariableDefinition	aSmaCCVariableDefinition baseType: (self baseTypeOf: aSmaCCVariableDefinition variableName).	aSmaCCVariableDefinition		isAlwaysAssigned: (self isAlwaysAssigned: aSmaCCVariableDefinition variableName).	self addVariable: aSmaCCVariableDefinition.	self compileGetterAndSetter: aSmaCCVariableDefinition</body><body package="SmaCC Development" selector="compileVariablesAndAccessors">compileVariablesAndAccessors	self variableDefinitions do: [:each | self compileVariableAndAccessor: each].	self extraAttributes do: [:each | self compileVariableAndAccessor: each]</body><body package="SmaCC Development" selector="compileVariablesMethods">compileVariablesMethods	self codeGenerator compileVariablesMethods: self</body><body package="SmaCC Development" selector="tempNodeName">tempNodeName	^self temporaryNameFor: grammar rootDefinition name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition</class-id> <category>accessing</category><body package="SmaCC Development" selector="addProduction:">addProduction: aSmaCCRHS	productions add: aSmaCCRHS.	aSmaCCRHS nodeClassDefinition: self</body><body package="SmaCC Development" selector="allVariableDefinitions">allVariableDefinitions	| defs |	defs := OrderedCollection new.	superclass notNil ifTrue: [defs addAll: superclass variableDefinitions].	defs addAll: self variableDefinitions.	^defs</body><body package="SmaCC Development" selector="extraAttributes">extraAttributes	^extraAttributes</body><body package="SmaCC Development" selector="fullName">fullName	^self codeGenerator namespaceName , grammar prefix , name , grammar suffix</body><body package="SmaCC Development" selector="grammar">grammar	^grammar</body><body package="SmaCC Development" selector="instanceVariableNames">instanceVariableNames	^self variableDefinitions collect: [:each | each variableName]</body><body package="SmaCC Development" selector="nodeVariableDefinitions">nodeVariableDefinitions	^self variableDefinitions select: [:each | each isBasePossibleNodeType]</body><body package="SmaCC Development" selector="productions">productions	^productions</body><body package="SmaCC Development" selector="variableDefinitions">variableDefinitions	variables isNil		ifTrue:			[variables := productions isEmpty ifTrue: [self calculateCommonSubclassVariables] ifFalse: [self productionVariables].			self removeDuplicateSubclassVariables.			SmaCCVariableDefinition assignIndices: variables].	^variables</body><body package="SmaCC Development" selector="variables">variables	^superclass isNil		ifTrue: [self instanceVariableNames copy]		ifFalse:			[(superclass variables)				addAll: self instanceVariableNames;				yourself]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="extraAttributes:">extraAttributes: aCollection	extraAttributes := aCollection</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	productions := OrderedCollection new.	extraAttributes := OrderedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNodeClassDefinition class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="named:grammar:">named: aSymbol grammar: aSmaCCGrammar 	^(self new)		name: aSymbol;		grammar: aSmaCCGrammar;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>compiling-scanner</category><body package="SmaCC Development" selector="acceptCharacterEdge:seen:">acceptCharacterEdge: aSmaCCCharacterEdge seen: aCollection	| stream |	stream := WriteStream with: String new.	aSmaCCCharacterEdge transitionObjects size + aCollection size &gt; SmaCCGrammar maximumCharacterValue		ifTrue: [^self trueValue].	stream nextPut: $(.	aSmaCCCharacterEdge transitionObjects size = SmaCCGrammar maximumCharacterValue		ifTrue: [self outputInvertedMatchFor: aSmaCCCharacterEdge on: stream]		ifFalse:			[self				outputMatchFor: aSmaCCCharacterEdge				seen: aCollection				on: stream].	stream nextPut: $).	^stream contents</body><body package="SmaCC Development" selector="acceptStateEdge:">acceptStateEdge: aSmaCCStateEdge	self subclassResponsibility</body><body package="SmaCC Development" selector="asStatement:forNode:lastNeedsReturn:">asStatement: methodMap forNode: aSmaCCNode lastNeedsReturn: aBoolean	| transitions seen |	aSmaCCNode hasSimpleLoop ifTrue: [self nextPutLine: self startDoWhileLoop].	self writeMatchingCodeFor: aSmaCCNode.	transitions := self sortedTransitionsForNode: aSmaCCNode.	seen := Set new.	transitions		do:			[:each | 			each to = aSmaCCNode				ifTrue: [self nextPutStatement: (self endDoWhileLoopWithClause: (each dispatchTo: self seen: seen))]				ifFalse:					[self nextPutLine: (self startIfWithClause: (each dispatchTo: self seen: seen)).					(methodMap at: each to ifAbsent: [nil])						ifNil:							[self								asStatement: methodMap								forNode: each to								lastNeedsReturn: each ~= transitions last]						ifNotNil: [:methodCall | self nextPutStatement: (self return: (self send: methodCall to: self receiverName))].					self nextPutStatement: self endConditionalString].			seen addAll: each transitionObjects].	(aBoolean and: [aSmaCCNode transitions notEmpty or: [aSmaCCNode action isNil]])		ifTrue: [self nextPutStatement: (self return: (self send: #reportLastMatch to: self receiverName))]</body><body package="SmaCC Development" selector="closestIsExpressionsFor:seen:">closestIsExpressionsFor: aSmaCCCharacterEdge seen: anObject	self subclassResponsibility</body><body package="SmaCC Development" selector="compileEmptySymbolTokenId:">compileEmptySymbolTokenId: emptySymbolId 	self compileTokenIdMethodNamed: 'emptySymbolToken' withId: emptySymbolId</body><body package="SmaCC Development" selector="compileErrorSymbolTokenId:">compileErrorSymbolTokenId: errorTokenId	self compileTokenIdMethodNamed: 'errorToken' withId: errorTokenId</body><body package="SmaCC Development" selector="compileIgnoreCaseMethods">compileIgnoreCaseMethods	self grammar ignoreCase ifFalse: [^self].	self		startPublicOverrideMethod;		nextPutLine:				(self						method: #keywordFor:						type: self stringType						argumentName: 'aString'						argumentType: self stringType);		nextPutStatement: (self return: (self uppercaseString: 'aString'));		endMethod;		compileMethodIn: scannerClass</body><body package="SmaCC Development" selector="compileKeywordInitializerUsing:">compileKeywordInitializerUsing: keywordMapDictionary 	self subclassResponsibility</body><body package="SmaCC Development" selector="compileMethodIn:">compileMethodIn: modelClass	self compileMethodWithoutFormattingIn: modelClass</body><body package="SmaCC Development" selector="compileNode:">compileNode: aSmaCCNode	| methodNodes methodMap |	methodNodes := self statesToMakeIntoMethodsFor: aSmaCCNode.	methodMap := self methodNameMap: aSmaCCNode forMethods: methodNodes.	methodNodes		do:			[:each | 			each = aSmaCCNode ifTrue: [self startProtectedOverrideMethod] ifFalse: [self startProtectedVirtualMethod].			self nextPutLine: (self method: (methodMap at: each) type: (model classFor: SmaCCToken) name).			self				asStatement: methodMap				forNode: each				lastNeedsReturn: true.			self endMethod.			self compileOptimizedMethodIn: scannerClass]</body><body package="SmaCC Development" selector="compilePostCopyMethod:">compilePostCopyMethod: aSmaCCNodeClassDefinition	aSmaCCNodeClassDefinition variableDefinitions isEmpty ifTrue: [^self].	self		startPublicOverrideMethod;		nextPutLine: (self method: 'postCopy' type: self voidType);		nextPutStatement: (self superMessage: 'postCopy').	aSmaCCNodeClassDefinition variableDefinitions		do:			[:each | 			| copySelector |			self				possiblyGuardNil: each				around:					[copySelector := each isPossibleNodeCollectionType ifTrue: [#copyNodeCollection:] ifFalse: [#copyNode:].					self						nextPutStatement:							(self								send: each setterMethodName								to: self receiverName								with:									(self cast: (self perform: copySelector with: (self send: each getterMethodName to: self receiverName)) to: each type name))]].	self		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compileStartingStateIds:">compileStartingStateIds: startingStates	startingStates		keysAndValuesDo:			[:symbol :position | 			self				startStaticMethod;				nextPutLine: (self method: 'startingStateFor' , symbol compileName type: self unsignedShort);				nextPutStatement: (self return: position printString);				endMethod;				compileMethodIn: parserClass metaclass]</body><body package="SmaCC Development" selector="compileSymbolTypes">compileSymbolTypes	| names |	names := grammar symbols		collect:			[:each | 			| types |			types := each modelTypes.			types remove: (self model classFor: nil class) ifAbsent: [].			(self commonSupertypeOf: types) name].	self compileSymbolTypes: names asArray</body><body package="SmaCC Development" selector="compileSymbolTypes:">compileSymbolTypes: anArray</body><body package="SmaCC Development" selector="compileTokenIdMethodNamed:withId:">compileTokenIdMethodNamed: aString withId: symbolId	self		startPublicOverrideMethod;		nextPutLine: (self method: aString , 'Id' type: self unsignedShort);		nextPutStatement: (self return: symbolId printString);		endMethod;		compileMethodIn: scannerClass</body><body package="SmaCC Development" selector="defineClass:asSubclassOf:">defineClass: aString asSubclassOf: aSmaCCClass	self subclassResponsibility</body><body package="SmaCC Development" selector="glrParserClass:">glrParserClass: aClassOrString	| name existingClass superclass |	name := (aClassOrString isKindOf: Behavior) ifTrue: [aClassOrString fullName] ifFalse: [aClassOrString].	superclass := SmaCCGLRParser.	existingClass := Smalltalk at: name ifAbsent: [nil].	(existingClass notNil and: [existingClass superclass includesBehavior: superclass])		ifTrue: [superclass := existingClass superclass].	parserClass := self defineClass: name asSubclassOf: superclass</body><body package="SmaCC Development" selector="methodNameMap:forMethods:">methodNameMap: aSmaCCNode forMethods: methodNodes	| index methodMap |	methodMap := Dictionary new.	index := 0.	methodNodes		do:			[:value | 			methodMap				at: value				put: (value = aSmaCCNode ifTrue: [#scanForToken] ifFalse: ['scan' , (index := index + 1) printString])].	^methodMap</body><body package="SmaCC Development" selector="minMaxPairsFor:without:">minMaxPairsFor: aSmaCCCharacterEdge without: isSelectors	| start last pairs charsLeft |	charsLeft := aSmaCCCharacterEdge transitionObjects reject: [:ch | isSelectors anySatisfy: [:each | ch perform: each]].	pairs := OrderedCollection new.	charsLeft isEmpty ifTrue: [^pairs].	last := charsLeft first.	start := nil.	charsLeft		do:			[:each | 			last asInteger + 1 = each asInteger				ifFalse:					[start notNil ifTrue: [pairs add: (Array with: start with: last)].					start := each].			last := each].	pairs add: (Array with: start with: last).	^pairs</body><body package="SmaCC Development" selector="outputInvertedMatchFor:on:">outputInvertedMatchFor: aSmaCCCharacterEdge on: stream	self subclassResponsibility</body><body package="SmaCC Development" selector="outputIsSelector:on:">outputIsSelector: isSelector on: stream 	self subclassResponsibility</body><body package="SmaCC Development" selector="outputMatchFor:on:without:">outputMatchFor: aSmaCCCharacterEdge on: aStream without: aSelector 	self subclassResponsibility</body><body package="SmaCC Development" selector="outputMatchFor:seen:on:">outputMatchFor: aSmaCCCharacterEdge seen: aCollection on: stream	| isSelectors |	isSelectors := self closestIsExpressionsFor: aSmaCCCharacterEdge seen: aCollection.	isSelectors do: [:each | self outputIsSelector: each on: stream] separatedBy: [stream nextPutAll: ' or: ['].	self		outputMatchFor: aSmaCCCharacterEdge		on: stream		without: isSelectors</body><body package="SmaCC Development" selector="parserClass:">parserClass: aClassOrString	| name existingClass superclass |	name := (aClassOrString isKindOf: Behavior) ifTrue: [aClassOrString fullName] ifFalse: [aClassOrString].	superclass := SmaCCParser.	existingClass := Smalltalk at: name ifAbsent: [nil].	(existingClass notNil and: 			[(existingClass superclass includesBehavior: superclass)				and: [(existingClass includesBehavior: SmaCCGLRParser) not]])		ifTrue: [superclass := existingClass superclass].	parserClass := self defineClass: name asSubclassOf: superclass</body><body package="SmaCC Development" selector="possiblyGuardNil:around:">possiblyGuardNil: each around: aBlock	each isAlwaysAssigned		ifTrue: [aBlock value]		ifFalse:			[self nextPutLine: (self notNilCheckFor: (self variableReference: each in: self receiverName)).			aBlock ensure: [self nextPutStatement: self endConditionalString]]</body><body package="SmaCC Development" selector="scannerActionFor:">scannerActionFor: aString 	self subclassResponsibility</body><body package="SmaCC Development" selector="scannerClass:">scannerClass: aString 	self subclassResponsibility</body><body package="SmaCC Development" selector="selectorMap:">selectorMap: aDictionary 	self subclassResponsibility</body><body package="SmaCC Development" selector="sortedTransitionsForNode:">sortedTransitionsForNode: aSmaCCNode	^aSmaCCNode transitions		asSortedCollection:			[:a :b | 			a isCharacterTransition				and:					[b isCharacterTransition not						or:							[| aPairs bPairs |							aPairs := self minMaxPairsFor: a without: #().							bPairs := self minMaxPairsFor: b without: #().							aPairs size &lt; bPairs size								or:									[aPairs size = bPairs size										and:											[a transitionObjects size &lt; b transitionObjects size												or: [a transitionObjects size = b transitionObjects size and: [a &lt;= b]]]]]]]</body><body package="SmaCC Development" selector="statesToMakeIntoMethodsFor:">statesToMakeIntoMethodsFor: aSmaCCNode	| allStates incoming |	allStates := aSmaCCNode allStates.	incoming := Dictionary new.	allStates		do:			[:each | each transitions do: [:edge | each ~= edge to ifTrue: [(incoming at: edge to ifAbsentPut: [Set new]) add: each]]].	^(allStates asOrderedCollection		select: [:each | aSmaCCNode = each or: [each isTerminalNode not and: [(incoming at: each ifAbsent: [#()]) size &gt; 1]]])		asSortedCollection: [:a :b | a id &lt; b id]</body><body package="SmaCC Development" selector="writeMatchingCodeFor:">writeMatchingCodeFor: aSmaCCNode	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>compiling-parser</category><body package="SmaCC Development" selector="ambiguousTableEntryFor:">ambiguousTableEntryFor: aCollection	| entry |	entry := aCollection asArray.	^ambiguousActions		indexOf: entry		ifAbsent:			[ambiguousActions add: entry.			ambiguousActions size]</body><body package="SmaCC Development" selector="compileAcceptNodeMethodFor:rootNode:">compileAcceptNodeMethodFor: aSmaCCVisitorClassDefinition rootNode: aSmaCCClassDefinition	"Only needed if we are using a brain dead type system"</body><body package="SmaCC Development" selector="compileAmbiguousTransitions">compileAmbiguousTransitions	| stream |	ambiguousActions isEmpty ifTrue: [^self].	stream := self outputStream.	stream nextPutAll: self newUnsignedShortArrayArray.	ambiguousActions do: 			[:each | 			self 				writeTransitionTableEntry: each				on: stream				firstIsType: false]		separatedBy: [stream nextPutAll: self literalArraySeparator].	stream		cr;		tab;		nextPutAll: self endLiteralArray.	self		startPublicOverrideMethod;		nextPutLine: (self method: 'ambiguousTransitions' type: self unsignedShortArrayArray);		nextPutStatement: (self return: stream contents);		endMethod;		compileMethodWithoutFormattingIn: parserClass</body><body package="SmaCC Development" selector="compileReductionActions">compileReductionActions</body><body package="SmaCC Development" selector="compileTransitionTable:">compileTransitionTable: transitionTable	| stream |	stream := self outputStream.	stream nextPutAll: self newUnsignedShortArrayArray.	transitionTable		do:			[:each | 			self				writeTransitionTableEntry: each				on: stream				firstIsType: true]		separatedBy: [stream nextPutAll: self literalArraySeparator].	stream		cr;		tab;		nextPutAll: self endLiteralArray.	self		startPublicOverrideMethod;		nextPutLine: (self method: 'transitionTable' type: self unsignedShortArrayArray);		nextPutStatement: (self return: stream contents);		endMethod;		compileMethodWithoutFormattingIn: parserClass.	self compileAmbiguousTransitions</body><body package="SmaCC Development" selector="initializeArrayContentsToNull:">initializeArrayContentsToNull: aSmaCCRHS</body><body package="SmaCC Development" selector="initializeResultForReduceAction:">initializeResultForReduceAction: aSmaCCRHS	^self newArrayOfSize: aSmaCCRHS productionSymbol variableDefinitions size</body><body package="SmaCC Development" selector="nextPut:">nextPut: aCharacter	self codeStream nextPut: aCharacter</body><body package="SmaCC Development" selector="processTransitionTable:">processTransitionTable: transitionTable	| table |	table := OrderedCollection new.	transitionTable do: [:each | table addLast: each].	^table</body><body package="SmaCC Development" selector="setGetterMethodNameTo:withName:">setGetterMethodNameTo: aSmaCCVariableDefinition withName: variableName	aSmaCCVariableDefinition getterMethodName: (self methodNameFor: variableName)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>private</category><body package="SmaCC Development" selector="addParentAssignmentFor:to:">addParentAssignmentFor: aSmaCCVariableDefinition to: valueString	aSmaCCVariableDefinition isBaseNodeType ifFalse: [^self].	aSmaCCVariableDefinition isCollection		ifTrue:			[self				nextPutStatement:					(self						send: #setParents:to:						to: self receiverName						with:							(self cast: (self variableReference: aSmaCCVariableDefinition in: self receiverName) to: self collectionType)						with: valueString)]		ifFalse:			[self nextPutLine: (self notNilCheckFor: (self variableReference: aSmaCCVariableDefinition in: self receiverName)).			self				nextPutStatement:					(self						send: #parent:						to: (self cast: (self variableReference: aSmaCCVariableDefinition in: self receiverName) to: 'ParseNode')						with: valueString).			self nextPutStatement: self endConditionalString]</body><body package="SmaCC Development" selector="addVariable:forDefinition:">addVariable: aSmaCCVariableDefinition forDefinition: aSmaCCNodeClassDefinition	self subclassResponsibility</body><body package="SmaCC Development" selector="codeStream">codeStream	codeStream isNil ifTrue: [codeStream := self outputStream].	^codeStream</body><body package="SmaCC Development" selector="compileAcceptVisitorMethod:visitor:">compileAcceptVisitorMethod: aSmaCCNodeClassDefinition visitor: aSmaCCVisitorClassDefinition	aSmaCCNodeClassDefinition isRoot ifTrue: [self startPublicVirtualMethod] ifFalse: [self startPublicOverrideMethod].	self		nextPutLine:				(self						method: #acceptVisitor:						type: self objectType						argumentName: aSmaCCNodeClassDefinition tempNodeName , 'Visitor'						argumentType: aSmaCCVisitorClassDefinition fullName);		nextPutStatement:				(self						return:							(self								send: 'visit' , aSmaCCNodeClassDefinition name , ':'								to: aSmaCCNodeClassDefinition tempNodeName , 'Visitor'								with: self receiverName));		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="defaultNodeReductionSource:">defaultNodeReductionSource: aReduction	self subclassResponsibility</body><body package="SmaCC Development" selector="endMethod">endMethod	self codeStream nextPutAll: self endMethodString</body><body package="SmaCC Development" selector="keywords">keywords	^#()</body><body package="SmaCC Development" selector="methodNameFor:">methodNameFor: aString	^aString</body><body package="SmaCC Development" selector="model">model	^model</body><body package="SmaCC Development" selector="nextPutLine:">nextPutLine: aString	(self codeStream)		nextPutAll: aString;		cr</body><body package="SmaCC Development" selector="nextPutStatement:">nextPutStatement: aString	(self codeStream)		nextPutAll: aString;		nextPutAll: self statementSeparator;		cr</body><body package="SmaCC Development" selector="nodeType">nodeType	^(model classFor: SmaCCParseNode) name</body><body package="SmaCC Development" selector="nonKeywordNameFor:">nonKeywordNameFor: aString	| word |	word := aString.	[self keywords includes: word] whileTrue: [word := '_' , word].	^word</body><body package="SmaCC Development" selector="outputStream">outputStream	^self outputStreamClass with: String new</body><body package="SmaCC Development" selector="parseSourceSelector">parseSourceSelector	^self class parseSourceSelector</body><body package="SmaCC Development" selector="removeOldMethodsFrom:">removeOldMethodsFrom: aRBClass	self subclassResponsibility</body><body package="SmaCC Development" selector="resetCodeStream">resetCodeStream	codeStream := nil</body><body package="SmaCC Development" selector="send:to:">send: selector to: aString	self subclassResponsibility</body><body package="SmaCC Development" selector="startProtectedOverrideMethod">startProtectedOverrideMethod	self resetCodeStream.	(self codeStream)		nextPutAll: self protected;		nextPutAll: self override</body><body package="SmaCC Development" selector="startProtectedVirtualMethod">startProtectedVirtualMethod	self resetCodeStream.	(self codeStream)		nextPutAll: self protected;		nextPutAll: self virtual</body><body package="SmaCC Development" selector="startPublicOverrideMethod">startPublicOverrideMethod	self resetCodeStream.	(self codeStream)		nextPutAll: self public;		nextPutAll: self override</body><body package="SmaCC Development" selector="startPublicVirtualMethod">startPublicVirtualMethod	self resetCodeStream.	(self codeStream)		nextPutAll: self public;		nextPutAll: self virtual</body><body package="SmaCC Development" selector="startStaticMethod">startStaticMethod	self resetCodeStream.	self codeStream nextPutAll: self static</body><body package="SmaCC Development" selector="startStaticPrivateMethod">startStaticPrivateMethod	self resetCodeStream.	(self codeStream)		nextPutAll: self static;		nextPutAll: self private</body><body package="SmaCC Development" selector="writeTransitionTableEntry:on:firstIsType:">writeTransitionTableEntry: anArray on: aStream firstIsType: aBoolean	self subclassResponsibility</body><body package="SmaCC Development" selector="writeTransitionTableMethod:withIndex:withArray:">writeTransitionTableMethod: stream withIndex: index withArray: array	self		startStaticPrivateMethod;		nextPutLine:				(self						method: 'transitionTable' , index printString						type: self voidType						argumentName: array						argumentType: self unsignedShortArrayArray);		nextPutStatement: stream contents;		endMethod;		compileMethodWithoutFormattingIn: parserClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>code generation templates</category><body package="SmaCC Development" selector="argumentIndex:">argumentIndex: anInteger	^self at: 'nodes' index: anInteger</body><body package="SmaCC Development" selector="argumentIndex:subIndex:">argumentIndex: anInteger subIndex: subIndex	^self at: (self cast: (self argumentIndex: anInteger) to: self collectionType) index: subIndex</body><body package="SmaCC Development" selector="comment:">comment: aString	self subclassResponsibility</body><body package="SmaCC Development" selector="doesNotUnderstand:">doesNotUnderstand: failedMessage	"Use the code templates to expand the string."	^(self class codeTemplates at: failedMessage selector ifAbsent: [^super doesNotUnderstand: failedMessage])		expandMacrosWithArguments: failedMessage arguments</body><body package="SmaCC Development" selector="endIteratorString">endIteratorString	^self endConditionalString</body><body package="SmaCC Development" selector="method:type:">method: aString type: typeString	self subclassResponsibility</body><body package="SmaCC Development" selector="method:type:argumentName:argumentType:">method: aString type: anObject argumentName: argumentNameString argumentType: argumentTypeString	self subclassResponsibility</body><body package="SmaCC Development" selector="method:type:argumentName:argumentType:argumentName:argumentType:">method: aString type: anObject argumentName: firstArgumentNameString argumentType: firstArgumentTypeString argumentName: secondArgumentNameString argumentType: secondArgumentTypeString	self subclassResponsibility</body><body package="SmaCC Development" selector="reduceAction:">reduceAction: anArray	self subclassResponsibility</body><body package="SmaCC Development" selector="send:to:with:">send: selectorString to: receiverString with: argumentString	self subclassResponsibility</body><body package="SmaCC Development" selector="send:to:with:with:">send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString	self subclassResponsibility</body><body package="SmaCC Development" selector="send:to:with:with:with:">send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString with: thirdArgumentString	self subclassResponsibility</body><body package="SmaCC Development" selector="superMessage:">superMessage: aString	self subclassResponsibility</body><body package="SmaCC Development" selector="superMessage:argument:">superMessage: aString argument: argumentString	self subclassResponsibility</body><body package="SmaCC Development" selector="superMessage:argument:argument:">superMessage: aString argument: firstArgumentString argument: secondArgumentString	self subclassResponsibility</body><body package="SmaCC Development" selector="variableReference:">variableReference: aSmaCCVariableDefinition	^self nonKeywordNameFor: aSmaCCVariableDefinition sourceVariableName</body><body package="SmaCC Development" selector="variableReference:in:">variableReference: aSmaCCVariableDefinition in: aString	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>compiling</category><body package="SmaCC Development" selector="compileChanges">compileChanges	self subclassResponsibility</body><body package="SmaCC Development" selector="compileDefinitionComment:">compileDefinitionComment: aString	self		startPublicVirtualMethod;		nextPutLine: (self method: #definitionComment type: self voidType);		nextPutLine: (self comment: aString);		endMethod.	self compileMethodWithoutFormattingIn: parserClass metaclass</body><body package="SmaCC Development" selector="compileMethodWithoutFormattingIn:">compileMethodWithoutFormattingIn: modelClass	self subclassResponsibility</body><body package="SmaCC Development" selector="compileNodeClassDefinition:">compileNodeClassDefinition: aSmaCCClassDefinition	| class |	class := self		defineClass: aSmaCCClassDefinition fullName		asSubclassOf: (self model referencedItem: aSmaCCClassDefinition superclassName asSymbol).	aSmaCCClassDefinition modelClass: class.	self removeOldMethodsFrom: class.	self removeOldMethodsFrom: class metaclass</body><body package="SmaCC Development" selector="compileOptimizedMethodIn:">compileOptimizedMethodIn: modelClass	self compileMethodIn: modelClass</body><body package="SmaCC Development" selector="compileReductionTable:">compileReductionTable: reductionTable 	| stream |	stream := self outputStream.	stream nextPutAll: self reduceActionLiteralStart.	reductionTable do: 			[:each | 			stream				cr;				tab;				nextPutAll: (self reduceAction: each)]		separatedBy: [stream nextPutAll: self literalArraySeparator].	stream		cr;		tab;		nextPutAll: self endLiteralArray.	self		startProtectedOverrideMethod;		nextPutLine: (self method: 'reduceTable' type: self reduceActionArrayType);		nextPutStatement: (self return: stream contents);		endMethod;		compileMethodWithoutFormattingIn: parserClass</body><body package="SmaCC Development" selector="compileScannerClassIntoParser">compileScannerClassIntoParser	self subclassResponsibility</body><body package="SmaCC Development" selector="outputStreamClass">outputStreamClass	self subclassResponsibility</body><body package="SmaCC Development" selector="parserClass">parserClass	^parserClass</body><body package="SmaCC Development" selector="removeOldMethods">removeOldMethods	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>compiling-nodes</category><body package="SmaCC Development" selector="compileChildrenMethod:">compileChildrenMethod: aSmaCCNodeClassDefinition	aSmaCCNodeClassDefinition nodeVariableDefinitions isEmpty ifTrue: [^self].	self		startPublicOverrideMethod;		nextPutLine: (self method: 'children' type: self collectionType);		nextPutLine: (self variableDeclaration: 'children' ofType: self collectionType);		nextPutStatement: (self assignmentTo: 'children' from: (self superMessage: 'children')).	aSmaCCNodeClassDefinition nodeVariableDefinitions		do:			[:each | 			each isAlwaysAssigned				ifFalse: [self nextPutLine: (self notNilCheckFor: (self variableReference: each in: self receiverName))].			each isCollection				ifTrue:					[each isNodeCollectionType						ifTrue:							[self nextPutStatement: (self addAllSendTo: 'children' with: (self variableReference: each in: self receiverName))]						ifFalse:							[self								nextPutLine: (self iterateObjects: (self variableReference: each in: self receiverName) name: 'each');								nextPutLine: (self isKindOfTest: 'each' class: aSmaCCNodeClassDefinition grammar rootDefinition fullName);								nextPutLine: (self addSendTo: 'children' with: 'each');								nextPutLine: self endConditionalString;								nextPutStatement: self endIteratorString]]				ifFalse:					[each isNodeType						ifFalse:							[self								nextPutLine:									(self										isKindOfTest: (self variableReference: each in: self receiverName)										class: aSmaCCNodeClassDefinition grammar rootDefinition fullName)].					self nextPutStatement: (self addSendTo: 'children' with: (self variableReference: each in: self receiverName)).					each isNodeType ifFalse: [self nextPutStatement: self endConditionalString]].			each isAlwaysAssigned ifFalse: [self nextPutStatement: self endConditionalString]].	self		nextPutStatement: (self return: 'children');		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compileCopyInContextMethod:">compileCopyInContextMethod: aSmaCCNodeClassDefinition	aSmaCCNodeClassDefinition nodeVariableDefinitions isEmpty ifTrue: [^self].	self		startPublicOverrideMethod;		nextPutLine:				(self						method: #copyInContext:						type: 'ParseNode'						argumentName: 'aDictionary'						argumentType: self dictionaryType);		nextPutLine: (self variableDeclaration: aSmaCCNodeClassDefinition copyName ofType: aSmaCCNodeClassDefinition fullName);		nextPutStatement:				(self						assignmentTo: aSmaCCNodeClassDefinition copyName						from: (self cast: (self superMessage: #copyInContext: argument: 'aDictionary') to: aSmaCCNodeClassDefinition fullName)).	aSmaCCNodeClassDefinition nodeVariableDefinitions		do:			[:each | 			self				possiblyGuardNil: each				around:					[each isPossibleNodeType						ifTrue:							[each isNodeType								ifFalse:									[self										nextPutLine:											(self isKindOfTest: (self variableReference: each in: self receiverName) class: (model classFor: SmaCCParseNode) name)].							self								nextPutStatement:									(self										send: each setterMethodName										to: aSmaCCNodeClassDefinition copyName										with:											(self												cast:													(self														send: #copyInContext:														to: (self variableReference: each in: self receiverName)														with: 'aDictionary')												to: each type name)).							each isNodeType ifFalse: [self nextPutStatement: self endConditionalString]]						ifFalse:							[self								nextPutStatement:									(self										send: each setterMethodName										to: aSmaCCNodeClassDefinition copyName										with:											(self												copy: (self variableReference: each in: self receiverName)												inContext: 'aDictionary'												onlyNodes: each isNodeCollectionType))]]].	self		nextPutStatement: (self return: aSmaCCNodeClassDefinition copyName);		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compileEqualMethod:">compileEqualMethod: aSmaCCNodeClassDefinition	aSmaCCNodeClassDefinition variableDefinitions isEmpty ifTrue: [^self].	self		startPublicOverrideMethod;		nextPutLine:				(self						method: '='						type: self booleanType						argumentName: 'anObject'						argumentType: self objectType);		nextPutStatement: (self ifFalseReturn: (self superMessage: '=' argument: 'anObject')).	aSmaCCNodeClassDefinition variableDefinitions		do:			[:each | 			self				nextPutStatement:					(self						ifFalseReturn:							(self								compareEqual: (self variableReference: each in: self receiverName)								to: (self variableReference: each in: (self cast: 'anObject' to: aSmaCCNodeClassDefinition fullName))))].	self		nextPutStatement: (self return: self trueValue);		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compileGetterAndSetter:forDefinition:">compileGetterAndSetter: aSmaCCVariableDefinition forDefinition: aSmaCCNodeClassDefinition	| type typeName variableName |	variableName := self nonKeywordNameFor: aSmaCCVariableDefinition sourceVariableName.	type := aSmaCCVariableDefinition type.	self setGetterMethodNameTo: aSmaCCVariableDefinition withName: variableName.	(aSmaCCNodeClassDefinition modelClass definesMethod: variableName asSymbol)		ifFalse:			[self				startPublicVirtualMethod;				nextPutLine: (self method: aSmaCCVariableDefinition getterMethodName type: type name);				nextPutStatement: (self return: (self variableReference: aSmaCCVariableDefinition));				endMethod;				compileMethodIn: aSmaCCNodeClassDefinition modelClass].	aSmaCCVariableDefinition setterMethodName: variableName , ':'.	(aSmaCCNodeClassDefinition modelClass definesMethod: aSmaCCVariableDefinition setterMethodName asSymbol)		ifTrue: [^self].	typeName := aSmaCCNodeClassDefinition temporaryNameFor: type name.	self		startPublicVirtualMethod;		nextPutLine:				(self						method: aSmaCCVariableDefinition setterMethodName						type: self voidType						argumentName: typeName						argumentType: type name);		addParentAssignmentFor: aSmaCCVariableDefinition to: self undefinedObject;		nextPutStatement: (self assignmentTo: variableName from: typeName);		addParentAssignmentFor: aSmaCCVariableDefinition to: self receiverName;		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compileHashMethod:">compileHashMethod: aSmaCCNodeClassDefinition	| hashString |	aSmaCCNodeClassDefinition variableDefinitions isEmpty ifTrue: [^self].	hashString := aSmaCCNodeClassDefinition variableDefinitions		inject: (self superMessage: 'hash')		into: [:sum :each | self bitXor: sum with: (self hashFor: (self variableReference: each in: self receiverName))].	self		startPublicOverrideMethod;		nextPutLine: (self method: 'hash' type: self integerType);		nextPutStatement: (self return: hashString);		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compileInitializeMethod:">compileInitializeMethod: aSmaCCNodeClassDefinition	self subclassResponsibility</body><body package="SmaCC Development" selector="compileMatchInContextMethod:">compileMatchInContextMethod: aSmaCCNodeClassDefinition	aSmaCCNodeClassDefinition nodeVariableDefinitions isEmpty ifTrue: [^self].	self		startPublicOverrideMethod;		nextPutLine:				(self						method: #match:inContext:						type: self booleanType						argumentName: aSmaCCNodeClassDefinition tempNodeName						argumentType: self nodeType						argumentName: 'aDictionary'						argumentType: self dictionaryType);		nextPutStatement:				(self						ifFalseReturn:							(self								superMessage: #match:inContext:								argument: aSmaCCNodeClassDefinition tempNodeName								argument: 'aDictionary')).	aSmaCCNodeClassDefinition nodeVariableDefinitions		do:			[:each | 			self				possiblyGuardNil: each				around:					[each isPossibleNodeType						ifTrue:							[each isNodeType								ifFalse:									[self nextPutLine: (self isKindOfTest: (self variableReference: each in: self receiverName) class: self nodeType)].							self								nextPutStatement:									(self										ifFalseReturn:											(self												send: #match:inContext:												to: (self variableReference: each in: self receiverName)												with:													(self variableReference: each in: (self cast: aSmaCCNodeClassDefinition tempNodeName to: aSmaCCNodeClassDefinition fullName))												with: 'aDictionary')).							each isNodeType ifFalse: [self nextPutStatement: self endConditionalString]]						ifFalse:							[self								nextPutStatement:									(self										ifFalseReturn:											(self												send: #matchCollection:to:inContext:												to: self receiverName												with: (self variableReference: each in: self receiverName)												with:													(self variableReference: each in: (self cast: aSmaCCNodeClassDefinition tempNodeName to: aSmaCCNodeClassDefinition fullName))												with: 'aDictionary'))]]].	self		nextPutStatement: (self return: self trueValue);		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compileVariablesMethods:">compileVariablesMethods: aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="compileVisitMethodFor:visitor:">compileVisitMethodFor: aSmaCCNodeClassDefinition visitor: aSmaCCVisitorClassDefinition	| tempName |	self compileAcceptVisitorMethod: aSmaCCNodeClassDefinition visitor: aSmaCCVisitorClassDefinition.	tempName := aSmaCCNodeClassDefinition temporaryVariableName.	self		startPublicVirtualMethod;		nextPutLine:				(self						method: 'visit' , aSmaCCNodeClassDefinition name , ':'						type: self objectType						argumentName: tempName						argumentType: aSmaCCNodeClassDefinition fullName).	self		nextPutStatement:				(self						return:							(self								send:									(aSmaCCNodeClassDefinition superclass notNil										ifTrue: ['visit' , aSmaCCNodeClassDefinition superclass name , ':']										ifFalse: ['visitSmaCCParseNode:'])								to: self receiverName								with: tempName));		endMethod;		compileMethodIn: aSmaCCVisitorClassDefinition modelClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>reduction table</category><body package="SmaCC Development" selector="assignVariable:in:at:">assignVariable: variableName in: aSmaCCRHS at: key	| variableIndex value |	variableIndex := aSmaCCRHS productionSymbol indexOfVariable: variableName.	value := self argumentIndex: key.	self		nextPutStatement:			((aSmaCCRHS productionSymbol isCollection: variableName)				ifTrue: [self addSendTo: (self cast: (self at: 'result' index: variableIndex) to: self collectionType) with: value]				ifFalse:					[self						assignArray: 'result'						index: variableIndex						to: value])</body><body package="SmaCC Development" selector="basicCompileSourceFor:">basicCompileSourceFor: aSmaCCReduceAction	self subclassResponsibility</body><body package="SmaCC Development" selector="compileSourceFor:">compileSourceFor: aSmaCCReduceAction	^reduceActionCache at: aSmaCCReduceAction ifAbsentPut: [self basicCompileSourceFor: aSmaCCReduceAction]</body><body package="SmaCC Development" selector="createNodeReduceAction:">createNodeReduceAction: aSmaCCRHS 	^self createNodeReduceAction: aSmaCCRHS pullUpFrom: 0.</body><body package="SmaCC Development" selector="createNodeReduceAction:pullUpFrom:">createNodeReduceAction: aSmaCCRHS pullUpFrom: anInteger	self resetCodeStream.	self nextPutLine: (self variableDeclaration: 'result' ofType: aSmaCCRHS modelType name).	self		nextPutStatement:			(self				assignmentTo: 'result'				from:					(anInteger isZero						ifTrue: [self newObject: aSmaCCRHS modelType name]						ifFalse: [self cast: (self argumentIndex: anInteger) to: aSmaCCRHS modelType name])).	SmaCCReduceActionGenerator		generate: aSmaCCRHS		pullUp: anInteger		on: self.	self nextPutStatement: (self return: 'result').	^self codeStream contents</body><body package="SmaCC Development" selector="createVariableArrayFor:">createVariableArrayFor: aSmaCCRHS	self nextPutLine: (self variableDeclaration: 'result' ofType: self arrayType).	self nextPutStatement: (self assignmentTo: 'result' from: (self initializeResultForReduceAction: aSmaCCRHS)).	self initializeArrayContentsToNull: aSmaCCRHS.	aSmaCCRHS productionSymbol collectionVariableDefinitions		do:			[:each | 			self				nextPutStatement:					(self						assignArray: 'result'						index: each index						to: (self newCollectionOfSize: 2))]</body><body package="SmaCC Development" selector="defaultReductionSource">defaultReductionSource	self subclassResponsibility</body><body package="SmaCC Development" selector="pullUpNodeVariablesFrom:into:index:">pullUpNodeVariablesFrom: aSmaCCSymbol into: aSmaCCRHS index: anInteger	aSmaCCSymbol nodeType		ifNotNil:			[:value | 			aSmaCCSymbol variableDefinitions				do:					[:each | 					| collectionGetter variableGetter variableIndex |					variableIndex := aSmaCCRHS productionSymbol indexOfVariable: each variableName.					collectionGetter := value collectionGetterForVariableName: each variableName.					variableGetter := value objectGetterForVariableName: each variableName.					self						nextPutStatement:							((aSmaCCRHS productionSymbol isCollection: each variableName)								ifTrue:									[self										addAllSendTo: (self cast: (self at: 'result' index: variableIndex) to: self collectionType)										with:											(self												collectionVariableItemsIn: (self argumentIndex: anInteger)												forCollectionGetter: collectionGetter												andVariableGetter: variableGetter)]								ifFalse:									[self										assignArray: 'result'										index: variableIndex										to: (self variableItemIn: (self argumentIndex: anInteger) forVariableGetter: variableGetter)])]]</body><body package="SmaCC Development" selector="pullUpVariablesFrom:into:index:">pullUpVariablesFrom: aSmaCCSymbol into: aSmaCCRHS index: anInteger	aSmaCCSymbol variableDefinitions		do:			[:each | 			| variableValue rhsIndex |			variableValue := self argumentIndex: anInteger subIndex: (aSmaCCSymbol indexOfVariable: each variableName).			rhsIndex := aSmaCCRHS productionSymbol indexOfVariable: each variableName.			self				nextPutStatement:					((aSmaCCRHS productionSymbol isCollection: each variableName)						ifTrue:							[| collectionValue |							collectionValue := self cast: (self at: 'result' index: rhsIndex) to: self collectionType.							(aSmaCCSymbol isCollection: each variableName)								ifTrue: [self addAllSendTo: collectionValue with: (self cast: variableValue to: self collectionType)]								ifFalse: [self addSendTo: collectionValue with: variableValue]]						ifFalse:							[self								assignArray: 'result'								index: rhsIndex								to: variableValue])]</body><body package="SmaCC Development" selector="variableArrayAction:">variableArrayAction: aSmaCCRHS	self resetCodeStream.	self createVariableArrayFor: aSmaCCRHS.	aSmaCCRHS collection		keysAndValuesDo:			[:key :value | 			| variableName |			variableName := aSmaCCRHS variableNameForIndex: key.			variableName isNil				ifTrue:					[value isNode						ifTrue:							[self								pullUpNodeVariablesFrom: value								into: aSmaCCRHS								index: key]						ifFalse:							[self								pullUpVariablesFrom: value								into: aSmaCCRHS								index: key]]				ifFalse:					[self						assignVariable: variableName						in: aSmaCCRHS						at: key]].	self nextPutStatement: (self return: 'result').	self nextPutLine: ''.	^self codeStream contents</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	reduceActionCache := Dictionary new.	ambiguousActions := OrderedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator</class-id> <category>accessing</category><body package="SmaCC Development" selector="commonSupertypeBetween:and:">commonSupertypeBetween: modelClass and: anotherModelClass	^(anotherModelClass includesClass: modelClass)		ifTrue: [modelClass]		ifFalse:			[(modelClass includesClass: anotherModelClass)				ifTrue: [anotherModelClass]				ifFalse: [self commonSupertypeBetween: modelClass superclass and: anotherModelClass]]</body><body package="SmaCC Development" selector="commonSupertypeOf:">commonSupertypeOf: aCollection 	aCollection isEmpty ifTrue: [^model classFor: Object].	^aCollection inject: (aCollection detect: [:each | true])		into: [:sum :each | self commonSupertypeBetween: sum and: each]</body><body package="SmaCC Development" selector="grammar">grammar	^grammar</body><body package="SmaCC Development" selector="grammar:">grammar: aSmaCCGrammar	grammar := aSmaCCGrammar</body><body package="SmaCC Development" selector="namespaceName">namespaceName	^''</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator class</class-id> <category>code generation templates</category><body package="SmaCC Development" selector="codeTemplates">codeTemplates	^codeTemplates		ifNil:			[codeTemplates := IdentityDictionary new.			self codeTemplatesArray do: [:each | codeTemplates at: each first put: each last].			codeTemplates]</body><body package="SmaCC Development" selector="codeTemplatesArray">codeTemplatesArray	^#(		#(#override '')		#(#trueValue 'true')	)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator class</class-id> <category>accessing</category><body package="SmaCC Development" selector="parseSourceSelector">parseSourceSelector	self subclassResponsibility</body><body package="SmaCC Development" selector="typeName">typeName	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCodeGenerator class</class-id> <category>class initialization</category><body package="SmaCC Development" selector="reset">reset	"self reset"	codeTemplates := nil.	self allSubclassesDo: [:each | each reset]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionScanner</class-id> <category>generated</category><body package="SmaCC Development" selector="classLeftId">classLeftId	^39</body><body package="SmaCC Development" selector="classRightId">classRightId	^40</body><body package="SmaCC Development" selector="codeId">codeId	^29</body><body package="SmaCC Development" selector="directiveId">directiveId	^32</body><body package="SmaCC Development" selector="emptySymbolTokenId">emptySymbolTokenId	^84</body><body package="SmaCC Development" selector="errorTokenId">errorTokenId	^85</body><body package="SmaCC Development" selector="keywordId">keywordId	^27</body><body package="SmaCC Development" selector="productionId">productionId	^31</body><body package="SmaCC Development" selector="scan1">scan1	self recordMatch: #(31).	self step.	currentCharacter == $: ifTrue: [^self scan2].	^self reportLastMatch</body><body package="SmaCC Development" selector="scan10">scan10	[self step.	currentCharacter == $&gt; ifTrue: [^self recordAndReportMatch: #(25)].	currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue.	^self reportLastMatch</body><body package="SmaCC Development" selector="scan11">scan11	self recordMatch: #(26).	self step.	currentCharacter == $r ifTrue: [^self scan12].	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])		ifTrue:			[[self recordMatch: #(26).			self step.			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].	^self reportLastMatch</body><body package="SmaCC Development" selector="scan12">scan12	self recordMatch: #(26).	self step.	currentCharacter == $r		ifTrue:			[self recordMatch: #(26).			self step.			currentCharacter == $o				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $r						ifTrue:							[self recordMatch: #(7 26).							self step].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch]].	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])		ifTrue:			[[self recordMatch: #(26).			self step.			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].	^self reportLastMatch</body><body package="SmaCC Development" selector="scan13">scan13	[self step.	currentCharacter == $] ifTrue: [^self recordAndReportMatch: #(35)].	currentCharacter == $\ ifTrue: [^self scan14]] repeat</body><body package="SmaCC Development" selector="scan14">scan14	self step.	currentCharacter == $c		ifTrue:			[self step.			(currentCharacter between: $A and: $Z) ifTrue: [^self scan13].			^self reportLastMatch].	currentCharacter == $x		ifTrue:			[self step.			(currentCharacter isDigit or: [(currentCharacter between: $A and: $F) or: [currentCharacter between: $a and: $f]]) ifTrue: [^self scan13].			^self reportLastMatch].	^self scan13</body><body package="SmaCC Development" selector="scan15">scan15	[self step.	currentCharacter == $} ifTrue: [^self recordAndReportMatch: #(36)].	currentCharacter isDigit] whileTrue.	^self reportLastMatch</body><body package="SmaCC Development" selector="scan2">scan2	self step.	currentCharacter == $= ifTrue: [^self recordAndReportMatch: #(31)].	^self reportLastMatch</body><body package="SmaCC Development" selector="scan3">scan3	self step.	(currentCharacter isLetter or: [currentCharacter == $_]) ifTrue: [^self scan4].	^self reportLastMatch</body><body package="SmaCC Development" selector="scan4">scan4	[self step.	currentCharacter == $' ifTrue: [^self recordAndReportMatch: #(30)].	currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue.	^self reportLastMatch</body><body package="SmaCC Development" selector="scan5">scan5	[self step.	currentCharacter == $" ifTrue: [^self scan6]] repeat</body><body package="SmaCC Development" selector="scan6">scan6	self recordMatch: #(27).	self step.	currentCharacter == $" ifTrue: [^self scan5].	^self reportLastMatch</body><body package="SmaCC Development" selector="scan7">scan7	self step.	currentCharacter == $* ifTrue: [^self scan8].	^self reportLastMatch</body><body package="SmaCC Development" selector="scan8">scan8	[self step.	currentCharacter == $*		ifTrue:			[[self step.			currentCharacter == $*] whileTrue.			currentCharacter == $/ ifTrue: [^self recordAndReportMatch: #(28)].			^self scan8]] repeat</body><body package="SmaCC Development" selector="scan9">scan9	self step.	(currentCharacter isLetter or: [currentCharacter == $_]) ifTrue: [^self scan10].	^self reportLastMatch</body><body package="SmaCC Development" selector="scanForToken">scanForToken	state == #scanner		ifTrue:			[self step.			currentCharacter == Character newPage				ifTrue:					[self recordMatch: #(24 37).					self step.					((currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space])						ifTrue:							[[self recordMatch: #(24).							self step.							(currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space]] whileTrue].					^self reportLastMatch].			currentCharacter == $; ifTrue: [^self recordAndReportMatch: #(33 37)].			currentCharacter == $:				ifTrue:					[self recordMatch: #(31 37).					self step.					currentCharacter == $: ifTrue: [^self scan2].					^self reportLastMatch].			currentCharacter == $? ifTrue: [^self recordAndReportMatch: #(5 37)].			currentCharacter == $. ifTrue: [^self recordAndReportMatch: #(38)].			currentCharacter == $'				ifTrue:					[self recordMatch: #(37).					self step.					(currentCharacter isLetter or: [currentCharacter == $_]) ifTrue: [^self scan4].					^self reportLastMatch].			currentCharacter == $"				ifTrue:					[self recordMatch: #(37).					self step.					currentCharacter == $" ifTrue: [^self scan6].					^self scan5].			currentCharacter == $( ifTrue: [^self recordAndReportMatch: #(2)].			currentCharacter == $) ifTrue: [^self recordAndReportMatch: #(6 37)].			currentCharacter == $[				ifTrue:					[self step.					currentCharacter == $\ ifTrue: [^self scan14].					(currentCharacter &lt;= $[ or: [currentCharacter &gt;= $^]) ifTrue: [^self scan13].					^self reportLastMatch].			currentCharacter == ${				ifTrue:					[self recordMatch: #(29).					self step.					currentCharacter == $, ifTrue: [^self scan15].					currentCharacter isDigit						ifTrue:							[[self step.							currentCharacter == $, ifTrue: [^self scan15].							currentCharacter isDigit] whileTrue].					^self reportLastMatch].			currentCharacter == $* ifTrue: [^self recordAndReportMatch: #(3 37)].			currentCharacter == $/				ifTrue:					[self recordMatch: #(37).					self step.					currentCharacter == $* ifTrue: [^self scan8].					^self reportLastMatch].			currentCharacter == $\				ifTrue:					[self step.					currentCharacter == $c						ifTrue:							[self step.							(currentCharacter between: $A and: $Z) ifTrue: [^self recordAndReportMatch: #(34)].							^self reportLastMatch].					currentCharacter == $x						ifTrue:							[self step.							(currentCharacter isDigit or: [(currentCharacter between: $A and: $F) or: [currentCharacter between: $a and: $f]])								ifTrue:									[3										timesRepeat:											[self recordMatch: #(34).											self step.											(currentCharacter isDigit or: [(currentCharacter between: $A and: $F) or: [currentCharacter between: $a and: $f]])												ifFalse: [^self reportLastMatch]].									^self recordAndReportMatch: #(34)].							^self reportLastMatch].					^self recordAndReportMatch: #(34)].			currentCharacter == $#				ifTrue:					[self recordMatch: #(28 37).					self step.					(currentCharacter &lt;= Character tab						or: [(currentCharacter between: (Character value: 11) and: Character newPage) or: [currentCharacter &gt;= (Character value: 14)]])						ifTrue:							[[self recordMatch: #(28).							self step.							currentCharacter &lt;= Character tab								or: [(currentCharacter between: (Character value: 11) and: Character newPage) or: [currentCharacter &gt;= (Character value: 14)]]] whileTrue].					^self reportLastMatch].			currentCharacter == $% ifTrue: [^self recordAndReportMatch: #(32 37)].			currentCharacter == $+ ifTrue: [^self recordAndReportMatch: #(4 37)].			currentCharacter == $&lt;				ifTrue:					[self recordMatch: #(37).					self step.					(currentCharacter isLetter or: [currentCharacter == $_]) ifTrue: [^self scan10].					^self reportLastMatch].			currentCharacter == $| ifTrue: [^self recordAndReportMatch: #(1 37)].			currentCharacter == $e				ifTrue:					[self recordMatch: #(26 37).					self step.					currentCharacter == $r ifTrue: [^self scan12].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			((currentCharacter between: Character tab and: (Character value: 11))				or: [currentCharacter == Character cr or: [currentCharacter == Character space]])				ifTrue:					[[self recordMatch: #(24).					self step.					(currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space]] whileTrue.					^self reportLastMatch].			(currentCharacter isLetter or: [currentCharacter == $_])				ifTrue:					[self recordMatch: #(26 37).					self step.					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			^self recordAndReportMatch: #(37)].	state == #parser		ifTrue:			[self step.			currentCharacter == $; ifTrue: [^self recordAndReportMatch: #(33)].			currentCharacter == $: ifTrue: [^self scan1].			currentCharacter == $? ifTrue: [^self recordAndReportMatch: #(5)].			currentCharacter == $' ifTrue: [^self scan3].			currentCharacter == $" ifTrue: [^self scan5].			currentCharacter == $( ifTrue: [^self recordAndReportMatch: #(2)].			currentCharacter == $) ifTrue: [^self recordAndReportMatch: #(6)].			currentCharacter == ${				ifTrue:					[self recordMatch: #(29).					self step.					currentCharacter == ${ ifTrue: [^self recordAndReportMatch: #(39)].					^self reportLastMatch].			currentCharacter == $}				ifTrue:					[self step.					currentCharacter == $} ifTrue: [^self recordAndReportMatch: #(40)].					^self reportLastMatch].			currentCharacter == $* ifTrue: [^self recordAndReportMatch: #(3)].			currentCharacter == $/ ifTrue: [^self scan7].			currentCharacter == $#				ifTrue:					[[self recordMatch: #(28).					self step.					currentCharacter &lt;= Character tab						or: [(currentCharacter between: (Character value: 11) and: Character newPage) or: [currentCharacter &gt;= (Character value: 14)]]] whileTrue.					^self reportLastMatch].			currentCharacter == $% ifTrue: [^self recordAndReportMatch: #(32)].			currentCharacter == $+ ifTrue: [^self recordAndReportMatch: #(4)].			currentCharacter == $&lt; ifTrue: [^self scan9].			currentCharacter == $| ifTrue: [^self recordAndReportMatch: #(1)].			currentCharacter == $e ifTrue: [^self scan11].			((currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space])				ifTrue:					[[self recordMatch: #(24).					self step.					(currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space]] whileTrue.					^self reportLastMatch].			(currentCharacter isLetter or: [currentCharacter == $_])				ifTrue:					[[self recordMatch: #(26).					self step.					currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].			^self reportLastMatch].	state == #directives		ifTrue:			[self step.			currentCharacter == $; ifTrue: [^self recordAndReportMatch: #(33)].			currentCharacter == $: ifTrue: [^self scan1].			currentCharacter == $? ifTrue: [^self recordAndReportMatch: #(5)].			currentCharacter == $' ifTrue: [^self scan3].			currentCharacter == $" ifTrue: [^self scan5].			currentCharacter == $( ifTrue: [^self recordAndReportMatch: #(2)].			currentCharacter == $) ifTrue: [^self recordAndReportMatch: #(6)].			currentCharacter == ${ ifTrue: [^self recordAndReportMatch: #(29)].			currentCharacter == $* ifTrue: [^self recordAndReportMatch: #(3)].			currentCharacter == $/ ifTrue: [^self scan7].			currentCharacter == $#				ifTrue:					[[self recordMatch: #(28).					self step.					currentCharacter &lt;= Character tab						or: [(currentCharacter between: (Character value: 11) and: Character newPage) or: [currentCharacter &gt;= (Character value: 14)]]] whileTrue.					^self reportLastMatch].			currentCharacter == $% ifTrue: [^self recordAndReportMatch: #(32)].			currentCharacter == $+ ifTrue: [^self recordAndReportMatch: #(4)].			currentCharacter == $&lt; ifTrue: [^self scan9].			currentCharacter == $| ifTrue: [^self recordAndReportMatch: #(1)].			currentCharacter == $a				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $n						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $n								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $o										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $t												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $a														ifTrue:															[self recordMatch: #(26).															self step.															currentCharacter == $t																ifTrue:																	[self recordMatch: #(26).																	self step.																	currentCharacter == $e																		ifTrue:																			[self recordMatch: #(26).																			self step.																			currentCharacter == $_																				ifTrue:																					[self recordMatch: #(26).																					self step.																					currentCharacter == $t																						ifTrue:																							[self recordMatch: #(26).																							self step.																							currentCharacter == $o																								ifTrue:																									[self recordMatch: #(26).																									self step.																									currentCharacter == $k																										ifTrue:																											[self recordMatch: #(26).																											self step.																											currentCharacter == $e																												ifTrue:																													[self recordMatch: #(26).																													self step.																													currentCharacter == $n																														ifTrue:																															[self recordMatch: #(26).																															self step.																															currentCharacter == $s																																ifTrue:																																	[self recordMatch: #(23 26).																																	self step.																																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																																		ifTrue:																																			[[self recordMatch: #(26).																																			self step.																																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																																	^self reportLastMatch]].																													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																														ifTrue:																															[[self recordMatch: #(26).																															self step.																															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																													^self reportLastMatch]].																									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																										ifTrue:																											[[self recordMatch: #(26).																											self step.																											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																									^self reportLastMatch]].																					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																						ifTrue:																							[[self recordMatch: #(26).																							self step.																							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																					^self reportLastMatch].																			(currentCharacter isLetter or: [currentCharacter isAlphaNumeric])																				ifTrue:																					[[self recordMatch: #(26).																					self step.																					currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																			^self reportLastMatch]].															(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																ifTrue:																	[[self recordMatch: #(26).																	self step.																	currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].															^self reportLastMatch]].											(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])												ifTrue:													[[self recordMatch: #(26).													self step.													currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].											^self reportLastMatch]].							(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])								ifTrue:									[[self recordMatch: #(26).									self step.									currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].							^self reportLastMatch].					currentCharacter == $t						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $t								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $r										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $i												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $b														ifTrue:															[self recordMatch: #(26).															self step.															currentCharacter == $u																ifTrue:																	[self recordMatch: #(26).																	self step.																	currentCharacter == $t																		ifTrue:																			[self recordMatch: #(26).																			self step.																			currentCharacter == $e																				ifTrue:																					[self recordMatch: #(26).																					self step.																					currentCharacter == $s																						ifTrue:																							[self recordMatch: #(12 26).																							self step].																					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																						ifTrue:																							[[self recordMatch: #(26).																							self step.																							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																					^self reportLastMatch]].																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																		ifTrue:																			[[self recordMatch: #(26).																			self step.																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																	^self reportLastMatch]].													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])														ifTrue:															[[self recordMatch: #(26).															self step.															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].													^self reportLastMatch]].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $e				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $r ifTrue: [^self scan12].					currentCharacter == $x						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $c								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $l										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $u												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $d														ifTrue:															[self recordMatch: #(26).															self step.															currentCharacter == $e																ifTrue:																	[self recordMatch: #(26).																	self step.																	currentCharacter == $s																		ifTrue:																			[self recordMatch: #(9 26).																			self step].																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																		ifTrue:																			[[self recordMatch: #(26).																			self step.																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																	^self reportLastMatch]].													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])														ifTrue:															[[self recordMatch: #(26).															self step.															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].													^self reportLastMatch]].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $g				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $l						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $r								ifTrue:									[self recordMatch: #(20 26).									self step.									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $h				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $i						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $e								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $r										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $a												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $r														ifTrue:															[self recordMatch: #(26).															self step.															currentCharacter == $c																ifTrue:																	[self recordMatch: #(26).																	self step.																	currentCharacter == $h																		ifTrue:																			[self recordMatch: #(26).																			self step.																			currentCharacter == $y																				ifTrue:																					[self recordMatch: #(11 26).																					self step.																					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																						ifTrue:																							[[self recordMatch: #(26).																							self step.																							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																					^self reportLastMatch]].																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																		ifTrue:																			[[self recordMatch: #(26).																			self step.																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																	^self reportLastMatch]].													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])														ifTrue:															[[self recordMatch: #(26).															self step.															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].													^self reportLastMatch]].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $i				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $d						ifTrue:							[self recordMatch: #(18 26).							self step.							(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])								ifTrue:									[[self recordMatch: #(26).									self step.									currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].							^self reportLastMatch].					currentCharacter == $g						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $n								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $o										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $r												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $e														ifTrue:															[self recordMatch: #(26).															self step.															currentCharacter == $_																ifTrue:																	[self recordMatch: #(26).																	self step.																	currentCharacter == $v																		ifTrue:																			[self recordMatch: #(26).																			self step.																			currentCharacter == $a																				ifTrue:																					[self recordMatch: #(26).																					self step.																					currentCharacter == $r																						ifTrue:																							[self recordMatch: #(26).																							self step.																							currentCharacter == $i																								ifTrue:																									[self recordMatch: #(26).																									self step.																									currentCharacter == $a																										ifTrue:																											[self recordMatch: #(26).																											self step.																											currentCharacter == $b																												ifTrue:																													[self recordMatch: #(26).																													self step.																													currentCharacter == $l																														ifTrue:																															[self recordMatch: #(26).																															self step.																															currentCharacter == $e																																ifTrue:																																	[self recordMatch: #(26).																																	self step.																																	currentCharacter == $s																																		ifTrue:																																			[self recordMatch: #(22 26).																																			self step].																																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																																		ifTrue:																																			[[self recordMatch: #(26).																																			self step.																																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																																	^self reportLastMatch]].																													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																														ifTrue:																															[[self recordMatch: #(26).																															self step.																															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																													^self reportLastMatch]].																									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																										ifTrue:																											[[self recordMatch: #(26).																											self step.																											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																									^self reportLastMatch]].																					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																						ifTrue:																							[[self recordMatch: #(26).																							self step.																							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																					^self reportLastMatch]].																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																		ifTrue:																			[[self recordMatch: #(26).																			self step.																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																	^self reportLastMatch].															currentCharacter == $c																ifTrue:																	[self recordMatch: #(26).																	self step.																	currentCharacter == $a																		ifTrue:																			[self recordMatch: #(26).																			self step.																			currentCharacter == $s																				ifTrue:																					[self recordMatch: #(26).																					self step.																					currentCharacter == $e																						ifTrue:																							[self recordMatch: #(21 26).																							self step].																					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																						ifTrue:																							[[self recordMatch: #(26).																							self step.																							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																					^self reportLastMatch]].																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																		ifTrue:																			[[self recordMatch: #(26).																			self step.																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																	^self reportLastMatch].															(currentCharacter isLetter or: [currentCharacter isAlphaNumeric])																ifTrue:																	[[self recordMatch: #(26).																	self step.																	currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].															^self reportLastMatch].													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])														ifTrue:															[[self recordMatch: #(26).															self step.															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].													^self reportLastMatch]].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $l				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $e						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $f								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $t										ifTrue:											[self recordMatch: #(15 26).											self step].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $n				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $o						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $n								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $a										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $s												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $s														ifTrue:															[self recordMatch: #(26).															self step.															currentCharacter == $o																ifTrue:																	[self recordMatch: #(26).																	self step.																	currentCharacter == $c																		ifTrue:																			[self recordMatch: #(17 26).																			self step].																	(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																		ifTrue:																			[[self recordMatch: #(26).																			self step.																			currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].																	^self reportLastMatch]].													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])														ifTrue:															[[self recordMatch: #(26).															self step.															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].													^self reportLastMatch]].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $p				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $r						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $e								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $f										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $i												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $x														ifTrue:															[self recordMatch: #(13 26).															self step].													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])														ifTrue:															[[self recordMatch: #(26).															self step.															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].													^self reportLastMatch]].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $r				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $i						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $g								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $h										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $t												ifTrue:													[self recordMatch: #(16 26).													self step].											(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])												ifTrue:													[[self recordMatch: #(26).													self step.													currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].											^self reportLastMatch]].							(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])								ifTrue:									[[self recordMatch: #(26).									self step.									currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].							^self reportLastMatch].					currentCharacter == $o						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $o								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $t										ifTrue:											[self recordMatch: #(10 26).											self step].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			currentCharacter == $s				ifTrue:					[self recordMatch: #(26).					self step.					currentCharacter == $t						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $a								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $r										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $t												ifTrue:													[self recordMatch: #(19 26).													self step].											(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])												ifTrue:													[[self recordMatch: #(26).													self step.													currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].											^self reportLastMatch].									currentCharacter == $t										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $e												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $s														ifTrue:															[self recordMatch: #(8 26).															self step.															(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])																ifTrue:																	[[self recordMatch: #(26).																	self step.																	currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].															^self reportLastMatch]].											(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])												ifTrue:													[[self recordMatch: #(26).													self step.													currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].											^self reportLastMatch]].							(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])								ifTrue:									[[self recordMatch: #(26).									self step.									currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].							^self reportLastMatch].					currentCharacter == $u						ifTrue:							[self recordMatch: #(26).							self step.							currentCharacter == $f								ifTrue:									[self recordMatch: #(26).									self step.									currentCharacter == $f										ifTrue:											[self recordMatch: #(26).											self step.											currentCharacter == $i												ifTrue:													[self recordMatch: #(26).													self step.													currentCharacter == $x														ifTrue:															[self recordMatch: #(14 26).															self step].													(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])														ifTrue:															[[self recordMatch: #(26).															self step.															currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].													^self reportLastMatch]].									(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])										ifTrue:											[[self recordMatch: #(26).											self step.											currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].									^self reportLastMatch]].					(currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]])						ifTrue:							[[self recordMatch: #(26).							self step.							currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].					^self reportLastMatch].			((currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space])				ifTrue:					[[self recordMatch: #(24).					self step.					(currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space]] whileTrue.					^self reportLastMatch].			(currentCharacter isLetter or: [currentCharacter == $_])				ifTrue:					[[self recordMatch: #(26).					self step.					currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue].			^self reportLastMatch].	state == #default		ifTrue:			[self step.			currentCharacter == $; ifTrue: [^self recordAndReportMatch: #(33)].			currentCharacter == $: ifTrue: [^self scan1].			currentCharacter == $? ifTrue: [^self recordAndReportMatch: #(5)].			currentCharacter == $' ifTrue: [^self scan3].			currentCharacter == $" ifTrue: [^self scan5].			currentCharacter == $( ifTrue: [^self recordAndReportMatch: #(2)].			currentCharacter == $) ifTrue: [^self recordAndReportMatch: #(6)].			currentCharacter == ${ ifTrue: [^self recordAndReportMatch: #(29)].			currentCharacter == $* ifTrue: [^self recordAndReportMatch: #(3)].			currentCharacter == $/ ifTrue: [^self scan7].			currentCharacter == $#				ifTrue:					[[self recordMatch: #(28).					self step.					currentCharacter &lt;= Character tab						or: [(currentCharacter between: (Character value: 11) and: Character newPage) or: [currentCharacter &gt;= (Character value: 14)]]] whileTrue.					^self reportLastMatch].			currentCharacter == $% ifTrue: [^self recordAndReportMatch: #(32)].			currentCharacter == $+ ifTrue: [^self recordAndReportMatch: #(4)].			currentCharacter == $&lt; ifTrue: [^self scan9].			currentCharacter == $| ifTrue: [^self recordAndReportMatch: #(1)].			currentCharacter == $e ifTrue: [^self scan11].			((currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space])				ifTrue:					[[self recordMatch: #(24).					self step.					(currentCharacter between: Character tab and: Character cr) or: [currentCharacter == Character space]] whileTrue.					^self reportLastMatch].			(currentCharacter isLetter or: [currentCharacter == $_])				ifTrue:					[[self recordMatch: #(26).					self step.					currentCharacter isLetter or: [currentCharacter isAlphaNumeric or: [currentCharacter == $_]]] whileTrue]].	^self reportLastMatch</body><body package="SmaCC Development" selector="semicolonId">semicolonId	^33</body><body package="SmaCC Development" selector="symbolnameId">symbolnameId	^26</body><body package="SmaCC Development" selector="tokenActions">tokenActions	^#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #whitespace nil nil nil #comment #code)</body><body package="SmaCC Development" selector="tokennameId">tokennameId	^25</body><body package="SmaCC Development" selector="variablenameId">variablenameId	^30</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionScanner</class-id> <category>testing</category><body package="SmaCC Development" selector="canParse:">canParse: aString	^self perform: parseSourceSelector with: aString</body><body package="SmaCC Development" selector="canParseSmalltalk:">canParseSmalltalk: aString	RBParser parseExpression: aString onError: [:error :pos | ^false].	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionScanner</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	parseSourceSelector := #canParseSmalltalk:</body><body package="SmaCC Development" selector="parseSourceSelector:">parseSourceSelector: aSymbol 	parseSourceSelector := aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionScanner</class-id> <category>token-actions</category><body package="SmaCC Development" selector="code">code	| code |	code := ''.	[code := code , (stream upTo: $}).	self canParse: code]		whileFalse:			[stream atEnd ifTrue: [^self scannerError].			code := code , '}'].	matchActions := Array with: self codeId.	^self createTokenFor: '{' , code , '}'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefinitionScanner class</class-id> <category>testing</category><body package="SmaCC Development" selector="needsLineNumbers">needsLineNumbers	"Redefine to return true, if you need line number information"	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id> <category>accessing</category><body package="SmaCC Development" selector="symbols">symbols	^grammar symbols</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="codeGenerator:">codeGenerator: aSmaCCCodeGenerator	codeGenerator := aSmaCCCodeGenerator</body><body package="SmaCC Development" selector="grammar:">grammar: aGrammar	grammar := aGrammar</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id> <category>regular expression construction</category><body package="SmaCC Development" selector="addActions">addActions	self symbols		keysAndValuesDo:			[:index :each | each regularExpression ifNotNil: [:eachRegex | eachRegex action: index]]</body><body package="SmaCC Development" selector="addActionsFrom:to:at:">addActionsFrom: aRegularExpression to: aKeywordMap at: states	^states		do:			[:state | 			state ~= aRegularExpression action				ifTrue:					[aRegularExpression						possibleMatchesDo:							[:string | (aKeywordMap at: state ifAbsentPut: [Dictionary new]) at: string put: aRegularExpression action]]]</body><body package="SmaCC Development" selector="addNormalSymbols">addNormalSymbols	grammar symbols: (self symbols asSortedCollection: self filePositionSortBlock)</body><body package="SmaCC Development" selector="addSpecialSymbols">addSpecialSymbols	grammar tokens		keysDo:			[:each | (codeGenerator scannerActionFor: each) notNil ifTrue: [grammar terminalSymbolNamed: each]]</body><body package="SmaCC Development" selector="addSpecificREsWithoutActionsTo:">addSpecificREsWithoutActionsTo: aRegularExpression	| dfa regex |	regex := aRegularExpression.	dfa := regex isNil ifTrue: [nil] ifFalse: [regex asDFA].	self		specificRegularExpressionsDo:			[:each | 			| actions |			actions := dfa isNil ifTrue: [nil] ifFalse: [dfa actionForSpecificRegularExpression: each].			actions isNil ifTrue: [regex := regex isNil ifTrue: [each] ifFalse: [regex | each]]].	^regex</body><body package="SmaCC Development" selector="combinedGeneralRegexes">combinedGeneralRegexes	| combinedRegex |	combinedRegex := nil.	self		generalRegularExpressionsDo:			[:each | combinedRegex := combinedRegex isNil ifTrue: [each] ifFalse: [combinedRegex | each]].	^combinedRegex</body><body package="SmaCC Development" selector="computeKeywordMapFor:">computeKeywordMapFor: dfa	| keywordmap |	keywordmap := Dictionary new.	self		specificRegularExpressionsDo:			[:each | 			| actions |			actions := dfa actionForSpecificRegularExpression: each.			actions isNil				ifFalse:					[self						addActionsFrom: each						to: keywordmap						at: actions]].	^keywordmap</body><body package="SmaCC Development" selector="computeSelectorMap">computeSelectorMap	| selectorMap |	selectorMap := Dictionary new.	self symbols		keysAndValuesDo:			[:index :each | 			(codeGenerator scannerActionFor: each name)				ifNotNil: [:selector | selectorMap at: index put: selector]].	^selectorMap</body><body package="SmaCC Development" selector="generalRegularExpressionsDo:">generalRegularExpressionsDo: aBlock	self regularExpressionsDo: [:each | each isKeywordLiteral ifFalse: [aBlock value: each]]</body><body package="SmaCC Development" selector="specificRegularExpressionsDo:">specificRegularExpressionsDo: aBlock	self regularExpressionsDo: [:each | each isKeywordLiteral ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id> <category>compiling-scanner</category><body package="SmaCC Development" selector="compileMethodsFor:">compileMethodsFor: regex	| keywordmap dfa selectorMap |	dfa := regex asDFA.	selectorMap := self computeSelectorMap.	keywordmap := self computeKeywordMapFor: dfa.	codeGenerator selectorMap: selectorMap.	codeGenerator compileKeywordInitializerUsing: keywordmap.	codeGenerator compileNode: dfa.	codeGenerator compileEmptySymbolTokenId: (self symbols indexOf: grammar emptySymbol).	codeGenerator compileErrorSymbolTokenId: (self symbols indexOf: grammar errorSymbol).	codeGenerator compileIgnoreCaseMethods</body><body package="SmaCC Development" selector="compileScanner">compileScanner	| regex |	regex := self createRegex.	self compileTokenIdMethods.	self compileMethodsFor: regex</body><body package="SmaCC Development" selector="compileTokenIdMethods">compileTokenIdMethods	(self symbols select: [:each | each createIdMethod])		do:			[:each | codeGenerator compileTokenIdMethodNamed: each safeMethodName withId: (self symbols indexOf: each)]</body><body package="SmaCC Development" selector="createRegex">createRegex	self addSpecialSymbols.	self addNormalSymbols.	self addActions.	^self addSpecificREsWithoutActionsTo: self combinedGeneralRegexes</body><body package="SmaCC Development" selector="filePositionSortBlock">filePositionSortBlock	^[:a :b | 	| aRegex bRegex |	aRegex := a regularExpression.	bRegex := b regularExpression.	bRegex isNil or: [aRegex notNil and: [(aRegex position ifNil: [0]) &lt; (bRegex position ifNil: [0])]]]</body><body package="SmaCC Development" selector="regularExpressionsDo:">regularExpressionsDo: aBlock	self symbols do: [:each | each regularExpression ifNotNil: aBlock]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>private</category><body package="SmaCC Development" selector="checkFor:errorMessage:">checkFor: problemSymbols errorMessage: errorMessage 	| stream |	problemSymbols isEmpty ifTrue: [^self].	stream := WriteStream with: String new.	problemSymbols do: [:each | stream nextPutAll: each printString]		separatedBy: [stream space].	SmaCCCompilationNotification raiseRequestWith: stream contents		errorString: errorMessage</body><body package="SmaCC Development" selector="checkForEmptySymbols">checkForEmptySymbols	self checkFor: grammar emptySymbols errorMessage: 'Missing non-terminal productions'</body><body package="SmaCC Development" selector="checkForUnusedSymbols">checkForUnusedSymbols	self checkFor: grammar unusedSymbols errorMessage: 'Unused non-terminal symbols'</body><body package="SmaCC Development" selector="shiftTableKeyForIndex:symbol:">shiftTableKeyForIndex: anInteger symbol: aSmaCCSymbol	^SmaCCSymbolTableIndex forIndex: anInteger symbol: aSmaCCSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>compiling</category><body package="SmaCC Development" selector="compileInto:andParser:">compileInto: sClass andParser: pClass	self scannerClass: sClass.	self parserClass: pClass.	self createChanges.	self codeGenerator compileChanges</body><body package="SmaCC Development" selector="compileNodeClasses">compileNodeClasses	SmaCCNodeCalculation compileForGrammar: grammar</body><body package="SmaCC Development" selector="compileParser">compileParser	self compileNodeClasses.	(self codeGenerator)		compileTransitionTable: self transitionTable;		compileStartingStateIds: startingStateMap;		compileReductionTable: self reduceTable;		compileReductionActions;		compileScannerClassIntoParser</body><body package="SmaCC Development" selector="compileScanner">compileScanner	scannerCompiler compileScanner</body><body package="SmaCC Development" selector="createChanges">createChanges	self codeGenerator removeOldMethods.	self checkForEmptySymbols.	self checkForUnusedSymbols.	self compileScanner.	self compileParser.	self codeGenerator compileDefinitionComment: parserDefinitionString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>accessing</category><body package="SmaCC Development" selector="codeGenerator">codeGenerator	^codeGenerator ifNil: [self codeGenerator: SmaCCSmalltalkCodeGenerator new]</body><body package="SmaCC Development" selector="grammar">grammar	^grammar isNil ifTrue: [grammar := SmaCCGrammar new] ifFalse: [grammar]</body><body package="SmaCC Development" selector="itemSetsComment">itemSetsComment	| stream |	stream := WriteStream on: String new.	itemSets		keysAndValuesDo:			[:index :each | 			stream				nextPutAll: index printString;				nextPutAll: each printString;				cr].	^stream contents</body><body package="SmaCC Development" selector="parserClass">parserClass	^self codeGenerator parserClass</body><body package="SmaCC Development" selector="parserClass:">parserClass: aClassOrString	grammar isGLR		ifTrue: [self codeGenerator glrParserClass: aClassOrString]		ifFalse: [self codeGenerator parserClass: aClassOrString]</body><body package="SmaCC Development" selector="scannerClass:">scannerClass: aClassOrString	self codeGenerator scannerClass: aClassOrString</body><body package="SmaCC Development" selector="symbolsComment">symbolsComment	| stream |	stream := WriteStream on: String new.	scannerCompiler symbols		keysAndValuesDo:			[:index :each | 			stream				nextPutAll: index printString;				nextPutAll: '. ';				nextPutAll: each printString;				cr].	^stream contents</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>action table</category><body package="SmaCC Development" selector="actionForState:on:">actionForState: anInteger on: aSmaCCSymbol	| action |	action := (itemSets at: anInteger) action: aSmaCCSymbol prefer: (grammar preferredActionFor: aSmaCCSymbol).	^self		idForAction: action		state: anInteger		on: aSmaCCSymbol</body><body package="SmaCC Development" selector="compressTable:">compressTable: table	^table collect: [:row | self compressTableRow: row]</body><body package="SmaCC Development" selector="compressTableRow:">compressTableRow: row	| uniqueItems |	uniqueItems := self uniqueNonErrorActionsForTableRow: row.	^uniqueItems size = 1		ifTrue: [self singleActionTableRow: row forAction: uniqueItems first]		ifFalse: [self multipleActionTableRow: row]</body><body package="SmaCC Development" selector="compressedRowStream">compressedRowStream	^WriteStream with: Array new</body><body package="SmaCC Development" selector="createItemSets">createItemSets	| itemSet newState index |	startingStateMap := Dictionary new.	grammar calculateFirstSets.	itemSets := OrderedCollection new.	grammar allStartingSymbols		do:			[:each | 			itemSets add: (grammar initialItemSetFor: each).			startingStateMap at: each put: itemSets size].	shiftTable := Dictionary new.	index := 1.	[index &lt;= itemSets size]		whileTrue:			[itemSet := itemSets at: index.			grammar symbols				do:					[:each | 					newState := itemSet moveOn: each.					newState notEmpty						ifTrue: [shiftTable at: (self shiftTableKeyForIndex: index symbol: each) put: (self indexOfState: newState)]].			index := index + 1]</body><body package="SmaCC Development" selector="createTransitionTable">createTransitionTable	| table |	table := (1 to: itemSets size)		collect: [:index | scannerCompiler symbols collect: [:each | self actionForState: index on: each]].	actions := self compressTable: table</body><body package="SmaCC Development" selector="idForAction:state:on:">idForAction: aSmaCCAction state: anInteger on: aSmaCCSymbol	| index preferredAction newStateIndex |	(aSmaCCAction isAmbiguous and: [grammar isGLR])		ifTrue:			[index := codeGenerator				ambiguousTableEntryFor:					(aSmaCCAction actions						collect:							[:each | 							self								idForAction: each								state: anInteger								on: aSmaCCSymbol]) asSet asSortedCollection.			^(index bitShift: 2) + 3]		ifFalse:			[preferredAction := aSmaCCAction preferredAction.			preferredAction isShift				ifTrue:					[newStateIndex := shiftTable at: (self shiftTableKeyForIndex: anInteger symbol: aSmaCCSymbol).					^(newStateIndex bitShift: 2) + preferredAction id].			preferredAction isReduce ifTrue: [^((self reduceTableIndexFor: preferredAction) bitShift: 2) + preferredAction id].			^aSmaCCAction id]</body><body package="SmaCC Development" selector="indexOfState:">indexOfState: newState	| newStateIndex |	newStateIndex := itemSets indexOf: newState.	newStateIndex = 0		ifTrue:			[itemSets add: newState.			newStateIndex := itemSets size]		ifFalse: [(itemSets at: newStateIndex) mergeWith: newState].	^newStateIndex</body><body package="SmaCC Development" selector="multipleActionTableRow:">multipleActionTableRow: row	| stream |	stream := self compressedRowStream.	stream nextPut: 1.	row		keysAndValuesDo:			[:index :each | 			each ~= 3				ifTrue:					[self writeInteger: each on: stream.					self writeInteger: index on: stream]].	^stream contents</body><body package="SmaCC Development" selector="singleActionTableRow:forAction:">singleActionTableRow: row forAction: anInteger	| stream |	stream := self compressedRowStream.	stream nextPut: 0.	self writeInteger: anInteger on: stream.	row keysAndValuesDo: [:index :each | each ~= 3 ifTrue: [self writeInteger: index on: stream]].	^stream contents</body><body package="SmaCC Development" selector="transitionTable">transitionTable	actions isNil		ifTrue:			[self createItemSets.			self createTransitionTable].	^actions</body><body package="SmaCC Development" selector="uniqueNonErrorActionsForTableRow:">uniqueNonErrorActionsForTableRow: row	^(row asSet)		remove: 3 ifAbsent: [];		asArray</body><body package="SmaCC Development" selector="writeInteger:on:">writeInteger: anInteger on: aStream	aStream nextPut: anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>reduction table</category><body package="SmaCC Development" selector="reduceTable">reduceTable	^reduceTable</body><body package="SmaCC Development" selector="reduceTableIndexFor:">reduceTableIndexFor: aSmaCCReduceAction 	| value |	value := Array 				with: (scannerCompiler symbols indexOf: aSmaCCReduceAction symbol)				with: aSmaCCReduceAction rhs size				with: (self codeGenerator compileSourceFor: aSmaCCReduceAction).	^reduceTable indexOf: value		ifAbsent: 			[reduceTable				add: value;				size]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="buildDefinition:">buildDefinition: definitionString	| parser |	scannerCompiler grammar: self grammar.	parserDefinitionString := definitionString.	parser := SmaCCDefinitionParser on: (ReadStream on: definitionString).	parser scanner parseSourceSelector: self codeGenerator parseSourceSelector.	parser grammar: grammar.	parser parse.	grammar finishBuilding</body><body package="SmaCC Development" selector="codeGenerator:">codeGenerator: aSmaCCCodeGenerator	codeGenerator := aSmaCCCodeGenerator.	self grammar codeGenerator: aSmaCCCodeGenerator.	scannerCompiler codeGenerator: aSmaCCCodeGenerator.	^codeGenerator</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	scannerCompiler := SmaCCScannerCompiler new.	startingStateMap := Dictionary new.	reduceTable := OrderedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStateEdge</class-id> <category>comparing</category><body package="SmaCC Development" selector="&lt;=">&lt;= aSmaCCEdge	^self class ~= aSmaCCEdge class		or: [self transitionObjects first &lt;= aSmaCCEdge transitionObjects first]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStateEdge</class-id> <category>compiling</category><body package="SmaCC Development" selector="dispatchTo:seen:">dispatchTo: aSmaCCCodeGenerator seen: aCollection	^aSmaCCCodeGenerator acceptStateEdge: self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableCalculation</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="addExternallyDefinedVariablesFrom:">addExternallyDefinedVariablesFrom: aSmaCCRHS	aSmaCCRHS variableDefinitions		do:			[:each | 			| variable |			variable := self variableNamed: each variableName.			(each isCollection				or: [(currentRHS locallyDefinesVariable: each variableName) or: [previousVariables includes: each variableName]])				ifTrue: [variable isCollection: true]]</body><body package="SmaCC Development" selector="addLocallyDefinedVariable:">addLocallyDefinedVariable: aString	(self hasVariableNamed: aString)		ifTrue: [(self variableNamed: aString) isCollection: true]		ifFalse: [self addVariableNamed: aString]</body><body package="SmaCC Development" selector="addRHS:">addRHS: aSmaCCRHS 	(todo identityIndexOf: aSmaCCRHS) &gt; 0 ifTrue: [^self].	todo add: aSmaCCRHS</body><body package="SmaCC Development" selector="addVariableNamed:">addVariableNamed: aString	^newVariables add: (SmaCCVariableDefinition variableName: aString)</body><body package="SmaCC Development" selector="assignVariables">assignVariables	currentRHS variableDefinitions: newVariables</body><body package="SmaCC Development" selector="calculateNewVariables">calculateNewVariables	ourType := currentRHS nodeType.	newVariables := OrderedCollection new.	previousVariables := #().	currentRHS		variablesAndSymbolsDo:			[:variable :symbol | 			variable isNil ifTrue: [self processUnnamedSymbol: symbol] ifFalse: [self addLocallyDefinedVariable: variable].			previousVariables := newVariables collect: [:each | each variableName]]</body><body package="SmaCC Development" selector="calculateVariables">calculateVariables	self rhsDo: [:each | self addRHS: each].	[todo notEmpty] whileTrue: [self calculateVariablesFor: todo removeFirst]</body><body package="SmaCC Development" selector="calculateVariablesFor:">calculateVariablesFor: aSmaCCRHS	currentRHS := aSmaCCRHS.	self calculateNewVariables.	self hasVariableChanges		ifTrue:			[self assignVariables.			self recalculateDependents]</body><body package="SmaCC Development" selector="calculateVariablesForGrammar:">calculateVariablesForGrammar: aSmaCCGrammar	grammar := aSmaCCGrammar.	dependentsMap := IdentityDictionary new.	todo := OrderedCollection new.	self setupVariableDependents.	self calculateVariables</body><body package="SmaCC Development" selector="hasVariableChanges">hasVariableChanges	^newVariables anySatisfy: [:each | (currentRHS variableDefinitions includes: each) not]</body><body package="SmaCC Development" selector="hasVariableNamed:">hasVariableNamed: aString	^newVariables anySatisfy: [:each | each variableName = aString]</body><body package="SmaCC Development" selector="processUnnamedSymbol:">processUnnamedSymbol: aSmaCCSymbol	aSmaCCSymbol		productionsDo:			[:rhs | (self shouldAddVariablesFrom: rhs) ifTrue: [self addExternallyDefinedVariablesFrom: rhs]]</body><body package="SmaCC Development" selector="recalculateDependents">recalculateDependents	(dependentsMap at: currentRHS ifAbsent: [#()]) do: [:each | self addRHS: each]</body><body package="SmaCC Development" selector="shouldAddVariablesFrom:">shouldAddVariablesFrom: aSmaCCRHS	| theirType |	ourType isNil ifTrue: [^true].	theirType := aSmaCCRHS nodeType.	theirType isNil ifTrue: [^true].	ourType = theirType ifTrue: [^true].	^(theirType hierarchyIncludes: ourType) not</body><body package="SmaCC Development" selector="variableNamed:">variableNamed: aString	^newVariables		detect: [:each | each variableName = aString]		ifNone: [self addVariableNamed: aString]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableCalculation</class-id> <category>private</category><body package="SmaCC Development" selector="addDependent:to:">addDependent: dependentSmaCCRHS to: aSmaCCRHS	(dependentsMap at: aSmaCCRHS ifAbsentPut: [IdentitySet new]) add: dependentSmaCCRHS</body><body package="SmaCC Development" selector="rhsDo:">rhsDo: aBlock	grammar symbols do: [:each | each isStartingSymbol ifFalse: [each productionsDo: aBlock]]</body><body package="SmaCC Development" selector="setupVariableDependents">setupVariableDependents	self rhsDo: [:rhs | self setupVariableDependentsFor: rhs]</body><body package="SmaCC Development" selector="setupVariableDependentsFor:">setupVariableDependentsFor: aSmaCCRHS	aSmaCCRHS unnamedSymbolsDo: [:symbol | symbol productionsDo: [:rhs | self addDependent: aSmaCCRHS to: rhs]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCVariableCalculation class</class-id> <category>accessing</category><body package="SmaCC Development" selector="calculateVariablesForGrammar:">calculateVariablesForGrammar: aSmaCCGrammar	self new calculateVariablesForGrammar: aSmaCCGrammar</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>accessing</category><body package="SmaCC Development" selector="possibleMatchesSize">possibleMatchesSize	^node possibleMatchesSize * (maximumMatches - minimumMatches + 1)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>private</category><body package="SmaCC Development" selector="asNFAStartingWith:">asNFAStartingWith: aSmaCCNode	| endNode start |	start := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	minimumMatches timesRepeat: [start := node asNFAStartingWith: start].	start addEdgeTo: endNode.	maximumMatches &lt; self class finiteInfinity		ifTrue:			[maximumMatches - minimumMatches				timesRepeat:					[start := node asNFAStartingWith: start.					start addEdgeTo: endNode]]		ifFalse: [(node asNFAStartingWith: start) addEdgeTo: start].	^endNode</body><body package="SmaCC Development" selector="possibleMatchesDo:on:">possibleMatchesDo: aBlock on: aStream	self		possibleMatchesDo: aBlock		on: aStream		startingAt: 0</body><body package="SmaCC Development" selector="possibleMatchesDo:on:startingAt:">possibleMatchesDo: aBlock on: aStream startingAt: anInteger	(anInteger between: minimumMatches and: maximumMatches) ifTrue: [aBlock value].	anInteger &lt; maximumMatches		ifTrue:			[node				possibleMatchesDo:					[self						possibleMatchesDo: aBlock						on: aStream						startingAt: anInteger + 1]				on: aStream]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="component:minimum:maximum:">component: aSmaCCRegularExpressionNode minimum: minInteger maximum: maxInteger	node := aSmaCCRegularExpressionNode.	minimumMatches := minInteger.	maximumMatches := maxInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	node printOn: aStream.	maximumMatches = (1 bitShift: 31)		ifTrue:			[minimumMatches = 0 ifTrue: [^aStream nextPut: $*].			minimumMatches = 1 ifTrue: [^aStream nextPut: $+].			^aStream				nextPut: ${;				nextPutAll: minimumMatches printString;				nextPutAll: ',}'].	aStream		nextPut: ${;		nextPutAll: minimumMatches printString;		nextPut: $,;		nextPutAll: maximumMatches printString;		nextPut: $}</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>constructing</category><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive	node makeCaseInsensitive</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="component:">component: aSmaCCRegularExpressionNode 	^self component: aSmaCCRegularExpressionNode minimum: 0</body><body package="SmaCC Development" selector="component:minimum:">component: aSmaCCRegularExpressionNode minimum: anInteger 	^self 		component: aSmaCCRegularExpressionNode		minimum: anInteger		maximum: self finiteInfinity</body><body package="SmaCC Development" selector="component:minimum:maximum:">component: aSmaCCRegularExpressionNode minimum: minInteger maximum: maxInteger 	^(self new)		component: aSmaCCRegularExpressionNode			minimum: minInteger			maximum: maxInteger;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode class</class-id> <category>constants</category><body package="SmaCC Development" selector="finiteInfinity">finiteInfinity	"The number that we consider to be 'infinite'"	^2147483648</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRejectAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="id">id	^2r11</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRejectAction</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:prefer:">mergeWith: aSmaCCAction prefer: aClass	^aSmaCCAction</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRejectAction</class-id> <category>testing</category><body package="SmaCC Development" selector="isReject">isReject	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefaultReduceCode</class-id> <category>accessing</category><body package="SmaCC Development" selector="source">source	^self codeGenerator defaultReductionSource</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefaultReduceCode</class-id> <category>testing</category><body package="SmaCC Development" selector="hasReduceAction">hasReduceAction	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDefaultReduceCode</class-id> <category>private</category><body package="SmaCC Development" selector="basicModelTypes:">basicModelTypes: aSet	^Array with: (self model classFor: OrderedCollection)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAcceptAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="id">id	^2r00</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAcceptAction</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:prefer:">mergeWith: aSmaCCAction prefer: aClass	^self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousAction</class-id> <category>accessing-actions</category><body package="SmaCC Development" selector="addAction:">addAction: aSmaCCAction	aSmaCCAction isAmbiguous		ifTrue: [actions addAll: aSmaCCAction actions]		ifFalse: [super addAction: aSmaCCAction]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousAction</class-id> <category>testing</category><body package="SmaCC Development" selector="isAmbiguous">isAmbiguous	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousAction</class-id> <category>error handling</category><body package="SmaCC Development" selector="errorType">errorType	| sortedActions |	sortedActions := self sortedActions.	^sortedActions first class = sortedActions last class ifTrue: ['Reduce/Reduce Conflict'] ifFalse: ['Shift/Reduce Conflict']</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousAction</class-id> <category>accessing</category><body package="SmaCC Development" selector="preferredAction">preferredAction	^self sortedActions first</body><body package="SmaCC Development" selector="sortedActions">sortedActions	"When in doubt shift the token"	^actions asSortedCollection: [:a :b | a id &lt;= b id]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAmbiguousAction</class-id> <category>merging</category><body package="SmaCC Development" selector="mergeWith:prefer:">mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isReject ifTrue: [^self].	aSmaCCAction isAmbiguous ifTrue: [actions addAll: aSmaCCAction actions] ifFalse: [actions add: aSmaCCAction].	^self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="codeGenerator:">codeGenerator: aSmaCCCodeGenerator	codeGenerator := aSmaCCCodeGenerator.	aSmaCCCodeGenerator grammar: self</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	type := #LALR1.	symbols := OrderedCollection new.	shiftReduceTable := Dictionary new.	otherStartingSymbols := OrderedCollection new.	classDefinitions := Dictionary new.	prefix := suffix := ''.	isGLR := false.	ignoreCase := false.	ignoredVariables := Set new.	annotateTokens := false</body><body package="SmaCC Development" selector="isGLR:">isGLR: aBoolean	isGLR := aBoolean</body><body package="SmaCC Development" selector="prefix:">prefix: aString	prefix := aString</body><body package="SmaCC Development" selector="scannerDefinition:">scannerDefinition: aSmaCCScannerDefinition	scannerDefinition := aSmaCCScannerDefinition</body><body package="SmaCC Development" selector="suffix:">suffix: aString	suffix := aString</body><body package="SmaCC Development" selector="type:">type: aSmaCCSymbol	type := aSmaCCSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>private</category><body package="SmaCC Development" selector="addSymbol:">addSymbol: aSmaCCSymbol	aSmaCCSymbol grammar: self.	self symbols add: aSmaCCSymbol.	^aSmaCCSymbol</body><body package="SmaCC Development" selector="addSymbolFirst:">addSymbolFirst: aSmaCCSymbol	aSmaCCSymbol grammar: self.	^self symbols addFirst: aSmaCCSymbol</body><body package="SmaCC Development" selector="annotateTokens:">annotateTokens: aBoolean	annotateTokens := aBoolean</body><body package="SmaCC Development" selector="calculateFirstSets">calculateFirstSets	| changed |	changed := true.	[changed]		whileTrue:			[changed := false.			self symbols do: [:each | changed := changed | each calculateFirstTerminals]]</body><body package="SmaCC Development" selector="findSymbolNamed:ifAbsent:">findSymbolNamed: aString ifAbsent: aBlock	^self symbols detect: [:each | each name = aString] ifNone: aBlock</body><body package="SmaCC Development" selector="findSymbolNamed:ifAbsentAdd:">findSymbolNamed: aString ifAbsentAdd: aBlock	^self findSymbolNamed: aString ifAbsent: [self addSymbol: aBlock value]</body><body package="SmaCC Development" selector="findSymbolNamed:ifAbsentAddFirst:">findSymbolNamed: aString ifAbsentAddFirst: aBlock	^self findSymbolNamed: aString ifAbsent: [self addSymbolFirst: aBlock value]</body><body package="SmaCC Development" selector="finishBuilding">finishBuilding	self ignoreCase		ifTrue:			[self symbols do: [:each | each makeCaseInsensitive].			self mergeCaseSensitiveKeywords].	annotateTokens ifTrue: [self symbols do: [:each | each annotateTokenVariables: self class tokenNameBlock]]</body><body package="SmaCC Development" selector="ignoreCase:">ignoreCase: aBoolean	ignoreCase := aBoolean</body><body package="SmaCC Development" selector="ignoredVariables">ignoredVariables	^ignoredVariables</body><body package="SmaCC Development" selector="ignoredVariables:">ignoredVariables: aCollection	ignoredVariables := aCollection asSet</body><body package="SmaCC Development" selector="keywordRegularExpressionFor:">keywordRegularExpressionFor: aString	| regularExpressionString regex |	regularExpressionString := (aString copyFrom: 2 to: aString size - 1)		copyReplaceAll: '""'		with: '"'.	regex := regularExpressionString		inject: nil		into:			[:sum :each | 			sum isNil				ifTrue: [SmaCCCharacterRENode characters: (String with: each)]				ifFalse: [sum , (SmaCCCharacterRENode characters: (String with: each))]].	regex addStates: scannerDefinition states.	^regex</body><body package="SmaCC Development" selector="keywordTerminalNamed:">keywordTerminalNamed: aString	^self		findSymbolNamed: aString		ifAbsentAddFirst:			[(self newTerminalSymbolNamed: aString)				regularExpression: (self keywordRegularExpressionFor: aString);				yourself]</body><body package="SmaCC Development" selector="mergeAll:">mergeAll: anOrderedCollection	| new first set |	first := anOrderedCollection first.	new := self newTerminalSymbolNamed: first name asUppercase.	new regularExpression: first regularExpression.	symbols add: new before: first.	symbols removeAll: anOrderedCollection.	set := anOrderedCollection asSet.	self rhsDo: [:each | 1 to: each size do: [:i | (set includes: (each at: i)) ifTrue: [each collection at: i put: new]]]</body><body package="SmaCC Development" selector="mergeCaseSensitiveKeywords">mergeCaseSensitiveKeywords	| duplicateMap |	duplicateMap := Dictionary new.	self symbols		do:			[:each | 			(each isTerminal and: [each name first = $"])				ifTrue: [(duplicateMap at: each name asUppercase ifAbsentPut: [OrderedCollection new]) add: each]].	duplicateMap keysAndValuesDo: [:name :value | value size &gt; 1 ifTrue: [self mergeAll: value]]</body><body package="SmaCC Development" selector="nonTerminalSymbolNamed:">nonTerminalSymbolNamed: aString	^self findSymbolNamed: aString ifAbsentAdd: [self newNonTerminalSymbolNamed: aString]</body><body package="SmaCC Development" selector="symbols">symbols	^symbols</body><body package="SmaCC Development" selector="symbols:">symbols: aCollection	symbols := aCollection</body><body package="SmaCC Development" selector="terminalSymbolNamed:">terminalSymbolNamed: aString	^self		findSymbolNamed: aString		ifAbsentAdd:			[(self newTerminalSymbolNamed: aString)				regularExpression: (scannerDefinition tokenNamed: aString);				yourself]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>accessing</category><body package="SmaCC Development" selector="addExtraSymbols">addExtraSymbols	self addSymbol: self emptySymbol.	self addSymbol: self errorSymbol</body><body package="SmaCC Development" selector="addStartingSymbol:">addStartingSymbol: aSmaCCSymbol	(otherStartingSymbols includes: aSmaCCSymbol) ifFalse: [otherStartingSymbols add: aSmaCCSymbol]</body><body package="SmaCC Development" selector="allStartingSymbols">allStartingSymbols	"Return all starting symbols with the default starting symbol listed first."	| startingSymbols default |	default := self startSymbol.	startingSymbols := otherStartingSymbols copy.	startingSymbols remove: default ifAbsent: [].	startingSymbols := startingSymbols		collect:			[:each | 			(self newStartingSymbolNamed: each name)				addProduction:						((self newRHS)								add: each;								yourself);				yourself].	startingSymbols addFirst: default.	^startingSymbols</body><body package="SmaCC Development" selector="classDefinitions">classDefinitions	| defs root |	root := self rootDefinition.	(root isNil and: [classDefinitions notEmpty]) 		ifTrue: 			[SmaCCCompilationNotification 				raiseRequestWith: 'Cannot generate node classes without specifying a "%root" node.'				errorString: 'Node generation'].	root isNil ifTrue: [^#()].	defs := classDefinitions asOrderedCollection.	defs do: 			[:each | 			(each isRoot not and: [each superclass isNil]) 				ifTrue: [each superclass: root]].	^defs</body><body package="SmaCC Development" selector="classNamed:">classNamed: aSymbol	^classDefinitions at: aSymbol ifAbsentPut: [SmaCCNodeClassDefinition named: aSymbol grammar: self]</body><body package="SmaCC Development" selector="codeGenerator">codeGenerator	^codeGenerator</body><body package="SmaCC Development" selector="emptySymbol">emptySymbol	^emptySymbol ifNil: [emptySymbol := self newTerminalSymbolNamed: 'E O F']</body><body package="SmaCC Development" selector="emptySymbols">emptySymbols	^self symbols select: [:each | each isTerminal not and: [each isEmpty]]</body><body package="SmaCC Development" selector="errorSymbol">errorSymbol	^errorSymbol ifNil: [errorSymbol := self newTerminalSymbolNamed: 'error']</body><body package="SmaCC Development" selector="initialItemSetFor:">initialItemSetFor: aSmaCCSymbol	^(aSmaCCSymbol asLRItemSet)		type: type;		yourself</body><body package="SmaCC Development" selector="makeTokenIdMethodFor:">makeTokenIdMethodFor: aString	| token |	token := (scannerDefinition includesTokenNamed: aString)		ifTrue: [self terminalSymbolNamed: aString]		ifFalse: [self findSymbolNamed: aString ifAbsentAdd: [self newTerminalSymbolNamed: aString]].	token createIdMethod: true</body><body package="SmaCC Development" selector="preferredActionFor:">preferredActionFor: aSmaCCSymbol	^shiftReduceTable at: aSmaCCSymbol ifAbsent: [nil]</body><body package="SmaCC Development" selector="prefix">prefix	^prefix</body><body package="SmaCC Development" selector="rhsDo:">rhsDo: aBlock	self symbols do: [:each | each productionsDo: aBlock]</body><body package="SmaCC Development" selector="rootDefinition">rootDefinition	^classDefinitions detect: [:each | each isRoot] ifNone: [nil]</body><body package="SmaCC Development" selector="sentinelSymbol">sentinelSymbol	^sentinelSymbol ifNil: [sentinelSymbol := self newTerminalSymbolNamed: 'S e n t i n e l']</body><body package="SmaCC Development" selector="setStartSymbolIfNone:">setStartSymbolIfNone: aSmaCCSymbol	| startSymbol |	self startSymbol notNil ifTrue: [^self].	startSymbol := self newStartingSymbolNamed: ''.	self addSymbol: startSymbol.	startSymbol		addProduction:			((self newRHS)				add: aSmaCCSymbol;				yourself)</body><body package="SmaCC Development" selector="startSymbol">startSymbol	^self symbols detect: [:each | each isStartingSymbol] ifNone: [nil]</body><body package="SmaCC Development" selector="suffix">suffix	^suffix</body><body package="SmaCC Development" selector="tokens">tokens	^scannerDefinition tokens</body><body package="SmaCC Development" selector="unusedSymbols">unusedSymbols	| nonTerminals problemSymbols todo |	nonTerminals := self symbols reject: [:each | each isTerminal].	todo := OrderedCollection withAll: self allStartingSymbols.	problemSymbols := nonTerminals asSet reject: [:each | todo includes: each].	[todo isEmpty]		whileFalse:			[todo removeFirst				productionsDo:					[:rhs | 					rhs						do:							[:each | 							(problemSymbols includes: each)								ifTrue:									[todo add: each.									problemSymbols remove: each]]]].	^problemSymbols</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>precedence</category><body package="SmaCC Development" selector="leftPrecedenceFor:">leftPrecedenceFor: aSmaCCSymbol	shiftReduceTable at: aSmaCCSymbol put: SmaCCReduceAction</body><body package="SmaCC Development" selector="nonAssociativePrecedenceFor:">nonAssociativePrecedenceFor: aSmaCCSymbol	shiftReduceTable at: aSmaCCSymbol put: SmaCCRejectAction</body><body package="SmaCC Development" selector="rightPrecedenceFor:">rightPrecedenceFor: aSmaCCSymbol	shiftReduceTable at: aSmaCCSymbol put: SmaCCShiftAction</body><body package="SmaCC Development" selector="setOperatorPrecedenceFor:to:">setOperatorPrecedenceFor: aSmaCCSymbol to: anInteger	aSmaCCSymbol precedence: anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>item creation</category><body package="SmaCC Development" selector="newItemSet">newItemSet	^(SmaCCItemSet new)		grammar: self;		yourself</body><body package="SmaCC Development" selector="newNonTerminalSymbolNamed:">newNonTerminalSymbolNamed: aString	^(SmaCCNonTerminalSymbol name: aString)		grammar: self;		yourself</body><body package="SmaCC Development" selector="newRHS">newRHS	^(SmaCCRHS new)		grammar: self;		yourself</body><body package="SmaCC Development" selector="newStartingSymbolNamed:">newStartingSymbolNamed: aString	^(SmaCCStartingSymbol name: 'B e g i n' , aString)		grammar: self;		yourself</body><body package="SmaCC Development" selector="newTerminalSymbolNamed:">newTerminalSymbolNamed: aString	^(SmaCCTerminalSymbol name: aString)		grammar: self;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>testing</category><body package="SmaCC Development" selector="ignoreCase">ignoreCase	^ignoreCase</body><body package="SmaCC Development" selector="isGLR">isGLR	^isGLR</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar class</class-id> <category>accessing</category><body package="SmaCC Development" selector="allCharacters">allCharacters	^String withAll: ((0 to: self maximumCharacterValue) 				collect: [:each | Character value: each])</body><body package="SmaCC Development" selector="defaultTokenNameFor:">defaultTokenNameFor: aString	| stream string |	stream := WriteStream on: String new.	aString		do:			[:each | 			| value |			value := self tokenNameMap at: each ifAbsent: [each].			value isString				ifTrue:					[(stream position = 0 or: [value isEmpty])						ifTrue: [stream nextPutAll: value]						ifFalse:							[stream nextPut: value first asUppercase.							stream								next: value size - 1								putAll: value								startingAt: 2]]				ifFalse: [stream nextPut: (value isAlphaNumeric ifTrue: [value] ifFalse: [$_])]].	string := stream contents.	string first isDigit ifTrue: [string := '_' , string].	string first isUppercase ifTrue: [string at: 1 put: string first asLowercase].	^string , 'Token'</body><body package="SmaCC Development" selector="defaultTokenNameMap">defaultTokenNameMap	| map |	map := Dictionary new.	#(#($&lt; 'lessThan') #($&gt; 'greaterThan') #($= 'equal') #($( 'leftParen') #($) 'rightParen') #(${ 'leftBrace') #($} 'rightBrace') #($[ 'leftBracket') #($] 'rightBracket') #($, 'comma') #($; 'semicolon') #($- 'minus') #($+ 'plus') #($* 'times') #($/ 'divide') #($: 'colon') #($. 'period') #($? 'questionMark') #($! 'bang') #($% 'percent') #($^ 'upArrow') #($&amp; 'and') #($| 'or') #($~ 'tilde'))		do: [:each | map at: each first put: each last].	^map</body><body package="SmaCC Development" selector="implicitToken:">implicitToken: aString 	| symbol node |	symbol := (aString copyFrom: 2 to: aString size - 1) asSymbol.	(Character canUnderstand: symbol) ifFalse: [^nil].	node := SmaCCCharacterRENode 				characters: (self allCharacters select: [:each | each perform: symbol]).	node position: SmallInteger maxVal.	"Implicit nodes have least precedence"	^node</body><body package="SmaCC Development" selector="maximumCharacterValue">maximumCharacterValue	^MaximumCharacterValue</body><body package="SmaCC Development" selector="maximumCharacterValue:">maximumCharacterValue: anInteger 	MaximumCharacterValue := anInteger</body><body package="SmaCC Development" selector="tokenNameBlock">tokenNameBlock	^TokenNameBlock ifNil: [[:string | self defaultTokenNameFor: string]]</body><body package="SmaCC Development" selector="tokenNameBlock:">tokenNameBlock: aBlock	TokenNameBlock := aBlock</body><body package="SmaCC Development" selector="tokenNameMap">tokenNameMap	^TokenNameMap ifNil: [TokenNameMap := self defaultTokenNameMap]</body><body package="SmaCC Development" selector="tokenNameMap:">tokenNameMap: aDictionary	TokenNameMap := aDictionary</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar class</class-id> <category>class initialization</category><body package="SmaCC Development" selector="initialize">initialize	self maximumCharacterValue: 255</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSourceReduceCode</class-id> <category>accessing</category><body package="SmaCC Development" selector="source">source	^source</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSourceReduceCode</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= anObject	^super = anObject and: [self source = anObject source]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSourceReduceCode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="source:">source: aString	source := aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSourceReduceCode</class-id> <category>private</category><body package="SmaCC Development" selector="basicModelTypes:">basicModelTypes: aSet	| index parseTree |	index := self returnedNodeIndex.	index notNil ifTrue: [^self basicModelTypes: aSet forIndex: index].	parseTree := RBParser parseExpression: self source onError: [:e :p | ^Array with: (self model classFor: Object)].	parseTree isLiteralNode ifTrue: [^Array with: (self model classFor: parseTree value class)].	^Array with: (self model classFor: Object)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSourceReduceCode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="onRHS:source:">onRHS: aSmaCCRHS source: aString	^(self onRHS: aSmaCCRHS)		source: aString;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= aSmaCCItemSet	self class = aSmaCCItemSet class		ifTrue:			[type == #LALR1				ifTrue: [^self isLALREqualTo: aSmaCCItemSet]				ifFalse: [^self isLREqualTo: aSmaCCItemSet]].	^false</body><body package="SmaCC Development" selector="hash">hash	^self inject: self class hash into: [:sum :each | sum bitXor: each hash]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>private</category><body package="SmaCC Development" selector="itemFor:">itemFor: anObject	^self basicAt: (self findElementOrNil: anObject)</body><body package="SmaCC Development" selector="performClosureOn:">performClosureOn: aSmaCCLR1Item	| nextSymbol rest first followers |	nextSymbol := aSmaCCLR1Item nextSymbol.	nextSymbol isTerminal ifTrue: [^self].	rest := aSmaCCLR1Item rest.	first := rest firstTerminals.	followers := SmaCCSymbolSet new.	(first includes: grammar emptySymbol)		ifTrue:			[first remove: grammar emptySymbol.			followers baseOn: aSmaCCLR1Item followers].	followers addAll: first.	nextSymbol productionsDo: [:each | self add: (SmaCCLR1Item rhs: each follow: followers)]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>accessing</category><body package="SmaCC Development" selector="action:prefer:">action: aSmaCCSymbol prefer: aClass	| action |	action := nil.	self		do:			[:each | 			| eachAction |			eachAction := each action: aSmaCCSymbol.			action := action isNil ifTrue: [eachAction] ifFalse: [action mergeWith: eachAction prefer: aClass]].	action signalAllWarnings.	^action</body><body package="SmaCC Development" selector="addPrevious:">addPrevious: aSmaCCItemSet	previousItemSets add: aSmaCCItemSet</body><body package="SmaCC Development" selector="grammar">grammar	^grammar</body><body package="SmaCC Development" selector="grammar:">grammar: aSmaCCGrammar	grammar := aSmaCCGrammar</body><body package="SmaCC Development" selector="mergeWith:">mergeWith: aSmaCCItemSet	self == aSmaCCItemSet ifTrue: [^self].	self addAll: aSmaCCItemSet.	previousItemSets addAll: aSmaCCItemSet previousItemSets</body><body package="SmaCC Development" selector="moveOn:">moveOn: aSmaCCSymbol	| anItemSet |	anItemSet := self class new.	anItemSet grammar: grammar.	anItemSet addPrevious: self.	anItemSet type: type.	self do: [:each | each nextSymbol == aSmaCCSymbol ifTrue: [anItemSet add: each moveNext]].	^anItemSet</body><body package="SmaCC Development" selector="path">path	| result |	result := OrderedCollection new.	self pathInto: result.	^result</body><body package="SmaCC Development" selector="pathInto:">pathInto: anOrderedCollection	| item |	self previousState isNil ifTrue: [^self].	self previousState pathInto: anOrderedCollection.	item := self detect: [:each | each location &gt; 1].	anOrderedCollection add: (item rhs at: item location - 1)</body><body package="SmaCC Development" selector="previousItemSets">previousItemSets	^previousItemSets</body><body package="SmaCC Development" selector="previousItemSets:">previousItemSets: aCollection	previousItemSets := aCollection</body><body package="SmaCC Development" selector="previousState">previousState	"Pick some previous item set"	previousItemSets isEmpty ifTrue: [^nil].	^previousItemSets first</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	(self class superclass canUnderstand: #initialize) ifTrue: [super initialize].	type := #LALR1.	previousItemSets := OrderedCollection new</body><body package="SmaCC Development" selector="type:">type: aSymbol	type := aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	| strings |	strings := OrderedCollection new: self size.	self do: [:each | strings add: each printString].	strings asSortedCollection		do:			[:each | 			aStream				tab;				nextPutAll: each;				cr]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>testing</category><body package="SmaCC Development" selector="isLALREqualTo:">isLALREqualTo: aSmaCCItemSet	^aSmaCCItemSet size = self size and: [self allSatisfy: [:each | aSmaCCItemSet includes: each]]</body><body package="SmaCC Development" selector="isLREqualTo:">isLREqualTo: anItemSet	^anItemSet size = self size		and:			[self				allSatisfy:					[:each | 					| item |					(item := anItemSet itemFor: each) notNil and: [each isLR1EqualTo: item]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>copying</category><body package="SmaCC Development" selector="copyEmpty:">copyEmpty: anInteger	^(super copyEmpty: anInteger)		type: type;		previousItemSets: previousItemSets;		grammar: grammar;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>adding</category><body package="SmaCC Development" selector="add:">add: aSmaCCLR1Item	| index item |	aSmaCCLR1Item isNil ifTrue: [^aSmaCCLR1Item].	index := self findElementOrNil: aSmaCCLR1Item.	item := self basicAt: index.	item isNil		ifTrue:			[self atNewIndex: index put: aSmaCCLR1Item.			aSmaCCLR1Item itemSet: self.			self performClosureOn: aSmaCCLR1Item]		ifFalse: [item mergeWith: aSmaCCLR1Item].	^aSmaCCLR1Item</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="new:">new: anInteger 	^(super new: anInteger)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>accessing</category><body package="SmaCC Development" selector="characters">characters	^characters</body><body package="SmaCC Development" selector="matchingCharacters">matchingCharacters	^ignoreCase ifTrue: [characters reject: [:each | each isLowercase]] ifFalse: [characters]</body><body package="SmaCC Development" selector="possibleMatchesSize">possibleMatchesSize	^self matchingCharacters size</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>printing</category><body package="SmaCC Development" selector="printCharacter:on:">printCharacter: aCharacter on: aStream 	(aCharacter asInteger between: 32 and: 126) 		ifTrue: [^aStream nextPut: aCharacter].	aStream nextPutAll: '\x'.	aCharacter asInteger 		printOn: aStream		paddedWith: $0		to: 2		base: 16</body><body package="SmaCC Development" selector="printOn:">printOn: aStream	| allCharacters |	characters size = 1 ifTrue: [^self printCharacter: characters first on: aStream].	aStream nextPut: $[.	allCharacters := characters.	characters size &gt; 128		ifTrue:			[aStream nextPut: $^.			allCharacters := ((0 to: SmaCCGrammar maximumCharacterValue)				collect: [:each | Character value: each]) reject: [:each | characters includes: each]].	allCharacters do: [:each | self printCharacter: each on: aStream].	aStream nextPut: $]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>private</category><body package="SmaCC Development" selector="asNFAStartingWith:">asNFAStartingWith: aSmaCCNode	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	startNode addEdgeTo: endNode onCharacters: characters.	^endNode</body><body package="SmaCC Development" selector="assignCharacters:">assignCharacters: newCharacters	| sortedCharacters stream |	sortedCharacters := newCharacters asSortedCollection: [:a :b | a asInteger &lt; b asInteger].	stream := WriteStream with: String new.	sortedCharacters		inject: nil		into:			[:sum :each | 			(sum = each or: [each asInteger &gt; SmaCCGrammar maximumCharacterValue]) ifFalse: [stream nextPut: each].			each].	characters := stream contents</body><body package="SmaCC Development" selector="possibleMatchesDo:on:">possibleMatchesDo: aBlock on: aStream	self matchingCharacters		do:			[:each | 			aStream nextPut: each.			aBlock value.			aStream skip: -1]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>constructing</category><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive	| newCharacters |	ignoreCase := true.	newCharacters := Set new.	characters		do:			[:each | 			newCharacters				add: each asLowercase;				add: each asUppercase].	self assignCharacters: newCharacters</body><body package="SmaCC Development" selector="|">| aSmaCCRegularExpressionNode	| newCharacters |	(self canMergeWith: aSmaCCRegularExpressionNode) ifFalse: [^super | aSmaCCRegularExpressionNode].	newCharacters := (characters , aSmaCCRegularExpressionNode characters) asSet.	self assignCharacters: newCharacters.	^self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="characters:">characters: aString	characters := aString</body><body package="SmaCC Development" selector="initialize">initialize	super initialize.	ignoreCase := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>testing</category><body package="SmaCC Development" selector="canMergeWith:">canMergeWith: aSmaCCRegularExpressionNode	^self class = aSmaCCRegularExpressionNode class		and:			[characters notNil				and:					[aSmaCCRegularExpressionNode characters notNil						and: [self action = aSmaCCRegularExpressionNode action]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="characters:">characters: aString	^(self new)		assignCharacters: aString;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>accessing</category><body package="SmaCC Development" selector="action:">action: aSmaCCSymbol	self isAtEnd		ifTrue:			[(self symbol isStartingSymbol and: [aSmaCCSymbol isEmptySymbol]) ifTrue: [^SmaCCAcceptAction item: self].			(followers includes: aSmaCCSymbol) ifTrue: [^SmaCCReduceAction item: self]]		ifFalse: [(rhs at: location) = aSmaCCSymbol ifTrue: [^SmaCCShiftAction item: self]].	^SmaCCRejectAction item: self</body><body package="SmaCC Development" selector="followers">followers	^followers</body><body package="SmaCC Development" selector="grammar">grammar	^rhs grammar</body><body package="SmaCC Development" selector="isAtEnd">isAtEnd	^location &gt; rhs size</body><body package="SmaCC Development" selector="itemSet:">itemSet: aSmaCCItemSet	itemSet := aSmaCCItemSet</body><body package="SmaCC Development" selector="location">location	^location</body><body package="SmaCC Development" selector="mergeWith:">mergeWith: aSmaCCLR1Item	followers mergeWith: aSmaCCLR1Item followers</body><body package="SmaCC Development" selector="moveNext">moveNext	^(self copy)		followers: (followers class basedOn: followers);		location: location + 1;		yourself</body><body package="SmaCC Development" selector="nextSymbol">nextSymbol	^location &gt; rhs size ifTrue: [self grammar sentinelSymbol] ifFalse: [rhs at: location]</body><body package="SmaCC Development" selector="path">path	^itemSet path</body><body package="SmaCC Development" selector="precedence">precedence	| max |	self isAtEnd		ifTrue:			[max := -1.	"If we don't have a precedence, then assume we are the lowest precedence (which will cause a shift action)."			rhs do: [:each | max := max max: (each precedence ifNil: [max])].			^max]		ifFalse: [^(rhs at: location) precedence]</body><body package="SmaCC Development" selector="rest">rest	| newRHS |	newRHS := self grammar newRHS.	location + 1 to: rhs size do: [:each | newRHS add: (rhs at: each)].	^newRHS</body><body package="SmaCC Development" selector="rhs">rhs	^rhs</body><body package="SmaCC Development" selector="symbol">symbol	^self rhs productionSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>comparing</category><body package="SmaCC Development" selector="=">= aSmaCCLR1Item	^self class == aSmaCCLR1Item class		and: [location = aSmaCCLR1Item location and: [rhs == aSmaCCLR1Item rhs and: [self symbol == aSmaCCLR1Item symbol]]]</body><body package="SmaCC Development" selector="hash">hash	^(self symbol identityHash bitXor: (location bitShift: 14)) bitXor: rhs identityHash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="followers:">followers: aSmaCCSymbolSet	followers := aSmaCCSymbolSet</body><body package="SmaCC Development" selector="location:">location: anInteger	location := anInteger</body><body package="SmaCC Development" selector="rhs:follow:">rhs: aSmaCCRHS follow: aSmaCCSymbolCollection	rhs := aSmaCCRHS.	location := 1.	followers := aSmaCCSymbolCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>printing</category><body package="SmaCC Development" selector="printOn:">printOn: aStream	| i |	aStream		nextPut: $[;		nextPutAll: self symbol printString;		nextPutAll: ' :'.	i := 1.	rhs		do:			[:each | 			i = location ifTrue: [aStream nextPutAll: ' . '].			aStream				space;				nextPutAll: each printString.			i := i + 1].	location &gt; rhs size ifTrue: [aStream nextPutAll: ' . '].	aStream nextPut: $;.	followers printOn: aStream.	aStream nextPut: $]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>testing</category><body package="SmaCC Development" selector="isLR1EqualTo:">isLR1EqualTo: aSmaCCLR1Item	^self followers size = aSmaCCLR1Item followers size		and: [self followers allSatisfy: [:each | aSmaCCLR1Item followers includes: each]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item class</class-id> <category>instance creation</category><body package="SmaCC Development" selector="rhs:follow:">rhs: aSmaCCRHS follow: aSmaCCSymbolCollection	^(self new)		rhs: aSmaCCRHS follow: aSmaCCSymbolCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>private</category><body package="SmaCC Development" selector="addImplementationSpecificRewritesTo:">addImplementationSpecificRewritesTo: rewriter 	rewriter		replace: 'Core.Character' with: 'Character';		replace: '``@.Stmts1.				(`@a ifTrue: [``@.Stmts2]) `{:node :dictionary | | index myStatements |						index := node parent statements indexOf: node.						myStatements := node parent statements.						dictionary at: #size put: ``@.Stmts2 size - (myStatements size - index).						index ~~  myStatements size and: [``@.Stmts2 size &gt;= (myStatements size - index) and: [							(index + 1 to: myStatements size) allSatisfy: [:each | 								(myStatements at: each) = (``@.Stmts2 at: ``@.Stmts2 size - (myStatements size - each))]]]						}.				``@.Stmts3'			with: '``@.Stmts1.				`{:dictionary | RBMessageNode receiver: `@a selector: #ifTrue: arguments: (Array with: (RBBlockNode body: (RBSequenceNode statements: (``@.Stmts2 copyFrom: 1 to: (dictionary at: #size)))))}.				``@.Stmts3';		replace: 'currentCharacter == `#l1 or: [currentCharacter == `#l2]'			with: '`{RBLiteralNode value: (String with: `#l1 value with: `#l2 value)} includes: currentCharacter';		replace: 'currentCharacter == `#l1 or: [currentCharacter == `#l2 or: `@a]'			with: '(`{RBLiteralNode value: (String with: `#l1 value with: `#l2 value)} includes: currentCharacter) or: `@a';		replace: '(`#l1 includes: currentCharacter) or: [currentCharacter == `#l2]'			with: '`{RBLiteralNode value: `#l1 value , (String with: `#l2 value)} includes: currentCharacter';		replace: '(`#l1 includes: currentCharacter) or: [currentCharacter == `#l2 or: `@a]'			with: '(`{RBLiteralNode value: `#l1 value , (String with: `#l2 value)} includes: currentCharacter) or: `@a';		replace: '`@.Stmts1.				currentCharacter isLiteral ifTrue: [`@.Stmts2].				`@.Stmts3'			with: '`@.Stmts1.				`@.Stmts2'</body><body package="SmaCC Development" selector="generateCharacterSetFor:">generateCharacterSetFor: aSelector	| stream |	stream := WriteStream with: String new.	0		to: SmaCCGrammar maximumCharacterValue		do:			[:i | 			| ch |			ch := Character value: i.			(ch perform: aSelector) ifTrue: [stream nextPut: ch]].	^stream contents</body><body package="SmaCC Development" selector="generatedMethodsIn:">generatedMethodsIn: aRBClass	^aRBClass selectors		select:			[:each | 			(aRBClass protocolsFor: each)				anySatisfy: [:protocol | protocol notNil and: ['generated*' match: protocol]]]</body><body package="SmaCC Development" selector="initializeIsExpressions">initializeIsExpressions	"Creates a map from sets of characters to selectors that start with 'is' on Character. This allows generated scanners to take	full advantage of selectors that are already implemented on Character"	| selectors |	isExpressions := Dictionary new.	selectors := Character selectors		select:			[:each | ('is*' match: each) and: [each numArgs = 0 and: [(each at: 3) isUppercase]]].	selectors		do:			[:sel | 			| string |			string := self generateCharacterSetFor: sel.			string isEmpty ifFalse: [isExpressions at: string put: sel]]</body><body package="SmaCC Development" selector="keywords">keywords	"While Smalltalk doesn't have many keywords, we don't want to overwrite any existing method."	^[SmaCCParseNode allSelectors			inject: #('self' 'super' 'nil' 'true' 'false') asSet			into:				[:sum :each | 				(each numArgs &lt;= 1 and: [each isInfix not])					ifTrue: [sum add: (each last = $: ifTrue: [each first: each size - 1] ifFalse: [each]) asString].				sum]] once</body><body package="SmaCC Development" selector="namespaceName">namespaceName	^parserClass unambiguousName copyFrom: 1		to: (parserClass unambiguousName lastIndexOf: $.)</body><body package="SmaCC Development" selector="parserParseTreeFor:">parserParseTreeFor: aSelector	^parseTreeCache		at: aSelector		ifAbsentPut:			[| definingClass |			definingClass := self parserClass whoDefinesMethod: aSelector.			definingClass parseTreeFor: aSelector]</body><body package="SmaCC Development" selector="send:to:">send: selector to: aString	^'(' , aString , ') ' , selector</body><body package="SmaCC Development" selector="send:to:with:with:">send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString	| keywords |	keywords := selectorString asSymbol keywords.	^'(' , receiverString , ') ' , keywords first , ' (' , firstArgumentString , ') ' , keywords last , ' ('		, secondArgumentString , ')'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>compiling-scanner</category><body package="SmaCC Development" selector="acceptStateEdge:">acceptStateEdge: aSmaCCStateEdge	^aSmaCCStateEdge transitionObjects size = 1		ifTrue: ['state == #' , aSmaCCStateEdge transitionObjects asArray first]		ifFalse: ['(' , aSmaCCStateEdge transitionObjects asArray storeString , ' includes: state)']</body><body package="SmaCC Development" selector="addTimesRepeatOptimizationTo:">addTimesRepeatOptimizationTo: rewriter	rewriter		replace:				'`@.StmtsBefore.				`@.Common.				`@a ifTrue: 					[`@.Common.					`@a ifTrue: [`@.After].					`@.CommonAfter.					^self reportLastMatch].				`@.CommonAfter'			with:				'`@.StmtsBefore.				2 timesRepeat: [					`@.Common.					`@a ifFalse: [`@.CommonAfter. ^self reportLastMatch]].				`@.After';		replace:				'`@.StmtsBefore.				`@.Common.				`@a ifTrue: 					[`@.Common.					`@a ifTrue: [`@.After].					`@.CommonAfter].				`@.CommonAfter'			with:				'`@.StmtsBefore.				2 timesRepeat: [					`@.Common.					`@a ifFalse: [`@.CommonAfter. `{(`@.CommonAfter notEmpty and: [`@.CommonAfter last isReturn]) ifTrue: [#()] ifFalse: [Array with: (RBParser parseExpression: ''^self reportLastMatch'')]}]].				`@.After';		replace:				'`@.StmtsBefore.				`#l timesRepeat: [					`@.Common.					`@a ifFalse: [`@.CommonAfter. ^self reportLastMatch]].				`@.Common.				`@a ifTrue: [`@.After].				`@.CommonAfter'			with:				'`@.StmtsBefore.				`{RBLiteralNode value: `#l value + 1} timesRepeat: [					`@.Common.					`@a ifFalse: [`@.CommonAfter. ^self reportLastMatch]].				`@.After';		replace:				'`@.StmtsBefore.				`#l timesRepeat: [					`@.Common.					`@a ifFalse: [`@.CommonAfter]].				`@.Common.				`@a ifTrue: [`@.After].				`@.CommonAfter'			with:				'`@.StmtsBefore.				`{RBLiteralNode value: `#l value + 1} timesRepeat: [					`@.Common.					`@a ifFalse: [`@.CommonAfter]].				`@.After';		replace:				'`@.StmtsBefore.				`#l1 timesRepeat: `@b.				`#l2 timesRepeat: `@b.				`@.StmtsAfter'			with:				'`@.StmtsBefore.				`{RBLiteralNode value: `#l1 value + `#l2 value} timesRepeat: `@b.				`@.StmtsAfter'</body><body package="SmaCC Development" selector="closestIsExpressionsFor:seen:">closestIsExpressionsFor: aSmaCCCharacterEdge seen: aCollection 	| expressions |	expressions := OrderedCollection new.	isExpressions keysAndValuesDo: 			[:string :selector | 			| isInString |			isInString := false.			((string allSatisfy: 					[:each | 					(aSmaCCCharacterEdge transitionObjects includes: each) 						ifTrue: [isInString := true]						ifFalse: [aCollection includes: each]]) 				and: [isInString]) ifTrue: [expressions add: selector]].	(expressions isEmpty or: 			[(self minMaxPairsFor: aSmaCCCharacterEdge without: expressions) size 				&gt; (self minMaxPairsFor: aSmaCCCharacterEdge without: #()) size]) 		ifTrue: [^#()].	expressions size &gt; 1 		ifTrue: 			[| strings newExpressions |			strings := expressions collect: 							[:each | 							each -&gt; ((isExpressions keyAtValue: each) 										select: [:char | aSmaCCCharacterEdge transitionObjects includes: char])].			strings := strings asSortedCollection: 							[:a :b | 							a value size &gt; b value size or: 									[a value size = b value size and: 											[(isExpressions keyAtValue: a key) size 												&lt; (isExpressions keyAtValue: b key) size]]].			newExpressions := OrderedCollection with: strings first.			2 to: strings size				do: 					[:i | 					| left |					left := (strings at: i) value.					newExpressions 						do: [:each | left := left reject: [:char | each value includes: char]].					left notEmpty ifTrue: [newExpressions add: (strings at: i)]].			expressions := newExpressions collect: [:each | each key]].	^expressions</body><body package="SmaCC Development" selector="compileIgnoreCaseMethods">compileIgnoreCaseMethods	super compileIgnoreCaseMethods.	self grammar ignoreCase ifFalse: [^self].	scannerClass		compile:			'tokenClass	^SmaCCCaseInsensitiveToken'		classified: #generated</body><body package="SmaCC Development" selector="compileKeywordInitializerUsing:">compileKeywordInitializerUsing: keywordMapDictionary	| stream dataStream |	keywordMapDictionary isEmpty ifTrue: [^self].	stream := WriteStream with: String new.	stream nextPutAll: 'initializeKeywordMap'.	stream nextPutAll: ' keywordMap :=  Dictionary new. '.	dataStream := WriteStream with: Array new.	keywordMapDictionary		keysAndValuesDo:			[:key :value | 			value keys asSortedCollection				do:					[:each | 					dataStream						nextPut:							(Array								with: key								with: each								with: (value at: each))]].	stream		nextPutAll: '#(';		cr.	dataStream contents		do:			[:each | 			stream nextPutAll: '#('.			each do: [:item | item storeOn: stream] separatedBy: [stream nextPut: $ ].			stream nextPut: $)]		separatedBy: [stream cr].	stream nextPut: $).	stream		nextPutAll:			' do: [:each | (keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2) put: each last]. ^keywordMap'.	scannerClass metaclass		compile: (RBParser parseMethod: stream contents) formattedCode		classified: #'generated-initialization'</body><body package="SmaCC Development" selector="compileMethodIn:">compileMethodIn: modelClass	| tree |	tree := RBParser parseMethod: self codeStream contents.	modelClass compile: tree formattedCode classified: #generated</body><body package="SmaCC Development" selector="optimizationRewriter">optimizationRewriter	| rewriter |	rewriter := ParseTreeRewriter new.	self addTimesRepeatOptimizationTo: rewriter.	rewriter		replace:				'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				currentCharacter == `#l ifTrue: [`@.Stmts3. ^`@r3].				`@.Stmts4'			with:				'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				`@.Stmts3. ^`@r3';		replace:				'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				currentCharacter == `#l ifTrue: [`@.Stmts3].				`@.Stmts4'			with:				'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				`@.Stmts3. 				`@.Stmts4';		replaceMethod:				'`name					`@.Stmts1.					`@a ifTrue: [^self `name].					`@.Stmts3'			with:				'`name					[`@.Stmts1.					`@a] whileTrue.					`@.Stmts3';		replaceMethod:				'`name					`@.Stmts1.					`@a ifTrue: [`@.Stmts2.							^self `name].					`@.Stmts3'			with:				'`name					[`@.Stmts1.					`@a] whileTrue: [`@.Stmts2].					`@.Stmts3';		replace:				'`@.Stmts1.				currentCharacter isLiteral ifTrue: [`@.Stmts2].				`@.Stmts3'			with:				'`@.Stmts1.				`@.Stmts2';		replace:				'`@.Stmts1.				`.Stmt.				`@.Stmts.				`@a ifTrue: [self step. `.Stmt. `@.Stmts].				`@.Stmts2'			with:				'`@.Stmts1.				`@a ifTrue: [self step].				`.Stmt.				`@.Stmts.				`@.Stmts2';		replace:				'`@.Stmts1.				true ifTrue: [`@.Stmts2. ^`@obj].				`@.Stmts3'			with:				'`@.Stmts1.				`@.Stmts2.				^`@obj';		replace:				'`@.Stmts1.				[`@.Stmts2. true] whileTrue.				`@.Stmts3'			with:				'`@.Stmts1.				[`@.Stmts2] repeat'.	self addImplementationSpecificRewritesTo: rewriter.	^rewriter</body><body package="SmaCC Development" selector="outputGreaterThanMatch:on:">outputGreaterThanMatch: each on: stream	stream		nextPutAll: 'currentCharacter &gt;= ';		nextPutAll: each first storeString</body><body package="SmaCC Development" selector="outputInvertedMatchFor:on:">outputInvertedMatchFor: aSmaCCCharacterEdge on: stream	| char |	char := Character		value:			((0 to: SmaCCGrammar maximumCharacterValue)				detect: [:each | (aSmaCCCharacterEdge transitionObjects includes: (Character value: each)) not]).	stream		nextPutAll: 'currentCharacter ~~ ';		nextPutAll: char storeString</body><body package="SmaCC Development" selector="outputIsSelector:on:">outputIsSelector: isSelector on: stream 	stream nextPutAll: 'currentCharacter ' , isSelector</body><body package="SmaCC Development" selector="outputLessThanMatch:on:">outputLessThanMatch: each on: stream 	stream		nextPutAll: 'currentCharacter &lt;= ';		nextPutAll: each last storeString</body><body package="SmaCC Development" selector="outputMatchFor:on:without:">outputMatchFor: aSmaCCCharacterEdge on: stream without: isSelectors	| pairs |	pairs := self minMaxPairsFor: aSmaCCCharacterEdge without: isSelectors.	pairs isEmpty		ifTrue:			[stream next: isSelectors size - 1 put: $].			^self].	isSelectors notEmpty ifTrue: [stream nextPutAll: ' or: ['].	pairs do: [:each | self outputMatchForTransition: each on: stream] separatedBy: [stream nextPutAll: ' or: ['].	stream next: pairs size - 1 put: $].	stream next: isSelectors size put: $]</body><body package="SmaCC Development" selector="outputMatchForTransition:on:">outputMatchForTransition: each on: stream	each first = each last ifTrue: [^self outputSingleCharacterMatch: each on: stream].	each first = (Character value: 0) ifTrue: [^self outputLessThanMatch: each on: stream].	each last = (Character value: SmaCCGrammar maximumCharacterValue)		ifTrue: [^self outputGreaterThanMatch: each on: stream].	self outputRangeMatch: each on: stream</body><body package="SmaCC Development" selector="outputRangeMatch:on:">outputRangeMatch: each on: stream 	stream		nextPutAll: '(currentCharacter between: ';		nextPutAll: each first storeString;		nextPutAll: ' and: ';		nextPutAll: each last storeString;		nextPutAll: ')'</body><body package="SmaCC Development" selector="outputSingleCharacterMatch:on:">outputSingleCharacterMatch: each on: stream 	stream		nextPutAll: 'currentCharacter == ';		nextPutAll: each first storeString</body><body package="SmaCC Development" selector="outputStreamClass">outputStreamClass	^WriteStream</body><body package="SmaCC Development" selector="scannerActionFor:">scannerActionFor: aString	| selector |	aString size &gt; 2 ifFalse: [^nil].	selector := (aString copyFrom: 2 to: aString size - 1) asSymbol.	^(scannerClass notNil		and:			[(scannerClass definesMethod: selector) and: [(Object canUnderstand: selector) not and: [selector numArgs = 0]]])		ifTrue: [selector]		ifFalse: [nil]</body><body package="SmaCC Development" selector="writeMatchingCodeFor:">writeMatchingCodeFor: aSmaCCNode	| matchedItem |	(aSmaCCNode action notNil and: [aSmaCCNode action size &gt; 0])		ifTrue:			[matchedItem := aSmaCCNode action asArray.			self codeStream				nextPutAll: (aSmaCCNode transitions isEmpty ifTrue: ['^self recordAndReportMatch:'] ifFalse: ['self recordMatch: ']).			matchedItem isSymbol				ifTrue: [self codeStream nextPutAll: matchedItem storeString]				ifFalse:					[self codeStream nextPutAll: '#('.					matchedItem do: [:each | self codeStream nextPutAll: each storeString] separatedBy: [self codeStream nextPut: $ ].					self codeStream nextPut: $)].			(self codeStream)				nextPut: $.;				cr].	(aSmaCCNode transitions anySatisfy: [:each | each isCharacterTransition]) ifTrue: [self nextPutLine: 'self step.']</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>code generation templates</category><body package="SmaCC Development" selector="comment:">comment: aString	^'"' , (aString trimBlanks copyReplaceAll: '"' with: '""') , '"'</body><body package="SmaCC Development" selector="method:type:">method: aString type: typeString	^aString</body><body package="SmaCC Development" selector="method:type:argumentName:argumentType:">method: aString type: anObject argumentName: argumentNameString argumentType: argumentTypeString	^aString , ' ' , argumentNameString</body><body package="SmaCC Development" selector="method:type:argumentName:argumentType:argumentName:argumentType:">method: aString type: anObject argumentName: firstArgumentNameString argumentType: firstArgumentTypeString argumentName: secondArgumentNameString argumentType: secondArgumentTypeString	| keywords |	keywords := aString asSymbol keywords.	^keywords first , ' ' , firstArgumentNameString , ' ' , keywords last , ' '		, secondArgumentNameString</body><body package="SmaCC Development" selector="reduceAction:">reduceAction: anArray	^'#(' , anArray first storeString , ' ' , (anArray at: 2) storeString , ' ' , anArray last storeString , ')'</body><body package="SmaCC Development" selector="send:to:with:">send: selectorString to: receiverString with: argumentString	^'(' , receiverString , ') ' , selectorString , ' (' , argumentString , ')'</body><body package="SmaCC Development" selector="send:to:with:with:with:">send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString with: thirdArgumentString	| keywords |	keywords := selectorString asSymbol keywords.	^'(' , receiverString , ') ' , keywords first , ' (' , firstArgumentString , ') ' , (keywords at: 2) , ' ('		, secondArgumentString , ') ' , keywords last , ' (' , thirdArgumentString , ')'</body><body package="SmaCC Development" selector="superMessage:">superMessage: aString	^'super ' , aString</body><body package="SmaCC Development" selector="superMessage:argument:">superMessage: aString argument: argumentString	^'super ' , aString , ' (' , argumentString , ')'</body><body package="SmaCC Development" selector="superMessage:argument:argument:">superMessage: aString argument: firstArgumentString argument: secondArgumentString	| keywords |	keywords := aString asSymbol keywords.	^'super ' , keywords first , ' (' , firstArgumentString , ') ' , keywords last , ' ('		, secondArgumentString , ')'</body><body package="SmaCC Development" selector="variableReference:in:">variableReference: aSmaCCVariableDefinition in: aString	^'(' , aString , ') ' , aSmaCCVariableDefinition getterMethodName</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>compiling-nodes</category><body package="SmaCC Development" selector="compileChildrenMethod:">compileChildrenMethod: aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="compileCopyInContextMethod:">compileCopyInContextMethod: aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="compileEqualMethod:">compileEqualMethod: aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="compileHashMethod:">compileHashMethod: aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="compileMatchInContextMethod:">compileMatchInContextMethod: aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="compilePluralVariableMap:into:">compilePluralVariableMap: allVariables into: aSmaCCNodeClassDefinition	| stream |	allVariables isEmpty ifTrue: [^self].	(allVariables anySatisfy: [:each | aSmaCCNodeClassDefinition isLocalVariable: each]) ifFalse: [^self].	stream := WriteStream on: String new.	stream		nextPutAll: (self supportsOptimizedExpressions ifTrue: ['##('] ifFalse: ['[']);		nextPutAll: '(Dictionary new) '.	allVariables		do:			[:each | 			stream				nextPutAll: 'at: ''';				nextPutAll: each variableName;				nextPutAll: ''' put: ''';				nextPutAll: each sourceVariableName;				nextPutAll: '''; '].	stream		nextPutAll: 'yourself';		nextPutAll: (self supportsOptimizedExpressions ifTrue: [')'] ifFalse: ['] once']).	self		startPublicOverrideMethod;		nextPutLine: (self method: 'pluralVariablesMap' type: self collectionType);		nextPutStatement: (self return: stream contents);		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass</body><body package="SmaCC Development" selector="compilePostCopyMethod:">compilePostCopyMethod: aSmaCCNodeClassDefinition</body><body package="SmaCC Development" selector="compileVariablesMethods:">compileVariablesMethods: aSmaCCNodeClassDefinition	| compileBlock allVariables class |	allVariables := OrderedCollection new.	class := aSmaCCNodeClassDefinition.	[class notNil]		whileTrue:			[allVariables addAll: class variableDefinitions.			class := class superclass].	compileBlock := [:variables :methodName | 	| vars ignoredVars |	ignoredVars := variables select: [:each | grammar ignoredVariables includes: each variableName].	vars := variables reject: [:each | grammar ignoredVariables includes: each variableName].	(vars anySatisfy: [:each | aSmaCCNodeClassDefinition isLocalVariable: each])		ifTrue:			[self				startPublicOverrideMethod;				nextPutLine: (self method: methodName type: self collectionType);				nextPutStatement: (self return: (vars collect: [:each | each getterMethodName asSymbol]) asArray storeString);				endMethod;				compileMethodIn: aSmaCCNodeClassDefinition modelClass].	(ignoredVars anySatisfy: [:each | aSmaCCNodeClassDefinition isLocalVariable: each])		ifTrue:			[| ignoredMethodName |			ignoredMethodName := methodName copy.			ignoredMethodName at: 1 put: ignoredMethodName first asUppercase.			ignoredMethodName := 'ignored' , ignoredMethodName.			self				startPublicOverrideMethod;				nextPutLine: (self method: ignoredMethodName type: self collectionType);				nextPutStatement: (self return: (ignoredVars collect: [:each | each getterMethodName asSymbol]) asArray storeString);				endMethod;				compileMethodIn: aSmaCCNodeClassDefinition modelClass]].	compileBlock		value: (allVariables select: [:each | each isBaseNodeType and: [each isCollection not]]) value: 'nodeVariables';		value: (allVariables select: [:each | each isBaseNodeType and: [each isCollection]]) value: 'compositeNodeVariables';		value: (allVariables select: [:each | each isBaseTokenType and: [each isCollection not]]) value: 'tokenVariables';		value: (allVariables select: [:each | each isBaseTokenType and: [each isCollection]])			value: 'compositeTokenVariables';		value: (allVariables select: [:each | each isBaseTokenType not and: [each isBaseNodeType not]])			value: 'otherVariables'.	self compilePluralVariableMap: (allVariables select: [:each | each isCollection]) into: aSmaCCNodeClassDefinition</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>compiling</category><body package="SmaCC Development" selector="addVariable:forDefinition:">addVariable: aSmaCCVariableDefinition forDefinition: aSmaCCNodeClassDefinition	| instVarName |	instVarName := self nonKeywordNameFor: aSmaCCVariableDefinition sourceVariableName.	(aSmaCCNodeClassDefinition modelClass definesInstanceVariable: instVarName) ifTrue: [^self].	aSmaCCNodeClassDefinition modelClass addInstanceVariable: instVarName</body><body package="SmaCC Development" selector="compileChanges">compileChanges	self removeUnnecessaryChanges.	RefactoryChangeManager instance performChange: self changes.	parserClass realItem ifNotNil: [:each | each resetCaches].	scannerClass realItem ifNotNil: [:each | each initializeKeywordMap]</body><body package="SmaCC Development" selector="compileInitializeMethod:">compileInitializeMethod: aSmaCCNodeClassDefinition	| stream |	((aSmaCCNodeClassDefinition modelClass definesMethod: #initialize)		and: [aSmaCCNodeClassDefinition collectionVariableDefinitions isEmpty]) ifTrue: [^self].	stream := WriteStream on: String new.	stream nextPutAll: 'initialize'.	(aSmaCCNodeClassDefinition modelClass superclass definesMethod: #initialize)		ifTrue:			[stream				cr;				tab;				nextPutAll: 'super initialize.'].	aSmaCCNodeClassDefinition collectionVariableDefinitions		do:			[:each | 			stream				cr;				tab;				nextPutAll: (self nonKeywordNameFor: each sourceVariableName);				nextPutAll: ' := OrderedCollection new: 2.'].	aSmaCCNodeClassDefinition modelClass compile: stream contents classified: #'generated-initialize-release'</body><body package="SmaCC Development" selector="compileMethodWithoutFormattingIn:">compileMethodWithoutFormattingIn: modelClass	modelClass compile: self codeStream contents classified: #generated</body><body package="SmaCC Development" selector="compileOptimizedMethodIn:">compileOptimizedMethodIn: modelClass	| tree rewriter |	tree := RBParser parseMethod: self codeStream contents.	rewriter := self optimizationRewriter.	[rewriter executeTree: tree] whileTrue: [tree := rewriter tree].	modelClass compile: rewriter tree formattedCode classified: #generated</body><body package="SmaCC Development" selector="compileSymbolTypes:">compileSymbolTypes: anArray	self		startPublicVirtualMethod;		nextPutLine: (self method: 'symbolTypes' type: self arrayType);		nextPutStatement: (self return: anArray storeString);		endMethod;		compileMethodIn: self parserClass</body><body package="SmaCC Development" selector="defineClass:asSubclassOf:">defineClass: aString asSubclassOf: aBehavior 	| path name namespace current variables |	path := OrderedCollection withAll: aString asQualifiedReference path.	name := path removeLast.	(path notEmpty and: [path first = #Smalltalk]) ifTrue: [path removeFirst].	namespace := model smalltalkNameSpace.	namespace := path inject: namespace				into: 					[:sum :each | 					| item |					item := sum itemFor: each.					item isNil 						ifTrue: 							[model defineNameSpace: sum unambiguousName , ' defineNameSpace: #' , each 										, ' private: false imports: ''''	category: ''SmaCC Generated Scanner/Parser'''.							item := sum itemFor: each].					item].	current := Smalltalk at: aString asSymbol ifAbsent: [Object].	variables := ''.	(current includesBehavior: SmaCCParser) 		| (current includesBehavior: SmaCCScanner) 			ifTrue: 				[| stream |				stream := WriteStream on: String new.				current instVarNames do: 						[:each | 						stream							nextPutAll: each;							space].				variables := stream contents].	model 		defineClass: namespace unambiguousName , ' defineClass: #' , name 				, ' superclass: #{' , aBehavior unambiguousName 				, '} indexedType: #none private: false instanceVariableNames: ''' 					, variables 					, ''' classInstanceVariableNames: '''' imports: '''' category: ''SmaCC Generated Scanner/Parser'''.	^namespace itemFor: name</body><body package="SmaCC Development" selector="removeChange:">removeChange: aRBChange	| index |	index := self changes changes identityIndexOf: aRBChange.	index &gt; 0 ifFalse: [^self].	self changes changes removeAtIndex: index</body><body package="SmaCC Development" selector="removeOldMethods">removeOldMethods	self		removeOldMethodsFrom: scannerClass;		removeOldMethodsFrom: scannerClass metaclass;		removeOldMethodsFrom: parserClass;		removeOldMethodsFrom: parserClass metaclass</body><body package="SmaCC Development" selector="removeOldMethodsFrom:">removeOldMethodsFrom: aRBClass	(self generatedMethodsIn: aRBClass) do: [:each | aRBClass removeMethod: each]</body><body package="SmaCC Development" selector="removeUnnecessaryChanges">removeUnnecessaryChanges	| allChanges |	allChanges := self changes changes copy.	(allChanges allSatisfy: [:each | (each isKindOf: CompositeRefactoryChange) not]) ifFalse: [^self].	allChanges		keysAndValuesDo:			[:key :each | 			(each isKindOf: RemoveMethodChange)				ifTrue:					[key + 1						to: allChanges size						do:							[:i | 							| other |							other := allChanges at: i.							[((other isKindOf: AddMethodChange)								and:									[each selector = other selector										and:											[each changeClassName = other changeClassName												and: [(other changeObject sourceCodeAt: other selector) asString = other parseTree source asString]]])								ifTrue:									[self										removeChange: each;										removeChange: other]] on: Error do: [:ex | ex return]]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>reduction table</category><body package="SmaCC Development" selector="basicCompileSourceFor:">basicCompileSourceFor: aSmaCCReduceAction	| parseTree rewriter methodName existing |	parseTree := RBParser parseExpression: aSmaCCReduceAction rhs reduceAction source.	(parseTree isLiteralNode		and:			[parseTree value isSymbol				and: [parseTree value numArgs &lt;= 1 and: [self parserClass definesMethod: parseTree value]]])		ifTrue: [^parseTree value].	rewriter := self parseTreeRewriterFor: aSmaCCReduceAction rhs.	rewriter executeTree: parseTree.	parseTree := rewriter tree.	methodName := ('reduceActionFor' , aSmaCCReduceAction symbol safeMethodName		, (aSmaCCReduceAction symbol positionOf: aSmaCCReduceAction rhs) printString , ':') asSymbol.	parseTree isSequence ifFalse: [parseTree := RBSequenceNode statements: (Array with: parseTree)].	parseTree := RBMethodNode		selector: methodName		arguments: (Array with: (RBVariableNode named: 'nodes'))		body: parseTree.	parseTree addReturn.	existing := self findExistingMethodFor: parseTree.	existing notNil ifTrue: [^existing].	self parserClass compile: parseTree formattedCode classified: 'generated-reduction actions'.	^methodName</body><body package="SmaCC Development" selector="defaultNodeReductionSource:">defaultNodeReductionSource: aReduction	aReduction index = 0 ifTrue: [^'nil'].	^'''' , aReduction index printString , ''''</body><body package="SmaCC Development" selector="defaultReductionSource">defaultReductionSource	^'#reduceFor:'</body><body package="SmaCC Development" selector="findExistingMethodFor:">findExistingMethodFor: aRBMethodNode	| potentialSelectors smaccParserClass |	smaccParserClass := model classFor: SmaCCParser.	potentialSelectors := Set withAll: (self parserClass selectors select: [:each | each numArgs &lt;= 1]).	potentialSelectors addAll: (smaccParserClass selectors select: [:each | each numArgs &lt;= 1]).	^potentialSelectors		detect:			[:each | 			| parseTree |			parseTree := self parserParseTreeFor: each.			parseTree notNil and: [aRBMethodNode body equalTo: parseTree body exceptForVariables: aRBMethodNode argumentNames]]		ifNone: [nil]</body><body package="SmaCC Development" selector="parseTreeRewriterFor:">parseTreeRewriterFor: aSmaCCRHS	| rewriter |	rewriter := ParseTreeRewriter new.	1		to: aSmaCCRHS size		do:			[:i | 			rewriter replace: i printString storeString with: '(nodes at: ' , i printString , ')'.			(aSmaCCRHS variableNameForIndex: i)				ifNotNil: [:name | rewriter replace: name with: '(nodes at: ' , i printString , ')']].	^rewriter</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>accessing</category><body package="SmaCC Development" selector="changes">changes	^model changes</body><body package="SmaCC Development" selector="scannerClass">scannerClass	^scannerClass</body><body package="SmaCC Development" selector="scannerClass:">scannerClass: aClassOrString	(aClassOrString isKindOf: Behavior)		ifTrue: [scannerClass := model classFor: aClassOrString]		ifFalse:			[scannerClass := model referencedItem: aClassOrString.			scannerClass isNil				ifTrue: [scannerClass := self defineClass: aClassOrString asSubclassOf: SmaCCScanner]]</body><body package="SmaCC Development" selector="selectorMap:">selectorMap: aDictionary	| arrayMap |	aDictionary isEmpty ifTrue: [^self].	arrayMap := Array new: aDictionary keys asSortedCollection last.	aDictionary keysAndValuesDo: [:key :value | arrayMap at: key put: value].	self		startPublicOverrideMethod;		nextPutLine: (self method: 'tokenActions' type: self collectionType);		nextPutStatement: (self return: arrayMap storeString);		endMethod;		compileMethodIn: self scannerClass</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>testing</category><body package="SmaCC Development" selector="hasLiteralByteArrays">hasLiteralByteArrays	^true</body><body package="SmaCC Development" selector="supportsOptimizedExpressions">supportsOptimizedExpressions	"Do we support ##() expressions"	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	model := (RBRootNameSpace new)		description: 'Compile Scanner/Parser';		yourself.	self initializeIsExpressions.	parseTreeCache := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator</class-id> <category>compiling-parser</category><body package="SmaCC Development" selector="compileScannerClassIntoParser">compileScannerClassIntoParser	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'scannerClass';		cr;		tab;		nextPutAll: '^';		nextPutAll: scannerClass name.	parserClass metaclass compile: stream contents classified: #'generated-accessing'</body><body package="SmaCC Development" selector="writeTransitionTableEntry:on:firstIsType:">writeTransitionTableEntry: anArray on: aStream firstIsType: aBoolean	| startIndex |	aStream cr.	self hasLiteralByteArrays		ifTrue:			[aStream nextPutAll: '#['.			aBoolean				ifTrue:					[aStream print: anArray first.					startIndex := 2]				ifFalse: [startIndex := 1].			startIndex				to: anArray size				do:					[:i | 					aStream						nextPutAll: self literalArraySeparator;						print: ((anArray at: i) bitShift: -8);						nextPutAll: self literalArraySeparator;						print: ((anArray at: i) bitAnd: 16rFF)].			aStream nextPut: $]]		ifFalse:			[aStream nextPutAll: '#('.			anArray do: [:each | aStream print: each] separatedBy: [aStream nextPutAll: self literalArraySeparator].			aStream nextPut: $)]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSmalltalkCodeGenerator class</class-id> <category>accessing</category><body package="SmaCC Development" selector="codeTemplatesArray">codeTemplatesArray	^super codeTemplatesArray ,		#(			#(#addAllSendTo:with: 'self addAll: (&lt;2s&gt;) to: (&lt;1s&gt;)')			#(#addSendTo:with: 'self add: (&lt;2s&gt;) to: (&lt;1s&gt;)')			#(#arrayType '')			#(#assignArray:index:to: '(&lt;1s&gt;) at: (&lt;2p&gt;) put: (&lt;3s&gt;)')			#(#assignmentTo:from: '&lt;1s&gt; := &lt;2s&gt;')			#(#at:index: '(&lt;1s&gt;) at: &lt;2p&gt;')			#(#bitXor:with: '(&lt;1s&gt;) bitXor: (&lt;2s&gt;)')			#(#booleanType '')			#(#cast:to: '&lt;1s&gt;')			#(#collectionType '')			#(#collectionVariableItemsIn:forCollectionGetter:andVariableGetter: 'SmaCCParseNode collectionVariableIn: (&lt;1s&gt;) collectionGetter: &lt;2p&gt; variableGetter: &lt;3p&gt;')			#(#compareEqual:to: '(&lt;1s&gt;) = (&lt;2s&gt;)')			#(#copy:inContext:onlyNodes: '&lt;1s&gt; collect: [:each | &lt;3?:(each isKindOf: SmaCCParseNode) ifTrue: [&gt;each copyInContext: &lt;2s&gt;]&lt;3?:]&gt;')			#(#copyNode: '(&lt;1s&gt;) copy')			#(#copyNodeCollection: '(&lt;1s&gt;) collect: [:each | each copy]')			#(#dictionaryType '')			#(#endConditionalString ']')			#(#endDoWhileLoopWithClause: '&lt;1s&gt;] whileTrue')			#(#endLiteralArray ')')			#(#endMethodString '')			#(#hashFor: '(&lt;1s&gt;) hash')			#(#ifFalseReturn: '(&lt;1s&gt;) ifFalse: [^false]')			#(#integerType '')			#(#isKindOfTest:class: '(&lt;1s&gt; isKindOf: &lt;2s&gt;) ifTrue: [')			#(#iterateObjects:name: '(&lt;1s&gt;) do: [:&lt;2s&gt; |')			#(#literalArraySeparator ' ')			#(#newArrayOfSize: 'Array new: &lt;1p&gt;')			#(#newCollectionOfSize: 'OrderedCollection new: &lt;1p&gt;')			#(#newObject: '&lt;1s&gt; new')			#(#newUnsignedShortArrayArray '#(')			#(#nodeCollectionType 'OrderedCollection')			#(#notNilCheckFor: '(&lt;1s&gt;) notNil ifTrue: [')			#(#objectType 'Object')			#(#private '')			#(#protected '')			#(#public '')			#(#receiverName 'self')			#(#reduceActionArrayType '')			#(#reduceActionLiteralStart '#(')			#(#return: '^&lt;1s&gt;')			#(#startDoWhileLoop '[')			#(#startIfWithClause: '(&lt;1s&gt;) ifTrue: [')			#(#statementSeparator '.')			#(#static '')			#(#stringType '')			#(#undefinedObject 'nil')			#(#unsignedShort '')			#(#unsignedShortArrayArray '')			#(#uppercaseString: '(&lt;1s&gt;) asUppercase')			#(#variableDeclaration:ofType: '| &lt;1s&gt; |')			#(#variableItemIn:forVariableGetter: 'SmaCCParseNode variableIn: (&lt;1s&gt;) getter: &lt;2p&gt;')			#(#virtual '')			#(#voidType '')		)</body><body package="SmaCC Development" selector="parseSourceSelector">parseSourceSelector	^#canParseSmalltalk:</body><body package="SmaCC Development" selector="typeName">typeName	^#Smalltalk</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDuplicateNodeEliminator</class-id> <category>algorithm</category><body package="SmaCC Development" selector="mergeAllTransitions">mergeAllTransitions	root allStates do: [:each | each mergeTransitions]</body><body package="SmaCC Development" selector="removeDuplicateNodesIn:">removeDuplicateNodesIn: aSmaCCNode	root := aSmaCCNode.	self removeDuplicates.	self copyGraph.	^root</body><body package="SmaCC Development" selector="removeDuplicates">removeDuplicates	| changed |	changed := true.	[changed]		whileTrue:			[changed := false.			self mergeAllTransitions.			self				pairsDo:					[:firstNode :secondNode | 					comparisonState := Dictionary new.					(self isNode: firstNode equivalentTo: secondNode)						ifTrue:							[firstNode mergeWith: secondNode.							changed := true]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDuplicateNodeEliminator</class-id> <category>testing</category><body package="SmaCC Development" selector="isNode:equivalentTo:">isNode: firstSmaCCNode equivalentTo: secondSmaCCNode	firstSmaCCNode = secondSmaCCNode ifTrue: [^true].	firstSmaCCNode transitions size = secondSmaCCNode transitions size ifFalse: [^false].	firstSmaCCNode action = secondSmaCCNode action ifFalse: [^false].	((comparisonState at: firstSmaCCNode ifAbsent: [#()]) includes: secondSmaCCNode) ifTrue: [^true].	(comparisonState at: firstSmaCCNode ifAbsentPut: [Set new]) add: secondSmaCCNode.	(comparisonState at: secondSmaCCNode ifAbsentPut: [Set new]) add: firstSmaCCNode.	firstSmaCCNode sortedTransitions		with: secondSmaCCNode sortedTransitions		do:			[:first :second | 			first transitionObjects = second transitionObjects ifFalse: [^false].			(self isNode: first to equivalentTo: second to) ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDuplicateNodeEliminator</class-id> <category>private</category><body package="SmaCC Development" selector="pairsDo:">pairsDo: aBlock	| nodes |	nodes := root allStates asOrderedCollection.	1		to: nodes size - 1		do: [:i | i + 1 to: nodes size do: [:j | aBlock value: (nodes at: i) value: (nodes at: j)]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDuplicateNodeEliminator</class-id> <category>graph copying</category><body package="SmaCC Development" selector="copyEdgesWith:">copyEdgesWith: aDictionary	| todo |	todo := OrderedCollection with: root.	[todo notEmpty]		whileTrue:			[| node |			node := todo removeFirst.			(aDictionary at: node)				transitions:					(node sortedTransitions						do:							[:each | 							| copy |							copy := each copy.							copy to: (aDictionary at: each to).							copy])]</body><body package="SmaCC Development" selector="copyGraph">copyGraph	| map |	map := Dictionary new.	self copyNodesInto: map.	self copyEdgesWith: map.	^map at: root</body><body package="SmaCC Development" selector="copyNodesInto:">copyNodesInto: aDictionary	root allStates do: [:each | aDictionary at: each put: each shallowCopy]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCDuplicateNodeEliminator class</class-id> <category>algorithm</category><body package="SmaCC Development" selector="removeDuplicateNodesIn:">removeDuplicateNodesIn: aSmaCCNode 	^self new removeDuplicateNodesIn: aSmaCCNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>private</category><body package="SmaCC Development" selector="calculateFirstTerminals">calculateFirstTerminals	^false</body><body package="SmaCC Development" selector="makeCaseInsensitive">makeCaseInsensitive	regularExpression notNil ifTrue: [regularExpression makeCaseInsensitive]</body><body package="SmaCC Development" selector="unsafeMethodName">unsafeMethodName	^name copyFrom: 2 to: name size - 1</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>accessing</category><body package="SmaCC Development" selector="createIdMethod">createIdMethod	^createIdMethod</body><body package="SmaCC Development" selector="createIdMethod:">createIdMethod: aBoolean	createIdMethod := aBoolean</body><body package="SmaCC Development" selector="modelTypes:">modelTypes: anIdentitySet	^Set with: (self model classFor: SmaCCToken)</body><body package="SmaCC Development" selector="regularExpression">regularExpression	^regularExpression</body><body package="SmaCC Development" selector="regularExpression:">regularExpression: aSmaCCRegularExpressionNode	regularExpression := aSmaCCRegularExpressionNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>testing</category><body package="SmaCC Development" selector="isTerminal">isTerminal	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>initialize-release</category><body package="SmaCC Development" selector="initialize">initialize	super initialize.	firstTerminals add: self.	createIdMethod := false</body></methods><initialize><class-id>Refactory.SmaCC.SmaCCNode</class-id></initialize><initialize><class-id>Refactory.SmaCC.SmaCCDefaultNodeReduceCode</class-id></initialize><initialize><class-id>Refactory.SmaCC.SmaCCGrammar</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SmaCCScanner</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock state comments </inst-vars><class-inst-vars>keywordMap </class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SmaCCParser</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken errorToken stateStack nodeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>