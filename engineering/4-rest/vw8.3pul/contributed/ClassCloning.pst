<?xml version="1.0"?><st-source><!-- Name: ClassCloningComment: This package extends the Browser's "class" menu with an option to "Clone" the class. You give it a new name, and it will create a copy of the the selection but with the new name. It's basically equivalent to filing out a class, changing the name in there, and filing it back in. It is often easiest to just clone a class that has a pattern you like as a starting point and work from there. Very Self-ish. Or maybe just very C-ish. You decide.DbIdentifier: bear73DbTrace: 237279PackageName: ClassCloningParcel: #('ClassCloning')PrintStringCache: (11,tgriggs)Version: 11Date: 11:17:37 AM November 3, 2009 --><time-stamp>From VisualWorksÂ®, 7.7 of November 3, 2009 on November 3, 2009 at 11:17:37 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ClassCloneChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CompositeRefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newClassName originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ClassCloning</package></attributes></class><comment><class-id>Refactory.Browser.ClassCloneChange</class-id><body>Encapsualtes a change that aggregate changes used to copy one class as a new nameInstance Variables	newClassName	&lt;String&gt;	the new name, client's job to validate	originalClass	&lt;Behavior&gt;	the class to clone (should be instanceBehavior)</body></comment><class><name>ClassBlendChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CompositeRefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newClassName originalSuperclass originalSubclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ClassCloning</package></attributes></class><comment><class-id>Refactory.Browser.ClassBlendChange</class-id><body>A special case of cloning that involves creating a clone from a super/subclass relationship. The instance variables and shares are copied at both levels. While the subclass methods take priority over the super (since it assumes it's the desired specialization).UsageThe point of this change object is to deal with those cases where excessive factoring has produced more layers than desired in a class model. These can be difficult to "compress" back together from a strict refactoring point of view, where all behavior is preserved. One can use the Blend to create a compressed clone of the super/subclass, and then via testing iron out the wrinkles, at which point it can then be substituted back in for the original two.super sends represent a special challenge. Not all are easily unravelled, especially, if the superclass implementation includes super sends of the same. Since these methods needs to be redone anyway, when a subclass method has a super theSameSelector in it, we preserve the superclass method by prepending a __ to the front of the method name AND placing these methods in a "__lost super methods__" method category.Instance Variables	newClassName	&lt;String&gt;	assumes client has validated	originalSubclass	&lt;Behavior&gt;	assumes instanceBehavior	originalSuperclass	&lt;Behavior&gt;	ditto</body></comment><methods><class-id>Refactory.Browser.ClassCloneChange</class-id> <category>accessing</category><body package="ClassCloning" selector="name">name		^'Clone ' , originalClass name</body><body package="ClassCloning" selector="newClassName">newClassName	^newClassName</body><body package="ClassCloning" selector="newClassName:">newClassName: anObject	newClassName := anObject</body><body package="ClassCloning" selector="newlyDefinedClass">newlyDefinedClass		^originalClass environment at: newClassName asSymbol</body><body package="ClassCloning" selector="originalClass">originalClass	^originalClass</body><body package="ClassCloning" selector="originalClass:">originalClass: anObject	originalClass := anObject</body></methods><methods><class-id>Refactory.Browser.ClassCloneChange</class-id> <category>private</category><body package="ClassCloning" selector="addComment">addComment		| ws |	ws := String new writeStream.	ws		nextPutAll:				'The following comment was copied from the original comments of ';		print: originalClass;		cr;		cr;		nextPutAll: '==========================================================';		cr;		cr;		nextPutAll: originalClass comment.	self		addChange:			((CommentChange new)				objectName: self newUnambiguousName;				comment: ws contents)</body><body package="ClassCloning" selector="addDefinition">addDefinition		| ws rs change |	rs := originalClass definition readStream.	ws := String new writeStream.	ws nextPutAll: (rs through: Character space).	"namespace"	ws nextPutAll: (rs through: Character space).	"selector"	rs skipThrough: Character cr.	"throw out original name"	ws print: newClassName asSymbol.	ws nextPutAll: rs upToEnd.	change := AddClassChange definition: ws contents.	change package: (Store.Registry containingPackageForClass: originalClass).	self addChange: change</body><body package="ClassCloning" selector="addMethod:">addMethod: aMethod		| methodChange |	methodChange := (AddMethodChange new)		objectName: self newUnambiguousName;		isMeta: aMethod mclass isMeta;		setTheSource: aMethod getSource;		protocols:				(aMethod mclass whichCategoryIncludesSelector: aMethod selector);		package:				(Store.Registry						containingPackageForSelector: aMethod selector						class: aMethod mclass).	self addChange: methodChange</body><body package="ClassCloning" selector="addMethods">addMethods		originalClass		selectorsAndMethodsDo: [:selector :method | self addMethod: method].	originalClass classBehavior		selectorsAndMethodsDo: [:selector :method | self addMethod: method]</body><body package="ClassCloning" selector="addShare:">addShare: aDataBinding		| rs ws shareChange |	rs := (originalClass definitionOfStatic: aDataBinding) readStream.	rs skipThrough: Character space.	ws := String new writeStream.	ws		nextPutAll: self newUnambiguousName;		space;		nextPutAll: rs upToEnd.	shareChange := (AddSharedVariableChange definition: ws contents)		package:			(Store.Registry				containingPackageForDataKey: aDataBinding key				class: originalClass).	self addChange: shareChange</body><body package="ClassCloning" selector="addShares">addShares		originalClass asNameSpace dataBindings do: [:each | self addShare: each]</body><body package="ClassCloning" selector="assembleChanges">assembleChanges		self addDefinition.	self addComment.	self addMethods.	self addShares</body><body package="ClassCloning" selector="executeNotifying:">executeNotifying: aBlock		self assembleChanges.	^super executeNotifying: aBlock</body><body package="ClassCloning" selector="newUnambiguousName">newUnambiguousName		^originalClass environment unambiguousName , '.' , newClassName</body></methods><methods><class-id>Refactory.Browser.ClassBlendChange</class-id> <category>accessing</category><body package="ClassCloning" selector="classes:">classes: aPairOfClasses	| classes | 	classes := aPairOfClasses collect: #instanceBehavior.	originalSuperclass := classes first superclass == classes last		ifTrue: [classes last]		ifFalse: [classes first].	originalSubclass := classes first == originalSuperclass		ifTrue: [classes last]		ifFalse: [classes first]</body><body package="ClassCloning" selector="name">name		^'Blend ' , originalSuperclass name , ' &amp; ' , originalSuperclass name</body><body package="ClassCloning" selector="newClassName">newClassName	^newClassName</body><body package="ClassCloning" selector="newClassName:">newClassName: anObject	newClassName := anObject</body><body package="ClassCloning" selector="newlyDefinedClass">newlyDefinedClass		^originalSuperclass environment at: newClassName asSymbol</body><body package="ClassCloning" selector="originalSubclass">originalSubclass	^originalSubclass</body><body package="ClassCloning" selector="originalSubclass:">originalSubclass: anObject	originalSubclass := anObject</body><body package="ClassCloning" selector="originalSuperclass">originalSuperclass	^originalSuperclass</body><body package="ClassCloning" selector="originalSuperclass:">originalSuperclass: anObject	originalSuperclass := anObject</body></methods><methods><class-id>Refactory.Browser.ClassBlendChange</class-id> <category>private</category><body package="ClassCloning" selector="addComment">addComment		| ws |	ws := String new writeStream.	ws		nextPutAll:				'The following comment was copied from the original comments of ';		print: originalSuperclass;		nextPutAll: ' &amp; ';		print: originalSubclass;		cr;		cr;		nextPutAll: '==========================================================';		cr;		cr;		nextPutAll: originalSuperclass comment;		cr;		cr;		nextPutAll: '==========================================================';		cr;		cr;		nextPutAll: originalSubclass comment.	self		addChange:			((CommentChange new)				objectName: self newUnambiguousName;				comment: ws contents)</body><body package="ClassCloning" selector="addDefinition">addDefinition		| ws rs change |	rs := originalSuperclass definition readStream.	ws := String new writeStream.	ws nextPutAll: (rs through: Character space).	"namespace"	ws nextPutAll: (rs through: Character space).	"selector"	rs skipThrough: Character cr.	"throw out original name"	ws print: newClassName asSymbol.	ws nextPutAll: (rs throughAll: 'instanceVariableNames:').	rs skipThrough: Character cr.	"throw out variable names"	ws space.	ws print: self newInstanceBehaviorVariableNames.	ws nextPutAll: (rs throughAll: 'classInstanceVariableNames:').	rs skipThrough: Character cr.	"throw out  class variable names"	ws print: self newClassBehaviorVariableNames.	ws nextPutAll: rs upToEnd.	change := AddClassChange definition: ws contents.	change		package: (Store.Registry containingPackageForClass: originalSuperclass).	self addChange: change</body><body package="ClassCloning" selector="addShare:from:">addShare: aDataBinding from: aDefiningScope		| rs ws shareChange |	rs := (aDefiningScope definitionOfStatic: aDataBinding) readStream.	rs skipThrough: Character space.	ws := String new writeStream.	ws		nextPutAll: self newUnambiguousName;		space;		nextPutAll: rs upToEnd.	shareChange := (AddSharedVariableChange definition: ws contents)		package:			(Store.Registry				containingPackageForDataKey: aDataBinding key				class: aDefiningScope).	self addChange: shareChange</body><body package="ClassCloning" selector="addShares">addShares		originalSuperclass asNameSpace dataBindings		do: [:each | self addShare: each from: originalSuperclass].	originalSubclass asNameSpace dataBindings		do: [:each | self addShare: each from: originalSubclass]</body><body package="ClassCloning" selector="addSubclassMethod:">addSubclassMethod: aMethod		| methodChange |	methodChange := (AddMethodChange new)		objectName: self newUnambiguousName;		isMeta: aMethod mclass isMeta;		setTheSource: aMethod getSource;		protocols:				(aMethod mclass whichCategoryIncludesSelector: aMethod selector);		package:				(Store.Registry						containingPackageForSelector: aMethod selector						class: aMethod mclass).	self addChange: methodChange</body><body package="ClassCloning" selector="addSubclassMethods">addSubclassMethods		originalSubclass		selectorsAndMethodsDo:			[:selector :method | self addSubclassMethod: method].	originalSubclass classBehavior		selectorsAndMethodsDo:			[:selector :method | self addSubclassMethod: method]</body><body package="ClassCloning" selector="addSuperclassMethod:">addSuperclassMethod: aMethod		| methodChange isLostSuper |	isLostSuper := self isLostSuper: aMethod.	((self isOverriden: aMethod) and: [isLostSuper not]) ifTrue: [^self].	methodChange := (AddMethodChange new)		objectName: self newUnambiguousName;		isMeta: aMethod mclass isMeta;		setTheSource:				(isLostSuper						ifTrue: ['__']						ifFalse: ['']) , aMethod getSource;		protocols:				(isLostSuper						ifTrue: ['__lost super sends__']						ifFalse:							[aMethod mclass whichCategoryIncludesSelector: aMethod selector]);		package:				(Store.Registry						containingPackageForSelector: aMethod selector						class: aMethod mclass).	self addChange: methodChange</body><body package="ClassCloning" selector="addSuperclassMethods">addSuperclassMethods		originalSuperclass		selectorsAndMethodsDo:			[:selector :method | self addSuperclassMethod: method].	originalSuperclass classBehavior		selectorsAndMethodsDo:			[:selector :method | self addSuperclassMethod: method]</body><body package="ClassCloning" selector="assembleChanges">assembleChanges		self addDefinition.	self addComment.	self addSubclassMethods.	self addSuperclassMethods.	self addShares</body><body package="ClassCloning" selector="executeNotifying:">executeNotifying: aBlock		self assembleChanges.	^super executeNotifying: aBlock</body><body package="ClassCloning" selector="isLostSuper:">isLostSuper: aMethod		| selector behavior output |	selector := aMethod selector.	behavior := aMethod mclass isMeta		ifTrue: [originalSubclass classBehavior]		ifFalse: [originalSubclass].	output := String new writeStream.	output nextPutAll: 'super'.	selector last = $:		ifTrue:			[selector keywords				keysAndValuesDo:					[:index :word | 					output						space;						nextPutAll: word;						space;						nextPutAll: '``@arg' , index printString]]		ifFalse:			[output				space;				nextPutAll: selector].	^(behavior includesSelector: selector)		and:			[(ParseTreeSearcher				treeMatching: output contents				in: (behavior parseTreeFor: selector)) notNil]</body><body package="ClassCloning" selector="isOverriden:">isOverriden: aMethod		| selector behavior |	selector := aMethod selector.	behavior := aMethod mclass isMeta		ifTrue: [originalSubclass classBehavior]		ifFalse: [originalSubclass].	^behavior includesSelector: selector</body><body package="ClassCloning" selector="newClassBehaviorVariableNames">newClassBehaviorVariableNames		^originalSuperclass class instVarNames , originalSubclass class instVarNames		inject: String new		into: [:accum :each | accum , ' ' , each]</body><body package="ClassCloning" selector="newInstanceBehaviorVariableNames">newInstanceBehaviorVariableNames		^originalSuperclass instVarNames , originalSubclass instVarNames		inject: String new		into: [:accum :each | accum , ' ' , each]</body><body package="ClassCloning" selector="newUnambiguousName">newUnambiguousName		^originalSuperclass environment unambiguousName , '.' , newClassName</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-class</category><body package="ClassCloning" selector="blendClasses">blendClasses		| name change |	self changeRequest ifFalse: [^self].	name := self requestOriginalClassName ifNil: [^self].	change := ClassBlendChange new.	change classes: self selectedClasses.	change newClassName: name.	RefactoryChangeManager instance performChange: change.	self selectClass: change newlyDefinedClass.	self refreshLists</body><body package="ClassCloning" selector="cloneClass">cloneClass		| name change |	self changeRequest ifFalse: [^self].	name := self requestOriginalClassName ifNil: [^self].	change := ClassCloneChange new.	change originalClass: self nonMetaClass.	change newClassName: name.	RefactoryChangeManager instance performChange: change.	self selectClass: change newlyDefinedClass.	self refreshLists</body><body package="ClassCloning" selector="requestOriginalClassName">requestOriginalClassName		| newName |	(newName := self requestClassName) ifNil: [^nil].	(self nonMetaClass environment includesKey: newName asSymbol)		ifTrue:			[Dialog warn: newName , ' is used already. Try again.'.			^nil].	^newName</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>accessing</category><body package="ClassCloning" selector="setTheSource:">setTheSource: anObject	source := anObject</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-class</category><body package="ClassCloning" selector="blendClassesMenutItem">blendClassesMenutItem		&lt;itemInMenu: #(#classMenu) position: 30.021&gt;	^(MenuItem labeled: 'Blend')		hidden:				[(self selectedClasses size = 2						and:							[| classes |							classes := self selectedClasses asArray.							classes first superclass == classes last								or: [classes last superclass == classes first]]) not];		value: [self blendClasses]</body><body package="ClassCloning" selector="cloneClassMenutItem">cloneClassMenutItem		&lt;itemInMenu: #(#classMenu) position: 30.02&gt;	^(MenuItem labeled: 'Clone')		hidden: [self isClassSelected not];		value: [self cloneClass]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>AddMethodChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source selector protocols controller definedSelector package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Navigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigatorType cachedSelectors windowLabel </inst-vars><class-inst-vars>dependents </class-inst-vars><imports>			Store.*			</imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>CompositeRefactoryChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class></st-source>