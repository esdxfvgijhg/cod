<?xml version="1.0"?><st-source><!-- Name: OEProfilerNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This parcel profiles a statistical sampling histogram profiler for the engine.  It displays data for functions in the engine (primitives, garbage collector etc) and for the native code form of CompiledMethods that the engine actually executes.  To open the profiler use Launcher->Tools->Advanced->Profiles->Object engine or Launcher->Tools->Advanced->Profiles->Benchmark Runner and choose Object Engine profiler from the profiler type menu.DbIdentifier: bear73DbTrace: 422866DbUsername: ablakeyDbVersion: 8.0 - 1DevelopmentPrerequisites: #(#(#any 'AT Benchmarks' ''))HideSource: falsePackageName: OEProfilerParcel: #('OEProfiler')ParcelName: OEProfilerPrerequisiteParcels: #(#('AT Benchmarks' ''))PrintStringCache: (8.0 - 1,ablakey)SaveSource: trueVersion: 8.0 - 1Pre-Unload Block: 	[ :pkg |  ApplicationModel checkUnloadOfApplicationsDefinedBy: pkg]Date: 10:36:41 AM February 28, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (feb14.4) of February 28, 2014 on February 28, 2014 at 10:36:41 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SimplePlotter</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gc controller currentPoint x y top bottom left right dirty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Applications-Plotting</category><attributes><package>OEProfiler</package></attributes></class><class><name>OEProfileInterface</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nzoneLowPC nzoneHighPC engineLowPC engineHighPC engineSymbolTable inverseEngineSymbolTable sortedEngineSymbols nzoneSymbolTable nzoneSymbols fileTable sortedFiles totalHits totalTextHits totalNZoneHits totalOtherHits engineHistogram nzoneHistogram </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-OE Profiling</category><attributes><package>OEProfiler</package></attributes></class><comment><class-id>Tools.OEProfileInterface</class-id><body>Instances of OEProfilerInterface provide an interface to profil(2)-like pc-sampling profiling facilities, and to the ObjectEngine's (OE's) symbols and native methods.  It is assumed that the underlying OS provides facilities for building a histogram of PCs in the running program.Bugs/ThingsToDo:	The underlying C code doesn't yet cope with shared libraries, although this may be doable.Instance Variables:	nzoneHighPC	&lt;Integer&gt;		the highest address of the OE's dynamically-compiled code (the address immediately following it)	nzoneLowPC	&lt;Object&gt;		the lowest address of the OE's dynamically-compiled code	engineHighPC	&lt;Integer&gt;		the highest address of the OE's statically-compiled code (the address immediately following it)	engineLowPC	&lt;Integer&gt;		the lowest address of the engine's statically-compiled code	engineHistogram	&lt;UninterpretedBytes&gt;	the pc samples for the address range (engineLowPC to engineHighPC], with 4 bytes per sample.	nzoneHistogram	&lt;UninterpretedBytes&gt;	the pc samples for the address range (nzoneLowPC to nzoneHighPC], with 4 bytes per sample.	engineSymbolTable	&lt;Dictionary of: String -&gt; Integer&gt;	map from OE functions to their start addresses	inverseEngineSymbolTable	&lt;Dictionary of: Integer -&gt; String&gt;	inverse of engineSymbolTable	fileTable	&lt;(Dictionary of: (String -&gt; SlidingInterval))&gt;	map from OE object files to their address ranges.	nzoneSymbols	&lt;Array&gt;	an Array answered by the OE when profiling is stopped that contains the pairwise sequence of addresses and native methods/PICs/run-time rutines of code in the nzone.	nzoneSymbolTable	&lt;Dictionary of: (CompiledCode | PICProxy | Symbol) -&gt; Integer&gt;	map from native method/pic/run-time routine to starting address	sortedEngineSymbols	&lt;(SequenceableCollection of: (String -&gt; Integer))&gt;	engineSymbolTable's associations sorted by start address	sortedFiles	&lt;Array of: String&gt;	fileTabvle's keys sorted by start address	totalHits	&lt;Integer&gt;		sum of all pc samples for the entire address range	totalTextHits	&lt;Integer&gt;		sum of all pc samples for the (engineHighPC to engineLowPC] address range	totalNZoneHits	&lt;Integer&gt;		sum of all pc samples for the (nzoneLowPC to nzoneHighPC] address range	totalOtherHits	&lt;Integer&gt;		sum of all pc samples for code other than the VM's, i.e. the unprofiled library code. Because libraries may be loaded dynamically it is difficult to sample the pcs of library code.  Instead a single total of all library code is maintained in totalOtherHits.</body></comment><class><name>OEProfiler</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graph plotter profile lowPC highPC highSymbol lowSymbol symbolList listType selectedSymbols showIntegral gsa gea tempGsa tempGea margin labelBase histogram integral peak total samplesPerBin labels history historyIndex symbolListMenu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-OE Profiling</category><attributes><package>OEProfiler</package></attributes></class><comment><class-id>Tools.OEProfiler</class-id><body>This class provides the user interface to a pc-sampling histogram for profiling the ObjectEngine.  The interface consists of a list of all the functions, file names and natively compiled methods in the ObjectEngine, and a graph in which various parts of the histogram are displayed, plus some buttons to control the display of the histogram.One can make the OE Profiler collect profile data either by starting it up, starting profiling via the 'StartProfiling' button, performing some computation, and then stopping profiling via the 'Stop Profiling' button, or by using OEProfiler profile: aBlock.One can display the histogram data using the 'View' button which displays the currently selected range of the hsitogram.  The 'Prev' and 'Next' buttons cycle through the history of displayed views.One can control the displayed range of the  histogram in one of three ways.1. Select a range of symbols from the list.  If you select a single function name and then 'View' the graph displays the portion of the histogram corresponding to the selected function.  Likewise, if you select a file name the display shows all the functions in that file.  One can use control-select to extend the selection.  There is also an Operate menu which allows one to search for a given symbol, etc.2. Select a sub-range of the currently displayed histogram by using the 'select lo pc:' and ':select hi pc' buttons.  Click on the desired button (cointaining a cross-hair) and the cursor changes to a cross-hair.  Click the Select mouse button somewhere in the histogram and it sets the lo or hi pc appropriately.  Press 'View' to see the new graph.3.  Type values directly into the 'pc lo[' and 'pc hi)' fields.  These fields are updated to show the boundaries of the current histogram.  When using method 2. to set the pc range the fields show in italics the new selection range before it is displayed.Instance Variables:graph					&lt;SpecWrapper&gt;							the graph widget, used by the plotter to display the hsitogramplotter					&lt;SimplePlotter&gt;							a simple plotter used to draw the graphprofile					&lt;OEProfileInterface&gt;							the interface to the underlying profile data and the symbol table.lowPC					&lt;ValueHolder&gt;							value holder for lo pc fieldhighPC				&lt;ValueHolder&gt;							value holder for hi pc fieldhighSymbol			&lt;ValueHolder&gt;							value holder for hi symbol fieldlowSymbol			&lt;ValueHolder&gt;							value holder for lo symbol fieldsymbolList			&lt;MultiSelectionInList&gt;							the list of symbolsselectedSymbols	&lt;OrderedCollection&gt;							collection of the symbols in rangeshowIntegral			&lt;ValueHolder&gt;							value holder for 'show integral' check-box, which, if set, causes the							display of the integral of the histogram above the hitogram itself.gsa	&lt;Integer&gt;							lo pc of current range (Graph Start Address)gea	&lt;Integer&gt;							hi pc of current range (Graph End Address)tempGsa	&lt;Integer|nil&gt;							holds the temporary lo pc selection made via the 'select lo pc:' buttontempGea	&lt;Integer|nil&gt;							holds the temporary hi pc selection made via the ':select hi pc' buttonmargin	&lt;Float&gt;							fraction of graph width or height used for the graph marginslabelBase	&lt;Float&gt;							fraction of graph height in which to display program labelshistogram	&lt;Array of: Integer&gt;							array of bins in graph.  Each bin may hold the sum of several samples in the OE histogramintegral	&lt;Array of: Integer&gt;							integral of histogrampeak	&lt;Integer&gt;							highest value in histogramtotal	&lt;Integer&gt;							sum of bins in histogramsamplesPerBin	&lt;Integer&gt;							number of samples in each bin (element) of histogramlabels	&lt;Array of: (String|nil)&gt;							the labels to display below the histogramhistory	&lt;OrderedCollection of: (Array of: Integer)&gt;							history of gsa,gea pairs for each displayed rangehistoryIndex	&lt;Integer&gt;							cuirrent position in historyClass Variables:CurrentProfileInterface		&lt;OEProfileInterface&gt;									holds onto the single instance of OEProfileInterface through which the									profile data and symbol table are accessed.</body></comment><class><name>PICProxy</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-OE Profiling</category><attributes><package>OEProfiler</package></attributes></class><shared-variable><name>CurrentProfileInterface</name><environment>Tools.OEProfiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OEProfiler</package></attributes></shared-variable><methods><class-id>Tools.SimplePlotter</class-id> <category>accessing</category><body package="OEProfiler">bounds: aRectangle	"Set the plotter's bounds (in screen coordinates)"	top := aRectangle bottom.	bottom := aRectangle top.	left := aRectangle left.	right := aRectangle right</body><body package="OEProfiler">graphicsContext: aGraphicsContext	"Initialize the receiver."	gc := aGraphicsContext.	dirty := false</body><body package="OEProfiler">selectSmallestFont	| af sfd |	af := gc fontPolicy availableFonts select: [:f| f pixelSize &gt;= 10].	sfd := af inject: af first			into: [:ff :nf |				nf pixelSize &lt; ff pixelSize					ifTrue: [nf]					ifFalse: [ff]].	gc font: (gc fontPolicy findFont: sfd)</body></methods><methods><class-id>Tools.SimplePlotter</class-id> <category>plotting</category><body package="OEProfiler">clear	| oldPaint |	oldPaint := gc paint.	gc paint: gc medium background.	gc displayRectangle: ((self scale: 0@1) corner: (self scale: 1@0)).	gc paint: oldPaint.	gc flush.	gc medium graphicsDevice sync.	ScheduledControllers checkForEvents.</body><body package="OEProfiler">clearWith: aPaint	| oldPaint |	oldPaint := gc paint.	gc paint: aPaint.	gc displayRectangle: ((self scale: 0@1) corner: (self scale: 1@0)).	gc paint: oldPaint.	gc flush.	gc medium graphicsDevice sync</body><body package="OEProfiler">goTo: aPoint	"Draw a line."	currentPoint := (self scale: aPoint)</body><body package="OEProfiler">label: aString at: aPoint	"comment stating purpose of message"	gc displayString: aString at: (self scale: aPoint)</body><body package="OEProfiler">lineFrom: aPoint to: bPoint	"Draw a line."	gc displayLineFrom: (self scale: aPoint) to: (currentPoint := self scale: bPoint).	dirty := true</body><body package="OEProfiler">lineTo: aPoint	"Draw a line."	gc displayLineFrom: currentPoint to: (currentPoint := self scale: aPoint).	dirty := true</body></methods><methods><class-id>Tools.SimplePlotter</class-id> <category>shapes</category><body package="OEProfiler">drawRectangle: aRectangle	| delay |	delay := Delay forMilliseconds: 250.	self goTo: aRectangle topLeft.	self lineTo: aRectangle bottomLeft.	delay wait.	self lineTo: aRectangle bottomRight.	delay wait.	self lineTo: aRectangle topRight.	delay wait.	self lineTo: aRectangle topLeft.	delay wait.</body></methods><methods><class-id>Tools.SimplePlotter</class-id> <category>private</category><body package="OEProfiler">scale: aPoint	"Scale aPoint expressed in the universal coordinate system 0,0 -&gt; 1,1 to our coordinate system."	^(aPoint x * (right - left) + left) rounded @ (aPoint y * (bottom - top) + top) rounded</body></methods><methods><class-id>Tools.SimplePlotter class</class-id> <category>instance creation</category><body package="OEProfiler">graphicsContext: aGraphicsContext	"Return a new plotter on nothing."	^self new graphicsContext: aGraphicsContext</body></methods><methods><class-id>Tools.OEProfileInterface</class-id> <category>testing</category><body package="OEProfiler">isFileSymbol: aSymbol	^fileTable includesKey: aSymbol</body></methods><methods><class-id>Tools.OEProfileInterface</class-id> <category>accessing</category><body package="OEProfiler">addressOf: aSymbol	"Return aSymbol's address; raise an error if the symbol doesn't exist."	^((self isEngineSymbol: aSymbol)			ifTrue: [engineSymbolTable]			ifFalse: [self nzoneSymbolTable])		at: aSymbol		ifAbsent: [(fileTable at: aSymbol) first]</body><body package="OEProfiler">addressOf: aSymbol ifAbsent: aBlock	"Return aSymbol's address; answer the evaluation of aBlock if the symbol doesn't exist."	^(self isEngineSymbol: aSymbol)		ifTrue:			[engineSymbolTable				at: aSymbol				ifAbsent: [(fileTable at: aSymbol ifAbsent: [Array with: aBlock value]) first]]		ifFalse:			[self nzoneSymbolTable at: aSymbol ifAbsent: aBlock]</body><body package="OEProfiler">addressRangeOf: aSymbol	"Return aSymbol's address range"	^fileTable		at: aSymbol		ifAbsent: [SlidingInterval						from: (self addressOf: aSymbol)						to: (self addressOf: (self nextSymbolTo: aSymbol))]</body><body package="OEProfiler">buildHistogramFor: pcRange into: anArray samplesPerBin: samplesPerBin 	anArray atAllPut: 0.	self		fillHistogram: anArray		samplesPerBin: samplesPerBin		from: pcRange first		to: pcRange last		from: engineHistogram		start: engineLowPC		end: engineHighPC.	self		fillHistogram: anArray		samplesPerBin: samplesPerBin		from: pcRange first		to: pcRange last		from: nzoneHistogram		start: nzoneLowPC		end: nzoneHighPC</body><body package="OEProfiler">costsBySymbol	"Return an Array of the total cost and the ObjectEngine's text symbols, sorted by cost, most to least, as a sequence of associations of cost to name."	^Cursor execute showWhile:		[| bins total |		total := 0.		bins := (self sortedSymbols asArray reject: [:sym| fileTable includesKey: sym])					collect:						[:sym| | t |						t := self totalForNonFileSymbol: sym.						total := total + t.						t -&gt; sym].		Array			with: total			with: bins asSortedCollection asArray reverse]</body><body package="OEProfiler">endPC	"Return the lowest pc in our range."	^nzoneHighPC</body><body package="OEProfiler">engineSymbolTable	"Return the ObjectEngine's text symbol table."	| tables |	engineSymbolTable isNil		ifTrue:			 [OSHandle currentOS = #win32				ifTrue:					[tables := self ntTextSymbols.					engineSymbolTable := tables key.					fileTable := tables value].			OSHandle currentOS = #unix				ifTrue: [engineSymbolTable := self unixTextSymbols.						fileTable := Dictionary new].			self buildSortedEngineSymbols].	^engineSymbolTable</body><body package="OEProfiler">findAddressInNZoneSymbols: anAddress ifAbsent: aBlock 	| index |	index := self findIndexOfNZoneSymbolAtAddress: anAddress.	index = 0 ifTrue: [^aBlock value].	^nzoneSymbols at: index</body><body package="OEProfiler">firstEngineSymbol	^sortedEngineSymbols first key</body><body package="OEProfiler">firstNZoneSymbol	^nzoneSymbols at: 2</body><body package="OEProfiler">lastEngineSymbol	^sortedEngineSymbols last key</body><body package="OEProfiler">lastNZoneSymbol	^nzoneSymbols at: nzoneSymbols size - 2</body><body package="OEProfiler">nearestNZoneSymbolBefore: anAddress into: aBlock	| index |	index := self indexForInsertingNZoneAddress: anAddress.	index &gt; 1 ifTrue:		[aBlock value: (nzoneSymbols at: index - 1) value: (nzoneSymbols at: index - 2)]</body><body package="OEProfiler">nearestSymbolBefore: anAddress into: aBlock	anAddress &lt; engineHighPC ifTrue:		[^self nearestNonFileEngineSymbolBefore: anAddress into: aBlock].	anAddress &gt; nzoneLowPC ifTrue:		[^self nearestNZoneSymbolBefore: anAddress into: aBlock].</body><body package="OEProfiler">nextNZoneSymbolTo: aSymbol	^(fileTable includesKey: aSymbol)		ifTrue:			[| index |			index := sortedFiles indexOf: aSymbol.			sortedFiles at: (index + 1 min: sortedFiles size)]		ifFalse: [self nextNonFileNZoneSymbolTo: aSymbol]</body><body package="OEProfiler">nextNonFileEngineSymbolTo: aSymbol	"Return the symbol following a symbol in the program."	| index limit assoc |	index := sortedEngineSymbols indexOf: (engineSymbolTable associationAt: aSymbol).	limit := sortedEngineSymbols size.	[(index := index + 1) &lt;= limit	 and: [fileTable includesKey: (assoc := sortedEngineSymbols at: index) key]] whileTrue.	^index &lt;= limit 		ifTrue: [assoc key]		ifFalse: [aSymbol]</body><body package="OEProfiler">nextNonFileNZoneSymbolTo: aSymbol 	| index |	index := self findIndexOfNZoneSymbolAtAddress: (nzoneSymbolTable at: aSymbol).	^nzoneSymbols at: (index + 2 min: nzoneSymbols size)</body><body package="OEProfiler">nextNonFileSymbolTo: aSymbol	"Return the symbol following a symbol in the program."	^(self isEngineSymbol: aSymbol)		ifTrue: [self nextNonFileEngineSymbolTo: aSymbol]		ifFalse: [self nextNonFileNZoneSymbolTo: aSymbol]</body><body package="OEProfiler">nextSymbolTo: aSymbol	"Return the symbol following a symbol in the program."	| index |	(self isEngineSymbol: aSymbol)		ifTrue:			[(fileTable includesKey: aSymbol)				ifTrue:					[index := sortedFiles indexOf: aSymbol.					^sortedFiles at: (index + 1 min: sortedFiles size)].			index := sortedEngineSymbols indexOf: (engineSymbolTable associationAt: aSymbol).			^(sortedEngineSymbols at: (index + 1 min: sortedEngineSymbols size)) key].	^self nextNZoneSymbolTo: aSymbol</body><body package="OEProfiler">nonFileAddressOf: aSymbol	"Return aSymbol's address, exclusing file symbols; raise an error if the symbol doesn't exist."	^((self isEngineSymbol: aSymbol)		ifTrue: [engineSymbolTable]		ifFalse: [self nzoneSymbolTable]) at: aSymbol</body><body package="OEProfiler">nonFileAddressOf: aSymbol ifAbsent: aBlock	"Return aSymbol's address, excluding file symbols; answer the evaluation of aBlock if the symbol doesn't exist."	^((self isEngineSymbol: aSymbol)			ifTrue: [engineSymbolTable]			ifFalse: [self nzoneSymbolTable])		at: aSymbol ifAbsent: aBlock</body><body package="OEProfiler">nzoneSize	^nzoneHighPC - nzoneLowPC</body><body package="OEProfiler">nzoneSymbolTable	nzoneSymbolTable isNil ifTrue:		[Cursor wait showWhile:			[| pics notPastNMethods |			 nzoneSymbols isNil ifTrue: [self stopProfiling].			 nzoneSymbolTable := IdentityDictionary new: nzoneSymbols size.			 pics := IdentityDictionary new: nzoneSymbols size // 10.			 notPastNMethods := true.			nzoneSymbolTable at: (nzoneSymbols at: 2) put: (nzoneSymbols at: 1).			 3 to: nzoneSymbols size by: 2 do:				[:i| | sym |				sym := nzoneSymbols at: i + 1.				sym = #'.NMethodEnd' ifTrue: [notPastNMethods := false].				"PICs are represented by their selectors, but they're not unique"				(sym isSymbol and: [notPastNMethods])					ifTrue: [(pics at: sym ifAbsentPut: [OrderedCollection new]) addLast: (nzoneSymbols at: i) -&gt; i]					ifFalse: [nzoneSymbolTable at: sym put: (nzoneSymbols at: i)]].			pics keysAndValuesDo:				[:sym :addresses|				1 to: addresses size do:					[:i| | picProxy |					picProxy := PICProxy selector: sym tag: (addresses size &gt; 1 ifTrue: [i]).					nzoneSymbolTable						at: picProxy						put: (addresses at: i) key.					nzoneSymbols at: (addresses at: i) value + 1 put: picProxy]]]].	^nzoneSymbolTable</body><body package="OEProfiler">oeCostsBySymbol	"Return an Array of the total cost and the ObjectEngine's text symbols, sorted by cost, most to least, as a sequence of associations of cost to name."	^Cursor execute showWhile:		[| bins total |		total := 0.		bins := (self sortedOESymbols asArray reject: [:sym| fileTable includesKey: sym])					collect:						[:sym| | t |						t := self totalForNonFileSymbol: sym.						total := total + t.						t -&gt; sym].		Array			with: total			with: bins asSortedCollection asArray reverse]</body><body package="OEProfiler">pcsPerBin	^4</body><body package="OEProfiler">rangeForNonFileSymbol: aSymbol	"Return the index range in histogram corresponding to the PC-range of a symbol in the program."	^(self nonFileAddressOf: aSymbol)		to: (self nonFileAddressOf: (self nextNonFileSymbolTo: aSymbol)) - 1</body><body package="OEProfiler">rangeForSymbol: aSymbol	"Return the index range in histogram corresponding to the PC-range of a symbol in the program."	^(self addressOf: aSymbol)		to: (self addressOf: (self nextSymbolTo: aSymbol)) - 1</body><body package="OEProfiler">samplesForRange: pcRange	^pcRange last - pcRange first + 1 // 4</body><body package="OEProfiler">sortedOESymbols	"Return the ObjectEngine's text symbols minus the NZone."	self engineSymbolTable.	self nzoneSymbolTable.	^(sortedEngineSymbols asArray collect: [:assoc| assoc key]),	  (((nzoneSymbols indexOf: #'.NMethodEnd') + 2 to: nzoneSymbols size by: 2) collect: [:i| nzoneSymbols at: i])</body><body package="OEProfiler">sortedStSymbols	"Return the ObjectEngine's current Smalltalk nmethod symbols."	self engineSymbolTable.	self nzoneSymbolTable.	"Start from 4, not 2, because first element is the pseudo-symbol #'.NZone' marker"	^(4 to: (nzoneSymbols indexOf: #'.NMethodEnd') - 2 by: 2) collect: [:i| nzoneSymbols at: i]</body><body package="OEProfiler">sortedSymbols	"Return the ObjectEngine's text symbols."	self engineSymbolTable.	self nzoneSymbolTable.	^(sortedEngineSymbols asArray collect: [:assoc| assoc key]),	  ((2 to: nzoneSymbols size by: 2) collect: [:i| nzoneSymbols at: i])"ws := (String new: 32) writeStream. s printNameOn: ws inClass: s mclass. ws contents"</body><body package="OEProfiler">stCostsBySymbol	"Answer an Array of the total cost and the ObjectEngine's Smalltalk nmethod symbols,	 sorted by cost, most to least, as a sequence of associations of cost to name."	^Cursor execute showWhile:		[| bins total |		total := 0.		bins := self sortedStSymbols collect:						[:sym| | t |						t := self totalForNonFileSymbol: sym.						total := total + t.						t -&gt; sym].		Array			with: total			with: bins asSortedCollection asArray reverse]</body><body package="OEProfiler">startPC	"Return the lowest pc in our range."	^engineLowPC</body><body package="OEProfiler">symbolOf: anAddress ifAbsent: aBlock	"Return a symbol for the argument anAddress"	^(anAddress between: engineLowPC and: engineHighPC)		ifTrue: [inverseEngineSymbolTable at: anAddress ifAbsent: aBlock]		ifFalse: [self findAddressInNZoneSymbols: anAddress ifAbsent: aBlock]</body><body package="OEProfiler">symbolsSortedByCost	"Return the ObjectEngine's text symbols, sorted by cost, most to least."	^(self costsBySymbol at: 2) collect: [:assoc| assoc value]</body><body package="OEProfiler">totalForNonFileSymbol: aSymbol	"Return the total hits in histogram corresponding to the given symbol's PC-range."	^self totalForRange: (self rangeForNonFileSymbol: aSymbol)</body><body package="OEProfiler">totalForRange: pcs	"Return the total hits in histogram corresponding to the given PC-range."	| total |	total := 0.	pcs first &lt; engineHighPC ifTrue:		[(self indexForEngineAddress: (pcs first max: engineLowPC))			to: (self indexForEngineAddress: (pcs last min: engineHighPC)) - 3			by: 4			do: [:i| total := total + (engineHistogram unsignedLongAt: i)]].	pcs last &gt; nzoneLowPC ifTrue:		[(self indexForNZoneAddress: (pcs first max: nzoneLowPC))			to: (self indexForNZoneAddress: (pcs last min: nzoneHighPC)) - 3			by: 4			do: [:i| total := total + (nzoneHistogram unsignedLongAt: i)]].	^total</body><body package="OEProfiler">totalForSymbol: aSymbol	"Return the total hits in histogram corresponding to the given symbol's PC-range."	^self totalForRange: (self rangeForSymbol: aSymbol)</body><body package="OEProfiler">totalHits	^totalHits</body><body package="OEProfiler">totalOEHits	^totalTextHits + totalNZoneHits</body><body package="OEProfiler">totalOENZoneHits	^totalNZoneHits</body><body package="OEProfiler">totalOETextHits	^totalTextHits</body><body package="OEProfiler">totalOtherHits	^totalOtherHits</body></methods><methods><class-id>Tools.OEProfileInterface</class-id> <category>private</category><body package="OEProfiler">buildSortedEngineSymbols	"Build a list of symbols sorted by ascending pc."	inverseEngineSymbolTable := Dictionary new: self engineSymbolTable size * 4.	engineSymbolTable keysAndValuesDo:		[:k :v | | prev |		inverseEngineSymbolTable			at: v			put: ((prev := inverseEngineSymbolTable at: v ifAbsent: nil) == nil 					ifTrue: [k]					ifFalse: [prev , ',' , k])].	sortedEngineSymbols := SortedCollection sortBlock: 				[:a :b | | av bv |				(av := a value) isInteger ifFalse: [av := av first].				(bv := b value) isInteger ifFalse: [bv := bv first].				av = bv					ifTrue: [b value isInteger]					ifFalse: [av &lt; bv]].	sortedEngineSymbols addAll: engineSymbolTable associations.	fileTable notNil ifTrue:		[sortedEngineSymbols addAll: (fileTable associations select: [:assoc| assoc value first &lt; engineHighPC])].	self computeSortedFiles</body><body package="OEProfiler">computeSortedFiles	sortedFiles := (fileTable associations asSortedCollection:						[:a :b | a value first &lt; b value first])							asArray collect: [:assoc | assoc key]</body><body package="OEProfiler">fillHistogram: anArray samplesPerBin: samplesPerBin from: histLoPC to: histHiPC from: profileData start: profileLoPC end: profileHiPC	(histLoPC max: profileLoPC) to: (histHiPC min: profileHiPC) by: 4 * samplesPerBin do:		[:pc| | total index |		total := 0.		pc to: (pc + (4 * samplesPerBin) min: (histHiPC min: profileHiPC)) - 3 by: 4 do:			[:profileIndex|			total := total + (profileData unsignedLongAt: profileIndex - profileLoPC + 1)].		index := (pc - histLoPC / (4.0 * samplesPerBin)) truncated + 1.		index &lt; anArray size ifTrue:			[anArray at: index put: total]]</body><body package="OEProfiler">findIndexOfNZoneSymbolAtAddress: anInteger 	"Look for the key in the receiver.  If it is found, answer	the key's index, otherwise answer 0."	| index low high probe |	high := nzoneSymbols size - 1.	low := 1.	[index := (low + high bitShift: -1) bitOr: 1.	low &gt; high ifTrue: [^0].	(probe := nzoneSymbols at: index) = anInteger ifTrue: [^index + 1].	probe &lt; anInteger		ifTrue: [low := index + 2]		ifFalse:			[probe &gt; anInteger				ifTrue: [high := index - 2]				ifFalse:					["Equal values.  Need linear search both ways until found."					low := index - 2.					[low &lt; 1 ifTrue: [^0].					(probe := self basicAt: low) = anInteger ifTrue: [^low].					probe = anInteger]						whileTrue: [low := low - 2].					low := index + 2.					[low &gt; high ifTrue: [^0].					(probe := self basicAt: low) = anInteger ifTrue: [^low].					probe = anInteger]						whileTrue: [low := low + 2].					^0]]] repeat</body><body package="OEProfiler">indexForEngineAddress: anAddress	^(anAddress bitAnd: -4) - engineLowPC + 1</body><body package="OEProfiler">indexForInsertingNZoneAddress: anInteger 	"Look for the key in the receiver.  If it is found, answer	the address's index, otherwise answer the index for inserting it."	| index low high probe |	high := nzoneSymbols size - 1.	low := 1.	[index := (low + high bitShift: -1) bitOr: 1.	low &gt; high ifTrue: [^index].	(probe := nzoneSymbols at: index) == anInteger ifTrue: [^index].	probe &lt; anInteger		ifTrue: [low := index + 2]		ifFalse:			[probe &gt; anInteger				ifTrue: [high := index - 2]				ifFalse:					["Equal addresses.  Need linear search both ways until found."					low := index - 2.					[low &lt; 1 ifTrue: [^index].					(probe := self basicAt: low) == anInteger ifTrue: [^low].					probe = anInteger]						whileTrue: [low := low - 2].					low := index + 2.					[low &gt; high ifTrue: [^0].					(probe := self basicAt: low) == anInteger ifTrue: [^low].					probe = anInteger]						whileTrue: [low := low + 2].					^low]]] repeat</body><body package="OEProfiler">indexForNZoneAddress: address	"Answer an index in the engine histogram for an address."	^(address bitAnd: -4) - nzoneLowPC + 1</body><body package="OEProfiler">isEngineSymbol: anObject 	"We distinguish between engine and nzone symbols 	by using strings for engine symbols and either 	methods or Symbols for nzone symbols. To do this we 	have to intern the names of the translated runtime 	routines whcih are passed back to us as strings."	^anObject isString and: [anObject isSymbol not]</body><body package="OEProfiler">ntTextSymbols	"Return a dictionary which maps each of the given names to their addresses or values."	"self basicNew ntTextSymbols"	| oe map file oedll symbols oedllmap dllSymbols |	oe := CEnvironment commandLine first asLowercase.	map := oe copyReplaceAll: 'exe' with: 'map'.	symbols := self ntTextSymbolsFor: map.	symbols key size &gt; 250 ifTrue:		[^symbols].	file := map asFilename readStream.	[(file skipToAll: '_dllCMain'; skipThrough: $:; atEnd) ifFalse:		[oedll := file upTo: Character cr]]		ensure: [file close]. 	oedll notNil ifTrue:		[oedllmap := oe asFilename directory construct: (oedll copyReplaceAll: 'dll' with: 'map').		 dllSymbols := self ntTextSymbolsFor: oedllmap.		 dllSymbols key addAll: symbols key associations.		 dllSymbols value addAll: symbols value associations.		 ^dllSymbols].	^self ntTextSymbolsFor: map</body><body package="OEProfiler">ntTextSymbolsFor: mapFile	"Return a pair of dictionaries which map each of the given names to their addresses or values.	 The pair is an association of Dictionary of functionName -&gt; address and Dictionary from objectFileName -&gt; addressRange."	"(self basicNew ntTextSymbolsFor: 'E:\HPS\BIN\VWNT.MAP')"	| map file objectMap |	map := Dictionary new: 1024.	objectMap := Dictionary new: 32.	file := mapFile asFilename readStream.	[| line i name address filename interval |	[file atEnd]		whileFalse:			[line := file upTo: Character cr.			(line size &gt; 4			and: [(line copyFrom: line size - 3 to: line size) = '.obj'			and: [(Integer readFrom: line readStream skipSeparators) between: 1 and: 2 "code in sections 1 &amp; 2"]])				ifTrue: [					i := 22.					[(line at: i) = Character space]						whileFalse: [i := i + 1].					name := line copyFrom: ((line at: 22) = $_ ifTrue: [23] ifFalse: [22]) to: i - 1.					[(line at: i) isDigit]						whileFalse: [i := i + 1].					address := Integer									readFrom: (ReadStream on: line from: i to: line size)									radix: 16.					"Prepend a space to all non-file symbols to make them stand-out"					map at: ' ', name put: address.					i := line size - 4.					[(line at: i) = Character space					or: [(line at: i) = $:]]						whileFalse: [i := i - 1].					filename := line copyFrom: i + 1 to: line size.					interval := objectMap at: filename ifAbsentPut: [SlidingInterval from: address to: address].					interval first &gt; address ifTrue: [interval addFirst: address].					interval stop &lt; address ifTrue: [interval addLast: address].		]]] ensure: [file close].	^map -&gt; objectMap</body><body package="OEProfiler">unixTextSymbols	"Return a dictionary which maps each of the given names to their addresses or values."	"self new unixTextSymbols"	| oe |	oe := CEnvironment commandLine first.	oe first = UnixFilename currentDirectoryString		ifTrue:			[oe := Filename defaultDirectoryName, (oe copyFrom: 2 to: oe size)].	(oe asFilename isAbsolute	or: [oe asFilename exists])		ifFalse:			["go search environment"			Dialog warn: 'go implement searching for oe via PATH'].	^self unixTextSymbolsFor: oe</body><body package="OEProfiler">unixTextSymbolsFor: adotout	"Return a dictionary which maps each of the given names to their addresses or values."	"(self basicNew unixTextSymbolsFor: '/vmunix')"	"(self basicNew unixTextSymbolsFor: '/vmunix') size"	"(self basicNew unixTextSymbols)"	"(self basicNew unixTextSymbols) size"	| map fileName |	map := Dictionary new: 1024.	fileName := '/tmp/OEProfile', (CEnvironment getenv: 'USER').	('*apple*' match: OSHandle currentPlatformID)		ifTrue:			[(UnixProcess				forkJob: '/bin/sh'				arguments: (Array									with: '-c'									with: 'nm -v -p ', adotout, ' | grep " [tT] " &gt;', fileName)) wait.			Stream incompleteNextCountSignal				handle: [:ex| ^map]				do: [ | s nameStream cr c v lastV filler |					s := fileName asFilename readStream.					nameStream := String new writeStream.					cr := Character cr.					["[s next == $x] whileFalse."					v := Integer readFrom: s radix: 16.					((filler := s next: 3) ~= ' T '					and: [filler ~= ' t '])						ifTrue: [self error: 'parse error'].					nameStream reset.					[(c := s next)  == cr] whileFalse: [nameStream nextPut: c].					v ~= lastV						ifTrue:							[map at: nameStream contents put: v.							lastV := v]] repeat]].	('*solaris*' match: OSHandle currentPlatformID) ifTrue:		[(UnixProcess			forkJob: '/bin/sh'			arguments: (Array								with: '-c'								with: 'nm -v -x -p ', adotout, ' | grep " [tT] " | fgrep -v ''t  $00'' &gt;', fileName)) wait.		[ | s nameStream cr c v lastV filler |		s := fileName asFilename readStream.		nameStream := String new writeStream.		cr := Character cr.		[[s next == $x] whileFalse. "skip leading 0x"		v := Integer readFrom: s radix: 16.		((filler := s next: 3) ~= ' T ' and: [filler ~= ' t ']) ifTrue:			[self error: 'parse error'].		nameStream reset.		[(c := s next)  == cr] whileFalse: [nameStream nextPut: c].		v ~= lastV ifTrue:			[map at: nameStream contents put: v.			lastV := v]] repeat]			on: Stream endOfStreamSignal			do: [:ex| ^map]].	('*linux*' match: OSHandle currentPlatformID) ifTrue:		[(UnixProcess			forkJob: '/bin/sh'			arguments: (Array							with: '-c'							with: 'nm --defined-only --numeric-sort --radix=x ', adotout, ' | grep " [tT] " &gt;', fileName)) wait.		[ | s nameStream cr c v lastV filler |		s := fileName asFilename readStream.		nameStream := String new writeStream.		cr := Character cr.		[[s next == $0] whileFalse. "hex numbers printed as 0F00"		v := Integer readFrom: s radix: 16.		((filler := s next: 3) ~= ' T ' and: [filler ~= ' t ']) ifTrue:			[self error: 'parse error'].		nameStream reset.		[(c := s next)  == cr] whileFalse: [nameStream nextPut: c].		v ~= lastV ifTrue:			[map at: nameStream contents put: v.			lastV := v]] repeat]			on: Stream endOfStreamSignal			do: [:ex| ^map]].	('*ibm*aix*' match: OSHandle currentPlatformID) ifTrue:		[(UnixProcess			forkJob: '/bin/sh'			arguments: (Array								with: '-c'								with: 'nm -B -e -p -x  ', adotout, ' | grep " [tT] " &gt;', fileName)) wait.		[ | s nameStream cr c v lastV filler |		s := fileName asFilename readStream.		nameStream := String new writeStream.		cr := Character cr.		[[s next == $x] whileFalse. "skip leading 0x"		v := Integer readFrom: s radix: 16.		((filler := s next: 3) ~= ' T ' and: [filler ~= ' t ']) ifTrue:			[self error: 'parse error'].		nameStream reset.		[(c := s next)  == cr] whileFalse: [nameStream nextPut: c].		v ~= lastV ifTrue:			[map at: nameStream contents put: v.			lastV := v]] repeat]			on: Stream endOfStreamSignal			do: [:ex| ^map]].	^map</body></methods><methods><class-id>Tools.OEProfileInterface</class-id> <category>disassembly</category><body package="OEProfiler">disassembleFrom: startAddress to: stopAddress	| string |	string := self primDisassembleFrom: startAddress to: stopAddress.	string := IOAccessor convertSimpleStringFromPlatform: string.	^self expandSymbolsIn: string</body><body package="OEProfiler">expandSymbolsIn: aString	| source dest address symbol isAtStartOfLine |	source := (aString					copyReplaceAll: (String with: Character lf)					with: (String with: Character cr)) readStream.	dest := (String new: aString size) readWriteStream.	[source atEnd] whileFalse:		[dest nextPutAll: (source upTo: $_).		isAtStartOfLine := dest position = 0 or: [(dest skip: -1; next) = Character cr].		('0123456789abcdef' includes: source peek)			ifFalse:				[dest nextPut: $_]			ifTrue:				[address := Integer readFrom: source radix: 16.				 symbol := self symbolOf: address ifAbsent: nil.				 (symbol == nil				 and: [isAtStartOfLine not]) ifTrue:					[self nearestSymbolBefore: address into:						[:nearest :nearestAddress|						(nearestAddress - address) abs &lt; 64 ifTrue:							[symbol := nearest, '+', (address - nearestAddress printStringRadix: 16) asLowercase,											' (', (address printStringRadix: 16) asLowercase, ')']]].				symbol == nil ifTrue:					[symbol := '_', (address printStringRadix: 16) asLowercase. isAtStartOfLine := false].				 dest nextPutAll: symbol.				 isAtStartOfLine ifTrue:					[dest nextPut: $:; cr; nextPut: $_; nextPutAll: (address printStringRadix: 16) asLowercase]]].	^dest contents</body></methods><methods><class-id>Tools.OEProfileInterface</class-id> <category>primitives</category><body package="OEProfiler">enableProfiling: aBoolean withEngineData: engineFixedArray nzoneData: nzoneFixedArray 	"The boolean argument controls profiling; true turns 	on profiling, false turns it off. The two fixed arrays 	are fixedSpace objects used to hold the profiling 	data. Their sizes must correspond to the ranges 	profile_text_lopc to profile_text_hipc and 	profile_nzone_lopc to profile_nzone_hipc 	respectively, and with the same ratios. The primitive 	fails if any of these constraints isn't met or if the 	return values cannot be allocated. Turning on the 	profile causes the primitive to start a periodic timer 	that samples the engine thread's PC and increments 	a 16-bit histogram bin corresponding to that PC in 	engineData or nzoneData as appropriate, and to 	answer nil. Turning off the profile causes the 	primitive to stop the periodic timer and return an 	Array of address,object pairs describing the contents 	of the nzone, organized in ascending address order. 	The address is an integer, and the object is a 	vMethod for an nMethod, a selector for a PIC and a 	string for a translated run-time routine. Two special 	run-time routine labels for addresses at the end of 	nzoneData correspond to data for pcs that lie outside 	of the engine or nzone (i.e. in system code) and data 	that has been compacted away by nzone 	compaction."	&lt;primitive: 1002 errorCode: err&gt;	^self primitiveFailed	"| oep r oes nzs oefa nzfa | 	oep := self basicNew. 	r := oep getProfileRanges. 	oes := (r at: 2) - (r at: 1). 	nzs := (r at: 4) - (r at: 3). 	oefa := UninterpretedBytes newInFixedSpace: oes. 	nzfa := UninterpretedBytes newInFixedSpace: nzs. 	oep enableProfiling: true withEngineData: oefa nzoneData: nzfa. 	oep enableProfiling: false withEngineData: nil nzoneData: nil"</body><body package="OEProfiler">getProfileRanges	"Answer an Array of four addresses		the address of base of engine text segment,		the address of end of text segment,		the address of base of nzone,		the address of end of nzone	These are the ranges of code primitive 1002 requires fixed space arrays	to be provided for to profile the engine."	&lt;primitive: 1001 errorCode: err&gt;	^self primitiveFailed	"self new getProfileRanges"</body><body package="OEProfiler">primDisassembleFrom: startAddress to: stopAddress	&lt;primitive: 1007 errorCode: _ec&gt;	^self primitiveFailed</body></methods><methods><class-id>Tools.OEProfileInterface</class-id> <category>initialize-release</category><body package="OEProfiler">clearProfile	"Zero the ObjectEngine's profile histogram."	self enableProfiling: false withEngineData: engineHistogram nzoneData: nzoneHistogram.	engineHistogram notNil ifTrue:		[1 to: engineHistogram basicSize by: 4 do:			[:i| engineHistogram unsignedLongAt: i put: 0].		 1 to: nzoneHistogram basicSize by: 4 do:			[:i| nzoneHistogram unsignedLongAt: i put: 0]].	totalHits := totalTextHits := totalNZoneHits := totalOtherHits := 0</body><body package="OEProfiler">initialize	"Enable ObjectEngine profiling.  Build the accessor for the histogram. Set up the symbol table etc."	| vector |	vector := self getProfileRanges.	engineLowPC := vector at: 1.	engineHighPC := vector at: 2.	nzoneLowPC := vector at: 3.	nzoneHighPC := vector at: 4.	engineHistogram isNil ifTrue:		[engineHistogram := UninterpretedBytes newInFixedSpace: engineHighPC - engineLowPC.		 nzoneHistogram := UninterpretedBytes newInFixedSpace: nzoneHighPC - nzoneLowPC].	self buildSortedEngineSymbols.	self stopProfiling</body><body package="OEProfiler">initializeNZoneSymbols: anArray 	"Remember the array iof nzone symbols; intern any 	string labels so they look like nzone symbols (which 	ar e methods or Symbols)"	| i label labels |	nzoneSymbols := anArray.	labels := SortedCollection new.	i := 2.	[(anArray at: i) class == String primitiveArgumentClass] whileTrue: 		[label := anArray at: i put: ((anArray at: i) asStringEncoding: #default) asSymbol.		labels add: (anArray at: i - 1) -&gt; label.		 i := i + 2].	i := anArray size.	[(anArray at: i) class == String primitiveArgumentClass] whileTrue: 		[label := anArray at: i put: ((anArray at: i) asStringEncoding: #default) asSymbol.		 label first ~= $N ifTrue:			[labels add: (anArray at: i - 1) -&gt; label].		 i := i - 2].	nzoneSymbolTable := nil.	1 to: labels size - 1 do:		[:li|		(#(#'.NMethodEnd') includes: (label := (labels at: li) value)) ifFalse:			[fileTable				at: label				put: (SlidingInterval from: (labels at: li) key to: (labels at: li + 1) key)]].	self computeSortedFiles</body><body package="OEProfiler">returnFromSnapshot	| vector |	nzoneSymbolTable := nzoneSymbols := nil.	self getProfileRanges ~= (Array with: engineLowPC with: engineHighPC with: nzoneLowPC with: nzoneHighPC) ifTrue:		[engineHistogram := nzoneHistogram := nil.		 nzoneLowPC := nzoneHighPC := engineLowPC := engineHighPC := nil.		 engineSymbolTable := inverseEngineSymbolTable := sortedEngineSymbols := fileTable := sortedFiles := nil.		 vector := self getProfileRanges.		 engineLowPC := vector at: 1.		 engineHighPC := vector at: 2.		 nzoneLowPC := vector at: 3.		 nzoneHighPC := vector at: 4.]</body><body package="OEProfiler">startProfiling	"Enable ObjectEngine profiling."	self enableProfiling: true withEngineData: engineHistogram nzoneData: nzoneHistogram</body><body package="OEProfiler">stopProfiling	"Stop ObjectEngine profiling.  Compute the number of hits in each segment."	| otherCodeIndex |	self initializeNZoneSymbols: (self enableProfiling: false withEngineData: engineHistogram nzoneData: nzoneHistogram).	totalTextHits := totalNZoneHits := totalOtherHits := 0.	1 to: engineHistogram basicSize - 3 by: 4 do:		[:i| totalTextHits := totalTextHits + (engineHistogram unsignedLongAt: i)].	otherCodeIndex := (nzoneSymbols at: nzoneSymbols size - 1) - nzoneLowPC + 1.	1 to: otherCodeIndex - 3 by: 4 do:		[:i| totalNZoneHits := totalNZoneHits + (nzoneHistogram unsignedLongAt: i)].	otherCodeIndex to: nzoneHistogram basicSize - 3 by: 4 do:		[:i| totalOtherHits := totalOtherHits + (nzoneHistogram unsignedLongAt: i)].	totalHits := totalTextHits + totalNZoneHits + totalOtherHits</body></methods><methods><class-id>Tools.OEProfileInterface class</class-id> <category>instance creation</category><body package="OEProfiler">new	"Return an initialized instance"	^super new initialize</body></methods><methods><class-id>Tools.OEProfileInterface class</class-id> <category>primitives</category><body package="OEProfiler">printPICStats	&lt;primitive: 1008 errorCode: _ec&gt;	^self primitiveFailed	"self printPICStats"</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>graphing</category><body package="OEProfiler">annotateGraphIn: aRectangle	| delta |	plotter selectSmallestFont.	"plotter drawRectangle: aRectangle.	plotter label: 'topLeft' at: aRectangle topLeft.	plotter label: 'topRight' at: aRectangle topRight.	plotter label: 'bottomLeft' at: aRectangle bottomLeft.	plotter label: 'bottomRight' at: aRectangle bottomRight."	delta := aRectangle height / 12.	plotter		label: 'Integral:',				'  total ', profile totalHits printString,				'  [other ', profile totalOtherHits printString,				'] [oe ', profile totalOEHits printString,				'  (code ', profile totalOETextHits printString,				'  nzone ', profile totalOENZoneHits printString,				')]'		at: aRectangle origin.	plotter		label: (self asPercentage: [total / profile totalHits]), '% of total'		at: aRectangle left@(delta + aRectangle top).	plotter		label: (self asPercentage: [total / profile totalOEHits]), '% of all oe'		at: aRectangle left@(delta * 2 + aRectangle top).	plotter		label: (self asPercentage: [total / profile totalOETextHits]), '% of oe code'		at: aRectangle left@(delta * 3 + aRectangle top).	plotter		label: (self asPercentage: [total / profile totalOENZoneHits]), '% of nzone'		at: aRectangle left@(delta * 4 + aRectangle top).	plotter		label: (self asPercentage: [total / profile totalOtherHits]), '% of other'		at: aRectangle left@(delta * 5 + aRectangle top).	plotter		label: 'Peak (= ', peak printString, '):'		at: aRectangle left@(delta * 6 + aRectangle top).	plotter		label: (self asPercentage: [peak / total]), '% of range'		at: aRectangle left@(delta * 7 + aRectangle top).	plotter		label: (self asPercentage: [peak / profile totalHits]), '% of total'		at: aRectangle left@(delta * 8 + aRectangle top).	plotter		label: (self asPercentage: [peak / profile totalOEHits]), '% of all oe'		at: aRectangle left@(delta * 9 + aRectangle top).	plotter		label: (self asPercentage: [peak / profile totalOETextHits]), '% of oe code'		at: aRectangle left@(delta * 10 + aRectangle top).	plotter		label: (self asPercentage: [peak / profile totalOENZoneHits]), '% of nzone'		at: aRectangle left@(delta * 11 + aRectangle top).	plotter		label: (self asPercentage: [peak / profile totalOtherHits]), '% of other'		at: aRectangle left@(delta * 12 + aRectangle top).</body><body package="OEProfiler">drawBins: bins in: aRectangle maxVal: maxVal	| scaleX scaleY lastBin lastX bin  |	"plotter drawRectangle: aRectangle."	bins size = 0 ifTrue: [^self].	scaleX := aRectangle width / bins size.	scaleY := maxVal &lt;= 0				ifTrue: [aRectangle height]				ifFalse: [(aRectangle height / maxVal) asDouble].	lastBin := bins at: 1.	lastX := 0.	plotter goTo: aRectangle origin.	0 to: (bins size - 1) do: [:x|		bin := bins at: x + 1.		bin ~= lastBin			ifTrue:				[plotter					lineTo: scaleX * lastX @ (scaleY * lastBin) + aRectangle origin;					lineTo: scaleX * x @ (scaleY * lastBin) + aRectangle origin.				lastBin := bin.				lastX := x]].	plotter		lineTo: scaleX * lastX @ (scaleY * lastBin) + aRectangle origin;		lineTo: scaleX * bins size @ (scaleY * lastBin) + aRectangle origin.</body><body package="OEProfiler">drawGraph	"Compute and draw the entire graph."	| midPoint |	gsa &gt;= gea ifTrue: [^graph flash].	self setMargins.	Cursor wait showWhile: [self computeGraphDataIn: 1 - (2 * margin)].	plotter isNil ifTrue: [		plotter := SimplePlotter graphicsContext: graph graphicsContext].	plotter bounds: (graph bounds insetBy: 1).	midPoint := 1 - labelBase - (2 * margin) / 2 + labelBase + margin.	plotter clearWith: graph lookPreferences backgroundColor.	showIntegral value		ifTrue:			[self drawHistogramIn: (0@labelBase + margin corner: (1@midPoint - margin)).			self drawIntegralIn:  (0@midPoint + margin corner: (1@1 - margin))]		ifFalse:			[self drawHistogramIn: (0@labelBase + margin corner: (1@1 - margin))].		self labelGraphIn: (1@0.5 * margin corner: (1 - margin)@(labelBase + (margin / 2))).	self annotateGraphIn: (margin/2@(1-(margin*3/4)) corner: midPoint@(midPoint*7/5)).	self enableCrossHairs: true.	self setHistoryButtons</body><body package="OEProfiler">drawHistogramIn: aRectangle	self drawBins: histogram in: aRectangle maxVal: peak</body><body package="OEProfiler">drawIntegralIn: aRectangle	self drawBins: integral in: aRectangle maxVal: total</body><body package="OEProfiler">labelGraphIn: aRectangle	| scaleX y initialY delta label |	"plotter drawRectangle: aRectangle."	plotter selectSmallestFont.	delta := (aRectangle height / 5) negated.	y := initialY := aRectangle corner y - (margin / 2) + (delta / 1.2).	scaleX := aRectangle width / labels size.	0 to: labels size - 1 do: [:x| | scaledX |		(label := labels at: x + 1) notNil ifTrue: [			scaledX := scaleX * x.			plotter label: (label copyWithout: Character space) at: scaledX @ y + aRectangle origin.			plotter lineFrom: scaledX @ delta negated + aRectangle bottomLeft to: scaledX @ (delta / 2) negated + aRectangle bottomLeft.			"Transcript cr; print: y; endEntry."			(y := y + delta) &lt; 0 ifTrue: [y := initialY]]]</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>private</category><body package="OEProfiler">asPercentage: aFractionBlock	"Return aFraction formatted as a percentage"	| aFraction percentage |	aFraction := Number divisionByZeroSignal						handle: [:ex| ^'  ??.? ']						do: aFractionBlock.	percentage := (aFraction * 10000) rounded / 100.0.	^(percentage &gt;= 10 ifTrue: [percentage &gt;= 100 ifTrue: [' '] ifFalse: ['  ']] ifFalse: ['   ']),	percentage printString,	((percentage * 10) fractionPart = 0		ifTrue: [' ']		ifFalse: [''])</body><body package="OEProfiler">computeGraphDataIn: unitWidth	"Build arrays for the histogram and integral views.	 To make drawing more efficient compute how many profile bins should	 fit in each histogram bin if the profiled range is very large."	| width si ei i limit samples selections fileSelections |	width := unitWidth * graph bounds width.	si := gsa.	ei := gea - 1.	samples := profile samplesForRange: (si to: ei).	samples &gt;= (2 * width)		ifTrue: [samplesPerBin := (samples / width) ceiling asInteger]		ifFalse: [samplesPerBin := 1].	histogram := Array new: (samples / samplesPerBin) ceiling.	integral := histogram shallowCopy.	labels := histogram shallowCopy.	total := peak := 0.	profile buildHistogramFor: (si to: ei) into: histogram samplesPerBin: samplesPerBin.	((selections := symbolList selections) size &gt; 50	and: [(fileSelections := selections select: [:s| profile isFileSymbol: s]) size &gt; 2])		ifTrue: [selections := fileSelections].	selections do: [:aSymbol| | index name dotIndex |		index := (profile addressOf: aSymbol) - si // (profile pcsPerBin * samplesPerBin) + 1.		name := aSymbol oeProfilerDisplayString.		(dotIndex := name indexOf: $.) &gt; 1 ifTrue:			[name := name copyFrom: 1 to: dotIndex -1].		index &lt;= 0			ifTrue: [labels at: 1 put: '...', name]			ifFalse:				[index &lt; labels size ifTrue: [labels at: index put: name]]].	i := 1.	limit := histogram size.	[i &lt;= limit]		whileTrue:			[| v |			integral at: i put: (total := total + (v := histogram at: i)).			v &gt; peak ifTrue: [peak := v].			i := i + 1]</body><body package="OEProfiler">enableCrossHairs: aBoolean	"Enable or disable the crossHairs."	(builder componentAt: #setLowPCFromGraph) isEnabled: aBoolean.	(builder componentAt: #setHighPCFromGraph) isEnabled: aBoolean</body><body package="OEProfiler">interfaceWindow	builder == nil ifTrue: [^nil].	^builder window</body><body package="OEProfiler">postBuildWith: aBuilder	"Remember the graph."	graph := aBuilder componentAt: #graph.	(self widgetAt: #symbolList) displayStringSelector: #oeProfilerDisplayString</body><body package="OEProfiler">preBuildWith: aBuilder	"Set up some visuals"	aBuilder		visualAt: #crossHair		put: Cursor crossHair asOpaqueImage</body><body package="OEProfiler">pushHistory	"Push the current selectedSymbols onto the history list at the current index.	 If the current index is at the end extend the history if the current symbols are new.	 If the current index is not at the end and the new element differs then clear the following history."	| newHistory |	newHistory := Array with: gsa with: gea.	historyIndex &lt; history size		ifTrue:			[historyIndex := historyIndex + 1.			(((history at: historyIndex) ~= newHistory)			and: [history size &gt; historyIndex])				ifTrue:					[history at: historyIndex put: newHistory.					history removeLast: history size - historyIndex]]		ifFalse:			[(history size &gt; 0			and: [history last = newHistory])				ifFalse:					[history addLast: newHistory.					historyIndex := history size]]</body><body package="OEProfiler">selectSymbols	"Respond to a change of selection  in the symbol list."	selectedSymbols := symbolList selections.	self setRangeFromSelectedSymbols</body><body package="OEProfiler">setHistoryButtons	"Set the buttons to an appropriate state."	(builder componentAt: #drawPreviousGraph) isEnabled: historyIndex &gt; 1.	(builder componentAt: #drawNextGraph)  isEnabled: historyIndex &lt; history size.</body><body package="OEProfiler">setMargins	"Set up the margin around the graph and the label area."	margin := 0.025.	labelBase := 0.075</body><body package="OEProfiler">setPCDisplayFromPCRange	lowPC		value: '' asText;	"****ing text emphasis change bug!!"		value: (tempGsa notNil					ifTrue: [(tempGsa printStringRadix: 16) asText emphasizeAllWith: #italic]					ifFalse: [(gsa printStringRadix: 16) asText allBold]).	highPC		value: '' asText;	"****ing text emphasis change bug!!"		value: (tempGea notNil					ifTrue: [(tempGea printStringRadix: 16) asText emphasizeAllWith: #italic]					ifFalse: [(gea printStringRadix: 16) asText allBold])</body><body package="OEProfiler">setPCRange	"Set up the pc range addresses from the lowPC/highPC values."	gsa := tempGsa notNil				ifTrue: [tempGsa]				ifFalse: [Integer readFrom: lowPC value readStream radix: 16].	gea := tempGea notNil				ifTrue: [tempGea]				ifFalse: [Integer readFrom: highPC value readStream radix: 16].	gsa &lt; profile startPC ifTrue: [gsa := profile startPC].	gea &gt; profile endPC ifTrue: [gea := profile endPC].	"Update displays if any changes have occured."	self setPCDisplayFromPCRange.	(tempGsa notNil or: [tempGea notNil])		ifTrue: [self setSymbolsForPCRange].	tempGsa := tempGea := nil.</body><body package="OEProfiler">setRangeFromSelectedSymbols	"Compute the current PC-range from the selected symbols and update the PC range."	| nextSymbol |	self enableCrossHairs: false.	selectedSymbols size &gt; 0		ifTrue:			[gsa := profile addressOf: selectedSymbols first.			nextSymbol := profile nextSymbolTo: selectedSymbols last.			gea := selectedSymbols first = nextSymbol					ifTrue: [(profile addressRangeOf: nextSymbol) last]					ifFalse: [(profile addressRangeOf: nextSymbol) first].			lowSymbol value: selectedSymbols first oeProfilerDisplayString.			highSymbol value: nextSymbol oeProfilerDisplayString.			self setPCDisplayFromPCRange]</body><body package="OEProfiler">setSymbolsForPCRange	"The PC-range has changed.  Update the selected symbols list and symbol lo/symbol hi displays to reflect the new range."	| start end startSymbol endSymbol symbols |	tempGsa := tempGea := nil.	self setPCRange.	self enableCrossHairs: false.	listType == #cost ifTrue: [^self].	symbols := symbolList list.	"Search for symbols that bound the range"	start := (1 to: symbols size)					detect: [:i| (profile addressOf: (symbols at: i)) &gt;= gsa]					ifNone: [symbols size].	end := (symbols size to: 1 by: -1)				detect: [:i| (profile addressOf: (symbols at: i)) &lt;= gea]				ifNone: [1].	"Set lowSymbol to reflect symbol nearest below value"	lowSymbol value: ((profile addressOf: (startSymbol := symbols at: start)) &gt; gsa							ifTrue:								[start &gt; 1 ifTrue: [startSymbol := symbols at: (start := start - 1)].								((profile addressOf: startSymbol) &gt; gsa									ifTrue: ['&lt; ']									ifFalse: ['&gt; ']), startSymbol oeProfilerDisplayString]							ifFalse: [startSymbol oeProfilerDisplayString]).	"Set highSymbol to reflect symbol nearest above value"	highSymbol value: ((profile addressOf: (endSymbol := symbols at: end)) &lt; gea							ifTrue:								[end &lt; symbols size ifTrue: [endSymbol := symbols at: (end := end + 1)].								((profile addressOf: endSymbol) &lt; gea									ifTrue: ['&gt; ']									ifFalse: ['&lt; ']), endSymbol oeProfilerDisplayString]							ifFalse: [endSymbol oeProfilerDisplayString]).	"select symbols from symbols"	symbolList selectionIndexes: (start to: end) asSet.	(builder componentAt: #symbolList) widget makeVisible: start.</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>actions</category><body package="OEProfiler">browseSelection	symbolList selections anElement oeProfilerBrowse</body><body package="OEProfiler">chooseSymbol: symbolName	| list matches pat |	list := symbolList list.	matches := SortedCollection sortBlock: 					[:a :b | 					(list at: a) oeProfilerDisplayString 						&lt; (list at: b) oeProfilerDisplayString].	pat := '*' , symbolName , '*'.	1 to: list size do: 		[:index |  | ds |		ds := (list at: index) oeProfilerDisplayString.		symbolName = ds ifTrue: [^index].		(pat match: ds ignoreCase: true) ifTrue: [matches add: index]].	matches size &lt;= 1 ifTrue: 		[matches isEmpty  ifTrue: 			[Screen default ringBell.			 ^nil].			^matches first].	^Dialog 		choose: 'Which Symbol?'		fromList: (matches collect: [:i | (list at: i) oeProfilerDisplayString])		values: matches		lines: 10		cancel: 			[^nil]		for: self interfaceWindow</body><body package="OEProfiler">clearProfile	"Clear the profiler's profiling histogram."	profile clearProfile.	(builder componentAt: #startProfiling) isEnabled: true.	(builder componentAt: #stopProfiling)  isEnabled: false</body><body package="OEProfiler">disassemble	SimpleWorkspace new		 setWorkspace: (profile disassembleFrom: gsa to: gea) asString asText asValue;		open</body><body package="OEProfiler">drawCurrentGraph	"Go draw the graph."	self setPCRange.	self setSymbolsForPCRange.	self pushHistory.	self drawGraph</body><body package="OEProfiler">drawNextGraph	"Draw the next graph in the history."	| range |	range := (history at: (historyIndex := historyIndex + 1)).	tempGsa := range first.	tempGea := range last.	self setPCRange.	self drawGraph</body><body package="OEProfiler">drawPreviousGraph	"Draw the previous graph in the history."	| range |	range := (history at: (historyIndex := historyIndex - 1)).	tempGsa := range first.	tempGea := range last.	self setPCRange.	self drawGraph</body><body package="OEProfiler">extendToSymbol	"Extend the selected symbols to include a new symbol."	| symbolName index selections max min |	selections := symbolList selectionIndexes.	(selections size = 0	or: [symbolName := Dialog request: 'Which Symbol?' for: self interfaceWindow.		(index := symbolList list indexOf: symbolName ifAbsent: []) isNil])		ifTrue: [^Screen default ringBell].	min := max := (selections includes: index)					ifTrue: [selections detect: [:i| true]]					ifFalse: [index].	selections do: [:i|		i &gt; max ifTrue: [max := i].		i &lt; min ifTrue: [min := i]].	(selections includes: index)		ifTrue:			[index - min &gt; (max - index)				ifTrue: [max := index]				ifFalse: [min := index]].	symbolList selectionIndexes: (min to: max) asSet.	(builder componentAt: #symbolList) widget makeVisible: index.	self selectSymbols</body><body package="OEProfiler">findSymbol	"Go select a given symbol."	| symbolName selectionIndex |	symbolName := Dialog request: 'Which Symbol?' for: self interfaceWindow.	(selectionIndex := self chooseSymbol: symbolName) notNil ifTrue:		[symbolList selectionIndexes: (Set with: selectionIndex).		 (builder componentAt: #symbolList) widget makeVisible: selectionIndex.		 self selectSymbols]</body><body package="OEProfiler">oeReport	| stream costs totalCost |	costs := profile oeCostsBySymbol.	totalCost := (costs at: 1) asFloat.	stream := (String new: 1024) writeStream.	stream nextPutAll: 'total cost '; print: totalCost asInteger; cr; cr.	(costs at: 2) do:		[:assoc| | cost percentage |		(cost := assoc key) = 0 ifTrue: [^stream contents].		percentage := (cost * 10000.0 / totalCost) rounded / 100.0.		stream			nextPutAll: assoc value oeProfilerDisplayString;			tab;			print: percentage;			nextPut: $%;			space; tab; "space because tabs have no minimum width"			print: cost;			cr].	^stream contents</body><body package="OEProfiler">openOEReport	ComposedTextView		open: (ValueHolder with: (Cursor write showWhile: [self oeReport asText]))		label: 'OE Symbols By Cost'</body><body package="OEProfiler">openReport	ComposedTextView		open: (ValueHolder with: (Cursor write showWhile: [self report asText]))		label: 'Symbols By Cost'</body><body package="OEProfiler">openStReport	ComposedTextView		open: (ValueHolder with: (Cursor write showWhile: [self stReport asText]))		label: 'Smalltalk Code Symbols By Cost'</body><body package="OEProfiler">refreshList	self symbolList list: (listType == #address								ifTrue: [profile sortedSymbols]								ifFalse: [profile symbolsSortedByCost])</body><body package="OEProfiler">report	| stream costs totalCost |	costs := profile costsBySymbol.	totalCost := (costs at: 1) asFloat.	stream := (String new: 1024) writeStream.	stream nextPutAll: 'total cost '; print: totalCost asInteger; cr; cr.	(costs at: 2) do:		[:assoc| | cost percentage |		(cost := assoc key) = 0 ifTrue: [^stream contents].		percentage := (cost * 10000.0 / totalCost) rounded / 100.0.		stream			nextPutAll: assoc value oeProfilerDisplayString;			tab;			print: percentage;			nextPut: $%;			space; tab; "space because tabs have no minimum width"			print: cost;			cr].	^stream contents</body><body package="OEProfiler">selectAll	"Select the entire profile."	symbolList selectionIndexes: (1 to: symbolList list size - 1) asSet.	(builder componentAt: #symbolList) widget makeVisible: 1.	self selectSymbols</body><body package="OEProfiler">selectNZone	"Select the OE's nzone."	| startIndex stopIndex |	startIndex := symbolList list indexOf: profile firstNZoneSymbol.	stopIndex := symbolList list indexOf: profile lastNZoneSymbol.	symbolList selectionIndexes: (startIndex to: stopIndex - 1) asSet.	(builder componentAt: #symbolList) widget makeVisible: startIndex.	self selectSymbols</body><body package="OEProfiler">selectOEText	"Select the OE's text."	| startIndex stopIndex |	startIndex := (symbolList list indexOf: profile firstEngineSymbol).	stopIndex := (symbolList list indexOf: profile lastEngineSymbol).	symbolList selectionIndexes: (startIndex to: stopIndex) asSet.	(builder componentAt: #symbolList) widget makeVisible: startIndex.	self selectSymbols</body><body package="OEProfiler">selectSymbols: sequenceController	"Compute the current PC-range from the selected symbols and update the PC range."	self selectSymbols.	^true	"self open"</body><body package="OEProfiler">setHighPC: aController	self setSymbolsForPCRange</body><body package="OEProfiler">setHighPCFromGraph	"Set the temporary highPC from a click in the graph"	| point x bounds |	Cursor crossHair showWhile: [point := self interfaceWindow sensor waitClickButton].	((bounds := graph bounds) containsPoint: point) ifFalse: [^self].	bounds := bounds insetBy: bounds extent * margin.	x := point x - bounds left - 1 "graph border; ho hum".	tempGea := (gea - gsa * (x / bounds width) + gsa) rounded.	tempGea &gt; gea ifTrue: [tempGea := nil].	self setPCDisplayFromPCRange</body><body package="OEProfiler">setLowPC: aController	self setSymbolsForPCRange</body><body package="OEProfiler">setLowPCFromGraph	"Set the temporary lowPC from a click in the graph"	| bounds point x |	Cursor crossHair showWhile: [point := self interfaceWindow sensor waitClickButton].	((bounds := graph bounds) containsPoint: point) ifFalse: [^self].	bounds := bounds insetBy: bounds extent * margin.	x := point x - bounds left - 1 "graph border; ho hum".	tempGsa := (gea - gsa * (x / bounds width) + gsa) rounded.	tempGsa &lt; gsa ifTrue: [tempGsa := nil].	self setPCDisplayFromPCRange</body><body package="OEProfiler">sortByAddress	listType := #address.	self refreshList</body><body package="OEProfiler">sortByCost	listType := #cost.	self refreshList</body><body package="OEProfiler">stReport	| stream costs totalCost |	costs := profile stCostsBySymbol.	totalCost := (costs at: 1) asFloat.	stream := (String new: 1024) writeStream.	stream nextPutAll: 'total cost '; print: totalCost asInteger; cr; cr.	(costs at: 2) do:		[:assoc| | cost percentage |		(cost := assoc key) = 0 ifTrue: [^stream contents].		percentage := (cost * 10000.0 / totalCost) rounded / 100.0.		stream			nextPutAll: assoc value oeProfilerDisplayString;			tab;			print: percentage;			nextPut: $%;			space; tab; "space because tabs have no minimum width"			print: cost;			cr].	^stream contents</body><body package="OEProfiler">startProfiling	"Start the profiler profiling."	(builder componentAt: #startProfiling) isEnabled: false.	(builder componentAt: #stopProfiling)  isEnabled: true.	profile startProfiling</body><body package="OEProfiler">stopProfiling	"Ask the profiler to stop profiling."	Cursor wait showWhile: [profile stopProfiling].	(builder componentAt: #startProfiling) isEnabled: true.	(builder componentAt: #stopProfiling)  isEnabled: false.	self refreshList</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>aspects</category><body package="OEProfiler">highPC	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^highPC isNil		ifTrue:			[highPC := Text new asValue]		ifFalse:			[highPC]</body><body package="OEProfiler">highSymbol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^highSymbol isNil		ifTrue:			[highSymbol := String new asValue]		ifFalse:			[highSymbol]</body><body package="OEProfiler">lowPC	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lowPC isNil		ifTrue:			[lowPC := Text new asValue]		ifFalse:			[lowPC]</body><body package="OEProfiler">lowSymbol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lowSymbol isNil		ifTrue:			[lowSymbol := String new asValue]		ifFalse:			[lowSymbol]</body><body package="OEProfiler">showIntegral	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showIntegral isNil		ifTrue:			[showIntegral := false asValue]		ifFalse:			[showIntegral]</body><body package="OEProfiler">symbolList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^symbolList isNil		ifTrue:			[symbolList := MultiSelectionInList new]		ifFalse:			[symbolList]</body><body package="OEProfiler">symbolListMenuHolder	^[symbolListMenu isNil ifTrue:		[symbolListMenu := self class symbolListMenu].	  (symbolListMenu atNameKey: #browse)		enabled: (symbolList selections size = 1					and: [symbolList selections anElement								respondsTo: #oeProfilerBrowse]).	  symbolListMenu]</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>interface opening</category><body package="OEProfiler">postOpenWith: aBuilder 	"Ensure we get window events so we can handle our dependency on ObjectMemory."	aBuilder window		application: self;		sendWindowEvents: #(enter exit close)</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>events</category><body package="OEProfiler">windowEvent: anAssociation from: anApplicationWindow	"Handle window events to remove our dependency on closing, and to reinitialize the profile on reopening.."	| type |	type := anAssociation key.	#close == type ifTrue: [ObjectMemory removeDependent: self].	#reopen == type ifTrue: [profile == nil ifTrue: [profile := self class profileInterface]].	^super windowEvent: anAssociation from: anApplicationWindow</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>initialize-release</category><body package="OEProfiler">initialize	"Initialize the receiver's OEProfileInterface"	super initialize.	(ObjectMemory dependents includes: self) ifFalse: [ObjectMemory addDependent: self].	profile := self class profileInterface.	history := OrderedCollection new.	historyIndex := 0.	self sortByAddress.	self setMargins	"OEProfiler open"</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>updating</category><body package="OEProfiler">update: aSymbol	"Handle updates to clear the profile interface on snapshot."	aSymbol == #aboutToSnapshot ifTrue:		[^profile := nil].	aSymbol == #returnFromSnapshot ifTrue:		[^profile ~~ nil ifTrue: [profile returnFromSnapshot]].	^super update: aSymbol</body></methods><methods><class-id>Tools.OEProfiler</class-id> <category>profiling access</category><body package="OEProfiler">profile: aBlock	"Start profiling whilst doing aBlock"	self clearProfile.	self startProfiling.	aBlock ensure: [self stopProfiling]</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>class initialization</category><body package="OEProfiler">initialize	"Initialize the receiver.  This involves ensuring we clear the OEProfileInterface on start-up."	(ObjectMemory dependents includes: self) ifFalse: [ObjectMemory addDependent: self].	CurrentProfileInterface := nil	"OEProfiler initialize"</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>private</category><body package="OEProfiler">obsolete	ObjectMemory removeDependent: self.	super obsolete</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>public access</category><body package="OEProfiler">profile: aBlock	"Profile aBlock.  If an existing open OEProfiler is available	 use it to display data otheriwse open a new one."	| insts p |	insts := self allInstances.	insts size &gt; 1 ifTrue: [		ObjectMemory compactingGC.		(insts := self allInstances) size &gt; 1			ifTrue: [^self error: 'too many profilers']].	(insts size = 1	and: [insts first dependents contains:				[:dep| (dep isKindOf: ApplicationWindow) and: [dep isOpen]]])		ifTrue: [p := insts first]		ifFalse: [p := self open window model].	Cursor execute showWhile: [p profile: aBlock]</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>updating</category><body package="OEProfiler">update: aSymbol	"Ensure we clear the profile interface when starting the image."	aSymbol == #returnFromSnapshot ifTrue: [^CurrentProfileInterface := nil].	^super update: aSymbol</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>interface specs</category><body package="OEProfiler">windowSpec	"Return a suitably-sized windowSpec for the current display."	| extent |	extent := Screen default bounds extent.	extent &gt; (1024@768) ifTrue: [^self windowSpecLarge].	^self windowSpecMedium</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>accessing</category><body package="OEProfiler">profileInterface	"Return the current OEProfileInterface instance, shared by all 	 viewers, and accessible to others for specific profiling functions.	 If one is not already existant, then create one."	CurrentProfileInterface isNil ifTrue:		[Cursor wait showWhile: [CurrentProfileInterface := OEProfileInterface new]].	^CurrentProfileInterface</body></methods><methods><class-id>Tools.PICProxy</class-id> <category>oe profiler</category><body package="OEProfiler">oeProfilerBrowse	MethodCollector new browseAllImplementorsOf: selector</body><body package="OEProfiler">oeProfilerDisplayString	| ws |	ws := (String new: 32) writeStream.	ws nextPutAll: 'PIC'.	tag notNil ifTrue: [ws print: tag].	ws space.	selector storeOn: ws.	^ws contents</body></methods><methods><class-id>Tools.PICProxy</class-id> <category>instance initialization</category><body package="OEProfiler">selector: aSelector tag: aTag	selector := aSelector.	tag := aTag</body></methods><methods><class-id>Tools.PICProxy class</class-id> <category>instance creation</category><body package="OEProfiler">selector: aSelector tag: aTag	^self new selector: aSelector tag: aTag</body></methods><methods><class-id>Kernel.CompiledCode class</class-id> <category>primitives</category><body package="OEProfiler">nativeCodeOffsets	"Answer an Array of pair-wise offset-name, offset for ``interesting'' native code offsets."	^self primNativeCodeOffsets collect:		[:ea|		ea isInteger			ifTrue: [ea]			ifFalse: [ea asStringEncoding: #default]]	"self nativeCodeOffsets"</body><body package="OEProfiler">primNativeCodeOffsets	"Answer an Array of pair-wise offset-name, offset for ``interesting'' native code offsets."	&lt;primitive: 1003&gt;	^self primitiveFailed</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>oe profiler</category><body package="OEProfiler">oeProfilerBrowse	| def |	def := self homeMethod definition.	MethodCollector new		openListBrowserOn: (Array with: def)		label: def displayString</body><body package="OEProfiler">oeProfilerDisplayString	| ws |	ws := (String new: 32) writeStream.	self printNameOn: ws inClass: self mclass.	^ws contents</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="OEProfiler">anElement	self do: [:anElement| ^anElement].	^self emptyCollectionError</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>oe profiler</category><body package="OEProfiler">oeProfilerDisplayString	^self</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>resources</category><body package="OEProfiler">patternListMenu	"MenuEditor new openOnClass: self andSelector: #patternListMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 'add..' 				#value: #addPattern ) 			#(#MenuItem 				#rawLabel: 'remove' 				#value: #removePattern ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="OEProfiler">symbolListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #symbolListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'find...' 				#value: #findSymbol ) 			#(#{UI.MenuItem} 				#rawLabel: 'extend to...' 				#value: #extendToSymbol ) 			#(#{UI.MenuItem} 				#rawLabel: 'select all' 				#value: #selectAll ) 			#(#{UI.MenuItem} 				#rawLabel: 'select oe text' 				#value: #selectOEText ) 			#(#{UI.MenuItem} 				#rawLabel: 'select nzone' 				#value: #selectNZone ) 			#(#{UI.MenuItem} 				#rawLabel: 'sort by address' 				#value: #sortByAddress ) 			#(#{UI.MenuItem} 				#rawLabel: 'sort by cost' 				#value: #sortByCost ) 			#(#{UI.MenuItem} 				#rawLabel: 'display costs' 				#value: #openReport ) 			#(#{UI.MenuItem} 				#rawLabel: 'display oe costs' 				#value: #openOEReport ) 			#(#{UI.MenuItem} 				#rawLabel: 'display Smalltalk code costs' 				#value: #openStReport ) 			#(#{UI.MenuItem} 				#rawLabel: 'browse' 				#enabled: false 				#nameKey: #browse 				#value: #browseSelection ) ) #(2 3 2 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.OEProfiler class</class-id> <category>interface specs</category><body package="OEProfiler">windowSpecLarge	"UIPainter new openOnClass: self andSelector: #windowSpecLarge"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'OE Profiler' 			#min: #(#{Core.Point} 800 800 ) 			#max: #(#{Core.Point} 800 800 ) 			#bounds: #(#{Graphics.Rectangle} 458 293 1258 1093 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.2 0 0 0 1 0 0.89 ) 					#name: #graph 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#lineWidth: 1 ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.2 0 0.89 ) 					#name: #symbolList 					#flags: 15 					#model: #symbolList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#selectSymbols: ) 					#menu: #symbolListMenuHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 716 67 746 ) 					#model: #drawCurrentGraph 					#label: 'View' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 742 ) 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) ) 					#model: #showIntegral 					#tabable: false 					#label: 'Show Integral' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 407 775 527 797 ) 					#model: #lowPC 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#setLowPC: ) 					#alignment: #right 					#type: #text ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 533 775 653 797 ) 					#model: #highPC 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#setHighPC: ) 					#alignment: #right 					#type: #text ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 406 750 ) 					#label: 'pc lo[' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 532 752 ) 					#label: 'hi)' 					#style: #systemDefault ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 134 716 253 746 ) 					#name: #startProfiling 					#model: #startProfiling 					#label: 'Start Profiling' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 134 743 253 773 ) 					#name: #stopProfiling 					#flags: 40 					#model: #stopProfiling 					#label: 'Stop Profiling' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 134 770 253 800 ) 					#model: #clearProfile 					#label: 'Clear Profile' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 252 716 373 746 ) 					#model: #disassemble 					#label: 'Disassemble' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 407 737 527 759 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #lowSymbol 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 533 737 653 759 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #highSymbol 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 406 712 ) 					#label: 'symbol lo[' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 532 712 ) 					#label: 'hi)' 					#style: #systemDefault ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 373 769 405 800 ) 					#name: #setLowPCFromGraph 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setLowPCFromGraph ) 					#label: #crossHair 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 655 771 687 801 ) 					#name: #setHighPCFromGraph 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setHighPCFromGraph ) 					#label: #crossHair 					#hasCharacterOrientedLabel: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 283 770 ) 					#label: 'select lo pc:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 689 770 ) 					#label: ':select hi pc' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 3 770 66 800 ) 					#name: #drawPreviousGraph 					#flags: 40 					#model: #drawPreviousGraph 					#label: 'Prev' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 67 770 130 800 ) 					#name: #drawNextGraph 					#flags: 40 					#model: #drawNextGraph 					#label: 'Next' 					#defaultable: true ) ) ) )</body><body package="OEProfiler">windowSpecMedium	"UIPainter new openOnClass: self andSelector: #windowSpecMedium"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'OE Profiler' 			#min: #(#{Core.Point} 800 700 ) 			#max: #(#{Core.Point} 800 700 ) 			#bounds: #(#{Graphics.Rectangle} 561 351 1361 1051 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.2 0 0 0 1 0 0.875 ) 					#name: #graph 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#lineWidth: 1 ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.2 0 0.875 ) 					#name: #symbolList 					#flags: 15 					#model: #symbolList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#selectSymbols: ) 					#menu: #symbolListMenuHolder					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 616 67 646 ) 					#model: #drawCurrentGraph 					#label: 'View' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 642 ) 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) ) 					#model: #showIntegral 					#tabable: false 					#label: 'Show Integral' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 407 675 527 697 ) 					#model: #lowPC 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#setLowPC: ) 					#alignment: #right 					#type: #text ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 533 675 653 697 ) 					#model: #highPC 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#setHighPC: ) 					#alignment: #right 					#type: #text ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 406 650 ) 					#label: 'pc lo[' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 532 652 ) 					#label: 'hi)' 					#style: #systemDefault ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 134 616 253 646 ) 					#name: #startProfiling 					#model: #startProfiling 					#label: 'Start Profiling' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 134 643 253 673 ) 					#name: #stopProfiling 					#flags: 40 					#model: #stopProfiling 					#label: 'Stop Profiling' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 134 670 253 700 ) 					#model: #clearProfile 					#label: 'Clear Profile' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 252 616 373 646 ) 					#model: #disassemble 					#label: 'Disassemble' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 407 637 527 659 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #lowSymbol 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 533 637 653 659 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #highSymbol 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 406 612 ) 					#label: 'symbol lo[' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 532 612 ) 					#label: 'hi)' 					#style: #systemDefault ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 374 669 406 700 ) 					#name: #setLowPCFromGraph 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setLowPCFromGraph ) 					#label: #crossHair 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 654 670 686 700 ) 					#name: #setHighPCFromGraph 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setHighPCFromGraph ) 					#label: #crossHair 					#hasCharacterOrientedLabel: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 286 670 ) 					#label: 'select lo pc:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 686 670 ) 					#label: ':select hi pc' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 3 670 66 700 ) 					#name: #drawPreviousGraph 					#flags: 40 					#model: #drawPreviousGraph 					#label: 'Prev' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 67 670 130 700 ) 					#name: #drawNextGraph 					#flags: 40 					#model: #drawNextGraph 					#label: 'Next' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="OEProfiler">openOEProfilerCommand	&lt;command: #openOEProfiler&gt;	^Command		label: #ATObjectEngine &lt;&lt; #menus &gt;&gt; 'Object engine'		group: #launcher		bindings: #()</body></methods><methods><class-id>Tools.BenchmarkRunner class</class-id> <category>resources</category><body package="OEProfiler">profilerMenu	"Tools.MenuEditor new openOnClass: self andSelector: #profilerMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #NoProfiler 					#defaultString: 'No Profiler' 					#catalogID: #advanced ) 				#nameKey: #noProfiler 				#value: #nil ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #TimeProfiler 					#defaultString: 'Time Profiler' 					#catalogID: #advanced ) 				#nameKey: #TimeProfiler 				#value: #TimeProfiler ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AllocationProfiler 					#defaultString: 'Allocation Profiler' 					#catalogID: #advanced ) 				#nameKey: #AllocationProfiler 				#value: #AllocationProfiler ) 			#(#{UI.MenuItem} 				#rawLabel: 'Object engine Profiler' 				#nameKey: #OEProfiler 				#value: #OEProfiler ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools - advanced</category><body package="OEProfiler">menuItemObjectEngineProfiler	&lt;menuItemForCommand: #openOEProfiler		nameKey: nil		menu: #(#menuBar #tools #atTools #atProfiles)		position: 10.5&gt;	self openApplicationForClassNamed: #{OEProfiler} withSelector: #open</body></methods><initialize><class-id>Tools.OEProfiler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>