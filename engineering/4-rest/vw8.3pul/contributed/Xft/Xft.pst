<?xml version="1.0"?><st-source><!-- Name: XftNotice: Licensed under the MIT licenseCopyright (c) 2012 Holger KleinsorgenPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: A binding for the X FreeType interface library for enumerating and rendering fonts.Also includes XftFont, a screen font implementation.Does not replace XFonts, this is done in another package, Xft-Integration.Loading new versions of this package can be difficult if Xft is active, especially if there have been substantial changes.Solution 1:     Load the new version on another platform (Windows, OS X)Solution 2:   - remove the method Screen>>preferredFontClass   - save, quit, open again. XFonts are now active   - load the new versions, including Xft-Integration, which contains Screen>>preferredFontClass   - save, quit, open again. Solution 3:   Perform the following script:	 ScheduledControllers scheduledControllers do: [ : controller | controller view collapse ].	Screen default installFontPolicy.	" fork -> no StoreProgressOverlay "	[			#('Xft' 'Xft-Integration' 'Xft-DesktopIntegration') do: [ : packageName |			(Store.Glorp.StorePackage newestVersionWithName: packageName) loadSource		].		ScheduledControllers scheduledControllers do: [ : controller | controller view expand ].	] fork.Contact: h . kleinsorgen - at - gmail . comLicensed under the MIT license (see Copyright)DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))PackageName: XftParcel: #('Xft')ParcelDirectory: XftPrerequisiteDescriptions: #(#(#name 'DLLCC' #componentType #package))PrerequisiteParcels: #(#('DLLCC' ''))Version: (7.7).74Date: 1:23:40 PM July 26, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jul14.3) of 25. Juli 2014 on 26. Juli 2014 at 13:23:40</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Xft</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Xft</package></attributes></name-space><class><name>LibXft</name><environment>Xft</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports>			private Xft.LibXftDictionary.*			</imports><category>ExternalInterface-New</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libXft.so.2</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Xft</package></attributes></class><comment><class-id>Xft.LibXft</class-id><body>Interface for LibXft and fontconfig</body></comment><class><name>FontPattern</name><environment>Xft</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars>propertyReadConverters propertyPrintConverters ignoredValues </class-inst-vars><imports></imports><category></category><attributes><package>Xft</package></attributes></class><comment><class-id>Xft.FontPattern</class-id><body>Represents a fontconfig font pattern. These are used to match fonts.</body></comment><class><name>XftError</name><environment>Xft</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xft</package></attributes></class><comment><class-id>Xft.XftError</class-id><body>Raised by Xft-related classes</body></comment><class><name>UnicodeCompositeFont</name><environment>Xft</environment><super>Graphics.CompositeFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastPriorityTableFontIndex requestedFontDescription device availableFonts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xft</package></attributes></class><comment><class-id>Xft.UnicodeCompositeFont</class-id><body>The font selection for a character is based on the glyphs supported by the fonts, not by the encodings.</body></comment><class><name>XftFont</name><environment>Xft</environment><super>Graphics.ScreenFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xftFont screen colors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xft</package></attributes></class><comment><class-id>Xft.XftFont</class-id><body>XftFont uses Xft, the X FreeType interface library</body></comment><class><name>XftSystem</name><environment>Xft</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xft</package></attributes></class><comment><class-id>Xft.XftSystem</class-id><body>Initializes Xft</body></comment><class><name>XftSettings</name><environment>Xft</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preferredFontDescription preferredFontPointSize antialias hintStyle lcdFilter dpi subPixelRendering </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category></category><attributes><package>Xft</package></attributes></class><comment><class-id>Xft.XftSettings</class-id><body>Various Xft-related settings</body></comment><class><name>FontPatternDescription</name><environment>Xft</environment><super>Graphics.FontDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fontPattern pointSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xft</package></attributes></class><comment><class-id>Xft.FontPatternDescription</class-id><body>A font description based on a fontconfig font pattern</body></comment><shared-variable><name>ExtendedFontPatternDescriptionClass</name><environment>Xft.FontPatternDescription</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>Xft</package></attributes></shared-variable><shared-variable><name>GlyphTables</name><environment>Xft.XftFont</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>Xft</package></attributes></shared-variable><shared-variable><name>GlyphRanges</name><environment>Xft.XftFont</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>Xft</package></attributes></shared-variable><shared-variable><name>LibXftDictionary</name><environment>Xft</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Xft</package></attributes></shared-variable><methods><class-id>Xft.LibXft</class-id> <category>procedures - fontconfig</category><body package="Xft">FcCharSetFirstPage: a with: map with: next	&lt;C: FcChar32 FcCharSetFirstPage(FcCharSet const * a, FcChar32 map[8], FcChar32 * next)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcCharSetNextPage: a with: map with: next	&lt;C: FcChar32 FcCharSetNextPage(FcCharSet const * a, FcChar32 map[8], FcChar32 * next)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontList: config with: p with: os	&lt;C: FcFontSet *  FcFontList(FcConfig * config, FcPattern * p, FcObjectSet * os)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontMatch: config with: p with: result	&lt;C: FcPattern *  FcFontMatch(FcConfig * config, FcPattern * p, FcResult * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontRenderPrepare: config with: pat with: font	&lt;C: FcPattern *  FcFontRenderPrepare(FcConfig * config, FcPattern * pat, FcPattern * font)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontSetCreate	&lt;C: FcFontSet *  FcFontSetCreate(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontSetDestroy: s	&lt;C: void FcFontSetDestroy(FcFontSet * s)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontSetList: config with: sets with: nsets with: p with: os	&lt;C: FcFontSet *  FcFontSetList(FcConfig * config, FcFontSet * * sets, int nsets, FcPattern * p, FcObjectSet * os)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontSetMatch: config with: sets with: nsets with: p with: result	&lt;C: FcPattern *  FcFontSetMatch(FcConfig * config, FcFontSet * * sets, int nsets, FcPattern * p, FcResult * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontSetSort: config with: sets with: nsets with: p with: trim with: csp with: result	&lt;C: FcFontSet *  FcFontSetSort(FcConfig * config, FcFontSet * * sets, int nsets, FcPattern * p, FcBool trim, FcCharSet * * csp, FcResult * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontSetSortDestroy: fs	&lt;C: void FcFontSetSortDestroy(FcFontSet * fs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcFontSort: config with: p with: trim with: csp with: result	&lt;C: FcFontSet *  FcFontSort(FcConfig * config, FcPattern * p, FcBool trim, FcCharSet * * csp, FcResult * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcGetVersion	&lt;C: int FcGetVersion(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcNameParse: name	&lt;C: FcPattern *  FcNameParse(FcChar8 const * name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcNameUnparse: pat	&lt;C: FcChar8 *  FcNameUnparse(FcPattern * pat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcObjectSetBuild: arguments	&lt;C: FcObjectSet*  FcObjectSetBuild( ...)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcObjectSetDestroy: os	&lt;C: void FcObjectSetDestroy(FcObjectSet *os)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAdd: p with: object with: value with: append	&lt;C: FcBool FcPatternAdd(FcPattern * p, const char * object, FcValue value, FcBool append)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddBool: p with: object with: b	&lt;C: FcBool FcPatternAddBool(FcPattern * p, const char * object, FcBool b)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddCharSet: p with: object with: c	&lt;C: FcBool FcPatternAddCharSet(FcPattern * p, const char * object, FcCharSet const * c)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddDouble: p with: object with: d	&lt;C: FcBool FcPatternAddDouble(FcPattern * p, const char * object, double d)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddInteger: p with: object with: i	&lt;C: FcBool FcPatternAddInteger(FcPattern * p, const char * object, int i)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddLangSet: p with: object with: ls	&lt;C: FcBool FcPatternAddLangSet(FcPattern * p, const char * object, const FcLangSet * ls)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddMatrix: p with: object with: s	&lt;C: FcBool FcPatternAddMatrix(FcPattern * p, const char * object, FcMatrix const * s)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddString: p with: object with: s	&lt;C: FcBool FcPatternAddString(FcPattern * p, const char * object, FcChar8 const * s)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternAddWeak: p with: object with: value with: append	&lt;C: FcBool FcPatternAddWeak(FcPattern * p, const char * object, FcValue value, FcBool append)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternBuild: argArray	&lt;C: FcPattern *  FcPatternBuild(FcPattern *, ...)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternCreate	&lt;C: FcPattern *  FcPatternCreate(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternDel: p with: object	&lt;C: FcBool FcPatternDel(FcPattern * p, const char * object)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternDestroy: p	&lt;C: void FcPatternDestroy(FcPattern * p)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternDuplicate: p	&lt;C: FcPattern *  FcPatternDuplicate(FcPattern const * p)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternEqual: pa with: pb	&lt;C: FcBool FcPatternEqual(FcPattern const * pa, FcPattern const * pb)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternEqualSubset: pa with: pb with: os	&lt;C: FcBool FcPatternEqualSubset(FcPattern const * pa, FcPattern const * pb, FcObjectSet const * os)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternFilter: p with: os	&lt;C: FcPattern *  FcPatternFilter(FcPattern * p, FcObjectSet const * os)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternFormat: pat with: format	&lt;C: FcChar8 *  FcPatternFormat(FcPattern * pat, FcChar8 const * format)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGet: p with: object with: id with: v	&lt;C: FcResult FcPatternGet(FcPattern const * p, const char * object, int id, FcValue * v)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGetBool: p with: object with: n with: b	&lt;C: FcResult FcPatternGetBool(FcPattern const * p, const char * object, int n, FcBool * b)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGetCharSet: p with: object with: n with: c	&lt;C: FcResult FcPatternGetCharSet(FcPattern const * p, const char * object, int n, FcCharSet * * c)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGetDouble: p with: object with: n with: d	&lt;C: FcResult FcPatternGetDouble(FcPattern const * p, const char * object, int n, double * d)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGetInteger: p with: object with: n with: i	&lt;C: FcResult FcPatternGetInteger(FcPattern const * p, const char * object, int n, int * i)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGetLangSet: p with: object with: n with: ls	&lt;C: FcResult FcPatternGetLangSet(FcPattern const * p, const char * object, int n, FcLangSet * * ls)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGetMatrix: p with: object with: n with: s	&lt;C: FcResult FcPatternGetMatrix(FcPattern const * p, const char * object, int n, FcMatrix * * s)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternGetString: p with: object with: n with: s	&lt;C: FcResult FcPatternGetString(FcPattern const * p, const char * object, int n, FcChar8 * * s)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternHash: p	&lt;C: FcChar32 FcPatternHash(FcPattern const * p)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternPrint: p	&lt;C: void FcPatternPrint(FcPattern const * p)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternReference: p	&lt;C: void FcPatternReference(FcPattern * p)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcPatternRemove: p with: object with: id	&lt;C: FcBool FcPatternRemove(FcPattern * p, const char * object, int id)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">FcStrFree: s	&lt;C: void FcStrFree(FcChar8 * s)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Xft.LibXft</class-id> <category>procedures - Xft</category><body package="Xft">XftCharExists: dpy with: pub with: ucs4	&lt;C: FcBool XftCharExists(Display * dpy, XftFont * pub, FcChar32 ucs4)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftCharSpecRender: dpy with: op with: src with: pub with: dst with: srcx with: srcy with: chars with: len	&lt;C: void XftCharSpecRender(Display * dpy, int op, Picture src, XftFont * pub, Picture dst, int srcx, int srcy, const XftCharSpec * chars, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftColorAllocName: dpy with: visual with: cmap with: name with: result	&lt;C: Bool XftColorAllocName(Display * dpy, Visual const * visual, Colormap cmap, const char * name, XftColor * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftColorAllocValue: dpy with: visual with: cmap with: color with: result	&lt;C: Bool XftColorAllocValue(Display * dpy, Visual * visual, Colormap cmap, XRenderColor const * color, XftColor * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftColorFree: dpy with: visual with: cmap with: color	&lt;C: void XftColorFree(Display * dpy, Visual * visual, Colormap cmap, XftColor * color)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDefaultHasRender: dpy	&lt;C: Bool XftDefaultHasRender(Display * dpy)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDefaultSet: dpy with: defaults	&lt;C: Bool XftDefaultSet(Display * dpy, FcPattern * defaults)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDefaultSubstitute: dpy with: screen with: pattern	&lt;C: void XftDefaultSubstitute(Display * dpy, int screen, FcPattern * pattern)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawChange: draw with: drawable	&lt;C: void XftDrawChange(XftDraw * draw, Drawable drawable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawCharSpec: draw with: color with: pub with: chars with: len	&lt;C: void XftDrawCharSpec(XftDraw * draw, const XftColor * color, XftFont * pub, const XftCharSpec * chars, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawColormap: draw	&lt;C: Colormap XftDrawColormap(XftDraw * draw)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawCreate: dpy with: drawable with: visual with: colormap	&lt;C: XftDraw *  XftDrawCreate(Display * dpy, Drawable drawable, Visual * visual, Colormap colormap)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawCreateAlpha: dpy with: pixmap with: depth	&lt;C: XftDraw *  XftDrawCreateAlpha(Display * dpy, Pixmap pixmap, int depth)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawCreateBitmap: dpy with: bitmap	&lt;C: XftDraw *  XftDrawCreateBitmap(Display * dpy, Pixmap bitmap)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawDestroy: draw	&lt;C: void XftDrawDestroy(XftDraw * draw)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawDisplay: draw	&lt;C: Display *  XftDrawDisplay(XftDraw * draw)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawDrawable: draw	&lt;C: Drawable XftDrawDrawable(XftDraw * draw)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawGlyphFontSpec: draw with: color with: glyphs with: len	&lt;C: void XftDrawGlyphFontSpec(XftDraw * draw, const XftColor * color, const XftGlyphFontSpec * glyphs, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawGlyphSpec: draw with: color with: pub with: glyphs with: len	&lt;C: void XftDrawGlyphSpec(XftDraw * draw, const XftColor * color, XftFont * pub, const XftGlyphSpec * glyphs, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawGlyphs: draw with: color with: pub with: x with: y with: glyphs with: nglyphs	&lt;C: void XftDrawGlyphs(XftDraw * draw, const XftColor * color, XftFont * pub, int x, int y, FT_UInt const * glyphs, int nglyphs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawSetClip: draw with: r	&lt;C: Bool XftDrawSetClip(XftDraw * draw, Region r)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawSetClipRectangles: draw with: xOrigin with: yOrigin with: rects with: n	&lt;C: Bool XftDrawSetClipRectangles(XftDraw * draw, int xOrigin, int yOrigin, XRectangle const * rects, int n)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawSetSubwindowMode: draw with: mode	&lt;C: void XftDrawSetSubwindowMode(XftDraw * draw, int mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawString16: draw with: color with: pub with: x with: y with: string with: len	&lt;C: void XftDrawString16(XftDraw * draw, const XftColor * color, XftFont * pub, int x, int y, FcChar16 const * string, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawString32: draw with: color with: pub with: x with: y with: string with: len	&lt;C: void XftDrawString32(XftDraw * draw, const XftColor * color, XftFont * pub, int x, int y, FcChar32 const * string, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawString8: draw with: color with: pub with: x with: y with: string with: len	&lt;C: void XftDrawString8(XftDraw * draw, const XftColor * color, XftFont * pub, int x, int y, FcChar8 const * string, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawStringUtf16: draw with: color with: pub with: x with: y with: string with: endian with: len	&lt;C: void XftDrawStringUtf16(XftDraw * draw, const XftColor * color, XftFont * pub, int x, int y, FcChar8 const * string, FcEndian endian, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawStringUtf8: draw with: color with: pub with: x with: y with: string with: len	&lt;C: void XftDrawStringUtf8(XftDraw * draw, const XftColor * color, XftFont * pub, int x, int y, FcChar8 const * string, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftDrawVisual: draw	&lt;C: Visual *  XftDrawVisual(XftDraw * draw)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontClose: dpy with: pub	&lt;C: void XftFontClose(Display * dpy, XftFont * pub)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontCopy: dpy with: pub	&lt;C: XftFont *  XftFontCopy(Display * dpy, XftFont * pub)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontMatch: dpy with: screen with: pattern with: result	&lt;C: FcPattern *  XftFontMatch(Display * dpy, int screen, FcPattern const * pattern, FcResult * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontOpen: argArray	&lt;C: XftFont *  XftFontOpen(Display *, int, ...)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontOpenInfo: dpy with: pattern with: fi	&lt;C: XftFont *  XftFontOpenInfo(Display * dpy, FcPattern * pattern, XftFontInfo * fi)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontOpenName: dpy with: screen with: name	&lt;C: XftFont *  XftFontOpenName(Display * dpy, int screen, const char * name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontOpenPattern: dpy with: pattern	&lt;C: XftFont *  XftFontOpenPattern(Display * dpy, FcPattern * pattern)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontOpenXlfd: dpy with: screen with: xlfd	&lt;C: XftFont *  XftFontOpenXlfd(Display * dpy, int screen, const char * xlfd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftFontUnloadGlyphs: dpy with: pub with: glyphs with: nglyph	&lt;C: void XftFontUnloadGlyphs(Display * dpy, XftFont * pub, FT_UInt const * glyphs, int nglyph)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftGetVersion	&lt;C: int XftGetVersion(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftGlyphExtents: dpy with: pub with: glyphs with: nglyphs with: extents	&lt;C: void XftGlyphExtents(Display * dpy, XftFont * pub, FT_UInt const * glyphs, int nglyphs, XGlyphInfo * extents)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftGlyphFontSpecRender: dpy with: op with: src with: dst with: srcx with: srcy with: glyphs with: nglyphs	&lt;C: void XftGlyphFontSpecRender(Display * dpy, int op, Picture src, Picture dst, int srcx, int srcy, const XftGlyphFontSpec * glyphs, int nglyphs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftGlyphRender: dpy with: op with: src with: pub with: dst with: srcx with: srcy with: x with: y with: glyphs with: nglyphs	&lt;C: void XftGlyphRender(Display * dpy, int op, Picture src, XftFont * pub, Picture dst, int srcx, int srcy, int x, int y, FT_UInt const * glyphs, int nglyphs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftGlyphSpecRender: dpy with: op with: src with: pub with: dst with: srcx with: srcy with: glyphs with: nglyphs	&lt;C: void XftGlyphSpecRender(Display * dpy, int op, Picture src, XftFont * pub, Picture dst, int srcx, int srcy, const XftGlyphSpec * glyphs, int nglyphs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftInit: config	&lt;C: FcBool XftInit(const char * config)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftInitFtLibrary	&lt;C: FcBool XftInitFtLibrary(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftListFonts: argArray	&lt;C: FcFontSet *  XftListFonts(Display * , int, ...)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftNameParse: name	&lt;C: FcPattern *  XftNameParse(const char * name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftNameUnparse: pat with: dest with: len	&lt;C: FcBool XftNameUnparse(XftPattern * pat, char * dest, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftTextExtents16: dpy with: pub with: string with: len with: extents	&lt;C: void XftTextExtents16(Display * dpy, XftFont * pub, FcChar16 const * string, int len, XGlyphInfo * extents)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftTextExtents32: dpy with: pub with: string with: len with: extents	&lt;C: void XftTextExtents32(Display * dpy, XftFont * pub, FcChar32 const * string, int len, XGlyphInfo * extents)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftTextExtents8: dpy with: pub with: string with: len with: extents	&lt;C: void XftTextExtents8(Display * dpy, XftFont * pub, FcChar8 const * string, int len, XGlyphInfo * extents)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftTextExtentsUtf16: dpy with: pub with: string with: endian with: len with: extents	&lt;C: void XftTextExtentsUtf16(Display * dpy, XftFont * pub, FcChar8 const * string, FcEndian endian, int len, XGlyphInfo * extents)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftTextExtentsUtf8: dpy with: pub with: string with: len with: extents	&lt;C: void XftTextExtentsUtf8(Display * dpy, XftFont * pub, FcChar8 const * string, int len, XGlyphInfo * extents)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XftXlfdParse: xlfd_orig with: ignore_scalable with: complete	&lt;C: FcPattern *  XftXlfdParse(const char * xlfd_orig, Bool ignore_scalable, Bool complete)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Xft.LibXft</class-id> <category>procedures - Xlib</category><body package="Xft">XCreateRegion	&lt;C: Region XCreateRegion()&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XDefaultColormap: display with: screen	&lt;C: Colormap XDefaultColormap(Display *display, int screen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XDefaultVisual: display with: screen	&lt;C: Visual* XDefaultVisual(Display *display, int screen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XDestroyRegion: region	&lt;C: void XDestroyRegion(Region region)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Xft">XPolygonRegion: points with: numberOfPoints with: fillRule	&lt;C: Region XPolygonRegion(XPoint points[], int numberOfPoints, int fillRule)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>properties</category><body package="Xft">family	&lt;propertyList: $, &gt;	&lt;print: #preferredFamily&gt;	^ self		propertyAt: #family		ifAbsent: 		[	" compatibility "			self propertyAt: #familyNames ifAbsent: [ #() ] 		]</body><body package="Xft">familyLanguages	&lt;propertyList: $,&gt;	&lt; print: nil&gt;		^ self propertyAt: #familylang ifAbsent: [ #( )]</body><body package="Xft">foundry	&lt;propertyType: #String&gt;	&lt;ignoredValues: #('unknown')&gt;	^ self propertyAt: #foundry</body><body package="Xft">fullName	&lt;propertyList: $,&gt;	&lt;print: #preferredFullName&gt;		^ self propertyAt: #fullname ifAbsent: [ #( )]</body><body package="Xft">fullNameLanguages	&lt;propertyList: $,&gt;	&lt; print: nil&gt;		^ self propertyAt: #fullnamelang ifAbsent: [ #( )]</body><body package="Xft">pixelSize	&lt;propertyType: #Double&gt;	^ self propertyAt: #pixelsize</body><body package="Xft">pointSize	&lt;propertyType: #Double&gt;	^ self propertyAt: #pointSize</body><body package="Xft">slant	&lt;propertyType: #Integer&gt;	^ self propertyAt: #slant</body><body package="Xft">spacing	&lt;propertyType: #Integer&gt;	^ self propertyAt: #spacing</body><body package="Xft">weight	&lt;propertyType: #Integer&gt;	^ self propertyAt: #weight</body></methods><methods><class-id>Xft.FontPattern class</class-id> <category>private</category><body package="Xft">propertyPragmas	" Pragmas that define a known/supported property "	&lt;pragmas: #instance&gt;	^ #( 		propertyType: 		ignoredValues: 		propertyList:printWith:  		propertyList: 		print: 	)</body></methods><methods><class-id>Graphics.WindowingSystem</class-id> <category>prerequisites</category><body package="Xft">xftPrerequisite	&lt;prerequisites&gt;	^Array with: Xft.XftSystem</body></methods><methods><class-id>Xft.LibXft</class-id> <category>defines</category><body package="Xft">EvenOddRule	&lt;C: #define EvenOddRule 0	&gt;</body><body package="Xft">FC_ANTIALIAS	&lt;C: #define FC_ANTIALIAS "antialias"	&gt;</body><body package="Xft">FC_ASPECT	&lt;C: #define FC_ASPECT "aspect"	&gt;</body><body package="Xft">FC_AUTOHINT	&lt;C: #define FC_AUTOHINT "autohint"	&gt;</body><body package="Xft">FC_CACHE_SUFFIX	&lt;C: #define FC_CACHE_SUFFIX ".cache-" FC_CACHE_VERSION	&gt;</body><body package="Xft">FC_CACHE_VERSION	&lt;C: #define FC_CACHE_VERSION "3"	&gt;</body><body package="Xft">FC_CAPABILITY	&lt;C: #define FC_CAPABILITY "capability"	&gt;</body><body package="Xft">FC_CHARCELL	&lt;C: #define FC_CHARCELL 110	&gt;</body><body package="Xft">FC_CHARSET	&lt;C: #define FC_CHARSET "charset"	&gt;</body><body package="Xft">FC_CHARSET_DONE	&lt;C: #define FC_CHARSET_DONE ((FcChar32)-1)	&gt;</body><body package="Xft">FC_CHARSET_MAP_SIZE	&lt;C: #define FC_CHARSET_MAP_SIZE (256/32)	&gt;</body><body package="Xft">FC_CHAR_HEIGHT	&lt;C: #define FC_CHAR_HEIGHT "charheight"	&gt;</body><body package="Xft">FC_CHAR_WIDTH	&lt;C: #define FC_CHAR_WIDTH "charwidth"	&gt;</body><body package="Xft">FC_DECORATIVE	&lt;C: #define FC_DECORATIVE "decorative"	&gt;</body><body package="Xft">FC_DIR_CACHE_FILE	&lt;C: #define FC_DIR_CACHE_FILE "fonts.cache-" FC_CACHE_VERSION	&gt;</body><body package="Xft">FC_DPI	&lt;C: #define FC_DPI "dpi"	&gt;</body><body package="Xft">FC_DUAL	&lt;C: #define FC_DUAL 90	&gt;</body><body package="Xft">FC_EMBEDDED_BITMAP	&lt;C: #define FC_EMBEDDED_BITMAP "embeddedbitmap"	&gt;</body><body package="Xft">FC_EMBOLDEN	&lt;C: #define FC_EMBOLDEN "embolden"	&gt;</body><body package="Xft">FC_FAMILY	&lt;C: #define FC_FAMILY "family"	&gt;</body><body package="Xft">FC_FAMILYLANG	&lt;C: #define FC_FAMILYLANG "familylang"	&gt;</body><body package="Xft">FC_FILE	&lt;C: #define FC_FILE "file"	&gt;</body><body package="Xft">FC_FONTFORMAT	&lt;C: #define FC_FONTFORMAT "fontformat"	&gt;</body><body package="Xft">FC_FONTVERSION	&lt;C: #define FC_FONTVERSION "fontversion"	&gt;</body><body package="Xft">FC_FOUNDRY	&lt;C: #define FC_FOUNDRY "foundry"	&gt;</body><body package="Xft">FC_FT_FACE	&lt;C: #define FC_FT_FACE "ftface"	&gt;</body><body package="Xft">FC_FULLNAME	&lt;C: #define FC_FULLNAME "fullname"	&gt;</body><body package="Xft">FC_FULLNAMELANG	&lt;C: #define FC_FULLNAMELANG "fullnamelang"	&gt;</body><body package="Xft">FC_GLOBAL_ADVANCE	&lt;C: #define FC_GLOBAL_ADVANCE "globaladvance"	&gt;</body><body package="Xft">FC_HINTING	&lt;C: #define FC_HINTING "hinting"	&gt;</body><body package="Xft">FC_HINT_FULL	&lt;C: #define FC_HINT_FULL 3	&gt;</body><body package="Xft">FC_HINT_MEDIUM	&lt;C: #define FC_HINT_MEDIUM 2	&gt;</body><body package="Xft">FC_HINT_NONE	&lt;C: #define FC_HINT_NONE 0	&gt;</body><body package="Xft">FC_HINT_SLIGHT	&lt;C: #define FC_HINT_SLIGHT 1	&gt;</body><body package="Xft">FC_HINT_STYLE	&lt;C: #define FC_HINT_STYLE "hintstyle"	&gt;</body><body package="Xft">FC_INDEX	&lt;C: #define FC_INDEX "index"	&gt;</body><body package="Xft">FC_LANG	&lt;C: #define FC_LANG "lang"	&gt;</body><body package="Xft">FC_LCD_DEFAULT	&lt;C: #define FC_LCD_DEFAULT 1	&gt;</body><body package="Xft">FC_LCD_FILTER	&lt;C: #define FC_LCD_FILTER "lcdfilter"	&gt;</body><body package="Xft">FC_LCD_LEGACY	&lt;C: #define FC_LCD_LEGACY 3	&gt;</body><body package="Xft">FC_LCD_LIGHT	&lt;C: #define FC_LCD_LIGHT 2	&gt;</body><body package="Xft">FC_LCD_NONE	&lt;C: #define FC_LCD_NONE 0	&gt;</body><body package="Xft">FC_MAJOR	&lt;C: #define FC_MAJOR 2	&gt;</body><body package="Xft">FC_MATRIX	&lt;C: #define FC_MATRIX "matrix"	&gt;</body><body package="Xft">FC_MINOR	&lt;C: #define FC_MINOR 8	&gt;</body><body package="Xft">FC_MINSPACE	&lt;C: #define FC_MINSPACE "minspace"	&gt;</body><body package="Xft">FC_MONO	&lt;C: #define FC_MONO 100	&gt;</body><body package="Xft">FC_OUTLINE	&lt;C: #define FC_OUTLINE "outline"	&gt;</body><body package="Xft">FC_PIXEL_SIZE	&lt;C: #define FC_PIXEL_SIZE "pixelsize"	&gt;</body><body package="Xft">FC_PROPORTIONAL	&lt;C: #define FC_PROPORTIONAL 0	&gt;</body><body package="Xft">FC_RASTERIZER	&lt;C: #define FC_RASTERIZER "rasterizer"	&gt;</body><body package="Xft">FC_REVISION	&lt;C: #define FC_REVISION 0	&gt;</body><body package="Xft">FC_RGBA	&lt;C: #define FC_RGBA "rgba"	&gt;</body><body package="Xft">FC_RGBA_BGR	&lt;C: #define FC_RGBA_BGR 2	&gt;</body><body package="Xft">FC_RGBA_NONE	&lt;C: #define FC_RGBA_NONE 5	&gt;</body><body package="Xft">FC_RGBA_RGB	&lt;C: #define FC_RGBA_RGB 1	&gt;</body><body package="Xft">FC_RGBA_UNKNOWN	&lt;C: #define FC_RGBA_UNKNOWN 0	&gt;</body><body package="Xft">FC_RGBA_VBGR	&lt;C: #define FC_RGBA_VBGR 4	&gt;</body><body package="Xft">FC_RGBA_VRGB	&lt;C: #define FC_RGBA_VRGB 3	&gt;</body><body package="Xft">FC_SCALABLE	&lt;C: #define FC_SCALABLE "scalable"	&gt;</body><body package="Xft">FC_SCALE	&lt;C: #define FC_SCALE "scale"	&gt;</body><body package="Xft">FC_SIZE	&lt;C: #define FC_SIZE "size"	&gt;</body><body package="Xft">FC_SLANT	&lt;C: #define FC_SLANT "slant"	&gt;</body><body package="Xft">FC_SLANT_ITALIC	&lt;C: #define FC_SLANT_ITALIC 100	&gt;</body><body package="Xft">FC_SLANT_OBLIQUE	&lt;C: #define FC_SLANT_OBLIQUE 110	&gt;</body><body package="Xft">FC_SLANT_ROMAN	&lt;C: #define FC_SLANT_ROMAN 0	&gt;</body><body package="Xft">FC_SOURCE	&lt;C: #define FC_SOURCE "source"	&gt;</body><body package="Xft">FC_SPACING	&lt;C: #define FC_SPACING "spacing"	&gt;</body><body package="Xft">FC_STYLE	&lt;C: #define FC_STYLE "style"	&gt;</body><body package="Xft">FC_STYLELANG	&lt;C: #define FC_STYLELANG "stylelang"	&gt;</body><body package="Xft">FC_USER_CACHE_FILE	&lt;C: #define FC_USER_CACHE_FILE ".fonts.cache-" FC_CACHE_VERSION	&gt;</body><body package="Xft">FC_UTF8_MAX_LEN	&lt;C: #define FC_UTF8_MAX_LEN 6	&gt;</body><body package="Xft">FC_VERSION	&lt;C: #define FC_VERSION ((FC_MAJOR*10000)+(FC_MINOR*100)+(FC_REVISION))	&gt;</body><body package="Xft">FC_VERTICAL_LAYOUT	&lt;C: #define FC_VERTICAL_LAYOUT "verticallayout"	&gt;</body><body package="Xft">FC_WEIGHT	&lt;C: #define FC_WEIGHT "weight"	&gt;</body><body package="Xft">FC_WEIGHT_BLACK	&lt;C: #define FC_WEIGHT_BLACK 210	&gt;</body><body package="Xft">FC_WEIGHT_BOLD	&lt;C: #define FC_WEIGHT_BOLD 200	&gt;</body><body package="Xft">FC_WEIGHT_BOOK	&lt;C: #define FC_WEIGHT_BOOK 75	&gt;</body><body package="Xft">FC_WEIGHT_DEMIBOLD	&lt;C: #define FC_WEIGHT_DEMIBOLD 180	&gt;</body><body package="Xft">FC_WEIGHT_EXTRABLACK	&lt;C: #define FC_WEIGHT_EXTRABLACK 215	&gt;</body><body package="Xft">FC_WEIGHT_EXTRABOLD	&lt;C: #define FC_WEIGHT_EXTRABOLD 205	&gt;</body><body package="Xft">FC_WEIGHT_EXTRALIGHT	&lt;C: #define FC_WEIGHT_EXTRALIGHT 40	&gt;</body><body package="Xft">FC_WEIGHT_HEAVY	&lt;C: #define FC_WEIGHT_HEAVY FC_WEIGHT_BLACK	&gt;</body><body package="Xft">FC_WEIGHT_LIGHT	&lt;C: #define FC_WEIGHT_LIGHT 50	&gt;</body><body package="Xft">FC_WEIGHT_MEDIUM	&lt;C: #define FC_WEIGHT_MEDIUM 100	&gt;</body><body package="Xft">FC_WEIGHT_NORMAL	&lt;C: #define FC_WEIGHT_NORMAL FC_WEIGHT_REGULAR	&gt;</body><body package="Xft">FC_WEIGHT_REGULAR	&lt;C: #define FC_WEIGHT_REGULAR 80	&gt;</body><body package="Xft">FC_WEIGHT_SEMIBOLD	&lt;C: #define FC_WEIGHT_SEMIBOLD FC_WEIGHT_DEMIBOLD	&gt;</body><body package="Xft">FC_WEIGHT_THIN	&lt;C: #define FC_WEIGHT_THIN 0	&gt;</body><body package="Xft">FC_WEIGHT_ULTRABLACK	&lt;C: #define FC_WEIGHT_ULTRABLACK FC_WEIGHT_EXTRABLACK	&gt;</body><body package="Xft">FC_WEIGHT_ULTRABOLD	&lt;C: #define FC_WEIGHT_ULTRABOLD FC_WEIGHT_EXTRABOLD	&gt;</body><body package="Xft">FC_WEIGHT_ULTRALIGHT	&lt;C: #define FC_WEIGHT_ULTRALIGHT FC_WEIGHT_EXTRALIGHT	&gt;</body><body package="Xft">FC_WIDTH	&lt;C: #define FC_WIDTH "width"	&gt;</body><body package="Xft">FC_WIDTH_CONDENSED	&lt;C: #define FC_WIDTH_CONDENSED 75	&gt;</body><body package="Xft">FC_WIDTH_EXPANDED	&lt;C: #define FC_WIDTH_EXPANDED 125	&gt;</body><body package="Xft">FC_WIDTH_EXTRACONDENSED	&lt;C: #define FC_WIDTH_EXTRACONDENSED 63	&gt;</body><body package="Xft">FC_WIDTH_EXTRAEXPANDED	&lt;C: #define FC_WIDTH_EXTRAEXPANDED 150	&gt;</body><body package="Xft">FC_WIDTH_NORMAL	&lt;C: #define FC_WIDTH_NORMAL 100	&gt;</body><body package="Xft">FC_WIDTH_SEMICONDENSED	&lt;C: #define FC_WIDTH_SEMICONDENSED 87	&gt;</body><body package="Xft">FC_WIDTH_SEMIEXPANDED	&lt;C: #define FC_WIDTH_SEMIEXPANDED 113	&gt;</body><body package="Xft">FC_WIDTH_ULTRACONDENSED	&lt;C: #define FC_WIDTH_ULTRACONDENSED 50	&gt;</body><body package="Xft">FC_WIDTH_ULTRAEXPANDED	&lt;C: #define FC_WIDTH_ULTRAEXPANDED 200	&gt;</body><body package="Xft">FcConfigGetRescanInverval	&lt;C: #define FcConfigGetRescanInverval FcConfigGetRescanInverval_REPLACE_BY_FcConfigGetRescanInterval	&gt;</body><body package="Xft">FcConfigSetRescanInverval	&lt;C: #define FcConfigSetRescanInverval FcConfigSetRescanInverval_REPLACE_BY_FcConfigSetRescanInterval	&gt;</body><body package="Xft">FcEndianBig	&lt;C: #define FcEndianBig 0	&gt;</body><body package="Xft">FcEndianLittle 	&lt;C: #define FcEndianLittle 1&gt;</body><body package="Xft">FcFalse	&lt;C: #define FcFalse 0	&gt;</body><body package="Xft">FcPublic	&lt;C: #define FcPublic 	&gt;</body><body package="Xft">FcTrue	&lt;C: #define FcTrue 1	&gt;</body><body package="Xft">WindingRule 	&lt;C: #define WindingRule  1	&gt;</body><body package="Xft">XFT_ANTIALIAS	&lt;C: #define XFT_ANTIALIAS FC_ANTIALIAS	&gt;</body><body package="Xft">XFT_CHARCELL	&lt;C: #define XFT_CHARCELL FC_CHARCELL	&gt;</body><body package="Xft">XFT_CHAR_HEIGHT	&lt;C: #define XFT_CHAR_HEIGHT FC_CHAR_HEIGHT	&gt;</body><body package="Xft">XFT_CHAR_WIDTH	&lt;C: #define XFT_CHAR_WIDTH FC_CHAR_WIDTH	&gt;</body><body package="Xft">XFT_CORE	&lt;C: #define XFT_CORE "core"	&gt;</body><body package="Xft">XFT_DPI	&lt;C: #define XFT_DPI FC_DPI	&gt;</body><body package="Xft">XFT_ENCODING	&lt;C: #define XFT_ENCODING "encoding"	&gt;</body><body package="Xft">XFT_FAMILY	&lt;C: #define XFT_FAMILY FC_FAMILY	&gt;</body><body package="Xft">XFT_FILE	&lt;C: #define XFT_FILE FC_FILE	&gt;</body><body package="Xft">XFT_FOUNDRY	&lt;C: #define XFT_FOUNDRY FC_FOUNDRY	&gt;</body><body package="Xft">XFT_INDEX	&lt;C: #define XFT_INDEX FC_INDEX	&gt;</body><body package="Xft">XFT_MAJOR	&lt;C: #define XFT_MAJOR 2	&gt;</body><body package="Xft">XFT_MATRIX	&lt;C: #define XFT_MATRIX FC_MATRIX	&gt;</body><body package="Xft">XFT_MAX_GLYPH_MEMORY	&lt;C: #define XFT_MAX_GLYPH_MEMORY "maxglyphmemory"	&gt;</body><body package="Xft">XFT_MAX_UNREF_FONTS	&lt;C: #define XFT_MAX_UNREF_FONTS "maxunreffonts"	&gt;</body><body package="Xft">XFT_MINOR	&lt;C: #define XFT_MINOR 1	&gt;</body><body package="Xft">XFT_MINSPACE	&lt;C: #define XFT_MINSPACE FC_MINSPACE	&gt;</body><body package="Xft">XFT_MONO	&lt;C: #define XFT_MONO FC_MONO	&gt;</body><body package="Xft">XFT_NMISSING	&lt;C: #define XFT_NMISSING 256	&gt;</body><body package="Xft">XFT_OUTLINE	&lt;C: #define XFT_OUTLINE FC_OUTLINE	&gt;</body><body package="Xft">XFT_PIXEL_SIZE	&lt;C: #define XFT_PIXEL_SIZE FC_PIXEL_SIZE	&gt;</body><body package="Xft">XFT_PROPORTIONAL	&lt;C: #define XFT_PROPORTIONAL FC_PROPORTIONAL	&gt;</body><body package="Xft">XFT_RASTERIZER	&lt;C: #define XFT_RASTERIZER FC_RASTERIZER	&gt;</body><body package="Xft">XFT_RENDER	&lt;C: #define XFT_RENDER "render"	&gt;</body><body package="Xft">XFT_REVISION	&lt;C: #define XFT_REVISION 14	&gt;</body><body package="Xft">XFT_RGBA	&lt;C: #define XFT_RGBA FC_RGBA	&gt;</body><body package="Xft">XFT_RGBA_BGR	&lt;C: #define XFT_RGBA_BGR FC_RGBA_BGR	&gt;</body><body package="Xft">XFT_RGBA_NONE	&lt;C: #define XFT_RGBA_NONE FC_RGBA_NONE	&gt;</body><body package="Xft">XFT_RGBA_RGB	&lt;C: #define XFT_RGBA_RGB FC_RGBA_RGB	&gt;</body><body package="Xft">XFT_RGBA_UNKNOWN	&lt;C: #define XFT_RGBA_UNKNOWN FC_RGBA_UNKNOWN	&gt;</body><body package="Xft">XFT_RGBA_VBGR	&lt;C: #define XFT_RGBA_VBGR FC_RGBA_VBGR	&gt;</body><body package="Xft">XFT_RGBA_VRGB	&lt;C: #define XFT_RGBA_VRGB FC_RGBA_VRGB	&gt;</body><body package="Xft">XFT_SCALABLE	&lt;C: #define XFT_SCALABLE FC_SCALABLE	&gt;</body><body package="Xft">XFT_SCALE	&lt;C: #define XFT_SCALE FC_SCALE	&gt;</body><body package="Xft">XFT_SIZE	&lt;C: #define XFT_SIZE FC_SIZE	&gt;</body><body package="Xft">XFT_SLANT	&lt;C: #define XFT_SLANT FC_SLANT	&gt;</body><body package="Xft">XFT_SLANT_ITALIC	&lt;C: #define XFT_SLANT_ITALIC FC_SLANT_ITALIC	&gt;</body><body package="Xft">XFT_SLANT_OBLIQUE	&lt;C: #define XFT_SLANT_OBLIQUE FC_SLANT_OBLIQUE	&gt;</body><body package="Xft">XFT_SLANT_ROMAN	&lt;C: #define XFT_SLANT_ROMAN FC_SLANT_ROMAN	&gt;</body><body package="Xft">XFT_SPACING	&lt;C: #define XFT_SPACING FC_SPACING	&gt;</body><body package="Xft">XFT_STYLE	&lt;C: #define XFT_STYLE FC_STYLE	&gt;</body><body package="Xft">XFT_VERSION	&lt;C: #define XFT_VERSION ((XFT_MAJOR*10000)+(XFT_MINOR*100)+(XFT_REVISION))	&gt;</body><body package="Xft">XFT_WEIGHT	&lt;C: #define XFT_WEIGHT FC_WEIGHT	&gt;</body><body package="Xft">XFT_WEIGHT_BLACK	&lt;C: #define XFT_WEIGHT_BLACK FC_WEIGHT_BLACK	&gt;</body><body package="Xft">XFT_WEIGHT_BOLD	&lt;C: #define XFT_WEIGHT_BOLD FC_WEIGHT_BOLD	&gt;</body><body package="Xft">XFT_WEIGHT_DEMIBOLD	&lt;C: #define XFT_WEIGHT_DEMIBOLD FC_WEIGHT_DEMIBOLD	&gt;</body><body package="Xft">XFT_WEIGHT_LIGHT	&lt;C: #define XFT_WEIGHT_LIGHT FC_WEIGHT_LIGHT	&gt;</body><body package="Xft">XFT_WEIGHT_MEDIUM	&lt;C: #define XFT_WEIGHT_MEDIUM FC_WEIGHT_MEDIUM	&gt;</body><body package="Xft">XFT_XLFD	&lt;C: #define XFT_XLFD "xlfd"	&gt;</body></methods><methods><class-id>Xft.LibXft</class-id> <category>types</category><body package="Xft">Bool	&lt;C: typedef void * Bool&gt;</body><body package="Xft">Colormap	&lt;C: typedef void * Colormap&gt;</body><body package="Xft">Display	&lt;C: typedef void * Display&gt;</body><body package="Xft">Drawable	&lt;C: typedef void * Drawable&gt;</body><body package="Xft">FT_Face	&lt;C: typedef void * FT_Face&gt;</body><body package="Xft">FT_Library	&lt;C: typedef void * FT_Library&gt;</body><body package="Xft">FT_UInt	&lt;C: typedef unsigned int FT_UInt&gt;</body><body package="Xft">FcAtomic	&lt;C: typedef struct _FcAtomic FcAtomic&gt;</body><body package="Xft">FcBlanks	&lt;C: typedef struct _FcBlanks FcBlanks&gt;</body><body package="Xft">FcBool	&lt;C: typedef int FcBool&gt;</body><body package="Xft">FcCache	&lt;C: typedef struct _FcCache FcCache&gt;</body><body package="Xft">FcChar16	&lt;C: typedef unsigned short FcChar16&gt;</body><body package="Xft">FcChar32	&lt;C: typedef unsigned int FcChar32&gt;</body><body package="Xft">FcChar8	&lt;C: typedef unsigned char FcChar8&gt;</body><body package="Xft">FcCharSet	&lt;C: typedef struct _FcCharSet FcCharSet&gt;</body><body package="Xft">FcConfig	&lt;C: typedef struct _FcConfig FcConfig&gt;</body><body package="Xft">FcConstant	&lt;C: typedef struct _FcConstant FcConstant&gt;</body><body package="Xft">FcEndian	&lt;C: typedef enum {			FcEndianBig, 			FcEndianLittle		} FcEndian&gt;</body><body package="Xft">FcFileCache	&lt;C: typedef struct _FcGlobalCache FcFileCache&gt;</body><body package="Xft">FcFontSet	&lt;C: typedef struct _FcFontSet FcFontSet&gt;</body><body package="Xft">FcLangResult	&lt;C: typedef enum _FcLangResult FcLangResult&gt;</body><body package="Xft">FcLangSet	&lt;C: typedef struct _FcLangSet FcLangSet&gt;</body><body package="Xft">FcMatchKind	&lt;C: typedef enum _FcMatchKind FcMatchKind&gt;</body><body package="Xft">FcMatrix	&lt;C: typedef struct _FcMatrix FcMatrix&gt;</body><body package="Xft">FcObjectSet	&lt;C: typedef struct _FcObjectSet FcObjectSet&gt;</body><body package="Xft">FcObjectType	&lt;C: typedef struct _FcObjectType FcObjectType&gt;</body><body package="Xft">FcPattern	&lt;C: typedef struct _FcPattern FcPattern&gt;</body><body package="Xft">FcResult	&lt;C: typedef enum _FcResult FcResult&gt;</body><body package="Xft">FcSetName	&lt;C: typedef enum _FcSetName FcSetName&gt;</body><body package="Xft">FcStrList	&lt;C: typedef struct _FcStrList FcStrList&gt;</body><body package="Xft">FcStrSet	&lt;C: typedef struct _FcStrSet FcStrSet&gt;</body><body package="Xft">FcType	&lt;C: typedef enum _FcType FcType&gt;</body><body package="Xft">FcValue	&lt;C: typedef struct _FcValue FcValue&gt;</body><body package="Xft">PFcCharSet	&lt;C: typedef FcCharSet *PFcCharSet&gt;</body><body package="Xft">Picture	&lt;C: typedef void * Picture&gt;</body><body package="Xft">Pixmap	&lt;C: typedef void * Pixmap&gt;</body><body package="Xft">Region	&lt;C: typedef void * Region&gt;</body><body package="Xft">Visual	&lt;C: typedef void * Visual&gt;</body><body package="Xft">XGlyphInfo	&lt;C: typedef struct _XGlyphInfo XGlyphInfo&gt;</body><body package="Xft">XPoint	&lt;C: typedef struct _XPoint XPoint&gt;</body><body package="Xft">XRectangle	&lt;C: typedef struct _XRectangle XRectangle&gt;</body><body package="Xft">XRenderColor	&lt;C: typedef struct _XRenderColor XRenderColor&gt;</body><body package="Xft">XftChar16	&lt;C: typedef FcChar16 XftChar16&gt;</body><body package="Xft">XftChar32	&lt;C: typedef FcChar32 XftChar32&gt;</body><body package="Xft">XftChar8	&lt;C: typedef FcChar8 XftChar8&gt;</body><body package="Xft">XftCharFontSpec	&lt;C: typedef struct _XftCharFontSpec XftCharFontSpec&gt;</body><body package="Xft">XftCharSpec	&lt;C: typedef struct _XftCharSpec XftCharSpec&gt;</body><body package="Xft">XftColor	&lt;C: typedef struct _XftColor XftColor&gt;</body><body package="Xft">XftDraw	&lt;C: typedef struct _XftDraw XftDraw&gt;</body><body package="Xft">XftFont	&lt;C: typedef struct _XftFont XftFont&gt;</body><body package="Xft">XftFontInfo	&lt;C: typedef struct _XftFontInfo XftFontInfo&gt;</body><body package="Xft">XftFontSet	&lt;C: typedef FcFontSet XftFontSet&gt;</body><body package="Xft">XftGlyphFontSpec	&lt;C: typedef struct _XftGlyphFontSpec XftGlyphFontSpec&gt;</body><body package="Xft">XftGlyphSpec	&lt;C: typedef struct _XftGlyphSpec XftGlyphSpec&gt;</body><body package="Xft">XftMatrix	&lt;C: typedef FcMatrix XftMatrix&gt;</body><body package="Xft">XftObjectSet	&lt;C: typedef FcObjectSet XftObjectSet&gt;</body><body package="Xft">XftPattern	&lt;C: typedef FcPattern XftPattern&gt;</body><body package="Xft">XftResult	&lt;C: typedef FcResult XftResult&gt;</body><body package="Xft">XftType	&lt;C: typedef FcType XftType&gt;</body><body package="Xft">XftValue	&lt;C: typedef FcValue XftValue&gt;</body><body package="Xft">va_list	&lt;C: typedef void * va_list&gt;</body></methods><methods><class-id>Xft.LibXft</class-id> <category>structs</category><body package="Xft">_FcAtomic	&lt;C: struct _FcAtomic&gt;</body><body package="Xft">_FcBlanks	&lt;C: struct _FcBlanks&gt;</body><body package="Xft">_FcCache	&lt;C: struct _FcCache&gt;</body><body package="Xft">_FcCharSet	&lt;C: struct _FcCharSet&gt;</body><body package="Xft">_FcConfig	&lt;C: struct _FcConfig&gt;</body><body package="Xft">_FcConstant	&lt;C: struct _FcConstant {			const FcChar8 * name;			const char * object;			int value;		}&gt;</body><body package="Xft">_FcFontSet	&lt;C: struct _FcFontSet {			int nfont, sfont;			FcPattern * * fonts;		}&gt;</body><body package="Xft">_FcGlobalCache	&lt;C: struct _FcGlobalCache&gt;</body><body package="Xft">_FcLangSet	&lt;C: struct _FcLangSet&gt;</body><body package="Xft">_FcMatrix	&lt;C: struct _FcMatrix {			double xx, xy, yx, yy;		}&gt;</body><body package="Xft">_FcObjectSet	&lt;C: struct _FcObjectSet {			int nobject, sobject;			const char * * objects;		}&gt;</body><body package="Xft">_FcObjectType	&lt;C: struct _FcObjectType {			const char * object;			FcType type;		}&gt;</body><body package="Xft">_FcPattern	&lt;C: struct _FcPattern&gt;</body><body package="Xft">_FcStrList	&lt;C: struct _FcStrList&gt;</body><body package="Xft">_FcStrSet	&lt;C: struct _FcStrSet&gt;</body><body package="Xft">_FcValue	&lt;C: struct _FcValue {			FcType type;			union {				const FcChar8 * s;				int i;				FcBool b;				double d;				const FcMatrix * m;				const FcCharSet * c;				void * f;				const FcLangSet * l;			} u;		}&gt;</body><body package="Xft">_XGlyphInfo	&lt;C: struct  _XGlyphInfo {		    unsigned short  width;		    unsigned short  height;		    short	    x;		    short	    y;		    short	    xOff;		    short	    yOff;		}&gt;</body><body package="Xft">_XPoint	&lt;C: struct _XPoint{	short x, y;}&gt;</body><body package="Xft">_XRectangle	&lt;C: struct _XRectangle {		short x, y;		unsigned short width, height;	}&gt;</body><body package="Xft">_XRenderColor	&lt;C: struct _XRenderColor {			unsigned short red, green, blue, alpha;		}&gt;</body><body package="Xft">_XftCharFontSpec	&lt;C: struct _XftCharFontSpec {			XftFont * font;			FcChar32 ucs4;			short x, y;		}&gt;</body><body package="Xft">_XftCharSpec	&lt;C: struct _XftCharSpec {			FcChar32 ucs4;			short x, y;		}&gt;</body><body package="Xft">_XftColor	&lt;C: struct _XftColor {			unsigned long pixel;			XRenderColor color;		}&gt;</body><body package="Xft">_XftDraw	&lt;C: struct _XftDraw&gt;</body><body package="Xft">_XftFont	&lt;C: struct _XftFont {			int ascent, descent, height, max_advance_width;			FcCharSet * charset;			FcPattern * pattern;		}&gt;</body><body package="Xft">_XftFontInfo	&lt;C: struct _XftFontInfo&gt;</body><body package="Xft">_XftGlyphFontSpec	&lt;C: struct _XftGlyphFontSpec {			XftFont * font;			FT_UInt glyph;			short x, y;		}&gt;</body><body package="Xft">_XftGlyphSpec	&lt;C: struct _XftGlyphSpec {			FT_UInt glyph;			short x, y;		}&gt;</body><body package="Xft">stat	&lt;C: struct stat&gt;</body></methods><methods><class-id>Xft.LibXft</class-id> <category>enums</category><body package="Xft">_FcLangResult	&lt;C: enum _FcLangResult {			FcLangEqual, 			FcLangDifferentCountry, 			FcLangDifferentTerritory = 1, 			FcLangDifferentLang		}&gt;</body><body package="Xft">_FcMatchKind	&lt;C: enum _FcMatchKind {			FcMatchPattern, 			FcMatchFont, 			FcMatchScan		}&gt;</body><body package="Xft">_FcResult	&lt;C: enum _FcResult {			FcResultMatch, 			FcResultNoMatch, 			FcResultTypeMismatch, 			FcResultNoId, 			FcResultOutOfMemory		}&gt;</body><body package="Xft">_FcSetName	&lt;C: enum _FcSetName {			FcSetSystem, 			FcSetApplication		}&gt;</body><body package="Xft">_FcType	&lt;C: enum _FcType {			FcTypeVoid, 			FcTypeInteger, 			FcTypeDouble, 			FcTypeString, 			FcTypeBool, 			FcTypeMatrix, 			FcTypeCharSet, 			FcTypeFTFace, 			FcTypeLangSet		}&gt;</body></methods><methods><class-id>Xft.LibXft</class-id> <category>enums - convenience</category><body package="Xft">XftTypeBool	^ self _FcType memberNamed: #FcTypeBool</body><body package="Xft">XftTypeDouble	^ self _FcType memberNamed: #FcTypeDouble</body><body package="Xft">XftTypeInteger	^ self _FcType memberNamed: #FcTypeInteger</body><body package="Xft">XftTypeMatrix	^ self _FcType memberNamed: #FcTypeMatrix</body><body package="Xft">XftTypeString	^ self _FcType memberNamed: #FcTypeString</body><body package="Xft">XftTypeVoid	^ self _FcType memberNamed: #FcTypeVoid</body></methods><methods><class-id>Xft.LibXft</class-id> <category>utilities</category><body package="Xft">printFcFontPattern: anFcPattern 	| fcName pattern |	fcName := self FcNameUnparse: anFcPattern.	pattern := fcName copyCStringFromHeap: #utf8.	self  FcStrFree: fcName.	^ pattern</body></methods><methods><class-id>Xft.LibXft class</class-id> <category>instance creation</category><body package="Xft">current	current isNil		ifTrue: [ current := self new ].	^ current</body><body package="Xft">flushCurrent	current := nil</body></methods><methods><class-id>Xft.LibXft class</class-id> <category>testing</category><body package="Xft">isAvailable	^ [		self current XftGetVersion.		true	] on: Error do: [ :ex |		false	].</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>properties</category><body package="Xft">family: aFamilyNameCollection	self propertyAt: #family put: aFamilyNameCollection</body><body package="Xft">familyLanguages: aLanguageCollection	self propertyAt: #familylang put: aLanguageCollection</body><body package="Xft">foundry: aString	self propertyAt: #foundry put: aString</body><body package="Xft">fullName: aNameCollection	self propertyAt: #fullname put: aNameCollection</body><body package="Xft">fullNameLanguages: aLanguageCollection	self propertyAt: #fullnamelang put: aLanguageCollection</body><body package="Xft">pixelSize: aNumber	self propertyAt: #pixelsize put: aNumber</body><body package="Xft">pointSize: aNumber	self propertyAt: #pointSize put: aNumber</body><body package="Xft">slant: anInteger	self propertyAt: #slant put: anInteger</body><body package="Xft">spacing: anInteger	self propertyAt: #spacing put: anInteger</body><body package="Xft">weight: anInteger	self propertyAt: #weight put: anInteger</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>comparing</category><body package="Xft">= anotherPattern	^ self class = anotherPattern class and: [ self properties = anotherPattern properties ]</body><body package="Xft">hash	^ self properties hash</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>initialize-release</category><body package="Xft">initialize	properties := Dictionary new</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>accessing</category><body package="Xft">preferredFamily	^ self preferredNameFrom: self family languages: self familyLanguages</body><body package="Xft">preferredFullName	" Returnes the preferred full name of the font "	^ self preferredNameFrom: self fullName languages: self fullNameLanguages</body><body package="Xft">properties	^ properties</body><body package="Xft">propertyAt: aPropertyName 	" Returns the value of the property, or nil if the property does not exist "	^ self propertyAt: aPropertyName ifAbsent: [ nil ]</body><body package="Xft">propertyAt: aPropertyName ifAbsent: aBlock	" Returns the value of the property, or the value of the block does not exist "	^ properties at: aPropertyName ifAbsent: aBlock</body><body package="Xft">propertyAt: aPropertyName put: aPropertyValueOrString	" Converts the value according to the type definition "	| propertyValue |	propertyValue := aPropertyValueOrString isCharacters				ifTrue: 				[	" convert if necessary "					self class readProperty: aPropertyName valueString: aPropertyValueOrString 				]				ifFalse: 				[	" assume the sender knows the correct type "					aPropertyValueOrString 				].	propertyValue notNil		ifTrue: [ properties at: aPropertyName put: propertyValue ]		ifFalse: [ properties removeKey: aPropertyName ifAbsent: [  ] ]</body><body package="Xft">propertyStringAt: aPropertyName ifAbsent: aBlock	" Returns the value of the property value as string, or the value of the block if the property is absent "	| propertyValue |	propertyValue := properties at: aPropertyName ifAbsent: [ nil ].	^ propertyValue notNil		ifTrue: [ (self printProperty: aPropertyName value: propertyValue) ifNil: [ aBlock value ] ]		ifFalse: [ aBlock value ]</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>copying</category><body package="Xft">postCopy	super postCopy.	properties notNil		ifTrue: [ properties := properties copy ]</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>private</category><body package="Xft">applyStyleToFontDescriptions: fontDescriptions</body><body package="Xft">glyphCacheKey	" returns a value suitable for caching glyph information "	| key |	key := self preferredFamily.	self foundry ifNotNil: [: foundry | key := key , '/' , foundry ].	^ key</body><body package="Xft">preferredNameFrom: names languages: languages 	" Returns the preferred name "	| preferredLanguage index name |	^ names notEmpty 		ifTrue: 		[	index := nil.			names size &gt; 1 				ifTrue: 				[	" Try language of the curent locale first "					preferredLanguage := Locale current languageID ifNil: [ 'en' ].					index := languages indexOf: preferredLanguage ifAbsent: [ nil ].					" ... then english... "					( index isNil and: [ preferredLanguage ~= 'en' ]) 						ifTrue: [ index := languages indexOf: 'en' ifAbsent: [ nil ]]				].			index isNil 				ifTrue: [ index := 1 ].			name := index &lt;= names size 					ifTrue: [ names at: index ]					ifFalse: [ names first ].			self unescapeName: name		]		ifFalse: [ nil ]</body><body package="Xft">unescapeName: aName	^ self class unescapeName: aName</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>converting</category><body package="Xft">createFontDescription	" Create a FontDescription  "	| fontDescription |	fontDescription := self createFontDescriptionWithoutFamily.	fontDescription family: self preferredFamily.	^ fontDescription</body><body package="Xft">createFontDescriptionForMatching	" Create a FontDescription suitable for matching a list of font descriptions "	| fontDescription |	fontDescription := self createFontDescriptionWithoutFamily.	fontDescription family: self family, #('*').	^ fontDescription</body><body package="Xft">createFontDescriptionWithoutFamily	" Create a FontDescription without  family "	| fontDescription lib spacing slant pointSize pixelSize |	fontDescription := FontPatternDescription fontPattern: self.	lib := LibXft current.	fontDescription manufacturer: self foundry.	spacing := self spacing.	fontDescription fixedWidth: ( spacing = lib XFT_MONO or: [ spacing = lib XFT_CHARCELL ]).	slant := self slant.	fontDescription italic: ( slant = lib XFT_SLANT_ITALIC or: [ slant = LibXft current XFT_SLANT_OBLIQUE ]).	fontDescription boldness: ( XftFont boldnessForWeight: ( self weight ifNil: [ LibXft current XFT_WEIGHT_MEDIUM ])).	fontDescription encoding: XftFont defaultEncodingName.	pointSize := self pointSize.	pixelSize := self pixelSize ifNil: 			[	pointSize notNil 					ifTrue: [ pointSize * XftFont pointToPixelSizeFactor ]					ifFalse: [ nil ]			].	fontDescription pixelSize: pixelSize pointSize: pointSize.	^ fontDescription</body></methods><methods><class-id>Xft.FontPattern</class-id> <category>printing</category><body package="Xft">patternString	" Print a pattern that can be parsed by Xft "	| stream skippedProperties |	stream := String new writeStream.	skippedProperties := #( #family #pointSize ).	" family and point size have a special syntax "	self preferredFamily ifNotNil: 		[: familyString |			stream nextPutAll: familyString.			( self propertyStringAt: #pointSize ifAbsent: [ nil ]) ifNotNil: 				[: pointStringString |					skippedProperties := skippedProperties , #( #pixelsize ).					stream nextPut: $-; nextPutAll: pointStringString				]		].	" print all other properties as name=value "	self properties keysAndValuesDo: 		[: propertyName : propertyValue | | propertyValueString |			( skippedProperties includes: propertyName ) 				ifFalse: 				[	propertyValueString := self printProperty: propertyName value: propertyValue.					propertyValueString notNil 						ifTrue: 						[	stream								nextPut: $:; nextPutAll: propertyName; nextPut: $=; nextPutAll: propertyValueString						]				]		].	^ stream contents</body><body package="Xft">printProperty: aPropertyName value: propertyValue 	^ self class printProperty: aPropertyName value: propertyValue pattern: self</body></methods><methods><class-id>Xft.FontPattern class</class-id> <category>instance creation</category><body package="Xft">createFromString: aPatternString	" Parse a pattern text  "	| tokens nameToken names pattern propertyValueString pointIndex |	pattern := self new.	tokens := aPatternString tokensBasedOn: $:.	nameToken := tokens removeFirst.	pointIndex := nameToken lastIndexOf: $- ifAbsent: [ nil ].	(pointIndex notNil and: [ (nameToken at: pointIndex - 1) ~= $\ ])		ifTrue: 		[	pattern pointSize: (nameToken copyFrom: pointIndex + 1 to: nameToken size).			nameToken := nameToken copyFrom: 1 to: pointIndex - 1 		].	names := nameToken tokensBasedOn: $,.	pattern family: names.	" parse known properties, skip unknown ones "	tokens do: 		[: token | | i propertyName |			i := token indexOf: $= ifAbsent: [ nil ].			i notNil				ifTrue: 				[	propertyName := (token copyFrom: 1 to: i - 1) asSymbol.					(propertyReadConverters includesKey: propertyName)						ifTrue: 						[	propertyValueString := token copyFrom: i + 1 to: token size.							pattern propertyAt: propertyName asSymbol put: propertyValueString 						] 				] 		].	^ pattern</body><body package="Xft">new	^ super new initialize</body></methods><methods><class-id>Xft.FontPattern class</class-id> <category>class initialization</category><body package="Xft">initialize	self initializeConverters.</body><body package="Xft">initializeConverters	| customPrintConverters |	propertyReadConverters := Dictionary new.	propertyPrintConverters := Dictionary new.	" Property values that are not stored in the font pattern "	ignoredValues := Dictionary new.	( Pragma allNamed: #ignoredValues: in: self ) do: [: pragma | ignoredValues at: pragma selector put: ( pragma argumentAt: 1 )].	" Custom print methods "	customPrintConverters := Dictionary new.	( Pragma allNamed: #print: in: self ) 		do: [: pragma | customPrintConverters at: pragma selector put: ( self printConverterForSelector: ( pragma argumentAt: 1 ))].	" register value converters "	( Pragma allNamed: #propertyType: in: self ) do: 		[: pragma | | type propertyName |			propertyName := pragma selector.			type := pragma argumentAt: 1.			propertyReadConverters at: propertyName put: ( self readConverterForType: type ).			propertyPrintConverters at: propertyName put: ( customPrintConverters at: propertyName ifAbsent: [ self printConverterForType: type ])		].	( Pragma allNamed: #propertyList: in: self ) do: 		[: pragma | | propertyName separator |			propertyName := pragma selector.			separator := pragma argumentAt: 1.			propertyReadConverters at: propertyName put: ( self readConverterForListWithSeparator: separator ).			propertyPrintConverters 				at: propertyName				put: ( customPrintConverters at: propertyName ifAbsent: [ self printConverterForListWithSeparator: separator ])		].</body></methods><methods><class-id>Xft.FontPattern class</class-id> <category>private</category><body package="Xft">printConverterForListWithSeparator: separator	^ [ : propertyValueList | | stream |		stream := String new writeStream.		propertyValueList do: [ : string | stream nextPutAll: string ] separatedBy:[ stream  nextPut: separator ].		stream contents	]</body><body package="Xft">printConverterForSelector: aSelector 	^ aSelector notNil 		ifTrue: [ [: propertyValueList : pattern | pattern perform: aSelector ]]		ifFalse: 		[	" do not print "			[: propertyValueList : pattern | nil ]		]</body><body package="Xft">printConverterForType: aType	aType = #String		ifTrue: [ ^ [: propertyValue | propertyValue ] ].	aType = #Integer		ifTrue: [ ^ [: propertyValue | propertyValue rounded printString ] ].	aType = #Double		ifTrue: [ ^ [: propertyValue | propertyValue asFloat displayString ] ].	aType = #Boolean		ifTrue:[ ^ [: propertyValue | propertyValue == true ifTrue: [ 'True' ] ifFalse: [ 'False' ] ] ].	^ [: propertyValue | propertyValue displayString ]</body><body package="Xft">printProperty: aPropertyName value: aPropertyValue pattern: aPattern	^ (propertyPrintConverters at: aPropertyName ifAbsent: [ [: propertyValue : pattern | propertyValue displayString ] ]) cull: aPropertyValue cull: aPattern</body><body package="Xft">readConverterForListWithSeparator: separator	^ [ : propertyValueString | propertyValueString tokensBasedOn: separator ]</body><body package="Xft">readConverterForType: aType	aType = #Integer		ifTrue: [ ^ [: propertyValueString | (Integer readFrom: propertyValueString readStream) rounded ] ].	aType = #Double		ifTrue: [ ^ [: propertyValueString | Double readFrom: propertyValueString readStream ] ].	aType = #Boolean		ifTrue: [ ^ [: propertyValueString | propertyValueString asLowercase = 'true' ] ].	 ^ [: propertyValueString | propertyValueString ]</body><body package="Xft">readProperty: aPropertyName valueString: aPropertyValueString	ignoredValues		at: aPropertyName		ifPresent: 		[: blacklist |			(blacklist includes: aPropertyValueString)				ifTrue: [ ^ nil ] 		].	^ (propertyReadConverters		at: aPropertyName		ifAbsent: [ [: propertyValueString | propertyValueString ] ]) value: aPropertyValueString</body><body package="Xft">unescapeName: aName	| stream readStream |	stream := String new writeStream.	readStream := aName readStream.	[ readStream atEnd ] whileFalse: 		[ | char |			char := readStream next.			char = $\				ifTrue: [ stream nextPut: readStream next ]				ifFalse: [ stream nextPut: char ] 		].	^ stream contents</body></methods><methods><class-id>Xft.UnicodeCompositeFont</class-id> <category>initialization</category><body package="Xft">font: aFont requestedFontDescription: aFontDescription device: aDevice	" Examine the glyphs of the first font only, the other ones will be computed on demand "	device := aDevice.	requestedFontDescription := aFontDescription.	self with: (OrderedCollection with: aFont)  priorityTable: aFont glyphTable.</body><body package="Xft">fonts: aFontList 	" there are no further fonts, only the specified ones "	availableFonts := OrderedCollection new.	" Examine the glyphs of the first font only, the other ones will be computed on demand "	self with: aFontList priorityTable: aFontList first glyphTable</body><body package="Xft">with: aFontList priorityTable: priorityArray	currentFont := aFontList at: 1.	fonts := aFontList.	" the fallbacks might contain some wacky fonts, so only consider the first one for ascent/descent "	ascent := currentFont ascent.	descent := currentFont descent.	lastPriorityTableFontIndex := 1.	priorityTable := priorityArray.	^ self</body></methods><methods><class-id>Xft.UnicodeCompositeFont</class-id> <category>displaying</category><body package="Xft">displayByteIndexedString: string from: start to: stop at: aPoint on: aGraphicsContext 	self displayString: string from: start to: stop at: aPoint on: aGraphicsContext</body><body package="Xft">displayTwoByteString: string from: start to: stop at: aPoint on: aGraphicsContext	self displayString: string from: start to: stop at: aPoint on: aGraphicsContext</body></methods><methods><class-id>Xft.UnicodeCompositeFont</class-id> <category>private</category><body package="Xft">addNextAvailableFont	" Add the next available font , if possible.	The font will be opened, which takes some time &amp; resources "	| fontDescription |	( requestedFontDescription notNil and: [ device notNil and: [ self availableFonts notEmpty ]]) 		ifTrue: 		[	fontDescription := self availableFonts removeFirst.			[ | font |				font := XftFont createDeviceFont: fontDescription toResemble: requestedFontDescription on: device.				fonts add: font			] on: NoMatchingFontError do: [: ex | ]		].</body><body package="Xft">availableFonts	availableFonts isNil		ifTrue: [ availableFonts := fonts first compositeFontDescriptions ].	^ availableFonts</body><body package="Xft">canExtendPriorityTable	^ lastPriorityTableFontIndex &lt; fonts size or: [ self availableFonts notEmpty ]</body><body package="Xft">extendPriorityTable	" extend the priority table with the next font "	| font |	lastPriorityTableFontIndex = 1		ifTrue: 		[	" need a private copy "			priorityTable := priorityTable copy 		].	" extend the font  list, if we've reached the end of the current list of fonts "	[ lastPriorityTableFontIndex &gt;= fonts size and: [ self availableFonts notEmpty ] ] whileTrue: 		[			self addNextAvailableFont 		].	lastPriorityTableFontIndex &lt; fonts size		ifTrue: 		[	lastPriorityTableFontIndex := lastPriorityTableFontIndex + 1.			font := fonts at: lastPriorityTableFontIndex.			font glyphRanges do: 				[: range |					range first to: range last						do: 						[: i | | k |							k := i + 1.							(priorityTable at: k) = 0								ifTrue: [ priorityTable at: k put: lastPriorityTableFontIndex ] 						] 				] 		]</body><body package="Xft">getFontFor: aCharacter	"Set my currentFont to be appropriate for aCharacter"	| fontCollectionIndex index priorityIndex |	index := aCharacter asInteger + 1.	fontCollectionIndex := index &gt; priorityTable size				ifTrue: [ 0 ]				ifFalse: 				[	priorityIndex := priorityTable at: index.					" Extend the priority table if no glyph is available.					Do not try to find fonts for control characters "					[ priorityIndex = 0 and: [ index &gt;= 33 and: [ self canExtendPriorityTable ] ] ] whileTrue: 						[	self extendPriorityTable.							priorityIndex := priorityTable at: index 						].					priorityIndex 				].	^ fontCollectionIndex == 0		ifTrue: [ fonts at: 1 ]		ifFalse: [ fonts at: fontCollectionIndex ]</body></methods><methods><class-id>Xft.UnicodeCompositeFont</class-id> <category>compatibility</category><body package="Xft">asDeviceFont	" sent by ExtraEmphases "	^ self</body></methods><methods><class-id>Xft.UnicodeCompositeFont class</class-id> <category>instance creation</category><body package="Xft">font: aFont requestedFontDescription: aFontDescription device: aDevice	^ self new font: aFont requestedFontDescription: aFontDescription device: aDevice;		yourself</body><body package="Xft">fonts: aFontList 	^ self new fonts: aFontList;		yourself</body></methods><methods><class-id>Xft.XftFont</class-id> <category>private</category><body package="Xft">getWidths: index into: widthArray	" Uses XftTextExtents to measure the glyphs "	| glyphInfo width display string |	self reopenIfNecessary.	display := self xftDisplay.	glyphInfo := self library XGlyphInfo gcMalloc.	string := self library FcChar16 malloc: 1.	[	1 to: widthArray size			do: 			[: i |				glyphInfo zeroFill.				string contents: i + index - 1.				self library					XftTextExtents16: display					with: xftFont					with: string					with: 1					with: glyphInfo.				width := glyphInfo memberAt: #xOff.				widthArray at: i put: width 			] 	] ensure: [ string free ]</body><body package="Xft">initializeFromFont	" Get information about the font "	| pattern patternString |	ascent := xftFont memberAt: #ascent.	descent := xftFont memberAt: #descent.	widths := LargeArray new: 65536.	" slightly cheesy: VW expects a single string as the family name of the font description "	patternString := self library printFcFontPattern: self xftPattern.	pattern :=  FontPattern createFromString: patternString.	pattern preferredFamily ifNotNil: [ : family | self fontDescription xftSetFamily:  family ].</body><body package="Xft">library	^ LibXft current</body><body package="Xft">openFont	" Open the XftFont "	| result display pattern matchPattern |	result := self library XftResult gcMalloc.	display := self xftDisplay.	pattern := self library				XftNameParse: (self fontDescription xftFontPatternString copyToHeapEncoding: #utf8).	pattern isNull		ifTrue: [ self error: ('Could not create Xft font pattern &lt;1s&gt;' expandMacrosWith: pattern) ].	matchPattern := self library				XftFontMatch: display				with: self xftScreen				with: pattern				with: result.	matchPattern isNull		ifTrue: [ self error: ('Could not match Xft font &lt;1s&gt;' expandMacrosWith: pattern) ].	[	" apply appearance settings (antialias, subpixel rendering etc.) "		self class settings ifNotNil: [: settings | settings appyToPattern: matchPattern ].		xftFont := self library XftFontOpenPattern: display with: matchPattern.		xftFont isNull			ifTrue: [ self error: ('Could not open Xft font &lt;1s&gt;' expandMacrosWith: pattern) ] 	] ensure: [ self library FcPatternDestroy: pattern ].	self initializeFromFont</body><body package="Xft">primUnLoadFont	self library XftFontClose: self xftDisplay with: xftFont</body><body package="Xft">reopenIfNecessary	" Ensure that the xftFont is active.	Aragon renderers cache composition scanners and thus refer to invalid XftFonts after snapshots "	self isAccessible 		ifFalse: 		[	screen := Screen default.			colors := nil.			self openFont		].</body><body package="Xft">unloadFont	| display visual colormap |	xftFont == nil 		ifFalse: 		[	self primUnLoadFont.			xftFont := nil		].	colors notNil 		ifTrue: 		[	display := self xftDisplay.			visual := self xftVisual.			colormap := self xftColormap.			colors do: [: xftColor | self library XftColorFree: display with: visual with: colormap with: xftColor ].			colors := nil		].</body></methods><methods><class-id>Xft.XftFont</class-id> <category>accessing</category><body package="Xft">screen	^ screen</body><body package="Xft">screen: aScreen	screen := aScreen</body></methods><methods><class-id>Xft.XftFont</class-id> <category>displaying</category><body package="Xft">displayByteIndexedString: string from: start to: stop at: aPoint on: aGraphicsContext 	self displayString: string from: start to: stop at: aPoint on: aGraphicsContext</body><body package="Xft">displayCharacter: aCharacter at: aPoint on: aGraphicsContext	" Draw a single character. This should be avoided, library calls have a significant overhead "	self		displayString: (String with: aCharacter)		from: 1		to: 1		at: aPoint		on: aGraphicsContext</body><body package="Xft">displayString: aString from: startIndex to: endIndex at: aPoint on: aGraphicsContext 	" The core display method. Creates a 'Draw' object (similar to a graphics context) and display the string "	| drawStructure substring position xftColor clippingRectangle |	clippingRectangle := aGraphicsContext clippingRectangleOrNil.	" check cases where everything is clipped "	( clippingRectangle notNil and: [ clippingRectangle width &lt;= 0 or: [ clippingRectangle height &lt;= 0 ]]) 		ifTrue: [ ^ self ].	self reopenIfNecessary.	drawStructure := aGraphicsContext 			xftCreateDrawStructureForDisplay: self xftDisplay			visual: self xftVisual			colormap: self xftColormap			library: self library.	drawStructure isNull 		ifTrue: [ self error: 'Could not create drawable' ].	[	xftColor := self xftColorForGraphicsContext: aGraphicsContext.		position := ( aPoint + aGraphicsContext translation ) rounded.		substring := ( startIndex = 1 and: [ endIndex = aString size ]) 				ifTrue: [ aString ]				ifFalse: [ aString copyFrom: startIndex to: endIndex ].		self 			setClipRectangle: clippingRectangle			ofDrawable: drawStructure			graphicsContext: aGraphicsContext			while: [ self displayString: substring at: position drawable: drawStructure xftColor: xftColor ]	] ensure: [ self library XftDrawDestroy: drawStructure ].</body><body package="Xft">displayTwoByteString: string from: start to: stop at: aPoint on: aGraphicsContext	self displayString: string from: start to: stop at: aPoint on: aGraphicsContext</body><body package="Xft">measureByteIndexedString: string from: start to: stop	"Measure a byte-indexed string from start..stop with the receiver"	| width |	width := 0.	start to: stop do: [:i | width := width + (self widthOf: (string at: i))].	^width @ self height</body><body package="Xft">measureTwoByteString: string from: start to: stop	"Measure a two-byte string from start..stop with the receiver"	| width |	width := 0.	start to: stop do: [:i | width := width + (self widthOf: (string at: i))].	^width @ self height</body><body package="Xft">primDisplayCharacterOfIndex: characterIndex at: aPoint on: aGraphicsContext	self displayCharacter: (Character value: characterIndex) at: aPoint on: aGraphicsContext</body><body package="Xft">primDisplayMappedString: aString from: startIndex to: endIndex at: aPoint withMap: map on: aGraphicsContext	self displayString: aString from: startIndex to: endIndex at: aPoint on: aGraphicsContext</body><body package="Xft">primDisplayTwoByteString: aString from: startIndex to: endIndex at: aPoint on: aGraphicsContext	self displayString: aString from: startIndex to: endIndex at: aPoint on: aGraphicsContext</body></methods><methods><class-id>Xft.XftFont</class-id> <category>testing</category><body package="Xft">hasGlyphForCharacter: aCharacter	" true if the font contains a glyph for the character "	^ self hasGlyphForCodepoint: aCharacter codePoint</body><body package="Xft">hasGlyphForCodepoint: anInteger	" true if the font contains a glyph for the character "	^ (self glyphTable at: anInteger + 1) == 1</body><body package="Xft">isAccessible	^ xftFont notNil and: [ xftFont isValid ]</body></methods><methods><class-id>Xft.XftFont</class-id> <category>installing</category><body package="Xft">installOn: aGraphicsContext	aGraphicsContext setXftFont:  self</body></methods><methods><class-id>Xft.XftFont</class-id> <category>displaying - private</category><body package="Xft">createClipRegionFor: aGraphicsContext rectangle: untranslatedRectangle 	" create a XRegion for clipping "	| point rectangle points numberOfPoints xpoints xpoint |	numberOfPoints := 4.	rectangle := untranslatedRectangle translatedBy: aGraphicsContext translation.	xpoints := self library XPoint gcMalloc: numberOfPoints.	points := Array with: rectangle topLeft with: rectangle topRight with: rectangle bottomRight with: rectangle bottomLeft.	1 to: numberOfPoints		do: 		[: i |			xpoint := xpoints + ( i - 1 ).			point := points at: i.			xpoint memberAt: #x put: point x.			xpoint memberAt: #y put: point y		].	^ self library XPolygonRegion: xpoints with: numberOfPoints with: self library EvenOddRule</body><body package="Xft">displayString: aString at: position drawable: drawable xftColor: xftColor 	" Draw the string "	| drawUnicode |	drawUnicode := true.	aString isCompatibleWithXftDrawString8 		ifTrue: 		[	" Try to avoid a unicode conversion. 			The library call might fail with a badArgumentsSignal if the string contains a character with codepoint 0 "			[	self library XftDrawString8: drawable with: xftColor with: xftFont with: position x with: position y with: aString with: aString size.				drawUnicode := false			] on: self library externalAccessFailedSignal do: [: ex | ]		].	drawUnicode 		ifTrue: 		[	aString isCompatibleWithXftDrawString16 				ifTrue: 				[	aString asFcChar16Do: 						[: fc16String |							self library XftDrawString16: drawable with: xftColor with: xftFont with: position x with: position y with: fc16String with: aString size						]				]				ifFalse: 				[	aString asFcChar32Do: 						[: fc32String |							self library XftDrawString32: drawable with: xftColor with: xftFont with: position x with: position y with: fc32String with: aString size						]				]		].</body><body package="Xft">setClipRectangle: aRecangleOrNil ofDrawable: aDrawable graphicsContext: aGraphicsContext while: aBlock 	" create &amp; enable a clip region for the drawable according to the graphics conext "	| clipRegion |	aRecangleOrNil notNil 		ifTrue: 		[	clipRegion := self createClipRegionFor: aGraphicsContext rectangle: aRecangleOrNil.			self library XftDrawSetClip: aDrawable with: clipRegion.			aBlock ensure: [ self library XDestroyRegion: clipRegion ]		]		ifFalse: [ aBlock value ].</body><body package="Xft">xftColorForGraphicsContext: aGraphicsContext 	" Returns a XftColor for the current paint of the graphics context "	| xftColor color visual colormap renderColor paint |	colors isNil 		ifTrue: [ colors := Dictionary new ].	" The RGB values of the paint are needed, so convert the paint to a ColorValue.	The conversion might be expensive, so cache the converted value "	paint := aGraphicsContext xftStaticPaint.	xftColor := colors at: paint ifAbsent: [ nil ].	xftColor isNil 		ifTrue: 		[	color := paint xftAsColorValueFor: aGraphicsContext.			visual := self xftVisual.			colormap := self xftColormap.			renderColor := self library XRenderColor gcMalloc.			renderColor memberAt: #red put: ( color red * 65535 ) rounded.			renderColor memberAt: #green put: ( color green * 65535 ) rounded.			renderColor memberAt: #blue put: ( color blue * 65535 ) rounded.			renderColor memberAt: #alpha put: 65535.			xftColor := self library XftColor gcMalloc.			self library XftColorAllocValue: self xftDisplay with: visual with: colormap with: renderColor with: xftColor.			colors at: paint put: xftColor		].	^ xftColor</body></methods><methods><class-id>Xft.XftFont</class-id> <category>composite fonts - private</category><body package="Xft">compositeFontDescriptions	" Returns a list of font descriptions to cover the Unicode charset range "	| result fontSet fontNames reducedFontDescriptions |	result := self library FcResult gcMalloc.	" Get all matching fonts. The first is the best match and should be the same font as this one "	fontSet := self library				FcFontSort: nil				with: self xftPattern				with: 1				with: nil				with: result.	^ [ | fontDescriptions |		fontNames := OrderedCollection new.		self class addFontNamesFromFontSet: fontSet to: fontNames.		fontDescriptions := fontNames collect: [: fontName | self class parse: fontName ].		reducedFontDescriptions := self reduceCompositeFontDescriptions: fontDescriptions.		" apply the style of this font to all fallbacks "		self fontDescription applyStyleToFontDescriptions: reducedFontDescriptions.		reducedFontDescriptions 	] ensure: [ self library FcFontSetDestroy: fontSet ]</body><body package="Xft">computeGlyphRanges	" build a collection of glyph ranges "	| charsetPointer result charset map nextPointer base mapSize bitSize ranges start end |	ranges := OrderedCollection new.	charsetPointer := self library PFcCharSet gcMalloc.	result := self library FcPatternGetCharSet: self xftPattern with: self library FC_CHARSET with: 0 with: charsetPointer.	result = 0 		ifFalse: [ ^ nil ].	charset := charsetPointer contents.	mapSize := self library FC_CHARSET_MAP_SIZE.	map := self library FcChar32 gcMalloc: mapSize.	nextPointer := self library FcChar32 gcMalloc.	base := self library FcCharSetFirstPage: charset with: map with: nextPointer.	bitSize := self library FcChar32 sizeof * 8.	start := nil.	end := nil.	[ base &lt; 65536 ] whileTrue: 		[	0 to: mapSize - 1				do: 				[: mapIndex | | bits glyphOffset |					bits := map at: mapIndex.					glyphOffset := base + ( mapIndex * bitSize ).					( start ~~ nil and: [ end + 1 ~= glyphOffset ]) 						ifTrue: 						[	ranges add: ( start to: ( end min: 65535 )).							start := nil						].					0 to: bitSize - 1						do: 						[: bitIndex | ( bits bitAt: bitIndex + 1 ) &gt; 0 								ifTrue: 								[	start == nil 										ifTrue: [ start := glyphOffset + bitIndex ].									end := glyphOffset + bitIndex								]								ifFalse: 								[	start ~~ nil 										ifTrue: 										[	ranges add: ( start to: ( end min: 65535 )).											start := nil										]								]						]				].			base := self library FcCharSetNextPage: charset with: map with: nextPointer		].	^ ranges</body><body package="Xft">computeGlyphTable	" build a table with 0 = no glyph, 1 = glyph "	| glyphs |	glyphs := ByteArray new: 65536.	self glyphRanges do: [: range | range first to: (range last min: 65535) do: [: i | glyphs at: i + 1 put: 1 ]].	^ glyphs</body><body package="Xft">glyphCacheKey	" All fonts with the same key should contain the same glyphs "	^ self fontDescription glyphCacheKey</body><body package="Xft">glyphRanges	GlyphRanges isNil		ifTrue: [ GlyphRanges := Dictionary new ].	^ GlyphRanges at: self glyphCacheKey ifAbsentPut: [ self computeGlyphRanges ]</body><body package="Xft">glyphTable	GlyphTables isNil		ifTrue: [ GlyphTables := Dictionary new ].	^ GlyphTables at: self glyphCacheKey ifAbsentPut: [ self computeGlyphTable ]</body><body package="Xft">reduceCompositeFontDescriptions: fontDescriptions	" Choose the best font per family "	| seenFamilies reducedFontDescriptions |	seenFamilies := Set new.	reducedFontDescriptions := OrderedCollection new: fontDescriptions size.	fontDescriptions do: 		[: each |			(seenFamilies includes: each family)				ifFalse: 				[	seenFamilies add: each family.					reducedFontDescriptions add: each  				] 		].	^ reducedFontDescriptions</body></methods><methods><class-id>Xft.XftFont</class-id> <category>printing</category><body package="Xft">printOn: aStream	super printOn: aStream.	self name notNil		ifTrue: 		[	aStream				nextPutAll: '(';				nextPutAll: self name;				nextPutAll: ')' 		]</body></methods><methods><class-id>Xft.XftFont</class-id> <category>handles - private</category><body package="Xft">xftColormap	^ self library XDefaultColormap: self xftDisplay with: self xftScreen.</body><body package="Xft">xftDisplay	^ self screen xftDisplay</body><body package="Xft">xftPattern	self reopenIfNecessary.	^ xftFont memberAt: #pattern</body><body package="Xft">xftScreen	^ self screen xftScreen</body><body package="Xft">xftVisual	^ self library XDefaultVisual: self xftDisplay with: self xftScreen</body></methods><methods><class-id>Xft.XftFont</class-id> <category>initialize-release</category><body package="Xft">releaseHandle	super releaseHandle.	xftFont := nil.	colors := nil.</body></methods><methods><class-id>Xft.XftFont class</class-id> <category>private</category><body package="Xft">addCommonFontPatternsFor: aGraphicsDevice to: fontNames	" Add common font patterns. Let Xft find a suitable match "	self commonFamilyNames do: 		[: family |			fontNames add: family , ':style=Bold Italic:slant=100:weight=200:scalable=True'.			fontNames add: family , ':style=Bold:slant=0:weight=200:scalable=True'.			fontNames add: family , ':style=Italic:slant=100:weight=80:scalable=True'.			fontNames add: family , ':style=Regular:slant=0:weight=80:scalable=True' 		]</body><body package="Xft">commonFamilyNames	^ #('Sans' 'Serif' 'Sans Serif' 'Helv' 'Monospace')</body><body package="Xft">createCompositeFont: bestMatch toResemble: aFontDescription for: fontPolicy	" Let fontconfig find suitable fonts "	| bestFont device |	device := fontPolicy graphicsDevice.	bestFont := self				createDeviceFont: bestMatch				toResemble: aFontDescription				on: device.	^  UnicodeCompositeFont font: bestFont requestedFontDescription: aFontDescription device: device</body><body package="Xft">defaultFontDescriptionIn: fontPolicy	^ (FontDescription new)		family: #('FreeSans' 'Sans' 'Serif' '*');		encodings: Locale current preferredEncodings;		italic: false;		fixedWidth: false</body><body package="Xft">flushCaches		GlyphTables := nil.	GlyphRanges := nil.</body><body package="Xft">parse: aName	" create a FontDescription from the pattern string "	| pattern |	pattern := FontPattern createFromString: aName.	^ pattern createFontDescription</body><body package="Xft">platformName	^'X11'</body><body package="Xft">queryAndAddFontNamesFor: aGraphicsDevice to: fontNames	" Get all known Xft fonts "	| fontSet |	fontSet := self listFontPatternsFor: aGraphicsDevice.	[ self addFontNamesFromFontSet: fontSet to: fontNames ] ensure: [ Xft.LibXft current FcFontSetDestroy: fontSet ]</body></methods><methods><class-id>Xft.XftFont class</class-id> <category>accessing</category><body package="Xft">listFontNamesAsOneChunk	^ true</body><body package="Xft">listFontNamesFor: aGraphicsDevice	" self listFontNamesFor: Screen default "	| fontNames |	fontNames := OrderedCollection new.	self queryAndAddFontNamesFor: aGraphicsDevice to: fontNames.	self addCommonFontPatternsFor: aGraphicsDevice to: fontNames.	^ fontNames</body><body package="Xft">pointToPixelSizeFactor	| dpi |	" 'Screen default resolution' currently returns 75@75, which is hardly useful "	dpi := self settings dpi ifNil: [ 96 ].	^ dpi / 72</body></methods><methods><class-id>Xft.XftFont class</class-id> <category>utilities</category><body package="Xft">boldnessForWeight: weight	| regular bold |	regular := LibXft current FC_WEIGHT_REGULAR.	bold := LibXft current FC_WEIGHT_BOLD.	^ (((weight max: regular) min: bold) - regular)  * 0.2 / (bold - regular) + 0.5</body><body package="Xft">createDeviceFont: matchedFontDescription toResemble: requestedFontDescription on: aScreen	"Based on a requested font, and the concrete font that best matches it, 	create an instance of the receiver, which can be used in rendering 	operations on the given GraphicsDevice"	| fontDescription encoding |	" create a copy so we can modify it "	fontDescription := matchedFontDescription copy.	requestedFontDescription specifiesPixelSize		ifTrue: 		[	fontDescription				pixelSize: requestedFontDescription pixelSize				pointSize: requestedFontDescription pointSize 		].	encoding := self encoderNamed: self defaultEncodingName.	^ aScreen		externalFontNamed: fontDescription xftFontPatternString		fromClass: self		encoding: encoding		description: fontDescription</body><body package="Xft">createFont: matchedFontDescription toResemble: requestedFontDescription on: aGraphicsDevice	" create a composite font for better glyph support "	^ self createCompositeFont: matchedFontDescription toResemble: requestedFontDescription for: aGraphicsDevice defaultFontPolicy</body><body package="Xft">defaultEncodingName	^ UnicodeCharacterEncoder new name</body><body package="Xft">preferredFontSizeReferringTo: aFontPolicy	^ self preferredFontPixelSize</body><body package="Xft">weightForBoldness: boldness	| regular bold |	regular := LibXft current FC_WEIGHT_REGULAR.	bold := LibXft current FC_WEIGHT_BOLD.	^ ((((boldness - 0.5) max: 0) min: 0.2) * 5 * (bold  - regular)) rounded + regular</body></methods><methods><class-id>Xft.XftFont class</class-id> <category>settings</category><body package="Xft">defaultFontPointSize	^ 10</body><body package="Xft">preferredFontPixelSize	| pointSize |	pointSize := (self settings ifNotNil: [: settings | settings preferredFontPointSize  ]) ifNil: [ self defaultFontPointSize ].	^ pointSize * self pointToPixelSizeFactor</body><body package="Xft">settings	" optional XftSettings "	^ XftSettings current</body></methods><methods><class-id>Xft.XftFont class</class-id> <category>signal constants</category><body package="Xft">errorSignal	^ XftError</body></methods><methods><class-id>Xft.XftFont class</class-id> <category>parsing - private</category><body package="Xft">addFontNamesFromFontSet: aXftFontSet to: fontNames	" Get all known Xft fonts "	| lib |	lib := Xft.LibXft current.	0 to: (aXftFontSet memberAt: #nfont) - 1		do: 		[: i | | fontPattern fontName fcName |			fontPattern := (aXftFontSet memberAt: #fonts) at: i.			fcName := lib FcNameUnparse: fontPattern.			fontName := fcName copyCStringFromHeap: #utf8.			lib FcStrFree: fcName.			fontName notEmpty ifTrue: [ fontNames add: fontName ].		].</body><body package="Xft">listFontPatternsFor: aGraphicsDevice 	" Query all relevant properties of all available fonts "	| arguments lib pattern objectSet |	lib := LibXft current.	pattern := lib FcPatternCreate.	^ [	arguments := OrderedCollection new.		arguments add: lib XFT_FAMILY.		arguments add: lib FC_FAMILYLANG.		arguments add: lib XFT_SLANT.		arguments add: lib XFT_SPACING.		arguments add: lib XFT_WEIGHT.		arguments add: lib XFT_FOUNDRY.		arguments add: lib FC_FULLNAMELANG.		arguments add: lib FC_FULLNAME.		arguments add: 0.		objectSet := lib FcObjectSetBuild: arguments asArray.		[ lib FcFontList: nil with: pattern with: objectSet ] ensure: [ lib FcObjectSetDestroy: objectSet ]	] ensure: [ lib FcPatternDestroy: pattern ]</body></methods><methods><class-id>Xft.XftSystem</class-id> <category>default actions</category><body package="Xft">pauseAction	super pauseAction.	LibXft flushCurrent.</body><body package="Xft">prerequisiteSystems	^ Array with: BasicGraphicsSystem</body><body package="Xft">setUp	WindowingSystem canActivate		ifTrue: [ Screen default defaultFontPolicy flushFonts ].	FontPattern initialize.	LibXft flushCurrent.	XftSettings flushCurrent.	XftFont flushCaches</body></methods><methods><class-id>Xft.XftSettings</class-id> <category>accessing - appearance</category><body package="Xft">antialias	^ antialias</body><body package="Xft">antialias: aBooleanOrNil	" true if antialiasing should be enabled.	nil if the default settings should be used "	antialias := aBooleanOrNil</body><body package="Xft">dpi	^ dpi</body><body package="Xft">dpi: anIntegerOrNil 	dpi := ( anIntegerOrNil notNil and: [ anIntegerOrNil &gt; 0 ]) 			ifTrue: [ anIntegerOrNil ]			ifFalse: [ nil ].</body><body package="Xft">hintStyle	^ hintStyle</body><body package="Xft">hintStyle: aSymbolOrNil	 " one of the hinting styles (e.g. #FC_HINT_NONE) 	nil if the default settings should be used "	hintStyle := aSymbolOrNil</body><body package="Xft">lcdFilter	^ lcdFilter</body><body package="Xft">lcdFilter: aSymbol		" one of the LCD filters (e.g. #FC_LCD_DEFAULT) 	nil if the default settings should be used "	lcdFilter := aSymbol</body><body package="Xft">subPixelRendering	^ subPixelRendering</body><body package="Xft">subPixelRendering: aSymbolOrNil	" one of the subpixel rendering styles (e.g. #FC_RGBA_RGB) 	nil if the default settings should be used "	subPixelRendering := aSymbolOrNil</body></methods><methods><class-id>Xft.XftSettings</class-id> <category>accessing - fonts</category><body package="Xft">preferredFontDescription	^ preferredFontDescription</body><body package="Xft">preferredFontDescription: aFontDescription	preferredFontDescription := aFontDescription</body><body package="Xft">preferredFontPointSize	" Returns the preferred font size in points, or nil "	^ preferredFontPointSize</body><body package="Xft">preferredFontPointSize: anIntegerOrNil 	" The preferred font size in points, or nil "	preferredFontPointSize := ( anIntegerOrNil notNil and: [ anIntegerOrNil &gt; 0 ]) 			ifTrue: [ anIntegerOrNil ]			ifFalse: [ nil ].</body></methods><methods><class-id>Xft.XftSettings</class-id> <category>patterns</category><body package="Xft">appyToPattern: aFcPattern	" apply appearance settings to the pattern "	| lib |	lib := LibXft current.	self antialias notNil		ifTrue: [			lib FcPatternDel: aFcPattern with: lib FC_ANTIALIAS .			lib FcPatternAddBool: aFcPattern with: lib FC_ANTIALIAS  with:  self antialias coerceToCInteger.		].	self hintStyle notNil		ifTrue: [			lib FcPatternDel: aFcPattern with: lib FC_HINTING .			lib FcPatternAddBool: aFcPattern with: lib FC_HINTING  with:  1.			lib FcPatternDel: aFcPattern with: lib FC_HINT_STYLE .			lib FcPatternAddInteger: aFcPattern with: lib FC_HINT_STYLE  with:  (lib perform: self hintStyle)		].	self subPixelRendering notNil		ifTrue: [			lib FcPatternDel: aFcPattern with: lib FC_RGBA .			lib FcPatternAddInteger: aFcPattern with: lib FC_RGBA  with:  (lib perform: self subPixelRendering)		].	self lcdFilter notNil		ifTrue: [			lib FcPatternDel: aFcPattern with: lib FC_LCD_FILTER .			lib FcPatternAddInteger: aFcPattern with: lib FC_LCD_FILTER  with:  (lib perform: self lcdFilter)		].</body></methods><methods><class-id>Xft.XftSettings class</class-id> <category>accessing</category><body package="Xft">current	current isNil ifTrue: [ current := self new ].	^ current</body><body package="Xft">current: aXftSettings	current := aXftSettings</body></methods><methods><class-id>Xft.XftSettings class</class-id> <category>initialize-release</category><body package="Xft">flushCurrent	current := nil</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>accessing</category><body package="Xft">fontPattern	^ fontPattern</body><body package="Xft">fontPattern: anObject	fontPattern := anObject</body><body package="Xft">pointSize	^ pointSize</body><body package="Xft">preferredFullName	^ self fontPattern preferredFullName</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>extended</category><body package="Xft">extend: aSymbol with: anObject	" similar to FontDescription&gt;&gt;extend:with:, except that an instance of a lightweight subclass of this class is created "	| instVars |	instVars := (self shallowCopy changeClassTo: Array)				copyWith: (Dictionary with: aSymbol -&gt; anObject).	self become: (instVars changeClassTo: self class extendedFontPatternDescriptionClass)</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>copying</category><body package="Xft">postCopy	super postCopy.	fontPattern notNil ifTrue: [ fontPattern := fontPattern copy ].</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>printing</category><body package="Xft">printOn: aStream	super printOn: aStream.	self fontPattern notNil		ifTrue: 		[	aStream				nextPutAll: '(';				nextPutAll: self fontPattern patternString;				nextPutAll: ')' 		]</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>private</category><body package="Xft">glyphCacheKey	" returns a value suitable for caching glyph information "	^ self fontPattern glyphCacheKey</body><body package="Xft">xftFontPatternString	" A pattern string that can be parsed by Xft "	| pixelSizePattern |	" create an updated pattern that knows about the font size "	pixelSizePattern := self fontPattern copy.	pixelSizePattern pixelSize: self pixelSize.	pixelSizePattern pointSize: self pointSize.	^ pixelSizePattern patternString</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>comparing</category><body package="Xft">= aFontDescription	^ super = aFontDescription 		and: [ self pointSize = aFontDescription pointSize		and: [ self preferredFullName = aFontDescription  preferredFullName ]]</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>modifying</category><body package="Xft">boldness: bold 	super boldness: bold.	self fontPattern weight: ( XftFont weightForBoldness: bold ).</body><body package="Xft">family: aFamilyName	| familyNames |	super family: aFamilyName.	familyNames := aFamilyName isCharacters ifTrue: [ Array with: aFamilyName ] ifFalse: [ aFamilyName ].	self fontPattern family: familyNames</body><body package="Xft">fixedWidth: isFixedWidth	super fixedWidth: isFixedWidth.	self fontPattern spacing: (isFixedWidth ifTrue: [ LibXft current XFT_MONO  ] ifFalse: [ LibXft current XFT_PROPORTIONAL ])</body><body package="Xft">italic: isItalic	super italic: isItalic.	self fontPattern slant: (isItalic ifTrue: [ LibXft current FC_SLANT_ITALIC ] ifFalse: [ LibXft current FC_SLANT_ROMAN ]).</body><body package="Xft">manufacturer: aVendorName	super manufacturer: aVendorName.	self fontPattern foundry: aVendorName</body><body package="Xft">pixelSize: aPixelSize	| size |	size := self asCompatibleNumber: aPixelSize.	super pixelSize: size.	size notNil		ifTrue: 		[	" a specific pixel size was requested, so reset the point size "			pointSize := nil 		].	self fontPattern pixelSize: size</body><body package="Xft">pixelSize: aPixelSize pointSize: aPointSize 	pixelSize := self asCompatibleNumber: aPixelSize.	pointSize := self asCompatibleNumber: aPointSize.	self fontPattern 		pixelSize: self pixelSize;		pointSize: self pointSize.</body></methods><methods><class-id>Xft.FontPatternDescription</class-id> <category>private and ugly</category><body package="Xft">applyStyleToFontDescriptions: fontDescriptions	" Apply styles that can be applied to any font "	| slant italic weight boldness |	slant := self fontPattern slant.	italic := self italic.	weight := self fontPattern weight.	boldness := self boldness.	fontDescriptions do: [ : fontDescription |		fontDescription italic: italic; boldness: boldness.		fontDescription fontPattern slant: slant; weight: weight .	].</body><body package="Xft">asCompatibleNumber: aNumber	^(aNumber isNil or: [aNumber isInteger])		ifTrue: [aNumber]		ifFalse: [aNumber asFloat]</body></methods><methods><class-id>Xft.FontPatternDescription class</class-id> <category>instance creation</category><body package="Xft">fontPattern: aFontPattern	^ (self new)		fontPattern: aFontPattern;		yourself</body></methods><methods><class-id>Xft.FontPatternDescription class</class-id> <category>private</category><body package="Xft">createExtendedFontPatternDescriptionClass	" create a copy of ExtendedFontDescription that is a subclass of me "	^ #{ExtendedFontDescription} 		ifDefinedDo: 		[: originalExtendedFontDescriptionClass |			| extendedClass extendedFormat |			extendedClass := originalExtendedFontDescriptionClass copy.			extendedClass superclass: self.			extendedFormat := self format + originalExtendedFontDescriptionClass instSize - FontDescription instSize.			extendedClass setInstanceFormat: extendedFormat.			extendedClass rebindAllMethods: originalExtendedFontDescriptionClass allInstVarNames.			extendedClass		]		elseDo: [ self error: 'Package ExtraEmphasis is not loaded' ]</body><body package="Xft">extendedFontPatternDescriptionClass	" returns a copy of ExtendedFontDescription that is a subclass of me "	ExtendedFontPatternDescriptionClass isNil		ifTrue: [ ExtendedFontPatternDescriptionClass := self createExtendedFontPatternDescriptionClass ].	^ ExtendedFontPatternDescriptionClass</body></methods><methods><class-id>Core.WordArray</class-id> <category>converting</category><body package="Xft">asFcChar16Do: aBlock	aBlock value: self</body></methods><methods><class-id>Core.WordArray</class-id> <category>testing</category><body package="Xft">isCompatibleWithXftDrawString16	^ true</body><body package="Xft">isCompatibleWithXftDrawString8	^ false</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Xft">asFcChar16Do: aBlock 	| bytes |	bytes := self asByteArrayEncoding: #'UCS-2'.	aBlock value: bytes</body><body package="Xft">asFcChar32Do: aBlock	| bytes offset |	bytes := UninterpretedBytes new: self size * 4.	offset := 1.	self do: [ : char | 		bytes unsignedLongAt: offset put: char codePoint.		offset := offset + 4.	].	aBlock value: bytes</body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="Xft">isCompatibleWithXftDrawString16	^ true</body><body package="Xft">isCompatibleWithXftDrawString8	^ false</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Xft">xftTrimWhitespace	"Return a copy of the receiver that has leading and trailing whitespaces removed."	| size index whitespaces |	whitespaces := #(9 10 13 32).	(size := self size) == 0 ifTrue:		[^self species new: 0].	index := 1.	[whitespaces includes: (self at: index) codePoint ] whileTrue:		[index == size ifTrue:			[^self species new: 0].		 index := index + 1].	[whitespaces includes:  (self at: size) codePoint] whileTrue:		[index == size ifTrue:			[^self species new: 0].		 size := size - 1].	^self copyFrom: index to: size</body></methods><methods><class-id>Graphics.HostGraphicsDevice</class-id> <category>private - allocating resources</category><body package="Xft">externalFontNamed: aName fromClass: fontClass encoding: encoding description: fontDescription	" like #fontNamed:fromClass:encoding:, except that the font is not managed by theVM "	| font nameKey |	nameKey := aName asSymbol.	font := openFonts at: nameKey ifAbsent: [  ].	font == nil		ifFalse: [ ^ font ].	font := fontClass new.	font name: aName.	font setEncoder: encoding.	font screen: self.	font setDescription: fontDescription.	font openFont.	openFonts at: nameKey put: font.	^ font</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>private-initialize-release</category><body package="Xft">setXftFont: anXftFont	" Hook for integrating Xft fonts "</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>accessing</category><body package="Xft">xftCreateDrawStructureForDisplay: display visual: visual colormap: colormap library: xftLibrary 	" Create a XftDraw structure "	^ self medium xftCreateDrawStructureForDisplay: display visual: visual colormap: colormap library: xftLibrary</body><body package="Xft">xftDisplay	" Returns the Display associated with this medium "	^ self medium xftDisplay</body><body package="Xft">xftDrawable	" Returns the Drawable associated with this medium "	^ self medium xftDrawable</body><body package="Xft">xftStaticPaint	" Returns a paint that can be cached "	| deviceColor |	deviceColor := devicePaint isInteger				ifTrue: [ medium palette at: devicePaint abs ifAbsent: [ nil ] ]				ifFalse: [ nil ].	^ deviceColor notNil		ifTrue: [ deviceColor xftAsStaticPaintFor: self ]		ifFalse: [ paint xftAsStaticPaintFor: self ]</body></methods><methods><class-id>Graphics.Screen</class-id> <category>accessing</category><body package="Xft">xftDisplay	^ self key</body><body package="Xft">xftScreen	^ 0</body></methods><methods><class-id>Core.ByteEncodedString</class-id> <category>testing</category><body package="Xft">isCompatibleWithXftDrawString8	^ true</body></methods><methods><class-id>Graphics.Window</class-id> <category>accessing</category><body package="Xft">xftDisplay	^ self graphicsDevice key.</body><body package="Xft">xftDrawable	^ self key</body></methods><methods><class-id>Graphics.Paint</class-id> <category>converting</category><body package="Xft">xftAsColorValueFor: aGraphicsContext	" Returns a ColorValue"	^ aGraphicsContext colorValueForPaint: self</body><body package="Xft">xftAsStaticPaintFor: aGraphicsContext	" Returns a paint that can be cached "	^ self</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Xft">xftAsColorValueFor: aGraphicsContext	^ self</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>private</category><body package="Xft">applyStyleToFontDescriptions: fontDescriptions	" Apply styles that can be applied to any font "</body><body package="Xft">glyphCacheKey	" returns a value suitable for caching glyph information "	^ self</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="Xft">pixelSize: aPixelSize pointSize: aPointSize	" Set pixel and point size, if possible "	self pixelSize: aPixelSize</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="Xft">pointSize	" Answer the point size of the font "	^ nil</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>private</category><body package="Xft">xftFontPatternString	" Returns a fontconfig font pattern string "	| pattern slant |	pattern := String new writeStream.	( self family notNil and: [ self family notEmpty ]) 		ifTrue: 		[	self family isCharacters 				ifTrue: [ pattern nextPutAll: self family ]				ifFalse: [ pattern nextPutAll: self family first ]		]		ifFalse: [ pattern nextPutAll: '*' ].	self xftPixelSize ifNotNil: [: pxSize | pattern nextPutAll: ':pixelsize='; print: pxSize ].	( self manufacturer notNil and: [ self manufacturer notEmpty ]) 		ifTrue: 		[	pattern nextPutAll: ':foundry='.			self manufacturer isCharacters 				ifTrue: [ pattern nextPutAll: self manufacturer ]				ifFalse: [ pattern nextPutAll: self manufacturer first ]		].	pattern nextPutAll: ':weight='; print: ( Xft.XftFont weightForBoldness: self boldness ).	slant := self italic 			ifTrue: [ Xft.LibXft current XFT_SLANT_ITALIC ]			ifFalse: [ Xft.LibXft current XFT_SLANT_ROMAN ].	pattern nextPutAll: ':slant='; print: slant.	self fixedWidth 		ifTrue: [ pattern nextPutAll: ':spacing='; print: Xft.LibXft current XFT_MONO ].	^ pattern contents</body><body package="Xft">xftPixelSize	| screenDPI xftDPI |	^ ( self specifiesPixelSize and: [ self pixelSize &gt; 0 ]) 		ifTrue: 		[	" fallback values might be required for early initialization of the default screen font "			screenDPI := Screen default resolution ifNotNil: [: resolution | resolution x ] ifNil: [ 75 ].			xftDPI := Xft.XftSettings current dpi ifNil: [ 96 ].			( self pixelSize * screenDPI / xftDPI ) rounded		]		ifFalse: [ self pixelSize ]</body><body package="Xft">xftSetFamily: aFamilyString	family := aFamilyString</body></methods><methods><class-id>Core.FourByteString</class-id> <category>testing</category><body package="Xft">isCompatibleWithXftDrawString16	^ false</body></methods><methods><class-id>Graphics.GraphicsMedium</class-id> <category>accessing</category><body package="Xft">xftCreateDrawStructureForDisplay: display visual: visual colormap: colormap library: xftLibrary	" Create a XftDraw structure "	^xftLibrary		XftDrawCreate: display		with: self xftDrawable		with: visual		with: colormap</body><body package="Xft">xftDisplay	" Returns the Display associated with this medium "	self error: 'Cannot access the X11 Display for ', self printString</body><body package="Xft">xftDrawable	" Returns the Drawable associated with this medium "	self error: 'Cannot access the X11 Drawable for ', self printString</body></methods><methods><class-id>Graphics.CoverageValue</class-id> <category>converting</category><body package="Xft">xftAsColorValueFor: aGraphicsContext	" the actual color value does not matter here "	^ ColorValue black</body></methods><methods><class-id>Graphics.SymbolicPaint</class-id> <category>converting</category><body package="Xft">xftAsColorValueFor: aGraphicsContext	^ (aGraphicsContext paintPreferencesMatchAt: self) xftAsColorValueFor: aGraphicsContext</body><body package="Xft">xftAsStaticPaintFor: aGraphicsContext	^ (aGraphicsContext paintPreferencesMatchAt: self) xftAsStaticPaintFor: aGraphicsContext</body></methods><methods><class-id>Graphics.UnmappableSurface</class-id> <category>accessing</category><body package="Xft">xftDisplay	" see x11Surface.h "	^ ObjectMemory is64Bit		ifTrue: [ handle unsignedLongLongAt: 17 ]		ifFalse: [ handle unsignedLongAt: 9]</body><body package="Xft">xftDrawable	" see x11Surface.h "	^ ObjectMemory is64Bit		ifTrue: [ handle unsignedLongLongAt: 1 ]		ifFalse: [ handle unsignedLongAt: 1]</body></methods><methods><class-id>Graphics.Mask</class-id> <category>accessing</category><body package="Xft">xftCreateDrawStructureForDisplay: display visual: visual colormap: colormap library: xftLibrary	" Create a bitmap "	^xftLibrary		XftDrawCreateBitmap: display		with: self xftDrawable</body></methods><initialize><class-id>Xft.FontPattern</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GraphicsMedium</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>UnmappableSurface</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Mask</name><environment>Graphics</environment><super>Graphics.UnmappableSurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>WordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>HostGraphicsDevice</name><environment>Graphics</environment><super>Graphics.GraphicsDevice</super><private>false</private><indexed-type>none</indexed-type><inst-vars>colorDepth colorBitsPerPixel coverageDepth coverageBitsPerPixel openFonts platName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Screen</name><environment>Graphics</environment><super>Graphics.HostGraphicsDevice</super><private>false</private><indexed-type>none</indexed-type><inst-vars>boundingBox subRegions resolution rendererName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>CompositeFont</name><environment>Graphics</environment><super>Graphics.ImplementationFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ascent descent currentFont fonts priorityTable defaultScanner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>ScreenFont</name><environment>Graphics</environment><super>Graphics.DeviceFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle ascent descent widths name encoder defaultScanner fontDescription measurementCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>FontDescription</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name family manufacturer pixelSize flags masks color encoding encodings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>Paint</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>SymbolicPaint</name><environment>Graphics</environment><super>Graphics.Paint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key constantCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.SymbolicPaintConstants.*			</imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>GraphicsContext</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>medium clipOriginX clipOriginY clipWidth clipHeight lineWidth capStyle joinStyle deviceFont devicePaint offsetX offsetY phaseX phaseY scaleX scaleY font paint paintPolicy fontPolicy clientData paintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>WindowingSystem</name><environment>Graphics</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>ByteEncodedString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars>encoder </class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>FourByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>CoverageValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>coverage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class></st-source>