<?xml version="1.0"?><st-source><!-- Name: Method Wrapper ExamplesNotice: Copyright 1994 - 2013 John Brant, Niall RossThis utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: John's basic examples plus my ConditionalMethodWrapper.DbIdentifier: bear73DbTrace: 486183DbUsername: nrossDbVersion: 1.5DevelopmentPrerequisites: #(#(#any 'Method Wrapper Base' ''))PackageName: Method Wrapper ExamplesParcel: #('Method Wrapper Examples')ParcelName: Method Wrapper ExamplesPrerequisiteParcels: #(#('Method Wrapper Base' ''))PrintStringCache: (1.5,nross)Version: 1.5Date: 1:46:57 PM June 17, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.3) of June 17, 2016 on June 17, 2016 at 1:46:57 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ConditionalMethodWrapper</name><environment>Refactory.Wrappers</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>alternative condition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Examples</package></attributes></class><comment><class-id>Refactory.Wrappers.ConditionalMethodWrapper</class-id><body>If the condition is met, return the result of running the wrapped method.  If the condition is not met, return the result of running the alternative block (only:  do not run any before and after methods as all required behaviour can be included in the alternative block and this helps logging of was-run, was-not-run).Usually, this does not set before and after blocks.  If they are set, they are run if the condition is met, i.e. before and after the wrapped method, and are not run if the condition fails and the alternative is executed.  (If desired, the alternative can call them.)Instance Variables:	alternative	&lt;BlockClosure&gt;	execute this block, not the wrapped method (and not any before and after block)	condition	&lt;BlockClosure&gt;	execute the wrapped method, plus any before and after blockBoth instvars hold two-arg blocks:  the args are the receiver of the wrapped method and the arguments provided in the call of it.</body></comment><class><name>CalledMethodWrapper</name><environment>Refactory.Wrappers</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>isCalled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Examples</package></attributes></class><comment><class-id>Refactory.Wrappers.CalledMethodWrapper</class-id><body>CalledMethodWrapper is a special method wrapper that uninstalls itself once it has been called. Although this is initially slower than the CountMethodWrapper, it will speed up to be the same speed as the unwrapped code.Instance Variables:isCalled	&lt;Boolean&gt;	has this method been calledClass Variables:Installing	&lt;Boolean&gt;	are we installing the wrappers. During installation, some of the methods might be called, but we shouldn't tag them as being called, since it results from the installation process, not normal code execution.</body></comment><class><name>TimeMethodWrapper</name><environment>Refactory.Wrappers</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>time count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Examples</package></attributes></class><comment><class-id>Refactory.Wrappers.TimeMethodWrapper</class-id><body>TimeMethodWrapper counts the number of times the method has been called, along with the total execution time this method has taken.Instance Variables:count	&lt;Integer&gt;	number of times calledtime	&lt;Integer&gt;	total time in milliseconds spent executing the method</body></comment><class><name>CountMethodWrapper</name><environment>Refactory.Wrappers</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Examples</package></attributes></class><comment><class-id>Refactory.Wrappers.CountMethodWrapper</class-id><body>CountMethodWrapper counts the number of times the method is called.Instance Variables:count	&lt;Integer&gt;	number of times this method has been called</body></comment><shared-variable><name>Installing</name><environment>Refactory.Wrappers.CalledMethodWrapper</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>Method Wrapper Examples</package></attributes></shared-variable><methods><class-id>Refactory.Wrappers.ConditionalMethodWrapper</class-id> <category>accessing</category><body package="Method Wrapper Examples">alternative: aTwoArgBlock	"Run the alternative instead of the wrapped method if the condition is not met."	alternative := aTwoArgBlock</body><body package="Method Wrapper Examples">class: aClass selector: aSelector	"By default, fail the condition and do nothing, i.e. just switch off the wrapped method and return its self (the receiver) as the most likely acceptable return."	super class: aClass selector: aSelector.	condition := [:receiver :arguments | false].	alternative := [:receiver :arguments | receiver]</body><body package="Method Wrapper Examples">condition: aTwoArgBoolBlock	"Run the wrapped method if the condition is met, the alternative otherwise."	condition := aTwoArgBoolBlock</body><body package="Method Wrapper Examples">valueWithReceiver: anObject arguments: anArrayOfObjects	"If the condition is met, return the result of running the wrapped method (also run any before and after method that may be defined in a subclass of me, e.g. to log that the operation did go ahead).  If the condition is not met, return the result of running the alternative block (only;  do not run any before and after methods as all required behaviour can be included in the alternative block and this helps logging of was-run, was-not-run)."	^(condition value: anObject value: anArrayOfObjects)		ifTrue: [super valueWithReceiver: anObject arguments: anArrayOfObjects]		ifFalse: [alternative value: anObject value: anArrayOfObjects]</body></methods><methods><class-id>Refactory.Wrappers.ConditionalMethodWrapper class</class-id> <category>instance creation</category><body package="Method Wrapper Examples">on: aCompiledMethod alternative: aTwoArgBlock	^(self on: aCompiledMethod)		alternative: aTwoArgBlock;		yourself</body><body package="Method Wrapper Examples">on: selector inClass: class alternative: aTwoArgBlock	^(self on: selector inClass: class)		alternative: aTwoArgBlock;		yourself</body></methods><methods><class-id>Refactory.Wrappers.CalledMethodWrapper</class-id> <category>evaluating</category><body package="Method Wrapper Examples">valueWithReceiver: anObject arguments: anArrayOfObjects 	(isCalled or: [Installing]) 		ifFalse: 			[isCalled := true.			self uninstall].	^clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects</body></methods><methods><class-id>Refactory.Wrappers.CalledMethodWrapper</class-id> <category>initialize-release</category><body package="Method Wrapper Examples">class: aClass selector: aSymbol 	isCalled := false.	^super class: aClass selector: aSymbol</body></methods><methods><class-id>Refactory.Wrappers.CalledMethodWrapper</class-id> <category>accessing</category><body package="Method Wrapper Examples">isCalled	^isCalled</body></methods><methods><class-id>Refactory.Wrappers.CalledMethodWrapper class</class-id> <category>class initialization</category><body package="Method Wrapper Examples">initialize	Installing := false.	super initialize</body></methods><methods><class-id>Refactory.Wrappers.CalledMethodWrapper class</class-id> <category>accessing</category><body package="Method Wrapper Examples">installing: aBoolean	Installing := aBoolean</body></methods><methods><class-id>Refactory.Wrappers.TimeMethodWrapper</class-id> <category>evaluating</category><body package="Method Wrapper Examples">valueWithReceiver: anObject arguments: argumentsArray 	"This method was overriden so that recursive calls will have a different beginTime."	| beginTime |	beginTime := Time millisecondClockValue.	count := count + 1.	^[clientMethod valueWithReceiver: anObject arguments: argumentsArray] 		ensure: [time := time + (Time millisecondClockValue - beginTime max: 0)]</body></methods><methods><class-id>Refactory.Wrappers.TimeMethodWrapper</class-id> <category>initialize-release</category><body package="Method Wrapper Examples">class: aClass selector: aSymbol 	time := 0.	count := 0.	^super class: aClass selector: aSymbol</body></methods><methods><class-id>Refactory.Wrappers.TimeMethodWrapper</class-id> <category>accessing</category><body package="Method Wrapper Examples">averageTime	^self count == 0 ifTrue: [0] ifFalse: [self totalTime / self count asFloat]</body><body package="Method Wrapper Examples">count	^count</body><body package="Method Wrapper Examples">totalTime	^time</body></methods><methods><class-id>Refactory.Wrappers.CountMethodWrapper</class-id> <category>evaluating</category><body package="Method Wrapper Examples">valueWithReceiver: anObject arguments: anArrayOfObjects 	count := count + 1.	^clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects</body></methods><methods><class-id>Refactory.Wrappers.CountMethodWrapper</class-id> <category>initialize-release</category><body package="Method Wrapper Examples">class: aClass selector: aSymbol 	count := 0.	^super class: aClass selector: aSymbol</body></methods><methods><class-id>Refactory.Wrappers.CountMethodWrapper</class-id> <category>accessing</category><body package="Method Wrapper Examples">count	^count</body></methods><initialize><class-id>Refactory.Wrappers.CalledMethodWrapper</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class></st-source>