<?xml version="1.0"?><st-source><!-- Name: Synchronization WrappersComment: SynchronizationWrappers synchronize method calls by wrapping them within #critical: calls.  The #critical: waits on a recursion lock that is shared between a group of methods.  In the set-up methods provided, the group is all the methods of a lightweight subclass of an object's class, specially generated to protect that object from concurrent access.DbIdentifier: psql_public_cst_2007DbTrace: 37014DevelopmentPrerequisites: #(#(#any 'Method Wrapper Base' ''))PackageName: Synchronization WrappersParcel: #('Synchronization Wrappers')PrerequisiteParcels: #(#('Method Wrapper Base' ''))PrintStringCache: (1.1,NiallRoss)Version: 1.1Date: 2:41:41 pm January 11, 2008 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.6 (jan08.1) of January 11, 2008 on January 11, 2008 at 2:41:41 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SynchronizationWrapper</name><environment>Refactory.Wrappers</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>recursionLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Synchronization Wrappers</package></attributes></class><comment><class-id>Refactory.Wrappers.SynchronizationWrapper</class-id><body>SynchronizationWrapper synchronizes method calls by using a recursion lock. The call to the original method is protected by the RecursionWrapper&gt;&gt;critical: method.Instance Variables:recursionLock	&lt;RecursionLock&gt;	the lock that is acquired when the method is called</body></comment><methods><class-id>Refactory.Wrappers.SynchronizationWrapper</class-id> <category>accessing</category><body package="Synchronization Wrappers" selector="lock:">lock: aRecursionLock 	recursionLock := aRecursionLock</body></methods><methods><class-id>Refactory.Wrappers.SynchronizationWrapper</class-id> <category>evaluating</category><body package="Synchronization Wrappers" selector="valueWithReceiver:arguments:">valueWithReceiver: object arguments: args 	^recursionLock		critical: [clientMethod valueWithReceiver: object arguments: args]</body></methods><methods><class-id>Refactory.Wrappers.SynchronizationWrapper class</class-id> <category>installation</category><body package="Synchronization Wrappers" selector="installOn:">installOn: aClass 	| recursionLock wrappers |	recursionLock := RecursionLock new.	wrappers := aClass selectors asOrderedCollection collect: [:each | (self on: each inClass: aClass)					lock: recursionLock; install; yourself].	^wrappers</body><body package="Synchronization Wrappers" selector="installOnObject:">installOnObject: anObject 	| newBehavior oldClass recursionLock |	oldClass := anObject class.	newBehavior := Behavior new.	newBehavior setInstanceFormat: oldClass format.	newBehavior superclass: oldClass.	newBehavior methodDictionary: MethodDictionary new.	recursionLock := RecursionLock new.	newBehavior allSelectors asOrderedCollection collect: [:each | (self on: each inClass: newBehavior)			lock: recursionLock; install; yourself].	newBehavior addSelector: #synchronize withMethod: (self class compiledMethodAt: #synchronize).	newBehavior addSelector: #unsynchronize withMethod: (self class compiledMethodAt: #unsynchronize).	anObject changeClassToThatOf: newBehavior basicNew</body><body package="Synchronization Wrappers" selector="uninstallOn:">uninstallOn: aClass 	aClass selectors		do: 			[:each | 			| method |			method := aClass compiledMethodAt: each.			(method isKindOf: MethodWrapper)				ifTrue: [method uninstall]]</body><body package="Synchronization Wrappers" selector="uninstallOnObject:">uninstallOnObject: anObject 	anObject changeClassToThatOf: anObject class superclass basicNew</body></methods><methods><class-id>Refactory.Wrappers.SynchronizationWrapper class</class-id> <category>private</category><body package="Synchronization Wrappers" selector="synchronize">synchronize</body><body package="Synchronization Wrappers" selector="unsynchronize">unsynchronize	SynchronizationWrapper uninstallOnObject: self</body></methods><methods><class-id>Refactory.Wrappers.SynchronizationWrapper class</class-id> <category>accessing</category><body package="Synchronization Wrappers" selector="canWrap:inClass:">canWrap: aSelector inClass: aClass 	"This could cause infinite recursion if wrapping classes."	^true</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Synchronization Wrappers" selector="synchronize">synchronize	Refactory.Wrappers.SynchronizationWrapper installOnObject: self</body><body package="Synchronization Wrappers" selector="unsynchronize">unsynchronize	^self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class></st-source>